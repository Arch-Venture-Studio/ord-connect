(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as React from "react";
import React__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useRef, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, useReducer, useSyncExternalStore, createRef } from "react";
import * as ReactDOM from "react-dom";
import { createPortal, flushSync } from "react-dom";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder, BrowserWalletRequestCancelledByUserError } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$3, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$4 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { signPsbt as signPsbt$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var z = queue.length; z; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < z; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, z = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var z = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var Y = 1; Y < arguments.length; Y++)
      z[Y - 1] = arguments[Y];
  queue.push(new Item(B, z)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, z) {
  this.fun = B, this.array = z;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
function getAugmentedNamespace(B) {
  if (B.__esModule) return B;
  var z = B.default;
  if (typeof z == "function") {
    var Y = function ne() {
      return this instanceof ne ? Reflect.construct(z, arguments, this.constructor) : z.apply(this, arguments);
    };
    Y.prototype = z.prototype;
  } else Y = {};
  return Object.defineProperty(Y, "__esModule", { value: !0 }), Object.keys(B).forEach(function(ne) {
    var ae = Object.getOwnPropertyDescriptor(B, ne);
    Object.defineProperty(Y, ne, ae.get ? ae : {
      enumerable: !0,
      get: function() {
        return B[ne];
      }
    });
  }), Y;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.fragment"), ne = Object.prototype.hasOwnProperty, ae = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ie = { key: !0, ref: !0, __self: !0, __source: !0 };
  function se(le, ve, ge) {
    var oe, Ee = {}, Ce = null, Pe = null;
    ge !== void 0 && (Ce = "" + ge), ve.key !== void 0 && (Ce = "" + ve.key), ve.ref !== void 0 && (Pe = ve.ref);
    for (oe in ve) ne.call(ve, oe) && !ie.hasOwnProperty(oe) && (Ee[oe] = ve[oe]);
    if (le && le.defaultProps) for (oe in ve = le.defaultProps, ve) Ee[oe] === void 0 && (Ee[oe] = ve[oe]);
    return { $$typeof: z, type: le, key: Ce, ref: Pe, props: Ee, _owner: ae.current };
  }
  return reactJsxRuntime_production_min.Fragment = Y, reactJsxRuntime_production_min.jsx = se, reactJsxRuntime_production_min.jsxs = se, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), ae = Symbol.for("react.strict_mode"), ie = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), le = Symbol.for("react.context"), ve = Symbol.for("react.forward_ref"), ge = Symbol.for("react.suspense"), oe = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), Ce = Symbol.for("react.lazy"), Pe = Symbol.for("react.offscreen"), Ve = Symbol.iterator, ht = "@@iterator";
    function vt(er) {
      if (er === null || typeof er != "object")
        return null;
      var br = Ve && er[Ve] || er[ht];
      return typeof br == "function" ? br : null;
    }
    var Pt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _t(er) {
      {
        for (var br = arguments.length, wr = new Array(br > 1 ? br - 1 : 0), Sr = 1; Sr < br; Sr++)
          wr[Sr - 1] = arguments[Sr];
        kt("error", er, wr);
      }
    }
    function kt(er, br, wr) {
      {
        var Sr = Pt.ReactDebugCurrentFrame, Or = Sr.getStackAddendum();
        Or !== "" && (br += "%s", wr = wr.concat([Or]));
        var Fr = wr.map(function(Ir) {
          return String(Ir);
        });
        Fr.unshift("Warning: " + br), Function.prototype.apply.call(console[er], console, Fr);
      }
    }
    var Ot = !1, Ht = !1, jt = !1, Yt = !1, Dt = !1, Ct;
    Ct = Symbol.for("react.module.reference");
    function Kt(er) {
      return !!(typeof er == "string" || typeof er == "function" || er === ne || er === ie || Dt || er === ae || er === ge || er === oe || Yt || er === Pe || Ot || Ht || jt || typeof er == "object" && er !== null && (er.$$typeof === Ce || er.$$typeof === Ee || er.$$typeof === se || er.$$typeof === le || er.$$typeof === ve || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      er.$$typeof === Ct || er.getModuleId !== void 0));
    }
    function Nt(er, br, wr) {
      var Sr = er.displayName;
      if (Sr)
        return Sr;
      var Or = br.displayName || br.name || "";
      return Or !== "" ? wr + "(" + Or + ")" : wr;
    }
    function Je(er) {
      return er.displayName || "Context";
    }
    function Xe(er) {
      if (er == null)
        return null;
      if (typeof er.tag == "number" && _t("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof er == "function")
        return er.displayName || er.name || null;
      if (typeof er == "string")
        return er;
      switch (er) {
        case ne:
          return "Fragment";
        case Y:
          return "Portal";
        case ie:
          return "Profiler";
        case ae:
          return "StrictMode";
        case ge:
          return "Suspense";
        case oe:
          return "SuspenseList";
      }
      if (typeof er == "object")
        switch (er.$$typeof) {
          case le:
            var br = er;
            return Je(br) + ".Consumer";
          case se:
            var wr = er;
            return Je(wr._context) + ".Provider";
          case ve:
            return Nt(er, er.render, "ForwardRef");
          case Ee:
            var Sr = er.displayName || null;
            return Sr !== null ? Sr : Xe(er.type) || "Memo";
          case Ce: {
            var Or = er, Fr = Or._payload, Ir = Or._init;
            try {
              return Xe(Ir(Fr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ke = Object.assign, Qe = 0, bt, wt, xt, Bt, $t, qt, Rt;
    function Lt() {
    }
    Lt.__reactDisabledLog = !0;
    function tr() {
      {
        if (Qe === 0) {
          bt = console.log, wt = console.info, xt = console.warn, Bt = console.error, $t = console.group, qt = console.groupCollapsed, Rt = console.groupEnd;
          var er = {
            configurable: !0,
            enumerable: !0,
            value: Lt,
            writable: !0
          };
          Object.defineProperties(console, {
            info: er,
            log: er,
            warn: er,
            error: er,
            group: er,
            groupCollapsed: er,
            groupEnd: er
          });
        }
        Qe++;
      }
    }
    function sr() {
      {
        if (Qe--, Qe === 0) {
          var er = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ke({}, er, {
              value: bt
            }),
            info: Ke({}, er, {
              value: wt
            }),
            warn: Ke({}, er, {
              value: xt
            }),
            error: Ke({}, er, {
              value: Bt
            }),
            group: Ke({}, er, {
              value: $t
            }),
            groupCollapsed: Ke({}, er, {
              value: qt
            }),
            groupEnd: Ke({}, er, {
              value: Rt
            })
          });
        }
        Qe < 0 && _t("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Zt = Pt.ReactCurrentDispatcher, Wt;
    function Gt(er, br, wr) {
      {
        if (Wt === void 0)
          try {
            throw Error();
          } catch (Or) {
            var Sr = Or.stack.trim().match(/\n( *(at )?)/);
            Wt = Sr && Sr[1] || "";
          }
        return `
` + Wt + er;
      }
    }
    var rr = !1, or;
    {
      var Xt = typeof WeakMap == "function" ? WeakMap : Map;
      or = new Xt();
    }
    function zt(er, br) {
      if (!er || rr)
        return "";
      {
        var wr = or.get(er);
        if (wr !== void 0)
          return wr;
      }
      var Sr;
      rr = !0;
      var Or = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Fr;
      Fr = Zt.current, Zt.current = null, tr();
      try {
        if (br) {
          var Ir = function() {
            throw Error();
          };
          if (Object.defineProperty(Ir.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ir, []);
            } catch (nn) {
              Sr = nn;
            }
            Reflect.construct(er, [], Ir);
          } else {
            try {
              Ir.call();
            } catch (nn) {
              Sr = nn;
            }
            er.call(Ir.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (nn) {
            Sr = nn;
          }
          er();
        }
      } catch (nn) {
        if (nn && Sr && typeof nn.stack == "string") {
          for (var Vr = nn.stack.split(`
`), tn = Sr.stack.split(`
`), Jr = Vr.length - 1, en = tn.length - 1; Jr >= 1 && en >= 0 && Vr[Jr] !== tn[en]; )
            en--;
          for (; Jr >= 1 && en >= 0; Jr--, en--)
            if (Vr[Jr] !== tn[en]) {
              if (Jr !== 1 || en !== 1)
                do
                  if (Jr--, en--, en < 0 || Vr[Jr] !== tn[en]) {
                    var an = `
` + Vr[Jr].replace(" at new ", " at ");
                    return er.displayName && an.includes("<anonymous>") && (an = an.replace("<anonymous>", er.displayName)), typeof er == "function" && or.set(er, an), an;
                  }
                while (Jr >= 1 && en >= 0);
              break;
            }
        }
      } finally {
        rr = !1, Zt.current = Fr, sr(), Error.prepareStackTrace = Or;
      }
      var on = er ? er.displayName || er.name : "", sn = on ? Gt(on) : "";
      return typeof er == "function" && or.set(er, sn), sn;
    }
    function ur(er, br, wr) {
      return zt(er, !1);
    }
    function pr(er) {
      var br = er.prototype;
      return !!(br && br.isReactComponent);
    }
    function vr(er, br, wr) {
      if (er == null)
        return "";
      if (typeof er == "function")
        return zt(er, pr(er));
      if (typeof er == "string")
        return Gt(er);
      switch (er) {
        case ge:
          return Gt("Suspense");
        case oe:
          return Gt("SuspenseList");
      }
      if (typeof er == "object")
        switch (er.$$typeof) {
          case ve:
            return ur(er.render);
          case Ee:
            return vr(er.type, br, wr);
          case Ce: {
            var Sr = er, Or = Sr._payload, Fr = Sr._init;
            try {
              return vr(Fr(Or), br, wr);
            } catch {
            }
          }
        }
      return "";
    }
    var _r = Object.prototype.hasOwnProperty, xr = {}, Tr = Pt.ReactDebugCurrentFrame;
    function hr(er) {
      if (er) {
        var br = er._owner, wr = vr(er.type, er._source, br ? br.type : null);
        Tr.setExtraStackFrame(wr);
      } else
        Tr.setExtraStackFrame(null);
    }
    function Wr(er, br, wr, Sr, Or) {
      {
        var Fr = Function.call.bind(_r);
        for (var Ir in er)
          if (Fr(er, Ir)) {
            var Vr = void 0;
            try {
              if (typeof er[Ir] != "function") {
                var tn = Error((Sr || "React class") + ": " + wr + " type `" + Ir + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof er[Ir] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw tn.name = "Invariant Violation", tn;
              }
              Vr = er[Ir](br, Ir, Sr, wr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Jr) {
              Vr = Jr;
            }
            Vr && !(Vr instanceof Error) && (hr(Or), _t("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Sr || "React class", wr, Ir, typeof Vr), hr(null)), Vr instanceof Error && !(Vr.message in xr) && (xr[Vr.message] = !0, hr(Or), _t("Failed %s type: %s", wr, Vr.message), hr(null));
          }
      }
    }
    var $r = Array.isArray;
    function Ur(er) {
      return $r(er);
    }
    function Gr(er) {
      {
        var br = typeof Symbol == "function" && Symbol.toStringTag, wr = br && er[Symbol.toStringTag] || er.constructor.name || "Object";
        return wr;
      }
    }
    function Rr(er) {
      try {
        return Hr(er), !1;
      } catch {
        return !0;
      }
    }
    function Hr(er) {
      return "" + er;
    }
    function Xr(er) {
      if (Rr(er))
        return _t("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Gr(er)), Hr(er);
    }
    var qr = Pt.ReactCurrentOwner, zr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Qr, Vt;
    function Ft(er) {
      if (_r.call(er, "ref")) {
        var br = Object.getOwnPropertyDescriptor(er, "ref").get;
        if (br && br.isReactWarning)
          return !1;
      }
      return er.ref !== void 0;
    }
    function Ut(er) {
      if (_r.call(er, "key")) {
        var br = Object.getOwnPropertyDescriptor(er, "key").get;
        if (br && br.isReactWarning)
          return !1;
      }
      return er.key !== void 0;
    }
    function Qt(er, br) {
      typeof er.ref == "string" && qr.current;
    }
    function fr(er, br) {
      {
        var wr = function() {
          Qr || (Qr = !0, _t("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", br));
        };
        wr.isReactWarning = !0, Object.defineProperty(er, "key", {
          get: wr,
          configurable: !0
        });
      }
    }
    function cr(er, br) {
      {
        var wr = function() {
          Vt || (Vt = !0, _t("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", br));
        };
        wr.isReactWarning = !0, Object.defineProperty(er, "ref", {
          get: wr,
          configurable: !0
        });
      }
    }
    var lr = function(er, br, wr, Sr, Or, Fr, Ir) {
      var Vr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: z,
        // Built-in properties that belong on the element
        type: er,
        key: br,
        ref: wr,
        props: Ir,
        // Record the component responsible for creating this element.
        _owner: Fr
      };
      return Vr._store = {}, Object.defineProperty(Vr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Vr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Sr
      }), Object.defineProperty(Vr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Or
      }), Object.freeze && (Object.freeze(Vr.props), Object.freeze(Vr)), Vr;
    };
    function kr(er, br, wr, Sr, Or) {
      {
        var Fr, Ir = {}, Vr = null, tn = null;
        wr !== void 0 && (Xr(wr), Vr = "" + wr), Ut(br) && (Xr(br.key), Vr = "" + br.key), Ft(br) && (tn = br.ref, Qt(br, Or));
        for (Fr in br)
          _r.call(br, Fr) && !zr.hasOwnProperty(Fr) && (Ir[Fr] = br[Fr]);
        if (er && er.defaultProps) {
          var Jr = er.defaultProps;
          for (Fr in Jr)
            Ir[Fr] === void 0 && (Ir[Fr] = Jr[Fr]);
        }
        if (Vr || tn) {
          var en = typeof er == "function" ? er.displayName || er.name || "Unknown" : er;
          Vr && fr(Ir, en), tn && cr(Ir, en);
        }
        return lr(er, Vr, tn, Or, Sr, qr.current, Ir);
      }
    }
    var jr = Pt.ReactCurrentOwner, Br = Pt.ReactDebugCurrentFrame;
    function Dr(er) {
      if (er) {
        var br = er._owner, wr = vr(er.type, er._source, br ? br.type : null);
        Br.setExtraStackFrame(wr);
      } else
        Br.setExtraStackFrame(null);
    }
    var Lr;
    Lr = !1;
    function Nr(er) {
      return typeof er == "object" && er !== null && er.$$typeof === z;
    }
    function Yr() {
      {
        if (jr.current) {
          var er = Xe(jr.current.type);
          if (er)
            return `

Check the render method of \`` + er + "`.";
        }
        return "";
      }
    }
    function Zr(er) {
      return "";
    }
    var nr = {};
    function Jt(er) {
      {
        var br = Yr();
        if (!br) {
          var wr = typeof er == "string" ? er : er.displayName || er.name;
          wr && (br = `

Check the top-level render call using <` + wr + ">.");
        }
        return br;
      }
    }
    function ir(er, br) {
      {
        if (!er._store || er._store.validated || er.key != null)
          return;
        er._store.validated = !0;
        var wr = Jt(br);
        if (nr[wr])
          return;
        nr[wr] = !0;
        var Sr = "";
        er && er._owner && er._owner !== jr.current && (Sr = " It was passed a child from " + Xe(er._owner.type) + "."), Dr(er), _t('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', wr, Sr), Dr(null);
      }
    }
    function ar(er, br) {
      {
        if (typeof er != "object")
          return;
        if (Ur(er))
          for (var wr = 0; wr < er.length; wr++) {
            var Sr = er[wr];
            Nr(Sr) && ir(Sr, br);
          }
        else if (Nr(er))
          er._store && (er._store.validated = !0);
        else if (er) {
          var Or = vt(er);
          if (typeof Or == "function" && Or !== er.entries)
            for (var Fr = Or.call(er), Ir; !(Ir = Fr.next()).done; )
              Nr(Ir.value) && ir(Ir.value, br);
        }
      }
    }
    function dr(er) {
      {
        var br = er.type;
        if (br == null || typeof br == "string")
          return;
        var wr;
        if (typeof br == "function")
          wr = br.propTypes;
        else if (typeof br == "object" && (br.$$typeof === ve || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        br.$$typeof === Ee))
          wr = br.propTypes;
        else
          return;
        if (wr) {
          var Sr = Xe(br);
          Wr(wr, er.props, "prop", Sr, er);
        } else if (br.PropTypes !== void 0 && !Lr) {
          Lr = !0;
          var Or = Xe(br);
          _t("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Or || "Unknown");
        }
        typeof br.getDefaultProps == "function" && !br.getDefaultProps.isReactClassApproved && _t("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function yr(er) {
      {
        for (var br = Object.keys(er.props), wr = 0; wr < br.length; wr++) {
          var Sr = br[wr];
          if (Sr !== "children" && Sr !== "key") {
            Dr(er), _t("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Sr), Dr(null);
            break;
          }
        }
        er.ref !== null && (Dr(er), _t("Invalid attribute `ref` supplied to `React.Fragment`."), Dr(null));
      }
    }
    var gr = {};
    function Er(er, br, wr, Sr, Or, Fr) {
      {
        var Ir = Kt(er);
        if (!Ir) {
          var Vr = "";
          (er === void 0 || typeof er == "object" && er !== null && Object.keys(er).length === 0) && (Vr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var tn = Zr();
          tn ? Vr += tn : Vr += Yr();
          var Jr;
          er === null ? Jr = "null" : Ur(er) ? Jr = "array" : er !== void 0 && er.$$typeof === z ? (Jr = "<" + (Xe(er.type) || "Unknown") + " />", Vr = " Did you accidentally export a JSX literal instead of a component?") : Jr = typeof er, _t("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Jr, Vr);
        }
        var en = kr(er, br, wr, Or, Fr);
        if (en == null)
          return en;
        if (Ir) {
          var an = br.children;
          if (an !== void 0)
            if (Sr)
              if (Ur(an)) {
                for (var on = 0; on < an.length; on++)
                  ar(an[on], er);
                Object.freeze && Object.freeze(an);
              } else
                _t("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ar(an, er);
        }
        if (_r.call(br, "key")) {
          var sn = Xe(er), nn = Object.keys(br).filter(function(cn) {
            return cn !== "key";
          }), fn = nn.length > 0 ? "{key: someKey, " + nn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!gr[sn + fn]) {
            var un = nn.length > 0 ? "{" + nn.join(": ..., ") + ": ...}" : "{}";
            _t(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fn, sn, un, sn), gr[sn + fn] = !0;
          }
        }
        return er === ne ? yr(en) : dr(en), en;
      }
    }
    function Pr(er, br, wr) {
      return Er(er, br, wr, !0);
    }
    function Ar(er, br, wr) {
      return Er(er, br, wr, !1);
    }
    var Mr = Ar, Cr = Pr;
    reactJsxRuntime_development.Fragment = ne, reactJsxRuntime_development.jsx = Mr, reactJsxRuntime_development.jsxs = Cr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, z] = useState(!1);
  return useEffect(() => {
    z(!0);
  }, []), B;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(B) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const z = `${KEY_PREFIX}_${B}`;
  try {
    const Y = window.localStorage.getItem(z);
    return Y != null ? JSON.parse(Y) : null;
  } catch (Y) {
    return console.error(`Error retrieving ${z} from localStorage`, Y), null;
  }
}
function setItemToLocalStorage(B, z) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const Y = `${KEY_PREFIX}_${B}`;
  try {
    z ? window.localStorage.setItem(Y, JSON.stringify(z)) : window.localStorage.removeItem(Y);
  } catch (ne) {
    console.error(`Error saving ${Y} to localStorage`, ne);
  }
}
function useLocalStorage(B, z, Y = {}) {
  const { initializeWithValue: ne = !0 } = Y, ae = useCallback(() => {
    const ve = getItemFromLocalStorage(B);
    return ve || (setItemToLocalStorage(B, z), z);
  }, [z, B]), [ie, se] = useState(() => ne ? ae() : z), le = useCallback(
    (ve) => {
      setItemToLocalStorage(B, ve), se(ve);
    },
    [B]
  );
  return useEffect(() => {
    se(ae());
  }, [B]), [ie, le];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {}), Chain = /* @__PURE__ */ ((B) => (B.BITCOIN = "bitcoin", B.FRACTAL_BITCOIN = "fractal-bitcoin", B))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: B,
  network: z,
  visibleWallets: Y,
  chain: ne = "bitcoin",
  ssr: ae = !1
}) {
  if (!z)
    throw new Error("Network cannot be empty");
  if (!Y || Y.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [ie, se] = useState(z), [le, ve] = useState(Y), [ge, oe] = useState(ne), [Ee, Ce] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ae }
  ), [Pe, Ve] = useLocalStorage(WALLET, null, {
    initializeWithValue: !ae
  }), [ht, vt] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ae }
  ), [Pt, _t] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ae }
  ), [kt, Ot] = useState(!1), Ht = useCallback(() => Ot(!0), []), jt = useCallback(() => Ot(!1), []), Yt = useCallback(() => {
    Ce(EMPTY_BIADDRESS_OBJECT), vt(EMPTY_BIADDRESS_OBJECT), _t(EMPTY_BIADDRESS_OBJECT), Ve(null);
  }, [Ce, _t, vt, Ve]), Dt = useMemo(
    () => ({
      address: Ee,
      updateAddress: Ce,
      publicKey: ht,
      updatePublicKey: vt,
      network: ie,
      updateNetwork: se,
      wallet: Pe,
      updateWallet: Ve,
      isModalOpen: kt,
      openModal: Ht,
      closeModal: jt,
      format: Pt,
      updateFormat: _t,
      disconnectWallet: Yt,
      chain: ge,
      updateChain: oe,
      visibleWallets: le,
      updateVisibleWallets: ve
    }),
    [
      Ee,
      Ce,
      ht,
      vt,
      ie,
      Pe,
      kt,
      Ht,
      jt,
      Pt,
      _t,
      Yt,
      ge,
      le,
      Ve
    ]
  );
  return useEffect(() => {
    se(z);
  }, [z]), useEffect(() => {
    ge !== ne && (Yt(), oe(ne));
  }, [ne, ge, Yt]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: Dt, children: B });
}
function useOrdConnect() {
  const B = useContext(OrdConnectContext);
  if (!B)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return B;
}
var build = { exports: {} };
(function(B, z) {
  (function(Y, ne) {
    B.exports = ne(React__default);
  })(commonjsGlobal, function(Y) {
    return function(ne) {
      var ae = {};
      function ie(se) {
        if (ae[se]) return ae[se].exports;
        var le = ae[se] = { i: se, l: !1, exports: {} };
        return ne[se].call(le.exports, le, le.exports, ie), le.l = !0, le.exports;
      }
      return ie.m = ne, ie.c = ae, ie.d = function(se, le, ve) {
        ie.o(se, le) || Object.defineProperty(se, le, { enumerable: !0, get: ve });
      }, ie.r = function(se) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(se, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(se, "__esModule", { value: !0 });
      }, ie.t = function(se, le) {
        if (1 & le && (se = ie(se)), 8 & le || 4 & le && typeof se == "object" && se && se.__esModule) return se;
        var ve = /* @__PURE__ */ Object.create(null);
        if (ie.r(ve), Object.defineProperty(ve, "default", { enumerable: !0, value: se }), 2 & le && typeof se != "string") for (var ge in se) ie.d(ve, ge, (function(oe) {
          return se[oe];
        }).bind(null, ge));
        return ve;
      }, ie.n = function(se) {
        var le = se && se.__esModule ? function() {
          return se.default;
        } : function() {
          return se;
        };
        return ie.d(le, "a", le), le;
      }, ie.o = function(se, le) {
        return Object.prototype.hasOwnProperty.call(se, le);
      }, ie.p = "/", ie(ie.s = 1);
    }([function(ne, ae) {
      ne.exports = Y;
    }, function(ne, ae, ie) {
      ne.exports = ie(2);
    }, function(ne, ae, ie) {
      function se(_t, kt) {
        if (_t == null) return {};
        var Ot, Ht, jt = function(Dt, Ct) {
          if (Dt == null) return {};
          var Kt, Nt, Je = {}, Xe = Object.keys(Dt);
          for (Nt = 0; Nt < Xe.length; Nt++) Kt = Xe[Nt], Ct.indexOf(Kt) >= 0 || (Je[Kt] = Dt[Kt]);
          return Je;
        }(_t, kt);
        if (Object.getOwnPropertySymbols) {
          var Yt = Object.getOwnPropertySymbols(_t);
          for (Ht = 0; Ht < Yt.length; Ht++) Ot = Yt[Ht], kt.indexOf(Ot) >= 0 || Object.prototype.propertyIsEnumerable.call(_t, Ot) && (jt[Ot] = _t[Ot]);
        }
        return jt;
      }
      ie.r(ae);
      var le = ie(0), ve = ie.n(le), ge = function(_t) {
        for (var kt = 0, Ot = 0; Ot < _t.length; Ot++)
          kt = (kt << 5) - kt + _t.charCodeAt(Ot), kt &= kt;
        return Math.abs(kt);
      }, oe = function(_t, kt) {
        return Math.floor(_t / Math.pow(10, kt) % 10);
      }, Ee = function(_t, kt) {
        return !(oe(_t, kt) % 2);
      }, Ce = function(_t, kt, Ot) {
        var Ht = _t % kt;
        return Ot && oe(_t, Ot) % 2 === 0 ? -Ht : Ht;
      }, Pe = function(_t, kt, Ot) {
        return kt[_t % Ot];
      }, Ve = function(_t) {
        var kt = _t.name, Ot = _t.colors, Ht = _t.title, jt = _t.square, Yt = _t.size, Dt = se(_t, ["name", "colors", "title", "square", "size"]), Ct = function(Nt, Je) {
          var Xe = ge(Nt), Ke = Je && Je.length;
          return Array.from({ length: 3 }, function(Qe, bt) {
            return { color: Pe(Xe + bt, Je, Ke), translateX: Ce(Xe * (bt + 1), 8, 1), translateY: Ce(Xe * (bt + 1), 8, 2), scale: 1.2 + Ce(Xe * (bt + 1), 4) / 10, rotate: Ce(Xe * (bt + 1), 360, 1) };
          });
        }(kt, Ot), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Dt), Ht && le.createElement("title", null, kt), le.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: jt ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 80, height: 80, fill: Ct[0].color }), le.createElement("path", { filter: "url(#filter_".concat(Kt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: Ct[1].color, transform: "translate(" + Ct[1].translateX + " " + Ct[1].translateY + ") rotate(" + Ct[1].rotate + " 40 40) scale(" + Ct[2].scale + ")" }), le.createElement("path", { filter: "url(#filter_".concat(Kt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: Ct[2].color, transform: "translate(" + Ct[2].translateX + " " + Ct[2].translateY + ") rotate(" + Ct[2].rotate + " 40 40) scale(" + Ct[2].scale + ")" })), le.createElement("defs", null, le.createElement("filter", { id: "filter_".concat(Kt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, le.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), le.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), le.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, ht = { pixel: function(_t) {
        var kt = _t.name, Ot = _t.colors, Ht = _t.title, jt = _t.square, Yt = _t.size, Dt = se(_t, ["name", "colors", "title", "square", "size"]), Ct = function(Nt, Je) {
          var Xe = ge(Nt), Ke = Je && Je.length;
          return Array.from({ length: 64 }, function(Qe, bt) {
            return Pe(Xe % (bt + 1), Je, Ke);
          });
        }(kt, Ot), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Dt), Ht && le.createElement("title", null, kt), le.createElement("mask", { id: Kt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: jt ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 10, height: 10, fill: Ct[0] }), le.createElement("rect", { x: 20, width: 10, height: 10, fill: Ct[1] }), le.createElement("rect", { x: 40, width: 10, height: 10, fill: Ct[2] }), le.createElement("rect", { x: 60, width: 10, height: 10, fill: Ct[3] }), le.createElement("rect", { x: 10, width: 10, height: 10, fill: Ct[4] }), le.createElement("rect", { x: 30, width: 10, height: 10, fill: Ct[5] }), le.createElement("rect", { x: 50, width: 10, height: 10, fill: Ct[6] }), le.createElement("rect", { x: 70, width: 10, height: 10, fill: Ct[7] }), le.createElement("rect", { y: 10, width: 10, height: 10, fill: Ct[8] }), le.createElement("rect", { y: 20, width: 10, height: 10, fill: Ct[9] }), le.createElement("rect", { y: 30, width: 10, height: 10, fill: Ct[10] }), le.createElement("rect", { y: 40, width: 10, height: 10, fill: Ct[11] }), le.createElement("rect", { y: 50, width: 10, height: 10, fill: Ct[12] }), le.createElement("rect", { y: 60, width: 10, height: 10, fill: Ct[13] }), le.createElement("rect", { y: 70, width: 10, height: 10, fill: Ct[14] }), le.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: Ct[15] }), le.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: Ct[16] }), le.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: Ct[17] }), le.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: Ct[18] }), le.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: Ct[19] }), le.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: Ct[20] }), le.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: Ct[21] }), le.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: Ct[22] }), le.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: Ct[23] }), le.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: Ct[24] }), le.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: Ct[25] }), le.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: Ct[26] }), le.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: Ct[27] }), le.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: Ct[28] }), le.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: Ct[29] }), le.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: Ct[30] }), le.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: Ct[31] }), le.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: Ct[32] }), le.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: Ct[33] }), le.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: Ct[34] }), le.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: Ct[35] }), le.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: Ct[36] }), le.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: Ct[37] }), le.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: Ct[38] }), le.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: Ct[39] }), le.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: Ct[40] }), le.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: Ct[41] }), le.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: Ct[42] }), le.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: Ct[43] }), le.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: Ct[44] }), le.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: Ct[45] }), le.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: Ct[46] }), le.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: Ct[47] }), le.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: Ct[48] }), le.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: Ct[49] }), le.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: Ct[50] }), le.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: Ct[51] }), le.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: Ct[52] }), le.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: Ct[53] }), le.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: Ct[54] }), le.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: Ct[55] }), le.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: Ct[56] }), le.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: Ct[57] }), le.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: Ct[58] }), le.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: Ct[59] }), le.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: Ct[60] }), le.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: Ct[61] }), le.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: Ct[62] }), le.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: Ct[63] })));
      }, bauhaus: function(_t) {
        var kt = _t.name, Ot = _t.colors, Ht = _t.title, jt = _t.square, Yt = _t.size, Dt = se(_t, ["name", "colors", "title", "square", "size"]), Ct = function(Nt, Je) {
          var Xe = ge(Nt), Ke = Je && Je.length;
          return Array.from({ length: 4 }, function(Qe, bt) {
            return { color: Pe(Xe + bt, Je, Ke), translateX: Ce(Xe * (bt + 1), 40 - (bt + 17), 1), translateY: Ce(Xe * (bt + 1), 40 - (bt + 17), 2), rotate: Ce(Xe * (bt + 1), 360), isSquare: Ee(Xe, 2) };
          });
        }(kt, Ot), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Dt), Ht && le.createElement("title", null, kt), le.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: jt ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 80, height: 80, fill: Ct[0].color }), le.createElement("rect", { x: 10, y: 30, width: 80, height: Ct[1].isSquare ? 80 : 10, fill: Ct[1].color, transform: "translate(" + Ct[1].translateX + " " + Ct[1].translateY + ") rotate(" + Ct[1].rotate + " 40 40)" }), le.createElement("circle", { cx: 40, cy: 40, fill: Ct[2].color, r: 16, transform: "translate(" + Ct[2].translateX + " " + Ct[2].translateY + ")" }), le.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: Ct[3].color, transform: "translate(" + Ct[3].translateX + " " + Ct[3].translateY + ") rotate(" + Ct[3].rotate + " 40 40)" })));
      }, ring: function(_t) {
        var kt = _t.name, Ot = _t.colors, Ht = _t.title, jt = _t.square, Yt = _t.size, Dt = se(_t, ["name", "colors", "title", "square", "size"]), Ct = function(Nt, Je) {
          var Xe = ge(Je), Ke = Nt && Nt.length, Qe = Array.from({ length: 5 }, function(wt, xt) {
            return Pe(Xe + xt, Nt, Ke);
          }), bt = [];
          return bt[0] = Qe[0], bt[1] = Qe[1], bt[2] = Qe[1], bt[3] = Qe[2], bt[4] = Qe[2], bt[5] = Qe[3], bt[6] = Qe[3], bt[7] = Qe[0], bt[8] = Qe[4], bt;
        }(Ot, kt), Kt = ve.a.useId();
        return ve.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Dt), Ht && ve.a.createElement("title", null, kt), ve.a.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ve.a.createElement("rect", { width: 90, height: 90, rx: jt ? void 0 : 180, fill: "#FFFFFF" })), ve.a.createElement("g", { mask: "url(#".concat(Kt, ")") }, ve.a.createElement("path", { d: "M0 0h90v45H0z", fill: Ct[0] }), ve.a.createElement("path", { d: "M0 45h90v45H0z", fill: Ct[1] }), ve.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: Ct[2] }), ve.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: Ct[3] }), ve.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: Ct[4] }), ve.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: Ct[5] }), ve.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: Ct[6] }), ve.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: Ct[7] }), ve.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: Ct[8] })));
      }, beam: function(_t) {
        var kt = _t.name, Ot = _t.colors, Ht = _t.title, jt = _t.square, Yt = _t.size, Dt = se(_t, ["name", "colors", "title", "square", "size"]), Ct = function(Nt, Je) {
          var Xe, Ke = ge(Nt), Qe = Je && Je.length, bt = Pe(Ke, Je, Qe), wt = Ce(Ke, 10, 1), xt = wt < 5 ? wt + 4 : wt, Bt = Ce(Ke, 10, 2), $t = Bt < 5 ? Bt + 4 : Bt;
          return { wrapperColor: bt, faceColor: (Xe = bt, Xe.slice(0, 1) === "#" && (Xe = Xe.slice(1)), (299 * parseInt(Xe.substr(0, 2), 16) + 587 * parseInt(Xe.substr(2, 2), 16) + 114 * parseInt(Xe.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Pe(Ke + 13, Je, Qe), wrapperTranslateX: xt, wrapperTranslateY: $t, wrapperRotate: Ce(Ke, 360), wrapperScale: 1 + Ce(Ke, 3) / 10, isMouthOpen: Ee(Ke, 2), isCircle: Ee(Ke, 1), eyeSpread: Ce(Ke, 5), mouthSpread: Ce(Ke, 3), faceRotate: Ce(Ke, 10, 3), faceTranslateX: xt > 6 ? xt / 2 : Ce(Ke, 8, 1), faceTranslateY: $t > 6 ? $t / 2 : Ce(Ke, 7, 2) };
        }(kt, Ot), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Dt), Ht && le.createElement("title", null, kt), le.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, le.createElement("rect", { width: 36, height: 36, rx: jt ? void 0 : 72, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 36, height: 36, fill: Ct.backgroundColor }), le.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + Ct.wrapperTranslateX + " " + Ct.wrapperTranslateY + ") rotate(" + Ct.wrapperRotate + " 18 18) scale(" + Ct.wrapperScale + ")", fill: Ct.wrapperColor, rx: Ct.isCircle ? 36 : 6 }), le.createElement("g", { transform: "translate(" + Ct.faceTranslateX + " " + Ct.faceTranslateY + ") rotate(" + Ct.faceRotate + " 18 18)" }, Ct.isMouthOpen ? le.createElement("path", { d: "M15 " + (19 + Ct.mouthSpread) + "c2 1 4 1 6 0", stroke: Ct.faceColor, fill: "none", strokeLinecap: "round" }) : le.createElement("path", { d: "M13," + (19 + Ct.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: Ct.faceColor }), le.createElement("rect", { x: 14 - Ct.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Ct.faceColor }), le.createElement("rect", { x: 20 + Ct.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Ct.faceColor }))));
      }, sunset: function(_t) {
        var kt = _t.name, Ot = _t.colors, Ht = _t.title, jt = _t.square, Yt = _t.size, Dt = se(_t, ["name", "colors", "title", "square", "size"]), Ct = function(Je, Xe) {
          var Ke = ge(Je), Qe = Xe && Xe.length;
          return Array.from({ length: 4 }, function(bt, wt) {
            return Pe(Ke + wt, Xe, Qe);
          });
        }(kt, Ot), Kt = kt.replace(/\s/g, ""), Nt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Dt), Ht && le.createElement("title", null, kt), le.createElement("mask", { id: Nt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: jt ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Nt, ")") }, le.createElement("path", { fill: "url(#gradient_paint0_linear_" + Kt + ")", d: "M0 0h80v40H0z" }), le.createElement("path", { fill: "url(#gradient_paint1_linear_" + Kt + ")", d: "M0 40h80v40H0z" })), le.createElement("defs", null, le.createElement("linearGradient", { id: "gradient_paint0_linear_" + Kt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, le.createElement("stop", { stopColor: Ct[0] }), le.createElement("stop", { offset: 1, stopColor: Ct[1] })), le.createElement("linearGradient", { id: "gradient_paint1_linear_" + Kt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, le.createElement("stop", { stopColor: Ct[2] }), le.createElement("stop", { offset: 1, stopColor: Ct[3] }))));
      }, marble: Ve }, vt = { geometric: "beam", abstract: "bauhaus" }, Pt = function(_t) {
        var kt = _t.variant, Ot = kt === void 0 ? "marble" : kt, Ht = _t.colors, jt = Ht === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Ht, Yt = _t.name, Dt = Yt === void 0 ? "Clara Barton" : Yt, Ct = _t.title, Kt = Ct !== void 0 && Ct, Nt = _t.size, Je = _t.square, Xe = Je !== void 0 && Je, Ke = se(_t, ["variant", "colors", "name", "title", "size", "square"]), Qe = ht[vt[Ot] || Ot] || Ve;
        return ve.a.createElement(Qe, Object.assign({ colors: jt, name: Dt, title: Kt, size: Nt, square: Xe }, Ke));
      };
      ae.default = Pt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports), $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(B) {
  const z = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    z.current = B;
  }, [
    B
  ]), useCallback((...Y) => {
    const ne = z.current;
    return ne == null ? void 0 : ne(...Y);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (B) => {
  var z;
  return (z = B == null ? void 0 : B.ownerDocument) !== null && z !== void 0 ? z : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (B) => B && "window" in B && B.window === B ? B : $431fbd86ca7dc216$export$b204af158042fbac(B).defaultView || window;
function $c87311424ea30a05$var$testUserAgent(B) {
  var z;
  return typeof window > "u" || window.navigator == null ? !1 : ((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.brands.some((Y) => B.test(Y.brand))) || B.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(B) {
  var z;
  return typeof window < "u" && window.navigator != null ? B.test(((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(B) {
  let z = null;
  return () => (z == null && (z = B()), z);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $6a7db85432448f7f$export$60278871457622de(B) {
  return B.mozInputSource === 0 && B.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && B.pointerType ? B.type === "click" && B.buttons === 1 : B.detail === 0 && !B.pointerType;
}
class $8a9cb279dc87e130$export$905e7fc544a71f36 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(z, Y) {
    this.nativeEvent = Y, this.target = Y.target, this.currentTarget = Y.currentTarget, this.relatedTarget = Y.relatedTarget, this.bubbles = Y.bubbles, this.cancelable = Y.cancelable, this.defaultPrevented = Y.defaultPrevented, this.eventPhase = Y.eventPhase, this.isTrusted = Y.isTrusted, this.timeStamp = Y.timeStamp, this.type = z;
  }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(B) {
  let z = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const ne = z.current;
    return () => {
      ne.observer && (ne.observer.disconnect(), ne.observer = null);
    };
  }, []);
  let Y = $8ae05eaa5c114e9c$export$7f54fc3180508a52((ne) => {
    B == null || B(ne);
  });
  return useCallback((ne) => {
    if (ne.target instanceof HTMLButtonElement || ne.target instanceof HTMLInputElement || ne.target instanceof HTMLTextAreaElement || ne.target instanceof HTMLSelectElement) {
      z.current.isFocused = !0;
      let ae = ne.target, ie = (se) => {
        z.current.isFocused = !1, ae.disabled && Y(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", se)), z.current.observer && (z.current.observer.disconnect(), z.current.observer = null);
      };
      ae.addEventListener("focusout", ie, {
        once: !0
      }), z.current.observer = new MutationObserver(() => {
        if (z.current.isFocused && ae.disabled) {
          var se;
          (se = z.current.observer) === null || se === void 0 || se.disconnect();
          let le = ae === document.activeElement ? null : document.activeElement;
          ae.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: le
          })), ae.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: le
          }));
        }
      }), z.current.observer.observe(ae, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    Y
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(B) {
  let { isDisabled: z, onFocus: Y, onBlur: ne, onFocusChange: ae } = B;
  const ie = useCallback((ve) => {
    if (ve.target === ve.currentTarget)
      return ne && ne(ve), ae && ae(!1), !0;
  }, [
    ne,
    ae
  ]), se = $8a9cb279dc87e130$export$715c682d09d639cc(ie), le = useCallback((ve) => {
    const ge = $431fbd86ca7dc216$export$b204af158042fbac(ve.target);
    ve.target === ve.currentTarget && ge.activeElement === ve.target && (Y && Y(ve), ae && ae(!0), se(ve));
  }, [
    ae,
    Y,
    se
  ]);
  return {
    focusProps: {
      onFocus: !z && (Y || ae || ne) ? le : void 0,
      onBlur: !z && (ne || ae) ? ie : void 0
    }
  };
}
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(B, z) {
  for (let Y of $507fabe10e71c6fb$var$changeHandlers) Y(B, z);
}
function $507fabe10e71c6fb$var$isValidKey(B) {
  return !(B.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && B.altKey || B.ctrlKey || B.key === "Control" || B.key === "Shift" || B.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(B) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(B) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", B));
}
function $507fabe10e71c6fb$var$handlePointerEvent(B) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (B.type === "mousedown" || B.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", B));
}
function $507fabe10e71c6fb$var$handleClickEvent(B) {
  $6a7db85432448f7f$export$60278871457622de(B) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(B) {
  B.target === window || B.target === document || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", B)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(B))) return;
  const z = $431fbd86ca7dc216$export$f21a1ffae260145a(B), Y = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let ne = z.HTMLElement.prototype.focus;
  z.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, ne.apply(this, arguments);
  }, Y.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), z.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), z.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (Y.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (Y.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), z.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(z, {
    focus: ne
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (B, z) => {
  const Y = $431fbd86ca7dc216$export$f21a1ffae260145a(B), ne = $431fbd86ca7dc216$export$b204af158042fbac(B);
  z && ne.removeEventListener("DOMContentLoaded", z), $507fabe10e71c6fb$export$d90243b58daecda7.has(Y) && (Y.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(Y).focus, ne.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), Y.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), Y.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (ne.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (ne.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(Y));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(B) {
  const z = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let Y;
  return z.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) : (Y = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(B);
  }, z.addEventListener("DOMContentLoaded", Y)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B, Y);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(B, z, Y) {
  var ne;
  const ae = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLInputElement : HTMLInputElement, ie = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLTextAreaElement : HTMLTextAreaElement, se = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLElement : HTMLElement, le = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).KeyboardEvent : KeyboardEvent;
  return B = B || (Y == null ? void 0 : Y.target) instanceof ae && !$507fabe10e71c6fb$var$nonTextInputTypes.has(Y == null || (ne = Y.target) === null || ne === void 0 ? void 0 : ne.type) || (Y == null ? void 0 : Y.target) instanceof ie || (Y == null ? void 0 : Y.target) instanceof se && (Y == null ? void 0 : Y.target.isContentEditable), !(B && z === "keyboard" && Y instanceof le && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[Y.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(B, z, Y) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let ne = (ae, ie) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(Y != null && Y.isTextInput), ae, ie) && B($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(ne), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(ne);
    };
  }, z);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(B) {
  let { isDisabled: z, onBlurWithin: Y, onFocusWithin: ne, onFocusWithinChange: ae } = B, ie = useRef({
    isFocusWithin: !1
  }), se = useCallback((ge) => {
    ie.current.isFocusWithin && !ge.currentTarget.contains(ge.relatedTarget) && (ie.current.isFocusWithin = !1, Y && Y(ge), ae && ae(!1));
  }, [
    Y,
    ae,
    ie
  ]), le = $8a9cb279dc87e130$export$715c682d09d639cc(se), ve = useCallback((ge) => {
    !ie.current.isFocusWithin && document.activeElement === ge.target && (ne && ne(ge), ae && ae(!0), ie.current.isFocusWithin = !0, le(ge));
  }, [
    ne,
    ae,
    le
  ]);
  return z ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: ve,
      onBlur: se
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(B) {
  B.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(B) {
  let { onHoverStart: z, onHoverChange: Y, onHoverEnd: ne, isDisabled: ae } = B, [ie, se] = useState(!1), le = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps: ve, triggerHoverEnd: ge } = useMemo(() => {
    let oe = (Pe, Ve) => {
      if (le.pointerType = Ve, ae || Ve === "touch" || le.isHovered || !Pe.currentTarget.contains(Pe.target)) return;
      le.isHovered = !0;
      let ht = Pe.currentTarget;
      le.target = ht, z && z({
        type: "hoverstart",
        target: ht,
        pointerType: Ve
      }), Y && Y(!0), se(!0);
    }, Ee = (Pe, Ve) => {
      if (le.pointerType = "", le.target = null, Ve === "touch" || !le.isHovered) return;
      le.isHovered = !1;
      let ht = Pe.currentTarget;
      ne && ne({
        type: "hoverend",
        target: ht,
        pointerType: Ve
      }), Y && Y(!1), se(!1);
    }, Ce = {};
    return typeof PointerEvent < "u" ? (Ce.onPointerEnter = (Pe) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && Pe.pointerType === "mouse" || oe(Pe, Pe.pointerType);
    }, Ce.onPointerLeave = (Pe) => {
      !ae && Pe.currentTarget.contains(Pe.target) && Ee(Pe, Pe.pointerType);
    }) : (Ce.onTouchStart = () => {
      le.ignoreEmulatedMouseEvents = !0;
    }, Ce.onMouseEnter = (Pe) => {
      !le.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && oe(Pe, "mouse"), le.ignoreEmulatedMouseEvents = !1;
    }, Ce.onMouseLeave = (Pe) => {
      !ae && Pe.currentTarget.contains(Pe.target) && Ee(Pe, "mouse");
    }), {
      hoverProps: Ce,
      triggerHoverEnd: Ee
    };
  }, [
    z,
    Y,
    ne,
    ae,
    le
  ]);
  return useEffect(() => {
    ae && ge({
      currentTarget: le.target
    }, le.pointerType);
  }, [
    ae
  ]), {
    hoverProps: ve,
    isHovered: ie
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(B = {}) {
  let { autoFocus: z = !1, isTextInput: Y, within: ne } = B, ae = useRef({
    isFocused: !1,
    isFocusVisible: z || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [ie, se] = useState(!1), [le, ve] = useState(() => ae.current.isFocused && ae.current.isFocusVisible), ge = useCallback(() => ve(ae.current.isFocused && ae.current.isFocusVisible), []), oe = useCallback((Pe) => {
    ae.current.isFocused = Pe, se(Pe), ge();
  }, [
    ge
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((Pe) => {
    ae.current.isFocusVisible = Pe, ge();
  }, [], {
    isTextInput: Y
  });
  let { focusProps: Ee } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: ne,
    onFocusChange: oe
  }), { focusWithinProps: Ce } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !ne,
    onFocusWithinChange: oe
  });
  return {
    isFocused: ie,
    isFocusVisible: le,
    focusProps: ne ? Ce : Ee
  };
}
var i$7 = Object.defineProperty, d$3 = (B, z, Y) => z in B ? i$7(B, z, { enumerable: !0, configurable: !0, writable: !0, value: Y }) : B[z] = Y, r$4 = (B, z, Y) => (d$3(B, typeof z != "symbol" ? z + "" : z, Y), Y);
let o$6 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(z) {
    this.current !== z && (this.handoffState = "pending", this.currentId = 0, this.current = z);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$8 = new o$6();
function u$8(B) {
  return s$8.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
function t$4(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((z) => setTimeout(() => {
    throw z;
  }));
}
function o$5() {
  let B = [], z = { addEventListener(Y, ne, ae, ie) {
    return Y.addEventListener(ne, ae, ie), z.add(() => Y.removeEventListener(ne, ae, ie));
  }, requestAnimationFrame(...Y) {
    let ne = requestAnimationFrame(...Y);
    return z.add(() => cancelAnimationFrame(ne));
  }, nextFrame(...Y) {
    return z.requestAnimationFrame(() => z.requestAnimationFrame(...Y));
  }, setTimeout(...Y) {
    let ne = setTimeout(...Y);
    return z.add(() => clearTimeout(ne));
  }, microTask(...Y) {
    let ne = { current: !0 };
    return t$4(() => {
      ne.current && Y[0]();
    }), z.add(() => {
      ne.current = !1;
    });
  }, style(Y, ne, ae) {
    let ie = Y.style.getPropertyValue(ne);
    return Object.assign(Y.style, { [ne]: ae }), this.add(() => {
      Object.assign(Y.style, { [ne]: ie });
    });
  }, group(Y) {
    let ne = o$5();
    return Y(ne), this.add(() => ne.dispose());
  }, add(Y) {
    return B.includes(Y) || B.push(Y), () => {
      let ne = B.indexOf(Y);
      if (ne >= 0) for (let ae of B.splice(ne, 1)) ae();
    };
  }, dispose() {
    for (let Y of B.splice(0)) Y();
  } };
  return z;
}
function p$2() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
let n$3 = (B, z) => {
  s$8.isServer ? useEffect(B, z) : useLayoutEffect(B, z);
};
function s$7(B) {
  let z = useRef(B);
  return n$3(() => {
    z.current = B;
  }, [B]), z;
}
let o$4 = function(B) {
  let z = s$7(B);
  return React__default.useCallback((...Y) => z.current(...Y), [z]);
};
function E$2(B) {
  let z = B.width / 2, Y = B.height / 2;
  return { top: B.clientY - Y, right: B.clientX + z, bottom: B.clientY + Y, left: B.clientX - z };
}
function P$3(B, z) {
  return !(!B || !z || B.right < z.left || B.left > z.right || B.bottom < z.top || B.top > z.bottom);
}
function w$5({ disabled: B = !1 } = {}) {
  let z = useRef(null), [Y, ne] = useState(!1), ae = p$2(), ie = o$4(() => {
    z.current = null, ne(!1), ae.dispose();
  }), se = o$4((le) => {
    if (ae.dispose(), z.current === null) {
      z.current = le.currentTarget, ne(!0);
      {
        let ve = u$8(le.currentTarget);
        ae.addEventListener(ve, "pointerup", ie, !1), ae.addEventListener(ve, "pointermove", (ge) => {
          if (z.current) {
            let oe = E$2(ge);
            ne(P$3(oe, z.current.getBoundingClientRect()));
          }
        }, !1), ae.addEventListener(ve, "pointercancel", ie, !1);
      }
    }
  });
  return { pressed: Y, pressProps: B ? {} : { onPointerDown: se, onPointerUp: ie, onClick: ie } };
}
let e$4 = createContext(void 0);
function a$b() {
  return useContext(e$4);
}
function t$3(...B) {
  return Array.from(new Set(B.flatMap((z) => typeof z == "string" ? z.split(" ") : []))).filter(Boolean).join(" ");
}
function u$7(B, z, ...Y) {
  if (B in z) {
    let ae = z[B];
    return typeof ae == "function" ? ae(...Y) : ae;
  }
  let ne = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(z).map((ae) => `"${ae}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(ne, u$7), ne;
}
var O$3 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$3 || {}), A$1 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(A$1 || {});
function L$1() {
  let B = U$3();
  return useCallback((z) => C$3({ mergeRefs: B, ...z }), [B]);
}
function C$3({ ourProps: B, theirProps: z, slot: Y, defaultTag: ne, features: ae, visible: ie = !0, name: se, mergeRefs: le }) {
  le = le ?? $$1;
  let ve = P$2(z, B);
  if (ie) return F$2(ve, Y, ne, se, le);
  let ge = ae ?? 0;
  if (ge & 2) {
    let { static: oe = !1, ...Ee } = ve;
    if (oe) return F$2(Ee, Y, ne, se, le);
  }
  if (ge & 1) {
    let { unmount: oe = !0, ...Ee } = ve;
    return u$7(oe ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F$2({ ...Ee, hidden: !0, style: { display: "none" } }, Y, ne, se, le);
    } });
  }
  return F$2(ve, Y, ne, se, le);
}
function F$2(B, z = {}, Y, ne, ae) {
  let { as: ie = Y, children: se, refName: le = "ref", ...ve } = h$4(B, ["unmount", "static"]), ge = B.ref !== void 0 ? { [le]: B.ref } : {}, oe = typeof se == "function" ? se(z) : se;
  "className" in ve && ve.className && typeof ve.className == "function" && (ve.className = ve.className(z)), ve["aria-labelledby"] && ve["aria-labelledby"] === ve.id && (ve["aria-labelledby"] = void 0);
  let Ee = {};
  if (z) {
    let Ce = !1, Pe = [];
    for (let [Ve, ht] of Object.entries(z)) typeof ht == "boolean" && (Ce = !0), ht === !0 && Pe.push(Ve.replace(/([A-Z])/g, (vt) => `-${vt.toLowerCase()}`));
    if (Ce) {
      Ee["data-headlessui-state"] = Pe.join(" ");
      for (let Ve of Pe) Ee[`data-${Ve}`] = "";
    }
  }
  if (ie === Fragment && (Object.keys(m$4(ve)).length > 0 || Object.keys(m$4(Ee)).length > 0)) if (!isValidElement(oe) || Array.isArray(oe) && oe.length > 1) {
    if (Object.keys(m$4(ve)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${ne} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(ve)).concat(Object.keys(m$4(Ee))).map((Ce) => `  - ${Ce}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((Ce) => `  - ${Ce}`).join(`
`)].join(`
`));
  } else {
    let Ce = oe.props, Pe = Ce == null ? void 0 : Ce.className, Ve = typeof Pe == "function" ? (...Pt) => t$3(Pe(...Pt), ve.className) : t$3(Pe, ve.className), ht = Ve ? { className: Ve } : {}, vt = P$2(oe.props, m$4(h$4(ve, ["ref"])));
    for (let Pt in Ee) Pt in vt && delete Ee[Pt];
    return cloneElement(oe, Object.assign({}, vt, Ee, ge, { ref: ae(H$3(oe), ge.ref) }, ht));
  }
  return createElement(ie, Object.assign({}, h$4(ve, ["ref"]), ie !== Fragment && ge, ie !== Fragment && Ee), oe);
}
function U$3() {
  let B = useRef([]), z = useCallback((Y) => {
    for (let ne of B.current) ne != null && (typeof ne == "function" ? ne(Y) : ne.current = Y);
  }, []);
  return (...Y) => {
    if (!Y.every((ne) => ne == null)) return B.current = Y, z;
  };
}
function $$1(...B) {
  return B.every((z) => z == null) ? void 0 : (z) => {
    for (let Y of B) Y != null && (typeof Y == "function" ? Y(z) : Y.current = z);
  };
}
function P$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let ae in ne) ae.startsWith("on") && typeof ne[ae] == "function" ? (Y[ae] != null || (Y[ae] = []), Y[ae].push(ne[ae])) : z[ae] = ne[ae];
  if (z.disabled || z["aria-disabled"]) for (let ne in Y) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(ne) && (Y[ne] = [(ae) => {
    var ie;
    return (ie = ae == null ? void 0 : ae.preventDefault) == null ? void 0 : ie.call(ae);
  }]);
  for (let ne in Y) Object.assign(z, { [ne](ae, ...ie) {
    let se = Y[ne];
    for (let le of se) {
      if ((ae instanceof Event || (ae == null ? void 0 : ae.nativeEvent) instanceof Event) && ae.defaultPrevented) return;
      le(ae, ...ie);
    }
  } });
  return z;
}
function _$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let ae in ne) ae.startsWith("on") && typeof ne[ae] == "function" ? (Y[ae] != null || (Y[ae] = []), Y[ae].push(ne[ae])) : z[ae] = ne[ae];
  for (let ne in Y) Object.assign(z, { [ne](...ae) {
    let ie = Y[ne];
    for (let se of ie) se == null || se(...ae);
  } });
  return z;
}
function K$1(B) {
  var z;
  return Object.assign(forwardRef(B), { displayName: (z = B.displayName) != null ? z : B.name });
}
function m$4(B) {
  let z = Object.assign({}, B);
  for (let Y in z) z[Y] === void 0 && delete z[Y];
  return z;
}
function h$4(B, z = []) {
  let Y = Object.assign({}, B);
  for (let ne of z) ne in Y && delete Y[ne];
  return Y;
}
function H$3(B) {
  return React__default.version.split(".")[0] >= "19" ? B.props.ref : B.ref;
}
let a$a = "span";
var s$6 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$6 || {});
function l$2(B, z) {
  var Y;
  let { features: ne = 1, ...ae } = B, ie = { ref: z, "aria-hidden": (ne & 2) === 2 ? !0 : (Y = ae["aria-hidden"]) != null ? Y : void 0, hidden: (ne & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ne & 4) === 4 && (ne & 2) !== 2 && { display: "none" } } };
  return L$1()({ ourProps: ie, theirProps: ae, slot: {}, defaultTag: a$a, name: "Hidden" });
}
let f$9 = K$1(l$2), e$3 = createContext(void 0);
function u$6() {
  return useContext(e$3);
}
function r$3(B) {
  let z = B.parentElement, Y = null;
  for (; z && !(z instanceof HTMLFieldSetElement); ) z instanceof HTMLLegendElement && (Y = z), z = z.parentElement;
  let ne = (z == null ? void 0 : z.getAttribute("disabled")) === "";
  return ne && i$6(Y) ? !1 : ne;
}
function i$6(B) {
  if (!B) return !1;
  let z = B.previousElementSibling;
  for (; z !== null; ) {
    if (z instanceof HTMLLegendElement) return !1;
    z = z.previousElementSibling;
  }
  return !0;
}
let u$5 = Symbol();
function T$2(B, z = !0) {
  return Object.assign(B, { [u$5]: z });
}
function y$4(...B) {
  let z = useRef(B);
  useEffect(() => {
    z.current = B;
  }, [B]);
  let Y = o$4((ne) => {
    for (let ae of z.current) ae != null && (typeof ae == "function" ? ae(ne) : ae.current = ne);
  });
  return B.every((ne) => ne == null || (ne == null ? void 0 : ne[u$5])) ? void 0 : Y;
}
let a$9 = createContext(null);
a$9.displayName = "DescriptionContext";
function f$8() {
  let B = useContext(a$9);
  if (B === null) {
    let z = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, f$8), z;
  }
  return B;
}
function w$4() {
  let [B, z] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(Y) {
    let ne = o$4((ie) => (z((se) => [...se, ie]), () => z((se) => {
      let le = se.slice(), ve = le.indexOf(ie);
      return ve !== -1 && le.splice(ve, 1), le;
    }))), ae = useMemo(() => ({ register: ne, slot: Y.slot, name: Y.name, props: Y.props, value: Y.value }), [ne, Y.slot, Y.name, Y.props, Y.value]);
    return React__default.createElement(a$9.Provider, { value: ae }, Y.children);
  }, [z])];
}
let S$2 = "p";
function C$2(B, z) {
  let Y = useId$1(), ne = a$b(), { id: ae = `headlessui-description-${Y}`, ...ie } = B, se = f$8(), le = y$4(z);
  n$3(() => se.register(ae), [ae, se.register]);
  let ve = ne || !1, ge = useMemo(() => ({ ...se.slot, disabled: ve }), [se.slot, ve]), oe = { ref: le, ...se.props, id: ae };
  return L$1()({ ourProps: oe, theirProps: ie, slot: ge, defaultTag: S$2, name: se.name || "Description" });
}
let _$1 = K$1(C$2), H$2 = Object.assign(_$1, {});
var o$3 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$3 || {});
let c$4 = createContext(null);
c$4.displayName = "LabelContext";
function P$1() {
  let B = useContext(c$4);
  if (B === null) {
    let z = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, P$1), z;
  }
  return B;
}
function I$3(B) {
  var z, Y, ne;
  let ae = (Y = (z = useContext(c$4)) == null ? void 0 : z.value) != null ? Y : void 0;
  return ((ne = void 0) != null ? ne : 0) > 0 ? [ae, ...B].filter(Boolean).join(" ") : ae;
}
function K({ inherit: B = !1 } = {}) {
  let z = I$3(), [Y, ne] = useState([]), ae = B ? [z, ...Y].filter(Boolean) : Y;
  return [ae.length > 0 ? ae.join(" ") : void 0, useMemo(() => function(ie) {
    let se = o$4((ve) => (ne((ge) => [...ge, ve]), () => ne((ge) => {
      let oe = ge.slice(), Ee = oe.indexOf(ve);
      return Ee !== -1 && oe.splice(Ee, 1), oe;
    }))), le = useMemo(() => ({ register: se, slot: ie.slot, name: ie.name, props: ie.props, value: ie.value }), [se, ie.slot, ie.name, ie.props, ie.value]);
    return React__default.createElement(c$4.Provider, { value: le }, ie.children);
  }, [ne])];
}
let N$1 = "label";
function G$1(B, z) {
  var Y;
  let ne = useId$1(), ae = P$1(), ie = u$6(), se = a$b(), { id: le = `headlessui-label-${ne}`, htmlFor: ve = ie ?? ((Y = ae.props) == null ? void 0 : Y.htmlFor), passive: ge = !1, ...oe } = B, Ee = y$4(z);
  n$3(() => ae.register(le), [le, ae.register]);
  let Ce = o$4((vt) => {
    let Pt = vt.currentTarget;
    if (Pt instanceof HTMLLabelElement && vt.preventDefault(), ae.props && "onClick" in ae.props && typeof ae.props.onClick == "function" && ae.props.onClick(vt), Pt instanceof HTMLLabelElement) {
      let _t = document.getElementById(Pt.htmlFor);
      if (_t) {
        let kt = _t.getAttribute("disabled");
        if (kt === "true" || kt === "") return;
        let Ot = _t.getAttribute("aria-disabled");
        if (Ot === "true" || Ot === "") return;
        (_t instanceof HTMLInputElement && (_t.type === "radio" || _t.type === "checkbox") || _t.role === "radio" || _t.role === "checkbox" || _t.role === "switch") && _t.click(), _t.focus({ preventScroll: !0 });
      }
    }
  }), Pe = se || !1, Ve = useMemo(() => ({ ...ae.slot, disabled: Pe }), [ae.slot, Pe]), ht = { ref: Ee, ...ae.props, id: le, htmlFor: ve, onClick: Ce };
  return ge && ("onClick" in ht && (delete ht.htmlFor, delete ht.onClick), "onClick" in oe && delete oe.onClick), L$1()({ ourProps: ht, theirProps: oe, slot: Ve, defaultTag: ve ? N$1 : "div", name: ae.name || "Label" });
}
let U$2 = K$1(G$1);
Object.assign(U$2, {});
let e$2 = createContext(() => {
});
function C$1({ value: B, children: z }) {
  return React__default.createElement(e$2.Provider, { value: B }, z);
}
function f$7(B) {
  if (B === null) return { width: 0, height: 0 };
  let { width: z, height: Y } = B.getBoundingClientRect();
  return { width: z, height: Y };
}
function d$2(B, z = !1) {
  let [Y, ne] = useReducer(() => ({}), {}), ae = useMemo(() => f$7(B), [B, Y]);
  return n$3(() => {
    if (!B) return;
    let ie = new ResizeObserver(ne);
    return ie.observe(B), () => {
      ie.disconnect();
    };
  }, [B]), z ? { width: `${ae.width}px`, height: `${ae.height}px` } : ae;
}
let a$8 = class extends Map {
  constructor(z) {
    super(), this.factory = z;
  }
  get(z) {
    let Y = super.get(z);
    return Y === void 0 && (Y = this.factory(z), this.set(z, Y)), Y;
  }
};
function a$7(B, z) {
  let Y = B(), ne = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return Y;
  }, subscribe(ae) {
    return ne.add(ae), () => ne.delete(ae);
  }, dispatch(ae, ...ie) {
    let se = z[ae].call(Y, ...ie);
    se && (Y = se, ne.forEach((le) => le()));
  } };
}
function o$2(B) {
  return useSyncExternalStore(B.subscribe, B.getSnapshot, B.getSnapshot);
}
let p$1 = new a$8(() => a$7(() => [], { ADD(B) {
  return this.includes(B) ? this : [...this, B];
}, REMOVE(B) {
  let z = this.indexOf(B);
  if (z === -1) return this;
  let Y = this.slice();
  return Y.splice(z, 1), Y;
} }));
function x$3(B, z) {
  let Y = p$1.get(z), ne = useId$1(), ae = o$2(Y);
  if (n$3(() => {
    if (B) return Y.dispatch("ADD", ne), () => Y.dispatch("REMOVE", ne);
  }, [Y, B]), !B) return !1;
  let ie = ae.indexOf(ne), se = ae.length;
  return ie === -1 && (ie = se, se += 1), ie === se - 1;
}
let f$6 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();
function h$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 0;
  return u$4.set(B, Y + 1), Y !== 0 ? () => m$3(B) : (f$6.set(B, { "aria-hidden": B.getAttribute("aria-hidden"), inert: B.inert }), B.setAttribute("aria-hidden", "true"), B.inert = !0, () => m$3(B));
}
function m$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 1;
  if (Y === 1 ? u$4.delete(B) : u$4.set(B, Y - 1), Y !== 1) return;
  let ne = f$6.get(B);
  ne && (ne["aria-hidden"] === null ? B.removeAttribute("aria-hidden") : B.setAttribute("aria-hidden", ne["aria-hidden"]), B.inert = ne.inert, f$6.delete(B));
}
function y$3(B, { allowed: z, disallowed: Y } = {}) {
  let ne = x$3(B, "inert-others");
  n$3(() => {
    var ae, ie;
    if (!ne) return;
    let se = o$5();
    for (let ve of (ae = Y == null ? void 0 : Y()) != null ? ae : []) ve && se.add(h$3(ve));
    let le = (ie = z == null ? void 0 : z()) != null ? ie : [];
    for (let ve of le) {
      if (!ve) continue;
      let ge = u$8(ve);
      if (!ge) continue;
      let oe = ve.parentElement;
      for (; oe && oe !== ge.body; ) {
        for (let Ee of oe.children) le.some((Ce) => Ee.contains(Ce)) || se.add(h$3(Ee));
        oe = oe.parentElement;
      }
    }
    return se.dispose;
  }, [ne, z, Y]);
}
function m$2(B, z, Y) {
  let ne = s$7((ae) => {
    let ie = ae.getBoundingClientRect();
    ie.x === 0 && ie.y === 0 && ie.width === 0 && ie.height === 0 && Y();
  });
  useEffect(() => {
    if (!B) return;
    let ae = z === null ? null : z instanceof HTMLElement ? z : z.current;
    if (!ae) return;
    let ie = o$5();
    if (typeof ResizeObserver < "u") {
      let se = new ResizeObserver(() => ne.current(ae));
      se.observe(ae), ie.add(() => se.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let se = new IntersectionObserver(() => ne.current(ae));
      se.observe(ae), ie.add(() => se.disconnect());
    }
    return () => ie.dispose();
  }, [z, ne, B]);
}
let f$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var F$1 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B[B.AutoFocus = 64] = "AutoFocus", B))(F$1 || {}), T$1 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(T$1 || {}), y$2 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(y$2 || {});
function b$2(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(f$5)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$1(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(p)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(h$2 || {});
function A(B, z = 0) {
  var Y;
  return B === ((Y = u$8(B)) == null ? void 0 : Y.body) ? !1 : u$7(z, { 0() {
    return B.matches(f$5);
  }, 1() {
    let ne = B;
    for (; ne !== null; ) {
      if (ne.matches(f$5)) return !0;
      ne = ne.parentElement;
    }
    return !1;
  } });
}
function G(B) {
  let z = u$8(B);
  o$5().nextFrame(() => {
    z && !A(z.activeElement, 0) && I$2(B);
  });
}
var H$1 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(H$1 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I$2(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let w$3 = ["textarea", "input"].join(",");
function O$2(B) {
  var z, Y;
  return (Y = (z = B == null ? void 0 : B.matches) == null ? void 0 : z.call(B, w$3)) != null ? Y : !1;
}
function _(B, z = (Y) => Y) {
  return B.slice().sort((Y, ne) => {
    let ae = z(Y), ie = z(ne);
    if (ae === null || ie === null) return 0;
    let se = ae.compareDocumentPosition(ie);
    return se & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : se & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$3(B, z) {
  return P(b$2(), z, { relativeTo: B });
}
function P(B, z, { sorted: Y = !0, relativeTo: ne = null, skipElements: ae = [] } = {}) {
  let ie = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, se = Array.isArray(B) ? Y ? _(B) : B : z & 64 ? S$1(B) : b$2(B);
  ae.length > 0 && se.length > 1 && (se = se.filter((Pe) => !ae.some((Ve) => Ve != null && "current" in Ve ? (Ve == null ? void 0 : Ve.current) === Pe : Ve === Pe))), ne = ne ?? ie.activeElement;
  let le = (() => {
    if (z & 5) return 1;
    if (z & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ve = (() => {
    if (z & 1) return 0;
    if (z & 2) return Math.max(0, se.indexOf(ne)) - 1;
    if (z & 4) return Math.max(0, se.indexOf(ne)) + 1;
    if (z & 8) return se.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ge = z & 32 ? { preventScroll: !0 } : {}, oe = 0, Ee = se.length, Ce;
  do {
    if (oe >= Ee || oe + Ee <= 0) return 0;
    let Pe = ve + oe;
    if (z & 16) Pe = (Pe + Ee) % Ee;
    else {
      if (Pe < 0) return 3;
      if (Pe >= Ee) return 1;
    }
    Ce = se[Pe], Ce == null || Ce.focus(ge), oe += le;
  } while (Ce !== ie.activeElement);
  return z & 6 && O$2(Ce) && Ce.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$5() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$5();
}
function i$4(B, z, Y, ne) {
  let ae = s$7(Y);
  useEffect(() => {
    if (!B) return;
    function ie(se) {
      ae.current(se);
    }
    return document.addEventListener(z, ie, ne), () => document.removeEventListener(z, ie, ne);
  }, [B, z, ne]);
}
function s$5(B, z, Y, ne) {
  let ae = s$7(Y);
  useEffect(() => {
    if (!B) return;
    function ie(se) {
      ae.current(se);
    }
    return window.addEventListener(z, ie, ne), () => window.removeEventListener(z, ie, ne);
  }, [B, z, ne]);
}
const E$1 = 30;
function R$2(B, z, Y) {
  let ne = x$3(B, "outside-click"), ae = s$7(Y), ie = useCallback(function(ve, ge) {
    if (ve.defaultPrevented) return;
    let oe = ge(ve);
    if (oe === null || !oe.getRootNode().contains(oe) || !oe.isConnected) return;
    let Ee = function Ce(Pe) {
      return typeof Pe == "function" ? Ce(Pe()) : Array.isArray(Pe) || Pe instanceof Set ? Pe : [Pe];
    }(z);
    for (let Ce of Ee) if (Ce !== null && (Ce.contains(oe) || ve.composed && ve.composedPath().includes(Ce))) return;
    return !A(oe, h$2.Loose) && oe.tabIndex !== -1 && ve.preventDefault(), ae.current(ve, oe);
  }, [ae, z]), se = useRef(null);
  i$4(ne, "pointerdown", (ve) => {
    var ge, oe;
    se.current = ((oe = (ge = ve.composedPath) == null ? void 0 : ge.call(ve)) == null ? void 0 : oe[0]) || ve.target;
  }, !0), i$4(ne, "mousedown", (ve) => {
    var ge, oe;
    se.current = ((oe = (ge = ve.composedPath) == null ? void 0 : ge.call(ve)) == null ? void 0 : oe[0]) || ve.target;
  }, !0), i$4(ne, "click", (ve) => {
    n$2() || se.current && (ie(ve, () => se.current), se.current = null);
  }, !0);
  let le = useRef({ x: 0, y: 0 });
  i$4(ne, "touchstart", (ve) => {
    le.current.x = ve.touches[0].clientX, le.current.y = ve.touches[0].clientY;
  }, !0), i$4(ne, "touchend", (ve) => {
    let ge = { x: ve.changedTouches[0].clientX, y: ve.changedTouches[0].clientY };
    if (!(Math.abs(ge.x - le.current.x) >= E$1 || Math.abs(ge.y - le.current.y) >= E$1)) return ie(ve, () => ve.target instanceof HTMLElement ? ve.target : null);
  }, !0), s$5(ne, "blur", (ve) => ie(ve, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$1(...B) {
  return useMemo(() => u$8(...B), [...B]);
}
function E(B, z, Y, ne) {
  let ae = s$7(Y);
  useEffect(() => {
    B = B ?? window;
    function ie(se) {
      ae.current(se);
    }
    return B.addEventListener(z, ie, ne), () => B.removeEventListener(z, ie, ne);
  }, [B, z, ne]);
}
function e$1(B, z) {
  return useMemo(() => {
    var Y;
    if (B.type) return B.type;
    let ne = (Y = B.as) != null ? Y : "button";
    if (typeof ne == "string" && ne.toLowerCase() === "button" || (z == null ? void 0 : z.tagName) === "BUTTON" && !z.hasAttribute("type")) return "button";
  }, [B.type, B.as, z]);
}
function d$1() {
  let B;
  return { before({ doc: z }) {
    var Y;
    let ne = z.documentElement, ae = (Y = z.defaultView) != null ? Y : window;
    B = Math.max(0, ae.innerWidth - ne.clientWidth);
  }, after({ doc: z, d: Y }) {
    let ne = z.documentElement, ae = Math.max(0, ne.clientWidth - ne.offsetWidth), ie = Math.max(0, B - ae);
    Y.style(ne, "paddingRight", `${ie}px`);
  } };
}
function d() {
  return t$2() ? { before({ doc: B, d: z, meta: Y }) {
    function ne(ae) {
      return Y.containers.flatMap((ie) => ie()).some((ie) => ie.contains(ae));
    }
    z.microTask(() => {
      var ae;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let le = o$5();
        le.style(B.documentElement, "scrollBehavior", "auto"), z.add(() => z.microTask(() => le.dispose()));
      }
      let ie = (ae = window.scrollY) != null ? ae : window.pageYOffset, se = null;
      z.addEventListener(B, "click", (le) => {
        if (le.target instanceof HTMLElement) try {
          let ve = le.target.closest("a");
          if (!ve) return;
          let { hash: ge } = new URL(ve.href), oe = B.querySelector(ge);
          oe && !ne(oe) && (se = oe);
        } catch {
        }
      }, !0), z.addEventListener(B, "touchstart", (le) => {
        if (le.target instanceof HTMLElement) if (ne(le.target)) {
          let ve = le.target;
          for (; ve.parentElement && ne(ve.parentElement); ) ve = ve.parentElement;
          z.style(ve, "overscrollBehavior", "contain");
        } else z.style(le.target, "touchAction", "none");
      }), z.addEventListener(B, "touchmove", (le) => {
        if (le.target instanceof HTMLElement) {
          if (le.target.tagName === "INPUT") return;
          if (ne(le.target)) {
            let ve = le.target;
            for (; ve.parentElement && ve.dataset.headlessuiPortal !== "" && !(ve.scrollHeight > ve.clientHeight || ve.scrollWidth > ve.clientWidth); ) ve = ve.parentElement;
            ve.dataset.headlessuiPortal === "" && le.preventDefault();
          } else le.preventDefault();
        }
      }, { passive: !1 }), z.add(() => {
        var le;
        let ve = (le = window.scrollY) != null ? le : window.pageYOffset;
        ie !== ve && window.scrollTo(0, ie), se && se.isConnected && (se.scrollIntoView({ block: "nearest" }), se = null);
      });
    });
  } } : {};
}
function r$2() {
  return { before({ doc: B, d: z }) {
    z.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let z = {};
  for (let Y of B) Object.assign(z, Y(z));
  return z;
}
let a$6 = a$7(() => /* @__PURE__ */ new Map(), { PUSH(B, z) {
  var Y;
  let ne = (Y = this.get(B)) != null ? Y : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return ne.count++, ne.meta.add(z), this.set(B, ne), this;
}, POP(B, z) {
  let Y = this.get(B);
  return Y && (Y.count--, Y.meta.delete(z)), this;
}, SCROLL_PREVENT({ doc: B, d: z, meta: Y }) {
  let ne = { doc: B, d: z, meta: m$1(Y) }, ae = [d(), d$1(), r$2()];
  ae.forEach(({ before: ie }) => ie == null ? void 0 : ie(ne)), ae.forEach(({ after: ie }) => ie == null ? void 0 : ie(ne));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$6.subscribe(() => {
  let B = a$6.getSnapshot(), z = /* @__PURE__ */ new Map();
  for (let [Y] of B) z.set(Y, Y.documentElement.style.overflow);
  for (let Y of B.values()) {
    let ne = z.get(Y.doc) === "hidden", ae = Y.count !== 0;
    (ae && !ne || !ae && ne) && a$6.dispatch(Y.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", Y), Y.count === 0 && a$6.dispatch("TEARDOWN", Y);
  }
});
function a$5(B, z, Y = () => ({ containers: [] })) {
  let ne = o$2(a$6), ae = z ? ne.get(z) : void 0, ie = ae ? ae.count > 0 : !1;
  return n$3(() => {
    if (!(!z || !B)) return a$6.dispatch("PUSH", z, Y), () => a$6.dispatch("POP", z, Y);
  }, [B, z]), ie;
}
function f$4(B, z, Y = () => [document.body]) {
  let ne = x$3(B, "scroll-lock");
  a$5(ne, z, (ae) => {
    var ie;
    return { containers: [...(ie = ae.containers) != null ? ie : [], Y] };
  });
}
function t$1(B) {
  return [B.screenX, B.screenY];
}
function u$3() {
  let B = useRef([-1, -1]);
  return { wasMoved(z) {
    let Y = t$1(z);
    return B.current[0] === Y[0] && B.current[1] === Y[1] ? !1 : (B.current = Y, !0);
  }, update(z) {
    B.current = t$1(z);
  } };
}
function c$3(B = 0) {
  let [z, Y] = useState(B), ne = useCallback((ve) => Y(ve), [z]), ae = useCallback((ve) => Y((ge) => ge | ve), [z]), ie = useCallback((ve) => (z & ve) === ve, [z]), se = useCallback((ve) => Y((ge) => ge & ~ve), [Y]), le = useCallback((ve) => Y((ge) => ge ^ ve), [Y]);
  return { flags: z, setFlag: ne, addFlag: ae, hasFlag: ie, removeFlag: se, toggleFlag: le };
}
var T, b$1;
typeof process$1 < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T = process$1 == null ? void 0 : process$1.env) == null ? void 0 : T.NODE_ENV) === "test" && typeof ((b$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$1.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L = ((B) => (B[B.None = 0] = "None", B[B.Closed = 1] = "Closed", B[B.Enter = 2] = "Enter", B[B.Leave = 4] = "Leave", B))(L || {});
function R$1(B) {
  let z = {};
  for (let Y in B) B[Y] === !0 && (z[`data-${Y}`] = "");
  return z;
}
function x$2(B, z, Y, ne) {
  let [ae, ie] = useState(Y), { hasFlag: se, addFlag: le, removeFlag: ve } = c$3(B && ae ? 3 : 0), ge = useRef(!1), oe = useRef(!1), Ee = p$2();
  return n$3(() => {
    var Ce;
    if (B) {
      if (Y && ie(!0), !z) {
        Y && le(3);
        return;
      }
      return (Ce = ne == null ? void 0 : ne.start) == null || Ce.call(ne, Y), C(z, { inFlight: ge, prepare() {
        oe.current ? oe.current = !1 : oe.current = ge.current, ge.current = !0, !oe.current && (Y ? (le(3), ve(4)) : (le(4), ve(2)));
      }, run() {
        oe.current ? Y ? (ve(3), le(4)) : (ve(4), le(3)) : Y ? ve(1) : le(1);
      }, done() {
        var Pe;
        oe.current && typeof z.getAnimations == "function" && z.getAnimations().length > 0 || (ge.current = !1, ve(7), Y || ie(!1), (Pe = ne == null ? void 0 : ne.end) == null || Pe.call(ne, Y));
      } });
    }
  }, [B, Y, z, Ee]), B ? [ae, { closed: se(1), enter: se(2), leave: se(4), transition: se(2) || se(4) }] : [Y, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(B, { prepare: z, run: Y, done: ne, inFlight: ae }) {
  let ie = o$5();
  return j$2(B, { prepare: z, inFlight: ae }), ie.nextFrame(() => {
    Y(), ie.requestAnimationFrame(() => {
      ie.add(M$2(B, ne));
    });
  }), ie.dispose;
}
function M$2(B, z) {
  var Y, ne;
  let ae = o$5();
  if (!B) return ae.dispose;
  let ie = !1;
  ae.add(() => {
    ie = !0;
  });
  let se = (ne = (Y = B.getAnimations) == null ? void 0 : Y.call(B).filter((le) => le instanceof CSSTransition)) != null ? ne : [];
  return se.length === 0 ? (z(), ae.dispose) : (Promise.allSettled(se.map((le) => le.finished)).then(() => {
    ie || z();
  }), ae.dispose);
}
function j$2(B, { inFlight: z, prepare: Y }) {
  if (z != null && z.current) {
    Y();
    return;
  }
  let ne = B.style.transition;
  B.style.transition = "none", Y(), B.offsetHeight, B.style.transition = ne;
}
function F(B, { container: z, accept: Y, walk: ne }) {
  let ae = useRef(Y), ie = useRef(ne);
  useEffect(() => {
    ae.current = Y, ie.current = ne;
  }, [Y, ne]), n$3(() => {
    if (!z || !B) return;
    let se = u$8(z);
    if (!se) return;
    let le = ae.current, ve = ie.current, ge = Object.assign((Ee) => le(Ee), { acceptNode: le }), oe = se.createTreeWalker(z, NodeFilter.SHOW_ELEMENT, ge, !1);
    for (; oe.nextNode(); ) ve(oe.currentNode);
  }, [z, B, ae, ie]);
}
function m(B, z) {
  let Y = useRef([]), ne = o$4(B);
  useEffect(() => {
    let ae = [...Y.current];
    for (let [ie, se] of z.entries()) if (Y.current[ie] !== se) {
      let le = ne(z, ae);
      return Y.current = z, le;
    }
  }, [ne, ...z]);
}
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(B) {
  return isNode(B) ? (B.nodeName || "").toLowerCase() : "#document";
}
function getWindow(B) {
  var z;
  return (B == null || (z = B.ownerDocument) == null ? void 0 : z.defaultView) || window;
}
function getDocumentElement(B) {
  var z;
  return (z = (isNode(B) ? B.ownerDocument : B.document) || window.document) == null ? void 0 : z.documentElement;
}
function isNode(B) {
  return hasWindow() ? B instanceof Node || B instanceof getWindow(B).Node : !1;
}
function isElement(B) {
  return hasWindow() ? B instanceof Element || B instanceof getWindow(B).Element : !1;
}
function isHTMLElement(B) {
  return hasWindow() ? B instanceof HTMLElement || B instanceof getWindow(B).HTMLElement : !1;
}
function isShadowRoot(B) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : B instanceof ShadowRoot || B instanceof getWindow(B).ShadowRoot;
}
function isOverflowElement(B) {
  const {
    overflow: z,
    overflowX: Y,
    overflowY: ne,
    display: ae
  } = getComputedStyle$1(B);
  return /auto|scroll|overlay|hidden|clip/.test(z + ne + Y) && !["inline", "contents"].includes(ae);
}
function isTableElement(B) {
  return ["table", "td", "th"].includes(getNodeName(B));
}
function isTopLayer(B) {
  return [":popover-open", ":modal"].some((z) => {
    try {
      return B.matches(z);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(B) {
  const z = isWebKit(), Y = isElement(B) ? getComputedStyle$1(B) : B;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((ne) => Y[ne] ? Y[ne] !== "none" : !1) || (Y.containerType ? Y.containerType !== "normal" : !1) || !z && (Y.backdropFilter ? Y.backdropFilter !== "none" : !1) || !z && (Y.filter ? Y.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((ne) => (Y.willChange || "").includes(ne)) || ["paint", "layout", "strict", "content"].some((ne) => (Y.contain || "").includes(ne));
}
function getContainingBlock(B) {
  let z = getParentNode(B);
  for (; isHTMLElement(z) && !isLastTraversableNode(z); ) {
    if (isContainingBlock(z))
      return z;
    if (isTopLayer(z))
      return null;
    z = getParentNode(z);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(B) {
  return ["html", "body", "#document"].includes(getNodeName(B));
}
function getComputedStyle$1(B) {
  return getWindow(B).getComputedStyle(B);
}
function getNodeScroll(B) {
  return isElement(B) ? {
    scrollLeft: B.scrollLeft,
    scrollTop: B.scrollTop
  } : {
    scrollLeft: B.scrollX,
    scrollTop: B.scrollY
  };
}
function getParentNode(B) {
  if (getNodeName(B) === "html")
    return B;
  const z = (
    // Step into the shadow DOM of the parent of a slotted node.
    B.assignedSlot || // DOM Element detected.
    B.parentNode || // ShadowRoot detected.
    isShadowRoot(B) && B.host || // Fallback.
    getDocumentElement(B)
  );
  return isShadowRoot(z) ? z.host : z;
}
function getNearestOverflowAncestor(B) {
  const z = getParentNode(B);
  return isLastTraversableNode(z) ? B.ownerDocument ? B.ownerDocument.body : B.body : isHTMLElement(z) && isOverflowElement(z) ? z : getNearestOverflowAncestor(z);
}
function getOverflowAncestors(B, z, Y) {
  var ne;
  z === void 0 && (z = []), Y === void 0 && (Y = !0);
  const ae = getNearestOverflowAncestor(B), ie = ae === ((ne = B.ownerDocument) == null ? void 0 : ne.body), se = getWindow(ae);
  if (ie) {
    const le = getFrameElement(se);
    return z.concat(se, se.visualViewport || [], isOverflowElement(ae) ? ae : [], le && Y ? getOverflowAncestors(le) : []);
  }
  return z.concat(ae, getOverflowAncestors(ae, [], Y));
}
function getFrameElement(B) {
  return B.parent && Object.getPrototypeOf(B.parent) ? B.frameElement : null;
}
function getUserAgent() {
  const B = navigator.userAgentData;
  return B && Array.isArray(B.brands) ? B.brands.map((z) => {
    let {
      brand: Y,
      version: ne
    } = z;
    return Y + "/" + ne;
  }).join(" ") : navigator.userAgent;
}
const min$1 = Math.min, max$1 = Math.max, round$1 = Math.round, floor$1 = Math.floor, createCoords = (B) => ({
  x: B,
  y: B
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(B, z, Y) {
  return max$1(B, min$1(z, Y));
}
function evaluate(B, z) {
  return typeof B == "function" ? B(z) : B;
}
function getSide(B) {
  return B.split("-")[0];
}
function getAlignment(B) {
  return B.split("-")[1];
}
function getOppositeAxis(B) {
  return B === "x" ? "y" : "x";
}
function getAxisLength(B) {
  return B === "y" ? "height" : "width";
}
function getSideAxis(B) {
  return ["top", "bottom"].includes(getSide(B)) ? "y" : "x";
}
function getAlignmentAxis(B) {
  return getOppositeAxis(getSideAxis(B));
}
function getAlignmentSides(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = getAlignment(B), ae = getAlignmentAxis(B), ie = getAxisLength(ae);
  let se = ae === "x" ? ne === (Y ? "end" : "start") ? "right" : "left" : ne === "start" ? "bottom" : "top";
  return z.reference[ie] > z.floating[ie] && (se = getOppositePlacement(se)), [se, getOppositePlacement(se)];
}
function getExpandedPlacements(B) {
  const z = getOppositePlacement(B);
  return [getOppositeAlignmentPlacement(B), z, getOppositeAlignmentPlacement(z)];
}
function getOppositeAlignmentPlacement(B) {
  return B.replace(/start|end/g, (z) => oppositeAlignmentMap[z]);
}
function getSideList(B, z, Y) {
  const ne = ["left", "right"], ae = ["right", "left"], ie = ["top", "bottom"], se = ["bottom", "top"];
  switch (B) {
    case "top":
    case "bottom":
      return Y ? z ? ae : ne : z ? ne : ae;
    case "left":
    case "right":
      return z ? ie : se;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(B, z, Y, ne) {
  const ae = getAlignment(B);
  let ie = getSideList(getSide(B), Y === "start", ne);
  return ae && (ie = ie.map((se) => se + "-" + ae), z && (ie = ie.concat(ie.map(getOppositeAlignmentPlacement)))), ie;
}
function getOppositePlacement(B) {
  return B.replace(/left|right|bottom|top/g, (z) => oppositeSideMap[z]);
}
function expandPaddingObject(B) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...B
  };
}
function getPaddingObject(B) {
  return typeof B != "number" ? expandPaddingObject(B) : {
    top: B,
    right: B,
    bottom: B,
    left: B
  };
}
function rectToClientRect(B) {
  const {
    x: z,
    y: Y,
    width: ne,
    height: ae
  } = B;
  return {
    width: ne,
    height: ae,
    top: Y,
    left: z,
    right: z + ne,
    bottom: Y + ae,
    x: z,
    y: Y
  };
}
function computeCoordsFromPlacement(B, z, Y) {
  let {
    reference: ne,
    floating: ae
  } = B;
  const ie = getSideAxis(z), se = getAlignmentAxis(z), le = getAxisLength(se), ve = getSide(z), ge = ie === "y", oe = ne.x + ne.width / 2 - ae.width / 2, Ee = ne.y + ne.height / 2 - ae.height / 2, Ce = ne[le] / 2 - ae[le] / 2;
  let Pe;
  switch (ve) {
    case "top":
      Pe = {
        x: oe,
        y: ne.y - ae.height
      };
      break;
    case "bottom":
      Pe = {
        x: oe,
        y: ne.y + ne.height
      };
      break;
    case "right":
      Pe = {
        x: ne.x + ne.width,
        y: Ee
      };
      break;
    case "left":
      Pe = {
        x: ne.x - ae.width,
        y: Ee
      };
      break;
    default:
      Pe = {
        x: ne.x,
        y: ne.y
      };
  }
  switch (getAlignment(z)) {
    case "start":
      Pe[se] -= Ce * (Y && ge ? -1 : 1);
      break;
    case "end":
      Pe[se] += Ce * (Y && ge ? -1 : 1);
      break;
  }
  return Pe;
}
const computePosition$1 = async (B, z, Y) => {
  const {
    placement: ne = "bottom",
    strategy: ae = "absolute",
    middleware: ie = [],
    platform: se
  } = Y, le = ie.filter(Boolean), ve = await (se.isRTL == null ? void 0 : se.isRTL(z));
  let ge = await se.getElementRects({
    reference: B,
    floating: z,
    strategy: ae
  }), {
    x: oe,
    y: Ee
  } = computeCoordsFromPlacement(ge, ne, ve), Ce = ne, Pe = {}, Ve = 0;
  for (let ht = 0; ht < le.length; ht++) {
    const {
      name: vt,
      fn: Pt
    } = le[ht], {
      x: _t,
      y: kt,
      data: Ot,
      reset: Ht
    } = await Pt({
      x: oe,
      y: Ee,
      initialPlacement: ne,
      placement: Ce,
      strategy: ae,
      middlewareData: Pe,
      rects: ge,
      platform: se,
      elements: {
        reference: B,
        floating: z
      }
    });
    oe = _t ?? oe, Ee = kt ?? Ee, Pe = {
      ...Pe,
      [vt]: {
        ...Pe[vt],
        ...Ot
      }
    }, Ht && Ve <= 50 && (Ve++, typeof Ht == "object" && (Ht.placement && (Ce = Ht.placement), Ht.rects && (ge = Ht.rects === !0 ? await se.getElementRects({
      reference: B,
      floating: z,
      strategy: ae
    }) : Ht.rects), {
      x: oe,
      y: Ee
    } = computeCoordsFromPlacement(ge, Ce, ve)), ht = -1);
  }
  return {
    x: oe,
    y: Ee,
    placement: Ce,
    strategy: ae,
    middlewareData: Pe
  };
};
async function detectOverflow$1(B, z) {
  var Y;
  z === void 0 && (z = {});
  const {
    x: ne,
    y: ae,
    platform: ie,
    rects: se,
    elements: le,
    strategy: ve
  } = B, {
    boundary: ge = "clippingAncestors",
    rootBoundary: oe = "viewport",
    elementContext: Ee = "floating",
    altBoundary: Ce = !1,
    padding: Pe = 0
  } = evaluate(z, B), Ve = getPaddingObject(Pe), vt = le[Ce ? Ee === "floating" ? "reference" : "floating" : Ee], Pt = rectToClientRect(await ie.getClippingRect({
    element: (Y = await (ie.isElement == null ? void 0 : ie.isElement(vt))) == null || Y ? vt : vt.contextElement || await (ie.getDocumentElement == null ? void 0 : ie.getDocumentElement(le.floating)),
    boundary: ge,
    rootBoundary: oe,
    strategy: ve
  })), _t = Ee === "floating" ? {
    x: ne,
    y: ae,
    width: se.floating.width,
    height: se.floating.height
  } : se.reference, kt = await (ie.getOffsetParent == null ? void 0 : ie.getOffsetParent(le.floating)), Ot = await (ie.isElement == null ? void 0 : ie.isElement(kt)) ? await (ie.getScale == null ? void 0 : ie.getScale(kt)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Ht = rectToClientRect(ie.convertOffsetParentRelativeRectToViewportRelativeRect ? await ie.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: le,
    rect: _t,
    offsetParent: kt,
    strategy: ve
  }) : _t);
  return {
    top: (Pt.top - Ht.top + Ve.top) / Ot.y,
    bottom: (Ht.bottom - Pt.bottom + Ve.bottom) / Ot.y,
    left: (Pt.left - Ht.left + Ve.left) / Ot.x,
    right: (Ht.right - Pt.right + Ve.right) / Ot.x
  };
}
const flip$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "flip",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: ae,
        middlewareData: ie,
        rects: se,
        initialPlacement: le,
        platform: ve,
        elements: ge
      } = z, {
        mainAxis: oe = !0,
        crossAxis: Ee = !0,
        fallbackPlacements: Ce,
        fallbackStrategy: Pe = "bestFit",
        fallbackAxisSideDirection: Ve = "none",
        flipAlignment: ht = !0,
        ...vt
      } = evaluate(B, z);
      if ((Y = ie.arrow) != null && Y.alignmentOffset)
        return {};
      const Pt = getSide(ae), _t = getSideAxis(le), kt = getSide(le) === le, Ot = await (ve.isRTL == null ? void 0 : ve.isRTL(ge.floating)), Ht = Ce || (kt || !ht ? [getOppositePlacement(le)] : getExpandedPlacements(le)), jt = Ve !== "none";
      !Ce && jt && Ht.push(...getOppositeAxisPlacements(le, ht, Ve, Ot));
      const Yt = [le, ...Ht], Dt = await detectOverflow$1(z, vt), Ct = [];
      let Kt = ((ne = ie.flip) == null ? void 0 : ne.overflows) || [];
      if (oe && Ct.push(Dt[Pt]), Ee) {
        const Ke = getAlignmentSides(ae, se, Ot);
        Ct.push(Dt[Ke[0]], Dt[Ke[1]]);
      }
      if (Kt = [...Kt, {
        placement: ae,
        overflows: Ct
      }], !Ct.every((Ke) => Ke <= 0)) {
        var Nt, Je;
        const Ke = (((Nt = ie.flip) == null ? void 0 : Nt.index) || 0) + 1, Qe = Yt[Ke];
        if (Qe)
          return {
            data: {
              index: Ke,
              overflows: Kt
            },
            reset: {
              placement: Qe
            }
          };
        let bt = (Je = Kt.filter((wt) => wt.overflows[0] <= 0).sort((wt, xt) => wt.overflows[1] - xt.overflows[1])[0]) == null ? void 0 : Je.placement;
        if (!bt)
          switch (Pe) {
            case "bestFit": {
              var Xe;
              const wt = (Xe = Kt.filter((xt) => {
                if (jt) {
                  const Bt = getSideAxis(xt.placement);
                  return Bt === _t || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  Bt === "y";
                }
                return !0;
              }).map((xt) => [xt.placement, xt.overflows.filter((Bt) => Bt > 0).reduce((Bt, $t) => Bt + $t, 0)]).sort((xt, Bt) => xt[1] - Bt[1])[0]) == null ? void 0 : Xe[0];
              wt && (bt = wt);
              break;
            }
            case "initialPlacement":
              bt = le;
              break;
          }
        if (ae !== bt)
          return {
            reset: {
              placement: bt
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(B, z) {
  const {
    placement: Y,
    platform: ne,
    elements: ae
  } = B, ie = await (ne.isRTL == null ? void 0 : ne.isRTL(ae.floating)), se = getSide(Y), le = getAlignment(Y), ve = getSideAxis(Y) === "y", ge = ["left", "top"].includes(se) ? -1 : 1, oe = ie && ve ? -1 : 1, Ee = evaluate(z, B);
  let {
    mainAxis: Ce,
    crossAxis: Pe,
    alignmentAxis: Ve
  } = typeof Ee == "number" ? {
    mainAxis: Ee,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: Ee.mainAxis || 0,
    crossAxis: Ee.crossAxis || 0,
    alignmentAxis: Ee.alignmentAxis
  };
  return le && typeof Ve == "number" && (Pe = le === "end" ? Ve * -1 : Ve), ve ? {
    x: Pe * oe,
    y: Ce * ge
  } : {
    x: Ce * ge,
    y: Pe * oe
  };
}
const offset$2 = function(B) {
  return B === void 0 && (B = 0), {
    name: "offset",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        x: ae,
        y: ie,
        placement: se,
        middlewareData: le
      } = z, ve = await convertValueToCoords(z, B);
      return se === ((Y = le.offset) == null ? void 0 : Y.placement) && (ne = le.arrow) != null && ne.alignmentOffset ? {} : {
        x: ae + ve.x,
        y: ie + ve.y,
        data: {
          ...ve,
          placement: se
        }
      };
    }
  };
}, shift$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "shift",
    options: B,
    async fn(z) {
      const {
        x: Y,
        y: ne,
        placement: ae
      } = z, {
        mainAxis: ie = !0,
        crossAxis: se = !1,
        limiter: le = {
          fn: (vt) => {
            let {
              x: Pt,
              y: _t
            } = vt;
            return {
              x: Pt,
              y: _t
            };
          }
        },
        ...ve
      } = evaluate(B, z), ge = {
        x: Y,
        y: ne
      }, oe = await detectOverflow$1(z, ve), Ee = getSideAxis(getSide(ae)), Ce = getOppositeAxis(Ee);
      let Pe = ge[Ce], Ve = ge[Ee];
      if (ie) {
        const vt = Ce === "y" ? "top" : "left", Pt = Ce === "y" ? "bottom" : "right", _t = Pe + oe[vt], kt = Pe - oe[Pt];
        Pe = clamp(_t, Pe, kt);
      }
      if (se) {
        const vt = Ee === "y" ? "top" : "left", Pt = Ee === "y" ? "bottom" : "right", _t = Ve + oe[vt], kt = Ve - oe[Pt];
        Ve = clamp(_t, Ve, kt);
      }
      const ht = le.fn({
        ...z,
        [Ce]: Pe,
        [Ee]: Ve
      });
      return {
        ...ht,
        data: {
          x: ht.x - Y,
          y: ht.y - ne,
          enabled: {
            [Ce]: ie,
            [Ee]: se
          }
        }
      };
    }
  };
}, size$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "size",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: ae,
        rects: ie,
        platform: se,
        elements: le
      } = z, {
        apply: ve = () => {
        },
        ...ge
      } = evaluate(B, z), oe = await detectOverflow$1(z, ge), Ee = getSide(ae), Ce = getAlignment(ae), Pe = getSideAxis(ae) === "y", {
        width: Ve,
        height: ht
      } = ie.floating;
      let vt, Pt;
      Ee === "top" || Ee === "bottom" ? (vt = Ee, Pt = Ce === (await (se.isRTL == null ? void 0 : se.isRTL(le.floating)) ? "start" : "end") ? "left" : "right") : (Pt = Ee, vt = Ce === "end" ? "top" : "bottom");
      const _t = ht - oe.top - oe.bottom, kt = Ve - oe.left - oe.right, Ot = min$1(ht - oe[vt], _t), Ht = min$1(Ve - oe[Pt], kt), jt = !z.middlewareData.shift;
      let Yt = Ot, Dt = Ht;
      if ((Y = z.middlewareData.shift) != null && Y.enabled.x && (Dt = kt), (ne = z.middlewareData.shift) != null && ne.enabled.y && (Yt = _t), jt && !Ce) {
        const Kt = max$1(oe.left, 0), Nt = max$1(oe.right, 0), Je = max$1(oe.top, 0), Xe = max$1(oe.bottom, 0);
        Pe ? Dt = Ve - 2 * (Kt !== 0 || Nt !== 0 ? Kt + Nt : max$1(oe.left, oe.right)) : Yt = ht - 2 * (Je !== 0 || Xe !== 0 ? Je + Xe : max$1(oe.top, oe.bottom));
      }
      await ve({
        ...z,
        availableWidth: Dt,
        availableHeight: Yt
      });
      const Ct = await se.getDimensions(le.floating);
      return Ve !== Ct.width || ht !== Ct.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(B) {
  const z = getComputedStyle$1(B);
  let Y = parseFloat(z.width) || 0, ne = parseFloat(z.height) || 0;
  const ae = isHTMLElement(B), ie = ae ? B.offsetWidth : Y, se = ae ? B.offsetHeight : ne, le = round$1(Y) !== ie || round$1(ne) !== se;
  return le && (Y = ie, ne = se), {
    width: Y,
    height: ne,
    $: le
  };
}
function unwrapElement(B) {
  return isElement(B) ? B : B.contextElement;
}
function getScale(B) {
  const z = unwrapElement(B);
  if (!isHTMLElement(z))
    return createCoords(1);
  const Y = z.getBoundingClientRect(), {
    width: ne,
    height: ae,
    $: ie
  } = getCssDimensions(z);
  let se = (ie ? round$1(Y.width) : Y.width) / ne, le = (ie ? round$1(Y.height) : Y.height) / ae;
  return (!se || !Number.isFinite(se)) && (se = 1), (!le || !Number.isFinite(le)) && (le = 1), {
    x: se,
    y: le
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(B) {
  const z = getWindow(B);
  return !isWebKit() || !z.visualViewport ? noOffsets : {
    x: z.visualViewport.offsetLeft,
    y: z.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(B, z, Y) {
  return z === void 0 && (z = !1), !Y || z && Y !== getWindow(B) ? !1 : z;
}
function getBoundingClientRect(B, z, Y, ne) {
  z === void 0 && (z = !1), Y === void 0 && (Y = !1);
  const ae = B.getBoundingClientRect(), ie = unwrapElement(B);
  let se = createCoords(1);
  z && (ne ? isElement(ne) && (se = getScale(ne)) : se = getScale(B));
  const le = shouldAddVisualOffsets(ie, Y, ne) ? getVisualOffsets(ie) : createCoords(0);
  let ve = (ae.left + le.x) / se.x, ge = (ae.top + le.y) / se.y, oe = ae.width / se.x, Ee = ae.height / se.y;
  if (ie) {
    const Ce = getWindow(ie), Pe = ne && isElement(ne) ? getWindow(ne) : ne;
    let Ve = Ce, ht = getFrameElement(Ve);
    for (; ht && ne && Pe !== Ve; ) {
      const vt = getScale(ht), Pt = ht.getBoundingClientRect(), _t = getComputedStyle$1(ht), kt = Pt.left + (ht.clientLeft + parseFloat(_t.paddingLeft)) * vt.x, Ot = Pt.top + (ht.clientTop + parseFloat(_t.paddingTop)) * vt.y;
      ve *= vt.x, ge *= vt.y, oe *= vt.x, Ee *= vt.y, ve += kt, ge += Ot, Ve = getWindow(ht), ht = getFrameElement(Ve);
    }
  }
  return rectToClientRect({
    width: oe,
    height: Ee,
    x: ve,
    y: ge
  });
}
function getWindowScrollBarX(B, z) {
  const Y = getNodeScroll(B).scrollLeft;
  return z ? z.left + Y : getBoundingClientRect(getDocumentElement(B)).left + Y;
}
function getHTMLOffset(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = B.getBoundingClientRect(), ae = ne.left + z.scrollLeft - (Y ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(B, ne)
  )), ie = ne.top + z.scrollTop;
  return {
    x: ae,
    y: ie
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(B) {
  let {
    elements: z,
    rect: Y,
    offsetParent: ne,
    strategy: ae
  } = B;
  const ie = ae === "fixed", se = getDocumentElement(ne), le = z ? isTopLayer(z.floating) : !1;
  if (ne === se || le && ie)
    return Y;
  let ve = {
    scrollLeft: 0,
    scrollTop: 0
  }, ge = createCoords(1);
  const oe = createCoords(0), Ee = isHTMLElement(ne);
  if ((Ee || !Ee && !ie) && ((getNodeName(ne) !== "body" || isOverflowElement(se)) && (ve = getNodeScroll(ne)), isHTMLElement(ne))) {
    const Pe = getBoundingClientRect(ne);
    ge = getScale(ne), oe.x = Pe.x + ne.clientLeft, oe.y = Pe.y + ne.clientTop;
  }
  const Ce = se && !Ee && !ie ? getHTMLOffset(se, ve, !0) : createCoords(0);
  return {
    width: Y.width * ge.x,
    height: Y.height * ge.y,
    x: Y.x * ge.x - ve.scrollLeft * ge.x + oe.x + Ce.x,
    y: Y.y * ge.y - ve.scrollTop * ge.y + oe.y + Ce.y
  };
}
function getClientRects(B) {
  return Array.from(B.getClientRects());
}
function getDocumentRect(B) {
  const z = getDocumentElement(B), Y = getNodeScroll(B), ne = B.ownerDocument.body, ae = max$1(z.scrollWidth, z.clientWidth, ne.scrollWidth, ne.clientWidth), ie = max$1(z.scrollHeight, z.clientHeight, ne.scrollHeight, ne.clientHeight);
  let se = -Y.scrollLeft + getWindowScrollBarX(B);
  const le = -Y.scrollTop;
  return getComputedStyle$1(ne).direction === "rtl" && (se += max$1(z.clientWidth, ne.clientWidth) - ae), {
    width: ae,
    height: ie,
    x: se,
    y: le
  };
}
function getViewportRect(B, z) {
  const Y = getWindow(B), ne = getDocumentElement(B), ae = Y.visualViewport;
  let ie = ne.clientWidth, se = ne.clientHeight, le = 0, ve = 0;
  if (ae) {
    ie = ae.width, se = ae.height;
    const ge = isWebKit();
    (!ge || ge && z === "fixed") && (le = ae.offsetLeft, ve = ae.offsetTop);
  }
  return {
    width: ie,
    height: se,
    x: le,
    y: ve
  };
}
function getInnerBoundingClientRect(B, z) {
  const Y = getBoundingClientRect(B, !0, z === "fixed"), ne = Y.top + B.clientTop, ae = Y.left + B.clientLeft, ie = isHTMLElement(B) ? getScale(B) : createCoords(1), se = B.clientWidth * ie.x, le = B.clientHeight * ie.y, ve = ae * ie.x, ge = ne * ie.y;
  return {
    width: se,
    height: le,
    x: ve,
    y: ge
  };
}
function getClientRectFromClippingAncestor(B, z, Y) {
  let ne;
  if (z === "viewport")
    ne = getViewportRect(B, Y);
  else if (z === "document")
    ne = getDocumentRect(getDocumentElement(B));
  else if (isElement(z))
    ne = getInnerBoundingClientRect(z, Y);
  else {
    const ae = getVisualOffsets(B);
    ne = {
      x: z.x - ae.x,
      y: z.y - ae.y,
      width: z.width,
      height: z.height
    };
  }
  return rectToClientRect(ne);
}
function hasFixedPositionAncestor(B, z) {
  const Y = getParentNode(B);
  return Y === z || !isElement(Y) || isLastTraversableNode(Y) ? !1 : getComputedStyle$1(Y).position === "fixed" || hasFixedPositionAncestor(Y, z);
}
function getClippingElementAncestors(B, z) {
  const Y = z.get(B);
  if (Y)
    return Y;
  let ne = getOverflowAncestors(B, [], !1).filter((le) => isElement(le) && getNodeName(le) !== "body"), ae = null;
  const ie = getComputedStyle$1(B).position === "fixed";
  let se = ie ? getParentNode(B) : B;
  for (; isElement(se) && !isLastTraversableNode(se); ) {
    const le = getComputedStyle$1(se), ve = isContainingBlock(se);
    !ve && le.position === "fixed" && (ae = null), (ie ? !ve && !ae : !ve && le.position === "static" && !!ae && ["absolute", "fixed"].includes(ae.position) || isOverflowElement(se) && !ve && hasFixedPositionAncestor(B, se)) ? ne = ne.filter((oe) => oe !== se) : ae = le, se = getParentNode(se);
  }
  return z.set(B, ne), ne;
}
function getClippingRect(B) {
  let {
    element: z,
    boundary: Y,
    rootBoundary: ne,
    strategy: ae
  } = B;
  const se = [...Y === "clippingAncestors" ? isTopLayer(z) ? [] : getClippingElementAncestors(z, this._c) : [].concat(Y), ne], le = se[0], ve = se.reduce((ge, oe) => {
    const Ee = getClientRectFromClippingAncestor(z, oe, ae);
    return ge.top = max$1(Ee.top, ge.top), ge.right = min$1(Ee.right, ge.right), ge.bottom = min$1(Ee.bottom, ge.bottom), ge.left = max$1(Ee.left, ge.left), ge;
  }, getClientRectFromClippingAncestor(z, le, ae));
  return {
    width: ve.right - ve.left,
    height: ve.bottom - ve.top,
    x: ve.left,
    y: ve.top
  };
}
function getDimensions(B) {
  const {
    width: z,
    height: Y
  } = getCssDimensions(B);
  return {
    width: z,
    height: Y
  };
}
function getRectRelativeToOffsetParent(B, z, Y) {
  const ne = isHTMLElement(z), ae = getDocumentElement(z), ie = Y === "fixed", se = getBoundingClientRect(B, !0, ie, z);
  let le = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ve = createCoords(0);
  if (ne || !ne && !ie)
    if ((getNodeName(z) !== "body" || isOverflowElement(ae)) && (le = getNodeScroll(z)), ne) {
      const Ce = getBoundingClientRect(z, !0, ie, z);
      ve.x = Ce.x + z.clientLeft, ve.y = Ce.y + z.clientTop;
    } else ae && (ve.x = getWindowScrollBarX(ae));
  const ge = ae && !ne && !ie ? getHTMLOffset(ae, le) : createCoords(0), oe = se.left + le.scrollLeft - ve.x - ge.x, Ee = se.top + le.scrollTop - ve.y - ge.y;
  return {
    x: oe,
    y: Ee,
    width: se.width,
    height: se.height
  };
}
function isStaticPositioned(B) {
  return getComputedStyle$1(B).position === "static";
}
function getTrueOffsetParent(B, z) {
  if (!isHTMLElement(B) || getComputedStyle$1(B).position === "fixed")
    return null;
  if (z)
    return z(B);
  let Y = B.offsetParent;
  return getDocumentElement(B) === Y && (Y = Y.ownerDocument.body), Y;
}
function getOffsetParent(B, z) {
  const Y = getWindow(B);
  if (isTopLayer(B))
    return Y;
  if (!isHTMLElement(B)) {
    let ae = getParentNode(B);
    for (; ae && !isLastTraversableNode(ae); ) {
      if (isElement(ae) && !isStaticPositioned(ae))
        return ae;
      ae = getParentNode(ae);
    }
    return Y;
  }
  let ne = getTrueOffsetParent(B, z);
  for (; ne && isTableElement(ne) && isStaticPositioned(ne); )
    ne = getTrueOffsetParent(ne, z);
  return ne && isLastTraversableNode(ne) && isStaticPositioned(ne) && !isContainingBlock(ne) ? Y : ne || getContainingBlock(B) || Y;
}
const getElementRects = async function(B) {
  const z = this.getOffsetParent || getOffsetParent, Y = this.getDimensions, ne = await Y(B.floating);
  return {
    reference: getRectRelativeToOffsetParent(B.reference, await z(B.floating), B.strategy),
    floating: {
      x: 0,
      y: 0,
      width: ne.width,
      height: ne.height
    }
  };
};
function isRTL(B) {
  return getComputedStyle$1(B).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(B, z) {
  return B.x === z.x && B.y === z.y && B.width === z.width && B.height === z.height;
}
function observeMove(B, z) {
  let Y = null, ne;
  const ae = getDocumentElement(B);
  function ie() {
    var le;
    clearTimeout(ne), (le = Y) == null || le.disconnect(), Y = null;
  }
  function se(le, ve) {
    le === void 0 && (le = !1), ve === void 0 && (ve = 1), ie();
    const ge = B.getBoundingClientRect(), {
      left: oe,
      top: Ee,
      width: Ce,
      height: Pe
    } = ge;
    if (le || z(), !Ce || !Pe)
      return;
    const Ve = floor$1(Ee), ht = floor$1(ae.clientWidth - (oe + Ce)), vt = floor$1(ae.clientHeight - (Ee + Pe)), Pt = floor$1(oe), kt = {
      rootMargin: -Ve + "px " + -ht + "px " + -vt + "px " + -Pt + "px",
      threshold: max$1(0, min$1(1, ve)) || 1
    };
    let Ot = !0;
    function Ht(jt) {
      const Yt = jt[0].intersectionRatio;
      if (Yt !== ve) {
        if (!Ot)
          return se();
        Yt ? se(!1, Yt) : ne = setTimeout(() => {
          se(!1, 1e-7);
        }, 1e3);
      }
      Yt === 1 && !rectsAreEqual(ge, B.getBoundingClientRect()) && se(), Ot = !1;
    }
    try {
      Y = new IntersectionObserver(Ht, {
        ...kt,
        // Handle <iframe>s
        root: ae.ownerDocument
      });
    } catch {
      Y = new IntersectionObserver(Ht, kt);
    }
    Y.observe(B);
  }
  return se(!0), ie;
}
function autoUpdate(B, z, Y, ne) {
  ne === void 0 && (ne = {});
  const {
    ancestorScroll: ae = !0,
    ancestorResize: ie = !0,
    elementResize: se = typeof ResizeObserver == "function",
    layoutShift: le = typeof IntersectionObserver == "function",
    animationFrame: ve = !1
  } = ne, ge = unwrapElement(B), oe = ae || ie ? [...ge ? getOverflowAncestors(ge) : [], ...getOverflowAncestors(z)] : [];
  oe.forEach((Pt) => {
    ae && Pt.addEventListener("scroll", Y, {
      passive: !0
    }), ie && Pt.addEventListener("resize", Y);
  });
  const Ee = ge && le ? observeMove(ge, Y) : null;
  let Ce = -1, Pe = null;
  se && (Pe = new ResizeObserver((Pt) => {
    let [_t] = Pt;
    _t && _t.target === ge && Pe && (Pe.unobserve(z), cancelAnimationFrame(Ce), Ce = requestAnimationFrame(() => {
      var kt;
      (kt = Pe) == null || kt.observe(z);
    })), Y();
  }), ge && !ve && Pe.observe(ge), Pe.observe(z));
  let Ve, ht = ve ? getBoundingClientRect(B) : null;
  ve && vt();
  function vt() {
    const Pt = getBoundingClientRect(B);
    ht && !rectsAreEqual(ht, Pt) && Y(), ht = Pt, Ve = requestAnimationFrame(vt);
  }
  return Y(), () => {
    var Pt;
    oe.forEach((_t) => {
      ae && _t.removeEventListener("scroll", Y), ie && _t.removeEventListener("resize", Y);
    }), Ee == null || Ee(), (Pt = Pe) == null || Pt.disconnect(), Pe = null, ve && cancelAnimationFrame(Ve);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, computePosition = (B, z, Y) => {
  const ne = /* @__PURE__ */ new Map(), ae = {
    platform,
    ...Y
  }, ie = {
    ...ae.platform,
    _c: ne
  };
  return computePosition$1(B, z, {
    ...ae,
    platform: ie
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(B, z) {
  if (B === z)
    return !0;
  if (typeof B != typeof z)
    return !1;
  if (typeof B == "function" && B.toString() === z.toString())
    return !0;
  let Y, ne, ae;
  if (B && z && typeof B == "object") {
    if (Array.isArray(B)) {
      if (Y = B.length, Y !== z.length) return !1;
      for (ne = Y; ne-- !== 0; )
        if (!deepEqual(B[ne], z[ne]))
          return !1;
      return !0;
    }
    if (ae = Object.keys(B), Y = ae.length, Y !== Object.keys(z).length)
      return !1;
    for (ne = Y; ne-- !== 0; )
      if (!{}.hasOwnProperty.call(z, ae[ne]))
        return !1;
    for (ne = Y; ne-- !== 0; ) {
      const ie = ae[ne];
      if (!(ie === "_owner" && B.$$typeof) && !deepEqual(B[ie], z[ie]))
        return !1;
    }
    return !0;
  }
  return B !== B && z !== z;
}
function getDPR(B) {
  return typeof window > "u" ? 1 : (B.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(B, z) {
  const Y = getDPR(B);
  return Math.round(z * Y) / Y;
}
function useLatestRef(B) {
  const z = React.useRef(B);
  return index$1(() => {
    z.current = B;
  }), z;
}
function useFloating$1(B) {
  B === void 0 && (B = {});
  const {
    placement: z = "bottom",
    strategy: Y = "absolute",
    middleware: ne = [],
    platform: ae,
    elements: {
      reference: ie,
      floating: se
    } = {},
    transform: le = !0,
    whileElementsMounted: ve,
    open: ge
  } = B, [oe, Ee] = React.useState({
    x: 0,
    y: 0,
    strategy: Y,
    placement: z,
    middlewareData: {},
    isPositioned: !1
  }), [Ce, Pe] = React.useState(ne);
  deepEqual(Ce, ne) || Pe(ne);
  const [Ve, ht] = React.useState(null), [vt, Pt] = React.useState(null), _t = React.useCallback((xt) => {
    xt !== jt.current && (jt.current = xt, ht(xt));
  }, []), kt = React.useCallback((xt) => {
    xt !== Yt.current && (Yt.current = xt, Pt(xt));
  }, []), Ot = ie || Ve, Ht = se || vt, jt = React.useRef(null), Yt = React.useRef(null), Dt = React.useRef(oe), Ct = ve != null, Kt = useLatestRef(ve), Nt = useLatestRef(ae), Je = useLatestRef(ge), Xe = React.useCallback(() => {
    if (!jt.current || !Yt.current)
      return;
    const xt = {
      placement: z,
      strategy: Y,
      middleware: Ce
    };
    Nt.current && (xt.platform = Nt.current), computePosition(jt.current, Yt.current, xt).then((Bt) => {
      const $t = {
        ...Bt,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Je.current !== !1
      };
      Ke.current && !deepEqual(Dt.current, $t) && (Dt.current = $t, ReactDOM.flushSync(() => {
        Ee($t);
      }));
    });
  }, [Ce, z, Y, Nt, Je]);
  index$1(() => {
    ge === !1 && Dt.current.isPositioned && (Dt.current.isPositioned = !1, Ee((xt) => ({
      ...xt,
      isPositioned: !1
    })));
  }, [ge]);
  const Ke = React.useRef(!1);
  index$1(() => (Ke.current = !0, () => {
    Ke.current = !1;
  }), []), index$1(() => {
    if (Ot && (jt.current = Ot), Ht && (Yt.current = Ht), Ot && Ht) {
      if (Kt.current)
        return Kt.current(Ot, Ht, Xe);
      Xe();
    }
  }, [Ot, Ht, Xe, Kt, Ct]);
  const Qe = React.useMemo(() => ({
    reference: jt,
    floating: Yt,
    setReference: _t,
    setFloating: kt
  }), [_t, kt]), bt = React.useMemo(() => ({
    reference: Ot,
    floating: Ht
  }), [Ot, Ht]), wt = React.useMemo(() => {
    const xt = {
      position: Y,
      left: 0,
      top: 0
    };
    if (!bt.floating)
      return xt;
    const Bt = roundByDPR(bt.floating, oe.x), $t = roundByDPR(bt.floating, oe.y);
    return le ? {
      ...xt,
      transform: "translate(" + Bt + "px, " + $t + "px)",
      ...getDPR(bt.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: Y,
      left: Bt,
      top: $t
    };
  }, [Y, le, bt.floating, oe.x, oe.y]);
  return React.useMemo(() => ({
    ...oe,
    update: Xe,
    refs: Qe,
    elements: bt,
    floatingStyles: wt
  }), [oe, Xe, Qe, bt, wt]);
}
const offset = (B, z) => ({
  ...offset$1(B),
  options: [B, z]
}), shift = (B, z) => ({
  ...shift$1(B),
  options: [B, z]
}), flip = (B, z) => ({
  ...flip$1(B),
  options: [B, z]
}), size = (B, z) => ({
  ...size$1(B),
  options: [B, z]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((B) => B());
function useEffectEvent(B) {
  const z = React.useRef(() => {
    if (process$1.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    z.current = B;
  }), React.useCallback(function() {
    for (var Y = arguments.length, ne = new Array(Y), ae = 0; ae < Y; ae++)
      ne[ae] = arguments[ae];
    return z.current == null ? void 0 : z.current(...ne);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [B, z] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    B == null && z(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), B;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
process$1.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const ae = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(ae))) {
    var ie;
    (ie = devMessageSet) == null || ie.add(ae), console.warn(ae);
  }
}
function error() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const ae = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(ae))) {
    var ie;
    (ie = devMessageSet) == null || ie.add(ae), console.error(ae);
  }
}
function createPubSub() {
  const B = /* @__PURE__ */ new Map();
  return {
    emit(z, Y) {
      var ne;
      (ne = B.get(z)) == null || ne.forEach((ae) => ae(Y));
    },
    on(z, Y) {
      B.set(z, [...B.get(z) || [], Y]);
    },
    off(z, Y) {
      var ne;
      B.set(z, ((ne = B.get(z)) == null ? void 0 : ne.filter((ae) => ae !== Y)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var B;
  return ((B = React.useContext(FloatingNodeContext)) == null ? void 0 : B.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(B) {
  const {
    open: z = !1,
    onOpenChange: Y,
    elements: ne
  } = B, ae = useId(), ie = React.useRef({}), [se] = React.useState(() => createPubSub()), le = useFloatingParentNodeId() != null;
  if (process$1.env.NODE_ENV !== "production") {
    const Pe = ne.reference;
    Pe && !isElement(Pe) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [ve, ge] = React.useState(ne.reference), oe = useEffectEvent((Pe, Ve, ht) => {
    ie.current.openEvent = Pe ? Ve : void 0, se.emit("openchange", {
      open: Pe,
      event: Ve,
      reason: ht,
      nested: le
    }), Y == null || Y(Pe, Ve, ht);
  }), Ee = React.useMemo(() => ({
    setPositionReference: ge
  }), []), Ce = React.useMemo(() => ({
    reference: ve || ne.reference || null,
    floating: ne.floating || null,
    domReference: ne.reference
  }), [ve, ne.reference, ne.floating]);
  return React.useMemo(() => ({
    dataRef: ie,
    open: z,
    onOpenChange: oe,
    elements: Ce,
    events: se,
    floatingId: ae,
    refs: Ee
  }), [z, oe, Ce, se, ae, Ee]);
}
function useFloating(B) {
  B === void 0 && (B = {});
  const {
    nodeId: z
  } = B, Y = useFloatingRootContext({
    ...B,
    elements: {
      reference: null,
      floating: null,
      ...B.elements
    }
  }), ne = B.rootContext || Y, ae = ne.elements, [ie, se] = React.useState(null), [le, ve] = React.useState(null), oe = (ae == null ? void 0 : ae.domReference) || ie, Ee = React.useRef(null), Ce = useFloatingTree();
  index(() => {
    oe && (Ee.current = oe);
  }, [oe]);
  const Pe = useFloating$1({
    ...B,
    elements: {
      ...ae,
      ...le && {
        reference: le
      }
    }
  }), Ve = React.useCallback((kt) => {
    const Ot = isElement(kt) ? {
      getBoundingClientRect: () => kt.getBoundingClientRect(),
      contextElement: kt
    } : kt;
    ve(Ot), Pe.refs.setReference(Ot);
  }, [Pe.refs]), ht = React.useCallback((kt) => {
    (isElement(kt) || kt === null) && (Ee.current = kt, se(kt)), (isElement(Pe.refs.reference.current) || Pe.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    kt !== null && !isElement(kt)) && Pe.refs.setReference(kt);
  }, [Pe.refs]), vt = React.useMemo(() => ({
    ...Pe.refs,
    setReference: ht,
    setPositionReference: Ve,
    domReference: Ee
  }), [Pe.refs, ht, Ve]), Pt = React.useMemo(() => ({
    ...Pe.elements,
    domReference: oe
  }), [Pe.elements, oe]), _t = React.useMemo(() => ({
    ...Pe,
    ...ne,
    refs: vt,
    elements: Pt,
    nodeId: z
  }), [Pe, vt, Pt, z, ne]);
  return index(() => {
    ne.dataRef.current.floatingContext = _t;
    const kt = Ce == null ? void 0 : Ce.nodesRef.current.find((Ot) => Ot.id === z);
    kt && (kt.context = _t);
  }), React.useMemo(() => ({
    ...Pe,
    context: _t,
    refs: vt,
    elements: Pt
  }), [Pe, vt, Pt, _t]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(B, z, Y) {
  const ne = /* @__PURE__ */ new Map(), ae = Y === "item";
  let ie = B;
  if (ae && B) {
    const {
      [ACTIVE_KEY]: se,
      [SELECTED_KEY]: le,
      ...ve
    } = B;
    ie = ve;
  }
  return {
    ...Y === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...ie,
    ...z.map((se) => {
      const le = se ? se[Y] : null;
      return typeof le == "function" ? B ? le(B) : null : le;
    }).concat(B).reduce((se, le) => (le && Object.entries(le).forEach((ve) => {
      let [ge, oe] = ve;
      if (!(ae && [ACTIVE_KEY, SELECTED_KEY].includes(ge)))
        if (ge.indexOf("on") === 0) {
          if (ne.has(ge) || ne.set(ge, []), typeof oe == "function") {
            var Ee;
            (Ee = ne.get(ge)) == null || Ee.push(oe), se[ge] = function() {
              for (var Ce, Pe = arguments.length, Ve = new Array(Pe), ht = 0; ht < Pe; ht++)
                Ve[ht] = arguments[ht];
              return (Ce = ne.get(ge)) == null ? void 0 : Ce.map((vt) => vt(...Ve)).find((vt) => vt !== void 0);
            };
          }
        } else
          se[ge] = oe;
    }), se), {})
  };
}
function useInteractions(B) {
  B === void 0 && (B = []);
  const z = B.map((le) => le == null ? void 0 : le.reference), Y = B.map((le) => le == null ? void 0 : le.floating), ne = B.map((le) => le == null ? void 0 : le.item), ae = React.useCallback(
    (le) => mergeProps(le, B, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    z
  ), ie = React.useCallback(
    (le) => mergeProps(le, B, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Y
  ), se = React.useCallback(
    (le) => mergeProps(le, B, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    ne
  );
  return React.useMemo(() => ({
    getReferenceProps: ae,
    getFloatingProps: ie,
    getItemProps: se
  }), [ae, ie, se]);
}
function getArgsWithCustomFloatingHeight(B, z) {
  return {
    ...B,
    rects: {
      ...B.rects,
      floating: {
        ...B.rects.floating,
        height: z
      }
    }
  };
}
const inner = (B) => ({
  name: "inner",
  options: B,
  async fn(z) {
    const {
      listRef: Y,
      overflowRef: ne,
      onFallbackChange: ae,
      offset: ie = 0,
      index: se = 0,
      minItemsVisible: le = 4,
      referenceOverflowThreshold: ve = 0,
      scrollRef: ge,
      ...oe
    } = evaluate(B, z), {
      rects: Ee,
      elements: {
        floating: Ce
      }
    } = z, Pe = Y.current[se], Ve = (ge == null ? void 0 : ge.current) || Ce, ht = Ce.clientTop || Ve.clientTop, vt = Ce.clientTop !== 0, Pt = Ve.clientTop !== 0, _t = Ce === Ve;
    if (process$1.env.NODE_ENV !== "production" && (z.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.")), !Pe)
      return {};
    const kt = {
      ...z,
      ...await offset(-Pe.offsetTop - Ce.clientTop - Ee.reference.height / 2 - Pe.offsetHeight / 2 - ie).fn(z)
    }, Ot = await detectOverflow(getArgsWithCustomFloatingHeight(kt, Ve.scrollHeight + ht + Ce.clientTop), oe), Ht = await detectOverflow(kt, {
      ...oe,
      elementContext: "reference"
    }), jt = max$1(0, Ot.top), Yt = kt.y + jt, Kt = (Ve.scrollHeight > Ve.clientHeight ? (Nt) => Nt : round$1)(max$1(0, Ve.scrollHeight + (vt && _t || Pt ? ht * 2 : 0) - jt - max$1(0, Ot.bottom)));
    if (Ve.style.maxHeight = Kt + "px", Ve.scrollTop = jt, ae) {
      const Nt = Ve.offsetHeight < Pe.offsetHeight * min$1(le, Y.current.length) - 1 || Ht.top >= -ve || Ht.bottom >= -ve;
      ReactDOM.flushSync(() => ae(Nt));
    }
    return ne && (ne.current = await detectOverflow(getArgsWithCustomFloatingHeight({
      ...kt,
      y: Yt
    }, Ve.offsetHeight + ht + Ce.clientTop), oe)), {
      y: Yt
    };
  }
});
function useInnerOffset(B, z) {
  const {
    open: Y,
    elements: ne
  } = B, {
    enabled: ae = !0,
    overflowRef: ie,
    scrollRef: se,
    onChange: le
  } = z, ve = useEffectEvent(le), ge = React.useRef(!1), oe = React.useRef(null), Ee = React.useRef(null);
  React.useEffect(() => {
    if (!ae) return;
    function Pe(ht) {
      if (ht.ctrlKey || !Ve || ie.current == null)
        return;
      const vt = ht.deltaY, Pt = ie.current.top >= -0.5, _t = ie.current.bottom >= -0.5, kt = Ve.scrollHeight - Ve.clientHeight, Ot = vt < 0 ? -1 : 1, Ht = vt < 0 ? "max" : "min";
      Ve.scrollHeight <= Ve.clientHeight || (!Pt && vt > 0 || !_t && vt < 0 ? (ht.preventDefault(), ReactDOM.flushSync(() => {
        ve((jt) => jt + Math[Ht](vt, kt * Ot));
      })) : /firefox/i.test(getUserAgent()) && (Ve.scrollTop += vt));
    }
    const Ve = (se == null ? void 0 : se.current) || ne.floating;
    if (Y && Ve)
      return Ve.addEventListener("wheel", Pe), requestAnimationFrame(() => {
        oe.current = Ve.scrollTop, ie.current != null && (Ee.current = {
          ...ie.current
        });
      }), () => {
        oe.current = null, Ee.current = null, Ve.removeEventListener("wheel", Pe);
      };
  }, [ae, Y, ne.floating, ie, se, ve]);
  const Ce = React.useMemo(() => ({
    onKeyDown() {
      ge.current = !0;
    },
    onWheel() {
      ge.current = !1;
    },
    onPointerMove() {
      ge.current = !1;
    },
    onScroll() {
      const Pe = (se == null ? void 0 : se.current) || ne.floating;
      if (!(!ie.current || !Pe || !ge.current)) {
        if (oe.current !== null) {
          const Ve = Pe.scrollTop - oe.current;
          (ie.current.bottom < -0.5 && Ve < -1 || ie.current.top < -0.5 && Ve > 1) && ReactDOM.flushSync(() => ve((ht) => ht + Ve));
        }
        requestAnimationFrame(() => {
          oe.current = Pe.scrollTop;
        });
      }
    }
  }), [ne.floating, ve, ie, se]);
  return React.useMemo(() => ae ? {
    floating: Ce
  } : {}, [ae, Ce]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let H = createContext(null);
H.displayName = "PlacementContext";
function xe(B) {
  return useMemo(() => B ? typeof B == "string" ? { to: B } : B : null, [B]);
}
function ye$1() {
  return useContext(y$1).setReference;
}
function Fe$1() {
  return useContext(y$1).getReferenceProps;
}
function be() {
  let { getFloatingProps: B, slot: z } = useContext(y$1);
  return useCallback((...Y) => Object.assign({}, B(...Y), { "data-anchor": z.anchor }), [B, z]);
}
function Re(B = null) {
  B === !1 && (B = null), typeof B == "string" && (B = { to: B });
  let z = useContext(H), Y = useMemo(() => B, [JSON.stringify(B, (ae, ie) => {
    var se;
    return (se = ie == null ? void 0 : ie.outerHTML) != null ? se : ie;
  })]);
  n$3(() => {
    z == null || z(Y ?? null);
  }, [z, Y]);
  let ne = useContext(y$1);
  return useMemo(() => [ne.setFloating, B ? ne.styles : {}], [ne.setFloating, B, ne.styles]);
}
let q = 4;
function Me$1({ children: B, enabled: z = !0 }) {
  let [Y, ne] = useState(null), [ae, ie] = useState(0), se = useRef(null), [le, ve] = useState(null);
  pe(le);
  let ge = z && Y !== null && le !== null, { to: oe = "bottom", gap: Ee = 0, offset: Ce = 0, padding: Pe = 0, inner: Ve } = ce(Y, le), [ht, vt = "center"] = oe.split(" ");
  n$3(() => {
    ge && ie(0);
  }, [ge]);
  let { refs: Pt, floatingStyles: _t, context: kt } = useFloating({ open: ge, placement: ht === "selection" ? vt === "center" ? "bottom" : `bottom-${vt}` : vt === "center" ? `${ht}` : `${ht}-${vt}`, strategy: "absolute", transform: !1, middleware: [offset({ mainAxis: ht === "selection" ? 0 : Ee, crossAxis: Ce }), shift({ padding: Pe }), ht !== "selection" && flip({ padding: Pe }), ht === "selection" && Ve ? inner({ ...Ve, padding: Pe, overflowRef: se, offset: ae, minItemsVisible: q, referenceOverflowThreshold: Pe, onFallbackChange(Nt) {
    var Je, Xe;
    if (!Nt) return;
    let Ke = kt.elements.floating;
    if (!Ke) return;
    let Qe = parseFloat(getComputedStyle(Ke).scrollPaddingBottom) || 0, bt = Math.min(q, Ke.childElementCount), wt = 0, xt = 0;
    for (let Bt of (Xe = (Je = kt.elements.floating) == null ? void 0 : Je.childNodes) != null ? Xe : []) if (Bt instanceof HTMLElement) {
      let $t = Bt.offsetTop, qt = $t + Bt.clientHeight + Qe, Rt = Ke.scrollTop, Lt = Rt + Ke.clientHeight;
      if ($t >= Rt && qt <= Lt) bt--;
      else {
        xt = Math.max(0, Math.min(qt, Lt) - Math.max($t, Rt)), wt = Bt.clientHeight;
        break;
      }
    }
    bt >= 1 && ie((Bt) => {
      let $t = wt * bt - xt + Qe;
      return Bt >= $t ? Bt : $t;
    });
  } }) : null, size({ padding: Pe, apply({ availableWidth: Nt, availableHeight: Je, elements: Xe }) {
    Object.assign(Xe.floating.style, { overflow: "auto", maxWidth: `${Nt}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${Je}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [Ot = ht, Ht = vt] = kt.placement.split("-");
  ht === "selection" && (Ot = "selection");
  let jt = useMemo(() => ({ anchor: [Ot, Ht].filter(Boolean).join(" ") }), [Ot, Ht]), Yt = useInnerOffset(kt, { overflowRef: se, onChange: ie }), { getReferenceProps: Dt, getFloatingProps: Ct } = useInteractions([Yt]), Kt = o$4((Nt) => {
    ve(Nt), Pt.setFloating(Nt);
  });
  return React.createElement(H.Provider, { value: ne }, React.createElement(y$1.Provider, { value: { setFloating: Kt, setReference: Pt.setReference, styles: _t, getReferenceProps: Dt, getFloatingProps: Ct, slot: jt } }, B));
}
function pe(B) {
  n$3(() => {
    if (!B) return;
    let z = new MutationObserver(() => {
      let Y = window.getComputedStyle(B).maxHeight, ne = parseFloat(Y);
      if (isNaN(ne)) return;
      let ae = parseInt(Y);
      isNaN(ae) || ne !== ae && (B.style.maxHeight = `${Math.ceil(ne)}px`);
    });
    return z.observe(B, { attributes: !0, attributeFilter: ["style"] }), () => {
      z.disconnect();
    };
  }, [B]);
}
function ce(B, z) {
  var Y, ne, ae;
  let ie = V$1((Y = B == null ? void 0 : B.gap) != null ? Y : "var(--anchor-gap, 0)", z), se = V$1((ne = B == null ? void 0 : B.offset) != null ? ne : "var(--anchor-offset, 0)", z), le = V$1((ae = B == null ? void 0 : B.padding) != null ? ae : "var(--anchor-padding, 0)", z);
  return { ...B, gap: ie, offset: se, padding: le };
}
function V$1(B, z, Y = void 0) {
  let ne = p$2(), ae = o$4((ve, ge) => {
    if (ve == null) return [Y, null];
    if (typeof ve == "number") return [ve, null];
    if (typeof ve == "string") {
      if (!ge) return [Y, null];
      let oe = J$1(ve, ge);
      return [oe, (Ee) => {
        let Ce = D$1(ve);
        {
          let Pe = Ce.map((Ve) => window.getComputedStyle(ge).getPropertyValue(Ve));
          ne.requestAnimationFrame(function Ve() {
            ne.nextFrame(Ve);
            let ht = !1;
            for (let [Pt, _t] of Ce.entries()) {
              let kt = window.getComputedStyle(ge).getPropertyValue(_t);
              if (Pe[Pt] !== kt) {
                Pe[Pt] = kt, ht = !0;
                break;
              }
            }
            if (!ht) return;
            let vt = J$1(ve, ge);
            oe !== vt && (Ee(vt), oe = vt);
          });
        }
        return ne.dispose;
      }];
    }
    return [Y, null];
  }), ie = useMemo(() => ae(B, z)[0], [B, z]), [se = ie, le] = useState();
  return n$3(() => {
    let [ve, ge] = ae(B, z);
    if (le(ve), !!ge) return ge(le);
  }, [B, z]), se;
}
function D$1(B) {
  let z = /var\((.*)\)/.exec(B);
  if (z) {
    let Y = z[1].indexOf(",");
    if (Y === -1) return [z[1]];
    let ne = z[1].slice(0, Y).trim(), ae = z[1].slice(Y + 1).trim();
    return ae ? [ne, ...D$1(ae)] : [ne];
  }
  return [];
}
function J$1(B, z) {
  let Y = document.createElement("div");
  z.appendChild(Y), Y.style.setProperty("margin-top", "0px", "important"), Y.style.setProperty("margin-top", B, "important");
  let ne = parseFloat(window.getComputedStyle(Y).marginTop) || 0;
  return z.removeChild(Y), ne;
}
let n = createContext(null);
n.displayName = "OpenClosedContext";
var i$3 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(i$3 || {});
function u$2() {
  return useContext(n);
}
function c$2({ value: B, children: z }) {
  return React__default.createElement(n.Provider, { value: B }, z);
}
function s$4({ children: B }) {
  return React__default.createElement(n.Provider, { value: null }, B);
}
function t(B) {
  function z() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", z));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", z), z());
}
let r$1 = [];
t(() => {
  function B(z) {
    if (!(z.target instanceof HTMLElement) || z.target === document.body || r$1[0] === z.target) return;
    let Y = z.target;
    Y = Y.closest(f$5), r$1.unshift(Y ?? z.target), r$1 = r$1.filter((ne) => ne != null && ne.isConnected), r$1.splice(10);
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function u$1(B) {
  throw new Error("Unexpected object: " + B);
}
var c$1 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$1 || {});
function f$3(B, z) {
  let Y = z.resolveItems();
  if (Y.length <= 0) return null;
  let ne = z.resolveActiveIndex(), ae = ne ?? -1;
  switch (B.focus) {
    case 0: {
      for (let ie = 0; ie < Y.length; ++ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 1: {
      ae === -1 && (ae = Y.length);
      for (let ie = ae - 1; ie >= 0; --ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 2: {
      for (let ie = ae + 1; ie < Y.length; ++ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 3: {
      for (let ie = Y.length - 1; ie >= 0; --ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 4: {
      for (let ie = 0; ie < Y.length; ++ie) if (z.resolveId(Y[ie], ie, Y) === B.id) return ie;
      return ne;
    }
    case 5:
      return null;
    default:
      u$1(B);
  }
}
function c(B) {
  let z = o$4(B), Y = useRef(!1);
  useEffect(() => (Y.current = !1, () => {
    Y.current = !0, t$4(() => {
      Y.current && z();
    });
  }), [z]);
}
function s$3() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in React ? ((z) => z.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$1() {
  let B = s$3(), [z, Y] = React.useState(s$8.isHandoffComplete);
  return z && s$8.isHandoffComplete === !1 && Y(!1), React.useEffect(() => {
    z !== !0 && Y(!0);
  }, [z]), React.useEffect(() => s$8.handoff(), []), B ? !1 : z;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l(B) {
  return React__default.createElement(e.Provider, { value: B.force }, B.children);
}
function N(B) {
  let z = a$4(), Y = useContext(v), ne = n$1(B), [ae, ie] = useState(() => {
    var se;
    if (!z && Y !== null) return (se = Y.current) != null ? se : null;
    if (s$8.isServer) return null;
    let le = ne == null ? void 0 : ne.getElementById("headlessui-portal-root");
    if (le) return le;
    if (ne === null) return null;
    let ve = ne.createElement("div");
    return ve.setAttribute("id", "headlessui-portal-root"), ne.body.appendChild(ve);
  });
  return useEffect(() => {
    ae !== null && (ne != null && ne.body.contains(ae) || ne == null || ne.body.appendChild(ae));
  }, [ae, ne]), useEffect(() => {
    z || Y !== null && ie(Y.current);
  }, [Y, ie, z]), ae;
}
let M$1 = Fragment, S = K$1(function(B, z) {
  let Y = B, ne = useRef(null), ae = y$4(T$2((Ee) => {
    ne.current = Ee;
  }), z), ie = n$1(ne), se = N(ne), [le] = useState(() => {
    var Ee;
    return s$8.isServer ? null : (Ee = ie == null ? void 0 : ie.createElement("div")) != null ? Ee : null;
  }), ve = useContext(y), ge = l$1();
  n$3(() => {
    !se || !le || se.contains(le) || (le.setAttribute("data-headlessui-portal", ""), se.appendChild(le));
  }, [se, le]), n$3(() => {
    if (le && ve) return ve.register(le);
  }, [ve, le]), c(() => {
    var Ee;
    !se || !le || (le instanceof Node && se.contains(le) && se.removeChild(le), se.childNodes.length <= 0 && ((Ee = se.parentElement) == null || Ee.removeChild(se)));
  });
  let oe = L$1();
  return ge ? !se || !le ? null : createPortal(oe({ ourProps: { ref: ae }, theirProps: Y, slot: {}, defaultTag: M$1, name: "Portal" }), le) : null;
});
function j$1(B, z) {
  let Y = y$4(z), { enabled: ne = !0, ...ae } = B, ie = L$1();
  return ne ? React__default.createElement(S, { ...ae, ref: Y }) : ie({ ourProps: { ref: Y }, theirProps: ae, slot: {}, defaultTag: M$1, name: "Portal" });
}
let W = Fragment, v = createContext(null);
function I$1(B, z) {
  let { target: Y, ...ne } = B, ae = { ref: y$4(z) }, ie = L$1();
  return React__default.createElement(v.Provider, { value: Y }, ie({ ourProps: ae, theirProps: ne, defaultTag: W, name: "Popover.Group" }));
}
let y = createContext(null);
function te$1() {
  let B = useContext(y), z = useRef([]), Y = o$4((ie) => (z.current.push(ie), B && B.register(ie), () => ne(ie))), ne = o$4((ie) => {
    let se = z.current.indexOf(ie);
    se !== -1 && z.current.splice(se, 1), B && B.unregister(ie);
  }), ae = useMemo(() => ({ register: Y, unregister: ne, portals: z }), [Y, ne, z]);
  return [z, useMemo(() => function({ children: ie }) {
    return React__default.createElement(y.Provider, { value: ae }, ie);
  }, [ae])];
}
let J = K$1(j$1), X$1 = K$1(I$1), re$1 = Object.assign(J, { Group: X$1 });
function a$3(B, z = typeof document < "u" ? document.defaultView : null, Y) {
  let ne = x$3(B, "escape");
  E(z, "keydown", (ae) => {
    ne && (ae.defaultPrevented || ae.key === o$3.Escape && Y(ae));
  });
}
function f$2() {
  var B;
  let [z] = useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [Y, ne] = useState((B = z == null ? void 0 : z.matches) != null ? B : !1);
  return n$3(() => {
    if (!z) return;
    function ae(ie) {
      ne(ie.matches);
    }
    return z.addEventListener("change", ae), () => z.removeEventListener("change", ae);
  }, [z]), Y;
}
function R({ defaultContainers: B = [], portals: z, mainTreeNode: Y } = {}) {
  let ne = n$1(Y), ae = o$4(() => {
    var ie, se;
    let le = [];
    for (let ve of B) ve !== null && (ve instanceof HTMLElement ? le.push(ve) : "current" in ve && ve.current instanceof HTMLElement && le.push(ve.current));
    if (z != null && z.current) for (let ve of z.current) le.push(ve);
    for (let ve of (ie = ne == null ? void 0 : ne.querySelectorAll("html > *, body > *")) != null ? ie : []) ve !== document.body && ve !== document.head && ve instanceof HTMLElement && ve.id !== "headlessui-portal-root" && (Y && (ve.contains(Y) || ve.contains((se = Y == null ? void 0 : Y.getRootNode()) == null ? void 0 : se.host)) || le.some((ge) => ve.contains(ge)) || le.push(ve));
    return le;
  });
  return { resolveContainers: ae, contains: o$4((ie) => ae().some((se) => se.contains(ie))) };
}
let a$2 = createContext(null);
function O$1({ children: B, node: z }) {
  let [Y, ne] = useState(null), ae = b(z ?? Y);
  return React__default.createElement(a$2.Provider, { value: ae }, B, ae === null && React__default.createElement(f$9, { features: s$6.Hidden, ref: (ie) => {
    var se, le;
    if (ie) {
      for (let ve of (le = (se = u$8(ie)) == null ? void 0 : se.querySelectorAll("html > *, body > *")) != null ? le : []) if (ve !== document.body && ve !== document.head && ve instanceof HTMLElement && ve != null && ve.contains(ie)) {
        ne(ve);
        break;
      }
    }
  } }));
}
function b(B = null) {
  var z;
  return (z = useContext(a$2)) != null ? z : B;
}
function f$1() {
  let B = useRef(!1);
  return n$3(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
var a$1 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(a$1 || {});
function u() {
  let B = useRef(0);
  return s$5(!0, "keydown", (z) => {
    z.key === "Tab" && (B.current = z.shiftKey ? 1 : 0);
  }, !0), B;
}
function U$1(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let z = /* @__PURE__ */ new Set();
  for (let Y of B.current) Y.current instanceof HTMLElement && z.add(Y.current);
  return z;
}
let Z = "div";
var x$1 = ((B) => (B[B.None = 0] = "None", B[B.InitialFocus = 1] = "InitialFocus", B[B.TabLock = 2] = "TabLock", B[B.FocusLock = 4] = "FocusLock", B[B.RestoreFocus = 8] = "RestoreFocus", B[B.AutoFocus = 16] = "AutoFocus", B))(x$1 || {});
function $(B, z) {
  let Y = useRef(null), ne = y$4(Y, z), { initialFocus: ae, initialFocusFallback: ie, containers: se, features: le = 15, ...ve } = B;
  l$1() || (le = 0);
  let ge = n$1(Y);
  ee(le, { ownerDocument: ge });
  let oe = te(le, { ownerDocument: ge, container: Y, initialFocus: ae, initialFocusFallback: ie });
  re(le, { ownerDocument: ge, container: Y, containers: se, previousActiveElement: oe });
  let Ee = u(), Ce = o$4((_t) => {
    let kt = Y.current;
    kt && ((Ot) => Ot())(() => {
      u$7(Ee.current, { [a$1.Forwards]: () => {
        P(kt, F$1.First, { skipElements: [_t.relatedTarget, ie] });
      }, [a$1.Backwards]: () => {
        P(kt, F$1.Last, { skipElements: [_t.relatedTarget, ie] });
      } });
    });
  }), Pe = x$3(!!(le & 2), "focus-trap#tab-lock"), Ve = p$2(), ht = useRef(!1), vt = { ref: ne, onKeyDown(_t) {
    _t.key == "Tab" && (ht.current = !0, Ve.requestAnimationFrame(() => {
      ht.current = !1;
    }));
  }, onBlur(_t) {
    if (!(le & 4)) return;
    let kt = U$1(se);
    Y.current instanceof HTMLElement && kt.add(Y.current);
    let Ot = _t.relatedTarget;
    Ot instanceof HTMLElement && Ot.dataset.headlessuiFocusGuard !== "true" && (I(kt, Ot) || (ht.current ? P(Y.current, u$7(Ee.current, { [a$1.Forwards]: () => F$1.Next, [a$1.Backwards]: () => F$1.Previous }) | F$1.WrapAround, { relativeTo: _t.target }) : _t.target instanceof HTMLElement && I$2(_t.target)));
  } }, Pt = L$1();
  return React__default.createElement(React__default.Fragment, null, Pe && React__default.createElement(f$9, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ce, features: s$6.Focusable }), Pt({ ourProps: vt, theirProps: ve, defaultTag: Z, name: "FocusTrap" }), Pe && React__default.createElement(f$9, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ce, features: s$6.Focusable }));
}
let D = K$1($), ye = Object.assign(D, { features: x$1 });
function w$2(B = !0) {
  let z = useRef(r$1.slice());
  return m(([Y], [ne]) => {
    ne === !0 && Y === !1 && t$4(() => {
      z.current.splice(0);
    }), ne === !1 && Y === !0 && (z.current = r$1.slice());
  }, [B, r$1, z]), o$4(() => {
    var Y;
    return (Y = z.current.find((ne) => ne != null && ne.isConnected)) != null ? Y : null;
  });
}
function ee(B, { ownerDocument: z }) {
  let Y = !!(B & 8), ne = w$2(Y);
  m(() => {
    Y || (z == null ? void 0 : z.activeElement) === (z == null ? void 0 : z.body) && I$2(ne());
  }, [Y]), c(() => {
    Y && I$2(ne());
  });
}
function te(B, { ownerDocument: z, container: Y, initialFocus: ne, initialFocusFallback: ae }) {
  let ie = useRef(null), se = x$3(!!(B & 1), "focus-trap#initial-focus"), le = f$1();
  return m(() => {
    if (B === 0) return;
    if (!se) {
      ae != null && ae.current && I$2(ae.current);
      return;
    }
    let ve = Y.current;
    ve && t$4(() => {
      if (!le.current) return;
      let ge = z == null ? void 0 : z.activeElement;
      if (ne != null && ne.current) {
        if ((ne == null ? void 0 : ne.current) === ge) {
          ie.current = ge;
          return;
        }
      } else if (ve.contains(ge)) {
        ie.current = ge;
        return;
      }
      if (ne != null && ne.current) I$2(ne.current);
      else {
        if (B & 16) {
          if (P(ve, F$1.First | F$1.AutoFocus) !== T$1.Error) return;
        } else if (P(ve, F$1.First) !== T$1.Error) return;
        if (ae != null && ae.current && (I$2(ae.current), (z == null ? void 0 : z.activeElement) === ae.current)) return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      ie.current = z == null ? void 0 : z.activeElement;
    });
  }, [ae, se, B]), ie;
}
function re(B, { ownerDocument: z, container: Y, containers: ne, previousActiveElement: ae }) {
  let ie = f$1(), se = !!(B & 4);
  E(z == null ? void 0 : z.defaultView, "focus", (le) => {
    if (!se || !ie.current) return;
    let ve = U$1(ne);
    Y.current instanceof HTMLElement && ve.add(Y.current);
    let ge = ae.current;
    if (!ge) return;
    let oe = le.target;
    oe && oe instanceof HTMLElement ? I(ve, oe) ? (ae.current = oe, I$2(oe)) : (le.preventDefault(), le.stopPropagation(), I$2(ge)) : I$2(ae.current);
  }, !0);
}
function I(B, z) {
  for (let Y of B) if (Y.contains(z)) return !0;
  return !1;
}
function ue(B) {
  var z;
  return !!(B.enter || B.enterFrom || B.enterTo || B.leave || B.leaveFrom || B.leaveTo) || ((z = B.as) != null ? z : de) !== Fragment || React__default.Children.count(B.children) === 1;
}
let w$1 = createContext(null);
w$1.displayName = "TransitionContext";
var _e = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(_e || {});
function De() {
  let B = useContext(w$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function He$1() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: z }) => z.current !== null).filter(({ state: z }) => z === "visible").length > 0;
}
function Te(B, z) {
  let Y = s$7(B), ne = useRef([]), ae = f$1(), ie = p$2(), se = o$4((Pe, Ve = A$1.Hidden) => {
    let ht = ne.current.findIndex(({ el: vt }) => vt === Pe);
    ht !== -1 && (u$7(Ve, { [A$1.Unmount]() {
      ne.current.splice(ht, 1);
    }, [A$1.Hidden]() {
      ne.current[ht].state = "hidden";
    } }), ie.microTask(() => {
      var vt;
      !U(ne) && ae.current && ((vt = Y.current) == null || vt.call(Y));
    }));
  }), le = o$4((Pe) => {
    let Ve = ne.current.find(({ el: ht }) => ht === Pe);
    return Ve ? Ve.state !== "visible" && (Ve.state = "visible") : ne.current.push({ el: Pe, state: "visible" }), () => se(Pe, A$1.Unmount);
  }), ve = useRef([]), ge = useRef(Promise.resolve()), oe = useRef({ enter: [], leave: [] }), Ee = o$4((Pe, Ve, ht) => {
    ve.current.splice(0), z && (z.chains.current[Ve] = z.chains.current[Ve].filter(([vt]) => vt !== Pe)), z == null || z.chains.current[Ve].push([Pe, new Promise((vt) => {
      ve.current.push(vt);
    })]), z == null || z.chains.current[Ve].push([Pe, new Promise((vt) => {
      Promise.all(oe.current[Ve].map(([Pt, _t]) => _t)).then(() => vt());
    })]), Ve === "enter" ? ge.current = ge.current.then(() => z == null ? void 0 : z.wait.current).then(() => ht(Ve)) : ht(Ve);
  }), Ce = o$4((Pe, Ve, ht) => {
    Promise.all(oe.current[Ve].splice(0).map(([vt, Pt]) => Pt)).then(() => {
      var vt;
      (vt = ve.current.shift()) == null || vt();
    }).then(() => ht(Ve));
  });
  return useMemo(() => ({ children: ne, register: le, unregister: se, onStart: Ee, onStop: Ce, wait: ge, chains: oe }), [le, se, ne, Ee, Ce, oe, ge]);
}
let de = Fragment, fe = O$3.RenderStrategy;
function Ae(B, z) {
  var Y, ne;
  let { transition: ae = !0, beforeEnter: ie, afterEnter: se, beforeLeave: le, afterLeave: ve, enter: ge, enterFrom: oe, enterTo: Ee, entered: Ce, leave: Pe, leaveFrom: Ve, leaveTo: ht, ...vt } = B, [Pt, _t] = useState(null), kt = useRef(null), Ot = ue(B), Ht = y$4(...Ot ? [kt, z, _t] : z === null ? [] : [z]), jt = (Y = vt.unmount) == null || Y ? A$1.Unmount : A$1.Hidden, { show: Yt, appear: Dt, initial: Ct } = De(), [Kt, Nt] = useState(Yt ? "visible" : "hidden"), Je = He$1(), { register: Xe, unregister: Ke } = Je;
  n$3(() => Xe(kt), [Xe, kt]), n$3(() => {
    if (jt === A$1.Hidden && kt.current) {
      if (Yt && Kt !== "visible") {
        Nt("visible");
        return;
      }
      return u$7(Kt, { hidden: () => Ke(kt), visible: () => Xe(kt) });
    }
  }, [Kt, kt, Xe, Ke, Yt, jt]);
  let Qe = l$1();
  n$3(() => {
    if (Ot && Qe && Kt === "visible" && kt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [kt, Kt, Qe, Ot]);
  let bt = Ct && !Dt, wt = Dt && Yt && Ct, xt = useRef(!1), Bt = Te(() => {
    xt.current || (Nt("hidden"), Ke(kt));
  }, Je), $t = o$4((Wt) => {
    xt.current = !0;
    let Gt = Wt ? "enter" : "leave";
    Bt.onStart(kt, Gt, (rr) => {
      rr === "enter" ? ie == null || ie() : rr === "leave" && (le == null || le());
    });
  }), qt = o$4((Wt) => {
    let Gt = Wt ? "enter" : "leave";
    xt.current = !1, Bt.onStop(kt, Gt, (rr) => {
      rr === "enter" ? se == null || se() : rr === "leave" && (ve == null || ve());
    }), Gt === "leave" && !U(Bt) && (Nt("hidden"), Ke(kt));
  });
  useEffect(() => {
    Ot && ae || ($t(Yt), qt(Yt));
  }, [Yt, Ot, ae]);
  let Rt = !(!ae || !Ot || !Qe || bt), [, Lt] = x$2(Rt, Pt, Yt, { start: $t, end: qt }), tr = m$4({ ref: Ht, className: ((ne = t$3(vt.className, wt && ge, wt && oe, Lt.enter && ge, Lt.enter && Lt.closed && oe, Lt.enter && !Lt.closed && Ee, Lt.leave && Pe, Lt.leave && !Lt.closed && Ve, Lt.leave && Lt.closed && ht, !Lt.transition && Yt && Ce)) == null ? void 0 : ne.trim()) || void 0, ...R$1(Lt) }), sr = 0;
  Kt === "visible" && (sr |= i$3.Open), Kt === "hidden" && (sr |= i$3.Closed), Lt.enter && (sr |= i$3.Opening), Lt.leave && (sr |= i$3.Closing);
  let Zt = L$1();
  return React__default.createElement(M.Provider, { value: Bt }, React__default.createElement(c$2, { value: sr }, Zt({ ourProps: tr, theirProps: vt, defaultTag: de, features: fe, visible: Kt === "visible", name: "Transition.Child" })));
}
function Ie$1(B, z) {
  let { show: Y, appear: ne = !1, unmount: ae = !0, ...ie } = B, se = useRef(null), le = ue(B), ve = y$4(...le ? [se, z] : z === null ? [] : [z]);
  l$1();
  let ge = u$2();
  if (Y === void 0 && ge !== null && (Y = (ge & i$3.Open) === i$3.Open), Y === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [oe, Ee] = useState(Y ? "visible" : "hidden"), Ce = Te(() => {
    Y || Ee("hidden");
  }), [Pe, Ve] = useState(!0), ht = useRef([Y]);
  n$3(() => {
    Pe !== !1 && ht.current[ht.current.length - 1] !== Y && (ht.current.push(Y), Ve(!1));
  }, [ht, Y]);
  let vt = useMemo(() => ({ show: Y, appear: ne, initial: Pe }), [Y, ne, Pe]);
  n$3(() => {
    Y ? Ee("visible") : !U(Ce) && se.current !== null && Ee("hidden");
  }, [Y, Ce]);
  let Pt = { unmount: ae }, _t = o$4(() => {
    var Ht;
    Pe && Ve(!1), (Ht = B.beforeEnter) == null || Ht.call(B);
  }), kt = o$4(() => {
    var Ht;
    Pe && Ve(!1), (Ht = B.beforeLeave) == null || Ht.call(B);
  }), Ot = L$1();
  return React__default.createElement(M.Provider, { value: Ce }, React__default.createElement(w$1.Provider, { value: vt }, Ot({ ourProps: { ...Pt, as: Fragment, children: React__default.createElement(me, { ref: ve, ...Pt, ...ie, beforeEnter: _t, beforeLeave: kt }) }, theirProps: {}, defaultTag: Fragment, features: fe, visible: oe === "visible", name: "Transition" })));
}
function Le(B, z) {
  let Y = useContext(w$1) !== null, ne = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !Y && ne ? React__default.createElement(X, { ref: z, ...B }) : React__default.createElement(me, { ref: z, ...B }));
}
let X = K$1(Ie$1), me = K$1(Ae), Fe = K$1(Le), ze$1 = Object.assign(X, { Child: Fe, Root: X });
var Oe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Oe || {}), he = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(he || {});
let Se = { 0(B, z) {
  return B.titleId === z.id ? B : { ...B, titleId: z.id };
} }, k$1 = createContext(null);
k$1.displayName = "DialogContext";
function O(B) {
  let z = useContext(k$1);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, O), Y;
  }
  return z;
}
function Ie(B, z) {
  return u$7(z.type, Se, B, z);
}
let V = K$1(function(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-${Y}`, open: ae, onClose: ie, initialFocus: se, role: le = "dialog", autoFocus: ve = !0, __demoMode: ge = !1, unmount: oe = !1, ...Ee } = B, Ce = useRef(!1);
  le = function() {
    return le === "dialog" || le === "alertdialog" ? le : (Ce.current || (Ce.current = !0, console.warn(`Invalid role [${le}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Pe = u$2();
  ae === void 0 && Pe !== null && (ae = (Pe & i$3.Open) === i$3.Open);
  let Ve = useRef(null), ht = y$4(Ve, z), vt = n$1(Ve), Pt = ae ? 0 : 1, [_t, kt] = useReducer(Ie, { titleId: null, descriptionId: null, panelRef: createRef() }), Ot = o$4(() => ie(!1)), Ht = o$4((qt) => kt({ type: 0, id: qt })), jt = l$1() ? Pt === 0 : !1, [Yt, Dt] = te$1(), Ct = { get current() {
    var qt;
    return (qt = _t.panelRef.current) != null ? qt : Ve.current;
  } }, Kt = b(), { resolveContainers: Nt } = R({ mainTreeNode: Kt, portals: Yt, defaultContainers: [Ct] }), Je = Pe !== null ? (Pe & i$3.Closing) === i$3.Closing : !1;
  y$3(ge || Je ? !1 : jt, { allowed: o$4(() => {
    var qt, Rt;
    return [(Rt = (qt = Ve.current) == null ? void 0 : qt.closest("[data-headlessui-portal]")) != null ? Rt : null];
  }), disallowed: o$4(() => {
    var qt;
    return [(qt = Kt == null ? void 0 : Kt.closest("body > *:not(#headlessui-portal-root)")) != null ? qt : null];
  }) }), R$2(jt, Nt, (qt) => {
    qt.preventDefault(), Ot();
  }), a$3(jt, vt == null ? void 0 : vt.defaultView, (qt) => {
    qt.preventDefault(), qt.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), Ot();
  }), f$4(ge || Je ? !1 : jt, vt, Nt), m$2(jt, Ve, Ot);
  let [Xe, Ke] = w$4(), Qe = useMemo(() => [{ dialogState: Pt, close: Ot, setTitleId: Ht, unmount: oe }, _t], [Pt, _t, Ot, Ht, oe]), bt = useMemo(() => ({ open: Pt === 0 }), [Pt]), wt = { ref: ht, id: ne, role: le, tabIndex: -1, "aria-modal": ge ? void 0 : Pt === 0 ? !0 : void 0, "aria-labelledby": _t.titleId, "aria-describedby": Xe, unmount: oe }, xt = !f$2(), Bt = x$1.None;
  jt && !ge && (Bt |= x$1.RestoreFocus, Bt |= x$1.TabLock, ve && (Bt |= x$1.AutoFocus), xt && (Bt |= x$1.InitialFocus));
  let $t = L$1();
  return React__default.createElement(s$4, null, React__default.createElement(l, { force: !0 }, React__default.createElement(re$1, null, React__default.createElement(k$1.Provider, { value: Qe }, React__default.createElement(X$1, { target: Ve }, React__default.createElement(l, { force: !1 }, React__default.createElement(Ke, { slot: bt }, React__default.createElement(Dt, null, React__default.createElement(ye, { initialFocus: se, initialFocusFallback: Ve, containers: Nt, features: Bt }, React__default.createElement(C$1, { value: Ot }, $t({ ourProps: wt, theirProps: Ee, slot: bt, defaultTag: Me, features: Ge, visible: Pt === 0, name: "Dialog" })))))))))));
}), Me = "div", Ge = O$3.RenderStrategy | O$3.Static;
function ke(B, z) {
  let { transition: Y = !1, open: ne, ...ae } = B, ie = u$2(), se = B.hasOwnProperty("open") || ie !== null, le = B.hasOwnProperty("onClose");
  if (!se && !le) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!se) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!le) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!ie && typeof B.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${B.open}`);
  if (typeof B.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${B.onClose}`);
  return (ne !== void 0 || Y) && !ae.static ? React__default.createElement(O$1, null, React__default.createElement(ze$1, { show: ne, transition: Y, unmount: ae.unmount }, React__default.createElement(V, { ref: z, ...ae }))) : React__default.createElement(O$1, null, React__default.createElement(V, { ref: z, open: ne, ...ae }));
}
let we = "div";
function Be(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-panel-${Y}`, transition: ae = !1, ...ie } = B, [{ dialogState: se, unmount: le }, ve] = O("Dialog.Panel"), ge = y$4(z, ve.panelRef), oe = useMemo(() => ({ open: se === 0 }), [se]), Ee = o$4((vt) => {
    vt.stopPropagation();
  }), Ce = { ref: ge, id: ne, onClick: Ee }, Pe = ae ? Fe : Fragment, Ve = ae ? { unmount: le } : {}, ht = L$1();
  return React__default.createElement(Pe, { ...Ve }, ht({ ourProps: Ce, theirProps: ie, slot: oe, defaultTag: we, name: "Dialog.Panel" }));
}
let Ue = "div";
function He(B, z) {
  let { transition: Y = !1, ...ne } = B, [{ dialogState: ae, unmount: ie }] = O("Dialog.Backdrop"), se = useMemo(() => ({ open: ae === 0 }), [ae]), le = { ref: z, "aria-hidden": !0 }, ve = Y ? Fe : Fragment, ge = Y ? { unmount: ie } : {}, oe = L$1();
  return React__default.createElement(ve, { ...ge }, oe({ ourProps: le, theirProps: ne, slot: se, defaultTag: Ue, name: "Dialog.Backdrop" }));
}
let Ne = "h2";
function We(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-title-${Y}`, ...ae } = B, [{ dialogState: ie, setTitleId: se }] = O("Dialog.Title"), le = y$4(z);
  useEffect(() => (se(ne), () => se(null)), [ne, se]);
  let ve = useMemo(() => ({ open: ie === 0 }), [ie]), ge = { ref: le, id: ne };
  return L$1()({ ourProps: ge, theirProps: ae, slot: ve, defaultTag: Ne, name: "Dialog.Title" });
}
let $e = K$1(ke), je = K$1(Be);
K$1(He);
let Ye$1 = K$1(We), yt$1 = Object.assign($e, { Panel: je, Title: Ye$1, Description: H$2 });
function s$2(B, z) {
  let Y = useRef({ left: 0, top: 0 });
  if (n$3(() => {
    if (!z) return;
    let ae = z.getBoundingClientRect();
    ae && (Y.current = ae);
  }, [B, z]), z == null || !B || z === document.activeElement) return !1;
  let ne = z.getBoundingClientRect();
  return ne.top !== Y.current.top || ne.left !== Y.current.left;
}
let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var z, Y;
  let ne = (z = B.innerText) != null ? z : "", ae = B.cloneNode(!0);
  if (!(ae instanceof HTMLElement)) return ne;
  let ie = !1;
  for (let le of ae.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) le.remove(), ie = !0;
  let se = ie ? (Y = ae.innerText) != null ? Y : "" : ne;
  return a.test(se) && (se = se.replace(a, "")), se;
}
function g(B) {
  let z = B.getAttribute("aria-label");
  if (typeof z == "string") return z.trim();
  let Y = B.getAttribute("aria-labelledby");
  if (Y) {
    let ne = Y.split(" ").map((ae) => {
      let ie = document.getElementById(ae);
      if (ie) {
        let se = ie.getAttribute("aria-label");
        return typeof se == "string" ? se.trim() : o$1(ie).trim();
      }
      return null;
    }).filter(Boolean);
    if (ne.length > 0) return ne.join(", ");
  }
  return o$1(B).trim();
}
function s$1(B) {
  let z = useRef(""), Y = useRef("");
  return o$4(() => {
    let ne = B.current;
    if (!ne) return "";
    let ae = ne.innerText;
    if (z.current === ae) return Y.current;
    let ie = g(ne).trim().toLowerCase();
    return z.current = ae, Y.current = ie, ie;
  });
}
var qe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(qe || {}), ze = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(ze || {}), Ye = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B[B.SetButtonElement = 7] = "SetButtonElement", B[B.SetItemsElement = 8] = "SetItemsElement", B))(Ye || {});
function j(B, z = (Y) => Y) {
  let Y = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, ne = _(z(B.items.slice()), (ie) => ie.dataRef.current.domRef.current), ae = Y ? ne.indexOf(Y) : null;
  return ae === -1 && (ae = null), { items: ne, activeItemIndex: ae };
}
let Ze = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, z) => {
  var Y, ne, ae, ie, se;
  if (B.menuState === 1) return B;
  let le = { ...B, searchQuery: "", activationTrigger: (Y = z.trigger) != null ? Y : 1, __demoMode: !1 };
  if (z.focus === c$1.Nothing) return { ...le, activeItemIndex: null };
  if (z.focus === c$1.Specific) return { ...le, activeItemIndex: B.items.findIndex((oe) => oe.id === z.id) };
  if (z.focus === c$1.Previous) {
    let oe = B.activeItemIndex;
    if (oe !== null) {
      let Ee = B.items[oe].dataRef.current.domRef, Ce = f$3(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Pe) => Pe.id, resolveDisabled: (Pe) => Pe.dataRef.current.disabled });
      if (Ce !== null) {
        let Pe = B.items[Ce].dataRef.current.domRef;
        if (((ne = Ee.current) == null ? void 0 : ne.previousElementSibling) === Pe.current || ((ae = Pe.current) == null ? void 0 : ae.previousElementSibling) === null) return { ...le, activeItemIndex: Ce };
      }
    }
  } else if (z.focus === c$1.Next) {
    let oe = B.activeItemIndex;
    if (oe !== null) {
      let Ee = B.items[oe].dataRef.current.domRef, Ce = f$3(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Pe) => Pe.id, resolveDisabled: (Pe) => Pe.dataRef.current.disabled });
      if (Ce !== null) {
        let Pe = B.items[Ce].dataRef.current.domRef;
        if (((ie = Ee.current) == null ? void 0 : ie.nextElementSibling) === Pe.current || ((se = Pe.current) == null ? void 0 : se.nextElementSibling) === null) return { ...le, activeItemIndex: Ce };
      }
    }
  }
  let ve = j(B), ge = f$3(z, { resolveItems: () => ve.items, resolveActiveIndex: () => ve.activeItemIndex, resolveId: (oe) => oe.id, resolveDisabled: (oe) => oe.dataRef.current.disabled });
  return { ...le, ...ve, activeItemIndex: ge };
}, 3: (B, z) => {
  let Y = B.searchQuery !== "" ? 0 : 1, ne = B.searchQuery + z.value.toLowerCase(), ae = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + Y).concat(B.items.slice(0, B.activeItemIndex + Y)) : B.items).find((se) => {
    var le;
    return ((le = se.dataRef.current.textValue) == null ? void 0 : le.startsWith(ne)) && !se.dataRef.current.disabled;
  }), ie = ae ? B.items.indexOf(ae) : -1;
  return ie === -1 || ie === B.activeItemIndex ? { ...B, searchQuery: ne } : { ...B, searchQuery: ne, activeItemIndex: ie, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, z) => {
  let Y = j(B, (ne) => [...ne, { id: z.id, dataRef: z.dataRef }]);
  return { ...B, ...Y };
}, 6: (B, z) => {
  let Y = j(B, (ne) => {
    let ae = ne.findIndex((ie) => ie.id === z.id);
    return ae !== -1 && ne.splice(ae, 1), ne;
  });
  return { ...B, ...Y, activationTrigger: 1 };
}, 7: (B, z) => B.buttonElement === z.element ? B : { ...B, buttonElement: z.element }, 8: (B, z) => B.itemsElement === z.element ? B : { ...B, itemsElement: z.element } }, Q = createContext(null);
Q.displayName = "MenuContext";
function w(B) {
  let z = useContext(Q);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, w), Y;
  }
  return z;
}
function et(B, z) {
  return u$7(z.type, Ze, B, z);
}
let tt = Fragment;
function nt(B, z) {
  let { __demoMode: Y = !1, ...ne } = B, ae = useReducer(et, { __demoMode: Y, menuState: Y ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: ie, itemsElement: se, buttonElement: le }, ve] = ae, ge = y$4(z);
  R$2(ie === 0, [le, se], (Ve, ht) => {
    ve({ type: 1 }), A(ht, h$2.Loose) || (Ve.preventDefault(), le == null || le.focus());
  });
  let oe = o$4(() => {
    ve({ type: 1 });
  }), Ee = useMemo(() => ({ open: ie === 0, close: oe }), [ie, oe]), Ce = { ref: ge }, Pe = L$1();
  return React__default.createElement(Me$1, null, React__default.createElement(Q.Provider, { value: ae }, React__default.createElement(c$2, { value: u$7(ie, { 0: i$3.Open, 1: i$3.Closed }) }, Pe({ ourProps: Ce, theirProps: ne, slot: Ee, defaultTag: tt, name: "Menu" }))));
}
let rt = "button";
function ot(B, z) {
  var Y;
  let ne = useId$1(), { id: ae = `headlessui-menu-button-${ne}`, disabled: ie = !1, autoFocus: se = !1, ...le } = B, [ve, ge] = w("Menu.Button"), oe = Fe$1(), Ee = y$4(z, ye$1(), o$4((Yt) => ge({ type: 7, element: Yt }))), Ce = o$4((Yt) => {
    switch (Yt.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        Yt.preventDefault(), Yt.stopPropagation(), flushSync(() => ge({ type: 0 })), ge({ type: 2, focus: c$1.First });
        break;
      case o$3.ArrowUp:
        Yt.preventDefault(), Yt.stopPropagation(), flushSync(() => ge({ type: 0 })), ge({ type: 2, focus: c$1.Last });
        break;
    }
  }), Pe = o$4((Yt) => {
    switch (Yt.key) {
      case o$3.Space:
        Yt.preventDefault();
        break;
    }
  }), Ve = o$4((Yt) => {
    var Dt;
    if (r$3(Yt.currentTarget)) return Yt.preventDefault();
    ie || (ve.menuState === 0 ? (flushSync(() => ge({ type: 1 })), (Dt = ve.buttonElement) == null || Dt.focus({ preventScroll: !0 })) : (Yt.preventDefault(), ge({ type: 0 })));
  }), { isFocusVisible: ht, focusProps: vt } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: se }), { isHovered: Pt, hoverProps: _t } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: ie }), { pressed: kt, pressProps: Ot } = w$5({ disabled: ie }), Ht = useMemo(() => ({ open: ve.menuState === 0, active: kt || ve.menuState === 0, disabled: ie, hover: Pt, focus: ht, autofocus: se }), [ve, Pt, ht, kt, ie, se]), jt = _$2(oe(), { ref: Ee, id: ae, type: e$1(B, ve.buttonElement), "aria-haspopup": "menu", "aria-controls": (Y = ve.itemsElement) == null ? void 0 : Y.id, "aria-expanded": ve.menuState === 0, disabled: ie || void 0, autoFocus: se, onKeyDown: Ce, onKeyUp: Pe, onClick: Ve }, vt, _t, Ot);
  return L$1()({ ourProps: jt, theirProps: le, slot: Ht, defaultTag: rt, name: "Menu.Button" });
}
let at = "div", lt = O$3.RenderStrategy | O$3.Static;
function it(B, z) {
  var Y, ne;
  let ae = useId$1(), { id: ie = `headlessui-menu-items-${ae}`, anchor: se, portal: le = !1, modal: ve = !0, transition: ge = !1, ...oe } = B, Ee = xe(se), [Ce, Pe] = w("Menu.Items"), [Ve, ht] = Re(Ee), vt = be(), [Pt, _t] = useState(null), kt = y$4(z, Ee ? Ve : null, o$4((xt) => Pe({ type: 8, element: xt })), _t), Ot = n$1(Ce.itemsElement);
  Ee && (le = !0);
  let Ht = u$2(), [jt, Yt] = x$2(ge, Pt, Ht !== null ? (Ht & i$3.Open) === i$3.Open : Ce.menuState === 0);
  m$2(jt, Ce.buttonElement, () => {
    Pe({ type: 1 });
  });
  let Dt = Ce.__demoMode ? !1 : ve && Ce.menuState === 0;
  f$4(Dt, Ot);
  let Ct = Ce.__demoMode ? !1 : ve && Ce.menuState === 0;
  y$3(Ct, { allowed: useCallback(() => [Ce.buttonElement, Ce.itemsElement], [Ce.buttonElement, Ce.itemsElement]) });
  let Kt = Ce.menuState !== 0, Nt = s$2(Kt, Ce.buttonElement) ? !1 : jt;
  useEffect(() => {
    let xt = Ce.itemsElement;
    xt && Ce.menuState === 0 && xt !== (Ot == null ? void 0 : Ot.activeElement) && xt.focus({ preventScroll: !0 });
  }, [Ce.menuState, Ce.itemsElement, Ot]), F(Ce.menuState === 0, { container: Ce.itemsElement, accept(xt) {
    return xt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : xt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(xt) {
    xt.setAttribute("role", "none");
  } });
  let Je = p$2(), Xe = o$4((xt) => {
    var Bt, $t, qt;
    switch (Je.dispose(), xt.key) {
      case o$3.Space:
        if (Ce.searchQuery !== "") return xt.preventDefault(), xt.stopPropagation(), Pe({ type: 3, value: xt.key });
      case o$3.Enter:
        if (xt.preventDefault(), xt.stopPropagation(), Pe({ type: 1 }), Ce.activeItemIndex !== null) {
          let { dataRef: Rt } = Ce.items[Ce.activeItemIndex];
          ($t = (Bt = Rt.current) == null ? void 0 : Bt.domRef.current) == null || $t.click();
        }
        G(Ce.buttonElement);
        break;
      case o$3.ArrowDown:
        return xt.preventDefault(), xt.stopPropagation(), Pe({ type: 2, focus: c$1.Next });
      case o$3.ArrowUp:
        return xt.preventDefault(), xt.stopPropagation(), Pe({ type: 2, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return xt.preventDefault(), xt.stopPropagation(), Pe({ type: 2, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return xt.preventDefault(), xt.stopPropagation(), Pe({ type: 2, focus: c$1.Last });
      case o$3.Escape:
        xt.preventDefault(), xt.stopPropagation(), flushSync(() => Pe({ type: 1 })), (qt = Ce.buttonElement) == null || qt.focus({ preventScroll: !0 });
        break;
      case o$3.Tab:
        xt.preventDefault(), xt.stopPropagation(), flushSync(() => Pe({ type: 1 })), j$3(Ce.buttonElement, xt.shiftKey ? F$1.Previous : F$1.Next);
        break;
      default:
        xt.key.length === 1 && (Pe({ type: 3, value: xt.key }), Je.setTimeout(() => Pe({ type: 4 }), 350));
        break;
    }
  }), Ke = o$4((xt) => {
    switch (xt.key) {
      case o$3.Space:
        xt.preventDefault();
        break;
    }
  }), Qe = useMemo(() => ({ open: Ce.menuState === 0 }), [Ce.menuState]), bt = _$2(Ee ? vt() : {}, { "aria-activedescendant": Ce.activeItemIndex === null || (Y = Ce.items[Ce.activeItemIndex]) == null ? void 0 : Y.id, "aria-labelledby": (ne = Ce.buttonElement) == null ? void 0 : ne.id, id: ie, onKeyDown: Xe, onKeyUp: Ke, role: "menu", tabIndex: Ce.menuState === 0 ? 0 : void 0, ref: kt, style: { ...oe.style, ...ht, "--button-width": d$2(Ce.buttonElement, !0).width }, ...R$1(Yt) }), wt = L$1();
  return React__default.createElement(re$1, { enabled: le ? B.static || jt : !1 }, wt({ ourProps: bt, theirProps: oe, slot: Qe, defaultTag: at, features: lt, visible: Nt, name: "Menu.Items" }));
}
let st = Fragment;
function ut(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-item-${Y}`, disabled: ae = !1, ...ie } = B, [se, le] = w("Menu.Item"), ve = se.activeItemIndex !== null ? se.items[se.activeItemIndex].id === ne : !1, ge = useRef(null), oe = y$4(z, ge);
  n$3(() => {
    if (!se.__demoMode && se.menuState === 0 && ve && se.activationTrigger !== 0) return o$5().requestAnimationFrame(() => {
      var Nt, Je;
      (Je = (Nt = ge.current) == null ? void 0 : Nt.scrollIntoView) == null || Je.call(Nt, { block: "nearest" });
    });
  }, [se.__demoMode, ge, ve, se.menuState, se.activationTrigger, se.activeItemIndex]);
  let Ee = s$1(ge), Ce = useRef({ disabled: ae, domRef: ge, get textValue() {
    return Ee();
  } });
  n$3(() => {
    Ce.current.disabled = ae;
  }, [Ce, ae]), n$3(() => (le({ type: 5, id: ne, dataRef: Ce }), () => le({ type: 6, id: ne })), [Ce, ne]);
  let Pe = o$4(() => {
    le({ type: 1 });
  }), Ve = o$4((Nt) => {
    if (ae) return Nt.preventDefault();
    le({ type: 1 }), G(se.buttonElement);
  }), ht = o$4(() => {
    if (ae) return le({ type: 2, focus: c$1.Nothing });
    le({ type: 2, focus: c$1.Specific, id: ne });
  }), vt = u$3(), Pt = o$4((Nt) => {
    vt.update(Nt), !ae && (ve || le({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), _t = o$4((Nt) => {
    vt.wasMoved(Nt) && (ae || ve || le({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), kt = o$4((Nt) => {
    vt.wasMoved(Nt) && (ae || ve && le({ type: 2, focus: c$1.Nothing }));
  }), [Ot, Ht] = K(), [jt, Yt] = w$4(), Dt = useMemo(() => ({ active: ve, focus: ve, disabled: ae, close: Pe }), [ve, ae, Pe]), Ct = { id: ne, ref: oe, role: "menuitem", tabIndex: ae === !0 ? void 0 : -1, "aria-disabled": ae === !0 ? !0 : void 0, "aria-labelledby": Ot, "aria-describedby": jt, disabled: void 0, onClick: Ve, onFocus: ht, onPointerEnter: Pt, onMouseEnter: Pt, onPointerMove: _t, onMouseMove: _t, onPointerLeave: kt, onMouseLeave: kt }, Kt = L$1();
  return React__default.createElement(Ht, null, React__default.createElement(Yt, null, Kt({ ourProps: Ct, theirProps: ie, slot: Dt, defaultTag: st, name: "Menu.Item" })));
}
let pt = "div";
function mt(B, z) {
  let [Y, ne] = K(), ae = B, ie = { ref: z, "aria-labelledby": Y, role: "group" }, se = L$1();
  return React__default.createElement(ne, null, se({ ourProps: ie, theirProps: ae, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
let dt = "header";
function ct(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-heading-${Y}`, ...ae } = B, ie = P$1();
  n$3(() => ie.register(ne), [ne, ie.register]);
  let se = { id: ne, ref: z, role: "presentation", ...ie.props };
  return L$1()({ ourProps: se, theirProps: ae, slot: {}, defaultTag: dt, name: "Menu.Heading" });
}
let ft = "div";
function Tt(B, z) {
  let Y = B, ne = { ref: z, role: "separator" };
  return L$1()({ ourProps: ne, theirProps: Y, slot: {}, defaultTag: ft, name: "Menu.Separator" });
}
let yt = K$1(nt), It = K$1(ot), gt = K$1(it), Et = K$1(ut), Mt = K$1(mt), St = K$1(ct), At = K$1(Tt), rn = Object.assign(yt, { Button: It, Items: gt, Item: Et, Section: Mt, Heading: St, Separator: At });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, z = 4, Y = 5) {
  if (B.length <= z + Y)
    return B;
  const ne = B.slice(0, z), ae = B.slice(B.length - Y);
  return `${ne}...${ae}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: z,
  onViewProfile: Y,
  onChangeWallet: ne,
  onDisconnectWallet: ae,
  renderAvatar: ie
}) {
  const { wallet: se } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    rn,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: le }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            ie ? ie(B, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: B,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[se],
                alt: `${se} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[z] ?? z })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${le ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => Y == null ? void 0 : Y(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ne == null ? void 0 : ne(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ae == null ? void 0 : ae(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: B,
  disabled: z
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: z,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength$1(B) {
  var z = getLens$1(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength$1(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray$1(B) {
  var z, Y = getLens$1(B), ne = Y[0], ae = Y[1], ie = new Arr$1(_byteLength$1(B, ne, ae)), se = 0, le = ae > 0 ? ne - 4 : ne, ve;
  for (ve = 0; ve < le; ve += 4)
    z = revLookup$1[B.charCodeAt(ve)] << 18 | revLookup$1[B.charCodeAt(ve + 1)] << 12 | revLookup$1[B.charCodeAt(ve + 2)] << 6 | revLookup$1[B.charCodeAt(ve + 3)], ie[se++] = z >> 16 & 255, ie[se++] = z >> 8 & 255, ie[se++] = z & 255;
  return ae === 2 && (z = revLookup$1[B.charCodeAt(ve)] << 2 | revLookup$1[B.charCodeAt(ve + 1)] >> 4, ie[se++] = z & 255), ae === 1 && (z = revLookup$1[B.charCodeAt(ve)] << 10 | revLookup$1[B.charCodeAt(ve + 1)] << 4 | revLookup$1[B.charCodeAt(ve + 2)] >> 2, ie[se++] = z >> 8 & 255, ie[se++] = z & 255), ie;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, z, Y) {
  for (var ne, ae = [], ie = z; ie < Y; ie += 3)
    ne = (B[ie] << 16 & 16711680) + (B[ie + 1] << 8 & 65280) + (B[ie + 2] & 255), ae.push(tripletToBase64$1(ne));
  return ae.join("");
}
function fromByteArray$1(B) {
  for (var z, Y = B.length, ne = Y % 3, ae = [], ie = 16383, se = 0, le = Y - ne; se < le; se += ie)
    ae.push(encodeChunk$1(B, se, se + ie > le ? le : se + ie));
  return ne === 1 ? (z = B[Y - 1], ae.push(
    lookup$1[z >> 2] + lookup$1[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], ae.push(
    lookup$1[z >> 10] + lookup$1[z >> 4 & 63] + lookup$1[z << 2 & 63] + "="
  )), ae.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, z, Y, ne, ae) {
  var ie, se, le = ae * 8 - ne - 1, ve = (1 << le) - 1, ge = ve >> 1, oe = -7, Ee = Y ? ae - 1 : 0, Ce = Y ? -1 : 1, Pe = B[z + Ee];
  for (Ee += Ce, ie = Pe & (1 << -oe) - 1, Pe >>= -oe, oe += le; oe > 0; ie = ie * 256 + B[z + Ee], Ee += Ce, oe -= 8)
    ;
  for (se = ie & (1 << -oe) - 1, ie >>= -oe, oe += ne; oe > 0; se = se * 256 + B[z + Ee], Ee += Ce, oe -= 8)
    ;
  if (ie === 0)
    ie = 1 - ge;
  else {
    if (ie === ve)
      return se ? NaN : (Pe ? -1 : 1) * (1 / 0);
    se = se + Math.pow(2, ne), ie = ie - ge;
  }
  return (Pe ? -1 : 1) * se * Math.pow(2, ie - ne);
};
ieee754.write = function(B, z, Y, ne, ae, ie) {
  var se, le, ve, ge = ie * 8 - ae - 1, oe = (1 << ge) - 1, Ee = oe >> 1, Ce = ae === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Pe = ne ? 0 : ie - 1, Ve = ne ? 1 : -1, ht = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
  for (z = Math.abs(z), isNaN(z) || z === 1 / 0 ? (le = isNaN(z) ? 1 : 0, se = oe) : (se = Math.floor(Math.log(z) / Math.LN2), z * (ve = Math.pow(2, -se)) < 1 && (se--, ve *= 2), se + Ee >= 1 ? z += Ce / ve : z += Ce * Math.pow(2, 1 - Ee), z * ve >= 2 && (se++, ve /= 2), se + Ee >= oe ? (le = 0, se = oe) : se + Ee >= 1 ? (le = (z * ve - 1) * Math.pow(2, ae), se = se + Ee) : (le = z * Math.pow(2, Ee - 1) * Math.pow(2, ae), se = 0)); ae >= 8; B[Y + Pe] = le & 255, Pe += Ve, le /= 256, ae -= 8)
    ;
  for (se = se << ae | le, ge += ae; ge > 0; B[Y + Pe] = se & 255, Pe += Ve, se /= 256, ge -= 8)
    ;
  B[Y + Pe - Ve] |= ht * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const z = base64Js$1, Y = ieee754, ne = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = oe, B.SlowBuffer = Ht, B.INSPECT_MAX_BYTES = 50;
  const ae = 2147483647;
  B.kMaxLength = ae;
  const { Uint8Array: ie, ArrayBuffer: se, SharedArrayBuffer: le } = globalThis;
  oe.TYPED_ARRAY_SUPPORT = ve(), !oe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ve() {
    try {
      const Vt = new ie(1), Ft = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Ft, ie.prototype), Object.setPrototypeOf(Vt, Ft), Vt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(oe.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (oe.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(oe.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (oe.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ge(Vt) {
    if (Vt > ae)
      throw new RangeError('The value "' + Vt + '" is invalid for option "size"');
    const Ft = new ie(Vt);
    return Object.setPrototypeOf(Ft, oe.prototype), Ft;
  }
  function oe(Vt, Ft, Ut) {
    if (typeof Vt == "number") {
      if (typeof Ft == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Ve(Vt);
    }
    return Ee(Vt, Ft, Ut);
  }
  oe.poolSize = 8192;
  function Ee(Vt, Ft, Ut) {
    if (typeof Vt == "string")
      return ht(Vt, Ft);
    if (se.isView(Vt))
      return Pt(Vt);
    if (Vt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Vt
      );
    if (Hr(Vt, se) || Vt && Hr(Vt.buffer, se) || typeof le < "u" && (Hr(Vt, le) || Vt && Hr(Vt.buffer, le)))
      return _t(Vt, Ft, Ut);
    if (typeof Vt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Qt = Vt.valueOf && Vt.valueOf();
    if (Qt != null && Qt !== Vt)
      return oe.from(Qt, Ft, Ut);
    const fr = kt(Vt);
    if (fr) return fr;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Vt[Symbol.toPrimitive] == "function")
      return oe.from(Vt[Symbol.toPrimitive]("string"), Ft, Ut);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Vt
    );
  }
  oe.from = function(Vt, Ft, Ut) {
    return Ee(Vt, Ft, Ut);
  }, Object.setPrototypeOf(oe.prototype, ie.prototype), Object.setPrototypeOf(oe, ie);
  function Ce(Vt) {
    if (typeof Vt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Vt < 0)
      throw new RangeError('The value "' + Vt + '" is invalid for option "size"');
  }
  function Pe(Vt, Ft, Ut) {
    return Ce(Vt), Vt <= 0 ? ge(Vt) : Ft !== void 0 ? typeof Ut == "string" ? ge(Vt).fill(Ft, Ut) : ge(Vt).fill(Ft) : ge(Vt);
  }
  oe.alloc = function(Vt, Ft, Ut) {
    return Pe(Vt, Ft, Ut);
  };
  function Ve(Vt) {
    return Ce(Vt), ge(Vt < 0 ? 0 : Ot(Vt) | 0);
  }
  oe.allocUnsafe = function(Vt) {
    return Ve(Vt);
  }, oe.allocUnsafeSlow = function(Vt) {
    return Ve(Vt);
  };
  function ht(Vt, Ft) {
    if ((typeof Ft != "string" || Ft === "") && (Ft = "utf8"), !oe.isEncoding(Ft))
      throw new TypeError("Unknown encoding: " + Ft);
    const Ut = jt(Vt, Ft) | 0;
    let Qt = ge(Ut);
    const fr = Qt.write(Vt, Ft);
    return fr !== Ut && (Qt = Qt.slice(0, fr)), Qt;
  }
  function vt(Vt) {
    const Ft = Vt.length < 0 ? 0 : Ot(Vt.length) | 0, Ut = ge(Ft);
    for (let Qt = 0; Qt < Ft; Qt += 1)
      Ut[Qt] = Vt[Qt] & 255;
    return Ut;
  }
  function Pt(Vt) {
    if (Hr(Vt, ie)) {
      const Ft = new ie(Vt);
      return _t(Ft.buffer, Ft.byteOffset, Ft.byteLength);
    }
    return vt(Vt);
  }
  function _t(Vt, Ft, Ut) {
    if (Ft < 0 || Vt.byteLength < Ft)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Vt.byteLength < Ft + (Ut || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Qt;
    return Ft === void 0 && Ut === void 0 ? Qt = new ie(Vt) : Ut === void 0 ? Qt = new ie(Vt, Ft) : Qt = new ie(Vt, Ft, Ut), Object.setPrototypeOf(Qt, oe.prototype), Qt;
  }
  function kt(Vt) {
    if (oe.isBuffer(Vt)) {
      const Ft = Ot(Vt.length) | 0, Ut = ge(Ft);
      return Ut.length === 0 || Vt.copy(Ut, 0, 0, Ft), Ut;
    }
    if (Vt.length !== void 0)
      return typeof Vt.length != "number" || Xr(Vt.length) ? ge(0) : vt(Vt);
    if (Vt.type === "Buffer" && Array.isArray(Vt.data))
      return vt(Vt.data);
  }
  function Ot(Vt) {
    if (Vt >= ae)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ae.toString(16) + " bytes");
    return Vt | 0;
  }
  function Ht(Vt) {
    return +Vt != Vt && (Vt = 0), oe.alloc(+Vt);
  }
  oe.isBuffer = function(Ft) {
    return Ft != null && Ft._isBuffer === !0 && Ft !== oe.prototype;
  }, oe.compare = function(Ft, Ut) {
    if (Hr(Ft, ie) && (Ft = oe.from(Ft, Ft.offset, Ft.byteLength)), Hr(Ut, ie) && (Ut = oe.from(Ut, Ut.offset, Ut.byteLength)), !oe.isBuffer(Ft) || !oe.isBuffer(Ut))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Ft === Ut) return 0;
    let Qt = Ft.length, fr = Ut.length;
    for (let cr = 0, lr = Math.min(Qt, fr); cr < lr; ++cr)
      if (Ft[cr] !== Ut[cr]) {
        Qt = Ft[cr], fr = Ut[cr];
        break;
      }
    return Qt < fr ? -1 : fr < Qt ? 1 : 0;
  }, oe.isEncoding = function(Ft) {
    switch (String(Ft).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, oe.concat = function(Ft, Ut) {
    if (!Array.isArray(Ft))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Ft.length === 0)
      return oe.alloc(0);
    let Qt;
    if (Ut === void 0)
      for (Ut = 0, Qt = 0; Qt < Ft.length; ++Qt)
        Ut += Ft[Qt].length;
    const fr = oe.allocUnsafe(Ut);
    let cr = 0;
    for (Qt = 0; Qt < Ft.length; ++Qt) {
      let lr = Ft[Qt];
      if (Hr(lr, ie))
        cr + lr.length > fr.length ? (oe.isBuffer(lr) || (lr = oe.from(lr)), lr.copy(fr, cr)) : ie.prototype.set.call(
          fr,
          lr,
          cr
        );
      else if (oe.isBuffer(lr))
        lr.copy(fr, cr);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      cr += lr.length;
    }
    return fr;
  };
  function jt(Vt, Ft) {
    if (oe.isBuffer(Vt))
      return Vt.length;
    if (se.isView(Vt) || Hr(Vt, se))
      return Vt.byteLength;
    if (typeof Vt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Vt
      );
    const Ut = Vt.length, Qt = arguments.length > 2 && arguments[2] === !0;
    if (!Qt && Ut === 0) return 0;
    let fr = !1;
    for (; ; )
      switch (Ft) {
        case "ascii":
        case "latin1":
        case "binary":
          return Ut;
        case "utf8":
        case "utf-8":
          return Wr(Vt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ut * 2;
        case "hex":
          return Ut >>> 1;
        case "base64":
          return Gr(Vt).length;
        default:
          if (fr)
            return Qt ? -1 : Wr(Vt).length;
          Ft = ("" + Ft).toLowerCase(), fr = !0;
      }
  }
  oe.byteLength = jt;
  function Yt(Vt, Ft, Ut) {
    let Qt = !1;
    if ((Ft === void 0 || Ft < 0) && (Ft = 0), Ft > this.length || ((Ut === void 0 || Ut > this.length) && (Ut = this.length), Ut <= 0) || (Ut >>>= 0, Ft >>>= 0, Ut <= Ft))
      return "";
    for (Vt || (Vt = "utf8"); ; )
      switch (Vt) {
        case "hex":
          return Rt(this, Ft, Ut);
        case "utf8":
        case "utf-8":
          return wt(this, Ft, Ut);
        case "ascii":
          return $t(this, Ft, Ut);
        case "latin1":
        case "binary":
          return qt(this, Ft, Ut);
        case "base64":
          return bt(this, Ft, Ut);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Lt(this, Ft, Ut);
        default:
          if (Qt) throw new TypeError("Unknown encoding: " + Vt);
          Vt = (Vt + "").toLowerCase(), Qt = !0;
      }
  }
  oe.prototype._isBuffer = !0;
  function Dt(Vt, Ft, Ut) {
    const Qt = Vt[Ft];
    Vt[Ft] = Vt[Ut], Vt[Ut] = Qt;
  }
  oe.prototype.swap16 = function() {
    const Ft = this.length;
    if (Ft % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Ut = 0; Ut < Ft; Ut += 2)
      Dt(this, Ut, Ut + 1);
    return this;
  }, oe.prototype.swap32 = function() {
    const Ft = this.length;
    if (Ft % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Ut = 0; Ut < Ft; Ut += 4)
      Dt(this, Ut, Ut + 3), Dt(this, Ut + 1, Ut + 2);
    return this;
  }, oe.prototype.swap64 = function() {
    const Ft = this.length;
    if (Ft % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Ut = 0; Ut < Ft; Ut += 8)
      Dt(this, Ut, Ut + 7), Dt(this, Ut + 1, Ut + 6), Dt(this, Ut + 2, Ut + 5), Dt(this, Ut + 3, Ut + 4);
    return this;
  }, oe.prototype.toString = function() {
    const Ft = this.length;
    return Ft === 0 ? "" : arguments.length === 0 ? wt(this, 0, Ft) : Yt.apply(this, arguments);
  }, oe.prototype.toLocaleString = oe.prototype.toString, oe.prototype.equals = function(Ft) {
    if (!oe.isBuffer(Ft)) throw new TypeError("Argument must be a Buffer");
    return this === Ft ? !0 : oe.compare(this, Ft) === 0;
  }, oe.prototype.inspect = function() {
    let Ft = "";
    const Ut = B.INSPECT_MAX_BYTES;
    return Ft = this.toString("hex", 0, Ut).replace(/(.{2})/g, "$1 ").trim(), this.length > Ut && (Ft += " ... "), "<Buffer " + Ft + ">";
  }, ne && (oe.prototype[ne] = oe.prototype.inspect), oe.prototype.compare = function(Ft, Ut, Qt, fr, cr) {
    if (Hr(Ft, ie) && (Ft = oe.from(Ft, Ft.offset, Ft.byteLength)), !oe.isBuffer(Ft))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ft
      );
    if (Ut === void 0 && (Ut = 0), Qt === void 0 && (Qt = Ft ? Ft.length : 0), fr === void 0 && (fr = 0), cr === void 0 && (cr = this.length), Ut < 0 || Qt > Ft.length || fr < 0 || cr > this.length)
      throw new RangeError("out of range index");
    if (fr >= cr && Ut >= Qt)
      return 0;
    if (fr >= cr)
      return -1;
    if (Ut >= Qt)
      return 1;
    if (Ut >>>= 0, Qt >>>= 0, fr >>>= 0, cr >>>= 0, this === Ft) return 0;
    let lr = cr - fr, kr = Qt - Ut;
    const jr = Math.min(lr, kr), Br = this.slice(fr, cr), Dr = Ft.slice(Ut, Qt);
    for (let Lr = 0; Lr < jr; ++Lr)
      if (Br[Lr] !== Dr[Lr]) {
        lr = Br[Lr], kr = Dr[Lr];
        break;
      }
    return lr < kr ? -1 : kr < lr ? 1 : 0;
  };
  function Ct(Vt, Ft, Ut, Qt, fr) {
    if (Vt.length === 0) return -1;
    if (typeof Ut == "string" ? (Qt = Ut, Ut = 0) : Ut > 2147483647 ? Ut = 2147483647 : Ut < -2147483648 && (Ut = -2147483648), Ut = +Ut, Xr(Ut) && (Ut = fr ? 0 : Vt.length - 1), Ut < 0 && (Ut = Vt.length + Ut), Ut >= Vt.length) {
      if (fr) return -1;
      Ut = Vt.length - 1;
    } else if (Ut < 0)
      if (fr) Ut = 0;
      else return -1;
    if (typeof Ft == "string" && (Ft = oe.from(Ft, Qt)), oe.isBuffer(Ft))
      return Ft.length === 0 ? -1 : Kt(Vt, Ft, Ut, Qt, fr);
    if (typeof Ft == "number")
      return Ft = Ft & 255, typeof ie.prototype.indexOf == "function" ? fr ? ie.prototype.indexOf.call(Vt, Ft, Ut) : ie.prototype.lastIndexOf.call(Vt, Ft, Ut) : Kt(Vt, [Ft], Ut, Qt, fr);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Kt(Vt, Ft, Ut, Qt, fr) {
    let cr = 1, lr = Vt.length, kr = Ft.length;
    if (Qt !== void 0 && (Qt = String(Qt).toLowerCase(), Qt === "ucs2" || Qt === "ucs-2" || Qt === "utf16le" || Qt === "utf-16le")) {
      if (Vt.length < 2 || Ft.length < 2)
        return -1;
      cr = 2, lr /= 2, kr /= 2, Ut /= 2;
    }
    function jr(Dr, Lr) {
      return cr === 1 ? Dr[Lr] : Dr.readUInt16BE(Lr * cr);
    }
    let Br;
    if (fr) {
      let Dr = -1;
      for (Br = Ut; Br < lr; Br++)
        if (jr(Vt, Br) === jr(Ft, Dr === -1 ? 0 : Br - Dr)) {
          if (Dr === -1 && (Dr = Br), Br - Dr + 1 === kr) return Dr * cr;
        } else
          Dr !== -1 && (Br -= Br - Dr), Dr = -1;
    } else
      for (Ut + kr > lr && (Ut = lr - kr), Br = Ut; Br >= 0; Br--) {
        let Dr = !0;
        for (let Lr = 0; Lr < kr; Lr++)
          if (jr(Vt, Br + Lr) !== jr(Ft, Lr)) {
            Dr = !1;
            break;
          }
        if (Dr) return Br;
      }
    return -1;
  }
  oe.prototype.includes = function(Ft, Ut, Qt) {
    return this.indexOf(Ft, Ut, Qt) !== -1;
  }, oe.prototype.indexOf = function(Ft, Ut, Qt) {
    return Ct(this, Ft, Ut, Qt, !0);
  }, oe.prototype.lastIndexOf = function(Ft, Ut, Qt) {
    return Ct(this, Ft, Ut, Qt, !1);
  };
  function Nt(Vt, Ft, Ut, Qt) {
    Ut = Number(Ut) || 0;
    const fr = Vt.length - Ut;
    Qt ? (Qt = Number(Qt), Qt > fr && (Qt = fr)) : Qt = fr;
    const cr = Ft.length;
    Qt > cr / 2 && (Qt = cr / 2);
    let lr;
    for (lr = 0; lr < Qt; ++lr) {
      const kr = parseInt(Ft.substr(lr * 2, 2), 16);
      if (Xr(kr)) return lr;
      Vt[Ut + lr] = kr;
    }
    return lr;
  }
  function Je(Vt, Ft, Ut, Qt) {
    return Rr(Wr(Ft, Vt.length - Ut), Vt, Ut, Qt);
  }
  function Xe(Vt, Ft, Ut, Qt) {
    return Rr($r(Ft), Vt, Ut, Qt);
  }
  function Ke(Vt, Ft, Ut, Qt) {
    return Rr(Gr(Ft), Vt, Ut, Qt);
  }
  function Qe(Vt, Ft, Ut, Qt) {
    return Rr(Ur(Ft, Vt.length - Ut), Vt, Ut, Qt);
  }
  oe.prototype.write = function(Ft, Ut, Qt, fr) {
    if (Ut === void 0)
      fr = "utf8", Qt = this.length, Ut = 0;
    else if (Qt === void 0 && typeof Ut == "string")
      fr = Ut, Qt = this.length, Ut = 0;
    else if (isFinite(Ut))
      Ut = Ut >>> 0, isFinite(Qt) ? (Qt = Qt >>> 0, fr === void 0 && (fr = "utf8")) : (fr = Qt, Qt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const cr = this.length - Ut;
    if ((Qt === void 0 || Qt > cr) && (Qt = cr), Ft.length > 0 && (Qt < 0 || Ut < 0) || Ut > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    fr || (fr = "utf8");
    let lr = !1;
    for (; ; )
      switch (fr) {
        case "hex":
          return Nt(this, Ft, Ut, Qt);
        case "utf8":
        case "utf-8":
          return Je(this, Ft, Ut, Qt);
        case "ascii":
        case "latin1":
        case "binary":
          return Xe(this, Ft, Ut, Qt);
        case "base64":
          return Ke(this, Ft, Ut, Qt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Qe(this, Ft, Ut, Qt);
        default:
          if (lr) throw new TypeError("Unknown encoding: " + fr);
          fr = ("" + fr).toLowerCase(), lr = !0;
      }
  }, oe.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function bt(Vt, Ft, Ut) {
    return Ft === 0 && Ut === Vt.length ? z.fromByteArray(Vt) : z.fromByteArray(Vt.slice(Ft, Ut));
  }
  function wt(Vt, Ft, Ut) {
    Ut = Math.min(Vt.length, Ut);
    const Qt = [];
    let fr = Ft;
    for (; fr < Ut; ) {
      const cr = Vt[fr];
      let lr = null, kr = cr > 239 ? 4 : cr > 223 ? 3 : cr > 191 ? 2 : 1;
      if (fr + kr <= Ut) {
        let jr, Br, Dr, Lr;
        switch (kr) {
          case 1:
            cr < 128 && (lr = cr);
            break;
          case 2:
            jr = Vt[fr + 1], (jr & 192) === 128 && (Lr = (cr & 31) << 6 | jr & 63, Lr > 127 && (lr = Lr));
            break;
          case 3:
            jr = Vt[fr + 1], Br = Vt[fr + 2], (jr & 192) === 128 && (Br & 192) === 128 && (Lr = (cr & 15) << 12 | (jr & 63) << 6 | Br & 63, Lr > 2047 && (Lr < 55296 || Lr > 57343) && (lr = Lr));
            break;
          case 4:
            jr = Vt[fr + 1], Br = Vt[fr + 2], Dr = Vt[fr + 3], (jr & 192) === 128 && (Br & 192) === 128 && (Dr & 192) === 128 && (Lr = (cr & 15) << 18 | (jr & 63) << 12 | (Br & 63) << 6 | Dr & 63, Lr > 65535 && Lr < 1114112 && (lr = Lr));
        }
      }
      lr === null ? (lr = 65533, kr = 1) : lr > 65535 && (lr -= 65536, Qt.push(lr >>> 10 & 1023 | 55296), lr = 56320 | lr & 1023), Qt.push(lr), fr += kr;
    }
    return Bt(Qt);
  }
  const xt = 4096;
  function Bt(Vt) {
    const Ft = Vt.length;
    if (Ft <= xt)
      return String.fromCharCode.apply(String, Vt);
    let Ut = "", Qt = 0;
    for (; Qt < Ft; )
      Ut += String.fromCharCode.apply(
        String,
        Vt.slice(Qt, Qt += xt)
      );
    return Ut;
  }
  function $t(Vt, Ft, Ut) {
    let Qt = "";
    Ut = Math.min(Vt.length, Ut);
    for (let fr = Ft; fr < Ut; ++fr)
      Qt += String.fromCharCode(Vt[fr] & 127);
    return Qt;
  }
  function qt(Vt, Ft, Ut) {
    let Qt = "";
    Ut = Math.min(Vt.length, Ut);
    for (let fr = Ft; fr < Ut; ++fr)
      Qt += String.fromCharCode(Vt[fr]);
    return Qt;
  }
  function Rt(Vt, Ft, Ut) {
    const Qt = Vt.length;
    (!Ft || Ft < 0) && (Ft = 0), (!Ut || Ut < 0 || Ut > Qt) && (Ut = Qt);
    let fr = "";
    for (let cr = Ft; cr < Ut; ++cr)
      fr += qr[Vt[cr]];
    return fr;
  }
  function Lt(Vt, Ft, Ut) {
    const Qt = Vt.slice(Ft, Ut);
    let fr = "";
    for (let cr = 0; cr < Qt.length - 1; cr += 2)
      fr += String.fromCharCode(Qt[cr] + Qt[cr + 1] * 256);
    return fr;
  }
  oe.prototype.slice = function(Ft, Ut) {
    const Qt = this.length;
    Ft = ~~Ft, Ut = Ut === void 0 ? Qt : ~~Ut, Ft < 0 ? (Ft += Qt, Ft < 0 && (Ft = 0)) : Ft > Qt && (Ft = Qt), Ut < 0 ? (Ut += Qt, Ut < 0 && (Ut = 0)) : Ut > Qt && (Ut = Qt), Ut < Ft && (Ut = Ft);
    const fr = this.subarray(Ft, Ut);
    return Object.setPrototypeOf(fr, oe.prototype), fr;
  };
  function tr(Vt, Ft, Ut) {
    if (Vt % 1 !== 0 || Vt < 0) throw new RangeError("offset is not uint");
    if (Vt + Ft > Ut) throw new RangeError("Trying to access beyond buffer length");
  }
  oe.prototype.readUintLE = oe.prototype.readUIntLE = function(Ft, Ut, Qt) {
    Ft = Ft >>> 0, Ut = Ut >>> 0, Qt || tr(Ft, Ut, this.length);
    let fr = this[Ft], cr = 1, lr = 0;
    for (; ++lr < Ut && (cr *= 256); )
      fr += this[Ft + lr] * cr;
    return fr;
  }, oe.prototype.readUintBE = oe.prototype.readUIntBE = function(Ft, Ut, Qt) {
    Ft = Ft >>> 0, Ut = Ut >>> 0, Qt || tr(Ft, Ut, this.length);
    let fr = this[Ft + --Ut], cr = 1;
    for (; Ut > 0 && (cr *= 256); )
      fr += this[Ft + --Ut] * cr;
    return fr;
  }, oe.prototype.readUint8 = oe.prototype.readUInt8 = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 1, this.length), this[Ft];
  }, oe.prototype.readUint16LE = oe.prototype.readUInt16LE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 2, this.length), this[Ft] | this[Ft + 1] << 8;
  }, oe.prototype.readUint16BE = oe.prototype.readUInt16BE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 2, this.length), this[Ft] << 8 | this[Ft + 1];
  }, oe.prototype.readUint32LE = oe.prototype.readUInt32LE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 4, this.length), (this[Ft] | this[Ft + 1] << 8 | this[Ft + 2] << 16) + this[Ft + 3] * 16777216;
  }, oe.prototype.readUint32BE = oe.prototype.readUInt32BE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 4, this.length), this[Ft] * 16777216 + (this[Ft + 1] << 16 | this[Ft + 2] << 8 | this[Ft + 3]);
  }, oe.prototype.readBigUInt64LE = zr(function(Ft) {
    Ft = Ft >>> 0, _r(Ft, "offset");
    const Ut = this[Ft], Qt = this[Ft + 7];
    (Ut === void 0 || Qt === void 0) && xr(Ft, this.length - 8);
    const fr = Ut + this[++Ft] * 2 ** 8 + this[++Ft] * 2 ** 16 + this[++Ft] * 2 ** 24, cr = this[++Ft] + this[++Ft] * 2 ** 8 + this[++Ft] * 2 ** 16 + Qt * 2 ** 24;
    return BigInt(fr) + (BigInt(cr) << BigInt(32));
  }), oe.prototype.readBigUInt64BE = zr(function(Ft) {
    Ft = Ft >>> 0, _r(Ft, "offset");
    const Ut = this[Ft], Qt = this[Ft + 7];
    (Ut === void 0 || Qt === void 0) && xr(Ft, this.length - 8);
    const fr = Ut * 2 ** 24 + this[++Ft] * 2 ** 16 + this[++Ft] * 2 ** 8 + this[++Ft], cr = this[++Ft] * 2 ** 24 + this[++Ft] * 2 ** 16 + this[++Ft] * 2 ** 8 + Qt;
    return (BigInt(fr) << BigInt(32)) + BigInt(cr);
  }), oe.prototype.readIntLE = function(Ft, Ut, Qt) {
    Ft = Ft >>> 0, Ut = Ut >>> 0, Qt || tr(Ft, Ut, this.length);
    let fr = this[Ft], cr = 1, lr = 0;
    for (; ++lr < Ut && (cr *= 256); )
      fr += this[Ft + lr] * cr;
    return cr *= 128, fr >= cr && (fr -= Math.pow(2, 8 * Ut)), fr;
  }, oe.prototype.readIntBE = function(Ft, Ut, Qt) {
    Ft = Ft >>> 0, Ut = Ut >>> 0, Qt || tr(Ft, Ut, this.length);
    let fr = Ut, cr = 1, lr = this[Ft + --fr];
    for (; fr > 0 && (cr *= 256); )
      lr += this[Ft + --fr] * cr;
    return cr *= 128, lr >= cr && (lr -= Math.pow(2, 8 * Ut)), lr;
  }, oe.prototype.readInt8 = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 1, this.length), this[Ft] & 128 ? (255 - this[Ft] + 1) * -1 : this[Ft];
  }, oe.prototype.readInt16LE = function(Ft, Ut) {
    Ft = Ft >>> 0, Ut || tr(Ft, 2, this.length);
    const Qt = this[Ft] | this[Ft + 1] << 8;
    return Qt & 32768 ? Qt | 4294901760 : Qt;
  }, oe.prototype.readInt16BE = function(Ft, Ut) {
    Ft = Ft >>> 0, Ut || tr(Ft, 2, this.length);
    const Qt = this[Ft + 1] | this[Ft] << 8;
    return Qt & 32768 ? Qt | 4294901760 : Qt;
  }, oe.prototype.readInt32LE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 4, this.length), this[Ft] | this[Ft + 1] << 8 | this[Ft + 2] << 16 | this[Ft + 3] << 24;
  }, oe.prototype.readInt32BE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 4, this.length), this[Ft] << 24 | this[Ft + 1] << 16 | this[Ft + 2] << 8 | this[Ft + 3];
  }, oe.prototype.readBigInt64LE = zr(function(Ft) {
    Ft = Ft >>> 0, _r(Ft, "offset");
    const Ut = this[Ft], Qt = this[Ft + 7];
    (Ut === void 0 || Qt === void 0) && xr(Ft, this.length - 8);
    const fr = this[Ft + 4] + this[Ft + 5] * 2 ** 8 + this[Ft + 6] * 2 ** 16 + (Qt << 24);
    return (BigInt(fr) << BigInt(32)) + BigInt(Ut + this[++Ft] * 2 ** 8 + this[++Ft] * 2 ** 16 + this[++Ft] * 2 ** 24);
  }), oe.prototype.readBigInt64BE = zr(function(Ft) {
    Ft = Ft >>> 0, _r(Ft, "offset");
    const Ut = this[Ft], Qt = this[Ft + 7];
    (Ut === void 0 || Qt === void 0) && xr(Ft, this.length - 8);
    const fr = (Ut << 24) + // Overflow
    this[++Ft] * 2 ** 16 + this[++Ft] * 2 ** 8 + this[++Ft];
    return (BigInt(fr) << BigInt(32)) + BigInt(this[++Ft] * 2 ** 24 + this[++Ft] * 2 ** 16 + this[++Ft] * 2 ** 8 + Qt);
  }), oe.prototype.readFloatLE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 4, this.length), Y.read(this, Ft, !0, 23, 4);
  }, oe.prototype.readFloatBE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 4, this.length), Y.read(this, Ft, !1, 23, 4);
  }, oe.prototype.readDoubleLE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 8, this.length), Y.read(this, Ft, !0, 52, 8);
  }, oe.prototype.readDoubleBE = function(Ft, Ut) {
    return Ft = Ft >>> 0, Ut || tr(Ft, 8, this.length), Y.read(this, Ft, !1, 52, 8);
  };
  function sr(Vt, Ft, Ut, Qt, fr, cr) {
    if (!oe.isBuffer(Vt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Ft > fr || Ft < cr) throw new RangeError('"value" argument is out of bounds');
    if (Ut + Qt > Vt.length) throw new RangeError("Index out of range");
  }
  oe.prototype.writeUintLE = oe.prototype.writeUIntLE = function(Ft, Ut, Qt, fr) {
    if (Ft = +Ft, Ut = Ut >>> 0, Qt = Qt >>> 0, !fr) {
      const kr = Math.pow(2, 8 * Qt) - 1;
      sr(this, Ft, Ut, Qt, kr, 0);
    }
    let cr = 1, lr = 0;
    for (this[Ut] = Ft & 255; ++lr < Qt && (cr *= 256); )
      this[Ut + lr] = Ft / cr & 255;
    return Ut + Qt;
  }, oe.prototype.writeUintBE = oe.prototype.writeUIntBE = function(Ft, Ut, Qt, fr) {
    if (Ft = +Ft, Ut = Ut >>> 0, Qt = Qt >>> 0, !fr) {
      const kr = Math.pow(2, 8 * Qt) - 1;
      sr(this, Ft, Ut, Qt, kr, 0);
    }
    let cr = Qt - 1, lr = 1;
    for (this[Ut + cr] = Ft & 255; --cr >= 0 && (lr *= 256); )
      this[Ut + cr] = Ft / lr & 255;
    return Ut + Qt;
  }, oe.prototype.writeUint8 = oe.prototype.writeUInt8 = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 1, 255, 0), this[Ut] = Ft & 255, Ut + 1;
  }, oe.prototype.writeUint16LE = oe.prototype.writeUInt16LE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 2, 65535, 0), this[Ut] = Ft & 255, this[Ut + 1] = Ft >>> 8, Ut + 2;
  }, oe.prototype.writeUint16BE = oe.prototype.writeUInt16BE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 2, 65535, 0), this[Ut] = Ft >>> 8, this[Ut + 1] = Ft & 255, Ut + 2;
  }, oe.prototype.writeUint32LE = oe.prototype.writeUInt32LE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 4, 4294967295, 0), this[Ut + 3] = Ft >>> 24, this[Ut + 2] = Ft >>> 16, this[Ut + 1] = Ft >>> 8, this[Ut] = Ft & 255, Ut + 4;
  }, oe.prototype.writeUint32BE = oe.prototype.writeUInt32BE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 4, 4294967295, 0), this[Ut] = Ft >>> 24, this[Ut + 1] = Ft >>> 16, this[Ut + 2] = Ft >>> 8, this[Ut + 3] = Ft & 255, Ut + 4;
  };
  function Zt(Vt, Ft, Ut, Qt, fr) {
    vr(Ft, Qt, fr, Vt, Ut, 7);
    let cr = Number(Ft & BigInt(4294967295));
    Vt[Ut++] = cr, cr = cr >> 8, Vt[Ut++] = cr, cr = cr >> 8, Vt[Ut++] = cr, cr = cr >> 8, Vt[Ut++] = cr;
    let lr = Number(Ft >> BigInt(32) & BigInt(4294967295));
    return Vt[Ut++] = lr, lr = lr >> 8, Vt[Ut++] = lr, lr = lr >> 8, Vt[Ut++] = lr, lr = lr >> 8, Vt[Ut++] = lr, Ut;
  }
  function Wt(Vt, Ft, Ut, Qt, fr) {
    vr(Ft, Qt, fr, Vt, Ut, 7);
    let cr = Number(Ft & BigInt(4294967295));
    Vt[Ut + 7] = cr, cr = cr >> 8, Vt[Ut + 6] = cr, cr = cr >> 8, Vt[Ut + 5] = cr, cr = cr >> 8, Vt[Ut + 4] = cr;
    let lr = Number(Ft >> BigInt(32) & BigInt(4294967295));
    return Vt[Ut + 3] = lr, lr = lr >> 8, Vt[Ut + 2] = lr, lr = lr >> 8, Vt[Ut + 1] = lr, lr = lr >> 8, Vt[Ut] = lr, Ut + 8;
  }
  oe.prototype.writeBigUInt64LE = zr(function(Ft, Ut = 0) {
    return Zt(this, Ft, Ut, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeBigUInt64BE = zr(function(Ft, Ut = 0) {
    return Wt(this, Ft, Ut, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeIntLE = function(Ft, Ut, Qt, fr) {
    if (Ft = +Ft, Ut = Ut >>> 0, !fr) {
      const jr = Math.pow(2, 8 * Qt - 1);
      sr(this, Ft, Ut, Qt, jr - 1, -jr);
    }
    let cr = 0, lr = 1, kr = 0;
    for (this[Ut] = Ft & 255; ++cr < Qt && (lr *= 256); )
      Ft < 0 && kr === 0 && this[Ut + cr - 1] !== 0 && (kr = 1), this[Ut + cr] = (Ft / lr >> 0) - kr & 255;
    return Ut + Qt;
  }, oe.prototype.writeIntBE = function(Ft, Ut, Qt, fr) {
    if (Ft = +Ft, Ut = Ut >>> 0, !fr) {
      const jr = Math.pow(2, 8 * Qt - 1);
      sr(this, Ft, Ut, Qt, jr - 1, -jr);
    }
    let cr = Qt - 1, lr = 1, kr = 0;
    for (this[Ut + cr] = Ft & 255; --cr >= 0 && (lr *= 256); )
      Ft < 0 && kr === 0 && this[Ut + cr + 1] !== 0 && (kr = 1), this[Ut + cr] = (Ft / lr >> 0) - kr & 255;
    return Ut + Qt;
  }, oe.prototype.writeInt8 = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 1, 127, -128), Ft < 0 && (Ft = 255 + Ft + 1), this[Ut] = Ft & 255, Ut + 1;
  }, oe.prototype.writeInt16LE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 2, 32767, -32768), this[Ut] = Ft & 255, this[Ut + 1] = Ft >>> 8, Ut + 2;
  }, oe.prototype.writeInt16BE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 2, 32767, -32768), this[Ut] = Ft >>> 8, this[Ut + 1] = Ft & 255, Ut + 2;
  }, oe.prototype.writeInt32LE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 4, 2147483647, -2147483648), this[Ut] = Ft & 255, this[Ut + 1] = Ft >>> 8, this[Ut + 2] = Ft >>> 16, this[Ut + 3] = Ft >>> 24, Ut + 4;
  }, oe.prototype.writeInt32BE = function(Ft, Ut, Qt) {
    return Ft = +Ft, Ut = Ut >>> 0, Qt || sr(this, Ft, Ut, 4, 2147483647, -2147483648), Ft < 0 && (Ft = 4294967295 + Ft + 1), this[Ut] = Ft >>> 24, this[Ut + 1] = Ft >>> 16, this[Ut + 2] = Ft >>> 8, this[Ut + 3] = Ft & 255, Ut + 4;
  }, oe.prototype.writeBigInt64LE = zr(function(Ft, Ut = 0) {
    return Zt(this, Ft, Ut, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), oe.prototype.writeBigInt64BE = zr(function(Ft, Ut = 0) {
    return Wt(this, Ft, Ut, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Gt(Vt, Ft, Ut, Qt, fr, cr) {
    if (Ut + Qt > Vt.length) throw new RangeError("Index out of range");
    if (Ut < 0) throw new RangeError("Index out of range");
  }
  function rr(Vt, Ft, Ut, Qt, fr) {
    return Ft = +Ft, Ut = Ut >>> 0, fr || Gt(Vt, Ft, Ut, 4), Y.write(Vt, Ft, Ut, Qt, 23, 4), Ut + 4;
  }
  oe.prototype.writeFloatLE = function(Ft, Ut, Qt) {
    return rr(this, Ft, Ut, !0, Qt);
  }, oe.prototype.writeFloatBE = function(Ft, Ut, Qt) {
    return rr(this, Ft, Ut, !1, Qt);
  };
  function or(Vt, Ft, Ut, Qt, fr) {
    return Ft = +Ft, Ut = Ut >>> 0, fr || Gt(Vt, Ft, Ut, 8), Y.write(Vt, Ft, Ut, Qt, 52, 8), Ut + 8;
  }
  oe.prototype.writeDoubleLE = function(Ft, Ut, Qt) {
    return or(this, Ft, Ut, !0, Qt);
  }, oe.prototype.writeDoubleBE = function(Ft, Ut, Qt) {
    return or(this, Ft, Ut, !1, Qt);
  }, oe.prototype.copy = function(Ft, Ut, Qt, fr) {
    if (!oe.isBuffer(Ft)) throw new TypeError("argument should be a Buffer");
    if (Qt || (Qt = 0), !fr && fr !== 0 && (fr = this.length), Ut >= Ft.length && (Ut = Ft.length), Ut || (Ut = 0), fr > 0 && fr < Qt && (fr = Qt), fr === Qt || Ft.length === 0 || this.length === 0) return 0;
    if (Ut < 0)
      throw new RangeError("targetStart out of bounds");
    if (Qt < 0 || Qt >= this.length) throw new RangeError("Index out of range");
    if (fr < 0) throw new RangeError("sourceEnd out of bounds");
    fr > this.length && (fr = this.length), Ft.length - Ut < fr - Qt && (fr = Ft.length - Ut + Qt);
    const cr = fr - Qt;
    return this === Ft && typeof ie.prototype.copyWithin == "function" ? this.copyWithin(Ut, Qt, fr) : ie.prototype.set.call(
      Ft,
      this.subarray(Qt, fr),
      Ut
    ), cr;
  }, oe.prototype.fill = function(Ft, Ut, Qt, fr) {
    if (typeof Ft == "string") {
      if (typeof Ut == "string" ? (fr = Ut, Ut = 0, Qt = this.length) : typeof Qt == "string" && (fr = Qt, Qt = this.length), fr !== void 0 && typeof fr != "string")
        throw new TypeError("encoding must be a string");
      if (typeof fr == "string" && !oe.isEncoding(fr))
        throw new TypeError("Unknown encoding: " + fr);
      if (Ft.length === 1) {
        const lr = Ft.charCodeAt(0);
        (fr === "utf8" && lr < 128 || fr === "latin1") && (Ft = lr);
      }
    } else typeof Ft == "number" ? Ft = Ft & 255 : typeof Ft == "boolean" && (Ft = Number(Ft));
    if (Ut < 0 || this.length < Ut || this.length < Qt)
      throw new RangeError("Out of range index");
    if (Qt <= Ut)
      return this;
    Ut = Ut >>> 0, Qt = Qt === void 0 ? this.length : Qt >>> 0, Ft || (Ft = 0);
    let cr;
    if (typeof Ft == "number")
      for (cr = Ut; cr < Qt; ++cr)
        this[cr] = Ft;
    else {
      const lr = oe.isBuffer(Ft) ? Ft : oe.from(Ft, fr), kr = lr.length;
      if (kr === 0)
        throw new TypeError('The value "' + Ft + '" is invalid for argument "value"');
      for (cr = 0; cr < Qt - Ut; ++cr)
        this[cr + Ut] = lr[cr % kr];
    }
    return this;
  };
  const Xt = {};
  function zt(Vt, Ft, Ut) {
    Xt[Vt] = class extends Ut {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Ft.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Vt}]`, this.stack, delete this.name;
      }
      get code() {
        return Vt;
      }
      set code(fr) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: fr,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Vt}]: ${this.message}`;
      }
    };
  }
  zt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Vt) {
      return Vt ? `${Vt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), zt(
    "ERR_INVALID_ARG_TYPE",
    function(Vt, Ft) {
      return `The "${Vt}" argument must be of type number. Received type ${typeof Ft}`;
    },
    TypeError
  ), zt(
    "ERR_OUT_OF_RANGE",
    function(Vt, Ft, Ut) {
      let Qt = `The value of "${Vt}" is out of range.`, fr = Ut;
      return Number.isInteger(Ut) && Math.abs(Ut) > 2 ** 32 ? fr = ur(String(Ut)) : typeof Ut == "bigint" && (fr = String(Ut), (Ut > BigInt(2) ** BigInt(32) || Ut < -(BigInt(2) ** BigInt(32))) && (fr = ur(fr)), fr += "n"), Qt += ` It must be ${Ft}. Received ${fr}`, Qt;
    },
    RangeError
  );
  function ur(Vt) {
    let Ft = "", Ut = Vt.length;
    const Qt = Vt[0] === "-" ? 1 : 0;
    for (; Ut >= Qt + 4; Ut -= 3)
      Ft = `_${Vt.slice(Ut - 3, Ut)}${Ft}`;
    return `${Vt.slice(0, Ut)}${Ft}`;
  }
  function pr(Vt, Ft, Ut) {
    _r(Ft, "offset"), (Vt[Ft] === void 0 || Vt[Ft + Ut] === void 0) && xr(Ft, Vt.length - (Ut + 1));
  }
  function vr(Vt, Ft, Ut, Qt, fr, cr) {
    if (Vt > Ut || Vt < Ft) {
      const lr = typeof Ft == "bigint" ? "n" : "";
      let kr;
      throw Ft === 0 || Ft === BigInt(0) ? kr = `>= 0${lr} and < 2${lr} ** ${(cr + 1) * 8}${lr}` : kr = `>= -(2${lr} ** ${(cr + 1) * 8 - 1}${lr}) and < 2 ** ${(cr + 1) * 8 - 1}${lr}`, new Xt.ERR_OUT_OF_RANGE("value", kr, Vt);
    }
    pr(Qt, fr, cr);
  }
  function _r(Vt, Ft) {
    if (typeof Vt != "number")
      throw new Xt.ERR_INVALID_ARG_TYPE(Ft, "number", Vt);
  }
  function xr(Vt, Ft, Ut) {
    throw Math.floor(Vt) !== Vt ? (_r(Vt, Ut), new Xt.ERR_OUT_OF_RANGE("offset", "an integer", Vt)) : Ft < 0 ? new Xt.ERR_BUFFER_OUT_OF_BOUNDS() : new Xt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Ft}`,
      Vt
    );
  }
  const Tr = /[^+/0-9A-Za-z-_]/g;
  function hr(Vt) {
    if (Vt = Vt.split("=")[0], Vt = Vt.trim().replace(Tr, ""), Vt.length < 2) return "";
    for (; Vt.length % 4 !== 0; )
      Vt = Vt + "=";
    return Vt;
  }
  function Wr(Vt, Ft) {
    Ft = Ft || 1 / 0;
    let Ut;
    const Qt = Vt.length;
    let fr = null;
    const cr = [];
    for (let lr = 0; lr < Qt; ++lr) {
      if (Ut = Vt.charCodeAt(lr), Ut > 55295 && Ut < 57344) {
        if (!fr) {
          if (Ut > 56319) {
            (Ft -= 3) > -1 && cr.push(239, 191, 189);
            continue;
          } else if (lr + 1 === Qt) {
            (Ft -= 3) > -1 && cr.push(239, 191, 189);
            continue;
          }
          fr = Ut;
          continue;
        }
        if (Ut < 56320) {
          (Ft -= 3) > -1 && cr.push(239, 191, 189), fr = Ut;
          continue;
        }
        Ut = (fr - 55296 << 10 | Ut - 56320) + 65536;
      } else fr && (Ft -= 3) > -1 && cr.push(239, 191, 189);
      if (fr = null, Ut < 128) {
        if ((Ft -= 1) < 0) break;
        cr.push(Ut);
      } else if (Ut < 2048) {
        if ((Ft -= 2) < 0) break;
        cr.push(
          Ut >> 6 | 192,
          Ut & 63 | 128
        );
      } else if (Ut < 65536) {
        if ((Ft -= 3) < 0) break;
        cr.push(
          Ut >> 12 | 224,
          Ut >> 6 & 63 | 128,
          Ut & 63 | 128
        );
      } else if (Ut < 1114112) {
        if ((Ft -= 4) < 0) break;
        cr.push(
          Ut >> 18 | 240,
          Ut >> 12 & 63 | 128,
          Ut >> 6 & 63 | 128,
          Ut & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return cr;
  }
  function $r(Vt) {
    const Ft = [];
    for (let Ut = 0; Ut < Vt.length; ++Ut)
      Ft.push(Vt.charCodeAt(Ut) & 255);
    return Ft;
  }
  function Ur(Vt, Ft) {
    let Ut, Qt, fr;
    const cr = [];
    for (let lr = 0; lr < Vt.length && !((Ft -= 2) < 0); ++lr)
      Ut = Vt.charCodeAt(lr), Qt = Ut >> 8, fr = Ut % 256, cr.push(fr), cr.push(Qt);
    return cr;
  }
  function Gr(Vt) {
    return z.toByteArray(hr(Vt));
  }
  function Rr(Vt, Ft, Ut, Qt) {
    let fr;
    for (fr = 0; fr < Qt && !(fr + Ut >= Ft.length || fr >= Vt.length); ++fr)
      Ft[fr + Ut] = Vt[fr];
    return fr;
  }
  function Hr(Vt, Ft) {
    return Vt instanceof Ft || Vt != null && Vt.constructor != null && Vt.constructor.name != null && Vt.constructor.name === Ft.name;
  }
  function Xr(Vt) {
    return Vt !== Vt;
  }
  const qr = function() {
    const Vt = "0123456789abcdef", Ft = new Array(256);
    for (let Ut = 0; Ut < 16; ++Ut) {
      const Qt = Ut * 16;
      for (let fr = 0; fr < 16; ++fr)
        Ft[Qt + fr] = Vt[Ut] + Vt[fr];
    }
    return Ft;
  }();
  function zr(Vt) {
    return typeof BigInt > "u" ? Qr : Vt;
  }
  function Qr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, z) {
  var Y;
  return (Y = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : Y.get(z);
}
function _stringify(B) {
  var Y, ne;
  const z = typeof B;
  return z === "string" ? `"${B}"` : z === "number" || z === "bigint" || z === "boolean" ? `${B}` : z === "object" || z === "function" ? (B && ((ne = (Y = Object.getPrototypeOf(B)) == null ? void 0 : Y.constructor) == null ? void 0 : ne.name)) ?? "null" : z;
}
function _addIssue(B, z, Y, ne, ae) {
  const ie = ae && "input" in ae ? ae.input : Y.value, se = (ae == null ? void 0 : ae.expected) ?? B.expects ?? null, le = (ae == null ? void 0 : ae.received) ?? _stringify(ie), ve = {
    kind: B.kind,
    type: B.type,
    input: ie,
    expected: se,
    received: le,
    message: `Invalid ${z}: ${se ? `Expected ${se} but r` : "R"}eceived ${le}`,
    requirement: B.requirement,
    path: ae == null ? void 0 : ae.path,
    issues: ae == null ? void 0 : ae.issues,
    lang: ne.lang,
    abortEarly: ne.abortEarly,
    abortPipeEarly: ne.abortPipeEarly
  }, ge = B.kind === "schema", oe = (ae == null ? void 0 : ae.message) ?? B.message ?? getSpecificMessage(B.reference, ve.lang) ?? (ge ? getSchemaMessage(ve.lang) : null) ?? ne.message ?? getGlobalMessage(ve.lang);
  oe && (ve.message = typeof oe == "function" ? (
    // @ts-expect-error
    oe(ve)
  ) : oe), ge && (Y.typed = !1), Y.issues ? Y.issues.push(ve) : Y.issues = [ve];
}
function _isValidObjectKey(B, z) {
  return Object.hasOwn(B, z) && z !== "__proto__" && z !== "prototype" && z !== "constructor";
}
function _joinExpects(B, z) {
  const Y = [...new Set(B)];
  return Y.length > 1 ? `(${Y.join(` ${z} `)})` : Y[0] ?? "never";
}
function check$e(B, z) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && !this.requirement(Y.value) && _addIssue(this, "input", Y, ne), Y;
    }
  };
}
function maxLength(B, z) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length > this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function minLength(B, z) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length < this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function getDefault(B, z, Y) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(z, Y)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function is(B, z) {
  return !B._run({ typed: !1, value: z }, { abortEarly: !0 }).issues;
}
function array(B, z) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: z,
    _run(Y, ne) {
      var ie;
      const ae = Y.value;
      if (Array.isArray(ae)) {
        Y.typed = !0, Y.value = [];
        for (let se = 0; se < ae.length; se++) {
          const le = ae[se], ve = this.item._run({ typed: !1, value: le }, ne);
          if (ve.issues) {
            const ge = {
              type: "array",
              origin: "value",
              input: ae,
              key: se,
              value: le
            };
            for (const oe of ve.issues)
              oe.path ? oe.path.unshift(ge) : oe.path = [ge], (ie = Y.issues) == null || ie.push(oe);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), Y.value.push(ve.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "boolean" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function enum_(B, z) {
  const Y = Object.entries(B).filter(([ne]) => isNaN(+ne)).map(([, ne]) => ne);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(Y.map(_stringify), "|"),
    async: !1,
    enum: B,
    options: Y,
    message: z,
    _run(ne, ae) {
      return this.options.includes(ne.value) ? ne.typed = !0 : _addIssue(this, "type", ne, ae), ne;
    }
  };
}
function literal(B, z) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: z,
    _run(Y, ne) {
      return Y.value === this.literal ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function looseObject(B, z) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var ie;
      const ae = Y.value;
      if (ae && typeof ae == "object") {
        Y.typed = !0, Y.value = {};
        for (const se in this.entries) {
          const le = ae[se], ve = this.entries[se]._run(
            { typed: !1, value: le },
            ne
          );
          if (ve.issues) {
            const ge = {
              type: "object",
              origin: "value",
              input: ae,
              key: se,
              value: le
            };
            for (const oe of ve.issues)
              oe.path ? oe.path.unshift(ge) : oe.path = [ge], (ie = Y.issues) == null || ie.push(oe);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), (ve.value !== void 0 || se in ae) && (Y.value[se] = ve.value);
        }
        if (!Y.issues || !ne.abortEarly)
          for (const se in ae)
            _isValidObjectKey(ae, se) && !(se in this.entries) && (Y.value[se] = ae[se]);
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function nonOptional(B, z) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: z,
    _run(Y, ne) {
      return Y.value === void 0 ? (_addIssue(this, "type", Y, ne), Y) : this.wrapped._run(Y, ne);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(z, Y) {
      return z.value === null ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function nullish(B, ...z) {
  const Y = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${B.expects} | null | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, ae) {
      return (ne.value === null || ne.value === void 0) && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        ae
      )), ne.value === null || ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, ae);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "number" && !isNaN(z.value) ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function object(B, z) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var ie;
      const ae = Y.value;
      if (ae && typeof ae == "object") {
        Y.typed = !0, Y.value = {};
        for (const se in this.entries) {
          const le = ae[se], ve = this.entries[se]._run(
            { typed: !1, value: le },
            ne
          );
          if (ve.issues) {
            const ge = {
              type: "object",
              origin: "value",
              input: ae,
              key: se,
              value: le
            };
            for (const oe of ve.issues)
              oe.path ? oe.path.unshift(ge) : oe.path = [ge], (ie = Y.issues) == null || ie.push(oe);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), (ve.value !== void 0 || se in ae) && (Y.value[se] = ve.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function optional(B, ...z) {
  const Y = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${B.expects} | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, ae) {
      return ne.value === void 0 && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        ae
      )), ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, ae);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function picklist(B, z) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(B.map(_stringify), "|"),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      return this.options.includes(Y.value) ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function record(B, z, Y) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: B,
    value: z,
    message: Y,
    _run(ne, ae) {
      var se, le;
      const ie = ne.value;
      if (ie && typeof ie == "object") {
        ne.typed = !0, ne.value = {};
        for (const ve in ie)
          if (_isValidObjectKey(ie, ve)) {
            const ge = ie[ve], oe = this.key._run(
              { typed: !1, value: ve },
              ae
            );
            if (oe.issues) {
              const Ce = {
                type: "object",
                origin: "key",
                input: ie,
                key: ve,
                value: ge
              };
              for (const Pe of oe.issues)
                Pe.path = [Ce], (se = ne.issues) == null || se.push(Pe);
              if (ne.issues || (ne.issues = oe.issues), ae.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            const Ee = this.value._run(
              { typed: !1, value: ge },
              ae
            );
            if (Ee.issues) {
              const Ce = {
                type: "object",
                origin: "value",
                input: ie,
                key: ve,
                value: ge
              };
              for (const Pe of Ee.issues)
                Pe.path ? Pe.path.unshift(Ce) : Pe.path = [Ce], (le = ne.issues) == null || le.push(Pe);
              if (ne.issues || (ne.issues = Ee.issues), ae.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            (!oe.typed || !Ee.typed) && (ne.typed = !1), oe.typed && (ne.value[oe.value] = Ee.value);
          }
      } else
        _addIssue(this, "type", ne, ae);
      return ne;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "string" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function _subIssues(B) {
  let z;
  if (B)
    for (const Y of B)
      z ? z.push(...Y.issues) : z = Y.issues;
  return z;
}
function union(B, z) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      B.map((Y) => Y.expects),
      "|"
    ),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      let ae, ie, se;
      for (const le of this.options) {
        const ve = le._run(
          { typed: !1, value: Y.value },
          ne
        );
        if (ve.typed)
          if (ve.issues)
            ie ? ie.push(ve) : ie = [ve];
          else {
            ae = ve;
            break;
          }
        else
          se ? se.push(ve) : se = [ve];
      }
      if (ae)
        return ae;
      if (ie) {
        if (ie.length === 1)
          return ie[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(ie)
        }), Y.typed = !0;
      } else {
        if ((se == null ? void 0 : se.length) === 1)
          return se[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(se)
        });
      }
      return Y;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
function variant(B, z, Y) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: B,
    options: z,
    message: Y,
    _run(ne, ae) {
      const ie = ne.value;
      if (ie && typeof ie == "object") {
        let se, le = 0, ve = this.key, ge = [];
        const oe = (Ee, Ce) => {
          for (const Pe of Ee.options) {
            if (Pe.type === "variant")
              oe(Pe, new Set(Ce).add(Pe.key));
            else {
              let Ve = !0, ht = 0;
              for (const vt of Ce) {
                if (Pe.entries[vt]._run(
                  // @ts-expect-error
                  { typed: !1, value: ie[vt] },
                  ae
                ).issues) {
                  Ve = !1, ve !== vt && (le < ht || le === ht && vt in ie && !(ve in ie)) && (le = ht, ve = vt, ge = []), ve === vt && ge.push(
                    Pe.entries[vt].expects
                  );
                  break;
                }
                ht++;
              }
              if (Ve) {
                const vt = Pe._run(
                  { typed: !1, value: ie },
                  ae
                );
                (!se || !se.typed && vt.typed) && (se = vt);
              }
            }
            if (se && !se.issues)
              break;
          }
        };
        if (oe(this, /* @__PURE__ */ new Set([this.key])), se)
          return se;
        _addIssue(this, "type", ne, ae, {
          // @ts-expect-error
          input: ie[ve],
          expected: _joinExpects(ge, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: ie,
              key: ve,
              // @ts-expect-error
              value: ie[ve]
            }
          ]
        });
      } else
        _addIssue(this, "type", ne, ae);
      return ne;
    }
  };
}
function omit(B, z) {
  const Y = {
    ...B.entries
  };
  for (const ne of z)
    delete Y[ne];
  return { ...B, entries: Y };
}
function pipe(...B) {
  return {
    ...B[0],
    pipe: B,
    _run(z, Y) {
      for (const ne of B)
        if (ne.kind !== "metadata") {
          if (z.issues && (ne.kind === "schema" || ne.kind === "transformation")) {
            z.typed = !1;
            break;
          }
          (!z.issues || !Y.abortEarly && !Y.abortPipeEarly) && (z = ne._run(z, Y));
        }
      return z;
    }
  };
}
function unwrap(B) {
  return B.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength(B) {
  var z = getLens(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray(B) {
  var z, Y = getLens(B), ne = Y[0], ae = Y[1], ie = new Arr(_byteLength(B, ne, ae)), se = 0, le = ae > 0 ? ne - 4 : ne, ve;
  for (ve = 0; ve < le; ve += 4)
    z = revLookup[B.charCodeAt(ve)] << 18 | revLookup[B.charCodeAt(ve + 1)] << 12 | revLookup[B.charCodeAt(ve + 2)] << 6 | revLookup[B.charCodeAt(ve + 3)], ie[se++] = z >> 16 & 255, ie[se++] = z >> 8 & 255, ie[se++] = z & 255;
  return ae === 2 && (z = revLookup[B.charCodeAt(ve)] << 2 | revLookup[B.charCodeAt(ve + 1)] >> 4, ie[se++] = z & 255), ae === 1 && (z = revLookup[B.charCodeAt(ve)] << 10 | revLookup[B.charCodeAt(ve + 1)] << 4 | revLookup[B.charCodeAt(ve + 2)] >> 2, ie[se++] = z >> 8 & 255, ie[se++] = z & 255), ie;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, z, Y) {
  for (var ne, ae = [], ie = z; ie < Y; ie += 3)
    ne = (B[ie] << 16 & 16711680) + (B[ie + 1] << 8 & 65280) + (B[ie + 2] & 255), ae.push(tripletToBase64(ne));
  return ae.join("");
}
function fromByteArray(B) {
  for (var z, Y = B.length, ne = Y % 3, ae = [], ie = 16383, se = 0, le = Y - ne; se < le; se += ie)
    ae.push(encodeChunk(B, se, se + ie > le ? le : se + ie));
  return ne === 1 ? (z = B[Y - 1], ae.push(
    lookup[z >> 2] + lookup[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], ae.push(
    lookup[z >> 10] + lookup[z >> 4 & 63] + lookup[z << 2 & 63] + "="
  )), ae.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode$j;
function decode$j(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error("positive integer expected, got " + B);
}
function isBytes(B) {
  return B instanceof Uint8Array || ArrayBuffer.isView(B) && B.constructor.name === "Uint8Array";
}
function abytes(B, ...z) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (z.length > 0 && !z.includes(B.length))
    throw new Error("Uint8Array expected of length " + z + ", got length=" + B.length);
}
function ahash(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(B.outputLen), anumber(B.blockLen);
}
function aexists(B, z = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (z && B.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(B, z) {
  abytes(B);
  const Y = z.outputLen;
  if (B.length < Y)
    throw new Error("digestInto() expects output buffer of length at least " + Y);
}
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.isLE = void 0, B.isBytes = ne, B.u8 = ae, B.u32 = ie, B.createView = se, B.rotr = le, B.rotl = ve, B.byteSwap = ge, B.byteSwap32 = oe, B.bytesToHex = Ce, B.hexToBytes = ht, B.asyncLoop = Pt, B.utf8ToBytes = _t, B.toBytes = kt, B.concatBytes = Ot, B.checkOpts = jt, B.wrapConstructor = Yt, B.wrapConstructorWithOpts = Dt, B.wrapXOFConstructorWithOpts = Ct, B.randomBytes = Kt;
  const z = crypto$2, Y = _assert;
  function ne(Nt) {
    return Nt instanceof Uint8Array || ArrayBuffer.isView(Nt) && Nt.constructor.name === "Uint8Array";
  }
  function ae(Nt) {
    return new Uint8Array(Nt.buffer, Nt.byteOffset, Nt.byteLength);
  }
  function ie(Nt) {
    return new Uint32Array(Nt.buffer, Nt.byteOffset, Math.floor(Nt.byteLength / 4));
  }
  function se(Nt) {
    return new DataView(Nt.buffer, Nt.byteOffset, Nt.byteLength);
  }
  function le(Nt, Je) {
    return Nt << 32 - Je | Nt >>> Je;
  }
  function ve(Nt, Je) {
    return Nt << Je | Nt >>> 32 - Je >>> 0;
  }
  B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function ge(Nt) {
    return Nt << 24 & 4278190080 | Nt << 8 & 16711680 | Nt >>> 8 & 65280 | Nt >>> 24 & 255;
  }
  B.byteSwapIfBE = B.isLE ? (Nt) => Nt : (Nt) => ge(Nt);
  function oe(Nt) {
    for (let Je = 0; Je < Nt.length; Je++)
      Nt[Je] = ge(Nt[Je]);
  }
  const Ee = /* @__PURE__ */ Array.from({ length: 256 }, (Nt, Je) => Je.toString(16).padStart(2, "0"));
  function Ce(Nt) {
    (0, Y.abytes)(Nt);
    let Je = "";
    for (let Xe = 0; Xe < Nt.length; Xe++)
      Je += Ee[Nt[Xe]];
    return Je;
  }
  const Pe = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function Ve(Nt) {
    if (Nt >= Pe._0 && Nt <= Pe._9)
      return Nt - Pe._0;
    if (Nt >= Pe.A && Nt <= Pe.F)
      return Nt - (Pe.A - 10);
    if (Nt >= Pe.a && Nt <= Pe.f)
      return Nt - (Pe.a - 10);
  }
  function ht(Nt) {
    if (typeof Nt != "string")
      throw new Error("hex string expected, got " + typeof Nt);
    const Je = Nt.length, Xe = Je / 2;
    if (Je % 2)
      throw new Error("hex string expected, got unpadded hex of length " + Je);
    const Ke = new Uint8Array(Xe);
    for (let Qe = 0, bt = 0; Qe < Xe; Qe++, bt += 2) {
      const wt = Ve(Nt.charCodeAt(bt)), xt = Ve(Nt.charCodeAt(bt + 1));
      if (wt === void 0 || xt === void 0) {
        const Bt = Nt[bt] + Nt[bt + 1];
        throw new Error('hex string expected, got non-hex character "' + Bt + '" at index ' + bt);
      }
      Ke[Qe] = wt * 16 + xt;
    }
    return Ke;
  }
  const vt = async () => {
  };
  B.nextTick = vt;
  async function Pt(Nt, Je, Xe) {
    let Ke = Date.now();
    for (let Qe = 0; Qe < Nt; Qe++) {
      Xe(Qe);
      const bt = Date.now() - Ke;
      bt >= 0 && bt < Je || (await (0, B.nextTick)(), Ke += bt);
    }
  }
  function _t(Nt) {
    if (typeof Nt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof Nt);
    return new Uint8Array(new TextEncoder().encode(Nt));
  }
  function kt(Nt) {
    return typeof Nt == "string" && (Nt = _t(Nt)), (0, Y.abytes)(Nt), Nt;
  }
  function Ot(...Nt) {
    let Je = 0;
    for (let Ke = 0; Ke < Nt.length; Ke++) {
      const Qe = Nt[Ke];
      (0, Y.abytes)(Qe), Je += Qe.length;
    }
    const Xe = new Uint8Array(Je);
    for (let Ke = 0, Qe = 0; Ke < Nt.length; Ke++) {
      const bt = Nt[Ke];
      Xe.set(bt, Qe), Qe += bt.length;
    }
    return Xe;
  }
  class Ht {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = Ht;
  function jt(Nt, Je) {
    if (Je !== void 0 && {}.toString.call(Je) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Nt, Je);
  }
  function Yt(Nt) {
    const Je = (Ke) => Nt().update(kt(Ke)).digest(), Xe = Nt();
    return Je.outputLen = Xe.outputLen, Je.blockLen = Xe.blockLen, Je.create = () => Nt(), Je;
  }
  function Dt(Nt) {
    const Je = (Ke, Qe) => Nt(Qe).update(kt(Ke)).digest(), Xe = Nt({});
    return Je.outputLen = Xe.outputLen, Je.blockLen = Xe.blockLen, Je.create = (Ke) => Nt(Ke), Je;
  }
  function Ct(Nt) {
    const Je = (Ke, Qe) => Nt(Qe).update(kt(Ke)).digest(), Xe = Nt({});
    return Je.outputLen = Xe.outputLen, Je.blockLen = Xe.blockLen, Je.create = (Ke) => Nt(Ke), Je;
  }
  function Kt(Nt = 32) {
    if (z.crypto && typeof z.crypto.getRandomValues == "function")
      return z.crypto.getRandomValues(new Uint8Array(Nt));
    if (z.crypto && typeof z.crypto.randomBytes == "function")
      return z.crypto.randomBytes(Nt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const z = _assert, Y = utils$5;
  class ne extends Y.Hash {
    constructor(se, le) {
      super(), this.finished = !1, this.destroyed = !1, (0, z.ahash)(se);
      const ve = (0, Y.toBytes)(le);
      if (this.iHash = se.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ge = this.blockLen, oe = new Uint8Array(ge);
      oe.set(ve.length > ge ? se.create().update(ve).digest() : ve);
      for (let Ee = 0; Ee < oe.length; Ee++)
        oe[Ee] ^= 54;
      this.iHash.update(oe), this.oHash = se.create();
      for (let Ee = 0; Ee < oe.length; Ee++)
        oe[Ee] ^= 106;
      this.oHash.update(oe), oe.fill(0);
    }
    update(se) {
      return (0, z.aexists)(this), this.iHash.update(se), this;
    }
    digestInto(se) {
      (0, z.aexists)(this), (0, z.abytes)(se, this.outputLen), this.finished = !0, this.iHash.digestInto(se), this.oHash.update(se), this.oHash.digestInto(se), this.destroy();
    }
    digest() {
      const se = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(se), se;
    }
    _cloneInto(se) {
      se || (se = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: le, iHash: ve, finished: ge, destroyed: oe, blockLen: Ee, outputLen: Ce } = this;
      return se = se, se.finished = ge, se.destroyed = oe, se.blockLen = Ee, se.outputLen = Ce, se.oHash = le._cloneInto(se.oHash), se.iHash = ve._cloneInto(se.iHash), se;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = ne;
  const ae = (ie, se, le) => new ne(ie, se).update(le).digest();
  B.hmac = ae, B.hmac.create = (ie, se) => new ne(ie, se);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(B, z, Y, ne) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(z, Y, ne);
  const ae = BigInt(32), ie = BigInt(4294967295), se = Number(Y >> ae & ie), le = Number(Y & ie), ve = ne ? 4 : 0, ge = ne ? 0 : 4;
  B.setUint32(z + ve, se, ne), B.setUint32(z + ge, le, ne);
}
function Chi(B, z, Y) {
  return B & z ^ ~B & Y;
}
function Maj(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(z, Y, ne, ae) {
    super(), this.blockLen = z, this.outputLen = Y, this.padOffset = ne, this.isLE = ae, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(z), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(z) {
    (0, _assert_js_1.aexists)(this);
    const { view: Y, buffer: ne, blockLen: ae } = this;
    z = (0, utils_js_1$3.toBytes)(z);
    const ie = z.length;
    for (let se = 0; se < ie; ) {
      const le = Math.min(ae - this.pos, ie - se);
      if (le === ae) {
        const ve = (0, utils_js_1$3.createView)(z);
        for (; ae <= ie - se; se += ae)
          this.process(ve, se);
        continue;
      }
      ne.set(z.subarray(se, se + le), this.pos), this.pos += le, se += le, this.pos === ae && (this.process(Y, 0), this.pos = 0);
    }
    return this.length += z.length, this.roundClean(), this;
  }
  digestInto(z) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(z, this), this.finished = !0;
    const { buffer: Y, view: ne, blockLen: ae, isLE: ie } = this;
    let { pos: se } = this;
    Y[se++] = 128, this.buffer.subarray(se).fill(0), this.padOffset > ae - se && (this.process(ne, 0), se = 0);
    for (let Ee = se; Ee < ae; Ee++)
      Y[Ee] = 0;
    setBigUint64(ne, ae - 8, BigInt(this.length * 8), ie), this.process(ne, 0);
    const le = (0, utils_js_1$3.createView)(z), ve = this.outputLen;
    if (ve % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ge = ve / 4, oe = this.get();
    if (ge > oe.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ee = 0; Ee < ge; Ee++)
      le.setUint32(4 * Ee, oe[Ee], ie);
  }
  digest() {
    const { buffer: z, outputLen: Y } = this;
    this.digestInto(z);
    const ne = z.slice(0, Y);
    return this.destroy(), ne;
  }
  _cloneInto(z) {
    z || (z = new this.constructor()), z.set(...this.get());
    const { blockLen: Y, buffer: ne, length: ae, finished: ie, destroyed: se, pos: le } = this;
    return z.length = ae, z.pos = le, z.finished = ie, z.destroyed = se, ae % Y && z.buffer.set(ne), z;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: ae, E: ie, F: se, G: le, H: ve } = this;
    return [z, Y, ne, ae, ie, se, le, ve];
  }
  // prettier-ignore
  set(z, Y, ne, ae, ie, se, le, ve) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = ae | 0, this.E = ie | 0, this.F = se | 0, this.G = le | 0, this.H = ve | 0;
  }
  process(z, Y) {
    for (let Ee = 0; Ee < 16; Ee++, Y += 4)
      SHA256_W[Ee] = z.getUint32(Y, !1);
    for (let Ee = 16; Ee < 64; Ee++) {
      const Ce = SHA256_W[Ee - 15], Pe = SHA256_W[Ee - 2], Ve = (0, utils_js_1$2.rotr)(Ce, 7) ^ (0, utils_js_1$2.rotr)(Ce, 18) ^ Ce >>> 3, ht = (0, utils_js_1$2.rotr)(Pe, 17) ^ (0, utils_js_1$2.rotr)(Pe, 19) ^ Pe >>> 10;
      SHA256_W[Ee] = ht + SHA256_W[Ee - 7] + Ve + SHA256_W[Ee - 16] | 0;
    }
    let { A: ne, B: ae, C: ie, D: se, E: le, F: ve, G: ge, H: oe } = this;
    for (let Ee = 0; Ee < 64; Ee++) {
      const Ce = (0, utils_js_1$2.rotr)(le, 6) ^ (0, utils_js_1$2.rotr)(le, 11) ^ (0, utils_js_1$2.rotr)(le, 25), Pe = oe + Ce + (0, _md_js_1$2.Chi)(le, ve, ge) + SHA256_K[Ee] + SHA256_W[Ee] | 0, ht = ((0, utils_js_1$2.rotr)(ne, 2) ^ (0, utils_js_1$2.rotr)(ne, 13) ^ (0, utils_js_1$2.rotr)(ne, 22)) + (0, _md_js_1$2.Maj)(ne, ae, ie) | 0;
      oe = ge, ge = ve, ve = le, le = se + Pe | 0, se = ie, ie = ae, ae = ne, ne = Pe + ht | 0;
    }
    ne = ne + this.A | 0, ae = ae + this.B | 0, ie = ie + this.C | 0, se = se + this.D | 0, le = le + this.E | 0, ve = ve + this.F | 0, ge = ge + this.G | 0, oe = oe + this.H | 0, this.set(ne, ae, ie, se, le, ve, ge, oe);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$4.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} };
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, z) {
  var Y = require$$0$1, ne = Y.Buffer;
  function ae(se, le) {
    for (var ve in se)
      le[ve] = se[ve];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (ae(Y, z), z.Buffer = ie);
  function ie(se, le, ve) {
    return ne(se, le, ve);
  }
  ie.prototype = Object.create(ne.prototype), ae(ne, ie), ie.from = function(se, le, ve) {
    if (typeof se == "number")
      throw new TypeError("Argument must not be a number");
    return ne(se, le, ve);
  }, ie.alloc = function(se, le, ve) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    var ge = ne(se);
    return le !== void 0 ? typeof ve == "string" ? ge.fill(le, ve) : ge.fill(le) : ge.fill(0), ge;
  }, ie.allocUnsafe = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return ne(se);
  }, ie.allocUnsafeSlow = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(se);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var B = 65536, z = 4294967295;
  function Y() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var ne = safeBufferExports.Buffer, ae = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  ae && ae.getRandomValues ? browser$b.exports = ie : browser$b.exports = Y;
  function ie(se, le) {
    if (se > z) throw new RangeError("requested too many random bytes");
    var ve = ne.allocUnsafe(se);
    if (se > 0)
      if (se > B)
        for (var ge = 0; ge < se; ge += B)
          ae.getRandomValues(ve.slice(ge, ge + B));
      else
        ae.getRandomValues(ve);
    return typeof le == "function" ? process$1.nextTick(function() {
      le(null, ve);
    }) : ve;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(z, Y) {
    Y && (z.super_ = Y, z.prototype = Object.create(Y.prototype, {
      constructor: {
        value: z,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(z, Y) {
    if (Y) {
      z.super_ = Y;
      var ne = function() {
      };
      ne.prototype = Y.prototype, z.prototype = new ne(), z.prototype.constructor = z;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var B = typeof Reflect == "object" ? Reflect : null, z = B && typeof B.apply == "function" ? B.apply : function(Ht, jt, Yt) {
    return Function.prototype.apply.call(Ht, jt, Yt);
  }, Y;
  B && typeof B.ownKeys == "function" ? Y = B.ownKeys : Object.getOwnPropertySymbols ? Y = function(Ht) {
    return Object.getOwnPropertyNames(Ht).concat(Object.getOwnPropertySymbols(Ht));
  } : Y = function(Ht) {
    return Object.getOwnPropertyNames(Ht);
  };
  function ne(Ot) {
    console && console.warn && console.warn(Ot);
  }
  var ae = Number.isNaN || function(Ht) {
    return Ht !== Ht;
  };
  function ie() {
    ie.init.call(this);
  }
  events.exports = ie, events.exports.once = Pt, ie.EventEmitter = ie, ie.prototype._events = void 0, ie.prototype._eventsCount = 0, ie.prototype._maxListeners = void 0;
  var se = 10;
  function le(Ot) {
    if (typeof Ot != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ot);
  }
  Object.defineProperty(ie, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return se;
    },
    set: function(Ot) {
      if (typeof Ot != "number" || Ot < 0 || ae(Ot))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ot + ".");
      se = Ot;
    }
  }), ie.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, ie.prototype.setMaxListeners = function(Ht) {
    if (typeof Ht != "number" || Ht < 0 || ae(Ht))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Ht + ".");
    return this._maxListeners = Ht, this;
  };
  function ve(Ot) {
    return Ot._maxListeners === void 0 ? ie.defaultMaxListeners : Ot._maxListeners;
  }
  ie.prototype.getMaxListeners = function() {
    return ve(this);
  }, ie.prototype.emit = function(Ht) {
    for (var jt = [], Yt = 1; Yt < arguments.length; Yt++) jt.push(arguments[Yt]);
    var Dt = Ht === "error", Ct = this._events;
    if (Ct !== void 0)
      Dt = Dt && Ct.error === void 0;
    else if (!Dt)
      return !1;
    if (Dt) {
      var Kt;
      if (jt.length > 0 && (Kt = jt[0]), Kt instanceof Error)
        throw Kt;
      var Nt = new Error("Unhandled error." + (Kt ? " (" + Kt.message + ")" : ""));
      throw Nt.context = Kt, Nt;
    }
    var Je = Ct[Ht];
    if (Je === void 0)
      return !1;
    if (typeof Je == "function")
      z(Je, this, jt);
    else
      for (var Xe = Je.length, Ke = Ve(Je, Xe), Yt = 0; Yt < Xe; ++Yt)
        z(Ke[Yt], this, jt);
    return !0;
  };
  function ge(Ot, Ht, jt, Yt) {
    var Dt, Ct, Kt;
    if (le(jt), Ct = Ot._events, Ct === void 0 ? (Ct = Ot._events = /* @__PURE__ */ Object.create(null), Ot._eventsCount = 0) : (Ct.newListener !== void 0 && (Ot.emit(
      "newListener",
      Ht,
      jt.listener ? jt.listener : jt
    ), Ct = Ot._events), Kt = Ct[Ht]), Kt === void 0)
      Kt = Ct[Ht] = jt, ++Ot._eventsCount;
    else if (typeof Kt == "function" ? Kt = Ct[Ht] = Yt ? [jt, Kt] : [Kt, jt] : Yt ? Kt.unshift(jt) : Kt.push(jt), Dt = ve(Ot), Dt > 0 && Kt.length > Dt && !Kt.warned) {
      Kt.warned = !0;
      var Nt = new Error("Possible EventEmitter memory leak detected. " + Kt.length + " " + String(Ht) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Nt.name = "MaxListenersExceededWarning", Nt.emitter = Ot, Nt.type = Ht, Nt.count = Kt.length, ne(Nt);
    }
    return Ot;
  }
  ie.prototype.addListener = function(Ht, jt) {
    return ge(this, Ht, jt, !1);
  }, ie.prototype.on = ie.prototype.addListener, ie.prototype.prependListener = function(Ht, jt) {
    return ge(this, Ht, jt, !0);
  };
  function oe() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Ee(Ot, Ht, jt) {
    var Yt = { fired: !1, wrapFn: void 0, target: Ot, type: Ht, listener: jt }, Dt = oe.bind(Yt);
    return Dt.listener = jt, Yt.wrapFn = Dt, Dt;
  }
  ie.prototype.once = function(Ht, jt) {
    return le(jt), this.on(Ht, Ee(this, Ht, jt)), this;
  }, ie.prototype.prependOnceListener = function(Ht, jt) {
    return le(jt), this.prependListener(Ht, Ee(this, Ht, jt)), this;
  }, ie.prototype.removeListener = function(Ht, jt) {
    var Yt, Dt, Ct, Kt, Nt;
    if (le(jt), Dt = this._events, Dt === void 0)
      return this;
    if (Yt = Dt[Ht], Yt === void 0)
      return this;
    if (Yt === jt || Yt.listener === jt)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Dt[Ht], Dt.removeListener && this.emit("removeListener", Ht, Yt.listener || jt));
    else if (typeof Yt != "function") {
      for (Ct = -1, Kt = Yt.length - 1; Kt >= 0; Kt--)
        if (Yt[Kt] === jt || Yt[Kt].listener === jt) {
          Nt = Yt[Kt].listener, Ct = Kt;
          break;
        }
      if (Ct < 0)
        return this;
      Ct === 0 ? Yt.shift() : ht(Yt, Ct), Yt.length === 1 && (Dt[Ht] = Yt[0]), Dt.removeListener !== void 0 && this.emit("removeListener", Ht, Nt || jt);
    }
    return this;
  }, ie.prototype.off = ie.prototype.removeListener, ie.prototype.removeAllListeners = function(Ht) {
    var jt, Yt, Dt;
    if (Yt = this._events, Yt === void 0)
      return this;
    if (Yt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Yt[Ht] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Yt[Ht]), this;
    if (arguments.length === 0) {
      var Ct = Object.keys(Yt), Kt;
      for (Dt = 0; Dt < Ct.length; ++Dt)
        Kt = Ct[Dt], Kt !== "removeListener" && this.removeAllListeners(Kt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (jt = Yt[Ht], typeof jt == "function")
      this.removeListener(Ht, jt);
    else if (jt !== void 0)
      for (Dt = jt.length - 1; Dt >= 0; Dt--)
        this.removeListener(Ht, jt[Dt]);
    return this;
  };
  function Ce(Ot, Ht, jt) {
    var Yt = Ot._events;
    if (Yt === void 0)
      return [];
    var Dt = Yt[Ht];
    return Dt === void 0 ? [] : typeof Dt == "function" ? jt ? [Dt.listener || Dt] : [Dt] : jt ? vt(Dt) : Ve(Dt, Dt.length);
  }
  ie.prototype.listeners = function(Ht) {
    return Ce(this, Ht, !0);
  }, ie.prototype.rawListeners = function(Ht) {
    return Ce(this, Ht, !1);
  }, ie.listenerCount = function(Ot, Ht) {
    return typeof Ot.listenerCount == "function" ? Ot.listenerCount(Ht) : Pe.call(Ot, Ht);
  }, ie.prototype.listenerCount = Pe;
  function Pe(Ot) {
    var Ht = this._events;
    if (Ht !== void 0) {
      var jt = Ht[Ot];
      if (typeof jt == "function")
        return 1;
      if (jt !== void 0)
        return jt.length;
    }
    return 0;
  }
  ie.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Y(this._events) : [];
  };
  function Ve(Ot, Ht) {
    for (var jt = new Array(Ht), Yt = 0; Yt < Ht; ++Yt)
      jt[Yt] = Ot[Yt];
    return jt;
  }
  function ht(Ot, Ht) {
    for (; Ht + 1 < Ot.length; Ht++)
      Ot[Ht] = Ot[Ht + 1];
    Ot.pop();
  }
  function vt(Ot) {
    for (var Ht = new Array(Ot.length), jt = 0; jt < Ht.length; ++jt)
      Ht[jt] = Ot[jt].listener || Ot[jt];
    return Ht;
  }
  function Pt(Ot, Ht) {
    return new Promise(function(jt, Yt) {
      function Dt(Kt) {
        Ot.removeListener(Ht, Ct), Yt(Kt);
      }
      function Ct() {
        typeof Ot.removeListener == "function" && Ot.removeListener("error", Dt), jt([].slice.call(arguments));
      }
      kt(Ot, Ht, Ct, { once: !0 }), Ht !== "error" && _t(Ot, Dt, { once: !0 });
    });
  }
  function _t(Ot, Ht, jt) {
    typeof Ot.on == "function" && kt(Ot, "error", Ht, jt);
  }
  function kt(Ot, Ht, jt, Yt) {
    if (typeof Ot.on == "function")
      Yt.once ? Ot.once(Ht, jt) : Ot.on(Ht, jt);
    else if (typeof Ot.addEventListener == "function")
      Ot.addEventListener(Ht, function Dt(Ct) {
        Yt.once && Ot.removeEventListener(Ht, Dt), jt(Ct);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ot);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var z = {}, Y = Symbol("test"), ne = Object(Y);
    if (typeof Y == "string" || Object.prototype.toString.call(Y) !== "[object Symbol]" || Object.prototype.toString.call(ne) !== "[object Symbol]")
      return !1;
    var ae = 42;
    z[Y] = ae;
    for (var ie in z)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(z).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(z).length !== 0)
      return !1;
    var se = Object.getOwnPropertySymbols(z);
    if (se.length !== 1 || se[0] !== Y || !Object.prototype.propertyIsEnumerable.call(z, Y))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var le = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(z, Y)
      );
      if (le.value !== ae || le.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var B = requireShams$1();
  return shams = function() {
    return B() && !!Symbol.toStringTag;
  }, shams;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(z) {
    return z !== z;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var B = require_isNaN();
  return sign$1 = function(Y) {
    return B(Y) || Y === 0 ? Y : Y < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var B = requireGOPD();
  if (B)
    try {
      B([], "length");
    } catch {
      B = null;
    }
  return gopd = B, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var B = Object.defineProperty || !1;
  if (B)
    try {
      B({}, "a", { value: 1 });
    } catch {
      B = !1;
    }
  return esDefineProperty = B, esDefineProperty;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, z = requireShams$1();
  return hasSymbols = function() {
    return typeof B != "function" || typeof Symbol != "function" || typeof B("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : z();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var B = requireEsObjectAtoms();
  return Object_getPrototypeOf = B.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var B = "Function.prototype.bind called on incompatible ", z = Object.prototype.toString, Y = Math.max, ne = "[object Function]", ae = function(ve, ge) {
    for (var oe = [], Ee = 0; Ee < ve.length; Ee += 1)
      oe[Ee] = ve[Ee];
    for (var Ce = 0; Ce < ge.length; Ce += 1)
      oe[Ce + ve.length] = ge[Ce];
    return oe;
  }, ie = function(ve, ge) {
    for (var oe = [], Ee = ge, Ce = 0; Ee < ve.length; Ee += 1, Ce += 1)
      oe[Ce] = ve[Ee];
    return oe;
  }, se = function(le, ve) {
    for (var ge = "", oe = 0; oe < le.length; oe += 1)
      ge += le[oe], oe + 1 < le.length && (ge += ve);
    return ge;
  };
  return implementation = function(ve) {
    var ge = this;
    if (typeof ge != "function" || z.apply(ge) !== ne)
      throw new TypeError(B + ge);
    for (var oe = ie(arguments, 1), Ee, Ce = function() {
      if (this instanceof Ee) {
        var Pt = ge.apply(
          this,
          ae(oe, arguments)
        );
        return Object(Pt) === Pt ? Pt : this;
      }
      return ge.apply(
        ve,
        ae(oe, arguments)
      );
    }, Pe = Y(0, ge.length - oe.length), Ve = [], ht = 0; ht < Pe; ht++)
      Ve[ht] = "$" + ht;
    if (Ee = Function("binder", "return function (" + se(Ve, ",") + "){ return binder.apply(this,arguments); }")(Ce), ge.prototype) {
      var vt = function() {
      };
      vt.prototype = ge.prototype, Ee.prototype = new vt(), vt.prototype = null;
    }
    return Ee;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var B = requireImplementation();
  return functionBind = Function.prototype.bind || B, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var B = requireFunctionBind(), z = requireFunctionApply(), Y = requireFunctionCall(), ne = requireReflectApply();
  return actualApply = ne || B.call(Y, z), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var B = requireFunctionBind(), z = requireType(), Y = requireFunctionCall(), ne = requireActualApply();
  return callBindApplyHelpers = function(ie) {
    if (ie.length < 1 || typeof ie[0] != "function")
      throw new z("a function is required");
    return ne(B, Y, ie);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var B = requireCallBindApplyHelpers(), z = requireGopd(), Y;
  try {
    Y = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (se) {
    if (!se || typeof se != "object" || !("code" in se) || se.code !== "ERR_PROTO_ACCESS")
      throw se;
  }
  var ne = !!Y && z && z(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), ae = Object, ie = ae.getPrototypeOf;
  return get = ne && typeof ne.get == "function" ? B([ne.get]) : typeof ie == "function" ? (
    /** @type {import('./get')} */
    function(le) {
      return ie(le == null ? le : ae(le));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var B = requireReflect_getPrototypeOf(), z = requireObject_getPrototypeOf(), Y = requireGet();
  return getProto = B ? function(ae) {
    return B(ae);
  } : z ? function(ae) {
    if (!ae || typeof ae != "object" && typeof ae != "function")
      throw new TypeError("getProto: not an object");
    return z(ae);
  } : Y ? function(ae) {
    return Y(ae);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var B = Function.prototype.call, z = Object.prototype.hasOwnProperty, Y = requireFunctionBind();
  return hasown = Y.call(B, z), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var B, z = requireEsObjectAtoms(), Y = requireEsErrors(), ne = require_eval(), ae = requireRange(), ie = requireRef(), se = requireSyntax(), le = requireType(), ve = requireUri(), ge = requireAbs(), oe = requireFloor(), Ee = requireMax(), Ce = requireMin(), Pe = requirePow(), Ve = requireRound(), ht = requireSign$1(), vt = Function, Pt = function(rr) {
    try {
      return vt('"use strict"; return (' + rr + ").constructor;")();
    } catch {
    }
  }, _t = requireGopd(), kt = requireEsDefineProperty(), Ot = function() {
    throw new le();
  }, Ht = _t ? function() {
    try {
      return arguments.callee, Ot;
    } catch {
      try {
        return _t(arguments, "callee").get;
      } catch {
        return Ot;
      }
    }
  }() : Ot, jt = requireHasSymbols()(), Yt = requireGetProto(), Dt = requireObject_getPrototypeOf(), Ct = requireReflect_getPrototypeOf(), Kt = requireFunctionApply(), Nt = requireFunctionCall(), Je = {}, Xe = typeof Uint8Array > "u" || !Yt ? B : Yt(Uint8Array), Ke = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? B : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? B : ArrayBuffer,
    "%ArrayIteratorPrototype%": jt && Yt ? Yt([][Symbol.iterator]()) : B,
    "%AsyncFromSyncIteratorPrototype%": B,
    "%AsyncFunction%": Je,
    "%AsyncGenerator%": Je,
    "%AsyncGeneratorFunction%": Je,
    "%AsyncIteratorPrototype%": Je,
    "%Atomics%": typeof Atomics > "u" ? B : Atomics,
    "%BigInt%": typeof BigInt > "u" ? B : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? B : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? B : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? B : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Y,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": ne,
    "%Float32Array%": typeof Float32Array > "u" ? B : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? B : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? B : FinalizationRegistry,
    "%Function%": vt,
    "%GeneratorFunction%": Je,
    "%Int8Array%": typeof Int8Array > "u" ? B : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? B : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? B : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": jt && Yt ? Yt(Yt([][Symbol.iterator]())) : B,
    "%JSON%": typeof JSON == "object" ? JSON : B,
    "%Map%": typeof Map > "u" ? B : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !jt || !Yt ? B : Yt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": z,
    "%Object.getOwnPropertyDescriptor%": _t,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? B : Promise,
    "%Proxy%": typeof Proxy > "u" ? B : Proxy,
    "%RangeError%": ae,
    "%ReferenceError%": ie,
    "%Reflect%": typeof Reflect > "u" ? B : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? B : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !jt || !Yt ? B : Yt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? B : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": jt && Yt ? Yt(""[Symbol.iterator]()) : B,
    "%Symbol%": jt ? Symbol : B,
    "%SyntaxError%": se,
    "%ThrowTypeError%": Ht,
    "%TypedArray%": Xe,
    "%TypeError%": le,
    "%Uint8Array%": typeof Uint8Array > "u" ? B : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? B : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? B : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? B : Uint32Array,
    "%URIError%": ve,
    "%WeakMap%": typeof WeakMap > "u" ? B : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? B : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? B : WeakSet,
    "%Function.prototype.call%": Nt,
    "%Function.prototype.apply%": Kt,
    "%Object.defineProperty%": kt,
    "%Object.getPrototypeOf%": Dt,
    "%Math.abs%": ge,
    "%Math.floor%": oe,
    "%Math.max%": Ee,
    "%Math.min%": Ce,
    "%Math.pow%": Pe,
    "%Math.round%": Ve,
    "%Math.sign%": ht,
    "%Reflect.getPrototypeOf%": Ct
  };
  if (Yt)
    try {
      null.error;
    } catch (rr) {
      var Qe = Yt(Yt(rr));
      Ke["%Error.prototype%"] = Qe;
    }
  var bt = function rr(or) {
    var Xt;
    if (or === "%AsyncFunction%")
      Xt = Pt("async function () {}");
    else if (or === "%GeneratorFunction%")
      Xt = Pt("function* () {}");
    else if (or === "%AsyncGeneratorFunction%")
      Xt = Pt("async function* () {}");
    else if (or === "%AsyncGenerator%") {
      var zt = rr("%AsyncGeneratorFunction%");
      zt && (Xt = zt.prototype);
    } else if (or === "%AsyncIteratorPrototype%") {
      var ur = rr("%AsyncGenerator%");
      ur && Yt && (Xt = Yt(ur.prototype));
    }
    return Ke[or] = Xt, Xt;
  }, wt = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, xt = requireFunctionBind(), Bt = requireHasown(), $t = xt.call(Nt, Array.prototype.concat), qt = xt.call(Kt, Array.prototype.splice), Rt = xt.call(Nt, String.prototype.replace), Lt = xt.call(Nt, String.prototype.slice), tr = xt.call(Nt, RegExp.prototype.exec), sr = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Zt = /\\(\\)?/g, Wt = function(or) {
    var Xt = Lt(or, 0, 1), zt = Lt(or, -1);
    if (Xt === "%" && zt !== "%")
      throw new se("invalid intrinsic syntax, expected closing `%`");
    if (zt === "%" && Xt !== "%")
      throw new se("invalid intrinsic syntax, expected opening `%`");
    var ur = [];
    return Rt(or, sr, function(pr, vr, _r, xr) {
      ur[ur.length] = _r ? Rt(xr, Zt, "$1") : vr || pr;
    }), ur;
  }, Gt = function(or, Xt) {
    var zt = or, ur;
    if (Bt(wt, zt) && (ur = wt[zt], zt = "%" + ur[0] + "%"), Bt(Ke, zt)) {
      var pr = Ke[zt];
      if (pr === Je && (pr = bt(zt)), typeof pr > "u" && !Xt)
        throw new le("intrinsic " + or + " exists, but is not available. Please file an issue!");
      return {
        alias: ur,
        name: zt,
        value: pr
      };
    }
    throw new se("intrinsic " + or + " does not exist!");
  };
  return getIntrinsic = function(or, Xt) {
    if (typeof or != "string" || or.length === 0)
      throw new le("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Xt != "boolean")
      throw new le('"allowMissing" argument must be a boolean');
    if (tr(/^%?[^%]*%?$/, or) === null)
      throw new se("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var zt = Wt(or), ur = zt.length > 0 ? zt[0] : "", pr = Gt("%" + ur + "%", Xt), vr = pr.name, _r = pr.value, xr = !1, Tr = pr.alias;
    Tr && (ur = Tr[0], qt(zt, $t([0, 1], Tr)));
    for (var hr = 1, Wr = !0; hr < zt.length; hr += 1) {
      var $r = zt[hr], Ur = Lt($r, 0, 1), Gr = Lt($r, -1);
      if ((Ur === '"' || Ur === "'" || Ur === "`" || Gr === '"' || Gr === "'" || Gr === "`") && Ur !== Gr)
        throw new se("property names with quotes must have matching quotes");
      if (($r === "constructor" || !Wr) && (xr = !0), ur += "." + $r, vr = "%" + ur + "%", Bt(Ke, vr))
        _r = Ke[vr];
      else if (_r != null) {
        if (!($r in _r)) {
          if (!Xt)
            throw new le("base intrinsic for " + or + " exists, but the property is not available.");
          return;
        }
        if (_t && hr + 1 >= zt.length) {
          var Rr = _t(_r, $r);
          Wr = !!Rr, Wr && "get" in Rr && !("originalValue" in Rr.get) ? _r = Rr.get : _r = _r[$r];
        } else
          Wr = Bt(_r, $r), _r = _r[$r];
        Wr && !xr && (Ke[vr] = _r);
      }
    }
    return _r;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var B = requireGetIntrinsic(), z = requireCallBindApplyHelpers(), Y = z([B("%String.prototype.indexOf%")]);
  return callBound = function(ae, ie) {
    var se = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      B(ae, !!ie)
    );
    return typeof se == "function" && Y(ae, ".prototype.") > -1 ? z([se]) : se;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var B = requireShams()(), z = requireCallBound(), Y = z("Object.prototype.toString"), ne = function(le) {
    return B && le && typeof le == "object" && Symbol.toStringTag in le ? !1 : Y(le) === "[object Arguments]";
  }, ae = function(le) {
    return ne(le) ? !0 : le !== null && typeof le == "object" && "length" in le && typeof le.length == "number" && le.length >= 0 && Y(le) !== "[object Array]" && "callee" in le && Y(le.callee) === "[object Function]";
  }, ie = function() {
    return ne(arguments);
  }();
  return ne.isLegacyArguments = ae, isArguments = ie ? ne : ae, isArguments;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var B = requireCallBound(), z = requireShams()(), Y = requireHasown(), ne = requireGopd(), ae;
  if (z) {
    var ie = B("RegExp.prototype.exec"), se = {}, le = function() {
      throw se;
    }, ve = {
      toString: le,
      valueOf: le
    };
    typeof Symbol.toPrimitive == "symbol" && (ve[Symbol.toPrimitive] = le), ae = function(Ce) {
      if (!Ce || typeof Ce != "object")
        return !1;
      var Pe = (
        /** @type {NonNullable<typeof gOPD>} */
        ne(
          /** @type {{ lastIndex?: unknown }} */
          Ce,
          "lastIndex"
        )
      ), Ve = Pe && Y(Pe, "value");
      if (!Ve)
        return !1;
      try {
        ie(
          Ce,
          /** @type {string} */
          /** @type {unknown} */
          ve
        );
      } catch (ht) {
        return ht === se;
      }
    };
  } else {
    var ge = B("Object.prototype.toString"), oe = "[object RegExp]";
    ae = function(Ce) {
      return !Ce || typeof Ce != "object" && typeof Ce != "function" ? !1 : ge(Ce) === oe;
    };
  }
  return isRegex = ae, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var B = requireCallBound(), z = requireIsRegex(), Y = B("RegExp.prototype.exec"), ne = requireType();
  return safeRegexTest = function(ie) {
    if (!z(ie))
      throw new ne("`regex` must be a RegExp");
    return function(le) {
      return Y(ie, le) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var B = requireCallBound(), z = requireSafeRegexTest(), Y = z(/^\s*(?:function)?\*/), ne = requireShams()(), ae = requireGetProto(), ie = B("Object.prototype.toString"), se = B("Function.prototype.toString"), le = function() {
    if (!ne)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, ve;
  return isGeneratorFunction = function(oe) {
    if (typeof oe != "function")
      return !1;
    if (Y(se(oe)))
      return !0;
    if (!ne) {
      var Ee = ie(oe);
      return Ee === "[object GeneratorFunction]";
    }
    if (!ae)
      return !1;
    if (typeof ve > "u") {
      var Ce = le();
      ve = Ce ? (
        /** @type {GeneratorFunctionConstructor} */
        ae(Ce)
      ) : !1;
    }
    return ae(oe) === ve;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var B = Function.prototype.toString, z = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Y, ne;
  if (typeof z == "function" && typeof Object.defineProperty == "function")
    try {
      Y = Object.defineProperty({}, "length", {
        get: function() {
          throw ne;
        }
      }), ne = {}, z(function() {
        throw 42;
      }, null, Y);
    } catch (_t) {
      _t !== ne && (z = null);
    }
  else
    z = null;
  var ae = /^\s*class\b/, ie = function(kt) {
    try {
      var Ot = B.call(kt);
      return ae.test(Ot);
    } catch {
      return !1;
    }
  }, se = function(kt) {
    try {
      return ie(kt) ? !1 : (B.call(kt), !0);
    } catch {
      return !1;
    }
  }, le = Object.prototype.toString, ve = "[object Object]", ge = "[object Function]", oe = "[object GeneratorFunction]", Ee = "[object HTMLAllCollection]", Ce = "[object HTML document.all class]", Pe = "[object HTMLCollection]", Ve = typeof Symbol == "function" && !!Symbol.toStringTag, ht = !(0 in [,]), vt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var Pt = document.all;
    le.call(Pt) === le.call(document.all) && (vt = function(kt) {
      if ((ht || !kt) && (typeof kt > "u" || typeof kt == "object"))
        try {
          var Ot = le.call(kt);
          return (Ot === Ee || Ot === Ce || Ot === Pe || Ot === ve) && kt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = z ? function(kt) {
    if (vt(kt))
      return !0;
    if (!kt || typeof kt != "function" && typeof kt != "object")
      return !1;
    try {
      z(kt, null, Y);
    } catch (Ot) {
      if (Ot !== ne)
        return !1;
    }
    return !ie(kt) && se(kt);
  } : function(kt) {
    if (vt(kt))
      return !0;
    if (!kt || typeof kt != "function" && typeof kt != "object")
      return !1;
    if (Ve)
      return se(kt);
    if (ie(kt))
      return !1;
    var Ot = le.call(kt);
    return Ot !== ge && Ot !== oe && !/^\[object HTML/.test(Ot) ? !1 : se(kt);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var B = requireIsCallable(), z = Object.prototype.toString, Y = Object.prototype.hasOwnProperty, ne = function(ve, ge, oe) {
    for (var Ee = 0, Ce = ve.length; Ee < Ce; Ee++)
      Y.call(ve, Ee) && (oe == null ? ge(ve[Ee], Ee, ve) : ge.call(oe, ve[Ee], Ee, ve));
  }, ae = function(ve, ge, oe) {
    for (var Ee = 0, Ce = ve.length; Ee < Ce; Ee++)
      oe == null ? ge(ve.charAt(Ee), Ee, ve) : ge.call(oe, ve.charAt(Ee), Ee, ve);
  }, ie = function(ve, ge, oe) {
    for (var Ee in ve)
      Y.call(ve, Ee) && (oe == null ? ge(ve[Ee], Ee, ve) : ge.call(oe, ve[Ee], Ee, ve));
  };
  function se(le) {
    return z.call(le) === "[object Array]";
  }
  return forEach = function(ve, ge, oe) {
    if (!B(ge))
      throw new TypeError("iterator must be a function");
    var Ee;
    arguments.length >= 3 && (Ee = oe), se(ve) ? ne(ve, ge, Ee) : typeof ve == "string" ? ae(ve, ge, Ee) : ie(ve, ge, Ee);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var B = requirePossibleTypedArrayNames(), z = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var ne = [], ae = 0; ae < B.length; ae++)
      typeof z[B[ae]] == "function" && (ne[ne.length] = B[ae]);
    return ne;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var B = requireEsDefineProperty(), z = requireSyntax(), Y = requireType(), ne = requireGopd();
  return defineDataProperty = function(ie, se, le) {
    if (!ie || typeof ie != "object" && typeof ie != "function")
      throw new Y("`obj` must be an object or a function`");
    if (typeof se != "string" && typeof se != "symbol")
      throw new Y("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new Y("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new Y("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new Y("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new Y("`loose`, if provided, must be a boolean");
    var ve = arguments.length > 3 ? arguments[3] : null, ge = arguments.length > 4 ? arguments[4] : null, oe = arguments.length > 5 ? arguments[5] : null, Ee = arguments.length > 6 ? arguments[6] : !1, Ce = !!ne && ne(ie, se);
    if (B)
      B(ie, se, {
        configurable: oe === null && Ce ? Ce.configurable : !oe,
        enumerable: ve === null && Ce ? Ce.enumerable : !ve,
        value: le,
        writable: ge === null && Ce ? Ce.writable : !ge
      });
    else if (Ee || !ve && !ge && !oe)
      ie[se] = le;
    else
      throw new z("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var B = requireEsDefineProperty(), z = function() {
    return !!B;
  };
  return z.hasArrayLengthDefineBug = function() {
    if (!B)
      return null;
    try {
      return B([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = z, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var B = requireGetIntrinsic(), z = requireDefineDataProperty(), Y = requireHasPropertyDescriptors()(), ne = requireGopd(), ae = requireType(), ie = B("%Math.floor%");
  return setFunctionLength = function(le, ve) {
    if (typeof le != "function")
      throw new ae("`fn` is not a function");
    if (typeof ve != "number" || ve < 0 || ve > 4294967295 || ie(ve) !== ve)
      throw new ae("`length` must be a positive 32-bit integer");
    var ge = arguments.length > 2 && !!arguments[2], oe = !0, Ee = !0;
    if ("length" in le && ne) {
      var Ce = ne(le, "length");
      Ce && !Ce.configurable && (oe = !1), Ce && !Ce.writable && (Ee = !1);
    }
    return (oe || Ee || !ge) && (Y ? z(
      /** @type {Parameters<define>[0]} */
      le,
      "length",
      ve,
      !0,
      !0
    ) : z(
      /** @type {Parameters<define>[0]} */
      le,
      "length",
      ve
    )), le;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var B = requireFunctionBind(), z = requireFunctionApply(), Y = requireActualApply();
  return applyBind = function() {
    return Y(B, z, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(B) {
    var z = requireSetFunctionLength(), Y = requireEsDefineProperty(), ne = requireCallBindApplyHelpers(), ae = requireApplyBind();
    B.exports = function(se) {
      var le = ne(arguments), ve = se.length - (arguments.length - 1);
      return z(
        le,
        1 + (ve > 0 ? ve : 0),
        !0
      );
    }, Y ? Y(B.exports, "apply", { value: ae }) : B.exports.apply = ae;
  }(callBind)), callBind.exports;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var B = requireForEach(), z = requireAvailableTypedArrays(), Y = requireCallBind(), ne = requireCallBound(), ae = requireGopd(), ie = ne("Object.prototype.toString"), se = requireShams()(), le = typeof globalThis > "u" ? commonjsGlobal : globalThis, ve = z(), ge = ne("String.prototype.slice"), oe = Object.getPrototypeOf, Ee = ne("Array.prototype.indexOf", !0) || function(vt, Pt) {
    for (var _t = 0; _t < vt.length; _t += 1)
      if (vt[_t] === Pt)
        return _t;
    return -1;
  }, Ce = { __proto__: null };
  se && ae && oe ? B(ve, function(ht) {
    var vt = new le[ht]();
    if (Symbol.toStringTag in vt) {
      var Pt = oe(vt), _t = ae(Pt, Symbol.toStringTag);
      if (!_t) {
        var kt = oe(Pt);
        _t = ae(kt, Symbol.toStringTag);
      }
      Ce["$" + ht] = Y(_t.get);
    }
  }) : B(ve, function(ht) {
    var vt = new le[ht](), Pt = vt.slice || vt.set;
    Pt && (Ce["$" + ht] = Y(Pt));
  });
  var Pe = function(vt) {
    var Pt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ce,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(_t, kt) {
        if (!Pt)
          try {
            "$" + _t(vt) === kt && (Pt = ge(kt, 1));
          } catch {
          }
      }
    ), Pt;
  }, Ve = function(vt) {
    var Pt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ce,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(_t, kt) {
        if (!Pt)
          try {
            _t(vt), Pt = ge(kt, 1);
          } catch {
          }
      }
    ), Pt;
  };
  return whichTypedArray = function(vt) {
    if (!vt || typeof vt != "object")
      return !1;
    if (!se) {
      var Pt = ge(ie(vt), 8, -1);
      return Ee(ve, Pt) > -1 ? Pt : Pt !== "Object" ? !1 : Ve(vt);
    }
    return ae ? Pe(vt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var B = requireWhichTypedArray();
  return isTypedArray = function(Y) {
    return !!B(Y);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(B) {
    var z = requireIsArguments(), Y = requireIsGeneratorFunction(), ne = requireWhichTypedArray(), ae = requireIsTypedArray();
    function ie(hr) {
      return hr.call.bind(hr);
    }
    var se = typeof BigInt < "u", le = typeof Symbol < "u", ve = ie(Object.prototype.toString), ge = ie(Number.prototype.valueOf), oe = ie(String.prototype.valueOf), Ee = ie(Boolean.prototype.valueOf);
    if (se)
      var Ce = ie(BigInt.prototype.valueOf);
    if (le)
      var Pe = ie(Symbol.prototype.valueOf);
    function Ve(hr, Wr) {
      if (typeof hr != "object")
        return !1;
      try {
        return Wr(hr), !0;
      } catch {
        return !1;
      }
    }
    B.isArgumentsObject = z, B.isGeneratorFunction = Y, B.isTypedArray = ae;
    function ht(hr) {
      return typeof Promise < "u" && hr instanceof Promise || hr !== null && typeof hr == "object" && typeof hr.then == "function" && typeof hr.catch == "function";
    }
    B.isPromise = ht;
    function vt(hr) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(hr) : ae(hr) || Lt(hr);
    }
    B.isArrayBufferView = vt;
    function Pt(hr) {
      return ne(hr) === "Uint8Array";
    }
    B.isUint8Array = Pt;
    function _t(hr) {
      return ne(hr) === "Uint8ClampedArray";
    }
    B.isUint8ClampedArray = _t;
    function kt(hr) {
      return ne(hr) === "Uint16Array";
    }
    B.isUint16Array = kt;
    function Ot(hr) {
      return ne(hr) === "Uint32Array";
    }
    B.isUint32Array = Ot;
    function Ht(hr) {
      return ne(hr) === "Int8Array";
    }
    B.isInt8Array = Ht;
    function jt(hr) {
      return ne(hr) === "Int16Array";
    }
    B.isInt16Array = jt;
    function Yt(hr) {
      return ne(hr) === "Int32Array";
    }
    B.isInt32Array = Yt;
    function Dt(hr) {
      return ne(hr) === "Float32Array";
    }
    B.isFloat32Array = Dt;
    function Ct(hr) {
      return ne(hr) === "Float64Array";
    }
    B.isFloat64Array = Ct;
    function Kt(hr) {
      return ne(hr) === "BigInt64Array";
    }
    B.isBigInt64Array = Kt;
    function Nt(hr) {
      return ne(hr) === "BigUint64Array";
    }
    B.isBigUint64Array = Nt;
    function Je(hr) {
      return ve(hr) === "[object Map]";
    }
    Je.working = typeof Map < "u" && Je(/* @__PURE__ */ new Map());
    function Xe(hr) {
      return typeof Map > "u" ? !1 : Je.working ? Je(hr) : hr instanceof Map;
    }
    B.isMap = Xe;
    function Ke(hr) {
      return ve(hr) === "[object Set]";
    }
    Ke.working = typeof Set < "u" && Ke(/* @__PURE__ */ new Set());
    function Qe(hr) {
      return typeof Set > "u" ? !1 : Ke.working ? Ke(hr) : hr instanceof Set;
    }
    B.isSet = Qe;
    function bt(hr) {
      return ve(hr) === "[object WeakMap]";
    }
    bt.working = typeof WeakMap < "u" && bt(/* @__PURE__ */ new WeakMap());
    function wt(hr) {
      return typeof WeakMap > "u" ? !1 : bt.working ? bt(hr) : hr instanceof WeakMap;
    }
    B.isWeakMap = wt;
    function xt(hr) {
      return ve(hr) === "[object WeakSet]";
    }
    xt.working = typeof WeakSet < "u" && xt(/* @__PURE__ */ new WeakSet());
    function Bt(hr) {
      return xt(hr);
    }
    B.isWeakSet = Bt;
    function $t(hr) {
      return ve(hr) === "[object ArrayBuffer]";
    }
    $t.working = typeof ArrayBuffer < "u" && $t(new ArrayBuffer());
    function qt(hr) {
      return typeof ArrayBuffer > "u" ? !1 : $t.working ? $t(hr) : hr instanceof ArrayBuffer;
    }
    B.isArrayBuffer = qt;
    function Rt(hr) {
      return ve(hr) === "[object DataView]";
    }
    Rt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Rt(new DataView(new ArrayBuffer(1), 0, 1));
    function Lt(hr) {
      return typeof DataView > "u" ? !1 : Rt.working ? Rt(hr) : hr instanceof DataView;
    }
    B.isDataView = Lt;
    var tr = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function sr(hr) {
      return ve(hr) === "[object SharedArrayBuffer]";
    }
    function Zt(hr) {
      return typeof tr > "u" ? !1 : (typeof sr.working > "u" && (sr.working = sr(new tr())), sr.working ? sr(hr) : hr instanceof tr);
    }
    B.isSharedArrayBuffer = Zt;
    function Wt(hr) {
      return ve(hr) === "[object AsyncFunction]";
    }
    B.isAsyncFunction = Wt;
    function Gt(hr) {
      return ve(hr) === "[object Map Iterator]";
    }
    B.isMapIterator = Gt;
    function rr(hr) {
      return ve(hr) === "[object Set Iterator]";
    }
    B.isSetIterator = rr;
    function or(hr) {
      return ve(hr) === "[object Generator]";
    }
    B.isGeneratorObject = or;
    function Xt(hr) {
      return ve(hr) === "[object WebAssembly.Module]";
    }
    B.isWebAssemblyCompiledModule = Xt;
    function zt(hr) {
      return Ve(hr, ge);
    }
    B.isNumberObject = zt;
    function ur(hr) {
      return Ve(hr, oe);
    }
    B.isStringObject = ur;
    function pr(hr) {
      return Ve(hr, Ee);
    }
    B.isBooleanObject = pr;
    function vr(hr) {
      return se && Ve(hr, Ce);
    }
    B.isBigIntObject = vr;
    function _r(hr) {
      return le && Ve(hr, Pe);
    }
    B.isSymbolObject = _r;
    function xr(hr) {
      return zt(hr) || ur(hr) || pr(hr) || vr(hr) || _r(hr);
    }
    B.isBoxedPrimitive = xr;
    function Tr(hr) {
      return typeof Uint8Array < "u" && (qt(hr) || Zt(hr));
    }
    B.isAnyArrayBuffer = Tr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(hr) {
      Object.defineProperty(B, hr, {
        enumerable: !1,
        value: function() {
          throw new Error(hr + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(z) {
    return z && typeof z == "object" && typeof z.copy == "function" && typeof z.fill == "function" && typeof z.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(B) {
    var z = Object.getOwnPropertyDescriptors || function(Lt) {
      for (var tr = Object.keys(Lt), sr = {}, Zt = 0; Zt < tr.length; Zt++)
        sr[tr[Zt]] = Object.getOwnPropertyDescriptor(Lt, tr[Zt]);
      return sr;
    }, Y = /%[sdj%]/g;
    B.format = function(Rt) {
      if (!Ht(Rt)) {
        for (var Lt = [], tr = 0; tr < arguments.length; tr++)
          Lt.push(se(arguments[tr]));
        return Lt.join(" ");
      }
      for (var tr = 1, sr = arguments, Zt = sr.length, Wt = String(Rt).replace(Y, function(rr) {
        if (rr === "%%") return "%";
        if (tr >= Zt) return rr;
        switch (rr) {
          case "%s":
            return String(sr[tr++]);
          case "%d":
            return Number(sr[tr++]);
          case "%j":
            try {
              return JSON.stringify(sr[tr++]);
            } catch {
              return "[Circular]";
            }
          default:
            return rr;
        }
      }), Gt = sr[tr]; tr < Zt; Gt = sr[++tr])
        _t(Gt) || !Ct(Gt) ? Wt += " " + Gt : Wt += " " + se(Gt);
      return Wt;
    }, B.deprecate = function(Rt, Lt) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return Rt;
      if (typeof process$1 > "u")
        return function() {
          return B.deprecate(Rt, Lt).apply(this, arguments);
        };
      var tr = !1;
      function sr() {
        if (!tr) {
          if (process$1.throwDeprecation)
            throw new Error(Lt);
          process$1.traceDeprecation ? console.trace(Lt) : console.error(Lt), tr = !0;
        }
        return Rt.apply(this, arguments);
      }
      return sr;
    };
    var ne = {}, ae = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var ie = process$1.env.NODE_DEBUG;
      ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ae = new RegExp("^" + ie + "$", "i");
    }
    B.debuglog = function(Rt) {
      if (Rt = Rt.toUpperCase(), !ne[Rt])
        if (ae.test(Rt)) {
          var Lt = process$1.pid;
          ne[Rt] = function() {
            var tr = B.format.apply(B, arguments);
            console.error("%s %d: %s", Rt, Lt, tr);
          };
        } else
          ne[Rt] = function() {
          };
      return ne[Rt];
    };
    function se(Rt, Lt) {
      var tr = {
        seen: [],
        stylize: ve
      };
      return arguments.length >= 3 && (tr.depth = arguments[2]), arguments.length >= 4 && (tr.colors = arguments[3]), Pt(Lt) ? tr.showHidden = Lt : Lt && B._extend(tr, Lt), Yt(tr.showHidden) && (tr.showHidden = !1), Yt(tr.depth) && (tr.depth = 2), Yt(tr.colors) && (tr.colors = !1), Yt(tr.customInspect) && (tr.customInspect = !0), tr.colors && (tr.stylize = le), oe(tr, Rt, tr.depth);
    }
    B.inspect = se, se.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, se.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function le(Rt, Lt) {
      var tr = se.styles[Lt];
      return tr ? "\x1B[" + se.colors[tr][0] + "m" + Rt + "\x1B[" + se.colors[tr][1] + "m" : Rt;
    }
    function ve(Rt, Lt) {
      return Rt;
    }
    function ge(Rt) {
      var Lt = {};
      return Rt.forEach(function(tr, sr) {
        Lt[tr] = !0;
      }), Lt;
    }
    function oe(Rt, Lt, tr) {
      if (Rt.customInspect && Lt && Je(Lt.inspect) && // Filter out the util module, it's inspect function is special
      Lt.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
      !(Lt.constructor && Lt.constructor.prototype === Lt)) {
        var sr = Lt.inspect(tr, Rt);
        return Ht(sr) || (sr = oe(Rt, sr, tr)), sr;
      }
      var Zt = Ee(Rt, Lt);
      if (Zt)
        return Zt;
      var Wt = Object.keys(Lt), Gt = ge(Wt);
      if (Rt.showHidden && (Wt = Object.getOwnPropertyNames(Lt)), Nt(Lt) && (Wt.indexOf("message") >= 0 || Wt.indexOf("description") >= 0))
        return Ce(Lt);
      if (Wt.length === 0) {
        if (Je(Lt)) {
          var rr = Lt.name ? ": " + Lt.name : "";
          return Rt.stylize("[Function" + rr + "]", "special");
        }
        if (Dt(Lt))
          return Rt.stylize(RegExp.prototype.toString.call(Lt), "regexp");
        if (Kt(Lt))
          return Rt.stylize(Date.prototype.toString.call(Lt), "date");
        if (Nt(Lt))
          return Ce(Lt);
      }
      var or = "", Xt = !1, zt = ["{", "}"];
      if (vt(Lt) && (Xt = !0, zt = ["[", "]"]), Je(Lt)) {
        var ur = Lt.name ? ": " + Lt.name : "";
        or = " [Function" + ur + "]";
      }
      if (Dt(Lt) && (or = " " + RegExp.prototype.toString.call(Lt)), Kt(Lt) && (or = " " + Date.prototype.toUTCString.call(Lt)), Nt(Lt) && (or = " " + Ce(Lt)), Wt.length === 0 && (!Xt || Lt.length == 0))
        return zt[0] + or + zt[1];
      if (tr < 0)
        return Dt(Lt) ? Rt.stylize(RegExp.prototype.toString.call(Lt), "regexp") : Rt.stylize("[Object]", "special");
      Rt.seen.push(Lt);
      var pr;
      return Xt ? pr = Pe(Rt, Lt, tr, Gt, Wt) : pr = Wt.map(function(vr) {
        return Ve(Rt, Lt, tr, Gt, vr, Xt);
      }), Rt.seen.pop(), ht(pr, or, zt);
    }
    function Ee(Rt, Lt) {
      if (Yt(Lt))
        return Rt.stylize("undefined", "undefined");
      if (Ht(Lt)) {
        var tr = "'" + JSON.stringify(Lt).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Rt.stylize(tr, "string");
      }
      if (Ot(Lt))
        return Rt.stylize("" + Lt, "number");
      if (Pt(Lt))
        return Rt.stylize("" + Lt, "boolean");
      if (_t(Lt))
        return Rt.stylize("null", "null");
    }
    function Ce(Rt) {
      return "[" + Error.prototype.toString.call(Rt) + "]";
    }
    function Pe(Rt, Lt, tr, sr, Zt) {
      for (var Wt = [], Gt = 0, rr = Lt.length; Gt < rr; ++Gt)
        xt(Lt, String(Gt)) ? Wt.push(Ve(
          Rt,
          Lt,
          tr,
          sr,
          String(Gt),
          !0
        )) : Wt.push("");
      return Zt.forEach(function(or) {
        or.match(/^\d+$/) || Wt.push(Ve(
          Rt,
          Lt,
          tr,
          sr,
          or,
          !0
        ));
      }), Wt;
    }
    function Ve(Rt, Lt, tr, sr, Zt, Wt) {
      var Gt, rr, or;
      if (or = Object.getOwnPropertyDescriptor(Lt, Zt) || { value: Lt[Zt] }, or.get ? or.set ? rr = Rt.stylize("[Getter/Setter]", "special") : rr = Rt.stylize("[Getter]", "special") : or.set && (rr = Rt.stylize("[Setter]", "special")), xt(sr, Zt) || (Gt = "[" + Zt + "]"), rr || (Rt.seen.indexOf(or.value) < 0 ? (_t(tr) ? rr = oe(Rt, or.value, null) : rr = oe(Rt, or.value, tr - 1), rr.indexOf(`
`) > -1 && (Wt ? rr = rr.split(`
`).map(function(Xt) {
        return "  " + Xt;
      }).join(`
`).slice(2) : rr = `
` + rr.split(`
`).map(function(Xt) {
        return "   " + Xt;
      }).join(`
`))) : rr = Rt.stylize("[Circular]", "special")), Yt(Gt)) {
        if (Wt && Zt.match(/^\d+$/))
          return rr;
        Gt = JSON.stringify("" + Zt), Gt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Gt = Gt.slice(1, -1), Gt = Rt.stylize(Gt, "name")) : (Gt = Gt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Gt = Rt.stylize(Gt, "string"));
      }
      return Gt + ": " + rr;
    }
    function ht(Rt, Lt, tr) {
      var sr = Rt.reduce(function(Zt, Wt) {
        return Wt.indexOf(`
`) >= 0, Zt + Wt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return sr > 60 ? tr[0] + (Lt === "" ? "" : Lt + `
 `) + " " + Rt.join(`,
  `) + " " + tr[1] : tr[0] + Lt + " " + Rt.join(", ") + " " + tr[1];
    }
    B.types = requireTypes();
    function vt(Rt) {
      return Array.isArray(Rt);
    }
    B.isArray = vt;
    function Pt(Rt) {
      return typeof Rt == "boolean";
    }
    B.isBoolean = Pt;
    function _t(Rt) {
      return Rt === null;
    }
    B.isNull = _t;
    function kt(Rt) {
      return Rt == null;
    }
    B.isNullOrUndefined = kt;
    function Ot(Rt) {
      return typeof Rt == "number";
    }
    B.isNumber = Ot;
    function Ht(Rt) {
      return typeof Rt == "string";
    }
    B.isString = Ht;
    function jt(Rt) {
      return typeof Rt == "symbol";
    }
    B.isSymbol = jt;
    function Yt(Rt) {
      return Rt === void 0;
    }
    B.isUndefined = Yt;
    function Dt(Rt) {
      return Ct(Rt) && Ke(Rt) === "[object RegExp]";
    }
    B.isRegExp = Dt, B.types.isRegExp = Dt;
    function Ct(Rt) {
      return typeof Rt == "object" && Rt !== null;
    }
    B.isObject = Ct;
    function Kt(Rt) {
      return Ct(Rt) && Ke(Rt) === "[object Date]";
    }
    B.isDate = Kt, B.types.isDate = Kt;
    function Nt(Rt) {
      return Ct(Rt) && (Ke(Rt) === "[object Error]" || Rt instanceof Error);
    }
    B.isError = Nt, B.types.isNativeError = Nt;
    function Je(Rt) {
      return typeof Rt == "function";
    }
    B.isFunction = Je;
    function Xe(Rt) {
      return Rt === null || typeof Rt == "boolean" || typeof Rt == "number" || typeof Rt == "string" || typeof Rt == "symbol" || // ES6 symbol
      typeof Rt > "u";
    }
    B.isPrimitive = Xe, B.isBuffer = requireIsBufferBrowser();
    function Ke(Rt) {
      return Object.prototype.toString.call(Rt);
    }
    function Qe(Rt) {
      return Rt < 10 ? "0" + Rt.toString(10) : Rt.toString(10);
    }
    var bt = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function wt() {
      var Rt = /* @__PURE__ */ new Date(), Lt = [
        Qe(Rt.getHours()),
        Qe(Rt.getMinutes()),
        Qe(Rt.getSeconds())
      ].join(":");
      return [Rt.getDate(), bt[Rt.getMonth()], Lt].join(" ");
    }
    B.log = function() {
      console.log("%s - %s", wt(), B.format.apply(B, arguments));
    }, B.inherits = requireInherits_browser(), B._extend = function(Rt, Lt) {
      if (!Lt || !Ct(Lt)) return Rt;
      for (var tr = Object.keys(Lt), sr = tr.length; sr--; )
        Rt[tr[sr]] = Lt[tr[sr]];
      return Rt;
    };
    function xt(Rt, Lt) {
      return Object.prototype.hasOwnProperty.call(Rt, Lt);
    }
    var Bt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    B.promisify = function(Lt) {
      if (typeof Lt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (Bt && Lt[Bt]) {
        var tr = Lt[Bt];
        if (typeof tr != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(tr, Bt, {
          value: tr,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), tr;
      }
      function tr() {
        for (var sr, Zt, Wt = new Promise(function(or, Xt) {
          sr = or, Zt = Xt;
        }), Gt = [], rr = 0; rr < arguments.length; rr++)
          Gt.push(arguments[rr]);
        Gt.push(function(or, Xt) {
          or ? Zt(or) : sr(Xt);
        });
        try {
          Lt.apply(this, Gt);
        } catch (or) {
          Zt(or);
        }
        return Wt;
      }
      return Object.setPrototypeOf(tr, Object.getPrototypeOf(Lt)), Bt && Object.defineProperty(tr, Bt, {
        value: tr,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        tr,
        z(Lt)
      );
    }, B.promisify.custom = Bt;
    function $t(Rt, Lt) {
      if (!Rt) {
        var tr = new Error("Promise was rejected with a falsy value");
        tr.reason = Rt, Rt = tr;
      }
      return Lt(Rt);
    }
    function qt(Rt) {
      if (typeof Rt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Lt() {
        for (var tr = [], sr = 0; sr < arguments.length; sr++)
          tr.push(arguments[sr]);
        var Zt = tr.pop();
        if (typeof Zt != "function")
          throw new TypeError("The last argument must be of type Function");
        var Wt = this, Gt = function() {
          return Zt.apply(Wt, arguments);
        };
        Rt.apply(this, tr).then(
          function(rr) {
            process$1.nextTick(Gt.bind(null, null, rr));
          },
          function(rr) {
            process$1.nextTick($t.bind(null, rr, Gt));
          }
        );
      }
      return Object.setPrototypeOf(Lt, Object.getPrototypeOf(Rt)), Object.defineProperties(
        Lt,
        z(Rt)
      ), Lt;
    }
    B.callbackify = qt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B(Ve, ht) {
    var vt = Object.keys(Ve);
    if (Object.getOwnPropertySymbols) {
      var Pt = Object.getOwnPropertySymbols(Ve);
      ht && (Pt = Pt.filter(function(_t) {
        return Object.getOwnPropertyDescriptor(Ve, _t).enumerable;
      })), vt.push.apply(vt, Pt);
    }
    return vt;
  }
  function z(Ve) {
    for (var ht = 1; ht < arguments.length; ht++) {
      var vt = arguments[ht] != null ? arguments[ht] : {};
      ht % 2 ? B(Object(vt), !0).forEach(function(Pt) {
        Y(Ve, Pt, vt[Pt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Ve, Object.getOwnPropertyDescriptors(vt)) : B(Object(vt)).forEach(function(Pt) {
        Object.defineProperty(Ve, Pt, Object.getOwnPropertyDescriptor(vt, Pt));
      });
    }
    return Ve;
  }
  function Y(Ve, ht, vt) {
    return ht = se(ht), ht in Ve ? Object.defineProperty(Ve, ht, { value: vt, enumerable: !0, configurable: !0, writable: !0 }) : Ve[ht] = vt, Ve;
  }
  function ne(Ve, ht) {
    if (!(Ve instanceof ht))
      throw new TypeError("Cannot call a class as a function");
  }
  function ae(Ve, ht) {
    for (var vt = 0; vt < ht.length; vt++) {
      var Pt = ht[vt];
      Pt.enumerable = Pt.enumerable || !1, Pt.configurable = !0, "value" in Pt && (Pt.writable = !0), Object.defineProperty(Ve, se(Pt.key), Pt);
    }
  }
  function ie(Ve, ht, vt) {
    return ht && ae(Ve.prototype, ht), Object.defineProperty(Ve, "prototype", { writable: !1 }), Ve;
  }
  function se(Ve) {
    var ht = le(Ve, "string");
    return typeof ht == "symbol" ? ht : String(ht);
  }
  function le(Ve, ht) {
    if (typeof Ve != "object" || Ve === null) return Ve;
    var vt = Ve[Symbol.toPrimitive];
    if (vt !== void 0) {
      var Pt = vt.call(Ve, ht);
      if (typeof Pt != "object") return Pt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(Ve);
  }
  var ve = require$$0$1, ge = ve.Buffer, oe = requireUtil$1(), Ee = oe.inspect, Ce = Ee && Ee.custom || "inspect";
  function Pe(Ve, ht, vt) {
    ge.prototype.copy.call(Ve, ht, vt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function Ve() {
      ne(this, Ve), this.head = null, this.tail = null, this.length = 0;
    }
    return ie(Ve, [{
      key: "push",
      value: function(vt) {
        var Pt = {
          data: vt,
          next: null
        };
        this.length > 0 ? this.tail.next = Pt : this.head = Pt, this.tail = Pt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(vt) {
        var Pt = {
          data: vt,
          next: this.head
        };
        this.length === 0 && (this.tail = Pt), this.head = Pt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var vt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, vt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(vt) {
        if (this.length === 0) return "";
        for (var Pt = this.head, _t = "" + Pt.data; Pt = Pt.next; ) _t += vt + Pt.data;
        return _t;
      }
    }, {
      key: "concat",
      value: function(vt) {
        if (this.length === 0) return ge.alloc(0);
        for (var Pt = ge.allocUnsafe(vt >>> 0), _t = this.head, kt = 0; _t; )
          Pe(_t.data, Pt, kt), kt += _t.data.length, _t = _t.next;
        return Pt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(vt, Pt) {
        var _t;
        return vt < this.head.data.length ? (_t = this.head.data.slice(0, vt), this.head.data = this.head.data.slice(vt)) : vt === this.head.data.length ? _t = this.shift() : _t = Pt ? this._getString(vt) : this._getBuffer(vt), _t;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(vt) {
        var Pt = this.head, _t = 1, kt = Pt.data;
        for (vt -= kt.length; Pt = Pt.next; ) {
          var Ot = Pt.data, Ht = vt > Ot.length ? Ot.length : vt;
          if (Ht === Ot.length ? kt += Ot : kt += Ot.slice(0, vt), vt -= Ht, vt === 0) {
            Ht === Ot.length ? (++_t, Pt.next ? this.head = Pt.next : this.head = this.tail = null) : (this.head = Pt, Pt.data = Ot.slice(Ht));
            break;
          }
          ++_t;
        }
        return this.length -= _t, kt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(vt) {
        var Pt = ge.allocUnsafe(vt), _t = this.head, kt = 1;
        for (_t.data.copy(Pt), vt -= _t.data.length; _t = _t.next; ) {
          var Ot = _t.data, Ht = vt > Ot.length ? Ot.length : vt;
          if (Ot.copy(Pt, Pt.length - vt, 0, Ht), vt -= Ht, vt === 0) {
            Ht === Ot.length ? (++kt, _t.next ? this.head = _t.next : this.head = this.tail = null) : (this.head = _t, _t.data = Ot.slice(Ht));
            break;
          }
          ++kt;
        }
        return this.length -= kt, Pt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Ce,
      value: function(vt, Pt) {
        return Ee(this, z(z({}, Pt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Ve;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function B(se, le) {
    var ve = this, ge = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
    return ge || oe ? (le ? le(se) : se && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(ae, this, se)) : process$1.nextTick(ae, this, se)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(se || null, function(Ee) {
      !le && Ee ? ve._writableState ? ve._writableState.errorEmitted ? process$1.nextTick(Y, ve) : (ve._writableState.errorEmitted = !0, process$1.nextTick(z, ve, Ee)) : process$1.nextTick(z, ve, Ee) : le ? (process$1.nextTick(Y, ve), le(Ee)) : process$1.nextTick(Y, ve);
    }), this);
  }
  function z(se, le) {
    ae(se, le), Y(se);
  }
  function Y(se) {
    se._writableState && !se._writableState.emitClose || se._readableState && !se._readableState.emitClose || se.emit("close");
  }
  function ne() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function ae(se, le) {
    se.emit("error", le);
  }
  function ie(se, le) {
    var ve = se._readableState, ge = se._writableState;
    ve && ve.autoDestroy || ge && ge.autoDestroy ? se.destroy(le) : se.emit("error", le);
  }
  return destroy_1$1 = {
    destroy: B,
    undestroy: ne,
    errorOrDestroy: ie
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function B(le, ve) {
    le.prototype = Object.create(ve.prototype), le.prototype.constructor = le, le.__proto__ = ve;
  }
  var z = {};
  function Y(le, ve, ge) {
    ge || (ge = Error);
    function oe(Ce, Pe, Ve) {
      return typeof ve == "string" ? ve : ve(Ce, Pe, Ve);
    }
    var Ee = /* @__PURE__ */ function(Ce) {
      B(Pe, Ce);
      function Pe(Ve, ht, vt) {
        return Ce.call(this, oe(Ve, ht, vt)) || this;
      }
      return Pe;
    }(ge);
    Ee.prototype.name = ge.name, Ee.prototype.code = le, z[le] = Ee;
  }
  function ne(le, ve) {
    if (Array.isArray(le)) {
      var ge = le.length;
      return le = le.map(function(oe) {
        return String(oe);
      }), ge > 2 ? "one of ".concat(ve, " ").concat(le.slice(0, ge - 1).join(", "), ", or ") + le[ge - 1] : ge === 2 ? "one of ".concat(ve, " ").concat(le[0], " or ").concat(le[1]) : "of ".concat(ve, " ").concat(le[0]);
    } else
      return "of ".concat(ve, " ").concat(String(le));
  }
  function ae(le, ve, ge) {
    return le.substr(0, ve.length) === ve;
  }
  function ie(le, ve, ge) {
    return (ge === void 0 || ge > le.length) && (ge = le.length), le.substring(ge - ve.length, ge) === ve;
  }
  function se(le, ve, ge) {
    return typeof ge != "number" && (ge = 0), ge + ve.length > le.length ? !1 : le.indexOf(ve, ge) !== -1;
  }
  return Y("ERR_INVALID_OPT_VALUE", function(le, ve) {
    return 'The value "' + ve + '" is invalid for option "' + le + '"';
  }, TypeError), Y("ERR_INVALID_ARG_TYPE", function(le, ve, ge) {
    var oe;
    typeof ve == "string" && ae(ve, "not ") ? (oe = "must not be", ve = ve.replace(/^not /, "")) : oe = "must be";
    var Ee;
    if (ie(le, " argument"))
      Ee = "The ".concat(le, " ").concat(oe, " ").concat(ne(ve, "type"));
    else {
      var Ce = se(le, ".") ? "property" : "argument";
      Ee = 'The "'.concat(le, '" ').concat(Ce, " ").concat(oe, " ").concat(ne(ve, "type"));
    }
    return Ee += ". Received type ".concat(typeof ge), Ee;
  }, TypeError), Y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Y("ERR_METHOD_NOT_IMPLEMENTED", function(le) {
    return "The " + le + " method is not implemented";
  }), Y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Y("ERR_STREAM_DESTROYED", function(le) {
    return "Cannot call " + le + " after a stream was destroyed";
  }), Y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Y("ERR_STREAM_WRITE_AFTER_END", "write after end"), Y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Y("ERR_UNKNOWN_ENCODING", function(le) {
    return "Unknown encoding: " + le;
  }, TypeError), Y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = z, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function z(ne, ae, ie) {
    return ne.highWaterMark != null ? ne.highWaterMark : ae ? ne[ie] : null;
  }
  function Y(ne, ae, ie, se) {
    var le = z(ae, se, ie);
    if (le != null) {
      if (!(isFinite(le) && Math.floor(le) === le) || le < 0) {
        var ve = se ? ie : "highWaterMark";
        throw new B(ve, le);
      }
      return Math.floor(le);
    }
    return ne.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Y
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = B;
  function B(Y, ne) {
    if (z("noDeprecation"))
      return Y;
    var ae = !1;
    function ie() {
      if (!ae) {
        if (z("throwDeprecation"))
          throw new Error(ne);
        z("traceDeprecation") ? console.trace(ne) : console.warn(ne), ae = !0;
      }
      return Y.apply(this, arguments);
    }
    return ie;
  }
  function z(Y) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var ne = commonjsGlobal.localStorage[Y];
    return ne == null ? !1 : String(ne).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Dt;
  function B(Zt) {
    var Wt = this;
    this.next = null, this.entry = null, this.finish = function() {
      sr(Wt, Zt);
    };
  }
  var z;
  Dt.WritableState = jt;
  var Y = {
    deprecate: requireBrowser$a()
  }, ne = requireStreamBrowser$1(), ae = require$$0$1.Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function se(Zt) {
    return ae.from(Zt);
  }
  function le(Zt) {
    return ae.isBuffer(Zt) || Zt instanceof ie;
  }
  var ve = requireDestroy$1(), ge = requireState(), oe = ge.getHighWaterMark, Ee = requireErrorsBrowser().codes, Ce = Ee.ERR_INVALID_ARG_TYPE, Pe = Ee.ERR_METHOD_NOT_IMPLEMENTED, Ve = Ee.ERR_MULTIPLE_CALLBACK, ht = Ee.ERR_STREAM_CANNOT_PIPE, vt = Ee.ERR_STREAM_DESTROYED, Pt = Ee.ERR_STREAM_NULL_VALUES, _t = Ee.ERR_STREAM_WRITE_AFTER_END, kt = Ee.ERR_UNKNOWN_ENCODING, Ot = ve.errorOrDestroy;
  requireInherits_browser()(Dt, ne);
  function Ht() {
  }
  function jt(Zt, Wt, Gt) {
    z = z || require_stream_duplex$1(), Zt = Zt || {}, typeof Gt != "boolean" && (Gt = Wt instanceof z), this.objectMode = !!Zt.objectMode, Gt && (this.objectMode = this.objectMode || !!Zt.writableObjectMode), this.highWaterMark = oe(this, Zt, "writableHighWaterMark", Gt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var rr = Zt.decodeStrings === !1;
    this.decodeStrings = !rr, this.defaultEncoding = Zt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(or) {
      bt(Wt, or);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Zt.emitClose !== !1, this.autoDestroy = !!Zt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  jt.prototype.getBuffer = function() {
    for (var Wt = this.bufferedRequest, Gt = []; Wt; )
      Gt.push(Wt), Wt = Wt.next;
    return Gt;
  }, function() {
    try {
      Object.defineProperty(jt.prototype, "buffer", {
        get: Y.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Yt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Yt = Function.prototype[Symbol.hasInstance], Object.defineProperty(Dt, Symbol.hasInstance, {
    value: function(Wt) {
      return Yt.call(this, Wt) ? !0 : this !== Dt ? !1 : Wt && Wt._writableState instanceof jt;
    }
  })) : Yt = function(Wt) {
    return Wt instanceof this;
  };
  function Dt(Zt) {
    z = z || require_stream_duplex$1();
    var Wt = this instanceof z;
    if (!Wt && !Yt.call(Dt, this)) return new Dt(Zt);
    this._writableState = new jt(Zt, this, Wt), this.writable = !0, Zt && (typeof Zt.write == "function" && (this._write = Zt.write), typeof Zt.writev == "function" && (this._writev = Zt.writev), typeof Zt.destroy == "function" && (this._destroy = Zt.destroy), typeof Zt.final == "function" && (this._final = Zt.final)), ne.call(this);
  }
  Dt.prototype.pipe = function() {
    Ot(this, new ht());
  };
  function Ct(Zt, Wt) {
    var Gt = new _t();
    Ot(Zt, Gt), process$1.nextTick(Wt, Gt);
  }
  function Kt(Zt, Wt, Gt, rr) {
    var or;
    return Gt === null ? or = new Pt() : typeof Gt != "string" && !Wt.objectMode && (or = new Ce("chunk", ["string", "Buffer"], Gt)), or ? (Ot(Zt, or), process$1.nextTick(rr, or), !1) : !0;
  }
  Dt.prototype.write = function(Zt, Wt, Gt) {
    var rr = this._writableState, or = !1, Xt = !rr.objectMode && le(Zt);
    return Xt && !ae.isBuffer(Zt) && (Zt = se(Zt)), typeof Wt == "function" && (Gt = Wt, Wt = null), Xt ? Wt = "buffer" : Wt || (Wt = rr.defaultEncoding), typeof Gt != "function" && (Gt = Ht), rr.ending ? Ct(this, Gt) : (Xt || Kt(this, rr, Zt, Gt)) && (rr.pendingcb++, or = Je(this, rr, Xt, Zt, Wt, Gt)), or;
  }, Dt.prototype.cork = function() {
    this._writableState.corked++;
  }, Dt.prototype.uncork = function() {
    var Zt = this._writableState;
    Zt.corked && (Zt.corked--, !Zt.writing && !Zt.corked && !Zt.bufferProcessing && Zt.bufferedRequest && Bt(this, Zt));
  }, Dt.prototype.setDefaultEncoding = function(Wt) {
    if (typeof Wt == "string" && (Wt = Wt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Wt + "").toLowerCase()) > -1)) throw new kt(Wt);
    return this._writableState.defaultEncoding = Wt, this;
  }, Object.defineProperty(Dt.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Nt(Zt, Wt, Gt) {
    return !Zt.objectMode && Zt.decodeStrings !== !1 && typeof Wt == "string" && (Wt = ae.from(Wt, Gt)), Wt;
  }
  Object.defineProperty(Dt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Je(Zt, Wt, Gt, rr, or, Xt) {
    if (!Gt) {
      var zt = Nt(Wt, rr, or);
      rr !== zt && (Gt = !0, or = "buffer", rr = zt);
    }
    var ur = Wt.objectMode ? 1 : rr.length;
    Wt.length += ur;
    var pr = Wt.length < Wt.highWaterMark;
    if (pr || (Wt.needDrain = !0), Wt.writing || Wt.corked) {
      var vr = Wt.lastBufferedRequest;
      Wt.lastBufferedRequest = {
        chunk: rr,
        encoding: or,
        isBuf: Gt,
        callback: Xt,
        next: null
      }, vr ? vr.next = Wt.lastBufferedRequest : Wt.bufferedRequest = Wt.lastBufferedRequest, Wt.bufferedRequestCount += 1;
    } else
      Xe(Zt, Wt, !1, ur, rr, or, Xt);
    return pr;
  }
  function Xe(Zt, Wt, Gt, rr, or, Xt, zt) {
    Wt.writelen = rr, Wt.writecb = zt, Wt.writing = !0, Wt.sync = !0, Wt.destroyed ? Wt.onwrite(new vt("write")) : Gt ? Zt._writev(or, Wt.onwrite) : Zt._write(or, Xt, Wt.onwrite), Wt.sync = !1;
  }
  function Ke(Zt, Wt, Gt, rr, or) {
    --Wt.pendingcb, Gt ? (process$1.nextTick(or, rr), process$1.nextTick(Lt, Zt, Wt), Zt._writableState.errorEmitted = !0, Ot(Zt, rr)) : (or(rr), Zt._writableState.errorEmitted = !0, Ot(Zt, rr), Lt(Zt, Wt));
  }
  function Qe(Zt) {
    Zt.writing = !1, Zt.writecb = null, Zt.length -= Zt.writelen, Zt.writelen = 0;
  }
  function bt(Zt, Wt) {
    var Gt = Zt._writableState, rr = Gt.sync, or = Gt.writecb;
    if (typeof or != "function") throw new Ve();
    if (Qe(Gt), Wt) Ke(Zt, Gt, rr, Wt, or);
    else {
      var Xt = $t(Gt) || Zt.destroyed;
      !Xt && !Gt.corked && !Gt.bufferProcessing && Gt.bufferedRequest && Bt(Zt, Gt), rr ? process$1.nextTick(wt, Zt, Gt, Xt, or) : wt(Zt, Gt, Xt, or);
    }
  }
  function wt(Zt, Wt, Gt, rr) {
    Gt || xt(Zt, Wt), Wt.pendingcb--, rr(), Lt(Zt, Wt);
  }
  function xt(Zt, Wt) {
    Wt.length === 0 && Wt.needDrain && (Wt.needDrain = !1, Zt.emit("drain"));
  }
  function Bt(Zt, Wt) {
    Wt.bufferProcessing = !0;
    var Gt = Wt.bufferedRequest;
    if (Zt._writev && Gt && Gt.next) {
      var rr = Wt.bufferedRequestCount, or = new Array(rr), Xt = Wt.corkedRequestsFree;
      Xt.entry = Gt;
      for (var zt = 0, ur = !0; Gt; )
        or[zt] = Gt, Gt.isBuf || (ur = !1), Gt = Gt.next, zt += 1;
      or.allBuffers = ur, Xe(Zt, Wt, !0, Wt.length, or, "", Xt.finish), Wt.pendingcb++, Wt.lastBufferedRequest = null, Xt.next ? (Wt.corkedRequestsFree = Xt.next, Xt.next = null) : Wt.corkedRequestsFree = new B(Wt), Wt.bufferedRequestCount = 0;
    } else {
      for (; Gt; ) {
        var pr = Gt.chunk, vr = Gt.encoding, _r = Gt.callback, xr = Wt.objectMode ? 1 : pr.length;
        if (Xe(Zt, Wt, !1, xr, pr, vr, _r), Gt = Gt.next, Wt.bufferedRequestCount--, Wt.writing)
          break;
      }
      Gt === null && (Wt.lastBufferedRequest = null);
    }
    Wt.bufferedRequest = Gt, Wt.bufferProcessing = !1;
  }
  Dt.prototype._write = function(Zt, Wt, Gt) {
    Gt(new Pe("_write()"));
  }, Dt.prototype._writev = null, Dt.prototype.end = function(Zt, Wt, Gt) {
    var rr = this._writableState;
    return typeof Zt == "function" ? (Gt = Zt, Zt = null, Wt = null) : typeof Wt == "function" && (Gt = Wt, Wt = null), Zt != null && this.write(Zt, Wt), rr.corked && (rr.corked = 1, this.uncork()), rr.ending || tr(this, rr, Gt), this;
  }, Object.defineProperty(Dt.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function $t(Zt) {
    return Zt.ending && Zt.length === 0 && Zt.bufferedRequest === null && !Zt.finished && !Zt.writing;
  }
  function qt(Zt, Wt) {
    Zt._final(function(Gt) {
      Wt.pendingcb--, Gt && Ot(Zt, Gt), Wt.prefinished = !0, Zt.emit("prefinish"), Lt(Zt, Wt);
    });
  }
  function Rt(Zt, Wt) {
    !Wt.prefinished && !Wt.finalCalled && (typeof Zt._final == "function" && !Wt.destroyed ? (Wt.pendingcb++, Wt.finalCalled = !0, process$1.nextTick(qt, Zt, Wt)) : (Wt.prefinished = !0, Zt.emit("prefinish")));
  }
  function Lt(Zt, Wt) {
    var Gt = $t(Wt);
    if (Gt && (Rt(Zt, Wt), Wt.pendingcb === 0 && (Wt.finished = !0, Zt.emit("finish"), Wt.autoDestroy))) {
      var rr = Zt._readableState;
      (!rr || rr.autoDestroy && rr.endEmitted) && Zt.destroy();
    }
    return Gt;
  }
  function tr(Zt, Wt, Gt) {
    Wt.ending = !0, Lt(Zt, Wt), Gt && (Wt.finished ? process$1.nextTick(Gt) : Zt.once("finish", Gt)), Wt.ended = !0, Zt.writable = !1;
  }
  function sr(Zt, Wt, Gt) {
    var rr = Zt.entry;
    for (Zt.entry = null; rr; ) {
      var or = rr.callback;
      Wt.pendingcb--, or(Gt), rr = rr.next;
    }
    Wt.corkedRequestsFree.next = Zt;
  }
  return Object.defineProperty(Dt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Wt) {
      this._writableState && (this._writableState.destroyed = Wt);
    }
  }), Dt.prototype.destroy = ve.destroy, Dt.prototype._undestroy = ve.undestroy, Dt.prototype._destroy = function(Zt, Wt) {
    Wt(Zt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(ge) {
    var oe = [];
    for (var Ee in ge) oe.push(Ee);
    return oe;
  };
  _stream_duplex$1 = se;
  var z = require_stream_readable$1(), Y = require_stream_writable$1();
  requireInherits_browser()(se, z);
  for (var ne = B(Y.prototype), ae = 0; ae < ne.length; ae++) {
    var ie = ne[ae];
    se.prototype[ie] || (se.prototype[ie] = Y.prototype[ie]);
  }
  function se(ge) {
    if (!(this instanceof se)) return new se(ge);
    z.call(this, ge), Y.call(this, ge), this.allowHalfOpen = !0, ge && (ge.readable === !1 && (this.readable = !1), ge.writable === !1 && (this.writable = !1), ge.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", le)));
  }
  Object.defineProperty(se.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(se.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(se.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function le() {
    this._writableState.ended || process$1.nextTick(ve, this);
  }
  function ve(ge) {
    ge.end();
  }
  return Object.defineProperty(se.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(oe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = oe, this._writableState.destroyed = oe);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var B = safeBufferExports.Buffer, z = B.isEncoding || function(Pt) {
    switch (Pt = "" + Pt, Pt && Pt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function Y(Pt) {
    if (!Pt) return "utf8";
    for (var _t; ; )
      switch (Pt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return Pt;
        default:
          if (_t) return;
          Pt = ("" + Pt).toLowerCase(), _t = !0;
      }
  }
  function ne(Pt) {
    var _t = Y(Pt);
    if (typeof _t != "string" && (B.isEncoding === z || !z(Pt))) throw new Error("Unknown encoding: " + Pt);
    return _t || Pt;
  }
  string_decoder.StringDecoder = ae;
  function ae(Pt) {
    this.encoding = ne(Pt);
    var _t;
    switch (this.encoding) {
      case "utf16le":
        this.text = Ee, this.end = Ce, _t = 4;
        break;
      case "utf8":
        this.fillLast = ve, _t = 4;
        break;
      case "base64":
        this.text = Pe, this.end = Ve, _t = 3;
        break;
      default:
        this.write = ht, this.end = vt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = B.allocUnsafe(_t);
  }
  ae.prototype.write = function(Pt) {
    if (Pt.length === 0) return "";
    var _t, kt;
    if (this.lastNeed) {
      if (_t = this.fillLast(Pt), _t === void 0) return "";
      kt = this.lastNeed, this.lastNeed = 0;
    } else
      kt = 0;
    return kt < Pt.length ? _t ? _t + this.text(Pt, kt) : this.text(Pt, kt) : _t || "";
  }, ae.prototype.end = oe, ae.prototype.text = ge, ae.prototype.fillLast = function(Pt) {
    if (this.lastNeed <= Pt.length)
      return Pt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Pt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Pt.length), this.lastNeed -= Pt.length;
  };
  function ie(Pt) {
    return Pt <= 127 ? 0 : Pt >> 5 === 6 ? 2 : Pt >> 4 === 14 ? 3 : Pt >> 3 === 30 ? 4 : Pt >> 6 === 2 ? -1 : -2;
  }
  function se(Pt, _t, kt) {
    var Ot = _t.length - 1;
    if (Ot < kt) return 0;
    var Ht = ie(_t[Ot]);
    return Ht >= 0 ? (Ht > 0 && (Pt.lastNeed = Ht - 1), Ht) : --Ot < kt || Ht === -2 ? 0 : (Ht = ie(_t[Ot]), Ht >= 0 ? (Ht > 0 && (Pt.lastNeed = Ht - 2), Ht) : --Ot < kt || Ht === -2 ? 0 : (Ht = ie(_t[Ot]), Ht >= 0 ? (Ht > 0 && (Ht === 2 ? Ht = 0 : Pt.lastNeed = Ht - 3), Ht) : 0));
  }
  function le(Pt, _t, kt) {
    if ((_t[0] & 192) !== 128)
      return Pt.lastNeed = 0, "";
    if (Pt.lastNeed > 1 && _t.length > 1) {
      if ((_t[1] & 192) !== 128)
        return Pt.lastNeed = 1, "";
      if (Pt.lastNeed > 2 && _t.length > 2 && (_t[2] & 192) !== 128)
        return Pt.lastNeed = 2, "";
    }
  }
  function ve(Pt) {
    var _t = this.lastTotal - this.lastNeed, kt = le(this, Pt);
    if (kt !== void 0) return kt;
    if (this.lastNeed <= Pt.length)
      return Pt.copy(this.lastChar, _t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Pt.copy(this.lastChar, _t, 0, Pt.length), this.lastNeed -= Pt.length;
  }
  function ge(Pt, _t) {
    var kt = se(this, Pt, _t);
    if (!this.lastNeed) return Pt.toString("utf8", _t);
    this.lastTotal = kt;
    var Ot = Pt.length - (kt - this.lastNeed);
    return Pt.copy(this.lastChar, 0, Ot), Pt.toString("utf8", _t, Ot);
  }
  function oe(Pt) {
    var _t = Pt && Pt.length ? this.write(Pt) : "";
    return this.lastNeed ? _t + "" : _t;
  }
  function Ee(Pt, _t) {
    if ((Pt.length - _t) % 2 === 0) {
      var kt = Pt.toString("utf16le", _t);
      if (kt) {
        var Ot = kt.charCodeAt(kt.length - 1);
        if (Ot >= 55296 && Ot <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Pt[Pt.length - 2], this.lastChar[1] = Pt[Pt.length - 1], kt.slice(0, -1);
      }
      return kt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Pt[Pt.length - 1], Pt.toString("utf16le", _t, Pt.length - 1);
  }
  function Ce(Pt) {
    var _t = Pt && Pt.length ? this.write(Pt) : "";
    if (this.lastNeed) {
      var kt = this.lastTotal - this.lastNeed;
      return _t + this.lastChar.toString("utf16le", 0, kt);
    }
    return _t;
  }
  function Pe(Pt, _t) {
    var kt = (Pt.length - _t) % 3;
    return kt === 0 ? Pt.toString("base64", _t) : (this.lastNeed = 3 - kt, this.lastTotal = 3, kt === 1 ? this.lastChar[0] = Pt[Pt.length - 1] : (this.lastChar[0] = Pt[Pt.length - 2], this.lastChar[1] = Pt[Pt.length - 1]), Pt.toString("base64", _t, Pt.length - kt));
  }
  function Ve(Pt) {
    var _t = Pt && Pt.length ? this.write(Pt) : "";
    return this.lastNeed ? _t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : _t;
  }
  function ht(Pt) {
    return Pt.toString(this.encoding);
  }
  function vt(Pt) {
    return Pt && Pt.length ? this.write(Pt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function z(ie) {
    var se = !1;
    return function() {
      if (!se) {
        se = !0;
        for (var le = arguments.length, ve = new Array(le), ge = 0; ge < le; ge++)
          ve[ge] = arguments[ge];
        ie.apply(this, ve);
      }
    };
  }
  function Y() {
  }
  function ne(ie) {
    return ie.setHeader && typeof ie.abort == "function";
  }
  function ae(ie, se, le) {
    if (typeof se == "function") return ae(ie, null, se);
    se || (se = {}), le = z(le || Y);
    var ve = se.readable || se.readable !== !1 && ie.readable, ge = se.writable || se.writable !== !1 && ie.writable, oe = function() {
      ie.writable || Ce();
    }, Ee = ie._writableState && ie._writableState.finished, Ce = function() {
      ge = !1, Ee = !0, ve || le.call(ie);
    }, Pe = ie._readableState && ie._readableState.endEmitted, Ve = function() {
      ve = !1, Pe = !0, ge || le.call(ie);
    }, ht = function(kt) {
      le.call(ie, kt);
    }, vt = function() {
      var kt;
      if (ve && !Pe)
        return (!ie._readableState || !ie._readableState.ended) && (kt = new B()), le.call(ie, kt);
      if (ge && !Ee)
        return (!ie._writableState || !ie._writableState.ended) && (kt = new B()), le.call(ie, kt);
    }, Pt = function() {
      ie.req.on("finish", Ce);
    };
    return ne(ie) ? (ie.on("complete", Ce), ie.on("abort", vt), ie.req ? Pt() : ie.on("request", Pt)) : ge && !ie._writableState && (ie.on("end", oe), ie.on("close", oe)), ie.on("end", Ve), ie.on("finish", Ce), se.error !== !1 && ie.on("error", ht), ie.on("close", vt), function() {
      ie.removeListener("complete", Ce), ie.removeListener("abort", vt), ie.removeListener("request", Pt), ie.req && ie.req.removeListener("finish", Ce), ie.removeListener("end", oe), ie.removeListener("close", oe), ie.removeListener("finish", Ce), ie.removeListener("end", Ve), ie.removeListener("error", ht), ie.removeListener("close", vt);
    };
  }
  return endOfStream = ae, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function z(kt, Ot, Ht) {
    return Ot = Y(Ot), Ot in kt ? Object.defineProperty(kt, Ot, { value: Ht, enumerable: !0, configurable: !0, writable: !0 }) : kt[Ot] = Ht, kt;
  }
  function Y(kt) {
    var Ot = ne(kt, "string");
    return typeof Ot == "symbol" ? Ot : String(Ot);
  }
  function ne(kt, Ot) {
    if (typeof kt != "object" || kt === null) return kt;
    var Ht = kt[Symbol.toPrimitive];
    if (Ht !== void 0) {
      var jt = Ht.call(kt, Ot);
      if (typeof jt != "object") return jt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ot === "string" ? String : Number)(kt);
  }
  var ae = requireEndOfStream(), ie = Symbol("lastResolve"), se = Symbol("lastReject"), le = Symbol("error"), ve = Symbol("ended"), ge = Symbol("lastPromise"), oe = Symbol("handlePromise"), Ee = Symbol("stream");
  function Ce(kt, Ot) {
    return {
      value: kt,
      done: Ot
    };
  }
  function Pe(kt) {
    var Ot = kt[ie];
    if (Ot !== null) {
      var Ht = kt[Ee].read();
      Ht !== null && (kt[ge] = null, kt[ie] = null, kt[se] = null, Ot(Ce(Ht, !1)));
    }
  }
  function Ve(kt) {
    process$1.nextTick(Pe, kt);
  }
  function ht(kt, Ot) {
    return function(Ht, jt) {
      kt.then(function() {
        if (Ot[ve]) {
          Ht(Ce(void 0, !0));
          return;
        }
        Ot[oe](Ht, jt);
      }, jt);
    };
  }
  var vt = Object.getPrototypeOf(function() {
  }), Pt = Object.setPrototypeOf((B = {
    get stream() {
      return this[Ee];
    },
    next: function() {
      var Ot = this, Ht = this[le];
      if (Ht !== null)
        return Promise.reject(Ht);
      if (this[ve])
        return Promise.resolve(Ce(void 0, !0));
      if (this[Ee].destroyed)
        return new Promise(function(Ct, Kt) {
          process$1.nextTick(function() {
            Ot[le] ? Kt(Ot[le]) : Ct(Ce(void 0, !0));
          });
        });
      var jt = this[ge], Yt;
      if (jt)
        Yt = new Promise(ht(jt, this));
      else {
        var Dt = this[Ee].read();
        if (Dt !== null)
          return Promise.resolve(Ce(Dt, !1));
        Yt = new Promise(this[oe]);
      }
      return this[ge] = Yt, Yt;
    }
  }, z(B, Symbol.asyncIterator, function() {
    return this;
  }), z(B, "return", function() {
    var Ot = this;
    return new Promise(function(Ht, jt) {
      Ot[Ee].destroy(null, function(Yt) {
        if (Yt) {
          jt(Yt);
          return;
        }
        Ht(Ce(void 0, !0));
      });
    });
  }), B), vt), _t = function(Ot) {
    var Ht, jt = Object.create(Pt, (Ht = {}, z(Ht, Ee, {
      value: Ot,
      writable: !0
    }), z(Ht, ie, {
      value: null,
      writable: !0
    }), z(Ht, se, {
      value: null,
      writable: !0
    }), z(Ht, le, {
      value: null,
      writable: !0
    }), z(Ht, ve, {
      value: Ot._readableState.endEmitted,
      writable: !0
    }), z(Ht, oe, {
      value: function(Dt, Ct) {
        var Kt = jt[Ee].read();
        Kt ? (jt[ge] = null, jt[ie] = null, jt[se] = null, Dt(Ce(Kt, !1))) : (jt[ie] = Dt, jt[se] = Ct);
      },
      writable: !0
    }), Ht));
    return jt[ge] = null, ae(Ot, function(Yt) {
      if (Yt && Yt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Dt = jt[se];
        Dt !== null && (jt[ge] = null, jt[ie] = null, jt[se] = null, Dt(Yt)), jt[le] = Yt;
        return;
      }
      var Ct = jt[ie];
      Ct !== null && (jt[ge] = null, jt[ie] = null, jt[se] = null, Ct(Ce(void 0, !0))), jt[ve] = !0;
    }), Ot.on("readable", Ve.bind(null, jt)), jt;
  };
  return async_iterator = _t, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Ct;
  var B;
  Ct.ReadableState = Dt, requireEvents().EventEmitter;
  var z = function(zt, ur) {
    return zt.listeners(ur).length;
  }, Y = requireStreamBrowser$1(), ne = require$$0$1.Buffer, ae = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ie(Xt) {
    return ne.from(Xt);
  }
  function se(Xt) {
    return ne.isBuffer(Xt) || Xt instanceof ae;
  }
  var le = requireUtil$1(), ve;
  le && le.debuglog ? ve = le.debuglog("stream") : ve = function() {
  };
  var ge = requireBuffer_list(), oe = requireDestroy$1(), Ee = requireState(), Ce = Ee.getHighWaterMark, Pe = requireErrorsBrowser().codes, Ve = Pe.ERR_INVALID_ARG_TYPE, ht = Pe.ERR_STREAM_PUSH_AFTER_EOF, vt = Pe.ERR_METHOD_NOT_IMPLEMENTED, Pt = Pe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, _t, kt, Ot;
  requireInherits_browser()(Ct, Y);
  var Ht = oe.errorOrDestroy, jt = ["error", "close", "destroy", "pause", "resume"];
  function Yt(Xt, zt, ur) {
    if (typeof Xt.prependListener == "function") return Xt.prependListener(zt, ur);
    !Xt._events || !Xt._events[zt] ? Xt.on(zt, ur) : Array.isArray(Xt._events[zt]) ? Xt._events[zt].unshift(ur) : Xt._events[zt] = [ur, Xt._events[zt]];
  }
  function Dt(Xt, zt, ur) {
    B = B || require_stream_duplex$1(), Xt = Xt || {}, typeof ur != "boolean" && (ur = zt instanceof B), this.objectMode = !!Xt.objectMode, ur && (this.objectMode = this.objectMode || !!Xt.readableObjectMode), this.highWaterMark = Ce(this, Xt, "readableHighWaterMark", ur), this.buffer = new ge(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Xt.emitClose !== !1, this.autoDestroy = !!Xt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Xt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Xt.encoding && (_t || (_t = requireString_decoder().StringDecoder), this.decoder = new _t(Xt.encoding), this.encoding = Xt.encoding);
  }
  function Ct(Xt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof Ct)) return new Ct(Xt);
    var zt = this instanceof B;
    this._readableState = new Dt(Xt, this, zt), this.readable = !0, Xt && (typeof Xt.read == "function" && (this._read = Xt.read), typeof Xt.destroy == "function" && (this._destroy = Xt.destroy)), Y.call(this);
  }
  Object.defineProperty(Ct.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(zt) {
      this._readableState && (this._readableState.destroyed = zt);
    }
  }), Ct.prototype.destroy = oe.destroy, Ct.prototype._undestroy = oe.undestroy, Ct.prototype._destroy = function(Xt, zt) {
    zt(Xt);
  }, Ct.prototype.push = function(Xt, zt) {
    var ur = this._readableState, pr;
    return ur.objectMode ? pr = !0 : typeof Xt == "string" && (zt = zt || ur.defaultEncoding, zt !== ur.encoding && (Xt = ne.from(Xt, zt), zt = ""), pr = !0), Kt(this, Xt, zt, !1, pr);
  }, Ct.prototype.unshift = function(Xt) {
    return Kt(this, Xt, null, !0, !1);
  };
  function Kt(Xt, zt, ur, pr, vr) {
    ve("readableAddChunk", zt);
    var _r = Xt._readableState;
    if (zt === null)
      _r.reading = !1, bt(Xt, _r);
    else {
      var xr;
      if (vr || (xr = Je(_r, zt)), xr)
        Ht(Xt, xr);
      else if (_r.objectMode || zt && zt.length > 0)
        if (typeof zt != "string" && !_r.objectMode && Object.getPrototypeOf(zt) !== ne.prototype && (zt = ie(zt)), pr)
          _r.endEmitted ? Ht(Xt, new Pt()) : Nt(Xt, _r, zt, !0);
        else if (_r.ended)
          Ht(Xt, new ht());
        else {
          if (_r.destroyed)
            return !1;
          _r.reading = !1, _r.decoder && !ur ? (zt = _r.decoder.write(zt), _r.objectMode || zt.length !== 0 ? Nt(Xt, _r, zt, !1) : Bt(Xt, _r)) : Nt(Xt, _r, zt, !1);
        }
      else pr || (_r.reading = !1, Bt(Xt, _r));
    }
    return !_r.ended && (_r.length < _r.highWaterMark || _r.length === 0);
  }
  function Nt(Xt, zt, ur, pr) {
    zt.flowing && zt.length === 0 && !zt.sync ? (zt.awaitDrain = 0, Xt.emit("data", ur)) : (zt.length += zt.objectMode ? 1 : ur.length, pr ? zt.buffer.unshift(ur) : zt.buffer.push(ur), zt.needReadable && wt(Xt)), Bt(Xt, zt);
  }
  function Je(Xt, zt) {
    var ur;
    return !se(zt) && typeof zt != "string" && zt !== void 0 && !Xt.objectMode && (ur = new Ve("chunk", ["string", "Buffer", "Uint8Array"], zt)), ur;
  }
  Ct.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ct.prototype.setEncoding = function(Xt) {
    _t || (_t = requireString_decoder().StringDecoder);
    var zt = new _t(Xt);
    this._readableState.decoder = zt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ur = this._readableState.buffer.head, pr = ""; ur !== null; )
      pr += zt.write(ur.data), ur = ur.next;
    return this._readableState.buffer.clear(), pr !== "" && this._readableState.buffer.push(pr), this._readableState.length = pr.length, this;
  };
  var Xe = 1073741824;
  function Ke(Xt) {
    return Xt >= Xe ? Xt = Xe : (Xt--, Xt |= Xt >>> 1, Xt |= Xt >>> 2, Xt |= Xt >>> 4, Xt |= Xt >>> 8, Xt |= Xt >>> 16, Xt++), Xt;
  }
  function Qe(Xt, zt) {
    return Xt <= 0 || zt.length === 0 && zt.ended ? 0 : zt.objectMode ? 1 : Xt !== Xt ? zt.flowing && zt.length ? zt.buffer.head.data.length : zt.length : (Xt > zt.highWaterMark && (zt.highWaterMark = Ke(Xt)), Xt <= zt.length ? Xt : zt.ended ? zt.length : (zt.needReadable = !0, 0));
  }
  Ct.prototype.read = function(Xt) {
    ve("read", Xt), Xt = parseInt(Xt, 10);
    var zt = this._readableState, ur = Xt;
    if (Xt !== 0 && (zt.emittedReadable = !1), Xt === 0 && zt.needReadable && ((zt.highWaterMark !== 0 ? zt.length >= zt.highWaterMark : zt.length > 0) || zt.ended))
      return ve("read: emitReadable", zt.length, zt.ended), zt.length === 0 && zt.ended ? Gt(this) : wt(this), null;
    if (Xt = Qe(Xt, zt), Xt === 0 && zt.ended)
      return zt.length === 0 && Gt(this), null;
    var pr = zt.needReadable;
    ve("need readable", pr), (zt.length === 0 || zt.length - Xt < zt.highWaterMark) && (pr = !0, ve("length less than watermark", pr)), zt.ended || zt.reading ? (pr = !1, ve("reading or ended", pr)) : pr && (ve("do read"), zt.reading = !0, zt.sync = !0, zt.length === 0 && (zt.needReadable = !0), this._read(zt.highWaterMark), zt.sync = !1, zt.reading || (Xt = Qe(ur, zt)));
    var vr;
    return Xt > 0 ? vr = Wt(Xt, zt) : vr = null, vr === null ? (zt.needReadable = zt.length <= zt.highWaterMark, Xt = 0) : (zt.length -= Xt, zt.awaitDrain = 0), zt.length === 0 && (zt.ended || (zt.needReadable = !0), ur !== Xt && zt.ended && Gt(this)), vr !== null && this.emit("data", vr), vr;
  };
  function bt(Xt, zt) {
    if (ve("onEofChunk"), !zt.ended) {
      if (zt.decoder) {
        var ur = zt.decoder.end();
        ur && ur.length && (zt.buffer.push(ur), zt.length += zt.objectMode ? 1 : ur.length);
      }
      zt.ended = !0, zt.sync ? wt(Xt) : (zt.needReadable = !1, zt.emittedReadable || (zt.emittedReadable = !0, xt(Xt)));
    }
  }
  function wt(Xt) {
    var zt = Xt._readableState;
    ve("emitReadable", zt.needReadable, zt.emittedReadable), zt.needReadable = !1, zt.emittedReadable || (ve("emitReadable", zt.flowing), zt.emittedReadable = !0, process$1.nextTick(xt, Xt));
  }
  function xt(Xt) {
    var zt = Xt._readableState;
    ve("emitReadable_", zt.destroyed, zt.length, zt.ended), !zt.destroyed && (zt.length || zt.ended) && (Xt.emit("readable"), zt.emittedReadable = !1), zt.needReadable = !zt.flowing && !zt.ended && zt.length <= zt.highWaterMark, Zt(Xt);
  }
  function Bt(Xt, zt) {
    zt.readingMore || (zt.readingMore = !0, process$1.nextTick($t, Xt, zt));
  }
  function $t(Xt, zt) {
    for (; !zt.reading && !zt.ended && (zt.length < zt.highWaterMark || zt.flowing && zt.length === 0); ) {
      var ur = zt.length;
      if (ve("maybeReadMore read 0"), Xt.read(0), ur === zt.length)
        break;
    }
    zt.readingMore = !1;
  }
  Ct.prototype._read = function(Xt) {
    Ht(this, new vt("_read()"));
  }, Ct.prototype.pipe = function(Xt, zt) {
    var ur = this, pr = this._readableState;
    switch (pr.pipesCount) {
      case 0:
        pr.pipes = Xt;
        break;
      case 1:
        pr.pipes = [pr.pipes, Xt];
        break;
      default:
        pr.pipes.push(Xt);
        break;
    }
    pr.pipesCount += 1, ve("pipe count=%d opts=%j", pr.pipesCount, zt);
    var vr = (!zt || zt.end !== !1) && Xt !== process$1.stdout && Xt !== process$1.stderr, _r = vr ? Tr : Xr;
    pr.endEmitted ? process$1.nextTick(_r) : ur.once("end", _r), Xt.on("unpipe", xr);
    function xr(qr, zr) {
      ve("onunpipe"), qr === ur && zr && zr.hasUnpiped === !1 && (zr.hasUnpiped = !0, $r());
    }
    function Tr() {
      ve("onend"), Xt.end();
    }
    var hr = qt(ur);
    Xt.on("drain", hr);
    var Wr = !1;
    function $r() {
      ve("cleanup"), Xt.removeListener("close", Rr), Xt.removeListener("finish", Hr), Xt.removeListener("drain", hr), Xt.removeListener("error", Gr), Xt.removeListener("unpipe", xr), ur.removeListener("end", Tr), ur.removeListener("end", Xr), ur.removeListener("data", Ur), Wr = !0, pr.awaitDrain && (!Xt._writableState || Xt._writableState.needDrain) && hr();
    }
    ur.on("data", Ur);
    function Ur(qr) {
      ve("ondata");
      var zr = Xt.write(qr);
      ve("dest.write", zr), zr === !1 && ((pr.pipesCount === 1 && pr.pipes === Xt || pr.pipesCount > 1 && or(pr.pipes, Xt) !== -1) && !Wr && (ve("false write response, pause", pr.awaitDrain), pr.awaitDrain++), ur.pause());
    }
    function Gr(qr) {
      ve("onerror", qr), Xr(), Xt.removeListener("error", Gr), z(Xt, "error") === 0 && Ht(Xt, qr);
    }
    Yt(Xt, "error", Gr);
    function Rr() {
      Xt.removeListener("finish", Hr), Xr();
    }
    Xt.once("close", Rr);
    function Hr() {
      ve("onfinish"), Xt.removeListener("close", Rr), Xr();
    }
    Xt.once("finish", Hr);
    function Xr() {
      ve("unpipe"), ur.unpipe(Xt);
    }
    return Xt.emit("pipe", ur), pr.flowing || (ve("pipe resume"), ur.resume()), Xt;
  };
  function qt(Xt) {
    return function() {
      var ur = Xt._readableState;
      ve("pipeOnDrain", ur.awaitDrain), ur.awaitDrain && ur.awaitDrain--, ur.awaitDrain === 0 && z(Xt, "data") && (ur.flowing = !0, Zt(Xt));
    };
  }
  Ct.prototype.unpipe = function(Xt) {
    var zt = this._readableState, ur = {
      hasUnpiped: !1
    };
    if (zt.pipesCount === 0) return this;
    if (zt.pipesCount === 1)
      return Xt && Xt !== zt.pipes ? this : (Xt || (Xt = zt.pipes), zt.pipes = null, zt.pipesCount = 0, zt.flowing = !1, Xt && Xt.emit("unpipe", this, ur), this);
    if (!Xt) {
      var pr = zt.pipes, vr = zt.pipesCount;
      zt.pipes = null, zt.pipesCount = 0, zt.flowing = !1;
      for (var _r = 0; _r < vr; _r++) pr[_r].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var xr = or(zt.pipes, Xt);
    return xr === -1 ? this : (zt.pipes.splice(xr, 1), zt.pipesCount -= 1, zt.pipesCount === 1 && (zt.pipes = zt.pipes[0]), Xt.emit("unpipe", this, ur), this);
  }, Ct.prototype.on = function(Xt, zt) {
    var ur = Y.prototype.on.call(this, Xt, zt), pr = this._readableState;
    return Xt === "data" ? (pr.readableListening = this.listenerCount("readable") > 0, pr.flowing !== !1 && this.resume()) : Xt === "readable" && !pr.endEmitted && !pr.readableListening && (pr.readableListening = pr.needReadable = !0, pr.flowing = !1, pr.emittedReadable = !1, ve("on readable", pr.length, pr.reading), pr.length ? wt(this) : pr.reading || process$1.nextTick(Lt, this)), ur;
  }, Ct.prototype.addListener = Ct.prototype.on, Ct.prototype.removeListener = function(Xt, zt) {
    var ur = Y.prototype.removeListener.call(this, Xt, zt);
    return Xt === "readable" && process$1.nextTick(Rt, this), ur;
  }, Ct.prototype.removeAllListeners = function(Xt) {
    var zt = Y.prototype.removeAllListeners.apply(this, arguments);
    return (Xt === "readable" || Xt === void 0) && process$1.nextTick(Rt, this), zt;
  };
  function Rt(Xt) {
    var zt = Xt._readableState;
    zt.readableListening = Xt.listenerCount("readable") > 0, zt.resumeScheduled && !zt.paused ? zt.flowing = !0 : Xt.listenerCount("data") > 0 && Xt.resume();
  }
  function Lt(Xt) {
    ve("readable nexttick read 0"), Xt.read(0);
  }
  Ct.prototype.resume = function() {
    var Xt = this._readableState;
    return Xt.flowing || (ve("resume"), Xt.flowing = !Xt.readableListening, tr(this, Xt)), Xt.paused = !1, this;
  };
  function tr(Xt, zt) {
    zt.resumeScheduled || (zt.resumeScheduled = !0, process$1.nextTick(sr, Xt, zt));
  }
  function sr(Xt, zt) {
    ve("resume", zt.reading), zt.reading || Xt.read(0), zt.resumeScheduled = !1, Xt.emit("resume"), Zt(Xt), zt.flowing && !zt.reading && Xt.read(0);
  }
  Ct.prototype.pause = function() {
    return ve("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ve("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Zt(Xt) {
    var zt = Xt._readableState;
    for (ve("flow", zt.flowing); zt.flowing && Xt.read() !== null; ) ;
  }
  Ct.prototype.wrap = function(Xt) {
    var zt = this, ur = this._readableState, pr = !1;
    Xt.on("end", function() {
      if (ve("wrapped end"), ur.decoder && !ur.ended) {
        var xr = ur.decoder.end();
        xr && xr.length && zt.push(xr);
      }
      zt.push(null);
    }), Xt.on("data", function(xr) {
      if (ve("wrapped data"), ur.decoder && (xr = ur.decoder.write(xr)), !(ur.objectMode && xr == null) && !(!ur.objectMode && (!xr || !xr.length))) {
        var Tr = zt.push(xr);
        Tr || (pr = !0, Xt.pause());
      }
    });
    for (var vr in Xt)
      this[vr] === void 0 && typeof Xt[vr] == "function" && (this[vr] = /* @__PURE__ */ function(Tr) {
        return function() {
          return Xt[Tr].apply(Xt, arguments);
        };
      }(vr));
    for (var _r = 0; _r < jt.length; _r++)
      Xt.on(jt[_r], this.emit.bind(this, jt[_r]));
    return this._read = function(xr) {
      ve("wrapped _read", xr), pr && (pr = !1, Xt.resume());
    }, this;
  }, typeof Symbol == "function" && (Ct.prototype[Symbol.asyncIterator] = function() {
    return kt === void 0 && (kt = requireAsync_iterator()), kt(this);
  }), Object.defineProperty(Ct.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Ct.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Ct.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(zt) {
      this._readableState && (this._readableState.flowing = zt);
    }
  }), Ct._fromList = Wt, Object.defineProperty(Ct.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Wt(Xt, zt) {
    if (zt.length === 0) return null;
    var ur;
    return zt.objectMode ? ur = zt.buffer.shift() : !Xt || Xt >= zt.length ? (zt.decoder ? ur = zt.buffer.join("") : zt.buffer.length === 1 ? ur = zt.buffer.first() : ur = zt.buffer.concat(zt.length), zt.buffer.clear()) : ur = zt.buffer.consume(Xt, zt.decoder), ur;
  }
  function Gt(Xt) {
    var zt = Xt._readableState;
    ve("endReadable", zt.endEmitted), zt.endEmitted || (zt.ended = !0, process$1.nextTick(rr, zt, Xt));
  }
  function rr(Xt, zt) {
    if (ve("endReadableNT", Xt.endEmitted, Xt.length), !Xt.endEmitted && Xt.length === 0 && (Xt.endEmitted = !0, zt.readable = !1, zt.emit("end"), Xt.autoDestroy)) {
      var ur = zt._writableState;
      (!ur || ur.autoDestroy && ur.finished) && zt.destroy();
    }
  }
  typeof Symbol == "function" && (Ct.from = function(Xt, zt) {
    return Ot === void 0 && (Ot = requireFromBrowser()), Ot(Ct, Xt, zt);
  });
  function or(Xt, zt) {
    for (var ur = 0, pr = Xt.length; ur < pr; ur++)
      if (Xt[ur] === zt) return ur;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = le;
  var B = requireErrorsBrowser().codes, z = B.ERR_METHOD_NOT_IMPLEMENTED, Y = B.ERR_MULTIPLE_CALLBACK, ne = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, ae = B.ERR_TRANSFORM_WITH_LENGTH_0, ie = require_stream_duplex$1();
  requireInherits_browser()(le, ie);
  function se(oe, Ee) {
    var Ce = this._transformState;
    Ce.transforming = !1;
    var Pe = Ce.writecb;
    if (Pe === null)
      return this.emit("error", new Y());
    Ce.writechunk = null, Ce.writecb = null, Ee != null && this.push(Ee), Pe(oe);
    var Ve = this._readableState;
    Ve.reading = !1, (Ve.needReadable || Ve.length < Ve.highWaterMark) && this._read(Ve.highWaterMark);
  }
  function le(oe) {
    if (!(this instanceof le)) return new le(oe);
    ie.call(this, oe), this._transformState = {
      afterTransform: se.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, oe && (typeof oe.transform == "function" && (this._transform = oe.transform), typeof oe.flush == "function" && (this._flush = oe.flush)), this.on("prefinish", ve);
  }
  function ve() {
    var oe = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Ee, Ce) {
      ge(oe, Ee, Ce);
    }) : ge(this, null, null);
  }
  le.prototype.push = function(oe, Ee) {
    return this._transformState.needTransform = !1, ie.prototype.push.call(this, oe, Ee);
  }, le.prototype._transform = function(oe, Ee, Ce) {
    Ce(new z("_transform()"));
  }, le.prototype._write = function(oe, Ee, Ce) {
    var Pe = this._transformState;
    if (Pe.writecb = Ce, Pe.writechunk = oe, Pe.writeencoding = Ee, !Pe.transforming) {
      var Ve = this._readableState;
      (Pe.needTransform || Ve.needReadable || Ve.length < Ve.highWaterMark) && this._read(Ve.highWaterMark);
    }
  }, le.prototype._read = function(oe) {
    var Ee = this._transformState;
    Ee.writechunk !== null && !Ee.transforming ? (Ee.transforming = !0, this._transform(Ee.writechunk, Ee.writeencoding, Ee.afterTransform)) : Ee.needTransform = !0;
  }, le.prototype._destroy = function(oe, Ee) {
    ie.prototype._destroy.call(this, oe, function(Ce) {
      Ee(Ce);
    });
  };
  function ge(oe, Ee, Ce) {
    if (Ee) return oe.emit("error", Ee);
    if (Ce != null && oe.push(Ce), oe._writableState.length) throw new ae();
    if (oe._transformState.transforming) throw new ne();
    return oe.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = z;
  var B = require_stream_transform$1();
  requireInherits_browser()(z, B);
  function z(Y) {
    if (!(this instanceof z)) return new z(Y);
    B.call(this, Y);
  }
  return z.prototype._transform = function(Y, ne, ae) {
    ae(null, Y);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var B;
  function z(Ce) {
    var Pe = !1;
    return function() {
      Pe || (Pe = !0, Ce.apply(void 0, arguments));
    };
  }
  var Y = requireErrorsBrowser().codes, ne = Y.ERR_MISSING_ARGS, ae = Y.ERR_STREAM_DESTROYED;
  function ie(Ce) {
    if (Ce) throw Ce;
  }
  function se(Ce) {
    return Ce.setHeader && typeof Ce.abort == "function";
  }
  function le(Ce, Pe, Ve, ht) {
    ht = z(ht);
    var vt = !1;
    Ce.on("close", function() {
      vt = !0;
    }), B === void 0 && (B = requireEndOfStream()), B(Ce, {
      readable: Pe,
      writable: Ve
    }, function(_t) {
      if (_t) return ht(_t);
      vt = !0, ht();
    });
    var Pt = !1;
    return function(_t) {
      if (!vt && !Pt) {
        if (Pt = !0, se(Ce)) return Ce.abort();
        if (typeof Ce.destroy == "function") return Ce.destroy();
        ht(_t || new ae("pipe"));
      }
    };
  }
  function ve(Ce) {
    Ce();
  }
  function ge(Ce, Pe) {
    return Ce.pipe(Pe);
  }
  function oe(Ce) {
    return !Ce.length || typeof Ce[Ce.length - 1] != "function" ? ie : Ce.pop();
  }
  function Ee() {
    for (var Ce = arguments.length, Pe = new Array(Ce), Ve = 0; Ve < Ce; Ve++)
      Pe[Ve] = arguments[Ve];
    var ht = oe(Pe);
    if (Array.isArray(Pe[0]) && (Pe = Pe[0]), Pe.length < 2)
      throw new ne("streams");
    var vt, Pt = Pe.map(function(_t, kt) {
      var Ot = kt < Pe.length - 1, Ht = kt > 0;
      return le(_t, Ot, Ht, function(jt) {
        vt || (vt = jt), jt && Pt.forEach(ve), !Ot && (Pt.forEach(ve), ht(vt));
      });
    });
    return Pe.reduce(ge);
  }
  return pipeline_1 = Ee, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(B, z) {
    z = B.exports = require_stream_readable$1(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable$1(), z.Duplex = require_stream_duplex$1(), z.Transform = require_stream_transform$1(), z.PassThrough = require_stream_passthrough$1(), z.finished = requireEndOfStream(), z.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var B = safeBufferExports.Buffer, z = requireReadableBrowser$1().Transform, Y = requireInherits_browser();
  function ne(ie, se) {
    if (!B.isBuffer(ie) && typeof ie != "string")
      throw new TypeError(se + " must be a string or a buffer");
  }
  function ae(ie) {
    z.call(this), this._block = B.allocUnsafe(ie), this._blockSize = ie, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Y(ae, z), ae.prototype._transform = function(ie, se, le) {
    var ve = null;
    try {
      this.update(ie, se);
    } catch (ge) {
      ve = ge;
    }
    le(ve);
  }, ae.prototype._flush = function(ie) {
    var se = null;
    try {
      this.push(this.digest());
    } catch (le) {
      se = le;
    }
    ie(se);
  }, ae.prototype.update = function(ie, se) {
    if (ne(ie, "Data"), this._finalized) throw new Error("Digest already called");
    B.isBuffer(ie) || (ie = B.from(ie, se));
    for (var le = this._block, ve = 0; this._blockOffset + ie.length - ve >= this._blockSize; ) {
      for (var ge = this._blockOffset; ge < this._blockSize; ) le[ge++] = ie[ve++];
      this._update(), this._blockOffset = 0;
    }
    for (; ve < ie.length; ) le[this._blockOffset++] = ie[ve++];
    for (var oe = 0, Ee = ie.length * 8; Ee > 0; ++oe)
      this._length[oe] += Ee, Ee = this._length[oe] / 4294967296 | 0, Ee > 0 && (this._length[oe] -= 4294967296 * Ee);
    return this;
  }, ae.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, ae.prototype.digest = function(ie) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var se = this._digest();
    ie !== void 0 && (se = se.toString(ie)), this._block.fill(0), this._blockOffset = 0;
    for (var le = 0; le < 4; ++le) this._length[le] = 0;
    return se;
  }, ae.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = ae, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var B = requireInherits_browser(), z = requireHashBase(), Y = safeBufferExports.Buffer, ne = new Array(16);
  function ae() {
    z.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  B(ae, z), ae.prototype._update = function() {
    for (var oe = ne, Ee = 0; Ee < 16; ++Ee) oe[Ee] = this._block.readInt32LE(Ee * 4);
    var Ce = this._a, Pe = this._b, Ve = this._c, ht = this._d;
    Ce = se(Ce, Pe, Ve, ht, oe[0], 3614090360, 7), ht = se(ht, Ce, Pe, Ve, oe[1], 3905402710, 12), Ve = se(Ve, ht, Ce, Pe, oe[2], 606105819, 17), Pe = se(Pe, Ve, ht, Ce, oe[3], 3250441966, 22), Ce = se(Ce, Pe, Ve, ht, oe[4], 4118548399, 7), ht = se(ht, Ce, Pe, Ve, oe[5], 1200080426, 12), Ve = se(Ve, ht, Ce, Pe, oe[6], 2821735955, 17), Pe = se(Pe, Ve, ht, Ce, oe[7], 4249261313, 22), Ce = se(Ce, Pe, Ve, ht, oe[8], 1770035416, 7), ht = se(ht, Ce, Pe, Ve, oe[9], 2336552879, 12), Ve = se(Ve, ht, Ce, Pe, oe[10], 4294925233, 17), Pe = se(Pe, Ve, ht, Ce, oe[11], 2304563134, 22), Ce = se(Ce, Pe, Ve, ht, oe[12], 1804603682, 7), ht = se(ht, Ce, Pe, Ve, oe[13], 4254626195, 12), Ve = se(Ve, ht, Ce, Pe, oe[14], 2792965006, 17), Pe = se(Pe, Ve, ht, Ce, oe[15], 1236535329, 22), Ce = le(Ce, Pe, Ve, ht, oe[1], 4129170786, 5), ht = le(ht, Ce, Pe, Ve, oe[6], 3225465664, 9), Ve = le(Ve, ht, Ce, Pe, oe[11], 643717713, 14), Pe = le(Pe, Ve, ht, Ce, oe[0], 3921069994, 20), Ce = le(Ce, Pe, Ve, ht, oe[5], 3593408605, 5), ht = le(ht, Ce, Pe, Ve, oe[10], 38016083, 9), Ve = le(Ve, ht, Ce, Pe, oe[15], 3634488961, 14), Pe = le(Pe, Ve, ht, Ce, oe[4], 3889429448, 20), Ce = le(Ce, Pe, Ve, ht, oe[9], 568446438, 5), ht = le(ht, Ce, Pe, Ve, oe[14], 3275163606, 9), Ve = le(Ve, ht, Ce, Pe, oe[3], 4107603335, 14), Pe = le(Pe, Ve, ht, Ce, oe[8], 1163531501, 20), Ce = le(Ce, Pe, Ve, ht, oe[13], 2850285829, 5), ht = le(ht, Ce, Pe, Ve, oe[2], 4243563512, 9), Ve = le(Ve, ht, Ce, Pe, oe[7], 1735328473, 14), Pe = le(Pe, Ve, ht, Ce, oe[12], 2368359562, 20), Ce = ve(Ce, Pe, Ve, ht, oe[5], 4294588738, 4), ht = ve(ht, Ce, Pe, Ve, oe[8], 2272392833, 11), Ve = ve(Ve, ht, Ce, Pe, oe[11], 1839030562, 16), Pe = ve(Pe, Ve, ht, Ce, oe[14], 4259657740, 23), Ce = ve(Ce, Pe, Ve, ht, oe[1], 2763975236, 4), ht = ve(ht, Ce, Pe, Ve, oe[4], 1272893353, 11), Ve = ve(Ve, ht, Ce, Pe, oe[7], 4139469664, 16), Pe = ve(Pe, Ve, ht, Ce, oe[10], 3200236656, 23), Ce = ve(Ce, Pe, Ve, ht, oe[13], 681279174, 4), ht = ve(ht, Ce, Pe, Ve, oe[0], 3936430074, 11), Ve = ve(Ve, ht, Ce, Pe, oe[3], 3572445317, 16), Pe = ve(Pe, Ve, ht, Ce, oe[6], 76029189, 23), Ce = ve(Ce, Pe, Ve, ht, oe[9], 3654602809, 4), ht = ve(ht, Ce, Pe, Ve, oe[12], 3873151461, 11), Ve = ve(Ve, ht, Ce, Pe, oe[15], 530742520, 16), Pe = ve(Pe, Ve, ht, Ce, oe[2], 3299628645, 23), Ce = ge(Ce, Pe, Ve, ht, oe[0], 4096336452, 6), ht = ge(ht, Ce, Pe, Ve, oe[7], 1126891415, 10), Ve = ge(Ve, ht, Ce, Pe, oe[14], 2878612391, 15), Pe = ge(Pe, Ve, ht, Ce, oe[5], 4237533241, 21), Ce = ge(Ce, Pe, Ve, ht, oe[12], 1700485571, 6), ht = ge(ht, Ce, Pe, Ve, oe[3], 2399980690, 10), Ve = ge(Ve, ht, Ce, Pe, oe[10], 4293915773, 15), Pe = ge(Pe, Ve, ht, Ce, oe[1], 2240044497, 21), Ce = ge(Ce, Pe, Ve, ht, oe[8], 1873313359, 6), ht = ge(ht, Ce, Pe, Ve, oe[15], 4264355552, 10), Ve = ge(Ve, ht, Ce, Pe, oe[6], 2734768916, 15), Pe = ge(Pe, Ve, ht, Ce, oe[13], 1309151649, 21), Ce = ge(Ce, Pe, Ve, ht, oe[4], 4149444226, 6), ht = ge(ht, Ce, Pe, Ve, oe[11], 3174756917, 10), Ve = ge(Ve, ht, Ce, Pe, oe[2], 718787259, 15), Pe = ge(Pe, Ve, ht, Ce, oe[9], 3951481745, 21), this._a = this._a + Ce | 0, this._b = this._b + Pe | 0, this._c = this._c + Ve | 0, this._d = this._d + ht | 0;
  }, ae.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var oe = Y.allocUnsafe(16);
    return oe.writeInt32LE(this._a, 0), oe.writeInt32LE(this._b, 4), oe.writeInt32LE(this._c, 8), oe.writeInt32LE(this._d, 12), oe;
  };
  function ie(oe, Ee) {
    return oe << Ee | oe >>> 32 - Ee;
  }
  function se(oe, Ee, Ce, Pe, Ve, ht, vt) {
    return ie(oe + (Ee & Ce | ~Ee & Pe) + Ve + ht | 0, vt) + Ee | 0;
  }
  function le(oe, Ee, Ce, Pe, Ve, ht, vt) {
    return ie(oe + (Ee & Pe | Ce & ~Pe) + Ve + ht | 0, vt) + Ee | 0;
  }
  function ve(oe, Ee, Ce, Pe, Ve, ht, vt) {
    return ie(oe + (Ee ^ Ce ^ Pe) + Ve + ht | 0, vt) + Ee | 0;
  }
  function ge(oe, Ee, Ce, Pe, Ve, ht, vt) {
    return ie(oe + (Ce ^ (Ee | ~Pe)) + Ve + ht | 0, vt) + Ee | 0;
  }
  return md5_js = ae, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var B = require$$0$1.Buffer, z = requireInherits_browser(), Y = requireHashBase(), ne = new Array(16), ae = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ie = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], se = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], le = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ve = [0, 1518500249, 1859775393, 2400959708, 2840853838], ge = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function oe() {
    Y.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  z(oe, Y), oe.prototype._update = function() {
    for (var Pt = ne, _t = 0; _t < 16; ++_t) Pt[_t] = this._block.readInt32LE(_t * 4);
    for (var kt = this._a | 0, Ot = this._b | 0, Ht = this._c | 0, jt = this._d | 0, Yt = this._e | 0, Dt = this._a | 0, Ct = this._b | 0, Kt = this._c | 0, Nt = this._d | 0, Je = this._e | 0, Xe = 0; Xe < 80; Xe += 1) {
      var Ke, Qe;
      Xe < 16 ? (Ke = Ce(kt, Ot, Ht, jt, Yt, Pt[ae[Xe]], ve[0], se[Xe]), Qe = vt(Dt, Ct, Kt, Nt, Je, Pt[ie[Xe]], ge[0], le[Xe])) : Xe < 32 ? (Ke = Pe(kt, Ot, Ht, jt, Yt, Pt[ae[Xe]], ve[1], se[Xe]), Qe = ht(Dt, Ct, Kt, Nt, Je, Pt[ie[Xe]], ge[1], le[Xe])) : Xe < 48 ? (Ke = Ve(kt, Ot, Ht, jt, Yt, Pt[ae[Xe]], ve[2], se[Xe]), Qe = Ve(Dt, Ct, Kt, Nt, Je, Pt[ie[Xe]], ge[2], le[Xe])) : Xe < 64 ? (Ke = ht(kt, Ot, Ht, jt, Yt, Pt[ae[Xe]], ve[3], se[Xe]), Qe = Pe(Dt, Ct, Kt, Nt, Je, Pt[ie[Xe]], ge[3], le[Xe])) : (Ke = vt(kt, Ot, Ht, jt, Yt, Pt[ae[Xe]], ve[4], se[Xe]), Qe = Ce(Dt, Ct, Kt, Nt, Je, Pt[ie[Xe]], ge[4], le[Xe])), kt = Yt, Yt = jt, jt = Ee(Ht, 10), Ht = Ot, Ot = Ke, Dt = Je, Je = Nt, Nt = Ee(Kt, 10), Kt = Ct, Ct = Qe;
    }
    var bt = this._b + Ht + Nt | 0;
    this._b = this._c + jt + Je | 0, this._c = this._d + Yt + Dt | 0, this._d = this._e + kt + Ct | 0, this._e = this._a + Ot + Kt | 0, this._a = bt;
  }, oe.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Pt = B.alloc ? B.alloc(20) : new B(20);
    return Pt.writeInt32LE(this._a, 0), Pt.writeInt32LE(this._b, 4), Pt.writeInt32LE(this._c, 8), Pt.writeInt32LE(this._d, 12), Pt.writeInt32LE(this._e, 16), Pt;
  };
  function Ee(Pt, _t) {
    return Pt << _t | Pt >>> 32 - _t;
  }
  function Ce(Pt, _t, kt, Ot, Ht, jt, Yt, Dt) {
    return Ee(Pt + (_t ^ kt ^ Ot) + jt + Yt | 0, Dt) + Ht | 0;
  }
  function Pe(Pt, _t, kt, Ot, Ht, jt, Yt, Dt) {
    return Ee(Pt + (_t & kt | ~_t & Ot) + jt + Yt | 0, Dt) + Ht | 0;
  }
  function Ve(Pt, _t, kt, Ot, Ht, jt, Yt, Dt) {
    return Ee(Pt + ((_t | ~kt) ^ Ot) + jt + Yt | 0, Dt) + Ht | 0;
  }
  function ht(Pt, _t, kt, Ot, Ht, jt, Yt, Dt) {
    return Ee(Pt + (_t & Ot | kt & ~Ot) + jt + Yt | 0, Dt) + Ht | 0;
  }
  function vt(Pt, _t, kt, Ot, Ht, jt, Yt, Dt) {
    return Ee(Pt + (_t ^ (kt | ~Ot)) + jt + Yt | 0, Dt) + Ht | 0;
  }
  return ripemd160$1 = oe, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var B = safeBufferExports.Buffer;
  function z(Y, ne) {
    this._block = B.alloc(Y), this._finalSize = ne, this._blockSize = Y, this._len = 0;
  }
  return z.prototype.update = function(Y, ne) {
    typeof Y == "string" && (ne = ne || "utf8", Y = B.from(Y, ne));
    for (var ae = this._block, ie = this._blockSize, se = Y.length, le = this._len, ve = 0; ve < se; ) {
      for (var ge = le % ie, oe = Math.min(se - ve, ie - ge), Ee = 0; Ee < oe; Ee++)
        ae[ge + Ee] = Y[ve + Ee];
      le += oe, ve += oe, le % ie === 0 && this._update(ae);
    }
    return this._len += se, this;
  }, z.prototype.digest = function(Y) {
    var ne = this._len % this._blockSize;
    this._block[ne] = 128, this._block.fill(0, ne + 1), ne >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var ae = this._len * 8;
    if (ae <= 4294967295)
      this._block.writeUInt32BE(ae, this._blockSize - 4);
    else {
      var ie = (ae & 4294967295) >>> 0, se = (ae - ie) / 4294967296;
      this._block.writeUInt32BE(se, this._blockSize - 8), this._block.writeUInt32BE(ie, this._blockSize - 4);
    }
    this._update(this._block);
    var le = this._hash();
    return Y ? le.toString(Y) : le;
  }, z.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = z, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], ae = new Array(80);
  function ie() {
    this.init(), this._w = ae, z.call(this, 64, 56);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function se(ge) {
    return ge << 5 | ge >>> 27;
  }
  function le(ge) {
    return ge << 30 | ge >>> 2;
  }
  function ve(ge, oe, Ee, Ce) {
    return ge === 0 ? oe & Ee | ~oe & Ce : ge === 2 ? oe & Ee | oe & Ce | Ee & Ce : oe ^ Ee ^ Ce;
  }
  return ie.prototype._update = function(ge) {
    for (var oe = this._w, Ee = this._a | 0, Ce = this._b | 0, Pe = this._c | 0, Ve = this._d | 0, ht = this._e | 0, vt = 0; vt < 16; ++vt) oe[vt] = ge.readInt32BE(vt * 4);
    for (; vt < 80; ++vt) oe[vt] = oe[vt - 3] ^ oe[vt - 8] ^ oe[vt - 14] ^ oe[vt - 16];
    for (var Pt = 0; Pt < 80; ++Pt) {
      var _t = ~~(Pt / 20), kt = se(Ee) + ve(_t, Ce, Pe, Ve) + ht + oe[Pt] + ne[_t] | 0;
      ht = Ve, Ve = Pe, Pe = le(Ce), Ce = Ee, Ee = kt;
    }
    this._a = Ee + this._a | 0, this._b = Ce + this._b | 0, this._c = Pe + this._c | 0, this._d = Ve + this._d | 0, this._e = ht + this._e | 0;
  }, ie.prototype._hash = function() {
    var ge = Y.allocUnsafe(20);
    return ge.writeInt32BE(this._a | 0, 0), ge.writeInt32BE(this._b | 0, 4), ge.writeInt32BE(this._c | 0, 8), ge.writeInt32BE(this._d | 0, 12), ge.writeInt32BE(this._e | 0, 16), ge;
  }, sha$1 = ie, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], ae = new Array(80);
  function ie() {
    this.init(), this._w = ae, z.call(this, 64, 56);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function se(oe) {
    return oe << 1 | oe >>> 31;
  }
  function le(oe) {
    return oe << 5 | oe >>> 27;
  }
  function ve(oe) {
    return oe << 30 | oe >>> 2;
  }
  function ge(oe, Ee, Ce, Pe) {
    return oe === 0 ? Ee & Ce | ~Ee & Pe : oe === 2 ? Ee & Ce | Ee & Pe | Ce & Pe : Ee ^ Ce ^ Pe;
  }
  return ie.prototype._update = function(oe) {
    for (var Ee = this._w, Ce = this._a | 0, Pe = this._b | 0, Ve = this._c | 0, ht = this._d | 0, vt = this._e | 0, Pt = 0; Pt < 16; ++Pt) Ee[Pt] = oe.readInt32BE(Pt * 4);
    for (; Pt < 80; ++Pt) Ee[Pt] = se(Ee[Pt - 3] ^ Ee[Pt - 8] ^ Ee[Pt - 14] ^ Ee[Pt - 16]);
    for (var _t = 0; _t < 80; ++_t) {
      var kt = ~~(_t / 20), Ot = le(Ce) + ge(kt, Pe, Ve, ht) + vt + Ee[_t] + ne[kt] | 0;
      vt = ht, ht = Ve, Ve = ve(Pe), Pe = Ce, Ce = Ot;
    }
    this._a = Ce + this._a | 0, this._b = Pe + this._b | 0, this._c = Ve + this._c | 0, this._d = ht + this._d | 0, this._e = vt + this._e | 0;
  }, ie.prototype._hash = function() {
    var oe = Y.allocUnsafe(20);
    return oe.writeInt32BE(this._a | 0, 0), oe.writeInt32BE(this._b | 0, 4), oe.writeInt32BE(this._c | 0, 8), oe.writeInt32BE(this._d | 0, 12), oe.writeInt32BE(this._e | 0, 16), oe;
  }, sha1$1 = ie, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], ae = new Array(64);
  function ie() {
    this.init(), this._w = ae, z.call(this, 64, 56);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function se(Ce, Pe, Ve) {
    return Ve ^ Ce & (Pe ^ Ve);
  }
  function le(Ce, Pe, Ve) {
    return Ce & Pe | Ve & (Ce | Pe);
  }
  function ve(Ce) {
    return (Ce >>> 2 | Ce << 30) ^ (Ce >>> 13 | Ce << 19) ^ (Ce >>> 22 | Ce << 10);
  }
  function ge(Ce) {
    return (Ce >>> 6 | Ce << 26) ^ (Ce >>> 11 | Ce << 21) ^ (Ce >>> 25 | Ce << 7);
  }
  function oe(Ce) {
    return (Ce >>> 7 | Ce << 25) ^ (Ce >>> 18 | Ce << 14) ^ Ce >>> 3;
  }
  function Ee(Ce) {
    return (Ce >>> 17 | Ce << 15) ^ (Ce >>> 19 | Ce << 13) ^ Ce >>> 10;
  }
  return ie.prototype._update = function(Ce) {
    for (var Pe = this._w, Ve = this._a | 0, ht = this._b | 0, vt = this._c | 0, Pt = this._d | 0, _t = this._e | 0, kt = this._f | 0, Ot = this._g | 0, Ht = this._h | 0, jt = 0; jt < 16; ++jt) Pe[jt] = Ce.readInt32BE(jt * 4);
    for (; jt < 64; ++jt) Pe[jt] = Ee(Pe[jt - 2]) + Pe[jt - 7] + oe(Pe[jt - 15]) + Pe[jt - 16] | 0;
    for (var Yt = 0; Yt < 64; ++Yt) {
      var Dt = Ht + ge(_t) + se(_t, kt, Ot) + ne[Yt] + Pe[Yt] | 0, Ct = ve(Ve) + le(Ve, ht, vt) | 0;
      Ht = Ot, Ot = kt, kt = _t, _t = Pt + Dt | 0, Pt = vt, vt = ht, ht = Ve, Ve = Dt + Ct | 0;
    }
    this._a = Ve + this._a | 0, this._b = ht + this._b | 0, this._c = vt + this._c | 0, this._d = Pt + this._d | 0, this._e = _t + this._e | 0, this._f = kt + this._f | 0, this._g = Ot + this._g | 0, this._h = Ht + this._h | 0;
  }, ie.prototype._hash = function() {
    var Ce = Y.allocUnsafe(32);
    return Ce.writeInt32BE(this._a, 0), Ce.writeInt32BE(this._b, 4), Ce.writeInt32BE(this._c, 8), Ce.writeInt32BE(this._d, 12), Ce.writeInt32BE(this._e, 16), Ce.writeInt32BE(this._f, 20), Ce.writeInt32BE(this._g, 24), Ce.writeInt32BE(this._h, 28), Ce;
  }, sha256$3 = ie, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var B = requireInherits_browser(), z = requireSha256(), Y = requireHash$1(), ne = safeBufferExports.Buffer, ae = new Array(64);
  function ie() {
    this.init(), this._w = ae, Y.call(this, 64, 56);
  }
  return B(ie, z), ie.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, ie.prototype._hash = function() {
    var se = ne.allocUnsafe(28);
    return se.writeInt32BE(this._a, 0), se.writeInt32BE(this._b, 4), se.writeInt32BE(this._c, 8), se.writeInt32BE(this._d, 12), se.writeInt32BE(this._e, 16), se.writeInt32BE(this._f, 20), se.writeInt32BE(this._g, 24), se;
  }, sha224$1 = ie, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], ae = new Array(160);
  function ie() {
    this.init(), this._w = ae, z.call(this, 128, 112);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function se(ht, vt, Pt) {
    return Pt ^ ht & (vt ^ Pt);
  }
  function le(ht, vt, Pt) {
    return ht & vt | Pt & (ht | vt);
  }
  function ve(ht, vt) {
    return (ht >>> 28 | vt << 4) ^ (vt >>> 2 | ht << 30) ^ (vt >>> 7 | ht << 25);
  }
  function ge(ht, vt) {
    return (ht >>> 14 | vt << 18) ^ (ht >>> 18 | vt << 14) ^ (vt >>> 9 | ht << 23);
  }
  function oe(ht, vt) {
    return (ht >>> 1 | vt << 31) ^ (ht >>> 8 | vt << 24) ^ ht >>> 7;
  }
  function Ee(ht, vt) {
    return (ht >>> 1 | vt << 31) ^ (ht >>> 8 | vt << 24) ^ (ht >>> 7 | vt << 25);
  }
  function Ce(ht, vt) {
    return (ht >>> 19 | vt << 13) ^ (vt >>> 29 | ht << 3) ^ ht >>> 6;
  }
  function Pe(ht, vt) {
    return (ht >>> 19 | vt << 13) ^ (vt >>> 29 | ht << 3) ^ (ht >>> 6 | vt << 26);
  }
  function Ve(ht, vt) {
    return ht >>> 0 < vt >>> 0 ? 1 : 0;
  }
  return ie.prototype._update = function(ht) {
    for (var vt = this._w, Pt = this._ah | 0, _t = this._bh | 0, kt = this._ch | 0, Ot = this._dh | 0, Ht = this._eh | 0, jt = this._fh | 0, Yt = this._gh | 0, Dt = this._hh | 0, Ct = this._al | 0, Kt = this._bl | 0, Nt = this._cl | 0, Je = this._dl | 0, Xe = this._el | 0, Ke = this._fl | 0, Qe = this._gl | 0, bt = this._hl | 0, wt = 0; wt < 32; wt += 2)
      vt[wt] = ht.readInt32BE(wt * 4), vt[wt + 1] = ht.readInt32BE(wt * 4 + 4);
    for (; wt < 160; wt += 2) {
      var xt = vt[wt - 30], Bt = vt[wt - 15 * 2 + 1], $t = oe(xt, Bt), qt = Ee(Bt, xt);
      xt = vt[wt - 2 * 2], Bt = vt[wt - 2 * 2 + 1];
      var Rt = Ce(xt, Bt), Lt = Pe(Bt, xt), tr = vt[wt - 7 * 2], sr = vt[wt - 7 * 2 + 1], Zt = vt[wt - 16 * 2], Wt = vt[wt - 16 * 2 + 1], Gt = qt + sr | 0, rr = $t + tr + Ve(Gt, qt) | 0;
      Gt = Gt + Lt | 0, rr = rr + Rt + Ve(Gt, Lt) | 0, Gt = Gt + Wt | 0, rr = rr + Zt + Ve(Gt, Wt) | 0, vt[wt] = rr, vt[wt + 1] = Gt;
    }
    for (var or = 0; or < 160; or += 2) {
      rr = vt[or], Gt = vt[or + 1];
      var Xt = le(Pt, _t, kt), zt = le(Ct, Kt, Nt), ur = ve(Pt, Ct), pr = ve(Ct, Pt), vr = ge(Ht, Xe), _r = ge(Xe, Ht), xr = ne[or], Tr = ne[or + 1], hr = se(Ht, jt, Yt), Wr = se(Xe, Ke, Qe), $r = bt + _r | 0, Ur = Dt + vr + Ve($r, bt) | 0;
      $r = $r + Wr | 0, Ur = Ur + hr + Ve($r, Wr) | 0, $r = $r + Tr | 0, Ur = Ur + xr + Ve($r, Tr) | 0, $r = $r + Gt | 0, Ur = Ur + rr + Ve($r, Gt) | 0;
      var Gr = pr + zt | 0, Rr = ur + Xt + Ve(Gr, pr) | 0;
      Dt = Yt, bt = Qe, Yt = jt, Qe = Ke, jt = Ht, Ke = Xe, Xe = Je + $r | 0, Ht = Ot + Ur + Ve(Xe, Je) | 0, Ot = kt, Je = Nt, kt = _t, Nt = Kt, _t = Pt, Kt = Ct, Ct = $r + Gr | 0, Pt = Ur + Rr + Ve(Ct, $r) | 0;
    }
    this._al = this._al + Ct | 0, this._bl = this._bl + Kt | 0, this._cl = this._cl + Nt | 0, this._dl = this._dl + Je | 0, this._el = this._el + Xe | 0, this._fl = this._fl + Ke | 0, this._gl = this._gl + Qe | 0, this._hl = this._hl + bt | 0, this._ah = this._ah + Pt + Ve(this._al, Ct) | 0, this._bh = this._bh + _t + Ve(this._bl, Kt) | 0, this._ch = this._ch + kt + Ve(this._cl, Nt) | 0, this._dh = this._dh + Ot + Ve(this._dl, Je) | 0, this._eh = this._eh + Ht + Ve(this._el, Xe) | 0, this._fh = this._fh + jt + Ve(this._fl, Ke) | 0, this._gh = this._gh + Yt + Ve(this._gl, Qe) | 0, this._hh = this._hh + Dt + Ve(this._hl, bt) | 0;
  }, ie.prototype._hash = function() {
    var ht = Y.allocUnsafe(64);
    function vt(Pt, _t, kt) {
      ht.writeInt32BE(Pt, kt), ht.writeInt32BE(_t, kt + 4);
    }
    return vt(this._ah, this._al, 0), vt(this._bh, this._bl, 8), vt(this._ch, this._cl, 16), vt(this._dh, this._dl, 24), vt(this._eh, this._el, 32), vt(this._fh, this._fl, 40), vt(this._gh, this._gl, 48), vt(this._hh, this._hl, 56), ht;
  }, sha512$1 = ie, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var B = requireInherits_browser(), z = requireSha512(), Y = requireHash$1(), ne = safeBufferExports.Buffer, ae = new Array(160);
  function ie() {
    this.init(), this._w = ae, Y.call(this, 128, 112);
  }
  return B(ie, z), ie.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, ie.prototype._hash = function() {
    var se = ne.allocUnsafe(48);
    function le(ve, ge, oe) {
      se.writeInt32BE(ve, oe), se.writeInt32BE(ge, oe + 4);
    }
    return le(this._ah, this._al, 0), le(this._bh, this._bl, 8), le(this._ch, this._cl, 16), le(this._dh, this._dl, 24), le(this._eh, this._el, 32), le(this._fh, this._fl, 40), se;
  }, sha384$1 = ie, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var B = sha_js.exports = function(Y) {
    Y = Y.toLowerCase();
    var ne = B[Y];
    if (!ne) throw new Error(Y + " is not supported (we accept pull requests)");
    return new ne();
  };
  return B.sha = requireSha$1(), B.sha1 = requireSha1(), B.sha224 = requireSha224(), B.sha256 = requireSha256(), B.sha384 = requireSha384(), B.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = Y;
  var B = requireEvents().EventEmitter, z = requireInherits_browser();
  z(Y, B), Y.Readable = require_stream_readable$1(), Y.Writable = require_stream_writable$1(), Y.Duplex = require_stream_duplex$1(), Y.Transform = require_stream_transform$1(), Y.PassThrough = require_stream_passthrough$1(), Y.finished = requireEndOfStream(), Y.pipeline = requirePipeline(), Y.Stream = Y;
  function Y() {
    B.call(this);
  }
  return Y.prototype.pipe = function(ne, ae) {
    var ie = this;
    function se(Pe) {
      ne.writable && ne.write(Pe) === !1 && ie.pause && ie.pause();
    }
    ie.on("data", se);
    function le() {
      ie.readable && ie.resume && ie.resume();
    }
    ne.on("drain", le), !ne._isStdio && (!ae || ae.end !== !1) && (ie.on("end", ge), ie.on("close", oe));
    var ve = !1;
    function ge() {
      ve || (ve = !0, ne.end());
    }
    function oe() {
      ve || (ve = !0, typeof ne.destroy == "function" && ne.destroy());
    }
    function Ee(Pe) {
      if (Ce(), B.listenerCount(this, "error") === 0)
        throw Pe;
    }
    ie.on("error", Ee), ne.on("error", Ee);
    function Ce() {
      ie.removeListener("data", se), ne.removeListener("drain", le), ie.removeListener("end", ge), ie.removeListener("close", oe), ie.removeListener("error", Ee), ne.removeListener("error", Ee), ie.removeListener("end", Ce), ie.removeListener("close", Ce), ne.removeListener("close", Ce);
    }
    return ie.on("end", Ce), ie.on("close", Ce), ne.on("close", Ce), ne.emit("pipe", ie), ne;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var B = safeBufferExports.Buffer, z = requireStreamBrowserify().Transform, Y = requireString_decoder().StringDecoder, ne = requireInherits_browser();
  function ae(ve) {
    z.call(this), this.hashMode = typeof ve == "string", this.hashMode ? this[ve] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  ne(ae, z);
  var ie = typeof Uint8Array < "u", se = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (B.prototype instanceof Uint8Array || B.TYPED_ARRAY_SUPPORT);
  function le(ve, ge) {
    if (ve instanceof B)
      return ve;
    if (typeof ve == "string")
      return B.from(ve, ge);
    if (se && ArrayBuffer.isView(ve)) {
      if (ve.byteLength === 0)
        return B.alloc(0);
      var oe = B.from(ve.buffer, ve.byteOffset, ve.byteLength);
      if (oe.byteLength === ve.byteLength)
        return oe;
    }
    if (ie && ve instanceof Uint8Array || B.isBuffer(ve) && ve.constructor && typeof ve.constructor.isBuffer == "function" && ve.constructor.isBuffer(ve))
      return B.from(ve);
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  return ae.prototype.update = function(ve, ge, oe) {
    var Ee = le(ve, ge), Ce = this._update(Ee);
    return this.hashMode ? this : (oe && (Ce = this._toString(Ce, oe)), Ce);
  }, ae.prototype.setAutoPadding = function() {
  }, ae.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, ae.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, ae.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, ae.prototype._transform = function(ve, ge, oe) {
    var Ee;
    try {
      this.hashMode ? this._update(ve) : this.push(this._update(ve));
    } catch (Ce) {
      Ee = Ce;
    } finally {
      oe(Ee);
    }
  }, ae.prototype._flush = function(ve) {
    var ge;
    try {
      this.push(this.__final());
    } catch (oe) {
      ge = oe;
    }
    ve(ge);
  }, ae.prototype._finalOrDigest = function(ve) {
    var ge = this.__final() || B.alloc(0);
    return ve && (ge = this._toString(ge, ve, !0)), ge;
  }, ae.prototype._toString = function(ve, ge, oe) {
    if (this._decoder || (this._decoder = new Y(ge), this._encoding = ge), this._encoding !== ge)
      throw new Error("cant switch encodings");
    var Ee = this._decoder.write(ve);
    return oe && (Ee += this._decoder.end()), Ee;
  }, cipherBase = ae, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var B = requireInherits_browser(), z = requireMd5_js(), Y = requireRipemd160(), ne = requireSha_js(), ae = requireCipherBase();
  function ie(se) {
    ae.call(this, "digest"), this._hash = se;
  }
  return B(ie, ae), ie.prototype._update = function(se) {
    this._hash.update(se);
  }, ie.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(le) {
    return le = le.toLowerCase(), le === "md5" ? new z() : le === "rmd160" || le === "ripemd160" ? new Y() : new ie(ne(le));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var B = requireInherits_browser(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ne = z.alloc(128), ae = 64;
  function ie(se, le) {
    Y.call(this, "digest"), typeof le == "string" && (le = z.from(le)), this._alg = se, this._key = le, le.length > ae ? le = se(le) : le.length < ae && (le = z.concat([le, ne], ae));
    for (var ve = this._ipad = z.allocUnsafe(ae), ge = this._opad = z.allocUnsafe(ae), oe = 0; oe < ae; oe++)
      ve[oe] = le[oe] ^ 54, ge[oe] = le[oe] ^ 92;
    this._hash = [ve];
  }
  return B(ie, Y), ie.prototype._update = function(se) {
    this._hash.push(se);
  }, ie.prototype._final = function() {
    var se = this._alg(z.concat(this._hash));
    return this._alg(z.concat([this._opad, se]));
  }, legacy = ie, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var B = requireMd5_js();
  return md5 = function(z) {
    return new B().update(z).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var B = requireInherits_browser(), z = requireLegacy(), Y = requireCipherBase(), ne = safeBufferExports.Buffer, ae = requireMd5(), ie = requireRipemd160(), se = requireSha_js(), le = ne.alloc(128);
  function ve(ge, oe) {
    Y.call(this, "digest"), typeof oe == "string" && (oe = ne.from(oe));
    var Ee = ge === "sha512" || ge === "sha384" ? 128 : 64;
    if (this._alg = ge, this._key = oe, oe.length > Ee) {
      var Ce = ge === "rmd160" ? new ie() : se(ge);
      oe = Ce.update(oe).digest();
    } else oe.length < Ee && (oe = ne.concat([oe, le], Ee));
    for (var Pe = this._ipad = ne.allocUnsafe(Ee), Ve = this._opad = ne.allocUnsafe(Ee), ht = 0; ht < Ee; ht++)
      Pe[ht] = oe[ht] ^ 54, Ve[ht] = oe[ht] ^ 92;
    this._hash = ge === "rmd160" ? new ie() : se(ge), this._hash.update(Pe);
  }
  return B(ve, Y), ve.prototype._update = function(ge) {
    this._hash.update(ge);
  }, ve.prototype._final = function() {
    var ge = this._hash.digest(), oe = this._alg === "rmd160" ? new ie() : se(this._alg);
    return oe.update(this._opad).update(ge).digest();
  }, browser$8 = function(oe, Ee) {
    return oe = oe.toLowerCase(), oe === "rmd160" || oe === "ripemd160" ? new ve("rmd160", Ee) : oe === "md5" ? new z(ae, Ee) : new ve(oe, Ee);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var B = Math.pow(2, 30) - 1;
  return precondition = function(z, Y) {
    if (typeof z != "number")
      throw new TypeError("Iterations not a number");
    if (z < 0)
      throw new TypeError("Bad iterations");
    if (typeof Y != "number")
      throw new TypeError("Key length not a number");
    if (Y < 0 || Y > B || Y !== Y)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var B;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    B = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var z = parseInt(process$1.version.split(".")[0].slice(1), 10);
    B = z >= 6 ? "utf-8" : "binary";
  } else
    B = "utf-8";
  return defaultEncoding_1 = B, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var B = safeBufferExports.Buffer;
  return toBuffer$1 = function(z, Y, ne) {
    if (B.isBuffer(z))
      return z;
    if (typeof z == "string")
      return B.from(z, Y);
    if (ArrayBuffer.isView(z))
      return B.from(z.buffer);
    throw new TypeError(ne + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var B = requireMd5(), z = requireRipemd160(), Y = requireSha_js(), ne = safeBufferExports.Buffer, ae = requirePrecondition(), ie = requireDefaultEncoding(), se = requireToBuffer(), le = ne.alloc(128), ve = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function ge(Ce, Pe, Ve) {
    var ht = oe(Ce), vt = Ce === "sha512" || Ce === "sha384" ? 128 : 64;
    Pe.length > vt ? Pe = ht(Pe) : Pe.length < vt && (Pe = ne.concat([Pe, le], vt));
    for (var Pt = ne.allocUnsafe(vt + ve[Ce]), _t = ne.allocUnsafe(vt + ve[Ce]), kt = 0; kt < vt; kt++)
      Pt[kt] = Pe[kt] ^ 54, _t[kt] = Pe[kt] ^ 92;
    var Ot = ne.allocUnsafe(vt + Ve + 4);
    Pt.copy(Ot, 0, 0, vt), this.ipad1 = Ot, this.ipad2 = Pt, this.opad = _t, this.alg = Ce, this.blocksize = vt, this.hash = ht, this.size = ve[Ce];
  }
  ge.prototype.run = function(Ce, Pe) {
    Ce.copy(Pe, this.blocksize);
    var Ve = this.hash(Pe);
    return Ve.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function oe(Ce) {
    function Pe(ht) {
      return Y(Ce).update(ht).digest();
    }
    function Ve(ht) {
      return new z().update(ht).digest();
    }
    return Ce === "rmd160" || Ce === "ripemd160" ? Ve : Ce === "md5" ? B : Pe;
  }
  function Ee(Ce, Pe, Ve, ht, vt) {
    ae(Ve, ht), Ce = se(Ce, ie, "Password"), Pe = se(Pe, ie, "Salt"), vt = vt || "sha1";
    var Pt = new ge(vt, Ce, Pe.length), _t = ne.allocUnsafe(ht), kt = ne.allocUnsafe(Pe.length + 4);
    Pe.copy(kt, 0, 0, Pe.length);
    for (var Ot = 0, Ht = ve[vt], jt = Math.ceil(ht / Ht), Yt = 1; Yt <= jt; Yt++) {
      kt.writeUInt32BE(Yt, Pe.length);
      for (var Dt = Pt.run(kt, Pt.ipad1), Ct = Dt, Kt = 1; Kt < Ve; Kt++) {
        Ct = Pt.run(Ct, Pt.ipad2);
        for (var Nt = 0; Nt < Ht; Nt++) Dt[Nt] ^= Ct[Nt];
      }
      Dt.copy(_t, Ot), Ot += Ht;
    }
    return _t;
  }
  return syncBrowser = Ee, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var B = safeBufferExports.Buffer, z = requirePrecondition(), Y = requireDefaultEncoding(), ne = requireSyncBrowser(), ae = requireToBuffer(), ie, se = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, le = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ve = [];
  function ge(Ve) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !se || !se.importKey || !se.deriveBits)
      return Promise.resolve(!1);
    if (ve[Ve] !== void 0)
      return ve[Ve];
    ie = ie || B.alloc(8);
    var ht = Ce(ie, ie, 10, 128, Ve).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ve[Ve] = ht, ht;
  }
  var oe;
  function Ee() {
    return oe || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? oe = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? oe = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? oe = commonjsGlobal.setImmediate : oe = commonjsGlobal.setTimeout, oe);
  }
  function Ce(Ve, ht, vt, Pt, _t) {
    return se.importKey(
      "raw",
      Ve,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(kt) {
      return se.deriveBits({
        name: "PBKDF2",
        salt: ht,
        iterations: vt,
        hash: {
          name: _t
        }
      }, kt, Pt << 3);
    }).then(function(kt) {
      return B.from(kt);
    });
  }
  function Pe(Ve, ht) {
    Ve.then(function(vt) {
      Ee()(function() {
        ht(null, vt);
      });
    }, function(vt) {
      Ee()(function() {
        ht(vt);
      });
    });
  }
  return async = function(Ve, ht, vt, Pt, _t, kt) {
    typeof _t == "function" && (kt = _t, _t = void 0), _t = _t || "sha1";
    var Ot = le[_t.toLowerCase()];
    if (!Ot || typeof commonjsGlobal.Promise != "function") {
      Ee()(function() {
        var Ht;
        try {
          Ht = ne(Ve, ht, vt, Pt, _t);
        } catch (jt) {
          return kt(jt);
        }
        kt(null, Ht);
      });
      return;
    }
    if (z(vt, Pt), Ve = ae(Ve, Y, "Password"), ht = ae(ht, Y, "Salt"), typeof kt != "function") throw new Error("No callback provided to pbkdf2");
    Pe(ge(Ot).then(function(Ht) {
      return Ht ? Ce(Ve, ht, vt, Pt, Ot) : ne(Ve, ht, vt, Pt, _t);
    }), kt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(ae, ie) {
    var se = ae[0 + ie] << 24 | ae[1 + ie] << 16 | ae[2 + ie] << 8 | ae[3 + ie];
    return se >>> 0;
  }, utils$4.writeUInt32BE = function(ae, ie, se) {
    ae[0 + se] = ie >>> 24, ae[1 + se] = ie >>> 16 & 255, ae[2 + se] = ie >>> 8 & 255, ae[3 + se] = ie & 255;
  }, utils$4.ip = function(ae, ie, se, le) {
    for (var ve = 0, ge = 0, oe = 6; oe >= 0; oe -= 2) {
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= ie >>> Ee + oe & 1;
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= ae >>> Ee + oe & 1;
    }
    for (var oe = 6; oe >= 0; oe -= 2) {
      for (var Ee = 1; Ee <= 25; Ee += 8)
        ge <<= 1, ge |= ie >>> Ee + oe & 1;
      for (var Ee = 1; Ee <= 25; Ee += 8)
        ge <<= 1, ge |= ae >>> Ee + oe & 1;
    }
    se[le + 0] = ve >>> 0, se[le + 1] = ge >>> 0;
  }, utils$4.rip = function(ae, ie, se, le) {
    for (var ve = 0, ge = 0, oe = 0; oe < 4; oe++)
      for (var Ee = 24; Ee >= 0; Ee -= 8)
        ve <<= 1, ve |= ie >>> Ee + oe & 1, ve <<= 1, ve |= ae >>> Ee + oe & 1;
    for (var oe = 4; oe < 8; oe++)
      for (var Ee = 24; Ee >= 0; Ee -= 8)
        ge <<= 1, ge |= ie >>> Ee + oe & 1, ge <<= 1, ge |= ae >>> Ee + oe & 1;
    se[le + 0] = ve >>> 0, se[le + 1] = ge >>> 0;
  }, utils$4.pc1 = function(ae, ie, se, le) {
    for (var ve = 0, ge = 0, oe = 7; oe >= 5; oe--) {
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= ie >> Ee + oe & 1;
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= ae >> Ee + oe & 1;
    }
    for (var Ee = 0; Ee <= 24; Ee += 8)
      ve <<= 1, ve |= ie >> Ee + oe & 1;
    for (var oe = 1; oe <= 3; oe++) {
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ge <<= 1, ge |= ie >> Ee + oe & 1;
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ge <<= 1, ge |= ae >> Ee + oe & 1;
    }
    for (var Ee = 0; Ee <= 24; Ee += 8)
      ge <<= 1, ge |= ae >> Ee + oe & 1;
    se[le + 0] = ve >>> 0, se[le + 1] = ge >>> 0;
  }, utils$4.r28shl = function(ae, ie) {
    return ae << ie & 268435455 | ae >>> 28 - ie;
  };
  var B = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(ae, ie, se, le) {
    for (var ve = 0, ge = 0, oe = B.length >>> 1, Ee = 0; Ee < oe; Ee++)
      ve <<= 1, ve |= ae >>> B[Ee] & 1;
    for (var Ee = oe; Ee < B.length; Ee++)
      ge <<= 1, ge |= ie >>> B[Ee] & 1;
    se[le + 0] = ve >>> 0, se[le + 1] = ge >>> 0;
  }, utils$4.expand = function(ae, ie, se) {
    var le = 0, ve = 0;
    le = (ae & 1) << 5 | ae >>> 27;
    for (var ge = 23; ge >= 15; ge -= 4)
      le <<= 6, le |= ae >>> ge & 63;
    for (var ge = 11; ge >= 3; ge -= 4)
      ve |= ae >>> ge & 63, ve <<= 6;
    ve |= (ae & 31) << 1 | ae >>> 31, ie[se + 0] = le >>> 0, ie[se + 1] = ve >>> 0;
  };
  var z = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(ae, ie) {
    for (var se = 0, le = 0; le < 4; le++) {
      var ve = ae >>> 18 - le * 6 & 63, ge = z[le * 64 + ve];
      se <<= 4, se |= ge;
    }
    for (var le = 0; le < 4; le++) {
      var ve = ie >>> 18 - le * 6 & 63, ge = z[4 * 64 + le * 64 + ve];
      se <<= 4, se |= ge;
    }
    return se >>> 0;
  };
  var Y = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(ae) {
    for (var ie = 0, se = 0; se < Y.length; se++)
      ie <<= 1, ie |= ae >>> Y[se] & 1;
    return ie >>> 0;
  }, utils$4.padSplit = function(ae, ie, se) {
    for (var le = ae.toString(2); le.length < ie; )
      le = "0" + le;
    for (var ve = [], ge = 0; ge < ie; ge += se)
      ve.push(le.slice(ge, ge + se));
    return ve.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = B;
  function B(z, Y) {
    if (!z)
      throw new Error(Y || "Assertion failed");
  }
  return B.equal = function(Y, ne, ae) {
    if (Y != ne)
      throw new Error(ae || "Assertion failed: " + Y + " != " + ne);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var B = requireMinimalisticAssert();
  function z(Y) {
    this.options = Y, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = Y.padding !== !1;
  }
  return cipher = z, z.prototype._init = function() {
  }, z.prototype.update = function(ne) {
    return ne.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(ne) : this._updateEncrypt(ne);
  }, z.prototype._buffer = function(ne, ae) {
    for (var ie = Math.min(this.buffer.length - this.bufferOff, ne.length - ae), se = 0; se < ie; se++)
      this.buffer[this.bufferOff + se] = ne[ae + se];
    return this.bufferOff += ie, ie;
  }, z.prototype._flushBuffer = function(ne, ae) {
    return this._update(this.buffer, 0, ne, ae), this.bufferOff = 0, this.blockSize;
  }, z.prototype._updateEncrypt = function(ne) {
    var ae = 0, ie = 0, se = (this.bufferOff + ne.length) / this.blockSize | 0, le = new Array(se * this.blockSize);
    this.bufferOff !== 0 && (ae += this._buffer(ne, ae), this.bufferOff === this.buffer.length && (ie += this._flushBuffer(le, ie)));
    for (var ve = ne.length - (ne.length - ae) % this.blockSize; ae < ve; ae += this.blockSize)
      this._update(ne, ae, le, ie), ie += this.blockSize;
    for (; ae < ne.length; ae++, this.bufferOff++)
      this.buffer[this.bufferOff] = ne[ae];
    return le;
  }, z.prototype._updateDecrypt = function(ne) {
    for (var ae = 0, ie = 0, se = Math.ceil((this.bufferOff + ne.length) / this.blockSize) - 1, le = new Array(se * this.blockSize); se > 0; se--)
      ae += this._buffer(ne, ae), ie += this._flushBuffer(le, ie);
    return ae += this._buffer(ne, ae), le;
  }, z.prototype.final = function(ne) {
    var ae;
    ne && (ae = this.update(ne));
    var ie;
    return this.type === "encrypt" ? ie = this._finalEncrypt() : ie = this._finalDecrypt(), ae ? ae.concat(ie) : ie;
  }, z.prototype._pad = function(ne, ae) {
    if (ae === 0)
      return !1;
    for (; ae < ne.length; )
      ne[ae++] = 0;
    return !0;
  }, z.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var ne = new Array(this.blockSize);
    return this._update(this.buffer, 0, ne, 0), ne;
  }, z.prototype._unpad = function(ne) {
    return ne;
  }, z.prototype._finalDecrypt = function() {
    B.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var ne = new Array(this.blockSize);
    return this._flushBuffer(ne, 0), this._unpad(ne);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = requireUtils$3(), ne = requireCipher();
  function ae() {
    this.tmp = new Array(2), this.keys = null;
  }
  function ie(le) {
    ne.call(this, le);
    var ve = new ae();
    this._desState = ve, this.deriveKeys(ve, le.key);
  }
  z(ie, ne), des = ie, ie.create = function(ve) {
    return new ie(ve);
  };
  var se = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return ie.prototype.deriveKeys = function(ve, ge) {
    ve.keys = new Array(16 * 2), B.equal(ge.length, this.blockSize, "Invalid key length");
    var oe = Y.readUInt32BE(ge, 0), Ee = Y.readUInt32BE(ge, 4);
    Y.pc1(oe, Ee, ve.tmp, 0), oe = ve.tmp[0], Ee = ve.tmp[1];
    for (var Ce = 0; Ce < ve.keys.length; Ce += 2) {
      var Pe = se[Ce >>> 1];
      oe = Y.r28shl(oe, Pe), Ee = Y.r28shl(Ee, Pe), Y.pc2(oe, Ee, ve.keys, Ce);
    }
  }, ie.prototype._update = function(ve, ge, oe, Ee) {
    var Ce = this._desState, Pe = Y.readUInt32BE(ve, ge), Ve = Y.readUInt32BE(ve, ge + 4);
    Y.ip(Pe, Ve, Ce.tmp, 0), Pe = Ce.tmp[0], Ve = Ce.tmp[1], this.type === "encrypt" ? this._encrypt(Ce, Pe, Ve, Ce.tmp, 0) : this._decrypt(Ce, Pe, Ve, Ce.tmp, 0), Pe = Ce.tmp[0], Ve = Ce.tmp[1], Y.writeUInt32BE(oe, Pe, Ee), Y.writeUInt32BE(oe, Ve, Ee + 4);
  }, ie.prototype._pad = function(ve, ge) {
    if (this.padding === !1)
      return !1;
    for (var oe = ve.length - ge, Ee = ge; Ee < ve.length; Ee++)
      ve[Ee] = oe;
    return !0;
  }, ie.prototype._unpad = function(ve) {
    if (this.padding === !1)
      return ve;
    for (var ge = ve[ve.length - 1], oe = ve.length - ge; oe < ve.length; oe++)
      B.equal(ve[oe], ge);
    return ve.slice(0, ve.length - ge);
  }, ie.prototype._encrypt = function(ve, ge, oe, Ee, Ce) {
    for (var Pe = ge, Ve = oe, ht = 0; ht < ve.keys.length; ht += 2) {
      var vt = ve.keys[ht], Pt = ve.keys[ht + 1];
      Y.expand(Ve, ve.tmp, 0), vt ^= ve.tmp[0], Pt ^= ve.tmp[1];
      var _t = Y.substitute(vt, Pt), kt = Y.permute(_t), Ot = Ve;
      Ve = (Pe ^ kt) >>> 0, Pe = Ot;
    }
    Y.rip(Ve, Pe, Ee, Ce);
  }, ie.prototype._decrypt = function(ve, ge, oe, Ee, Ce) {
    for (var Pe = oe, Ve = ge, ht = ve.keys.length - 2; ht >= 0; ht -= 2) {
      var vt = ve.keys[ht], Pt = ve.keys[ht + 1];
      Y.expand(Pe, ve.tmp, 0), vt ^= ve.tmp[0], Pt ^= ve.tmp[1];
      var _t = Y.substitute(vt, Pt), kt = Y.permute(_t), Ot = Pe;
      Pe = (Ve ^ kt) >>> 0, Ve = Ot;
    }
    Y.rip(Pe, Ve, Ee, Ce);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = {};
  function ne(ie) {
    B.equal(ie.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var se = 0; se < this.iv.length; se++)
      this.iv[se] = ie[se];
  }
  function ae(ie) {
    function se(oe) {
      ie.call(this, oe), this._cbcInit();
    }
    z(se, ie);
    for (var le = Object.keys(Y), ve = 0; ve < le.length; ve++) {
      var ge = le[ve];
      se.prototype[ge] = Y[ge];
    }
    return se.create = function(Ee) {
      return new se(Ee);
    }, se;
  }
  return cbc$1.instantiate = ae, Y._cbcInit = function() {
    var se = new ne(this.options.iv);
    this._cbcState = se;
  }, Y._update = function(se, le, ve, ge) {
    var oe = this._cbcState, Ee = this.constructor.super_.prototype, Ce = oe.iv;
    if (this.type === "encrypt") {
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        Ce[Pe] ^= se[le + Pe];
      Ee._update.call(this, Ce, 0, ve, ge);
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        Ce[Pe] = ve[ge + Pe];
    } else {
      Ee._update.call(this, se, le, ve, ge);
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        ve[ge + Pe] ^= Ce[Pe];
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        Ce[Pe] = se[le + Pe];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = requireCipher(), ne = requireDes$1();
  function ae(se, le) {
    B.equal(le.length, 24, "Invalid key length");
    var ve = le.slice(0, 8), ge = le.slice(8, 16), oe = le.slice(16, 24);
    se === "encrypt" ? this.ciphers = [
      ne.create({ type: "encrypt", key: ve }),
      ne.create({ type: "decrypt", key: ge }),
      ne.create({ type: "encrypt", key: oe })
    ] : this.ciphers = [
      ne.create({ type: "decrypt", key: oe }),
      ne.create({ type: "encrypt", key: ge }),
      ne.create({ type: "decrypt", key: ve })
    ];
  }
  function ie(se) {
    Y.call(this, se);
    var le = new ae(this.type, this.options.key);
    this._edeState = le;
  }
  return z(ie, Y), ede = ie, ie.create = function(le) {
    return new ie(le);
  }, ie.prototype._update = function(le, ve, ge, oe) {
    var Ee = this._edeState;
    Ee.ciphers[0]._update(le, ve, ge, oe), Ee.ciphers[1]._update(ge, oe, ge, oe), Ee.ciphers[2]._update(ge, oe, ge, oe);
  }, ie.prototype._pad = ne.prototype._pad, ie.prototype._unpad = ne.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var B = requireCipherBase(), z = requireDes(), Y = requireInherits_browser(), ne = safeBufferExports.Buffer, ae = {
    "des-ede3-cbc": z.CBC.instantiate(z.EDE),
    "des-ede3": z.EDE,
    "des-ede-cbc": z.CBC.instantiate(z.EDE),
    "des-ede": z.EDE,
    "des-cbc": z.CBC.instantiate(z.DES),
    "des-ecb": z.DES
  };
  ae.des = ae["des-cbc"], ae.des3 = ae["des-ede3-cbc"], browserifyDes = ie, Y(ie, B);
  function ie(se) {
    B.call(this);
    var le = se.mode.toLowerCase(), ve = ae[le], ge;
    se.decrypt ? ge = "decrypt" : ge = "encrypt";
    var oe = se.key;
    ne.isBuffer(oe) || (oe = ne.from(oe)), (le === "des-ede" || le === "des-ede-cbc") && (oe = ne.concat([oe, oe.slice(0, 8)]));
    var Ee = se.iv;
    ne.isBuffer(Ee) || (Ee = ne.from(Ee)), this._des = ve.create({
      key: oe,
      iv: Ee,
      type: ge
    });
  }
  return ie.prototype._update = function(se) {
    return ne.from(this._des.update(se));
  }, ie.prototype._final = function() {
    return ne.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(B, z) {
    return B._cipher.encryptBlock(z);
  }, ecb.decrypt = function(B, z) {
    return B._cipher.decryptBlock(z);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(z, Y) {
    for (var ne = Math.min(z.length, Y.length), ae = new Buffer$1(ne), ie = 0; ie < ne; ++ie)
      ae[ie] = z[ie] ^ Y[ie];
    return ae;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var B = requireBufferXor();
  return cbc.encrypt = function(z, Y) {
    var ne = B(Y, z._prev);
    return z._prev = z._cipher.encryptBlock(ne), z._prev;
  }, cbc.decrypt = function(z, Y) {
    var ne = z._prev;
    z._prev = Y;
    var ae = z._cipher.decryptBlock(Y);
    return B(ae, ne);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var B = safeBufferExports.Buffer, z = requireBufferXor();
  function Y(ne, ae, ie) {
    var se = ae.length, le = z(ae, ne._cache);
    return ne._cache = ne._cache.slice(se), ne._prev = B.concat([ne._prev, ie ? ae : le]), le;
  }
  return cfb.encrypt = function(ne, ae, ie) {
    for (var se = B.allocUnsafe(0), le; ae.length; )
      if (ne._cache.length === 0 && (ne._cache = ne._cipher.encryptBlock(ne._prev), ne._prev = B.allocUnsafe(0)), ne._cache.length <= ae.length)
        le = ne._cache.length, se = B.concat([se, Y(ne, ae.slice(0, le), ie)]), ae = ae.slice(le);
      else {
        se = B.concat([se, Y(ne, ae, ie)]);
        break;
      }
    return se;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var B = safeBufferExports.Buffer;
  function z(Y, ne, ae) {
    var ie = Y._cipher.encryptBlock(Y._prev), se = ie[0] ^ ne;
    return Y._prev = B.concat([
      Y._prev.slice(1),
      B.from([ae ? ne : se])
    ]), se;
  }
  return cfb8.encrypt = function(Y, ne, ae) {
    for (var ie = ne.length, se = B.allocUnsafe(ie), le = -1; ++le < ie; )
      se[le] = z(Y, ne[le], ae);
    return se;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var B = safeBufferExports.Buffer;
  function z(ne, ae, ie) {
    for (var se, le = -1, ve = 8, ge = 0, oe, Ee; ++le < ve; )
      se = ne._cipher.encryptBlock(ne._prev), oe = ae & 1 << 7 - le ? 128 : 0, Ee = se[0] ^ oe, ge += (Ee & 128) >> le % 8, ne._prev = Y(ne._prev, ie ? oe : Ee);
    return ge;
  }
  function Y(ne, ae) {
    var ie = ne.length, se = -1, le = B.allocUnsafe(ne.length);
    for (ne = B.concat([ne, B.from([ae])]); ++se < ie; )
      le[se] = ne[se] << 1 | ne[se + 1] >> 7;
    return le;
  }
  return cfb1.encrypt = function(ne, ae, ie) {
    for (var se = ae.length, le = B.allocUnsafe(se), ve = -1; ++ve < se; )
      le[ve] = z(ne, ae[ve], ie);
    return le;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var B = requireBufferXor();
  function z(Y) {
    return Y._prev = Y._cipher.encryptBlock(Y._prev), Y._prev;
  }
  return ofb.encrypt = function(Y, ne) {
    for (; Y._cache.length < ne.length; )
      Y._cache = Buffer$1.concat([Y._cache, z(Y)]);
    var ae = Y._cache.slice(0, ne.length);
    return Y._cache = Y._cache.slice(ne.length), B(ne, ae);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function B(z) {
    for (var Y = z.length, ne; Y--; )
      if (ne = z.readUInt8(Y), ne === 255)
        z.writeUInt8(0, Y);
      else {
        ne++, z.writeUInt8(ne, Y);
        break;
      }
  }
  return incr32_1 = B, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var B = requireBufferXor(), z = safeBufferExports.Buffer, Y = requireIncr32();
  function ne(ie) {
    var se = ie._cipher.encryptBlockRaw(ie._prev);
    return Y(ie._prev), se;
  }
  var ae = 16;
  return ctr.encrypt = function(ie, se) {
    var le = Math.ceil(se.length / ae), ve = ie._cache.length;
    ie._cache = z.concat([
      ie._cache,
      z.allocUnsafe(le * ae)
    ]);
    for (var ge = 0; ge < le; ge++) {
      var oe = ne(ie), Ee = ve + ge * ae;
      ie._cache.writeUInt32BE(oe[0], Ee + 0), ie._cache.writeUInt32BE(oe[1], Ee + 4), ie._cache.writeUInt32BE(oe[2], Ee + 8), ie._cache.writeUInt32BE(oe[3], Ee + 12);
    }
    var Ce = ie._cache.slice(0, se.length);
    return ie._cache = ie._cache.slice(se.length), B(se, Ce);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var B = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, z = require$$2;
  for (var Y in z)
    z[Y].module = B[z[Y].mode];
  return modes_1 = z, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var B = safeBufferExports.Buffer;
  function z(le) {
    B.isBuffer(le) || (le = B.from(le));
    for (var ve = le.length / 4 | 0, ge = new Array(ve), oe = 0; oe < ve; oe++)
      ge[oe] = le.readUInt32BE(oe * 4);
    return ge;
  }
  function Y(le) {
    for (var ve = 0; ve < le.length; le++)
      le[ve] = 0;
  }
  function ne(le, ve, ge, oe, Ee) {
    for (var Ce = ge[0], Pe = ge[1], Ve = ge[2], ht = ge[3], vt = le[0] ^ ve[0], Pt = le[1] ^ ve[1], _t = le[2] ^ ve[2], kt = le[3] ^ ve[3], Ot, Ht, jt, Yt, Dt = 4, Ct = 1; Ct < Ee; Ct++)
      Ot = Ce[vt >>> 24] ^ Pe[Pt >>> 16 & 255] ^ Ve[_t >>> 8 & 255] ^ ht[kt & 255] ^ ve[Dt++], Ht = Ce[Pt >>> 24] ^ Pe[_t >>> 16 & 255] ^ Ve[kt >>> 8 & 255] ^ ht[vt & 255] ^ ve[Dt++], jt = Ce[_t >>> 24] ^ Pe[kt >>> 16 & 255] ^ Ve[vt >>> 8 & 255] ^ ht[Pt & 255] ^ ve[Dt++], Yt = Ce[kt >>> 24] ^ Pe[vt >>> 16 & 255] ^ Ve[Pt >>> 8 & 255] ^ ht[_t & 255] ^ ve[Dt++], vt = Ot, Pt = Ht, _t = jt, kt = Yt;
    return Ot = (oe[vt >>> 24] << 24 | oe[Pt >>> 16 & 255] << 16 | oe[_t >>> 8 & 255] << 8 | oe[kt & 255]) ^ ve[Dt++], Ht = (oe[Pt >>> 24] << 24 | oe[_t >>> 16 & 255] << 16 | oe[kt >>> 8 & 255] << 8 | oe[vt & 255]) ^ ve[Dt++], jt = (oe[_t >>> 24] << 24 | oe[kt >>> 16 & 255] << 16 | oe[vt >>> 8 & 255] << 8 | oe[Pt & 255]) ^ ve[Dt++], Yt = (oe[kt >>> 24] << 24 | oe[vt >>> 16 & 255] << 16 | oe[Pt >>> 8 & 255] << 8 | oe[_t & 255]) ^ ve[Dt++], Ot = Ot >>> 0, Ht = Ht >>> 0, jt = jt >>> 0, Yt = Yt >>> 0, [Ot, Ht, jt, Yt];
  }
  var ae = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], ie = function() {
    for (var le = new Array(256), ve = 0; ve < 256; ve++)
      ve < 128 ? le[ve] = ve << 1 : le[ve] = ve << 1 ^ 283;
    for (var ge = [], oe = [], Ee = [[], [], [], []], Ce = [[], [], [], []], Pe = 0, Ve = 0, ht = 0; ht < 256; ++ht) {
      var vt = Ve ^ Ve << 1 ^ Ve << 2 ^ Ve << 3 ^ Ve << 4;
      vt = vt >>> 8 ^ vt & 255 ^ 99, ge[Pe] = vt, oe[vt] = Pe;
      var Pt = le[Pe], _t = le[Pt], kt = le[_t], Ot = le[vt] * 257 ^ vt * 16843008;
      Ee[0][Pe] = Ot << 24 | Ot >>> 8, Ee[1][Pe] = Ot << 16 | Ot >>> 16, Ee[2][Pe] = Ot << 8 | Ot >>> 24, Ee[3][Pe] = Ot, Ot = kt * 16843009 ^ _t * 65537 ^ Pt * 257 ^ Pe * 16843008, Ce[0][vt] = Ot << 24 | Ot >>> 8, Ce[1][vt] = Ot << 16 | Ot >>> 16, Ce[2][vt] = Ot << 8 | Ot >>> 24, Ce[3][vt] = Ot, Pe === 0 ? Pe = Ve = 1 : (Pe = Pt ^ le[le[le[kt ^ Pt]]], Ve ^= le[le[Ve]]);
    }
    return {
      SBOX: ge,
      INV_SBOX: oe,
      SUB_MIX: Ee,
      INV_SUB_MIX: Ce
    };
  }();
  function se(le) {
    this._key = z(le), this._reset();
  }
  return se.blockSize = 4 * 4, se.keySize = 256 / 8, se.prototype.blockSize = se.blockSize, se.prototype.keySize = se.keySize, se.prototype._reset = function() {
    for (var le = this._key, ve = le.length, ge = ve + 6, oe = (ge + 1) * 4, Ee = [], Ce = 0; Ce < ve; Ce++)
      Ee[Ce] = le[Ce];
    for (Ce = ve; Ce < oe; Ce++) {
      var Pe = Ee[Ce - 1];
      Ce % ve === 0 ? (Pe = Pe << 8 | Pe >>> 24, Pe = ie.SBOX[Pe >>> 24] << 24 | ie.SBOX[Pe >>> 16 & 255] << 16 | ie.SBOX[Pe >>> 8 & 255] << 8 | ie.SBOX[Pe & 255], Pe ^= ae[Ce / ve | 0] << 24) : ve > 6 && Ce % ve === 4 && (Pe = ie.SBOX[Pe >>> 24] << 24 | ie.SBOX[Pe >>> 16 & 255] << 16 | ie.SBOX[Pe >>> 8 & 255] << 8 | ie.SBOX[Pe & 255]), Ee[Ce] = Ee[Ce - ve] ^ Pe;
    }
    for (var Ve = [], ht = 0; ht < oe; ht++) {
      var vt = oe - ht, Pt = Ee[vt - (ht % 4 ? 0 : 4)];
      ht < 4 || vt <= 4 ? Ve[ht] = Pt : Ve[ht] = ie.INV_SUB_MIX[0][ie.SBOX[Pt >>> 24]] ^ ie.INV_SUB_MIX[1][ie.SBOX[Pt >>> 16 & 255]] ^ ie.INV_SUB_MIX[2][ie.SBOX[Pt >>> 8 & 255]] ^ ie.INV_SUB_MIX[3][ie.SBOX[Pt & 255]];
    }
    this._nRounds = ge, this._keySchedule = Ee, this._invKeySchedule = Ve;
  }, se.prototype.encryptBlockRaw = function(le) {
    return le = z(le), ne(le, this._keySchedule, ie.SUB_MIX, ie.SBOX, this._nRounds);
  }, se.prototype.encryptBlock = function(le) {
    var ve = this.encryptBlockRaw(le), ge = B.allocUnsafe(16);
    return ge.writeUInt32BE(ve[0], 0), ge.writeUInt32BE(ve[1], 4), ge.writeUInt32BE(ve[2], 8), ge.writeUInt32BE(ve[3], 12), ge;
  }, se.prototype.decryptBlock = function(le) {
    le = z(le);
    var ve = le[1];
    le[1] = le[3], le[3] = ve;
    var ge = ne(le, this._invKeySchedule, ie.INV_SUB_MIX, ie.INV_SBOX, this._nRounds), oe = B.allocUnsafe(16);
    return oe.writeUInt32BE(ge[0], 0), oe.writeUInt32BE(ge[3], 4), oe.writeUInt32BE(ge[2], 8), oe.writeUInt32BE(ge[1], 12), oe;
  }, se.prototype.scrub = function() {
    Y(this._keySchedule), Y(this._invKeySchedule), Y(this._key);
  }, aes.AES = se, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var B = safeBufferExports.Buffer, z = B.alloc(16, 0);
  function Y(ie) {
    return [
      ie.readUInt32BE(0),
      ie.readUInt32BE(4),
      ie.readUInt32BE(8),
      ie.readUInt32BE(12)
    ];
  }
  function ne(ie) {
    var se = B.allocUnsafe(16);
    return se.writeUInt32BE(ie[0] >>> 0, 0), se.writeUInt32BE(ie[1] >>> 0, 4), se.writeUInt32BE(ie[2] >>> 0, 8), se.writeUInt32BE(ie[3] >>> 0, 12), se;
  }
  function ae(ie) {
    this.h = ie, this.state = B.alloc(16, 0), this.cache = B.allocUnsafe(0);
  }
  return ae.prototype.ghash = function(ie) {
    for (var se = -1; ++se < ie.length; )
      this.state[se] ^= ie[se];
    this._multiply();
  }, ae.prototype._multiply = function() {
    for (var ie = Y(this.h), se = [0, 0, 0, 0], le, ve, ge, oe = -1; ++oe < 128; ) {
      for (ve = (this.state[~~(oe / 8)] & 1 << 7 - oe % 8) !== 0, ve && (se[0] ^= ie[0], se[1] ^= ie[1], se[2] ^= ie[2], se[3] ^= ie[3]), ge = (ie[3] & 1) !== 0, le = 3; le > 0; le--)
        ie[le] = ie[le] >>> 1 | (ie[le - 1] & 1) << 31;
      ie[0] = ie[0] >>> 1, ge && (ie[0] = ie[0] ^ 225 << 24);
    }
    this.state = ne(se);
  }, ae.prototype.update = function(ie) {
    this.cache = B.concat([this.cache, ie]);
    for (var se; this.cache.length >= 16; )
      se = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(se);
  }, ae.prototype.final = function(ie, se) {
    return this.cache.length && this.ghash(B.concat([this.cache, z], 16)), this.ghash(ne([0, ie, 0, se])), this.state;
  }, ghash = ae, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var B = requireAes(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ne = requireInherits_browser(), ae = requireGhash(), ie = requireBufferXor(), se = requireIncr32();
  function le(oe, Ee) {
    var Ce = 0;
    oe.length !== Ee.length && Ce++;
    for (var Pe = Math.min(oe.length, Ee.length), Ve = 0; Ve < Pe; ++Ve)
      Ce += oe[Ve] ^ Ee[Ve];
    return Ce;
  }
  function ve(oe, Ee, Ce) {
    if (Ee.length === 12)
      return oe._finID = z.concat([Ee, z.from([0, 0, 0, 1])]), z.concat([Ee, z.from([0, 0, 0, 2])]);
    var Pe = new ae(Ce), Ve = Ee.length, ht = Ve % 16;
    Pe.update(Ee), ht && (ht = 16 - ht, Pe.update(z.alloc(ht, 0))), Pe.update(z.alloc(8, 0));
    var vt = Ve * 8, Pt = z.alloc(8);
    Pt.writeUIntBE(vt, 0, 8), Pe.update(Pt), oe._finID = Pe.state;
    var _t = z.from(oe._finID);
    return se(_t), _t;
  }
  function ge(oe, Ee, Ce, Pe) {
    Y.call(this);
    var Ve = z.alloc(4, 0);
    this._cipher = new B.AES(Ee);
    var ht = this._cipher.encryptBlock(Ve);
    this._ghash = new ae(ht), Ce = ve(this, Ce, ht), this._prev = z.from(Ce), this._cache = z.allocUnsafe(0), this._secCache = z.allocUnsafe(0), this._decrypt = Pe, this._alen = 0, this._len = 0, this._mode = oe, this._authTag = null, this._called = !1;
  }
  return ne(ge, Y), ge.prototype._update = function(oe) {
    if (!this._called && this._alen) {
      var Ee = 16 - this._alen % 16;
      Ee < 16 && (Ee = z.alloc(Ee, 0), this._ghash.update(Ee));
    }
    this._called = !0;
    var Ce = this._mode.encrypt(this, oe);
    return this._decrypt ? this._ghash.update(oe) : this._ghash.update(Ce), this._len += oe.length, Ce;
  }, ge.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var oe = ie(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && le(oe, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = oe, this._cipher.scrub();
  }, ge.prototype.getAuthTag = function() {
    if (this._decrypt || !z.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ge.prototype.setAuthTag = function(Ee) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = Ee;
  }, ge.prototype.setAAD = function(Ee) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(Ee), this._alen += Ee.length;
  }, authCipher = ge, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var B = requireAes(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ne = requireInherits_browser();
  function ae(ie, se, le, ve) {
    Y.call(this), this._cipher = new B.AES(se), this._prev = z.from(le), this._cache = z.allocUnsafe(0), this._secCache = z.allocUnsafe(0), this._decrypt = ve, this._mode = ie;
  }
  return ne(ae, Y), ae.prototype._update = function(ie) {
    return this._mode.encrypt(this, ie, this._decrypt);
  }, ae.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = ae, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var B = safeBufferExports.Buffer, z = requireMd5_js();
  function Y(ne, ae, ie, se) {
    if (B.isBuffer(ne) || (ne = B.from(ne, "binary")), ae && (B.isBuffer(ae) || (ae = B.from(ae, "binary")), ae.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var le = ie / 8, ve = B.alloc(le), ge = B.alloc(se || 0), oe = B.alloc(0); le > 0 || se > 0; ) {
      var Ee = new z();
      Ee.update(oe), Ee.update(ne), ae && Ee.update(ae), oe = Ee.digest();
      var Ce = 0;
      if (le > 0) {
        var Pe = ve.length - le;
        Ce = Math.min(le, oe.length), oe.copy(ve, Pe, 0, Ce), le -= Ce;
      }
      if (Ce < oe.length && se > 0) {
        var Ve = ge.length - se, ht = Math.min(se, oe.length - Ce);
        oe.copy(ge, Ve, Ce, Ce + ht), se -= ht;
      }
    }
    return oe.fill(0), { key: ve, iv: ge };
  }
  return evp_bytestokey = Y, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var B = requireModes$1(), z = requireAuthCipher(), Y = safeBufferExports.Buffer, ne = requireStreamCipher(), ae = requireCipherBase(), ie = requireAes(), se = requireEvp_bytestokey(), le = requireInherits_browser();
  function ve(Pe, Ve, ht) {
    ae.call(this), this._cache = new oe(), this._cipher = new ie.AES(Ve), this._prev = Y.from(ht), this._mode = Pe, this._autopadding = !0;
  }
  le(ve, ae), ve.prototype._update = function(Pe) {
    this._cache.add(Pe);
    for (var Ve, ht, vt = []; Ve = this._cache.get(); )
      ht = this._mode.encrypt(this, Ve), vt.push(ht);
    return Y.concat(vt);
  };
  var ge = Y.alloc(16, 16);
  ve.prototype._final = function() {
    var Pe = this._cache.flush();
    if (this._autopadding)
      return Pe = this._mode.encrypt(this, Pe), this._cipher.scrub(), Pe;
    if (!Pe.equals(ge))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ve.prototype.setAutoPadding = function(Pe) {
    return this._autopadding = !!Pe, this;
  };
  function oe() {
    this.cache = Y.allocUnsafe(0);
  }
  oe.prototype.add = function(Pe) {
    this.cache = Y.concat([this.cache, Pe]);
  }, oe.prototype.get = function() {
    if (this.cache.length > 15) {
      var Pe = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Pe;
    }
    return null;
  }, oe.prototype.flush = function() {
    for (var Pe = 16 - this.cache.length, Ve = Y.allocUnsafe(Pe), ht = -1; ++ht < Pe; )
      Ve.writeUInt8(Pe, ht);
    return Y.concat([this.cache, Ve]);
  };
  function Ee(Pe, Ve, ht) {
    var vt = B[Pe.toLowerCase()];
    if (!vt) throw new TypeError("invalid suite type");
    if (typeof Ve == "string" && (Ve = Y.from(Ve)), Ve.length !== vt.key / 8) throw new TypeError("invalid key length " + Ve.length);
    if (typeof ht == "string" && (ht = Y.from(ht)), vt.mode !== "GCM" && ht.length !== vt.iv) throw new TypeError("invalid iv length " + ht.length);
    return vt.type === "stream" ? new ne(vt.module, Ve, ht) : vt.type === "auth" ? new z(vt.module, Ve, ht) : new ve(vt.module, Ve, ht);
  }
  function Ce(Pe, Ve) {
    var ht = B[Pe.toLowerCase()];
    if (!ht) throw new TypeError("invalid suite type");
    var vt = se(Ve, !1, ht.key, ht.iv);
    return Ee(Pe, vt.key, vt.iv);
  }
  return encrypter.createCipheriv = Ee, encrypter.createCipher = Ce, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var B = requireAuthCipher(), z = safeBufferExports.Buffer, Y = requireModes$1(), ne = requireStreamCipher(), ae = requireCipherBase(), ie = requireAes(), se = requireEvp_bytestokey(), le = requireInherits_browser();
  function ve(Pe, Ve, ht) {
    ae.call(this), this._cache = new ge(), this._last = void 0, this._cipher = new ie.AES(Ve), this._prev = z.from(ht), this._mode = Pe, this._autopadding = !0;
  }
  le(ve, ae), ve.prototype._update = function(Pe) {
    this._cache.add(Pe);
    for (var Ve, ht, vt = []; Ve = this._cache.get(this._autopadding); )
      ht = this._mode.decrypt(this, Ve), vt.push(ht);
    return z.concat(vt);
  }, ve.prototype._final = function() {
    var Pe = this._cache.flush();
    if (this._autopadding)
      return oe(this._mode.decrypt(this, Pe));
    if (Pe)
      throw new Error("data not multiple of block length");
  }, ve.prototype.setAutoPadding = function(Pe) {
    return this._autopadding = !!Pe, this;
  };
  function ge() {
    this.cache = z.allocUnsafe(0);
  }
  ge.prototype.add = function(Pe) {
    this.cache = z.concat([this.cache, Pe]);
  }, ge.prototype.get = function(Pe) {
    var Ve;
    if (Pe) {
      if (this.cache.length > 16)
        return Ve = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Ve;
    } else if (this.cache.length >= 16)
      return Ve = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Ve;
    return null;
  }, ge.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function oe(Pe) {
    var Ve = Pe[15];
    if (Ve < 1 || Ve > 16)
      throw new Error("unable to decrypt data");
    for (var ht = -1; ++ht < Ve; )
      if (Pe[ht + (16 - Ve)] !== Ve)
        throw new Error("unable to decrypt data");
    if (Ve !== 16)
      return Pe.slice(0, 16 - Ve);
  }
  function Ee(Pe, Ve, ht) {
    var vt = Y[Pe.toLowerCase()];
    if (!vt) throw new TypeError("invalid suite type");
    if (typeof ht == "string" && (ht = z.from(ht)), vt.mode !== "GCM" && ht.length !== vt.iv) throw new TypeError("invalid iv length " + ht.length);
    if (typeof Ve == "string" && (Ve = z.from(Ve)), Ve.length !== vt.key / 8) throw new TypeError("invalid key length " + Ve.length);
    return vt.type === "stream" ? new ne(vt.module, Ve, ht, !0) : vt.type === "auth" ? new B(vt.module, Ve, ht, !0) : new ve(vt.module, Ve, ht);
  }
  function Ce(Pe, Ve) {
    var ht = Y[Pe.toLowerCase()];
    if (!ht) throw new TypeError("invalid suite type");
    var vt = se(Ve, !1, ht.key, ht.iv);
    return Ee(Pe, vt.key, vt.iv);
  }
  return decrypter.createDecipher = Ce, decrypter.createDecipheriv = Ee, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var B = requireEncrypter(), z = requireDecrypter(), Y = require$$2;
  function ne() {
    return Object.keys(Y);
  }
  return browser$5.createCipher = browser$5.Cipher = B.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = B.createCipheriv, browser$5.createDecipher = browser$5.Decipher = z.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = z.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = ne, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(B) {
    B["des-ecb"] = {
      key: 8,
      iv: 0
    }, B["des-cbc"] = B.des = {
      key: 8,
      iv: 8
    }, B["des-ede3-cbc"] = B.des3 = {
      key: 24,
      iv: 8
    }, B["des-ede3"] = {
      key: 24,
      iv: 0
    }, B["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, B["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var B = requireBrowserifyDes(), z = requireBrowser$6(), Y = requireModes$1(), ne = requireModes(), ae = requireEvp_bytestokey();
  function ie(oe, Ee) {
    oe = oe.toLowerCase();
    var Ce, Pe;
    if (Y[oe])
      Ce = Y[oe].key, Pe = Y[oe].iv;
    else if (ne[oe])
      Ce = ne[oe].key * 8, Pe = ne[oe].iv;
    else
      throw new TypeError("invalid suite type");
    var Ve = ae(Ee, !1, Ce, Pe);
    return le(oe, Ve.key, Ve.iv);
  }
  function se(oe, Ee) {
    oe = oe.toLowerCase();
    var Ce, Pe;
    if (Y[oe])
      Ce = Y[oe].key, Pe = Y[oe].iv;
    else if (ne[oe])
      Ce = ne[oe].key * 8, Pe = ne[oe].iv;
    else
      throw new TypeError("invalid suite type");
    var Ve = ae(Ee, !1, Ce, Pe);
    return ve(oe, Ve.key, Ve.iv);
  }
  function le(oe, Ee, Ce) {
    if (oe = oe.toLowerCase(), Y[oe]) return z.createCipheriv(oe, Ee, Ce);
    if (ne[oe]) return new B({ key: Ee, iv: Ce, mode: oe });
    throw new TypeError("invalid suite type");
  }
  function ve(oe, Ee, Ce) {
    if (oe = oe.toLowerCase(), Y[oe]) return z.createDecipheriv(oe, Ee, Ce);
    if (ne[oe]) return new B({ key: Ee, iv: Ce, mode: oe, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function ge() {
    return Object.keys(ne).concat(z.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = ie, browser$6.createCipheriv = browser$6.Cipheriv = le, browser$6.createDecipher = browser$6.Decipher = se, browser$6.createDecipheriv = browser$6.Decipheriv = ve, browser$6.listCiphers = browser$6.getCiphers = ge, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(B) {
    (function(z, Y) {
      function ne(Nt, Je) {
        if (!Nt) throw new Error(Je || "Assertion failed");
      }
      function ae(Nt, Je) {
        Nt.super_ = Je;
        var Xe = function() {
        };
        Xe.prototype = Je.prototype, Nt.prototype = new Xe(), Nt.prototype.constructor = Nt;
      }
      function ie(Nt, Je, Xe) {
        if (ie.isBN(Nt))
          return Nt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Nt !== null && ((Je === "le" || Je === "be") && (Xe = Je, Je = 10), this._init(Nt || 0, Je || 10, Xe || "be"));
      }
      typeof z == "object" ? z.exports = ie : Y.BN = ie, ie.BN = ie, ie.wordSize = 26;
      var se;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? se = window.Buffer : se = require$$0$1.Buffer;
      } catch {
      }
      ie.isBN = function(Je) {
        return Je instanceof ie ? !0 : Je !== null && typeof Je == "object" && Je.constructor.wordSize === ie.wordSize && Array.isArray(Je.words);
      }, ie.max = function(Je, Xe) {
        return Je.cmp(Xe) > 0 ? Je : Xe;
      }, ie.min = function(Je, Xe) {
        return Je.cmp(Xe) < 0 ? Je : Xe;
      }, ie.prototype._init = function(Je, Xe, Ke) {
        if (typeof Je == "number")
          return this._initNumber(Je, Xe, Ke);
        if (typeof Je == "object")
          return this._initArray(Je, Xe, Ke);
        Xe === "hex" && (Xe = 16), ne(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), Je = Je.toString().replace(/\s+/g, "");
        var Qe = 0;
        Je[0] === "-" && (Qe++, this.negative = 1), Qe < Je.length && (Xe === 16 ? this._parseHex(Je, Qe, Ke) : (this._parseBase(Je, Xe, Qe), Ke === "le" && this._initArray(this.toArray(), Xe, Ke)));
      }, ie.prototype._initNumber = function(Je, Xe, Ke) {
        Je < 0 && (this.negative = 1, Je = -Je), Je < 67108864 ? (this.words = [Je & 67108863], this.length = 1) : Je < 4503599627370496 ? (this.words = [
          Je & 67108863,
          Je / 67108864 & 67108863
        ], this.length = 2) : (ne(Je < 9007199254740992), this.words = [
          Je & 67108863,
          Je / 67108864 & 67108863,
          1
        ], this.length = 3), Ke === "le" && this._initArray(this.toArray(), Xe, Ke);
      }, ie.prototype._initArray = function(Je, Xe, Ke) {
        if (ne(typeof Je.length == "number"), Je.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Je.length / 3), this.words = new Array(this.length);
        for (var Qe = 0; Qe < this.length; Qe++)
          this.words[Qe] = 0;
        var bt, wt, xt = 0;
        if (Ke === "be")
          for (Qe = Je.length - 1, bt = 0; Qe >= 0; Qe -= 3)
            wt = Je[Qe] | Je[Qe - 1] << 8 | Je[Qe - 2] << 16, this.words[bt] |= wt << xt & 67108863, this.words[bt + 1] = wt >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, bt++);
        else if (Ke === "le")
          for (Qe = 0, bt = 0; Qe < Je.length; Qe += 3)
            wt = Je[Qe] | Je[Qe + 1] << 8 | Je[Qe + 2] << 16, this.words[bt] |= wt << xt & 67108863, this.words[bt + 1] = wt >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, bt++);
        return this.strip();
      };
      function le(Nt, Je) {
        var Xe = Nt.charCodeAt(Je);
        return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
      }
      function ve(Nt, Je, Xe) {
        var Ke = le(Nt, Xe);
        return Xe - 1 >= Je && (Ke |= le(Nt, Xe - 1) << 4), Ke;
      }
      ie.prototype._parseHex = function(Je, Xe, Ke) {
        this.length = Math.ceil((Je.length - Xe) / 6), this.words = new Array(this.length);
        for (var Qe = 0; Qe < this.length; Qe++)
          this.words[Qe] = 0;
        var bt = 0, wt = 0, xt;
        if (Ke === "be")
          for (Qe = Je.length - 1; Qe >= Xe; Qe -= 2)
            xt = ve(Je, Xe, Qe) << bt, this.words[wt] |= xt & 67108863, bt >= 18 ? (bt -= 18, wt += 1, this.words[wt] |= xt >>> 26) : bt += 8;
        else {
          var Bt = Je.length - Xe;
          for (Qe = Bt % 2 === 0 ? Xe + 1 : Xe; Qe < Je.length; Qe += 2)
            xt = ve(Je, Xe, Qe) << bt, this.words[wt] |= xt & 67108863, bt >= 18 ? (bt -= 18, wt += 1, this.words[wt] |= xt >>> 26) : bt += 8;
        }
        this.strip();
      };
      function ge(Nt, Je, Xe, Ke) {
        for (var Qe = 0, bt = Math.min(Nt.length, Xe), wt = Je; wt < bt; wt++) {
          var xt = Nt.charCodeAt(wt) - 48;
          Qe *= Ke, xt >= 49 ? Qe += xt - 49 + 10 : xt >= 17 ? Qe += xt - 17 + 10 : Qe += xt;
        }
        return Qe;
      }
      ie.prototype._parseBase = function(Je, Xe, Ke) {
        this.words = [0], this.length = 1;
        for (var Qe = 0, bt = 1; bt <= 67108863; bt *= Xe)
          Qe++;
        Qe--, bt = bt / Xe | 0;
        for (var wt = Je.length - Ke, xt = wt % Qe, Bt = Math.min(wt, wt - xt) + Ke, $t = 0, qt = Ke; qt < Bt; qt += Qe)
          $t = ge(Je, qt, qt + Qe, Xe), this.imuln(bt), this.words[0] + $t < 67108864 ? this.words[0] += $t : this._iaddn($t);
        if (xt !== 0) {
          var Rt = 1;
          for ($t = ge(Je, qt, Je.length, Xe), qt = 0; qt < xt; qt++)
            Rt *= Xe;
          this.imuln(Rt), this.words[0] + $t < 67108864 ? this.words[0] += $t : this._iaddn($t);
        }
        this.strip();
      }, ie.prototype.copy = function(Je) {
        Je.words = new Array(this.length);
        for (var Xe = 0; Xe < this.length; Xe++)
          Je.words[Xe] = this.words[Xe];
        Je.length = this.length, Je.negative = this.negative, Je.red = this.red;
      }, ie.prototype.clone = function() {
        var Je = new ie(null);
        return this.copy(Je), Je;
      }, ie.prototype._expand = function(Je) {
        for (; this.length < Je; )
          this.words[this.length++] = 0;
        return this;
      }, ie.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ie.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, ie.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var oe = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ee = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Ce = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ie.prototype.toString = function(Je, Xe) {
        Je = Je || 10, Xe = Xe | 0 || 1;
        var Ke;
        if (Je === 16 || Je === "hex") {
          Ke = "";
          for (var Qe = 0, bt = 0, wt = 0; wt < this.length; wt++) {
            var xt = this.words[wt], Bt = ((xt << Qe | bt) & 16777215).toString(16);
            bt = xt >>> 24 - Qe & 16777215, Qe += 2, Qe >= 26 && (Qe -= 26, wt--), bt !== 0 || wt !== this.length - 1 ? Ke = oe[6 - Bt.length] + Bt + Ke : Ke = Bt + Ke;
          }
          for (bt !== 0 && (Ke = bt.toString(16) + Ke); Ke.length % Xe !== 0; )
            Ke = "0" + Ke;
          return this.negative !== 0 && (Ke = "-" + Ke), Ke;
        }
        if (Je === (Je | 0) && Je >= 2 && Je <= 36) {
          var $t = Ee[Je], qt = Ce[Je];
          Ke = "";
          var Rt = this.clone();
          for (Rt.negative = 0; !Rt.isZero(); ) {
            var Lt = Rt.modn(qt).toString(Je);
            Rt = Rt.idivn(qt), Rt.isZero() ? Ke = Lt + Ke : Ke = oe[$t - Lt.length] + Lt + Ke;
          }
          for (this.isZero() && (Ke = "0" + Ke); Ke.length % Xe !== 0; )
            Ke = "0" + Ke;
          return this.negative !== 0 && (Ke = "-" + Ke), Ke;
        }
        ne(!1, "Base should be between 2 and 36");
      }, ie.prototype.toNumber = function() {
        var Je = this.words[0];
        return this.length === 2 ? Je += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Je += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Je : Je;
      }, ie.prototype.toJSON = function() {
        return this.toString(16);
      }, ie.prototype.toBuffer = function(Je, Xe) {
        return ne(typeof se < "u"), this.toArrayLike(se, Je, Xe);
      }, ie.prototype.toArray = function(Je, Xe) {
        return this.toArrayLike(Array, Je, Xe);
      }, ie.prototype.toArrayLike = function(Je, Xe, Ke) {
        var Qe = this.byteLength(), bt = Ke || Math.max(1, Qe);
        ne(Qe <= bt, "byte array longer than desired length"), ne(bt > 0, "Requested array length <= 0"), this.strip();
        var wt = Xe === "le", xt = new Je(bt), Bt, $t, qt = this.clone();
        if (wt) {
          for ($t = 0; !qt.isZero(); $t++)
            Bt = qt.andln(255), qt.iushrn(8), xt[$t] = Bt;
          for (; $t < bt; $t++)
            xt[$t] = 0;
        } else {
          for ($t = 0; $t < bt - Qe; $t++)
            xt[$t] = 0;
          for ($t = 0; !qt.isZero(); $t++)
            Bt = qt.andln(255), qt.iushrn(8), xt[bt - $t - 1] = Bt;
        }
        return xt;
      }, Math.clz32 ? ie.prototype._countBits = function(Je) {
        return 32 - Math.clz32(Je);
      } : ie.prototype._countBits = function(Je) {
        var Xe = Je, Ke = 0;
        return Xe >= 4096 && (Ke += 13, Xe >>>= 13), Xe >= 64 && (Ke += 7, Xe >>>= 7), Xe >= 8 && (Ke += 4, Xe >>>= 4), Xe >= 2 && (Ke += 2, Xe >>>= 2), Ke + Xe;
      }, ie.prototype._zeroBits = function(Je) {
        if (Je === 0) return 26;
        var Xe = Je, Ke = 0;
        return Xe & 8191 || (Ke += 13, Xe >>>= 13), Xe & 127 || (Ke += 7, Xe >>>= 7), Xe & 15 || (Ke += 4, Xe >>>= 4), Xe & 3 || (Ke += 2, Xe >>>= 2), Xe & 1 || Ke++, Ke;
      }, ie.prototype.bitLength = function() {
        var Je = this.words[this.length - 1], Xe = this._countBits(Je);
        return (this.length - 1) * 26 + Xe;
      };
      function Pe(Nt) {
        for (var Je = new Array(Nt.bitLength()), Xe = 0; Xe < Je.length; Xe++) {
          var Ke = Xe / 26 | 0, Qe = Xe % 26;
          Je[Xe] = (Nt.words[Ke] & 1 << Qe) >>> Qe;
        }
        return Je;
      }
      ie.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Je = 0, Xe = 0; Xe < this.length; Xe++) {
          var Ke = this._zeroBits(this.words[Xe]);
          if (Je += Ke, Ke !== 26) break;
        }
        return Je;
      }, ie.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ie.prototype.toTwos = function(Je) {
        return this.negative !== 0 ? this.abs().inotn(Je).iaddn(1) : this.clone();
      }, ie.prototype.fromTwos = function(Je) {
        return this.testn(Je - 1) ? this.notn(Je).iaddn(1).ineg() : this.clone();
      }, ie.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ie.prototype.neg = function() {
        return this.clone().ineg();
      }, ie.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ie.prototype.iuor = function(Je) {
        for (; this.length < Je.length; )
          this.words[this.length++] = 0;
        for (var Xe = 0; Xe < Je.length; Xe++)
          this.words[Xe] = this.words[Xe] | Je.words[Xe];
        return this.strip();
      }, ie.prototype.ior = function(Je) {
        return ne((this.negative | Je.negative) === 0), this.iuor(Je);
      }, ie.prototype.or = function(Je) {
        return this.length > Je.length ? this.clone().ior(Je) : Je.clone().ior(this);
      }, ie.prototype.uor = function(Je) {
        return this.length > Je.length ? this.clone().iuor(Je) : Je.clone().iuor(this);
      }, ie.prototype.iuand = function(Je) {
        var Xe;
        this.length > Je.length ? Xe = Je : Xe = this;
        for (var Ke = 0; Ke < Xe.length; Ke++)
          this.words[Ke] = this.words[Ke] & Je.words[Ke];
        return this.length = Xe.length, this.strip();
      }, ie.prototype.iand = function(Je) {
        return ne((this.negative | Je.negative) === 0), this.iuand(Je);
      }, ie.prototype.and = function(Je) {
        return this.length > Je.length ? this.clone().iand(Je) : Je.clone().iand(this);
      }, ie.prototype.uand = function(Je) {
        return this.length > Je.length ? this.clone().iuand(Je) : Je.clone().iuand(this);
      }, ie.prototype.iuxor = function(Je) {
        var Xe, Ke;
        this.length > Je.length ? (Xe = this, Ke = Je) : (Xe = Je, Ke = this);
        for (var Qe = 0; Qe < Ke.length; Qe++)
          this.words[Qe] = Xe.words[Qe] ^ Ke.words[Qe];
        if (this !== Xe)
          for (; Qe < Xe.length; Qe++)
            this.words[Qe] = Xe.words[Qe];
        return this.length = Xe.length, this.strip();
      }, ie.prototype.ixor = function(Je) {
        return ne((this.negative | Je.negative) === 0), this.iuxor(Je);
      }, ie.prototype.xor = function(Je) {
        return this.length > Je.length ? this.clone().ixor(Je) : Je.clone().ixor(this);
      }, ie.prototype.uxor = function(Je) {
        return this.length > Je.length ? this.clone().iuxor(Je) : Je.clone().iuxor(this);
      }, ie.prototype.inotn = function(Je) {
        ne(typeof Je == "number" && Je >= 0);
        var Xe = Math.ceil(Je / 26) | 0, Ke = Je % 26;
        this._expand(Xe), Ke > 0 && Xe--;
        for (var Qe = 0; Qe < Xe; Qe++)
          this.words[Qe] = ~this.words[Qe] & 67108863;
        return Ke > 0 && (this.words[Qe] = ~this.words[Qe] & 67108863 >> 26 - Ke), this.strip();
      }, ie.prototype.notn = function(Je) {
        return this.clone().inotn(Je);
      }, ie.prototype.setn = function(Je, Xe) {
        ne(typeof Je == "number" && Je >= 0);
        var Ke = Je / 26 | 0, Qe = Je % 26;
        return this._expand(Ke + 1), Xe ? this.words[Ke] = this.words[Ke] | 1 << Qe : this.words[Ke] = this.words[Ke] & ~(1 << Qe), this.strip();
      }, ie.prototype.iadd = function(Je) {
        var Xe;
        if (this.negative !== 0 && Je.negative === 0)
          return this.negative = 0, Xe = this.isub(Je), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Je.negative !== 0)
          return Je.negative = 0, Xe = this.isub(Je), Je.negative = 1, Xe._normSign();
        var Ke, Qe;
        this.length > Je.length ? (Ke = this, Qe = Je) : (Ke = Je, Qe = this);
        for (var bt = 0, wt = 0; wt < Qe.length; wt++)
          Xe = (Ke.words[wt] | 0) + (Qe.words[wt] | 0) + bt, this.words[wt] = Xe & 67108863, bt = Xe >>> 26;
        for (; bt !== 0 && wt < Ke.length; wt++)
          Xe = (Ke.words[wt] | 0) + bt, this.words[wt] = Xe & 67108863, bt = Xe >>> 26;
        if (this.length = Ke.length, bt !== 0)
          this.words[this.length] = bt, this.length++;
        else if (Ke !== this)
          for (; wt < Ke.length; wt++)
            this.words[wt] = Ke.words[wt];
        return this;
      }, ie.prototype.add = function(Je) {
        var Xe;
        return Je.negative !== 0 && this.negative === 0 ? (Je.negative = 0, Xe = this.sub(Je), Je.negative ^= 1, Xe) : Je.negative === 0 && this.negative !== 0 ? (this.negative = 0, Xe = Je.sub(this), this.negative = 1, Xe) : this.length > Je.length ? this.clone().iadd(Je) : Je.clone().iadd(this);
      }, ie.prototype.isub = function(Je) {
        if (Je.negative !== 0) {
          Je.negative = 0;
          var Xe = this.iadd(Je);
          return Je.negative = 1, Xe._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Je), this.negative = 1, this._normSign();
        var Ke = this.cmp(Je);
        if (Ke === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var Qe, bt;
        Ke > 0 ? (Qe = this, bt = Je) : (Qe = Je, bt = this);
        for (var wt = 0, xt = 0; xt < bt.length; xt++)
          Xe = (Qe.words[xt] | 0) - (bt.words[xt] | 0) + wt, wt = Xe >> 26, this.words[xt] = Xe & 67108863;
        for (; wt !== 0 && xt < Qe.length; xt++)
          Xe = (Qe.words[xt] | 0) + wt, wt = Xe >> 26, this.words[xt] = Xe & 67108863;
        if (wt === 0 && xt < Qe.length && Qe !== this)
          for (; xt < Qe.length; xt++)
            this.words[xt] = Qe.words[xt];
        return this.length = Math.max(this.length, xt), Qe !== this && (this.negative = 1), this.strip();
      }, ie.prototype.sub = function(Je) {
        return this.clone().isub(Je);
      };
      function Ve(Nt, Je, Xe) {
        Xe.negative = Je.negative ^ Nt.negative;
        var Ke = Nt.length + Je.length | 0;
        Xe.length = Ke, Ke = Ke - 1 | 0;
        var Qe = Nt.words[0] | 0, bt = Je.words[0] | 0, wt = Qe * bt, xt = wt & 67108863, Bt = wt / 67108864 | 0;
        Xe.words[0] = xt;
        for (var $t = 1; $t < Ke; $t++) {
          for (var qt = Bt >>> 26, Rt = Bt & 67108863, Lt = Math.min($t, Je.length - 1), tr = Math.max(0, $t - Nt.length + 1); tr <= Lt; tr++) {
            var sr = $t - tr | 0;
            Qe = Nt.words[sr] | 0, bt = Je.words[tr] | 0, wt = Qe * bt + Rt, qt += wt / 67108864 | 0, Rt = wt & 67108863;
          }
          Xe.words[$t] = Rt | 0, Bt = qt | 0;
        }
        return Bt !== 0 ? Xe.words[$t] = Bt | 0 : Xe.length--, Xe.strip();
      }
      var ht = function(Je, Xe, Ke) {
        var Qe = Je.words, bt = Xe.words, wt = Ke.words, xt = 0, Bt, $t, qt, Rt = Qe[0] | 0, Lt = Rt & 8191, tr = Rt >>> 13, sr = Qe[1] | 0, Zt = sr & 8191, Wt = sr >>> 13, Gt = Qe[2] | 0, rr = Gt & 8191, or = Gt >>> 13, Xt = Qe[3] | 0, zt = Xt & 8191, ur = Xt >>> 13, pr = Qe[4] | 0, vr = pr & 8191, _r = pr >>> 13, xr = Qe[5] | 0, Tr = xr & 8191, hr = xr >>> 13, Wr = Qe[6] | 0, $r = Wr & 8191, Ur = Wr >>> 13, Gr = Qe[7] | 0, Rr = Gr & 8191, Hr = Gr >>> 13, Xr = Qe[8] | 0, qr = Xr & 8191, zr = Xr >>> 13, Qr = Qe[9] | 0, Vt = Qr & 8191, Ft = Qr >>> 13, Ut = bt[0] | 0, Qt = Ut & 8191, fr = Ut >>> 13, cr = bt[1] | 0, lr = cr & 8191, kr = cr >>> 13, jr = bt[2] | 0, Br = jr & 8191, Dr = jr >>> 13, Lr = bt[3] | 0, Nr = Lr & 8191, Yr = Lr >>> 13, Zr = bt[4] | 0, nr = Zr & 8191, Jt = Zr >>> 13, ir = bt[5] | 0, ar = ir & 8191, dr = ir >>> 13, yr = bt[6] | 0, gr = yr & 8191, Er = yr >>> 13, Pr = bt[7] | 0, Ar = Pr & 8191, Mr = Pr >>> 13, Cr = bt[8] | 0, er = Cr & 8191, br = Cr >>> 13, wr = bt[9] | 0, Sr = wr & 8191, Or = wr >>> 13;
        Ke.negative = Je.negative ^ Xe.negative, Ke.length = 19, Bt = Math.imul(Lt, Qt), $t = Math.imul(Lt, fr), $t = $t + Math.imul(tr, Qt) | 0, qt = Math.imul(tr, fr);
        var Fr = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, Bt = Math.imul(Zt, Qt), $t = Math.imul(Zt, fr), $t = $t + Math.imul(Wt, Qt) | 0, qt = Math.imul(Wt, fr), Bt = Bt + Math.imul(Lt, lr) | 0, $t = $t + Math.imul(Lt, kr) | 0, $t = $t + Math.imul(tr, lr) | 0, qt = qt + Math.imul(tr, kr) | 0;
        var Ir = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (Ir >>> 26) | 0, Ir &= 67108863, Bt = Math.imul(rr, Qt), $t = Math.imul(rr, fr), $t = $t + Math.imul(or, Qt) | 0, qt = Math.imul(or, fr), Bt = Bt + Math.imul(Zt, lr) | 0, $t = $t + Math.imul(Zt, kr) | 0, $t = $t + Math.imul(Wt, lr) | 0, qt = qt + Math.imul(Wt, kr) | 0, Bt = Bt + Math.imul(Lt, Br) | 0, $t = $t + Math.imul(Lt, Dr) | 0, $t = $t + Math.imul(tr, Br) | 0, qt = qt + Math.imul(tr, Dr) | 0;
        var Vr = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, Bt = Math.imul(zt, Qt), $t = Math.imul(zt, fr), $t = $t + Math.imul(ur, Qt) | 0, qt = Math.imul(ur, fr), Bt = Bt + Math.imul(rr, lr) | 0, $t = $t + Math.imul(rr, kr) | 0, $t = $t + Math.imul(or, lr) | 0, qt = qt + Math.imul(or, kr) | 0, Bt = Bt + Math.imul(Zt, Br) | 0, $t = $t + Math.imul(Zt, Dr) | 0, $t = $t + Math.imul(Wt, Br) | 0, qt = qt + Math.imul(Wt, Dr) | 0, Bt = Bt + Math.imul(Lt, Nr) | 0, $t = $t + Math.imul(Lt, Yr) | 0, $t = $t + Math.imul(tr, Nr) | 0, qt = qt + Math.imul(tr, Yr) | 0;
        var tn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, Bt = Math.imul(vr, Qt), $t = Math.imul(vr, fr), $t = $t + Math.imul(_r, Qt) | 0, qt = Math.imul(_r, fr), Bt = Bt + Math.imul(zt, lr) | 0, $t = $t + Math.imul(zt, kr) | 0, $t = $t + Math.imul(ur, lr) | 0, qt = qt + Math.imul(ur, kr) | 0, Bt = Bt + Math.imul(rr, Br) | 0, $t = $t + Math.imul(rr, Dr) | 0, $t = $t + Math.imul(or, Br) | 0, qt = qt + Math.imul(or, Dr) | 0, Bt = Bt + Math.imul(Zt, Nr) | 0, $t = $t + Math.imul(Zt, Yr) | 0, $t = $t + Math.imul(Wt, Nr) | 0, qt = qt + Math.imul(Wt, Yr) | 0, Bt = Bt + Math.imul(Lt, nr) | 0, $t = $t + Math.imul(Lt, Jt) | 0, $t = $t + Math.imul(tr, nr) | 0, qt = qt + Math.imul(tr, Jt) | 0;
        var Jr = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, Bt = Math.imul(Tr, Qt), $t = Math.imul(Tr, fr), $t = $t + Math.imul(hr, Qt) | 0, qt = Math.imul(hr, fr), Bt = Bt + Math.imul(vr, lr) | 0, $t = $t + Math.imul(vr, kr) | 0, $t = $t + Math.imul(_r, lr) | 0, qt = qt + Math.imul(_r, kr) | 0, Bt = Bt + Math.imul(zt, Br) | 0, $t = $t + Math.imul(zt, Dr) | 0, $t = $t + Math.imul(ur, Br) | 0, qt = qt + Math.imul(ur, Dr) | 0, Bt = Bt + Math.imul(rr, Nr) | 0, $t = $t + Math.imul(rr, Yr) | 0, $t = $t + Math.imul(or, Nr) | 0, qt = qt + Math.imul(or, Yr) | 0, Bt = Bt + Math.imul(Zt, nr) | 0, $t = $t + Math.imul(Zt, Jt) | 0, $t = $t + Math.imul(Wt, nr) | 0, qt = qt + Math.imul(Wt, Jt) | 0, Bt = Bt + Math.imul(Lt, ar) | 0, $t = $t + Math.imul(Lt, dr) | 0, $t = $t + Math.imul(tr, ar) | 0, qt = qt + Math.imul(tr, dr) | 0;
        var en = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, Bt = Math.imul($r, Qt), $t = Math.imul($r, fr), $t = $t + Math.imul(Ur, Qt) | 0, qt = Math.imul(Ur, fr), Bt = Bt + Math.imul(Tr, lr) | 0, $t = $t + Math.imul(Tr, kr) | 0, $t = $t + Math.imul(hr, lr) | 0, qt = qt + Math.imul(hr, kr) | 0, Bt = Bt + Math.imul(vr, Br) | 0, $t = $t + Math.imul(vr, Dr) | 0, $t = $t + Math.imul(_r, Br) | 0, qt = qt + Math.imul(_r, Dr) | 0, Bt = Bt + Math.imul(zt, Nr) | 0, $t = $t + Math.imul(zt, Yr) | 0, $t = $t + Math.imul(ur, Nr) | 0, qt = qt + Math.imul(ur, Yr) | 0, Bt = Bt + Math.imul(rr, nr) | 0, $t = $t + Math.imul(rr, Jt) | 0, $t = $t + Math.imul(or, nr) | 0, qt = qt + Math.imul(or, Jt) | 0, Bt = Bt + Math.imul(Zt, ar) | 0, $t = $t + Math.imul(Zt, dr) | 0, $t = $t + Math.imul(Wt, ar) | 0, qt = qt + Math.imul(Wt, dr) | 0, Bt = Bt + Math.imul(Lt, gr) | 0, $t = $t + Math.imul(Lt, Er) | 0, $t = $t + Math.imul(tr, gr) | 0, qt = qt + Math.imul(tr, Er) | 0;
        var an = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, Bt = Math.imul(Rr, Qt), $t = Math.imul(Rr, fr), $t = $t + Math.imul(Hr, Qt) | 0, qt = Math.imul(Hr, fr), Bt = Bt + Math.imul($r, lr) | 0, $t = $t + Math.imul($r, kr) | 0, $t = $t + Math.imul(Ur, lr) | 0, qt = qt + Math.imul(Ur, kr) | 0, Bt = Bt + Math.imul(Tr, Br) | 0, $t = $t + Math.imul(Tr, Dr) | 0, $t = $t + Math.imul(hr, Br) | 0, qt = qt + Math.imul(hr, Dr) | 0, Bt = Bt + Math.imul(vr, Nr) | 0, $t = $t + Math.imul(vr, Yr) | 0, $t = $t + Math.imul(_r, Nr) | 0, qt = qt + Math.imul(_r, Yr) | 0, Bt = Bt + Math.imul(zt, nr) | 0, $t = $t + Math.imul(zt, Jt) | 0, $t = $t + Math.imul(ur, nr) | 0, qt = qt + Math.imul(ur, Jt) | 0, Bt = Bt + Math.imul(rr, ar) | 0, $t = $t + Math.imul(rr, dr) | 0, $t = $t + Math.imul(or, ar) | 0, qt = qt + Math.imul(or, dr) | 0, Bt = Bt + Math.imul(Zt, gr) | 0, $t = $t + Math.imul(Zt, Er) | 0, $t = $t + Math.imul(Wt, gr) | 0, qt = qt + Math.imul(Wt, Er) | 0, Bt = Bt + Math.imul(Lt, Ar) | 0, $t = $t + Math.imul(Lt, Mr) | 0, $t = $t + Math.imul(tr, Ar) | 0, qt = qt + Math.imul(tr, Mr) | 0;
        var on = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, Bt = Math.imul(qr, Qt), $t = Math.imul(qr, fr), $t = $t + Math.imul(zr, Qt) | 0, qt = Math.imul(zr, fr), Bt = Bt + Math.imul(Rr, lr) | 0, $t = $t + Math.imul(Rr, kr) | 0, $t = $t + Math.imul(Hr, lr) | 0, qt = qt + Math.imul(Hr, kr) | 0, Bt = Bt + Math.imul($r, Br) | 0, $t = $t + Math.imul($r, Dr) | 0, $t = $t + Math.imul(Ur, Br) | 0, qt = qt + Math.imul(Ur, Dr) | 0, Bt = Bt + Math.imul(Tr, Nr) | 0, $t = $t + Math.imul(Tr, Yr) | 0, $t = $t + Math.imul(hr, Nr) | 0, qt = qt + Math.imul(hr, Yr) | 0, Bt = Bt + Math.imul(vr, nr) | 0, $t = $t + Math.imul(vr, Jt) | 0, $t = $t + Math.imul(_r, nr) | 0, qt = qt + Math.imul(_r, Jt) | 0, Bt = Bt + Math.imul(zt, ar) | 0, $t = $t + Math.imul(zt, dr) | 0, $t = $t + Math.imul(ur, ar) | 0, qt = qt + Math.imul(ur, dr) | 0, Bt = Bt + Math.imul(rr, gr) | 0, $t = $t + Math.imul(rr, Er) | 0, $t = $t + Math.imul(or, gr) | 0, qt = qt + Math.imul(or, Er) | 0, Bt = Bt + Math.imul(Zt, Ar) | 0, $t = $t + Math.imul(Zt, Mr) | 0, $t = $t + Math.imul(Wt, Ar) | 0, qt = qt + Math.imul(Wt, Mr) | 0, Bt = Bt + Math.imul(Lt, er) | 0, $t = $t + Math.imul(Lt, br) | 0, $t = $t + Math.imul(tr, er) | 0, qt = qt + Math.imul(tr, br) | 0;
        var sn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, Bt = Math.imul(Vt, Qt), $t = Math.imul(Vt, fr), $t = $t + Math.imul(Ft, Qt) | 0, qt = Math.imul(Ft, fr), Bt = Bt + Math.imul(qr, lr) | 0, $t = $t + Math.imul(qr, kr) | 0, $t = $t + Math.imul(zr, lr) | 0, qt = qt + Math.imul(zr, kr) | 0, Bt = Bt + Math.imul(Rr, Br) | 0, $t = $t + Math.imul(Rr, Dr) | 0, $t = $t + Math.imul(Hr, Br) | 0, qt = qt + Math.imul(Hr, Dr) | 0, Bt = Bt + Math.imul($r, Nr) | 0, $t = $t + Math.imul($r, Yr) | 0, $t = $t + Math.imul(Ur, Nr) | 0, qt = qt + Math.imul(Ur, Yr) | 0, Bt = Bt + Math.imul(Tr, nr) | 0, $t = $t + Math.imul(Tr, Jt) | 0, $t = $t + Math.imul(hr, nr) | 0, qt = qt + Math.imul(hr, Jt) | 0, Bt = Bt + Math.imul(vr, ar) | 0, $t = $t + Math.imul(vr, dr) | 0, $t = $t + Math.imul(_r, ar) | 0, qt = qt + Math.imul(_r, dr) | 0, Bt = Bt + Math.imul(zt, gr) | 0, $t = $t + Math.imul(zt, Er) | 0, $t = $t + Math.imul(ur, gr) | 0, qt = qt + Math.imul(ur, Er) | 0, Bt = Bt + Math.imul(rr, Ar) | 0, $t = $t + Math.imul(rr, Mr) | 0, $t = $t + Math.imul(or, Ar) | 0, qt = qt + Math.imul(or, Mr) | 0, Bt = Bt + Math.imul(Zt, er) | 0, $t = $t + Math.imul(Zt, br) | 0, $t = $t + Math.imul(Wt, er) | 0, qt = qt + Math.imul(Wt, br) | 0, Bt = Bt + Math.imul(Lt, Sr) | 0, $t = $t + Math.imul(Lt, Or) | 0, $t = $t + Math.imul(tr, Sr) | 0, qt = qt + Math.imul(tr, Or) | 0;
        var nn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, Bt = Math.imul(Vt, lr), $t = Math.imul(Vt, kr), $t = $t + Math.imul(Ft, lr) | 0, qt = Math.imul(Ft, kr), Bt = Bt + Math.imul(qr, Br) | 0, $t = $t + Math.imul(qr, Dr) | 0, $t = $t + Math.imul(zr, Br) | 0, qt = qt + Math.imul(zr, Dr) | 0, Bt = Bt + Math.imul(Rr, Nr) | 0, $t = $t + Math.imul(Rr, Yr) | 0, $t = $t + Math.imul(Hr, Nr) | 0, qt = qt + Math.imul(Hr, Yr) | 0, Bt = Bt + Math.imul($r, nr) | 0, $t = $t + Math.imul($r, Jt) | 0, $t = $t + Math.imul(Ur, nr) | 0, qt = qt + Math.imul(Ur, Jt) | 0, Bt = Bt + Math.imul(Tr, ar) | 0, $t = $t + Math.imul(Tr, dr) | 0, $t = $t + Math.imul(hr, ar) | 0, qt = qt + Math.imul(hr, dr) | 0, Bt = Bt + Math.imul(vr, gr) | 0, $t = $t + Math.imul(vr, Er) | 0, $t = $t + Math.imul(_r, gr) | 0, qt = qt + Math.imul(_r, Er) | 0, Bt = Bt + Math.imul(zt, Ar) | 0, $t = $t + Math.imul(zt, Mr) | 0, $t = $t + Math.imul(ur, Ar) | 0, qt = qt + Math.imul(ur, Mr) | 0, Bt = Bt + Math.imul(rr, er) | 0, $t = $t + Math.imul(rr, br) | 0, $t = $t + Math.imul(or, er) | 0, qt = qt + Math.imul(or, br) | 0, Bt = Bt + Math.imul(Zt, Sr) | 0, $t = $t + Math.imul(Zt, Or) | 0, $t = $t + Math.imul(Wt, Sr) | 0, qt = qt + Math.imul(Wt, Or) | 0;
        var fn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, Bt = Math.imul(Vt, Br), $t = Math.imul(Vt, Dr), $t = $t + Math.imul(Ft, Br) | 0, qt = Math.imul(Ft, Dr), Bt = Bt + Math.imul(qr, Nr) | 0, $t = $t + Math.imul(qr, Yr) | 0, $t = $t + Math.imul(zr, Nr) | 0, qt = qt + Math.imul(zr, Yr) | 0, Bt = Bt + Math.imul(Rr, nr) | 0, $t = $t + Math.imul(Rr, Jt) | 0, $t = $t + Math.imul(Hr, nr) | 0, qt = qt + Math.imul(Hr, Jt) | 0, Bt = Bt + Math.imul($r, ar) | 0, $t = $t + Math.imul($r, dr) | 0, $t = $t + Math.imul(Ur, ar) | 0, qt = qt + Math.imul(Ur, dr) | 0, Bt = Bt + Math.imul(Tr, gr) | 0, $t = $t + Math.imul(Tr, Er) | 0, $t = $t + Math.imul(hr, gr) | 0, qt = qt + Math.imul(hr, Er) | 0, Bt = Bt + Math.imul(vr, Ar) | 0, $t = $t + Math.imul(vr, Mr) | 0, $t = $t + Math.imul(_r, Ar) | 0, qt = qt + Math.imul(_r, Mr) | 0, Bt = Bt + Math.imul(zt, er) | 0, $t = $t + Math.imul(zt, br) | 0, $t = $t + Math.imul(ur, er) | 0, qt = qt + Math.imul(ur, br) | 0, Bt = Bt + Math.imul(rr, Sr) | 0, $t = $t + Math.imul(rr, Or) | 0, $t = $t + Math.imul(or, Sr) | 0, qt = qt + Math.imul(or, Or) | 0;
        var un = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, Bt = Math.imul(Vt, Nr), $t = Math.imul(Vt, Yr), $t = $t + Math.imul(Ft, Nr) | 0, qt = Math.imul(Ft, Yr), Bt = Bt + Math.imul(qr, nr) | 0, $t = $t + Math.imul(qr, Jt) | 0, $t = $t + Math.imul(zr, nr) | 0, qt = qt + Math.imul(zr, Jt) | 0, Bt = Bt + Math.imul(Rr, ar) | 0, $t = $t + Math.imul(Rr, dr) | 0, $t = $t + Math.imul(Hr, ar) | 0, qt = qt + Math.imul(Hr, dr) | 0, Bt = Bt + Math.imul($r, gr) | 0, $t = $t + Math.imul($r, Er) | 0, $t = $t + Math.imul(Ur, gr) | 0, qt = qt + Math.imul(Ur, Er) | 0, Bt = Bt + Math.imul(Tr, Ar) | 0, $t = $t + Math.imul(Tr, Mr) | 0, $t = $t + Math.imul(hr, Ar) | 0, qt = qt + Math.imul(hr, Mr) | 0, Bt = Bt + Math.imul(vr, er) | 0, $t = $t + Math.imul(vr, br) | 0, $t = $t + Math.imul(_r, er) | 0, qt = qt + Math.imul(_r, br) | 0, Bt = Bt + Math.imul(zt, Sr) | 0, $t = $t + Math.imul(zt, Or) | 0, $t = $t + Math.imul(ur, Sr) | 0, qt = qt + Math.imul(ur, Or) | 0;
        var cn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, Bt = Math.imul(Vt, nr), $t = Math.imul(Vt, Jt), $t = $t + Math.imul(Ft, nr) | 0, qt = Math.imul(Ft, Jt), Bt = Bt + Math.imul(qr, ar) | 0, $t = $t + Math.imul(qr, dr) | 0, $t = $t + Math.imul(zr, ar) | 0, qt = qt + Math.imul(zr, dr) | 0, Bt = Bt + Math.imul(Rr, gr) | 0, $t = $t + Math.imul(Rr, Er) | 0, $t = $t + Math.imul(Hr, gr) | 0, qt = qt + Math.imul(Hr, Er) | 0, Bt = Bt + Math.imul($r, Ar) | 0, $t = $t + Math.imul($r, Mr) | 0, $t = $t + Math.imul(Ur, Ar) | 0, qt = qt + Math.imul(Ur, Mr) | 0, Bt = Bt + Math.imul(Tr, er) | 0, $t = $t + Math.imul(Tr, br) | 0, $t = $t + Math.imul(hr, er) | 0, qt = qt + Math.imul(hr, br) | 0, Bt = Bt + Math.imul(vr, Sr) | 0, $t = $t + Math.imul(vr, Or) | 0, $t = $t + Math.imul(_r, Sr) | 0, qt = qt + Math.imul(_r, Or) | 0;
        var ln = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, Bt = Math.imul(Vt, ar), $t = Math.imul(Vt, dr), $t = $t + Math.imul(Ft, ar) | 0, qt = Math.imul(Ft, dr), Bt = Bt + Math.imul(qr, gr) | 0, $t = $t + Math.imul(qr, Er) | 0, $t = $t + Math.imul(zr, gr) | 0, qt = qt + Math.imul(zr, Er) | 0, Bt = Bt + Math.imul(Rr, Ar) | 0, $t = $t + Math.imul(Rr, Mr) | 0, $t = $t + Math.imul(Hr, Ar) | 0, qt = qt + Math.imul(Hr, Mr) | 0, Bt = Bt + Math.imul($r, er) | 0, $t = $t + Math.imul($r, br) | 0, $t = $t + Math.imul(Ur, er) | 0, qt = qt + Math.imul(Ur, br) | 0, Bt = Bt + Math.imul(Tr, Sr) | 0, $t = $t + Math.imul(Tr, Or) | 0, $t = $t + Math.imul(hr, Sr) | 0, qt = qt + Math.imul(hr, Or) | 0;
        var dn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, Bt = Math.imul(Vt, gr), $t = Math.imul(Vt, Er), $t = $t + Math.imul(Ft, gr) | 0, qt = Math.imul(Ft, Er), Bt = Bt + Math.imul(qr, Ar) | 0, $t = $t + Math.imul(qr, Mr) | 0, $t = $t + Math.imul(zr, Ar) | 0, qt = qt + Math.imul(zr, Mr) | 0, Bt = Bt + Math.imul(Rr, er) | 0, $t = $t + Math.imul(Rr, br) | 0, $t = $t + Math.imul(Hr, er) | 0, qt = qt + Math.imul(Hr, br) | 0, Bt = Bt + Math.imul($r, Sr) | 0, $t = $t + Math.imul($r, Or) | 0, $t = $t + Math.imul(Ur, Sr) | 0, qt = qt + Math.imul(Ur, Or) | 0;
        var hn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, Bt = Math.imul(Vt, Ar), $t = Math.imul(Vt, Mr), $t = $t + Math.imul(Ft, Ar) | 0, qt = Math.imul(Ft, Mr), Bt = Bt + Math.imul(qr, er) | 0, $t = $t + Math.imul(qr, br) | 0, $t = $t + Math.imul(zr, er) | 0, qt = qt + Math.imul(zr, br) | 0, Bt = Bt + Math.imul(Rr, Sr) | 0, $t = $t + Math.imul(Rr, Or) | 0, $t = $t + Math.imul(Hr, Sr) | 0, qt = qt + Math.imul(Hr, Or) | 0;
        var pn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, Bt = Math.imul(Vt, er), $t = Math.imul(Vt, br), $t = $t + Math.imul(Ft, er) | 0, qt = Math.imul(Ft, br), Bt = Bt + Math.imul(qr, Sr) | 0, $t = $t + Math.imul(qr, Or) | 0, $t = $t + Math.imul(zr, Sr) | 0, qt = qt + Math.imul(zr, Or) | 0;
        var yn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        xt = (qt + ($t >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, Bt = Math.imul(Vt, Sr), $t = Math.imul(Vt, Or), $t = $t + Math.imul(Ft, Sr) | 0, qt = Math.imul(Ft, Or);
        var vn = (xt + Bt | 0) + (($t & 8191) << 13) | 0;
        return xt = (qt + ($t >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, wt[0] = Fr, wt[1] = Ir, wt[2] = Vr, wt[3] = tn, wt[4] = Jr, wt[5] = en, wt[6] = an, wt[7] = on, wt[8] = sn, wt[9] = nn, wt[10] = fn, wt[11] = un, wt[12] = cn, wt[13] = ln, wt[14] = dn, wt[15] = hn, wt[16] = pn, wt[17] = yn, wt[18] = vn, xt !== 0 && (wt[19] = xt, Ke.length++), Ke;
      };
      Math.imul || (ht = Ve);
      function vt(Nt, Je, Xe) {
        Xe.negative = Je.negative ^ Nt.negative, Xe.length = Nt.length + Je.length;
        for (var Ke = 0, Qe = 0, bt = 0; bt < Xe.length - 1; bt++) {
          var wt = Qe;
          Qe = 0;
          for (var xt = Ke & 67108863, Bt = Math.min(bt, Je.length - 1), $t = Math.max(0, bt - Nt.length + 1); $t <= Bt; $t++) {
            var qt = bt - $t, Rt = Nt.words[qt] | 0, Lt = Je.words[$t] | 0, tr = Rt * Lt, sr = tr & 67108863;
            wt = wt + (tr / 67108864 | 0) | 0, sr = sr + xt | 0, xt = sr & 67108863, wt = wt + (sr >>> 26) | 0, Qe += wt >>> 26, wt &= 67108863;
          }
          Xe.words[bt] = xt, Ke = wt, wt = Qe;
        }
        return Ke !== 0 ? Xe.words[bt] = Ke : Xe.length--, Xe.strip();
      }
      function Pt(Nt, Je, Xe) {
        var Ke = new _t();
        return Ke.mulp(Nt, Je, Xe);
      }
      ie.prototype.mulTo = function(Je, Xe) {
        var Ke, Qe = this.length + Je.length;
        return this.length === 10 && Je.length === 10 ? Ke = ht(this, Je, Xe) : Qe < 63 ? Ke = Ve(this, Je, Xe) : Qe < 1024 ? Ke = vt(this, Je, Xe) : Ke = Pt(this, Je, Xe), Ke;
      };
      function _t(Nt, Je) {
        this.x = Nt, this.y = Je;
      }
      _t.prototype.makeRBT = function(Je) {
        for (var Xe = new Array(Je), Ke = ie.prototype._countBits(Je) - 1, Qe = 0; Qe < Je; Qe++)
          Xe[Qe] = this.revBin(Qe, Ke, Je);
        return Xe;
      }, _t.prototype.revBin = function(Je, Xe, Ke) {
        if (Je === 0 || Je === Ke - 1) return Je;
        for (var Qe = 0, bt = 0; bt < Xe; bt++)
          Qe |= (Je & 1) << Xe - bt - 1, Je >>= 1;
        return Qe;
      }, _t.prototype.permute = function(Je, Xe, Ke, Qe, bt, wt) {
        for (var xt = 0; xt < wt; xt++)
          Qe[xt] = Xe[Je[xt]], bt[xt] = Ke[Je[xt]];
      }, _t.prototype.transform = function(Je, Xe, Ke, Qe, bt, wt) {
        this.permute(wt, Je, Xe, Ke, Qe, bt);
        for (var xt = 1; xt < bt; xt <<= 1)
          for (var Bt = xt << 1, $t = Math.cos(2 * Math.PI / Bt), qt = Math.sin(2 * Math.PI / Bt), Rt = 0; Rt < bt; Rt += Bt)
            for (var Lt = $t, tr = qt, sr = 0; sr < xt; sr++) {
              var Zt = Ke[Rt + sr], Wt = Qe[Rt + sr], Gt = Ke[Rt + sr + xt], rr = Qe[Rt + sr + xt], or = Lt * Gt - tr * rr;
              rr = Lt * rr + tr * Gt, Gt = or, Ke[Rt + sr] = Zt + Gt, Qe[Rt + sr] = Wt + rr, Ke[Rt + sr + xt] = Zt - Gt, Qe[Rt + sr + xt] = Wt - rr, sr !== Bt && (or = $t * Lt - qt * tr, tr = $t * tr + qt * Lt, Lt = or);
            }
      }, _t.prototype.guessLen13b = function(Je, Xe) {
        var Ke = Math.max(Xe, Je) | 1, Qe = Ke & 1, bt = 0;
        for (Ke = Ke / 2 | 0; Ke; Ke = Ke >>> 1)
          bt++;
        return 1 << bt + 1 + Qe;
      }, _t.prototype.conjugate = function(Je, Xe, Ke) {
        if (!(Ke <= 1))
          for (var Qe = 0; Qe < Ke / 2; Qe++) {
            var bt = Je[Qe];
            Je[Qe] = Je[Ke - Qe - 1], Je[Ke - Qe - 1] = bt, bt = Xe[Qe], Xe[Qe] = -Xe[Ke - Qe - 1], Xe[Ke - Qe - 1] = -bt;
          }
      }, _t.prototype.normalize13b = function(Je, Xe) {
        for (var Ke = 0, Qe = 0; Qe < Xe / 2; Qe++) {
          var bt = Math.round(Je[2 * Qe + 1] / Xe) * 8192 + Math.round(Je[2 * Qe] / Xe) + Ke;
          Je[Qe] = bt & 67108863, bt < 67108864 ? Ke = 0 : Ke = bt / 67108864 | 0;
        }
        return Je;
      }, _t.prototype.convert13b = function(Je, Xe, Ke, Qe) {
        for (var bt = 0, wt = 0; wt < Xe; wt++)
          bt = bt + (Je[wt] | 0), Ke[2 * wt] = bt & 8191, bt = bt >>> 13, Ke[2 * wt + 1] = bt & 8191, bt = bt >>> 13;
        for (wt = 2 * Xe; wt < Qe; ++wt)
          Ke[wt] = 0;
        ne(bt === 0), ne((bt & -8192) === 0);
      }, _t.prototype.stub = function(Je) {
        for (var Xe = new Array(Je), Ke = 0; Ke < Je; Ke++)
          Xe[Ke] = 0;
        return Xe;
      }, _t.prototype.mulp = function(Je, Xe, Ke) {
        var Qe = 2 * this.guessLen13b(Je.length, Xe.length), bt = this.makeRBT(Qe), wt = this.stub(Qe), xt = new Array(Qe), Bt = new Array(Qe), $t = new Array(Qe), qt = new Array(Qe), Rt = new Array(Qe), Lt = new Array(Qe), tr = Ke.words;
        tr.length = Qe, this.convert13b(Je.words, Je.length, xt, Qe), this.convert13b(Xe.words, Xe.length, qt, Qe), this.transform(xt, wt, Bt, $t, Qe, bt), this.transform(qt, wt, Rt, Lt, Qe, bt);
        for (var sr = 0; sr < Qe; sr++) {
          var Zt = Bt[sr] * Rt[sr] - $t[sr] * Lt[sr];
          $t[sr] = Bt[sr] * Lt[sr] + $t[sr] * Rt[sr], Bt[sr] = Zt;
        }
        return this.conjugate(Bt, $t, Qe), this.transform(Bt, $t, tr, wt, Qe, bt), this.conjugate(tr, wt, Qe), this.normalize13b(tr, Qe), Ke.negative = Je.negative ^ Xe.negative, Ke.length = Je.length + Xe.length, Ke.strip();
      }, ie.prototype.mul = function(Je) {
        var Xe = new ie(null);
        return Xe.words = new Array(this.length + Je.length), this.mulTo(Je, Xe);
      }, ie.prototype.mulf = function(Je) {
        var Xe = new ie(null);
        return Xe.words = new Array(this.length + Je.length), Pt(this, Je, Xe);
      }, ie.prototype.imul = function(Je) {
        return this.clone().mulTo(Je, this);
      }, ie.prototype.imuln = function(Je) {
        ne(typeof Je == "number"), ne(Je < 67108864);
        for (var Xe = 0, Ke = 0; Ke < this.length; Ke++) {
          var Qe = (this.words[Ke] | 0) * Je, bt = (Qe & 67108863) + (Xe & 67108863);
          Xe >>= 26, Xe += Qe / 67108864 | 0, Xe += bt >>> 26, this.words[Ke] = bt & 67108863;
        }
        return Xe !== 0 && (this.words[Ke] = Xe, this.length++), this;
      }, ie.prototype.muln = function(Je) {
        return this.clone().imuln(Je);
      }, ie.prototype.sqr = function() {
        return this.mul(this);
      }, ie.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ie.prototype.pow = function(Je) {
        var Xe = Pe(Je);
        if (Xe.length === 0) return new ie(1);
        for (var Ke = this, Qe = 0; Qe < Xe.length && Xe[Qe] === 0; Qe++, Ke = Ke.sqr())
          ;
        if (++Qe < Xe.length)
          for (var bt = Ke.sqr(); Qe < Xe.length; Qe++, bt = bt.sqr())
            Xe[Qe] !== 0 && (Ke = Ke.mul(bt));
        return Ke;
      }, ie.prototype.iushln = function(Je) {
        ne(typeof Je == "number" && Je >= 0);
        var Xe = Je % 26, Ke = (Je - Xe) / 26, Qe = 67108863 >>> 26 - Xe << 26 - Xe, bt;
        if (Xe !== 0) {
          var wt = 0;
          for (bt = 0; bt < this.length; bt++) {
            var xt = this.words[bt] & Qe, Bt = (this.words[bt] | 0) - xt << Xe;
            this.words[bt] = Bt | wt, wt = xt >>> 26 - Xe;
          }
          wt && (this.words[bt] = wt, this.length++);
        }
        if (Ke !== 0) {
          for (bt = this.length - 1; bt >= 0; bt--)
            this.words[bt + Ke] = this.words[bt];
          for (bt = 0; bt < Ke; bt++)
            this.words[bt] = 0;
          this.length += Ke;
        }
        return this.strip();
      }, ie.prototype.ishln = function(Je) {
        return ne(this.negative === 0), this.iushln(Je);
      }, ie.prototype.iushrn = function(Je, Xe, Ke) {
        ne(typeof Je == "number" && Je >= 0);
        var Qe;
        Xe ? Qe = (Xe - Xe % 26) / 26 : Qe = 0;
        var bt = Je % 26, wt = Math.min((Je - bt) / 26, this.length), xt = 67108863 ^ 67108863 >>> bt << bt, Bt = Ke;
        if (Qe -= wt, Qe = Math.max(0, Qe), Bt) {
          for (var $t = 0; $t < wt; $t++)
            Bt.words[$t] = this.words[$t];
          Bt.length = wt;
        }
        if (wt !== 0) if (this.length > wt)
          for (this.length -= wt, $t = 0; $t < this.length; $t++)
            this.words[$t] = this.words[$t + wt];
        else
          this.words[0] = 0, this.length = 1;
        var qt = 0;
        for ($t = this.length - 1; $t >= 0 && (qt !== 0 || $t >= Qe); $t--) {
          var Rt = this.words[$t] | 0;
          this.words[$t] = qt << 26 - bt | Rt >>> bt, qt = Rt & xt;
        }
        return Bt && qt !== 0 && (Bt.words[Bt.length++] = qt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, ie.prototype.ishrn = function(Je, Xe, Ke) {
        return ne(this.negative === 0), this.iushrn(Je, Xe, Ke);
      }, ie.prototype.shln = function(Je) {
        return this.clone().ishln(Je);
      }, ie.prototype.ushln = function(Je) {
        return this.clone().iushln(Je);
      }, ie.prototype.shrn = function(Je) {
        return this.clone().ishrn(Je);
      }, ie.prototype.ushrn = function(Je) {
        return this.clone().iushrn(Je);
      }, ie.prototype.testn = function(Je) {
        ne(typeof Je == "number" && Je >= 0);
        var Xe = Je % 26, Ke = (Je - Xe) / 26, Qe = 1 << Xe;
        if (this.length <= Ke) return !1;
        var bt = this.words[Ke];
        return !!(bt & Qe);
      }, ie.prototype.imaskn = function(Je) {
        ne(typeof Je == "number" && Je >= 0);
        var Xe = Je % 26, Ke = (Je - Xe) / 26;
        if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ke)
          return this;
        if (Xe !== 0 && Ke++, this.length = Math.min(Ke, this.length), Xe !== 0) {
          var Qe = 67108863 ^ 67108863 >>> Xe << Xe;
          this.words[this.length - 1] &= Qe;
        }
        return this.strip();
      }, ie.prototype.maskn = function(Je) {
        return this.clone().imaskn(Je);
      }, ie.prototype.iaddn = function(Je) {
        return ne(typeof Je == "number"), ne(Je < 67108864), Je < 0 ? this.isubn(-Je) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Je ? (this.words[0] = Je - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Je), this.negative = 1, this) : this._iaddn(Je);
      }, ie.prototype._iaddn = function(Je) {
        this.words[0] += Je;
        for (var Xe = 0; Xe < this.length && this.words[Xe] >= 67108864; Xe++)
          this.words[Xe] -= 67108864, Xe === this.length - 1 ? this.words[Xe + 1] = 1 : this.words[Xe + 1]++;
        return this.length = Math.max(this.length, Xe + 1), this;
      }, ie.prototype.isubn = function(Je) {
        if (ne(typeof Je == "number"), ne(Je < 67108864), Je < 0) return this.iaddn(-Je);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Je), this.negative = 1, this;
        if (this.words[0] -= Je, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Xe = 0; Xe < this.length && this.words[Xe] < 0; Xe++)
            this.words[Xe] += 67108864, this.words[Xe + 1] -= 1;
        return this.strip();
      }, ie.prototype.addn = function(Je) {
        return this.clone().iaddn(Je);
      }, ie.prototype.subn = function(Je) {
        return this.clone().isubn(Je);
      }, ie.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ie.prototype.abs = function() {
        return this.clone().iabs();
      }, ie.prototype._ishlnsubmul = function(Je, Xe, Ke) {
        var Qe = Je.length + Ke, bt;
        this._expand(Qe);
        var wt, xt = 0;
        for (bt = 0; bt < Je.length; bt++) {
          wt = (this.words[bt + Ke] | 0) + xt;
          var Bt = (Je.words[bt] | 0) * Xe;
          wt -= Bt & 67108863, xt = (wt >> 26) - (Bt / 67108864 | 0), this.words[bt + Ke] = wt & 67108863;
        }
        for (; bt < this.length - Ke; bt++)
          wt = (this.words[bt + Ke] | 0) + xt, xt = wt >> 26, this.words[bt + Ke] = wt & 67108863;
        if (xt === 0) return this.strip();
        for (ne(xt === -1), xt = 0, bt = 0; bt < this.length; bt++)
          wt = -(this.words[bt] | 0) + xt, xt = wt >> 26, this.words[bt] = wt & 67108863;
        return this.negative = 1, this.strip();
      }, ie.prototype._wordDiv = function(Je, Xe) {
        var Ke = this.length - Je.length, Qe = this.clone(), bt = Je, wt = bt.words[bt.length - 1] | 0, xt = this._countBits(wt);
        Ke = 26 - xt, Ke !== 0 && (bt = bt.ushln(Ke), Qe.iushln(Ke), wt = bt.words[bt.length - 1] | 0);
        var Bt = Qe.length - bt.length, $t;
        if (Xe !== "mod") {
          $t = new ie(null), $t.length = Bt + 1, $t.words = new Array($t.length);
          for (var qt = 0; qt < $t.length; qt++)
            $t.words[qt] = 0;
        }
        var Rt = Qe.clone()._ishlnsubmul(bt, 1, Bt);
        Rt.negative === 0 && (Qe = Rt, $t && ($t.words[Bt] = 1));
        for (var Lt = Bt - 1; Lt >= 0; Lt--) {
          var tr = (Qe.words[bt.length + Lt] | 0) * 67108864 + (Qe.words[bt.length + Lt - 1] | 0);
          for (tr = Math.min(tr / wt | 0, 67108863), Qe._ishlnsubmul(bt, tr, Lt); Qe.negative !== 0; )
            tr--, Qe.negative = 0, Qe._ishlnsubmul(bt, 1, Lt), Qe.isZero() || (Qe.negative ^= 1);
          $t && ($t.words[Lt] = tr);
        }
        return $t && $t.strip(), Qe.strip(), Xe !== "div" && Ke !== 0 && Qe.iushrn(Ke), {
          div: $t || null,
          mod: Qe
        };
      }, ie.prototype.divmod = function(Je, Xe, Ke) {
        if (ne(!Je.isZero()), this.isZero())
          return {
            div: new ie(0),
            mod: new ie(0)
          };
        var Qe, bt, wt;
        return this.negative !== 0 && Je.negative === 0 ? (wt = this.neg().divmod(Je, Xe), Xe !== "mod" && (Qe = wt.div.neg()), Xe !== "div" && (bt = wt.mod.neg(), Ke && bt.negative !== 0 && bt.iadd(Je)), {
          div: Qe,
          mod: bt
        }) : this.negative === 0 && Je.negative !== 0 ? (wt = this.divmod(Je.neg(), Xe), Xe !== "mod" && (Qe = wt.div.neg()), {
          div: Qe,
          mod: wt.mod
        }) : this.negative & Je.negative ? (wt = this.neg().divmod(Je.neg(), Xe), Xe !== "div" && (bt = wt.mod.neg(), Ke && bt.negative !== 0 && bt.isub(Je)), {
          div: wt.div,
          mod: bt
        }) : Je.length > this.length || this.cmp(Je) < 0 ? {
          div: new ie(0),
          mod: this
        } : Je.length === 1 ? Xe === "div" ? {
          div: this.divn(Je.words[0]),
          mod: null
        } : Xe === "mod" ? {
          div: null,
          mod: new ie(this.modn(Je.words[0]))
        } : {
          div: this.divn(Je.words[0]),
          mod: new ie(this.modn(Je.words[0]))
        } : this._wordDiv(Je, Xe);
      }, ie.prototype.div = function(Je) {
        return this.divmod(Je, "div", !1).div;
      }, ie.prototype.mod = function(Je) {
        return this.divmod(Je, "mod", !1).mod;
      }, ie.prototype.umod = function(Je) {
        return this.divmod(Je, "mod", !0).mod;
      }, ie.prototype.divRound = function(Je) {
        var Xe = this.divmod(Je);
        if (Xe.mod.isZero()) return Xe.div;
        var Ke = Xe.div.negative !== 0 ? Xe.mod.isub(Je) : Xe.mod, Qe = Je.ushrn(1), bt = Je.andln(1), wt = Ke.cmp(Qe);
        return wt < 0 || bt === 1 && wt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
      }, ie.prototype.modn = function(Je) {
        ne(Je <= 67108863);
        for (var Xe = (1 << 26) % Je, Ke = 0, Qe = this.length - 1; Qe >= 0; Qe--)
          Ke = (Xe * Ke + (this.words[Qe] | 0)) % Je;
        return Ke;
      }, ie.prototype.idivn = function(Je) {
        ne(Je <= 67108863);
        for (var Xe = 0, Ke = this.length - 1; Ke >= 0; Ke--) {
          var Qe = (this.words[Ke] | 0) + Xe * 67108864;
          this.words[Ke] = Qe / Je | 0, Xe = Qe % Je;
        }
        return this.strip();
      }, ie.prototype.divn = function(Je) {
        return this.clone().idivn(Je);
      }, ie.prototype.egcd = function(Je) {
        ne(Je.negative === 0), ne(!Je.isZero());
        var Xe = this, Ke = Je.clone();
        Xe.negative !== 0 ? Xe = Xe.umod(Je) : Xe = Xe.clone();
        for (var Qe = new ie(1), bt = new ie(0), wt = new ie(0), xt = new ie(1), Bt = 0; Xe.isEven() && Ke.isEven(); )
          Xe.iushrn(1), Ke.iushrn(1), ++Bt;
        for (var $t = Ke.clone(), qt = Xe.clone(); !Xe.isZero(); ) {
          for (var Rt = 0, Lt = 1; !(Xe.words[0] & Lt) && Rt < 26; ++Rt, Lt <<= 1) ;
          if (Rt > 0)
            for (Xe.iushrn(Rt); Rt-- > 0; )
              (Qe.isOdd() || bt.isOdd()) && (Qe.iadd($t), bt.isub(qt)), Qe.iushrn(1), bt.iushrn(1);
          for (var tr = 0, sr = 1; !(Ke.words[0] & sr) && tr < 26; ++tr, sr <<= 1) ;
          if (tr > 0)
            for (Ke.iushrn(tr); tr-- > 0; )
              (wt.isOdd() || xt.isOdd()) && (wt.iadd($t), xt.isub(qt)), wt.iushrn(1), xt.iushrn(1);
          Xe.cmp(Ke) >= 0 ? (Xe.isub(Ke), Qe.isub(wt), bt.isub(xt)) : (Ke.isub(Xe), wt.isub(Qe), xt.isub(bt));
        }
        return {
          a: wt,
          b: xt,
          gcd: Ke.iushln(Bt)
        };
      }, ie.prototype._invmp = function(Je) {
        ne(Je.negative === 0), ne(!Je.isZero());
        var Xe = this, Ke = Je.clone();
        Xe.negative !== 0 ? Xe = Xe.umod(Je) : Xe = Xe.clone();
        for (var Qe = new ie(1), bt = new ie(0), wt = Ke.clone(); Xe.cmpn(1) > 0 && Ke.cmpn(1) > 0; ) {
          for (var xt = 0, Bt = 1; !(Xe.words[0] & Bt) && xt < 26; ++xt, Bt <<= 1) ;
          if (xt > 0)
            for (Xe.iushrn(xt); xt-- > 0; )
              Qe.isOdd() && Qe.iadd(wt), Qe.iushrn(1);
          for (var $t = 0, qt = 1; !(Ke.words[0] & qt) && $t < 26; ++$t, qt <<= 1) ;
          if ($t > 0)
            for (Ke.iushrn($t); $t-- > 0; )
              bt.isOdd() && bt.iadd(wt), bt.iushrn(1);
          Xe.cmp(Ke) >= 0 ? (Xe.isub(Ke), Qe.isub(bt)) : (Ke.isub(Xe), bt.isub(Qe));
        }
        var Rt;
        return Xe.cmpn(1) === 0 ? Rt = Qe : Rt = bt, Rt.cmpn(0) < 0 && Rt.iadd(Je), Rt;
      }, ie.prototype.gcd = function(Je) {
        if (this.isZero()) return Je.abs();
        if (Je.isZero()) return this.abs();
        var Xe = this.clone(), Ke = Je.clone();
        Xe.negative = 0, Ke.negative = 0;
        for (var Qe = 0; Xe.isEven() && Ke.isEven(); Qe++)
          Xe.iushrn(1), Ke.iushrn(1);
        do {
          for (; Xe.isEven(); )
            Xe.iushrn(1);
          for (; Ke.isEven(); )
            Ke.iushrn(1);
          var bt = Xe.cmp(Ke);
          if (bt < 0) {
            var wt = Xe;
            Xe = Ke, Ke = wt;
          } else if (bt === 0 || Ke.cmpn(1) === 0)
            break;
          Xe.isub(Ke);
        } while (!0);
        return Ke.iushln(Qe);
      }, ie.prototype.invm = function(Je) {
        return this.egcd(Je).a.umod(Je);
      }, ie.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ie.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ie.prototype.andln = function(Je) {
        return this.words[0] & Je;
      }, ie.prototype.bincn = function(Je) {
        ne(typeof Je == "number");
        var Xe = Je % 26, Ke = (Je - Xe) / 26, Qe = 1 << Xe;
        if (this.length <= Ke)
          return this._expand(Ke + 1), this.words[Ke] |= Qe, this;
        for (var bt = Qe, wt = Ke; bt !== 0 && wt < this.length; wt++) {
          var xt = this.words[wt] | 0;
          xt += bt, bt = xt >>> 26, xt &= 67108863, this.words[wt] = xt;
        }
        return bt !== 0 && (this.words[wt] = bt, this.length++), this;
      }, ie.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ie.prototype.cmpn = function(Je) {
        var Xe = Je < 0;
        if (this.negative !== 0 && !Xe) return -1;
        if (this.negative === 0 && Xe) return 1;
        this.strip();
        var Ke;
        if (this.length > 1)
          Ke = 1;
        else {
          Xe && (Je = -Je), ne(Je <= 67108863, "Number is too big");
          var Qe = this.words[0] | 0;
          Ke = Qe === Je ? 0 : Qe < Je ? -1 : 1;
        }
        return this.negative !== 0 ? -Ke | 0 : Ke;
      }, ie.prototype.cmp = function(Je) {
        if (this.negative !== 0 && Je.negative === 0) return -1;
        if (this.negative === 0 && Je.negative !== 0) return 1;
        var Xe = this.ucmp(Je);
        return this.negative !== 0 ? -Xe | 0 : Xe;
      }, ie.prototype.ucmp = function(Je) {
        if (this.length > Je.length) return 1;
        if (this.length < Je.length) return -1;
        for (var Xe = 0, Ke = this.length - 1; Ke >= 0; Ke--) {
          var Qe = this.words[Ke] | 0, bt = Je.words[Ke] | 0;
          if (Qe !== bt) {
            Qe < bt ? Xe = -1 : Qe > bt && (Xe = 1);
            break;
          }
        }
        return Xe;
      }, ie.prototype.gtn = function(Je) {
        return this.cmpn(Je) === 1;
      }, ie.prototype.gt = function(Je) {
        return this.cmp(Je) === 1;
      }, ie.prototype.gten = function(Je) {
        return this.cmpn(Je) >= 0;
      }, ie.prototype.gte = function(Je) {
        return this.cmp(Je) >= 0;
      }, ie.prototype.ltn = function(Je) {
        return this.cmpn(Je) === -1;
      }, ie.prototype.lt = function(Je) {
        return this.cmp(Je) === -1;
      }, ie.prototype.lten = function(Je) {
        return this.cmpn(Je) <= 0;
      }, ie.prototype.lte = function(Je) {
        return this.cmp(Je) <= 0;
      }, ie.prototype.eqn = function(Je) {
        return this.cmpn(Je) === 0;
      }, ie.prototype.eq = function(Je) {
        return this.cmp(Je) === 0;
      }, ie.red = function(Je) {
        return new Ct(Je);
      }, ie.prototype.toRed = function(Je) {
        return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), Je.convertTo(this)._forceRed(Je);
      }, ie.prototype.fromRed = function() {
        return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ie.prototype._forceRed = function(Je) {
        return this.red = Je, this;
      }, ie.prototype.forceRed = function(Je) {
        return ne(!this.red, "Already a number in reduction context"), this._forceRed(Je);
      }, ie.prototype.redAdd = function(Je) {
        return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, Je);
      }, ie.prototype.redIAdd = function(Je) {
        return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Je);
      }, ie.prototype.redSub = function(Je) {
        return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, Je);
      }, ie.prototype.redISub = function(Je) {
        return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, Je);
      }, ie.prototype.redShl = function(Je) {
        return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, Je);
      }, ie.prototype.redMul = function(Je) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Je), this.red.mul(this, Je);
      }, ie.prototype.redIMul = function(Je) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Je), this.red.imul(this, Je);
      }, ie.prototype.redSqr = function() {
        return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ie.prototype.redISqr = function() {
        return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ie.prototype.redSqrt = function() {
        return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ie.prototype.redInvm = function() {
        return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ie.prototype.redNeg = function() {
        return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ie.prototype.redPow = function(Je) {
        return ne(this.red && !Je.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Je);
      };
      var kt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Ot(Nt, Je) {
        this.name = Nt, this.p = new ie(Je, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ot.prototype._tmp = function() {
        var Je = new ie(null);
        return Je.words = new Array(Math.ceil(this.n / 13)), Je;
      }, Ot.prototype.ireduce = function(Je) {
        var Xe = Je, Ke;
        do
          this.split(Xe, this.tmp), Xe = this.imulK(Xe), Xe = Xe.iadd(this.tmp), Ke = Xe.bitLength();
        while (Ke > this.n);
        var Qe = Ke < this.n ? -1 : Xe.ucmp(this.p);
        return Qe === 0 ? (Xe.words[0] = 0, Xe.length = 1) : Qe > 0 ? Xe.isub(this.p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
      }, Ot.prototype.split = function(Je, Xe) {
        Je.iushrn(this.n, 0, Xe);
      }, Ot.prototype.imulK = function(Je) {
        return Je.imul(this.k);
      };
      function Ht() {
        Ot.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      ae(Ht, Ot), Ht.prototype.split = function(Je, Xe) {
        for (var Ke = 4194303, Qe = Math.min(Je.length, 9), bt = 0; bt < Qe; bt++)
          Xe.words[bt] = Je.words[bt];
        if (Xe.length = Qe, Je.length <= 9) {
          Je.words[0] = 0, Je.length = 1;
          return;
        }
        var wt = Je.words[9];
        for (Xe.words[Xe.length++] = wt & Ke, bt = 10; bt < Je.length; bt++) {
          var xt = Je.words[bt] | 0;
          Je.words[bt - 10] = (xt & Ke) << 4 | wt >>> 22, wt = xt;
        }
        wt >>>= 22, Je.words[bt - 10] = wt, wt === 0 && Je.length > 10 ? Je.length -= 10 : Je.length -= 9;
      }, Ht.prototype.imulK = function(Je) {
        Je.words[Je.length] = 0, Je.words[Je.length + 1] = 0, Je.length += 2;
        for (var Xe = 0, Ke = 0; Ke < Je.length; Ke++) {
          var Qe = Je.words[Ke] | 0;
          Xe += Qe * 977, Je.words[Ke] = Xe & 67108863, Xe = Qe * 64 + (Xe / 67108864 | 0);
        }
        return Je.words[Je.length - 1] === 0 && (Je.length--, Je.words[Je.length - 1] === 0 && Je.length--), Je;
      };
      function jt() {
        Ot.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      ae(jt, Ot);
      function Yt() {
        Ot.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      ae(Yt, Ot);
      function Dt() {
        Ot.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      ae(Dt, Ot), Dt.prototype.imulK = function(Je) {
        for (var Xe = 0, Ke = 0; Ke < Je.length; Ke++) {
          var Qe = (Je.words[Ke] | 0) * 19 + Xe, bt = Qe & 67108863;
          Qe >>>= 26, Je.words[Ke] = bt, Xe = Qe;
        }
        return Xe !== 0 && (Je.words[Je.length++] = Xe), Je;
      }, ie._prime = function(Je) {
        if (kt[Je]) return kt[Je];
        var Xe;
        if (Je === "k256")
          Xe = new Ht();
        else if (Je === "p224")
          Xe = new jt();
        else if (Je === "p192")
          Xe = new Yt();
        else if (Je === "p25519")
          Xe = new Dt();
        else
          throw new Error("Unknown prime " + Je);
        return kt[Je] = Xe, Xe;
      };
      function Ct(Nt) {
        if (typeof Nt == "string") {
          var Je = ie._prime(Nt);
          this.m = Je.p, this.prime = Je;
        } else
          ne(Nt.gtn(1), "modulus must be greater than 1"), this.m = Nt, this.prime = null;
      }
      Ct.prototype._verify1 = function(Je) {
        ne(Je.negative === 0, "red works only with positives"), ne(Je.red, "red works only with red numbers");
      }, Ct.prototype._verify2 = function(Je, Xe) {
        ne((Je.negative | Xe.negative) === 0, "red works only with positives"), ne(
          Je.red && Je.red === Xe.red,
          "red works only with red numbers"
        );
      }, Ct.prototype.imod = function(Je) {
        return this.prime ? this.prime.ireduce(Je)._forceRed(this) : Je.umod(this.m)._forceRed(this);
      }, Ct.prototype.neg = function(Je) {
        return Je.isZero() ? Je.clone() : this.m.sub(Je)._forceRed(this);
      }, Ct.prototype.add = function(Je, Xe) {
        this._verify2(Je, Xe);
        var Ke = Je.add(Xe);
        return Ke.cmp(this.m) >= 0 && Ke.isub(this.m), Ke._forceRed(this);
      }, Ct.prototype.iadd = function(Je, Xe) {
        this._verify2(Je, Xe);
        var Ke = Je.iadd(Xe);
        return Ke.cmp(this.m) >= 0 && Ke.isub(this.m), Ke;
      }, Ct.prototype.sub = function(Je, Xe) {
        this._verify2(Je, Xe);
        var Ke = Je.sub(Xe);
        return Ke.cmpn(0) < 0 && Ke.iadd(this.m), Ke._forceRed(this);
      }, Ct.prototype.isub = function(Je, Xe) {
        this._verify2(Je, Xe);
        var Ke = Je.isub(Xe);
        return Ke.cmpn(0) < 0 && Ke.iadd(this.m), Ke;
      }, Ct.prototype.shl = function(Je, Xe) {
        return this._verify1(Je), this.imod(Je.ushln(Xe));
      }, Ct.prototype.imul = function(Je, Xe) {
        return this._verify2(Je, Xe), this.imod(Je.imul(Xe));
      }, Ct.prototype.mul = function(Je, Xe) {
        return this._verify2(Je, Xe), this.imod(Je.mul(Xe));
      }, Ct.prototype.isqr = function(Je) {
        return this.imul(Je, Je.clone());
      }, Ct.prototype.sqr = function(Je) {
        return this.mul(Je, Je);
      }, Ct.prototype.sqrt = function(Je) {
        if (Je.isZero()) return Je.clone();
        var Xe = this.m.andln(3);
        if (ne(Xe % 2 === 1), Xe === 3) {
          var Ke = this.m.add(new ie(1)).iushrn(2);
          return this.pow(Je, Ke);
        }
        for (var Qe = this.m.subn(1), bt = 0; !Qe.isZero() && Qe.andln(1) === 0; )
          bt++, Qe.iushrn(1);
        ne(!Qe.isZero());
        var wt = new ie(1).toRed(this), xt = wt.redNeg(), Bt = this.m.subn(1).iushrn(1), $t = this.m.bitLength();
        for ($t = new ie(2 * $t * $t).toRed(this); this.pow($t, Bt).cmp(xt) !== 0; )
          $t.redIAdd(xt);
        for (var qt = this.pow($t, Qe), Rt = this.pow(Je, Qe.addn(1).iushrn(1)), Lt = this.pow(Je, Qe), tr = bt; Lt.cmp(wt) !== 0; ) {
          for (var sr = Lt, Zt = 0; sr.cmp(wt) !== 0; Zt++)
            sr = sr.redSqr();
          ne(Zt < tr);
          var Wt = this.pow(qt, new ie(1).iushln(tr - Zt - 1));
          Rt = Rt.redMul(Wt), qt = Wt.redSqr(), Lt = Lt.redMul(qt), tr = Zt;
        }
        return Rt;
      }, Ct.prototype.invm = function(Je) {
        var Xe = Je._invmp(this.m);
        return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
      }, Ct.prototype.pow = function(Je, Xe) {
        if (Xe.isZero()) return new ie(1).toRed(this);
        if (Xe.cmpn(1) === 0) return Je.clone();
        var Ke = 4, Qe = new Array(1 << Ke);
        Qe[0] = new ie(1).toRed(this), Qe[1] = Je;
        for (var bt = 2; bt < Qe.length; bt++)
          Qe[bt] = this.mul(Qe[bt - 1], Je);
        var wt = Qe[0], xt = 0, Bt = 0, $t = Xe.bitLength() % 26;
        for ($t === 0 && ($t = 26), bt = Xe.length - 1; bt >= 0; bt--) {
          for (var qt = Xe.words[bt], Rt = $t - 1; Rt >= 0; Rt--) {
            var Lt = qt >> Rt & 1;
            if (wt !== Qe[0] && (wt = this.sqr(wt)), Lt === 0 && xt === 0) {
              Bt = 0;
              continue;
            }
            xt <<= 1, xt |= Lt, Bt++, !(Bt !== Ke && (bt !== 0 || Rt !== 0)) && (wt = this.mul(wt, Qe[xt]), Bt = 0, xt = 0);
          }
          $t = 26;
        }
        return wt;
      }, Ct.prototype.convertTo = function(Je) {
        var Xe = Je.umod(this.m);
        return Xe === Je ? Xe.clone() : Xe;
      }, Ct.prototype.convertFrom = function(Je) {
        var Xe = Je.clone();
        return Xe.red = null, Xe;
      }, ie.mont = function(Je) {
        return new Kt(Je);
      };
      function Kt(Nt) {
        Ct.call(this, Nt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      ae(Kt, Ct), Kt.prototype.convertTo = function(Je) {
        return this.imod(Je.ushln(this.shift));
      }, Kt.prototype.convertFrom = function(Je) {
        var Xe = this.imod(Je.mul(this.rinv));
        return Xe.red = null, Xe;
      }, Kt.prototype.imul = function(Je, Xe) {
        if (Je.isZero() || Xe.isZero())
          return Je.words[0] = 0, Je.length = 1, Je;
        var Ke = Je.imul(Xe), Qe = Ke.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), bt = Ke.isub(Qe).iushrn(this.shift), wt = bt;
        return bt.cmp(this.m) >= 0 ? wt = bt.isub(this.m) : bt.cmpn(0) < 0 && (wt = bt.iadd(this.m)), wt._forceRed(this);
      }, Kt.prototype.mul = function(Je, Xe) {
        if (Je.isZero() || Xe.isZero()) return new ie(0)._forceRed(this);
        var Ke = Je.mul(Xe), Qe = Ke.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), bt = Ke.isub(Qe).iushrn(this.shift), wt = bt;
        return bt.cmp(this.m) >= 0 ? wt = bt.isub(this.m) : bt.cmpn(0) < 0 && (wt = bt.iadd(this.m)), wt._forceRed(this);
      }, Kt.prototype.invm = function(Je) {
        var Xe = this.imod(Je._invmp(this.m).mul(this.r2));
        return Xe._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(ae) {
    return B || (B = new z(null)), B.generate(ae);
  };
  function z(ne) {
    this.rand = ne;
  }
  if (brorand.exports.Rand = z, z.prototype.generate = function(ae) {
    return this._rand(ae);
  }, z.prototype._rand = function(ae) {
    if (this.rand.getBytes)
      return this.rand.getBytes(ae);
    for (var ie = new Uint8Array(ae), se = 0; se < ie.length; se++)
      ie[se] = this.rand.getByte();
    return ie;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? z.prototype._rand = function(ae) {
      var ie = new Uint8Array(ae);
      return self.crypto.getRandomValues(ie), ie;
    } : self.msCrypto && self.msCrypto.getRandomValues ? z.prototype._rand = function(ae) {
      var ie = new Uint8Array(ae);
      return self.msCrypto.getRandomValues(ie), ie;
    } : typeof window == "object" && (z.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Y = requireCryptoBrowserify();
      if (typeof Y.randomBytes != "function")
        throw new Error("Not supported");
      z.prototype._rand = function(ae) {
        return Y.randomBytes(ae);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = requireBn$1(), z = requireBrorand();
  function Y(ne) {
    this.rand = ne || new z.Rand();
  }
  return mr = Y, Y.create = function(ae) {
    return new Y(ae);
  }, Y.prototype._randbelow = function(ae) {
    var ie = ae.bitLength(), se = Math.ceil(ie / 8);
    do
      var le = new B(this.rand.generate(se));
    while (le.cmp(ae) >= 0);
    return le;
  }, Y.prototype._randrange = function(ae, ie) {
    var se = ie.sub(ae);
    return ae.add(this._randbelow(se));
  }, Y.prototype.test = function(ae, ie, se) {
    var le = ae.bitLength(), ve = B.mont(ae), ge = new B(1).toRed(ve);
    ie || (ie = Math.max(1, le / 48 | 0));
    for (var oe = ae.subn(1), Ee = 0; !oe.testn(Ee); Ee++)
      ;
    for (var Ce = ae.shrn(Ee), Pe = oe.toRed(ve), Ve = !0; ie > 0; ie--) {
      var ht = this._randrange(new B(2), oe);
      se && se(ht);
      var vt = ht.toRed(ve).redPow(Ce);
      if (!(vt.cmp(ge) === 0 || vt.cmp(Pe) === 0)) {
        for (var Pt = 1; Pt < Ee; Pt++) {
          if (vt = vt.redSqr(), vt.cmp(ge) === 0)
            return !1;
          if (vt.cmp(Pe) === 0)
            break;
        }
        if (Pt === Ee)
          return !1;
      }
    }
    return Ve;
  }, Y.prototype.getDivisor = function(ae, ie) {
    var se = ae.bitLength(), le = B.mont(ae), ve = new B(1).toRed(le);
    ie || (ie = Math.max(1, se / 48 | 0));
    for (var ge = ae.subn(1), oe = 0; !ge.testn(oe); oe++)
      ;
    for (var Ee = ae.shrn(oe), Ce = ge.toRed(le); ie > 0; ie--) {
      var Pe = this._randrange(new B(2), ge), Ve = ae.gcd(Pe);
      if (Ve.cmpn(1) !== 0)
        return Ve;
      var ht = Pe.toRed(le).redPow(Ee);
      if (!(ht.cmp(ve) === 0 || ht.cmp(Ce) === 0)) {
        for (var vt = 1; vt < oe; vt++) {
          if (ht = ht.redSqr(), ht.cmp(ve) === 0)
            return ht.fromRed().subn(1).gcd(ae);
          if (ht.cmp(Ce) === 0)
            break;
        }
        if (vt === oe)
          return ht = ht.redSqr(), ht.fromRed().subn(1).gcd(ae);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = requireBrowser$b();
  generatePrime = vt, vt.simpleSieve = Ve, vt.fermatTest = ht;
  var z = requireBn$1(), Y = new z(24), ne = requireMr(), ae = new ne(), ie = new z(1), se = new z(2), le = new z(5);
  new z(16), new z(8);
  var ve = new z(10), ge = new z(3);
  new z(7);
  var oe = new z(11), Ee = new z(4);
  new z(12);
  var Ce = null;
  function Pe() {
    if (Ce !== null)
      return Ce;
    var Pt = 1048576, _t = [];
    _t[0] = 2;
    for (var kt = 1, Ot = 3; Ot < Pt; Ot += 2) {
      for (var Ht = Math.ceil(Math.sqrt(Ot)), jt = 0; jt < kt && _t[jt] <= Ht && Ot % _t[jt] !== 0; jt++)
        ;
      kt !== jt && _t[jt] <= Ht || (_t[kt++] = Ot);
    }
    return Ce = _t, _t;
  }
  function Ve(Pt) {
    for (var _t = Pe(), kt = 0; kt < _t.length; kt++)
      if (Pt.modn(_t[kt]) === 0)
        return Pt.cmpn(_t[kt]) === 0;
    return !0;
  }
  function ht(Pt) {
    var _t = z.mont(Pt);
    return se.toRed(_t).redPow(Pt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function vt(Pt, _t) {
    if (Pt < 16)
      return _t === 2 || _t === 5 ? new z([140, 123]) : new z([140, 39]);
    _t = new z(_t);
    for (var kt, Ot; ; ) {
      for (kt = new z(B(Math.ceil(Pt / 8))); kt.bitLength() > Pt; )
        kt.ishrn(1);
      if (kt.isEven() && kt.iadd(ie), kt.testn(1) || kt.iadd(se), _t.cmp(se)) {
        if (!_t.cmp(le))
          for (; kt.mod(ve).cmp(ge); )
            kt.iadd(Ee);
      } else for (; kt.mod(Y).cmp(oe); )
        kt.iadd(Ee);
      if (Ot = kt.shrn(1), Ve(Ot) && Ve(kt) && ht(Ot) && ht(kt) && ae.test(Ot) && ae.test(kt))
        return kt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = requireBn$1(), z = requireMr(), Y = new z(), ne = new B(24), ae = new B(11), ie = new B(10), se = new B(3), le = new B(7), ve = requireGeneratePrime(), ge = requireBrowser$b();
  dh = Ve;
  function oe(vt, Pt) {
    return Pt = Pt || "utf8", Buffer$1.isBuffer(vt) || (vt = new Buffer$1(vt, Pt)), this._pub = new B(vt), this;
  }
  function Ee(vt, Pt) {
    return Pt = Pt || "utf8", Buffer$1.isBuffer(vt) || (vt = new Buffer$1(vt, Pt)), this._priv = new B(vt), this;
  }
  var Ce = {};
  function Pe(vt, Pt) {
    var _t = Pt.toString("hex"), kt = [_t, vt.toString(16)].join("_");
    if (kt in Ce)
      return Ce[kt];
    var Ot = 0;
    if (vt.isEven() || !ve.simpleSieve || !ve.fermatTest(vt) || !Y.test(vt))
      return Ot += 1, _t === "02" || _t === "05" ? Ot += 8 : Ot += 4, Ce[kt] = Ot, Ot;
    Y.test(vt.shrn(1)) || (Ot += 2);
    var Ht;
    switch (_t) {
      case "02":
        vt.mod(ne).cmp(ae) && (Ot += 8);
        break;
      case "05":
        Ht = vt.mod(ie), Ht.cmp(se) && Ht.cmp(le) && (Ot += 8);
        break;
      default:
        Ot += 4;
    }
    return Ce[kt] = Ot, Ot;
  }
  function Ve(vt, Pt, _t) {
    this.setGenerator(Pt), this.__prime = new B(vt), this._prime = B.mont(this.__prime), this._primeLen = vt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, _t ? (this.setPublicKey = oe, this.setPrivateKey = Ee) : this._primeCode = 8;
  }
  Object.defineProperty(Ve.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Pe(this.__prime, this.__gen)), this._primeCode;
    }
  }), Ve.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(ge(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Ve.prototype.computeSecret = function(vt) {
    vt = new B(vt), vt = vt.toRed(this._prime);
    var Pt = vt.redPow(this._priv).fromRed(), _t = new Buffer$1(Pt.toArray()), kt = this.getPrime();
    if (_t.length < kt.length) {
      var Ot = new Buffer$1(kt.length - _t.length);
      Ot.fill(0), _t = Buffer$1.concat([Ot, _t]);
    }
    return _t;
  }, Ve.prototype.getPublicKey = function(Pt) {
    return ht(this._pub, Pt);
  }, Ve.prototype.getPrivateKey = function(Pt) {
    return ht(this._priv, Pt);
  }, Ve.prototype.getPrime = function(vt) {
    return ht(this.__prime, vt);
  }, Ve.prototype.getGenerator = function(vt) {
    return ht(this._gen, vt);
  }, Ve.prototype.setGenerator = function(vt, Pt) {
    return Pt = Pt || "utf8", Buffer$1.isBuffer(vt) || (vt = new Buffer$1(vt, Pt)), this.__gen = vt, this._gen = new B(vt), this;
  };
  function ht(vt, Pt) {
    var _t = new Buffer$1(vt.toArray());
    return Pt ? _t.toString(Pt) : _t;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var B = requireGeneratePrime(), z = require$$1$1, Y = requireDh();
  function ne(se) {
    var le = new Buffer$1(z[se].prime, "hex"), ve = new Buffer$1(z[se].gen, "hex");
    return new Y(le, ve);
  }
  var ae = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function ie(se, le, ve, ge) {
    return Buffer$1.isBuffer(le) || ae[le] === void 0 ? ie(se, "binary", le, ve) : (le = le || "binary", ge = ge || "binary", ve = ve || new Buffer$1([2]), Buffer$1.isBuffer(ve) || (ve = new Buffer$1(ve, ge)), typeof se == "number" ? new Y(B(se, ve), ve, !0) : (Buffer$1.isBuffer(se) || (se = new Buffer$1(se, le)), new Y(se, ve, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ne, browser$4.createDiffieHellman = browser$4.DiffieHellman = ie, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: B } : processNextickArgs.exports = process$1;
  function B(z, Y, ne, ae) {
    if (typeof z != "function")
      throw new TypeError('"callback" argument must be a function');
    var ie = arguments.length, se, le;
    switch (ie) {
      case 0:
      case 1:
        return process$1.nextTick(z);
      case 2:
        return process$1.nextTick(function() {
          z.call(null, Y);
        });
      case 3:
        return process$1.nextTick(function() {
          z.call(null, Y, ne);
        });
      case 4:
        return process$1.nextTick(function() {
          z.call(null, Y, ne, ae);
        });
      default:
        for (se = new Array(ie - 1), le = 0; le < se.length; )
          se[le++] = arguments[le];
        return process$1.nextTick(function() {
          z.apply(null, se);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var B = {}.toString;
  return isarray = Array.isArray || function(z) {
    return B.call(z) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(B, z) {
    var Y = require$$0$1, ne = Y.Buffer;
    function ae(se, le) {
      for (var ve in se)
        le[ve] = se[ve];
    }
    ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (ae(Y, z), z.Buffer = ie);
    function ie(se, le, ve) {
      return ne(se, le, ve);
    }
    ae(ne, ie), ie.from = function(se, le, ve) {
      if (typeof se == "number")
        throw new TypeError("Argument must not be a number");
      return ne(se, le, ve);
    }, ie.alloc = function(se, le, ve) {
      if (typeof se != "number")
        throw new TypeError("Argument must be a number");
      var ge = ne(se);
      return le !== void 0 ? typeof ve == "string" ? ge.fill(le, ve) : ge.fill(le) : ge.fill(0), ge;
    }, ie.allocUnsafe = function(se) {
      if (typeof se != "number")
        throw new TypeError("Argument must be a number");
      return ne(se);
    }, ie.allocUnsafeSlow = function(se) {
      if (typeof se != "number")
        throw new TypeError("Argument must be a number");
      return Y.SlowBuffer(se);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function B(ht) {
    return Array.isArray ? Array.isArray(ht) : Ve(ht) === "[object Array]";
  }
  util.isArray = B;
  function z(ht) {
    return typeof ht == "boolean";
  }
  util.isBoolean = z;
  function Y(ht) {
    return ht === null;
  }
  util.isNull = Y;
  function ne(ht) {
    return ht == null;
  }
  util.isNullOrUndefined = ne;
  function ae(ht) {
    return typeof ht == "number";
  }
  util.isNumber = ae;
  function ie(ht) {
    return typeof ht == "string";
  }
  util.isString = ie;
  function se(ht) {
    return typeof ht == "symbol";
  }
  util.isSymbol = se;
  function le(ht) {
    return ht === void 0;
  }
  util.isUndefined = le;
  function ve(ht) {
    return Ve(ht) === "[object RegExp]";
  }
  util.isRegExp = ve;
  function ge(ht) {
    return typeof ht == "object" && ht !== null;
  }
  util.isObject = ge;
  function oe(ht) {
    return Ve(ht) === "[object Date]";
  }
  util.isDate = oe;
  function Ee(ht) {
    return Ve(ht) === "[object Error]" || ht instanceof Error;
  }
  util.isError = Ee;
  function Ce(ht) {
    return typeof ht == "function";
  }
  util.isFunction = Ce;
  function Pe(ht) {
    return ht === null || typeof ht == "boolean" || typeof ht == "number" || typeof ht == "string" || typeof ht == "symbol" || // ES6 symbol
    typeof ht > "u";
  }
  util.isPrimitive = Pe, util.isBuffer = require$$0$1.Buffer.isBuffer;
  function Ve(ht) {
    return Object.prototype.toString.call(ht);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function z(ie, se) {
      if (!(ie instanceof se))
        throw new TypeError("Cannot call a class as a function");
    }
    var Y = requireSafeBuffer().Buffer, ne = requireUtil$1();
    function ae(ie, se, le) {
      ie.copy(se, le);
    }
    B.exports = function() {
      function ie() {
        z(this, ie), this.head = null, this.tail = null, this.length = 0;
      }
      return ie.prototype.push = function(le) {
        var ve = { data: le, next: null };
        this.length > 0 ? this.tail.next = ve : this.head = ve, this.tail = ve, ++this.length;
      }, ie.prototype.unshift = function(le) {
        var ve = { data: le, next: this.head };
        this.length === 0 && (this.tail = ve), this.head = ve, ++this.length;
      }, ie.prototype.shift = function() {
        if (this.length !== 0) {
          var le = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, le;
        }
      }, ie.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, ie.prototype.join = function(le) {
        if (this.length === 0) return "";
        for (var ve = this.head, ge = "" + ve.data; ve = ve.next; )
          ge += le + ve.data;
        return ge;
      }, ie.prototype.concat = function(le) {
        if (this.length === 0) return Y.alloc(0);
        for (var ve = Y.allocUnsafe(le >>> 0), ge = this.head, oe = 0; ge; )
          ae(ge.data, ve, oe), oe += ge.data.length, ge = ge.next;
        return ve;
      }, ie;
    }(), ne && ne.inspect && ne.inspect.custom && (B.exports.prototype[ne.inspect.custom] = function() {
      var ie = ne.inspect({ length: this.length });
      return this.constructor.name + " " + ie;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var B = requireProcessNextickArgs();
  function z(ae, ie) {
    var se = this, le = this._readableState && this._readableState.destroyed, ve = this._writableState && this._writableState.destroyed;
    return le || ve ? (ie ? ie(ae) : ae && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, B.nextTick(ne, this, ae)) : B.nextTick(ne, this, ae)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(ae || null, function(ge) {
      !ie && ge ? se._writableState ? se._writableState.errorEmitted || (se._writableState.errorEmitted = !0, B.nextTick(ne, se, ge)) : B.nextTick(ne, se, ge) : ie && ie(ge);
    }), this);
  }
  function Y() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function ne(ae, ie) {
    ae.emit("error", ie);
  }
  return destroy_1 = {
    destroy: z,
    undestroy: Y
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = requireProcessNextickArgs();
  _stream_writable = ht;
  function z(wt) {
    var xt = this;
    this.next = null, this.entry = null, this.finish = function() {
      bt(xt, wt);
    };
  }
  var Y = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, ne;
  ht.WritableState = Pe;
  var ae = Object.create(requireUtil());
  ae.inherits = requireInherits_browser();
  var ie = {
    deprecate: requireBrowser$a()
  }, se = requireStreamBrowser(), le = requireSafeBuffer().Buffer, ve = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ge(wt) {
    return le.from(wt);
  }
  function oe(wt) {
    return le.isBuffer(wt) || wt instanceof ve;
  }
  var Ee = requireDestroy();
  ae.inherits(ht, se);
  function Ce() {
  }
  function Pe(wt, xt) {
    ne = ne || require_stream_duplex(), wt = wt || {};
    var Bt = xt instanceof ne;
    this.objectMode = !!wt.objectMode, Bt && (this.objectMode = this.objectMode || !!wt.writableObjectMode);
    var $t = wt.highWaterMark, qt = wt.writableHighWaterMark, Rt = this.objectMode ? 16 : 16 * 1024;
    $t || $t === 0 ? this.highWaterMark = $t : Bt && (qt || qt === 0) ? this.highWaterMark = qt : this.highWaterMark = Rt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Lt = wt.decodeStrings === !1;
    this.decodeStrings = !Lt, this.defaultEncoding = wt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(tr) {
      Yt(xt, tr);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new z(this);
  }
  Pe.prototype.getBuffer = function() {
    for (var xt = this.bufferedRequest, Bt = []; xt; )
      Bt.push(xt), xt = xt.next;
    return Bt;
  }, function() {
    try {
      Object.defineProperty(Pe.prototype, "buffer", {
        get: ie.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Ve;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ve = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, {
    value: function(wt) {
      return Ve.call(this, wt) ? !0 : this !== ht ? !1 : wt && wt._writableState instanceof Pe;
    }
  })) : Ve = function(wt) {
    return wt instanceof this;
  };
  function ht(wt) {
    if (ne = ne || require_stream_duplex(), !Ve.call(ht, this) && !(this instanceof ne))
      return new ht(wt);
    this._writableState = new Pe(wt, this), this.writable = !0, wt && (typeof wt.write == "function" && (this._write = wt.write), typeof wt.writev == "function" && (this._writev = wt.writev), typeof wt.destroy == "function" && (this._destroy = wt.destroy), typeof wt.final == "function" && (this._final = wt.final)), se.call(this);
  }
  ht.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function vt(wt, xt) {
    var Bt = new Error("write after end");
    wt.emit("error", Bt), B.nextTick(xt, Bt);
  }
  function Pt(wt, xt, Bt, $t) {
    var qt = !0, Rt = !1;
    return Bt === null ? Rt = new TypeError("May not write null values to stream") : typeof Bt != "string" && Bt !== void 0 && !xt.objectMode && (Rt = new TypeError("Invalid non-string/buffer chunk")), Rt && (wt.emit("error", Rt), B.nextTick($t, Rt), qt = !1), qt;
  }
  ht.prototype.write = function(wt, xt, Bt) {
    var $t = this._writableState, qt = !1, Rt = !$t.objectMode && oe(wt);
    return Rt && !le.isBuffer(wt) && (wt = ge(wt)), typeof xt == "function" && (Bt = xt, xt = null), Rt ? xt = "buffer" : xt || (xt = $t.defaultEncoding), typeof Bt != "function" && (Bt = Ce), $t.ended ? vt(this, Bt) : (Rt || Pt(this, $t, wt, Bt)) && ($t.pendingcb++, qt = kt(this, $t, Rt, wt, xt, Bt)), qt;
  }, ht.prototype.cork = function() {
    var wt = this._writableState;
    wt.corked++;
  }, ht.prototype.uncork = function() {
    var wt = this._writableState;
    wt.corked && (wt.corked--, !wt.writing && !wt.corked && !wt.bufferProcessing && wt.bufferedRequest && Kt(this, wt));
  }, ht.prototype.setDefaultEncoding = function(xt) {
    if (typeof xt == "string" && (xt = xt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((xt + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + xt);
    return this._writableState.defaultEncoding = xt, this;
  };
  function _t(wt, xt, Bt) {
    return !wt.objectMode && wt.decodeStrings !== !1 && typeof xt == "string" && (xt = le.from(xt, Bt)), xt;
  }
  Object.defineProperty(ht.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function kt(wt, xt, Bt, $t, qt, Rt) {
    if (!Bt) {
      var Lt = _t(xt, $t, qt);
      $t !== Lt && (Bt = !0, qt = "buffer", $t = Lt);
    }
    var tr = xt.objectMode ? 1 : $t.length;
    xt.length += tr;
    var sr = xt.length < xt.highWaterMark;
    if (sr || (xt.needDrain = !0), xt.writing || xt.corked) {
      var Zt = xt.lastBufferedRequest;
      xt.lastBufferedRequest = {
        chunk: $t,
        encoding: qt,
        isBuf: Bt,
        callback: Rt,
        next: null
      }, Zt ? Zt.next = xt.lastBufferedRequest : xt.bufferedRequest = xt.lastBufferedRequest, xt.bufferedRequestCount += 1;
    } else
      Ot(wt, xt, !1, tr, $t, qt, Rt);
    return sr;
  }
  function Ot(wt, xt, Bt, $t, qt, Rt, Lt) {
    xt.writelen = $t, xt.writecb = Lt, xt.writing = !0, xt.sync = !0, Bt ? wt._writev(qt, xt.onwrite) : wt._write(qt, Rt, xt.onwrite), xt.sync = !1;
  }
  function Ht(wt, xt, Bt, $t, qt) {
    --xt.pendingcb, Bt ? (B.nextTick(qt, $t), B.nextTick(Ke, wt, xt), wt._writableState.errorEmitted = !0, wt.emit("error", $t)) : (qt($t), wt._writableState.errorEmitted = !0, wt.emit("error", $t), Ke(wt, xt));
  }
  function jt(wt) {
    wt.writing = !1, wt.writecb = null, wt.length -= wt.writelen, wt.writelen = 0;
  }
  function Yt(wt, xt) {
    var Bt = wt._writableState, $t = Bt.sync, qt = Bt.writecb;
    if (jt(Bt), xt) Ht(wt, Bt, $t, xt, qt);
    else {
      var Rt = Nt(Bt);
      !Rt && !Bt.corked && !Bt.bufferProcessing && Bt.bufferedRequest && Kt(wt, Bt), $t ? Y(Dt, wt, Bt, Rt, qt) : Dt(wt, Bt, Rt, qt);
    }
  }
  function Dt(wt, xt, Bt, $t) {
    Bt || Ct(wt, xt), xt.pendingcb--, $t(), Ke(wt, xt);
  }
  function Ct(wt, xt) {
    xt.length === 0 && xt.needDrain && (xt.needDrain = !1, wt.emit("drain"));
  }
  function Kt(wt, xt) {
    xt.bufferProcessing = !0;
    var Bt = xt.bufferedRequest;
    if (wt._writev && Bt && Bt.next) {
      var $t = xt.bufferedRequestCount, qt = new Array($t), Rt = xt.corkedRequestsFree;
      Rt.entry = Bt;
      for (var Lt = 0, tr = !0; Bt; )
        qt[Lt] = Bt, Bt.isBuf || (tr = !1), Bt = Bt.next, Lt += 1;
      qt.allBuffers = tr, Ot(wt, xt, !0, xt.length, qt, "", Rt.finish), xt.pendingcb++, xt.lastBufferedRequest = null, Rt.next ? (xt.corkedRequestsFree = Rt.next, Rt.next = null) : xt.corkedRequestsFree = new z(xt), xt.bufferedRequestCount = 0;
    } else {
      for (; Bt; ) {
        var sr = Bt.chunk, Zt = Bt.encoding, Wt = Bt.callback, Gt = xt.objectMode ? 1 : sr.length;
        if (Ot(wt, xt, !1, Gt, sr, Zt, Wt), Bt = Bt.next, xt.bufferedRequestCount--, xt.writing)
          break;
      }
      Bt === null && (xt.lastBufferedRequest = null);
    }
    xt.bufferedRequest = Bt, xt.bufferProcessing = !1;
  }
  ht.prototype._write = function(wt, xt, Bt) {
    Bt(new Error("_write() is not implemented"));
  }, ht.prototype._writev = null, ht.prototype.end = function(wt, xt, Bt) {
    var $t = this._writableState;
    typeof wt == "function" ? (Bt = wt, wt = null, xt = null) : typeof xt == "function" && (Bt = xt, xt = null), wt != null && this.write(wt, xt), $t.corked && ($t.corked = 1, this.uncork()), $t.ending || Qe(this, $t, Bt);
  };
  function Nt(wt) {
    return wt.ending && wt.length === 0 && wt.bufferedRequest === null && !wt.finished && !wt.writing;
  }
  function Je(wt, xt) {
    wt._final(function(Bt) {
      xt.pendingcb--, Bt && wt.emit("error", Bt), xt.prefinished = !0, wt.emit("prefinish"), Ke(wt, xt);
    });
  }
  function Xe(wt, xt) {
    !xt.prefinished && !xt.finalCalled && (typeof wt._final == "function" ? (xt.pendingcb++, xt.finalCalled = !0, B.nextTick(Je, wt, xt)) : (xt.prefinished = !0, wt.emit("prefinish")));
  }
  function Ke(wt, xt) {
    var Bt = Nt(xt);
    return Bt && (Xe(wt, xt), xt.pendingcb === 0 && (xt.finished = !0, wt.emit("finish"))), Bt;
  }
  function Qe(wt, xt, Bt) {
    xt.ending = !0, Ke(wt, xt), Bt && (xt.finished ? B.nextTick(Bt) : wt.once("finish", Bt)), xt.ended = !0, wt.writable = !1;
  }
  function bt(wt, xt, Bt) {
    var $t = wt.entry;
    for (wt.entry = null; $t; ) {
      var qt = $t.callback;
      xt.pendingcb--, qt(Bt), $t = $t.next;
    }
    xt.corkedRequestsFree.next = wt;
  }
  return Object.defineProperty(ht.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(wt) {
      this._writableState && (this._writableState.destroyed = wt);
    }
  }), ht.prototype.destroy = Ee.destroy, ht.prototype._undestroy = Ee.undestroy, ht.prototype._destroy = function(wt, xt) {
    this.end(), xt(wt);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = requireProcessNextickArgs(), z = Object.keys || function(Ee) {
    var Ce = [];
    for (var Pe in Ee)
      Ce.push(Pe);
    return Ce;
  };
  _stream_duplex = ve;
  var Y = Object.create(requireUtil());
  Y.inherits = requireInherits_browser();
  var ne = require_stream_readable(), ae = require_stream_writable();
  Y.inherits(ve, ne);
  for (var ie = z(ae.prototype), se = 0; se < ie.length; se++) {
    var le = ie[se];
    ve.prototype[le] || (ve.prototype[le] = ae.prototype[le]);
  }
  function ve(Ee) {
    if (!(this instanceof ve)) return new ve(Ee);
    ne.call(this, Ee), ae.call(this, Ee), Ee && Ee.readable === !1 && (this.readable = !1), Ee && Ee.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Ee && Ee.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ge);
  }
  Object.defineProperty(ve.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ge() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(oe, this);
  }
  function oe(Ee) {
    Ee.end();
  }
  return Object.defineProperty(ve.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ee) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ee, this._writableState.destroyed = Ee);
    }
  }), ve.prototype._destroy = function(Ee, Ce) {
    this.push(null), this.end(), B.nextTick(Ce, Ee);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = requireProcessNextickArgs();
  _stream_readable = _t;
  var z = requireIsarray(), Y;
  _t.ReadableState = Pt, requireEvents().EventEmitter;
  var ne = function(Wt, Gt) {
    return Wt.listeners(Gt).length;
  }, ae = requireStreamBrowser(), ie = requireSafeBuffer().Buffer, se = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function le(Wt) {
    return ie.from(Wt);
  }
  function ve(Wt) {
    return ie.isBuffer(Wt) || Wt instanceof se;
  }
  var ge = Object.create(requireUtil());
  ge.inherits = requireInherits_browser();
  var oe = requireUtil$1(), Ee = void 0;
  oe && oe.debuglog ? Ee = oe.debuglog("stream") : Ee = function() {
  };
  var Ce = requireBufferList(), Pe = requireDestroy(), Ve;
  ge.inherits(_t, ae);
  var ht = ["error", "close", "destroy", "pause", "resume"];
  function vt(Wt, Gt, rr) {
    if (typeof Wt.prependListener == "function") return Wt.prependListener(Gt, rr);
    !Wt._events || !Wt._events[Gt] ? Wt.on(Gt, rr) : z(Wt._events[Gt]) ? Wt._events[Gt].unshift(rr) : Wt._events[Gt] = [rr, Wt._events[Gt]];
  }
  function Pt(Wt, Gt) {
    Y = Y || require_stream_duplex(), Wt = Wt || {};
    var rr = Gt instanceof Y;
    this.objectMode = !!Wt.objectMode, rr && (this.objectMode = this.objectMode || !!Wt.readableObjectMode);
    var or = Wt.highWaterMark, Xt = Wt.readableHighWaterMark, zt = this.objectMode ? 16 : 16 * 1024;
    or || or === 0 ? this.highWaterMark = or : rr && (Xt || Xt === 0) ? this.highWaterMark = Xt : this.highWaterMark = zt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Wt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Wt.encoding && (Ve || (Ve = requireString_decoder().StringDecoder), this.decoder = new Ve(Wt.encoding), this.encoding = Wt.encoding);
  }
  function _t(Wt) {
    if (Y = Y || require_stream_duplex(), !(this instanceof _t)) return new _t(Wt);
    this._readableState = new Pt(Wt, this), this.readable = !0, Wt && (typeof Wt.read == "function" && (this._read = Wt.read), typeof Wt.destroy == "function" && (this._destroy = Wt.destroy)), ae.call(this);
  }
  Object.defineProperty(_t.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Wt) {
      this._readableState && (this._readableState.destroyed = Wt);
    }
  }), _t.prototype.destroy = Pe.destroy, _t.prototype._undestroy = Pe.undestroy, _t.prototype._destroy = function(Wt, Gt) {
    this.push(null), Gt(Wt);
  }, _t.prototype.push = function(Wt, Gt) {
    var rr = this._readableState, or;
    return rr.objectMode ? or = !0 : typeof Wt == "string" && (Gt = Gt || rr.defaultEncoding, Gt !== rr.encoding && (Wt = ie.from(Wt, Gt), Gt = ""), or = !0), kt(this, Wt, Gt, !1, or);
  }, _t.prototype.unshift = function(Wt) {
    return kt(this, Wt, null, !0, !1);
  };
  function kt(Wt, Gt, rr, or, Xt) {
    var zt = Wt._readableState;
    if (Gt === null)
      zt.reading = !1, Kt(Wt, zt);
    else {
      var ur;
      Xt || (ur = Ht(zt, Gt)), ur ? Wt.emit("error", ur) : zt.objectMode || Gt && Gt.length > 0 ? (typeof Gt != "string" && !zt.objectMode && Object.getPrototypeOf(Gt) !== ie.prototype && (Gt = le(Gt)), or ? zt.endEmitted ? Wt.emit("error", new Error("stream.unshift() after end event")) : Ot(Wt, zt, Gt, !0) : zt.ended ? Wt.emit("error", new Error("stream.push() after EOF")) : (zt.reading = !1, zt.decoder && !rr ? (Gt = zt.decoder.write(Gt), zt.objectMode || Gt.length !== 0 ? Ot(Wt, zt, Gt, !1) : Xe(Wt, zt)) : Ot(Wt, zt, Gt, !1))) : or || (zt.reading = !1);
    }
    return jt(zt);
  }
  function Ot(Wt, Gt, rr, or) {
    Gt.flowing && Gt.length === 0 && !Gt.sync ? (Wt.emit("data", rr), Wt.read(0)) : (Gt.length += Gt.objectMode ? 1 : rr.length, or ? Gt.buffer.unshift(rr) : Gt.buffer.push(rr), Gt.needReadable && Nt(Wt)), Xe(Wt, Gt);
  }
  function Ht(Wt, Gt) {
    var rr;
    return !ve(Gt) && typeof Gt != "string" && Gt !== void 0 && !Wt.objectMode && (rr = new TypeError("Invalid non-string/buffer chunk")), rr;
  }
  function jt(Wt) {
    return !Wt.ended && (Wt.needReadable || Wt.length < Wt.highWaterMark || Wt.length === 0);
  }
  _t.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, _t.prototype.setEncoding = function(Wt) {
    return Ve || (Ve = requireString_decoder().StringDecoder), this._readableState.decoder = new Ve(Wt), this._readableState.encoding = Wt, this;
  };
  var Yt = 8388608;
  function Dt(Wt) {
    return Wt >= Yt ? Wt = Yt : (Wt--, Wt |= Wt >>> 1, Wt |= Wt >>> 2, Wt |= Wt >>> 4, Wt |= Wt >>> 8, Wt |= Wt >>> 16, Wt++), Wt;
  }
  function Ct(Wt, Gt) {
    return Wt <= 0 || Gt.length === 0 && Gt.ended ? 0 : Gt.objectMode ? 1 : Wt !== Wt ? Gt.flowing && Gt.length ? Gt.buffer.head.data.length : Gt.length : (Wt > Gt.highWaterMark && (Gt.highWaterMark = Dt(Wt)), Wt <= Gt.length ? Wt : Gt.ended ? Gt.length : (Gt.needReadable = !0, 0));
  }
  _t.prototype.read = function(Wt) {
    Ee("read", Wt), Wt = parseInt(Wt, 10);
    var Gt = this._readableState, rr = Wt;
    if (Wt !== 0 && (Gt.emittedReadable = !1), Wt === 0 && Gt.needReadable && (Gt.length >= Gt.highWaterMark || Gt.ended))
      return Ee("read: emitReadable", Gt.length, Gt.ended), Gt.length === 0 && Gt.ended ? tr(this) : Nt(this), null;
    if (Wt = Ct(Wt, Gt), Wt === 0 && Gt.ended)
      return Gt.length === 0 && tr(this), null;
    var or = Gt.needReadable;
    Ee("need readable", or), (Gt.length === 0 || Gt.length - Wt < Gt.highWaterMark) && (or = !0, Ee("length less than watermark", or)), Gt.ended || Gt.reading ? (or = !1, Ee("reading or ended", or)) : or && (Ee("do read"), Gt.reading = !0, Gt.sync = !0, Gt.length === 0 && (Gt.needReadable = !0), this._read(Gt.highWaterMark), Gt.sync = !1, Gt.reading || (Wt = Ct(rr, Gt)));
    var Xt;
    return Wt > 0 ? Xt = $t(Wt, Gt) : Xt = null, Xt === null ? (Gt.needReadable = !0, Wt = 0) : Gt.length -= Wt, Gt.length === 0 && (Gt.ended || (Gt.needReadable = !0), rr !== Wt && Gt.ended && tr(this)), Xt !== null && this.emit("data", Xt), Xt;
  };
  function Kt(Wt, Gt) {
    if (!Gt.ended) {
      if (Gt.decoder) {
        var rr = Gt.decoder.end();
        rr && rr.length && (Gt.buffer.push(rr), Gt.length += Gt.objectMode ? 1 : rr.length);
      }
      Gt.ended = !0, Nt(Wt);
    }
  }
  function Nt(Wt) {
    var Gt = Wt._readableState;
    Gt.needReadable = !1, Gt.emittedReadable || (Ee("emitReadable", Gt.flowing), Gt.emittedReadable = !0, Gt.sync ? B.nextTick(Je, Wt) : Je(Wt));
  }
  function Je(Wt) {
    Ee("emit readable"), Wt.emit("readable"), Bt(Wt);
  }
  function Xe(Wt, Gt) {
    Gt.readingMore || (Gt.readingMore = !0, B.nextTick(Ke, Wt, Gt));
  }
  function Ke(Wt, Gt) {
    for (var rr = Gt.length; !Gt.reading && !Gt.flowing && !Gt.ended && Gt.length < Gt.highWaterMark && (Ee("maybeReadMore read 0"), Wt.read(0), rr !== Gt.length); )
      rr = Gt.length;
    Gt.readingMore = !1;
  }
  _t.prototype._read = function(Wt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, _t.prototype.pipe = function(Wt, Gt) {
    var rr = this, or = this._readableState;
    switch (or.pipesCount) {
      case 0:
        or.pipes = Wt;
        break;
      case 1:
        or.pipes = [or.pipes, Wt];
        break;
      default:
        or.pipes.push(Wt);
        break;
    }
    or.pipesCount += 1, Ee("pipe count=%d opts=%j", or.pipesCount, Gt);
    var Xt = (!Gt || Gt.end !== !1) && Wt !== process$1.stdout && Wt !== process$1.stderr, zt = Xt ? pr : Gr;
    or.endEmitted ? B.nextTick(zt) : rr.once("end", zt), Wt.on("unpipe", ur);
    function ur(Rr, Hr) {
      Ee("onunpipe"), Rr === rr && Hr && Hr.hasUnpiped === !1 && (Hr.hasUnpiped = !0, xr());
    }
    function pr() {
      Ee("onend"), Wt.end();
    }
    var vr = Qe(rr);
    Wt.on("drain", vr);
    var _r = !1;
    function xr() {
      Ee("cleanup"), Wt.removeListener("close", $r), Wt.removeListener("finish", Ur), Wt.removeListener("drain", vr), Wt.removeListener("error", Wr), Wt.removeListener("unpipe", ur), rr.removeListener("end", pr), rr.removeListener("end", Gr), rr.removeListener("data", hr), _r = !0, or.awaitDrain && (!Wt._writableState || Wt._writableState.needDrain) && vr();
    }
    var Tr = !1;
    rr.on("data", hr);
    function hr(Rr) {
      Ee("ondata"), Tr = !1;
      var Hr = Wt.write(Rr);
      Hr === !1 && !Tr && ((or.pipesCount === 1 && or.pipes === Wt || or.pipesCount > 1 && Zt(or.pipes, Wt) !== -1) && !_r && (Ee("false write response, pause", or.awaitDrain), or.awaitDrain++, Tr = !0), rr.pause());
    }
    function Wr(Rr) {
      Ee("onerror", Rr), Gr(), Wt.removeListener("error", Wr), ne(Wt, "error") === 0 && Wt.emit("error", Rr);
    }
    vt(Wt, "error", Wr);
    function $r() {
      Wt.removeListener("finish", Ur), Gr();
    }
    Wt.once("close", $r);
    function Ur() {
      Ee("onfinish"), Wt.removeListener("close", $r), Gr();
    }
    Wt.once("finish", Ur);
    function Gr() {
      Ee("unpipe"), rr.unpipe(Wt);
    }
    return Wt.emit("pipe", rr), or.flowing || (Ee("pipe resume"), rr.resume()), Wt;
  };
  function Qe(Wt) {
    return function() {
      var Gt = Wt._readableState;
      Ee("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && ne(Wt, "data") && (Gt.flowing = !0, Bt(Wt));
    };
  }
  _t.prototype.unpipe = function(Wt) {
    var Gt = this._readableState, rr = { hasUnpiped: !1 };
    if (Gt.pipesCount === 0) return this;
    if (Gt.pipesCount === 1)
      return Wt && Wt !== Gt.pipes ? this : (Wt || (Wt = Gt.pipes), Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1, Wt && Wt.emit("unpipe", this, rr), this);
    if (!Wt) {
      var or = Gt.pipes, Xt = Gt.pipesCount;
      Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1;
      for (var zt = 0; zt < Xt; zt++)
        or[zt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var ur = Zt(Gt.pipes, Wt);
    return ur === -1 ? this : (Gt.pipes.splice(ur, 1), Gt.pipesCount -= 1, Gt.pipesCount === 1 && (Gt.pipes = Gt.pipes[0]), Wt.emit("unpipe", this, rr), this);
  }, _t.prototype.on = function(Wt, Gt) {
    var rr = ae.prototype.on.call(this, Wt, Gt);
    if (Wt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Wt === "readable") {
      var or = this._readableState;
      !or.endEmitted && !or.readableListening && (or.readableListening = or.needReadable = !0, or.emittedReadable = !1, or.reading ? or.length && Nt(this) : B.nextTick(bt, this));
    }
    return rr;
  }, _t.prototype.addListener = _t.prototype.on;
  function bt(Wt) {
    Ee("readable nexttick read 0"), Wt.read(0);
  }
  _t.prototype.resume = function() {
    var Wt = this._readableState;
    return Wt.flowing || (Ee("resume"), Wt.flowing = !0, wt(this, Wt)), this;
  };
  function wt(Wt, Gt) {
    Gt.resumeScheduled || (Gt.resumeScheduled = !0, B.nextTick(xt, Wt, Gt));
  }
  function xt(Wt, Gt) {
    Gt.reading || (Ee("resume read 0"), Wt.read(0)), Gt.resumeScheduled = !1, Gt.awaitDrain = 0, Wt.emit("resume"), Bt(Wt), Gt.flowing && !Gt.reading && Wt.read(0);
  }
  _t.prototype.pause = function() {
    return Ee("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ee("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function Bt(Wt) {
    var Gt = Wt._readableState;
    for (Ee("flow", Gt.flowing); Gt.flowing && Wt.read() !== null; )
      ;
  }
  _t.prototype.wrap = function(Wt) {
    var Gt = this, rr = this._readableState, or = !1;
    Wt.on("end", function() {
      if (Ee("wrapped end"), rr.decoder && !rr.ended) {
        var ur = rr.decoder.end();
        ur && ur.length && Gt.push(ur);
      }
      Gt.push(null);
    }), Wt.on("data", function(ur) {
      if (Ee("wrapped data"), rr.decoder && (ur = rr.decoder.write(ur)), !(rr.objectMode && ur == null) && !(!rr.objectMode && (!ur || !ur.length))) {
        var pr = Gt.push(ur);
        pr || (or = !0, Wt.pause());
      }
    });
    for (var Xt in Wt)
      this[Xt] === void 0 && typeof Wt[Xt] == "function" && (this[Xt] = /* @__PURE__ */ function(ur) {
        return function() {
          return Wt[ur].apply(Wt, arguments);
        };
      }(Xt));
    for (var zt = 0; zt < ht.length; zt++)
      Wt.on(ht[zt], this.emit.bind(this, ht[zt]));
    return this._read = function(ur) {
      Ee("wrapped _read", ur), or && (or = !1, Wt.resume());
    }, this;
  }, Object.defineProperty(_t.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), _t._fromList = $t;
  function $t(Wt, Gt) {
    if (Gt.length === 0) return null;
    var rr;
    return Gt.objectMode ? rr = Gt.buffer.shift() : !Wt || Wt >= Gt.length ? (Gt.decoder ? rr = Gt.buffer.join("") : Gt.buffer.length === 1 ? rr = Gt.buffer.head.data : rr = Gt.buffer.concat(Gt.length), Gt.buffer.clear()) : rr = qt(Wt, Gt.buffer, Gt.decoder), rr;
  }
  function qt(Wt, Gt, rr) {
    var or;
    return Wt < Gt.head.data.length ? (or = Gt.head.data.slice(0, Wt), Gt.head.data = Gt.head.data.slice(Wt)) : Wt === Gt.head.data.length ? or = Gt.shift() : or = rr ? Rt(Wt, Gt) : Lt(Wt, Gt), or;
  }
  function Rt(Wt, Gt) {
    var rr = Gt.head, or = 1, Xt = rr.data;
    for (Wt -= Xt.length; rr = rr.next; ) {
      var zt = rr.data, ur = Wt > zt.length ? zt.length : Wt;
      if (ur === zt.length ? Xt += zt : Xt += zt.slice(0, Wt), Wt -= ur, Wt === 0) {
        ur === zt.length ? (++or, rr.next ? Gt.head = rr.next : Gt.head = Gt.tail = null) : (Gt.head = rr, rr.data = zt.slice(ur));
        break;
      }
      ++or;
    }
    return Gt.length -= or, Xt;
  }
  function Lt(Wt, Gt) {
    var rr = ie.allocUnsafe(Wt), or = Gt.head, Xt = 1;
    for (or.data.copy(rr), Wt -= or.data.length; or = or.next; ) {
      var zt = or.data, ur = Wt > zt.length ? zt.length : Wt;
      if (zt.copy(rr, rr.length - Wt, 0, ur), Wt -= ur, Wt === 0) {
        ur === zt.length ? (++Xt, or.next ? Gt.head = or.next : Gt.head = Gt.tail = null) : (Gt.head = or, or.data = zt.slice(ur));
        break;
      }
      ++Xt;
    }
    return Gt.length -= Xt, rr;
  }
  function tr(Wt) {
    var Gt = Wt._readableState;
    if (Gt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Gt.endEmitted || (Gt.ended = !0, B.nextTick(sr, Gt, Wt));
  }
  function sr(Wt, Gt) {
    !Wt.endEmitted && Wt.length === 0 && (Wt.endEmitted = !0, Gt.readable = !1, Gt.emit("end"));
  }
  function Zt(Wt, Gt) {
    for (var rr = 0, or = Wt.length; rr < or; rr++)
      if (Wt[rr] === Gt) return rr;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = ne;
  var B = require_stream_duplex(), z = Object.create(requireUtil());
  z.inherits = requireInherits_browser(), z.inherits(ne, B);
  function Y(se, le) {
    var ve = this._transformState;
    ve.transforming = !1;
    var ge = ve.writecb;
    if (!ge)
      return this.emit("error", new Error("write callback called multiple times"));
    ve.writechunk = null, ve.writecb = null, le != null && this.push(le), ge(se);
    var oe = this._readableState;
    oe.reading = !1, (oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
  }
  function ne(se) {
    if (!(this instanceof ne)) return new ne(se);
    B.call(this, se), this._transformState = {
      afterTransform: Y.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, se && (typeof se.transform == "function" && (this._transform = se.transform), typeof se.flush == "function" && (this._flush = se.flush)), this.on("prefinish", ae);
  }
  function ae() {
    var se = this;
    typeof this._flush == "function" ? this._flush(function(le, ve) {
      ie(se, le, ve);
    }) : ie(this, null, null);
  }
  ne.prototype.push = function(se, le) {
    return this._transformState.needTransform = !1, B.prototype.push.call(this, se, le);
  }, ne.prototype._transform = function(se, le, ve) {
    throw new Error("_transform() is not implemented");
  }, ne.prototype._write = function(se, le, ve) {
    var ge = this._transformState;
    if (ge.writecb = ve, ge.writechunk = se, ge.writeencoding = le, !ge.transforming) {
      var oe = this._readableState;
      (ge.needTransform || oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
    }
  }, ne.prototype._read = function(se) {
    var le = this._transformState;
    le.writechunk !== null && le.writecb && !le.transforming ? (le.transforming = !0, this._transform(le.writechunk, le.writeencoding, le.afterTransform)) : le.needTransform = !0;
  }, ne.prototype._destroy = function(se, le) {
    var ve = this;
    B.prototype._destroy.call(this, se, function(ge) {
      le(ge), ve.emit("close");
    });
  };
  function ie(se, le, ve) {
    if (le) return se.emit("error", le);
    if (ve != null && se.push(ve), se._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (se._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return se.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = Y;
  var B = require_stream_transform(), z = Object.create(requireUtil());
  z.inherits = requireInherits_browser(), z.inherits(Y, B);
  function Y(ne) {
    if (!(this instanceof Y)) return new Y(ne);
    B.call(this, ne);
  }
  return Y.prototype._transform = function(ne, ae, ie) {
    ie(null, ne);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(B, z) {
    z = B.exports = require_stream_readable(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable(), z.Duplex = require_stream_duplex(), z.Transform = require_stream_transform(), z.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(B) {
    (function(z, Y) {
      function ne(Xe, Ke) {
        if (!Xe) throw new Error(Ke || "Assertion failed");
      }
      function ae(Xe, Ke) {
        Xe.super_ = Ke;
        var Qe = function() {
        };
        Qe.prototype = Ke.prototype, Xe.prototype = new Qe(), Xe.prototype.constructor = Xe;
      }
      function ie(Xe, Ke, Qe) {
        if (ie.isBN(Xe))
          return Xe;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Xe !== null && ((Ke === "le" || Ke === "be") && (Qe = Ke, Ke = 10), this._init(Xe || 0, Ke || 10, Qe || "be"));
      }
      typeof z == "object" ? z.exports = ie : Y.BN = ie, ie.BN = ie, ie.wordSize = 26;
      var se;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? se = window.Buffer : se = require$$0$1.Buffer;
      } catch {
      }
      ie.isBN = function(Ke) {
        return Ke instanceof ie ? !0 : Ke !== null && typeof Ke == "object" && Ke.constructor.wordSize === ie.wordSize && Array.isArray(Ke.words);
      }, ie.max = function(Ke, Qe) {
        return Ke.cmp(Qe) > 0 ? Ke : Qe;
      }, ie.min = function(Ke, Qe) {
        return Ke.cmp(Qe) < 0 ? Ke : Qe;
      }, ie.prototype._init = function(Ke, Qe, bt) {
        if (typeof Ke == "number")
          return this._initNumber(Ke, Qe, bt);
        if (typeof Ke == "object")
          return this._initArray(Ke, Qe, bt);
        Qe === "hex" && (Qe = 16), ne(Qe === (Qe | 0) && Qe >= 2 && Qe <= 36), Ke = Ke.toString().replace(/\s+/g, "");
        var wt = 0;
        Ke[0] === "-" && (wt++, this.negative = 1), wt < Ke.length && (Qe === 16 ? this._parseHex(Ke, wt, bt) : (this._parseBase(Ke, Qe, wt), bt === "le" && this._initArray(this.toArray(), Qe, bt)));
      }, ie.prototype._initNumber = function(Ke, Qe, bt) {
        Ke < 0 && (this.negative = 1, Ke = -Ke), Ke < 67108864 ? (this.words = [Ke & 67108863], this.length = 1) : Ke < 4503599627370496 ? (this.words = [
          Ke & 67108863,
          Ke / 67108864 & 67108863
        ], this.length = 2) : (ne(Ke < 9007199254740992), this.words = [
          Ke & 67108863,
          Ke / 67108864 & 67108863,
          1
        ], this.length = 3), bt === "le" && this._initArray(this.toArray(), Qe, bt);
      }, ie.prototype._initArray = function(Ke, Qe, bt) {
        if (ne(typeof Ke.length == "number"), Ke.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Ke.length / 3), this.words = new Array(this.length);
        for (var wt = 0; wt < this.length; wt++)
          this.words[wt] = 0;
        var xt, Bt, $t = 0;
        if (bt === "be")
          for (wt = Ke.length - 1, xt = 0; wt >= 0; wt -= 3)
            Bt = Ke[wt] | Ke[wt - 1] << 8 | Ke[wt - 2] << 16, this.words[xt] |= Bt << $t & 67108863, this.words[xt + 1] = Bt >>> 26 - $t & 67108863, $t += 24, $t >= 26 && ($t -= 26, xt++);
        else if (bt === "le")
          for (wt = 0, xt = 0; wt < Ke.length; wt += 3)
            Bt = Ke[wt] | Ke[wt + 1] << 8 | Ke[wt + 2] << 16, this.words[xt] |= Bt << $t & 67108863, this.words[xt + 1] = Bt >>> 26 - $t & 67108863, $t += 24, $t >= 26 && ($t -= 26, xt++);
        return this._strip();
      };
      function le(Xe, Ke) {
        var Qe = Xe.charCodeAt(Ke);
        if (Qe >= 48 && Qe <= 57)
          return Qe - 48;
        if (Qe >= 65 && Qe <= 70)
          return Qe - 55;
        if (Qe >= 97 && Qe <= 102)
          return Qe - 87;
        ne(!1, "Invalid character in " + Xe);
      }
      function ve(Xe, Ke, Qe) {
        var bt = le(Xe, Qe);
        return Qe - 1 >= Ke && (bt |= le(Xe, Qe - 1) << 4), bt;
      }
      ie.prototype._parseHex = function(Ke, Qe, bt) {
        this.length = Math.ceil((Ke.length - Qe) / 6), this.words = new Array(this.length);
        for (var wt = 0; wt < this.length; wt++)
          this.words[wt] = 0;
        var xt = 0, Bt = 0, $t;
        if (bt === "be")
          for (wt = Ke.length - 1; wt >= Qe; wt -= 2)
            $t = ve(Ke, Qe, wt) << xt, this.words[Bt] |= $t & 67108863, xt >= 18 ? (xt -= 18, Bt += 1, this.words[Bt] |= $t >>> 26) : xt += 8;
        else {
          var qt = Ke.length - Qe;
          for (wt = qt % 2 === 0 ? Qe + 1 : Qe; wt < Ke.length; wt += 2)
            $t = ve(Ke, Qe, wt) << xt, this.words[Bt] |= $t & 67108863, xt >= 18 ? (xt -= 18, Bt += 1, this.words[Bt] |= $t >>> 26) : xt += 8;
        }
        this._strip();
      };
      function ge(Xe, Ke, Qe, bt) {
        for (var wt = 0, xt = 0, Bt = Math.min(Xe.length, Qe), $t = Ke; $t < Bt; $t++) {
          var qt = Xe.charCodeAt($t) - 48;
          wt *= bt, qt >= 49 ? xt = qt - 49 + 10 : qt >= 17 ? xt = qt - 17 + 10 : xt = qt, ne(qt >= 0 && xt < bt, "Invalid character"), wt += xt;
        }
        return wt;
      }
      ie.prototype._parseBase = function(Ke, Qe, bt) {
        this.words = [0], this.length = 1;
        for (var wt = 0, xt = 1; xt <= 67108863; xt *= Qe)
          wt++;
        wt--, xt = xt / Qe | 0;
        for (var Bt = Ke.length - bt, $t = Bt % wt, qt = Math.min(Bt, Bt - $t) + bt, Rt = 0, Lt = bt; Lt < qt; Lt += wt)
          Rt = ge(Ke, Lt, Lt + wt, Qe), this.imuln(xt), this.words[0] + Rt < 67108864 ? this.words[0] += Rt : this._iaddn(Rt);
        if ($t !== 0) {
          var tr = 1;
          for (Rt = ge(Ke, Lt, Ke.length, Qe), Lt = 0; Lt < $t; Lt++)
            tr *= Qe;
          this.imuln(tr), this.words[0] + Rt < 67108864 ? this.words[0] += Rt : this._iaddn(Rt);
        }
        this._strip();
      }, ie.prototype.copy = function(Ke) {
        Ke.words = new Array(this.length);
        for (var Qe = 0; Qe < this.length; Qe++)
          Ke.words[Qe] = this.words[Qe];
        Ke.length = this.length, Ke.negative = this.negative, Ke.red = this.red;
      };
      function oe(Xe, Ke) {
        Xe.words = Ke.words, Xe.length = Ke.length, Xe.negative = Ke.negative, Xe.red = Ke.red;
      }
      if (ie.prototype._move = function(Ke) {
        oe(Ke, this);
      }, ie.prototype.clone = function() {
        var Ke = new ie(null);
        return this.copy(Ke), Ke;
      }, ie.prototype._expand = function(Ke) {
        for (; this.length < Ke; )
          this.words[this.length++] = 0;
        return this;
      }, ie.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ie.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          ie.prototype[Symbol.for("nodejs.util.inspect.custom")] = Ee;
        } catch {
          ie.prototype.inspect = Ee;
        }
      else
        ie.prototype.inspect = Ee;
      function Ee() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Ce = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Pe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Ve = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ie.prototype.toString = function(Ke, Qe) {
        Ke = Ke || 10, Qe = Qe | 0 || 1;
        var bt;
        if (Ke === 16 || Ke === "hex") {
          bt = "";
          for (var wt = 0, xt = 0, Bt = 0; Bt < this.length; Bt++) {
            var $t = this.words[Bt], qt = (($t << wt | xt) & 16777215).toString(16);
            xt = $t >>> 24 - wt & 16777215, wt += 2, wt >= 26 && (wt -= 26, Bt--), xt !== 0 || Bt !== this.length - 1 ? bt = Ce[6 - qt.length] + qt + bt : bt = qt + bt;
          }
          for (xt !== 0 && (bt = xt.toString(16) + bt); bt.length % Qe !== 0; )
            bt = "0" + bt;
          return this.negative !== 0 && (bt = "-" + bt), bt;
        }
        if (Ke === (Ke | 0) && Ke >= 2 && Ke <= 36) {
          var Rt = Pe[Ke], Lt = Ve[Ke];
          bt = "";
          var tr = this.clone();
          for (tr.negative = 0; !tr.isZero(); ) {
            var sr = tr.modrn(Lt).toString(Ke);
            tr = tr.idivn(Lt), tr.isZero() ? bt = sr + bt : bt = Ce[Rt - sr.length] + sr + bt;
          }
          for (this.isZero() && (bt = "0" + bt); bt.length % Qe !== 0; )
            bt = "0" + bt;
          return this.negative !== 0 && (bt = "-" + bt), bt;
        }
        ne(!1, "Base should be between 2 and 36");
      }, ie.prototype.toNumber = function() {
        var Ke = this.words[0];
        return this.length === 2 ? Ke += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Ke += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Ke : Ke;
      }, ie.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, se && (ie.prototype.toBuffer = function(Ke, Qe) {
        return this.toArrayLike(se, Ke, Qe);
      }), ie.prototype.toArray = function(Ke, Qe) {
        return this.toArrayLike(Array, Ke, Qe);
      };
      var ht = function(Ke, Qe) {
        return Ke.allocUnsafe ? Ke.allocUnsafe(Qe) : new Ke(Qe);
      };
      ie.prototype.toArrayLike = function(Ke, Qe, bt) {
        this._strip();
        var wt = this.byteLength(), xt = bt || Math.max(1, wt);
        ne(wt <= xt, "byte array longer than desired length"), ne(xt > 0, "Requested array length <= 0");
        var Bt = ht(Ke, xt), $t = Qe === "le" ? "LE" : "BE";
        return this["_toArrayLike" + $t](Bt, wt), Bt;
      }, ie.prototype._toArrayLikeLE = function(Ke, Qe) {
        for (var bt = 0, wt = 0, xt = 0, Bt = 0; xt < this.length; xt++) {
          var $t = this.words[xt] << Bt | wt;
          Ke[bt++] = $t & 255, bt < Ke.length && (Ke[bt++] = $t >> 8 & 255), bt < Ke.length && (Ke[bt++] = $t >> 16 & 255), Bt === 6 ? (bt < Ke.length && (Ke[bt++] = $t >> 24 & 255), wt = 0, Bt = 0) : (wt = $t >>> 24, Bt += 2);
        }
        if (bt < Ke.length)
          for (Ke[bt++] = wt; bt < Ke.length; )
            Ke[bt++] = 0;
      }, ie.prototype._toArrayLikeBE = function(Ke, Qe) {
        for (var bt = Ke.length - 1, wt = 0, xt = 0, Bt = 0; xt < this.length; xt++) {
          var $t = this.words[xt] << Bt | wt;
          Ke[bt--] = $t & 255, bt >= 0 && (Ke[bt--] = $t >> 8 & 255), bt >= 0 && (Ke[bt--] = $t >> 16 & 255), Bt === 6 ? (bt >= 0 && (Ke[bt--] = $t >> 24 & 255), wt = 0, Bt = 0) : (wt = $t >>> 24, Bt += 2);
        }
        if (bt >= 0)
          for (Ke[bt--] = wt; bt >= 0; )
            Ke[bt--] = 0;
      }, Math.clz32 ? ie.prototype._countBits = function(Ke) {
        return 32 - Math.clz32(Ke);
      } : ie.prototype._countBits = function(Ke) {
        var Qe = Ke, bt = 0;
        return Qe >= 4096 && (bt += 13, Qe >>>= 13), Qe >= 64 && (bt += 7, Qe >>>= 7), Qe >= 8 && (bt += 4, Qe >>>= 4), Qe >= 2 && (bt += 2, Qe >>>= 2), bt + Qe;
      }, ie.prototype._zeroBits = function(Ke) {
        if (Ke === 0) return 26;
        var Qe = Ke, bt = 0;
        return Qe & 8191 || (bt += 13, Qe >>>= 13), Qe & 127 || (bt += 7, Qe >>>= 7), Qe & 15 || (bt += 4, Qe >>>= 4), Qe & 3 || (bt += 2, Qe >>>= 2), Qe & 1 || bt++, bt;
      }, ie.prototype.bitLength = function() {
        var Ke = this.words[this.length - 1], Qe = this._countBits(Ke);
        return (this.length - 1) * 26 + Qe;
      };
      function vt(Xe) {
        for (var Ke = new Array(Xe.bitLength()), Qe = 0; Qe < Ke.length; Qe++) {
          var bt = Qe / 26 | 0, wt = Qe % 26;
          Ke[Qe] = Xe.words[bt] >>> wt & 1;
        }
        return Ke;
      }
      ie.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Ke = 0, Qe = 0; Qe < this.length; Qe++) {
          var bt = this._zeroBits(this.words[Qe]);
          if (Ke += bt, bt !== 26) break;
        }
        return Ke;
      }, ie.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ie.prototype.toTwos = function(Ke) {
        return this.negative !== 0 ? this.abs().inotn(Ke).iaddn(1) : this.clone();
      }, ie.prototype.fromTwos = function(Ke) {
        return this.testn(Ke - 1) ? this.notn(Ke).iaddn(1).ineg() : this.clone();
      }, ie.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ie.prototype.neg = function() {
        return this.clone().ineg();
      }, ie.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ie.prototype.iuor = function(Ke) {
        for (; this.length < Ke.length; )
          this.words[this.length++] = 0;
        for (var Qe = 0; Qe < Ke.length; Qe++)
          this.words[Qe] = this.words[Qe] | Ke.words[Qe];
        return this._strip();
      }, ie.prototype.ior = function(Ke) {
        return ne((this.negative | Ke.negative) === 0), this.iuor(Ke);
      }, ie.prototype.or = function(Ke) {
        return this.length > Ke.length ? this.clone().ior(Ke) : Ke.clone().ior(this);
      }, ie.prototype.uor = function(Ke) {
        return this.length > Ke.length ? this.clone().iuor(Ke) : Ke.clone().iuor(this);
      }, ie.prototype.iuand = function(Ke) {
        var Qe;
        this.length > Ke.length ? Qe = Ke : Qe = this;
        for (var bt = 0; bt < Qe.length; bt++)
          this.words[bt] = this.words[bt] & Ke.words[bt];
        return this.length = Qe.length, this._strip();
      }, ie.prototype.iand = function(Ke) {
        return ne((this.negative | Ke.negative) === 0), this.iuand(Ke);
      }, ie.prototype.and = function(Ke) {
        return this.length > Ke.length ? this.clone().iand(Ke) : Ke.clone().iand(this);
      }, ie.prototype.uand = function(Ke) {
        return this.length > Ke.length ? this.clone().iuand(Ke) : Ke.clone().iuand(this);
      }, ie.prototype.iuxor = function(Ke) {
        var Qe, bt;
        this.length > Ke.length ? (Qe = this, bt = Ke) : (Qe = Ke, bt = this);
        for (var wt = 0; wt < bt.length; wt++)
          this.words[wt] = Qe.words[wt] ^ bt.words[wt];
        if (this !== Qe)
          for (; wt < Qe.length; wt++)
            this.words[wt] = Qe.words[wt];
        return this.length = Qe.length, this._strip();
      }, ie.prototype.ixor = function(Ke) {
        return ne((this.negative | Ke.negative) === 0), this.iuxor(Ke);
      }, ie.prototype.xor = function(Ke) {
        return this.length > Ke.length ? this.clone().ixor(Ke) : Ke.clone().ixor(this);
      }, ie.prototype.uxor = function(Ke) {
        return this.length > Ke.length ? this.clone().iuxor(Ke) : Ke.clone().iuxor(this);
      }, ie.prototype.inotn = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Math.ceil(Ke / 26) | 0, bt = Ke % 26;
        this._expand(Qe), bt > 0 && Qe--;
        for (var wt = 0; wt < Qe; wt++)
          this.words[wt] = ~this.words[wt] & 67108863;
        return bt > 0 && (this.words[wt] = ~this.words[wt] & 67108863 >> 26 - bt), this._strip();
      }, ie.prototype.notn = function(Ke) {
        return this.clone().inotn(Ke);
      }, ie.prototype.setn = function(Ke, Qe) {
        ne(typeof Ke == "number" && Ke >= 0);
        var bt = Ke / 26 | 0, wt = Ke % 26;
        return this._expand(bt + 1), Qe ? this.words[bt] = this.words[bt] | 1 << wt : this.words[bt] = this.words[bt] & ~(1 << wt), this._strip();
      }, ie.prototype.iadd = function(Ke) {
        var Qe;
        if (this.negative !== 0 && Ke.negative === 0)
          return this.negative = 0, Qe = this.isub(Ke), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Ke.negative !== 0)
          return Ke.negative = 0, Qe = this.isub(Ke), Ke.negative = 1, Qe._normSign();
        var bt, wt;
        this.length > Ke.length ? (bt = this, wt = Ke) : (bt = Ke, wt = this);
        for (var xt = 0, Bt = 0; Bt < wt.length; Bt++)
          Qe = (bt.words[Bt] | 0) + (wt.words[Bt] | 0) + xt, this.words[Bt] = Qe & 67108863, xt = Qe >>> 26;
        for (; xt !== 0 && Bt < bt.length; Bt++)
          Qe = (bt.words[Bt] | 0) + xt, this.words[Bt] = Qe & 67108863, xt = Qe >>> 26;
        if (this.length = bt.length, xt !== 0)
          this.words[this.length] = xt, this.length++;
        else if (bt !== this)
          for (; Bt < bt.length; Bt++)
            this.words[Bt] = bt.words[Bt];
        return this;
      }, ie.prototype.add = function(Ke) {
        var Qe;
        return Ke.negative !== 0 && this.negative === 0 ? (Ke.negative = 0, Qe = this.sub(Ke), Ke.negative ^= 1, Qe) : Ke.negative === 0 && this.negative !== 0 ? (this.negative = 0, Qe = Ke.sub(this), this.negative = 1, Qe) : this.length > Ke.length ? this.clone().iadd(Ke) : Ke.clone().iadd(this);
      }, ie.prototype.isub = function(Ke) {
        if (Ke.negative !== 0) {
          Ke.negative = 0;
          var Qe = this.iadd(Ke);
          return Ke.negative = 1, Qe._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Ke), this.negative = 1, this._normSign();
        var bt = this.cmp(Ke);
        if (bt === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var wt, xt;
        bt > 0 ? (wt = this, xt = Ke) : (wt = Ke, xt = this);
        for (var Bt = 0, $t = 0; $t < xt.length; $t++)
          Qe = (wt.words[$t] | 0) - (xt.words[$t] | 0) + Bt, Bt = Qe >> 26, this.words[$t] = Qe & 67108863;
        for (; Bt !== 0 && $t < wt.length; $t++)
          Qe = (wt.words[$t] | 0) + Bt, Bt = Qe >> 26, this.words[$t] = Qe & 67108863;
        if (Bt === 0 && $t < wt.length && wt !== this)
          for (; $t < wt.length; $t++)
            this.words[$t] = wt.words[$t];
        return this.length = Math.max(this.length, $t), wt !== this && (this.negative = 1), this._strip();
      }, ie.prototype.sub = function(Ke) {
        return this.clone().isub(Ke);
      };
      function Pt(Xe, Ke, Qe) {
        Qe.negative = Ke.negative ^ Xe.negative;
        var bt = Xe.length + Ke.length | 0;
        Qe.length = bt, bt = bt - 1 | 0;
        var wt = Xe.words[0] | 0, xt = Ke.words[0] | 0, Bt = wt * xt, $t = Bt & 67108863, qt = Bt / 67108864 | 0;
        Qe.words[0] = $t;
        for (var Rt = 1; Rt < bt; Rt++) {
          for (var Lt = qt >>> 26, tr = qt & 67108863, sr = Math.min(Rt, Ke.length - 1), Zt = Math.max(0, Rt - Xe.length + 1); Zt <= sr; Zt++) {
            var Wt = Rt - Zt | 0;
            wt = Xe.words[Wt] | 0, xt = Ke.words[Zt] | 0, Bt = wt * xt + tr, Lt += Bt / 67108864 | 0, tr = Bt & 67108863;
          }
          Qe.words[Rt] = tr | 0, qt = Lt | 0;
        }
        return qt !== 0 ? Qe.words[Rt] = qt | 0 : Qe.length--, Qe._strip();
      }
      var _t = function(Ke, Qe, bt) {
        var wt = Ke.words, xt = Qe.words, Bt = bt.words, $t = 0, qt, Rt, Lt, tr = wt[0] | 0, sr = tr & 8191, Zt = tr >>> 13, Wt = wt[1] | 0, Gt = Wt & 8191, rr = Wt >>> 13, or = wt[2] | 0, Xt = or & 8191, zt = or >>> 13, ur = wt[3] | 0, pr = ur & 8191, vr = ur >>> 13, _r = wt[4] | 0, xr = _r & 8191, Tr = _r >>> 13, hr = wt[5] | 0, Wr = hr & 8191, $r = hr >>> 13, Ur = wt[6] | 0, Gr = Ur & 8191, Rr = Ur >>> 13, Hr = wt[7] | 0, Xr = Hr & 8191, qr = Hr >>> 13, zr = wt[8] | 0, Qr = zr & 8191, Vt = zr >>> 13, Ft = wt[9] | 0, Ut = Ft & 8191, Qt = Ft >>> 13, fr = xt[0] | 0, cr = fr & 8191, lr = fr >>> 13, kr = xt[1] | 0, jr = kr & 8191, Br = kr >>> 13, Dr = xt[2] | 0, Lr = Dr & 8191, Nr = Dr >>> 13, Yr = xt[3] | 0, Zr = Yr & 8191, nr = Yr >>> 13, Jt = xt[4] | 0, ir = Jt & 8191, ar = Jt >>> 13, dr = xt[5] | 0, yr = dr & 8191, gr = dr >>> 13, Er = xt[6] | 0, Pr = Er & 8191, Ar = Er >>> 13, Mr = xt[7] | 0, Cr = Mr & 8191, er = Mr >>> 13, br = xt[8] | 0, wr = br & 8191, Sr = br >>> 13, Or = xt[9] | 0, Fr = Or & 8191, Ir = Or >>> 13;
        bt.negative = Ke.negative ^ Qe.negative, bt.length = 19, qt = Math.imul(sr, cr), Rt = Math.imul(sr, lr), Rt = Rt + Math.imul(Zt, cr) | 0, Lt = Math.imul(Zt, lr);
        var Vr = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, qt = Math.imul(Gt, cr), Rt = Math.imul(Gt, lr), Rt = Rt + Math.imul(rr, cr) | 0, Lt = Math.imul(rr, lr), qt = qt + Math.imul(sr, jr) | 0, Rt = Rt + Math.imul(sr, Br) | 0, Rt = Rt + Math.imul(Zt, jr) | 0, Lt = Lt + Math.imul(Zt, Br) | 0;
        var tn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, qt = Math.imul(Xt, cr), Rt = Math.imul(Xt, lr), Rt = Rt + Math.imul(zt, cr) | 0, Lt = Math.imul(zt, lr), qt = qt + Math.imul(Gt, jr) | 0, Rt = Rt + Math.imul(Gt, Br) | 0, Rt = Rt + Math.imul(rr, jr) | 0, Lt = Lt + Math.imul(rr, Br) | 0, qt = qt + Math.imul(sr, Lr) | 0, Rt = Rt + Math.imul(sr, Nr) | 0, Rt = Rt + Math.imul(Zt, Lr) | 0, Lt = Lt + Math.imul(Zt, Nr) | 0;
        var Jr = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, qt = Math.imul(pr, cr), Rt = Math.imul(pr, lr), Rt = Rt + Math.imul(vr, cr) | 0, Lt = Math.imul(vr, lr), qt = qt + Math.imul(Xt, jr) | 0, Rt = Rt + Math.imul(Xt, Br) | 0, Rt = Rt + Math.imul(zt, jr) | 0, Lt = Lt + Math.imul(zt, Br) | 0, qt = qt + Math.imul(Gt, Lr) | 0, Rt = Rt + Math.imul(Gt, Nr) | 0, Rt = Rt + Math.imul(rr, Lr) | 0, Lt = Lt + Math.imul(rr, Nr) | 0, qt = qt + Math.imul(sr, Zr) | 0, Rt = Rt + Math.imul(sr, nr) | 0, Rt = Rt + Math.imul(Zt, Zr) | 0, Lt = Lt + Math.imul(Zt, nr) | 0;
        var en = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, qt = Math.imul(xr, cr), Rt = Math.imul(xr, lr), Rt = Rt + Math.imul(Tr, cr) | 0, Lt = Math.imul(Tr, lr), qt = qt + Math.imul(pr, jr) | 0, Rt = Rt + Math.imul(pr, Br) | 0, Rt = Rt + Math.imul(vr, jr) | 0, Lt = Lt + Math.imul(vr, Br) | 0, qt = qt + Math.imul(Xt, Lr) | 0, Rt = Rt + Math.imul(Xt, Nr) | 0, Rt = Rt + Math.imul(zt, Lr) | 0, Lt = Lt + Math.imul(zt, Nr) | 0, qt = qt + Math.imul(Gt, Zr) | 0, Rt = Rt + Math.imul(Gt, nr) | 0, Rt = Rt + Math.imul(rr, Zr) | 0, Lt = Lt + Math.imul(rr, nr) | 0, qt = qt + Math.imul(sr, ir) | 0, Rt = Rt + Math.imul(sr, ar) | 0, Rt = Rt + Math.imul(Zt, ir) | 0, Lt = Lt + Math.imul(Zt, ar) | 0;
        var an = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, qt = Math.imul(Wr, cr), Rt = Math.imul(Wr, lr), Rt = Rt + Math.imul($r, cr) | 0, Lt = Math.imul($r, lr), qt = qt + Math.imul(xr, jr) | 0, Rt = Rt + Math.imul(xr, Br) | 0, Rt = Rt + Math.imul(Tr, jr) | 0, Lt = Lt + Math.imul(Tr, Br) | 0, qt = qt + Math.imul(pr, Lr) | 0, Rt = Rt + Math.imul(pr, Nr) | 0, Rt = Rt + Math.imul(vr, Lr) | 0, Lt = Lt + Math.imul(vr, Nr) | 0, qt = qt + Math.imul(Xt, Zr) | 0, Rt = Rt + Math.imul(Xt, nr) | 0, Rt = Rt + Math.imul(zt, Zr) | 0, Lt = Lt + Math.imul(zt, nr) | 0, qt = qt + Math.imul(Gt, ir) | 0, Rt = Rt + Math.imul(Gt, ar) | 0, Rt = Rt + Math.imul(rr, ir) | 0, Lt = Lt + Math.imul(rr, ar) | 0, qt = qt + Math.imul(sr, yr) | 0, Rt = Rt + Math.imul(sr, gr) | 0, Rt = Rt + Math.imul(Zt, yr) | 0, Lt = Lt + Math.imul(Zt, gr) | 0;
        var on = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, qt = Math.imul(Gr, cr), Rt = Math.imul(Gr, lr), Rt = Rt + Math.imul(Rr, cr) | 0, Lt = Math.imul(Rr, lr), qt = qt + Math.imul(Wr, jr) | 0, Rt = Rt + Math.imul(Wr, Br) | 0, Rt = Rt + Math.imul($r, jr) | 0, Lt = Lt + Math.imul($r, Br) | 0, qt = qt + Math.imul(xr, Lr) | 0, Rt = Rt + Math.imul(xr, Nr) | 0, Rt = Rt + Math.imul(Tr, Lr) | 0, Lt = Lt + Math.imul(Tr, Nr) | 0, qt = qt + Math.imul(pr, Zr) | 0, Rt = Rt + Math.imul(pr, nr) | 0, Rt = Rt + Math.imul(vr, Zr) | 0, Lt = Lt + Math.imul(vr, nr) | 0, qt = qt + Math.imul(Xt, ir) | 0, Rt = Rt + Math.imul(Xt, ar) | 0, Rt = Rt + Math.imul(zt, ir) | 0, Lt = Lt + Math.imul(zt, ar) | 0, qt = qt + Math.imul(Gt, yr) | 0, Rt = Rt + Math.imul(Gt, gr) | 0, Rt = Rt + Math.imul(rr, yr) | 0, Lt = Lt + Math.imul(rr, gr) | 0, qt = qt + Math.imul(sr, Pr) | 0, Rt = Rt + Math.imul(sr, Ar) | 0, Rt = Rt + Math.imul(Zt, Pr) | 0, Lt = Lt + Math.imul(Zt, Ar) | 0;
        var sn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, qt = Math.imul(Xr, cr), Rt = Math.imul(Xr, lr), Rt = Rt + Math.imul(qr, cr) | 0, Lt = Math.imul(qr, lr), qt = qt + Math.imul(Gr, jr) | 0, Rt = Rt + Math.imul(Gr, Br) | 0, Rt = Rt + Math.imul(Rr, jr) | 0, Lt = Lt + Math.imul(Rr, Br) | 0, qt = qt + Math.imul(Wr, Lr) | 0, Rt = Rt + Math.imul(Wr, Nr) | 0, Rt = Rt + Math.imul($r, Lr) | 0, Lt = Lt + Math.imul($r, Nr) | 0, qt = qt + Math.imul(xr, Zr) | 0, Rt = Rt + Math.imul(xr, nr) | 0, Rt = Rt + Math.imul(Tr, Zr) | 0, Lt = Lt + Math.imul(Tr, nr) | 0, qt = qt + Math.imul(pr, ir) | 0, Rt = Rt + Math.imul(pr, ar) | 0, Rt = Rt + Math.imul(vr, ir) | 0, Lt = Lt + Math.imul(vr, ar) | 0, qt = qt + Math.imul(Xt, yr) | 0, Rt = Rt + Math.imul(Xt, gr) | 0, Rt = Rt + Math.imul(zt, yr) | 0, Lt = Lt + Math.imul(zt, gr) | 0, qt = qt + Math.imul(Gt, Pr) | 0, Rt = Rt + Math.imul(Gt, Ar) | 0, Rt = Rt + Math.imul(rr, Pr) | 0, Lt = Lt + Math.imul(rr, Ar) | 0, qt = qt + Math.imul(sr, Cr) | 0, Rt = Rt + Math.imul(sr, er) | 0, Rt = Rt + Math.imul(Zt, Cr) | 0, Lt = Lt + Math.imul(Zt, er) | 0;
        var nn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, qt = Math.imul(Qr, cr), Rt = Math.imul(Qr, lr), Rt = Rt + Math.imul(Vt, cr) | 0, Lt = Math.imul(Vt, lr), qt = qt + Math.imul(Xr, jr) | 0, Rt = Rt + Math.imul(Xr, Br) | 0, Rt = Rt + Math.imul(qr, jr) | 0, Lt = Lt + Math.imul(qr, Br) | 0, qt = qt + Math.imul(Gr, Lr) | 0, Rt = Rt + Math.imul(Gr, Nr) | 0, Rt = Rt + Math.imul(Rr, Lr) | 0, Lt = Lt + Math.imul(Rr, Nr) | 0, qt = qt + Math.imul(Wr, Zr) | 0, Rt = Rt + Math.imul(Wr, nr) | 0, Rt = Rt + Math.imul($r, Zr) | 0, Lt = Lt + Math.imul($r, nr) | 0, qt = qt + Math.imul(xr, ir) | 0, Rt = Rt + Math.imul(xr, ar) | 0, Rt = Rt + Math.imul(Tr, ir) | 0, Lt = Lt + Math.imul(Tr, ar) | 0, qt = qt + Math.imul(pr, yr) | 0, Rt = Rt + Math.imul(pr, gr) | 0, Rt = Rt + Math.imul(vr, yr) | 0, Lt = Lt + Math.imul(vr, gr) | 0, qt = qt + Math.imul(Xt, Pr) | 0, Rt = Rt + Math.imul(Xt, Ar) | 0, Rt = Rt + Math.imul(zt, Pr) | 0, Lt = Lt + Math.imul(zt, Ar) | 0, qt = qt + Math.imul(Gt, Cr) | 0, Rt = Rt + Math.imul(Gt, er) | 0, Rt = Rt + Math.imul(rr, Cr) | 0, Lt = Lt + Math.imul(rr, er) | 0, qt = qt + Math.imul(sr, wr) | 0, Rt = Rt + Math.imul(sr, Sr) | 0, Rt = Rt + Math.imul(Zt, wr) | 0, Lt = Lt + Math.imul(Zt, Sr) | 0;
        var fn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, qt = Math.imul(Ut, cr), Rt = Math.imul(Ut, lr), Rt = Rt + Math.imul(Qt, cr) | 0, Lt = Math.imul(Qt, lr), qt = qt + Math.imul(Qr, jr) | 0, Rt = Rt + Math.imul(Qr, Br) | 0, Rt = Rt + Math.imul(Vt, jr) | 0, Lt = Lt + Math.imul(Vt, Br) | 0, qt = qt + Math.imul(Xr, Lr) | 0, Rt = Rt + Math.imul(Xr, Nr) | 0, Rt = Rt + Math.imul(qr, Lr) | 0, Lt = Lt + Math.imul(qr, Nr) | 0, qt = qt + Math.imul(Gr, Zr) | 0, Rt = Rt + Math.imul(Gr, nr) | 0, Rt = Rt + Math.imul(Rr, Zr) | 0, Lt = Lt + Math.imul(Rr, nr) | 0, qt = qt + Math.imul(Wr, ir) | 0, Rt = Rt + Math.imul(Wr, ar) | 0, Rt = Rt + Math.imul($r, ir) | 0, Lt = Lt + Math.imul($r, ar) | 0, qt = qt + Math.imul(xr, yr) | 0, Rt = Rt + Math.imul(xr, gr) | 0, Rt = Rt + Math.imul(Tr, yr) | 0, Lt = Lt + Math.imul(Tr, gr) | 0, qt = qt + Math.imul(pr, Pr) | 0, Rt = Rt + Math.imul(pr, Ar) | 0, Rt = Rt + Math.imul(vr, Pr) | 0, Lt = Lt + Math.imul(vr, Ar) | 0, qt = qt + Math.imul(Xt, Cr) | 0, Rt = Rt + Math.imul(Xt, er) | 0, Rt = Rt + Math.imul(zt, Cr) | 0, Lt = Lt + Math.imul(zt, er) | 0, qt = qt + Math.imul(Gt, wr) | 0, Rt = Rt + Math.imul(Gt, Sr) | 0, Rt = Rt + Math.imul(rr, wr) | 0, Lt = Lt + Math.imul(rr, Sr) | 0, qt = qt + Math.imul(sr, Fr) | 0, Rt = Rt + Math.imul(sr, Ir) | 0, Rt = Rt + Math.imul(Zt, Fr) | 0, Lt = Lt + Math.imul(Zt, Ir) | 0;
        var un = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, qt = Math.imul(Ut, jr), Rt = Math.imul(Ut, Br), Rt = Rt + Math.imul(Qt, jr) | 0, Lt = Math.imul(Qt, Br), qt = qt + Math.imul(Qr, Lr) | 0, Rt = Rt + Math.imul(Qr, Nr) | 0, Rt = Rt + Math.imul(Vt, Lr) | 0, Lt = Lt + Math.imul(Vt, Nr) | 0, qt = qt + Math.imul(Xr, Zr) | 0, Rt = Rt + Math.imul(Xr, nr) | 0, Rt = Rt + Math.imul(qr, Zr) | 0, Lt = Lt + Math.imul(qr, nr) | 0, qt = qt + Math.imul(Gr, ir) | 0, Rt = Rt + Math.imul(Gr, ar) | 0, Rt = Rt + Math.imul(Rr, ir) | 0, Lt = Lt + Math.imul(Rr, ar) | 0, qt = qt + Math.imul(Wr, yr) | 0, Rt = Rt + Math.imul(Wr, gr) | 0, Rt = Rt + Math.imul($r, yr) | 0, Lt = Lt + Math.imul($r, gr) | 0, qt = qt + Math.imul(xr, Pr) | 0, Rt = Rt + Math.imul(xr, Ar) | 0, Rt = Rt + Math.imul(Tr, Pr) | 0, Lt = Lt + Math.imul(Tr, Ar) | 0, qt = qt + Math.imul(pr, Cr) | 0, Rt = Rt + Math.imul(pr, er) | 0, Rt = Rt + Math.imul(vr, Cr) | 0, Lt = Lt + Math.imul(vr, er) | 0, qt = qt + Math.imul(Xt, wr) | 0, Rt = Rt + Math.imul(Xt, Sr) | 0, Rt = Rt + Math.imul(zt, wr) | 0, Lt = Lt + Math.imul(zt, Sr) | 0, qt = qt + Math.imul(Gt, Fr) | 0, Rt = Rt + Math.imul(Gt, Ir) | 0, Rt = Rt + Math.imul(rr, Fr) | 0, Lt = Lt + Math.imul(rr, Ir) | 0;
        var cn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, qt = Math.imul(Ut, Lr), Rt = Math.imul(Ut, Nr), Rt = Rt + Math.imul(Qt, Lr) | 0, Lt = Math.imul(Qt, Nr), qt = qt + Math.imul(Qr, Zr) | 0, Rt = Rt + Math.imul(Qr, nr) | 0, Rt = Rt + Math.imul(Vt, Zr) | 0, Lt = Lt + Math.imul(Vt, nr) | 0, qt = qt + Math.imul(Xr, ir) | 0, Rt = Rt + Math.imul(Xr, ar) | 0, Rt = Rt + Math.imul(qr, ir) | 0, Lt = Lt + Math.imul(qr, ar) | 0, qt = qt + Math.imul(Gr, yr) | 0, Rt = Rt + Math.imul(Gr, gr) | 0, Rt = Rt + Math.imul(Rr, yr) | 0, Lt = Lt + Math.imul(Rr, gr) | 0, qt = qt + Math.imul(Wr, Pr) | 0, Rt = Rt + Math.imul(Wr, Ar) | 0, Rt = Rt + Math.imul($r, Pr) | 0, Lt = Lt + Math.imul($r, Ar) | 0, qt = qt + Math.imul(xr, Cr) | 0, Rt = Rt + Math.imul(xr, er) | 0, Rt = Rt + Math.imul(Tr, Cr) | 0, Lt = Lt + Math.imul(Tr, er) | 0, qt = qt + Math.imul(pr, wr) | 0, Rt = Rt + Math.imul(pr, Sr) | 0, Rt = Rt + Math.imul(vr, wr) | 0, Lt = Lt + Math.imul(vr, Sr) | 0, qt = qt + Math.imul(Xt, Fr) | 0, Rt = Rt + Math.imul(Xt, Ir) | 0, Rt = Rt + Math.imul(zt, Fr) | 0, Lt = Lt + Math.imul(zt, Ir) | 0;
        var ln = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, qt = Math.imul(Ut, Zr), Rt = Math.imul(Ut, nr), Rt = Rt + Math.imul(Qt, Zr) | 0, Lt = Math.imul(Qt, nr), qt = qt + Math.imul(Qr, ir) | 0, Rt = Rt + Math.imul(Qr, ar) | 0, Rt = Rt + Math.imul(Vt, ir) | 0, Lt = Lt + Math.imul(Vt, ar) | 0, qt = qt + Math.imul(Xr, yr) | 0, Rt = Rt + Math.imul(Xr, gr) | 0, Rt = Rt + Math.imul(qr, yr) | 0, Lt = Lt + Math.imul(qr, gr) | 0, qt = qt + Math.imul(Gr, Pr) | 0, Rt = Rt + Math.imul(Gr, Ar) | 0, Rt = Rt + Math.imul(Rr, Pr) | 0, Lt = Lt + Math.imul(Rr, Ar) | 0, qt = qt + Math.imul(Wr, Cr) | 0, Rt = Rt + Math.imul(Wr, er) | 0, Rt = Rt + Math.imul($r, Cr) | 0, Lt = Lt + Math.imul($r, er) | 0, qt = qt + Math.imul(xr, wr) | 0, Rt = Rt + Math.imul(xr, Sr) | 0, Rt = Rt + Math.imul(Tr, wr) | 0, Lt = Lt + Math.imul(Tr, Sr) | 0, qt = qt + Math.imul(pr, Fr) | 0, Rt = Rt + Math.imul(pr, Ir) | 0, Rt = Rt + Math.imul(vr, Fr) | 0, Lt = Lt + Math.imul(vr, Ir) | 0;
        var dn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, qt = Math.imul(Ut, ir), Rt = Math.imul(Ut, ar), Rt = Rt + Math.imul(Qt, ir) | 0, Lt = Math.imul(Qt, ar), qt = qt + Math.imul(Qr, yr) | 0, Rt = Rt + Math.imul(Qr, gr) | 0, Rt = Rt + Math.imul(Vt, yr) | 0, Lt = Lt + Math.imul(Vt, gr) | 0, qt = qt + Math.imul(Xr, Pr) | 0, Rt = Rt + Math.imul(Xr, Ar) | 0, Rt = Rt + Math.imul(qr, Pr) | 0, Lt = Lt + Math.imul(qr, Ar) | 0, qt = qt + Math.imul(Gr, Cr) | 0, Rt = Rt + Math.imul(Gr, er) | 0, Rt = Rt + Math.imul(Rr, Cr) | 0, Lt = Lt + Math.imul(Rr, er) | 0, qt = qt + Math.imul(Wr, wr) | 0, Rt = Rt + Math.imul(Wr, Sr) | 0, Rt = Rt + Math.imul($r, wr) | 0, Lt = Lt + Math.imul($r, Sr) | 0, qt = qt + Math.imul(xr, Fr) | 0, Rt = Rt + Math.imul(xr, Ir) | 0, Rt = Rt + Math.imul(Tr, Fr) | 0, Lt = Lt + Math.imul(Tr, Ir) | 0;
        var hn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, qt = Math.imul(Ut, yr), Rt = Math.imul(Ut, gr), Rt = Rt + Math.imul(Qt, yr) | 0, Lt = Math.imul(Qt, gr), qt = qt + Math.imul(Qr, Pr) | 0, Rt = Rt + Math.imul(Qr, Ar) | 0, Rt = Rt + Math.imul(Vt, Pr) | 0, Lt = Lt + Math.imul(Vt, Ar) | 0, qt = qt + Math.imul(Xr, Cr) | 0, Rt = Rt + Math.imul(Xr, er) | 0, Rt = Rt + Math.imul(qr, Cr) | 0, Lt = Lt + Math.imul(qr, er) | 0, qt = qt + Math.imul(Gr, wr) | 0, Rt = Rt + Math.imul(Gr, Sr) | 0, Rt = Rt + Math.imul(Rr, wr) | 0, Lt = Lt + Math.imul(Rr, Sr) | 0, qt = qt + Math.imul(Wr, Fr) | 0, Rt = Rt + Math.imul(Wr, Ir) | 0, Rt = Rt + Math.imul($r, Fr) | 0, Lt = Lt + Math.imul($r, Ir) | 0;
        var pn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, qt = Math.imul(Ut, Pr), Rt = Math.imul(Ut, Ar), Rt = Rt + Math.imul(Qt, Pr) | 0, Lt = Math.imul(Qt, Ar), qt = qt + Math.imul(Qr, Cr) | 0, Rt = Rt + Math.imul(Qr, er) | 0, Rt = Rt + Math.imul(Vt, Cr) | 0, Lt = Lt + Math.imul(Vt, er) | 0, qt = qt + Math.imul(Xr, wr) | 0, Rt = Rt + Math.imul(Xr, Sr) | 0, Rt = Rt + Math.imul(qr, wr) | 0, Lt = Lt + Math.imul(qr, Sr) | 0, qt = qt + Math.imul(Gr, Fr) | 0, Rt = Rt + Math.imul(Gr, Ir) | 0, Rt = Rt + Math.imul(Rr, Fr) | 0, Lt = Lt + Math.imul(Rr, Ir) | 0;
        var yn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, qt = Math.imul(Ut, Cr), Rt = Math.imul(Ut, er), Rt = Rt + Math.imul(Qt, Cr) | 0, Lt = Math.imul(Qt, er), qt = qt + Math.imul(Qr, wr) | 0, Rt = Rt + Math.imul(Qr, Sr) | 0, Rt = Rt + Math.imul(Vt, wr) | 0, Lt = Lt + Math.imul(Vt, Sr) | 0, qt = qt + Math.imul(Xr, Fr) | 0, Rt = Rt + Math.imul(Xr, Ir) | 0, Rt = Rt + Math.imul(qr, Fr) | 0, Lt = Lt + Math.imul(qr, Ir) | 0;
        var vn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, qt = Math.imul(Ut, wr), Rt = Math.imul(Ut, Sr), Rt = Rt + Math.imul(Qt, wr) | 0, Lt = Math.imul(Qt, Sr), qt = qt + Math.imul(Qr, Fr) | 0, Rt = Rt + Math.imul(Qr, Ir) | 0, Rt = Rt + Math.imul(Vt, Fr) | 0, Lt = Lt + Math.imul(Vt, Ir) | 0;
        var mn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        $t = (Lt + (Rt >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, qt = Math.imul(Ut, Fr), Rt = Math.imul(Ut, Ir), Rt = Rt + Math.imul(Qt, Fr) | 0, Lt = Math.imul(Qt, Ir);
        var gn = ($t + qt | 0) + ((Rt & 8191) << 13) | 0;
        return $t = (Lt + (Rt >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, Bt[0] = Vr, Bt[1] = tn, Bt[2] = Jr, Bt[3] = en, Bt[4] = an, Bt[5] = on, Bt[6] = sn, Bt[7] = nn, Bt[8] = fn, Bt[9] = un, Bt[10] = cn, Bt[11] = ln, Bt[12] = dn, Bt[13] = hn, Bt[14] = pn, Bt[15] = yn, Bt[16] = vn, Bt[17] = mn, Bt[18] = gn, $t !== 0 && (Bt[19] = $t, bt.length++), bt;
      };
      Math.imul || (_t = Pt);
      function kt(Xe, Ke, Qe) {
        Qe.negative = Ke.negative ^ Xe.negative, Qe.length = Xe.length + Ke.length;
        for (var bt = 0, wt = 0, xt = 0; xt < Qe.length - 1; xt++) {
          var Bt = wt;
          wt = 0;
          for (var $t = bt & 67108863, qt = Math.min(xt, Ke.length - 1), Rt = Math.max(0, xt - Xe.length + 1); Rt <= qt; Rt++) {
            var Lt = xt - Rt, tr = Xe.words[Lt] | 0, sr = Ke.words[Rt] | 0, Zt = tr * sr, Wt = Zt & 67108863;
            Bt = Bt + (Zt / 67108864 | 0) | 0, Wt = Wt + $t | 0, $t = Wt & 67108863, Bt = Bt + (Wt >>> 26) | 0, wt += Bt >>> 26, Bt &= 67108863;
          }
          Qe.words[xt] = $t, bt = Bt, Bt = wt;
        }
        return bt !== 0 ? Qe.words[xt] = bt : Qe.length--, Qe._strip();
      }
      function Ot(Xe, Ke, Qe) {
        return kt(Xe, Ke, Qe);
      }
      ie.prototype.mulTo = function(Ke, Qe) {
        var bt, wt = this.length + Ke.length;
        return this.length === 10 && Ke.length === 10 ? bt = _t(this, Ke, Qe) : wt < 63 ? bt = Pt(this, Ke, Qe) : wt < 1024 ? bt = kt(this, Ke, Qe) : bt = Ot(this, Ke, Qe), bt;
      }, ie.prototype.mul = function(Ke) {
        var Qe = new ie(null);
        return Qe.words = new Array(this.length + Ke.length), this.mulTo(Ke, Qe);
      }, ie.prototype.mulf = function(Ke) {
        var Qe = new ie(null);
        return Qe.words = new Array(this.length + Ke.length), Ot(this, Ke, Qe);
      }, ie.prototype.imul = function(Ke) {
        return this.clone().mulTo(Ke, this);
      }, ie.prototype.imuln = function(Ke) {
        var Qe = Ke < 0;
        Qe && (Ke = -Ke), ne(typeof Ke == "number"), ne(Ke < 67108864);
        for (var bt = 0, wt = 0; wt < this.length; wt++) {
          var xt = (this.words[wt] | 0) * Ke, Bt = (xt & 67108863) + (bt & 67108863);
          bt >>= 26, bt += xt / 67108864 | 0, bt += Bt >>> 26, this.words[wt] = Bt & 67108863;
        }
        return bt !== 0 && (this.words[wt] = bt, this.length++), Qe ? this.ineg() : this;
      }, ie.prototype.muln = function(Ke) {
        return this.clone().imuln(Ke);
      }, ie.prototype.sqr = function() {
        return this.mul(this);
      }, ie.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ie.prototype.pow = function(Ke) {
        var Qe = vt(Ke);
        if (Qe.length === 0) return new ie(1);
        for (var bt = this, wt = 0; wt < Qe.length && Qe[wt] === 0; wt++, bt = bt.sqr())
          ;
        if (++wt < Qe.length)
          for (var xt = bt.sqr(); wt < Qe.length; wt++, xt = xt.sqr())
            Qe[wt] !== 0 && (bt = bt.mul(xt));
        return bt;
      }, ie.prototype.iushln = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Ke % 26, bt = (Ke - Qe) / 26, wt = 67108863 >>> 26 - Qe << 26 - Qe, xt;
        if (Qe !== 0) {
          var Bt = 0;
          for (xt = 0; xt < this.length; xt++) {
            var $t = this.words[xt] & wt, qt = (this.words[xt] | 0) - $t << Qe;
            this.words[xt] = qt | Bt, Bt = $t >>> 26 - Qe;
          }
          Bt && (this.words[xt] = Bt, this.length++);
        }
        if (bt !== 0) {
          for (xt = this.length - 1; xt >= 0; xt--)
            this.words[xt + bt] = this.words[xt];
          for (xt = 0; xt < bt; xt++)
            this.words[xt] = 0;
          this.length += bt;
        }
        return this._strip();
      }, ie.prototype.ishln = function(Ke) {
        return ne(this.negative === 0), this.iushln(Ke);
      }, ie.prototype.iushrn = function(Ke, Qe, bt) {
        ne(typeof Ke == "number" && Ke >= 0);
        var wt;
        Qe ? wt = (Qe - Qe % 26) / 26 : wt = 0;
        var xt = Ke % 26, Bt = Math.min((Ke - xt) / 26, this.length), $t = 67108863 ^ 67108863 >>> xt << xt, qt = bt;
        if (wt -= Bt, wt = Math.max(0, wt), qt) {
          for (var Rt = 0; Rt < Bt; Rt++)
            qt.words[Rt] = this.words[Rt];
          qt.length = Bt;
        }
        if (Bt !== 0) if (this.length > Bt)
          for (this.length -= Bt, Rt = 0; Rt < this.length; Rt++)
            this.words[Rt] = this.words[Rt + Bt];
        else
          this.words[0] = 0, this.length = 1;
        var Lt = 0;
        for (Rt = this.length - 1; Rt >= 0 && (Lt !== 0 || Rt >= wt); Rt--) {
          var tr = this.words[Rt] | 0;
          this.words[Rt] = Lt << 26 - xt | tr >>> xt, Lt = tr & $t;
        }
        return qt && Lt !== 0 && (qt.words[qt.length++] = Lt), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, ie.prototype.ishrn = function(Ke, Qe, bt) {
        return ne(this.negative === 0), this.iushrn(Ke, Qe, bt);
      }, ie.prototype.shln = function(Ke) {
        return this.clone().ishln(Ke);
      }, ie.prototype.ushln = function(Ke) {
        return this.clone().iushln(Ke);
      }, ie.prototype.shrn = function(Ke) {
        return this.clone().ishrn(Ke);
      }, ie.prototype.ushrn = function(Ke) {
        return this.clone().iushrn(Ke);
      }, ie.prototype.testn = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Ke % 26, bt = (Ke - Qe) / 26, wt = 1 << Qe;
        if (this.length <= bt) return !1;
        var xt = this.words[bt];
        return !!(xt & wt);
      }, ie.prototype.imaskn = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Ke % 26, bt = (Ke - Qe) / 26;
        if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= bt)
          return this;
        if (Qe !== 0 && bt++, this.length = Math.min(bt, this.length), Qe !== 0) {
          var wt = 67108863 ^ 67108863 >>> Qe << Qe;
          this.words[this.length - 1] &= wt;
        }
        return this._strip();
      }, ie.prototype.maskn = function(Ke) {
        return this.clone().imaskn(Ke);
      }, ie.prototype.iaddn = function(Ke) {
        return ne(typeof Ke == "number"), ne(Ke < 67108864), Ke < 0 ? this.isubn(-Ke) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= Ke ? (this.words[0] = Ke - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Ke), this.negative = 1, this) : this._iaddn(Ke);
      }, ie.prototype._iaddn = function(Ke) {
        this.words[0] += Ke;
        for (var Qe = 0; Qe < this.length && this.words[Qe] >= 67108864; Qe++)
          this.words[Qe] -= 67108864, Qe === this.length - 1 ? this.words[Qe + 1] = 1 : this.words[Qe + 1]++;
        return this.length = Math.max(this.length, Qe + 1), this;
      }, ie.prototype.isubn = function(Ke) {
        if (ne(typeof Ke == "number"), ne(Ke < 67108864), Ke < 0) return this.iaddn(-Ke);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Ke), this.negative = 1, this;
        if (this.words[0] -= Ke, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Qe = 0; Qe < this.length && this.words[Qe] < 0; Qe++)
            this.words[Qe] += 67108864, this.words[Qe + 1] -= 1;
        return this._strip();
      }, ie.prototype.addn = function(Ke) {
        return this.clone().iaddn(Ke);
      }, ie.prototype.subn = function(Ke) {
        return this.clone().isubn(Ke);
      }, ie.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ie.prototype.abs = function() {
        return this.clone().iabs();
      }, ie.prototype._ishlnsubmul = function(Ke, Qe, bt) {
        var wt = Ke.length + bt, xt;
        this._expand(wt);
        var Bt, $t = 0;
        for (xt = 0; xt < Ke.length; xt++) {
          Bt = (this.words[xt + bt] | 0) + $t;
          var qt = (Ke.words[xt] | 0) * Qe;
          Bt -= qt & 67108863, $t = (Bt >> 26) - (qt / 67108864 | 0), this.words[xt + bt] = Bt & 67108863;
        }
        for (; xt < this.length - bt; xt++)
          Bt = (this.words[xt + bt] | 0) + $t, $t = Bt >> 26, this.words[xt + bt] = Bt & 67108863;
        if ($t === 0) return this._strip();
        for (ne($t === -1), $t = 0, xt = 0; xt < this.length; xt++)
          Bt = -(this.words[xt] | 0) + $t, $t = Bt >> 26, this.words[xt] = Bt & 67108863;
        return this.negative = 1, this._strip();
      }, ie.prototype._wordDiv = function(Ke, Qe) {
        var bt = this.length - Ke.length, wt = this.clone(), xt = Ke, Bt = xt.words[xt.length - 1] | 0, $t = this._countBits(Bt);
        bt = 26 - $t, bt !== 0 && (xt = xt.ushln(bt), wt.iushln(bt), Bt = xt.words[xt.length - 1] | 0);
        var qt = wt.length - xt.length, Rt;
        if (Qe !== "mod") {
          Rt = new ie(null), Rt.length = qt + 1, Rt.words = new Array(Rt.length);
          for (var Lt = 0; Lt < Rt.length; Lt++)
            Rt.words[Lt] = 0;
        }
        var tr = wt.clone()._ishlnsubmul(xt, 1, qt);
        tr.negative === 0 && (wt = tr, Rt && (Rt.words[qt] = 1));
        for (var sr = qt - 1; sr >= 0; sr--) {
          var Zt = (wt.words[xt.length + sr] | 0) * 67108864 + (wt.words[xt.length + sr - 1] | 0);
          for (Zt = Math.min(Zt / Bt | 0, 67108863), wt._ishlnsubmul(xt, Zt, sr); wt.negative !== 0; )
            Zt--, wt.negative = 0, wt._ishlnsubmul(xt, 1, sr), wt.isZero() || (wt.negative ^= 1);
          Rt && (Rt.words[sr] = Zt);
        }
        return Rt && Rt._strip(), wt._strip(), Qe !== "div" && bt !== 0 && wt.iushrn(bt), {
          div: Rt || null,
          mod: wt
        };
      }, ie.prototype.divmod = function(Ke, Qe, bt) {
        if (ne(!Ke.isZero()), this.isZero())
          return {
            div: new ie(0),
            mod: new ie(0)
          };
        var wt, xt, Bt;
        return this.negative !== 0 && Ke.negative === 0 ? (Bt = this.neg().divmod(Ke, Qe), Qe !== "mod" && (wt = Bt.div.neg()), Qe !== "div" && (xt = Bt.mod.neg(), bt && xt.negative !== 0 && xt.iadd(Ke)), {
          div: wt,
          mod: xt
        }) : this.negative === 0 && Ke.negative !== 0 ? (Bt = this.divmod(Ke.neg(), Qe), Qe !== "mod" && (wt = Bt.div.neg()), {
          div: wt,
          mod: Bt.mod
        }) : this.negative & Ke.negative ? (Bt = this.neg().divmod(Ke.neg(), Qe), Qe !== "div" && (xt = Bt.mod.neg(), bt && xt.negative !== 0 && xt.isub(Ke)), {
          div: Bt.div,
          mod: xt
        }) : Ke.length > this.length || this.cmp(Ke) < 0 ? {
          div: new ie(0),
          mod: this
        } : Ke.length === 1 ? Qe === "div" ? {
          div: this.divn(Ke.words[0]),
          mod: null
        } : Qe === "mod" ? {
          div: null,
          mod: new ie(this.modrn(Ke.words[0]))
        } : {
          div: this.divn(Ke.words[0]),
          mod: new ie(this.modrn(Ke.words[0]))
        } : this._wordDiv(Ke, Qe);
      }, ie.prototype.div = function(Ke) {
        return this.divmod(Ke, "div", !1).div;
      }, ie.prototype.mod = function(Ke) {
        return this.divmod(Ke, "mod", !1).mod;
      }, ie.prototype.umod = function(Ke) {
        return this.divmod(Ke, "mod", !0).mod;
      }, ie.prototype.divRound = function(Ke) {
        var Qe = this.divmod(Ke);
        if (Qe.mod.isZero()) return Qe.div;
        var bt = Qe.div.negative !== 0 ? Qe.mod.isub(Ke) : Qe.mod, wt = Ke.ushrn(1), xt = Ke.andln(1), Bt = bt.cmp(wt);
        return Bt < 0 || xt === 1 && Bt === 0 ? Qe.div : Qe.div.negative !== 0 ? Qe.div.isubn(1) : Qe.div.iaddn(1);
      }, ie.prototype.modrn = function(Ke) {
        var Qe = Ke < 0;
        Qe && (Ke = -Ke), ne(Ke <= 67108863);
        for (var bt = (1 << 26) % Ke, wt = 0, xt = this.length - 1; xt >= 0; xt--)
          wt = (bt * wt + (this.words[xt] | 0)) % Ke;
        return Qe ? -wt : wt;
      }, ie.prototype.modn = function(Ke) {
        return this.modrn(Ke);
      }, ie.prototype.idivn = function(Ke) {
        var Qe = Ke < 0;
        Qe && (Ke = -Ke), ne(Ke <= 67108863);
        for (var bt = 0, wt = this.length - 1; wt >= 0; wt--) {
          var xt = (this.words[wt] | 0) + bt * 67108864;
          this.words[wt] = xt / Ke | 0, bt = xt % Ke;
        }
        return this._strip(), Qe ? this.ineg() : this;
      }, ie.prototype.divn = function(Ke) {
        return this.clone().idivn(Ke);
      }, ie.prototype.egcd = function(Ke) {
        ne(Ke.negative === 0), ne(!Ke.isZero());
        var Qe = this, bt = Ke.clone();
        Qe.negative !== 0 ? Qe = Qe.umod(Ke) : Qe = Qe.clone();
        for (var wt = new ie(1), xt = new ie(0), Bt = new ie(0), $t = new ie(1), qt = 0; Qe.isEven() && bt.isEven(); )
          Qe.iushrn(1), bt.iushrn(1), ++qt;
        for (var Rt = bt.clone(), Lt = Qe.clone(); !Qe.isZero(); ) {
          for (var tr = 0, sr = 1; !(Qe.words[0] & sr) && tr < 26; ++tr, sr <<= 1) ;
          if (tr > 0)
            for (Qe.iushrn(tr); tr-- > 0; )
              (wt.isOdd() || xt.isOdd()) && (wt.iadd(Rt), xt.isub(Lt)), wt.iushrn(1), xt.iushrn(1);
          for (var Zt = 0, Wt = 1; !(bt.words[0] & Wt) && Zt < 26; ++Zt, Wt <<= 1) ;
          if (Zt > 0)
            for (bt.iushrn(Zt); Zt-- > 0; )
              (Bt.isOdd() || $t.isOdd()) && (Bt.iadd(Rt), $t.isub(Lt)), Bt.iushrn(1), $t.iushrn(1);
          Qe.cmp(bt) >= 0 ? (Qe.isub(bt), wt.isub(Bt), xt.isub($t)) : (bt.isub(Qe), Bt.isub(wt), $t.isub(xt));
        }
        return {
          a: Bt,
          b: $t,
          gcd: bt.iushln(qt)
        };
      }, ie.prototype._invmp = function(Ke) {
        ne(Ke.negative === 0), ne(!Ke.isZero());
        var Qe = this, bt = Ke.clone();
        Qe.negative !== 0 ? Qe = Qe.umod(Ke) : Qe = Qe.clone();
        for (var wt = new ie(1), xt = new ie(0), Bt = bt.clone(); Qe.cmpn(1) > 0 && bt.cmpn(1) > 0; ) {
          for (var $t = 0, qt = 1; !(Qe.words[0] & qt) && $t < 26; ++$t, qt <<= 1) ;
          if ($t > 0)
            for (Qe.iushrn($t); $t-- > 0; )
              wt.isOdd() && wt.iadd(Bt), wt.iushrn(1);
          for (var Rt = 0, Lt = 1; !(bt.words[0] & Lt) && Rt < 26; ++Rt, Lt <<= 1) ;
          if (Rt > 0)
            for (bt.iushrn(Rt); Rt-- > 0; )
              xt.isOdd() && xt.iadd(Bt), xt.iushrn(1);
          Qe.cmp(bt) >= 0 ? (Qe.isub(bt), wt.isub(xt)) : (bt.isub(Qe), xt.isub(wt));
        }
        var tr;
        return Qe.cmpn(1) === 0 ? tr = wt : tr = xt, tr.cmpn(0) < 0 && tr.iadd(Ke), tr;
      }, ie.prototype.gcd = function(Ke) {
        if (this.isZero()) return Ke.abs();
        if (Ke.isZero()) return this.abs();
        var Qe = this.clone(), bt = Ke.clone();
        Qe.negative = 0, bt.negative = 0;
        for (var wt = 0; Qe.isEven() && bt.isEven(); wt++)
          Qe.iushrn(1), bt.iushrn(1);
        do {
          for (; Qe.isEven(); )
            Qe.iushrn(1);
          for (; bt.isEven(); )
            bt.iushrn(1);
          var xt = Qe.cmp(bt);
          if (xt < 0) {
            var Bt = Qe;
            Qe = bt, bt = Bt;
          } else if (xt === 0 || bt.cmpn(1) === 0)
            break;
          Qe.isub(bt);
        } while (!0);
        return bt.iushln(wt);
      }, ie.prototype.invm = function(Ke) {
        return this.egcd(Ke).a.umod(Ke);
      }, ie.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ie.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ie.prototype.andln = function(Ke) {
        return this.words[0] & Ke;
      }, ie.prototype.bincn = function(Ke) {
        ne(typeof Ke == "number");
        var Qe = Ke % 26, bt = (Ke - Qe) / 26, wt = 1 << Qe;
        if (this.length <= bt)
          return this._expand(bt + 1), this.words[bt] |= wt, this;
        for (var xt = wt, Bt = bt; xt !== 0 && Bt < this.length; Bt++) {
          var $t = this.words[Bt] | 0;
          $t += xt, xt = $t >>> 26, $t &= 67108863, this.words[Bt] = $t;
        }
        return xt !== 0 && (this.words[Bt] = xt, this.length++), this;
      }, ie.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ie.prototype.cmpn = function(Ke) {
        var Qe = Ke < 0;
        if (this.negative !== 0 && !Qe) return -1;
        if (this.negative === 0 && Qe) return 1;
        this._strip();
        var bt;
        if (this.length > 1)
          bt = 1;
        else {
          Qe && (Ke = -Ke), ne(Ke <= 67108863, "Number is too big");
          var wt = this.words[0] | 0;
          bt = wt === Ke ? 0 : wt < Ke ? -1 : 1;
        }
        return this.negative !== 0 ? -bt | 0 : bt;
      }, ie.prototype.cmp = function(Ke) {
        if (this.negative !== 0 && Ke.negative === 0) return -1;
        if (this.negative === 0 && Ke.negative !== 0) return 1;
        var Qe = this.ucmp(Ke);
        return this.negative !== 0 ? -Qe | 0 : Qe;
      }, ie.prototype.ucmp = function(Ke) {
        if (this.length > Ke.length) return 1;
        if (this.length < Ke.length) return -1;
        for (var Qe = 0, bt = this.length - 1; bt >= 0; bt--) {
          var wt = this.words[bt] | 0, xt = Ke.words[bt] | 0;
          if (wt !== xt) {
            wt < xt ? Qe = -1 : wt > xt && (Qe = 1);
            break;
          }
        }
        return Qe;
      }, ie.prototype.gtn = function(Ke) {
        return this.cmpn(Ke) === 1;
      }, ie.prototype.gt = function(Ke) {
        return this.cmp(Ke) === 1;
      }, ie.prototype.gten = function(Ke) {
        return this.cmpn(Ke) >= 0;
      }, ie.prototype.gte = function(Ke) {
        return this.cmp(Ke) >= 0;
      }, ie.prototype.ltn = function(Ke) {
        return this.cmpn(Ke) === -1;
      }, ie.prototype.lt = function(Ke) {
        return this.cmp(Ke) === -1;
      }, ie.prototype.lten = function(Ke) {
        return this.cmpn(Ke) <= 0;
      }, ie.prototype.lte = function(Ke) {
        return this.cmp(Ke) <= 0;
      }, ie.prototype.eqn = function(Ke) {
        return this.cmpn(Ke) === 0;
      }, ie.prototype.eq = function(Ke) {
        return this.cmp(Ke) === 0;
      }, ie.red = function(Ke) {
        return new Nt(Ke);
      }, ie.prototype.toRed = function(Ke) {
        return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), Ke.convertTo(this)._forceRed(Ke);
      }, ie.prototype.fromRed = function() {
        return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ie.prototype._forceRed = function(Ke) {
        return this.red = Ke, this;
      }, ie.prototype.forceRed = function(Ke) {
        return ne(!this.red, "Already a number in reduction context"), this._forceRed(Ke);
      }, ie.prototype.redAdd = function(Ke) {
        return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, Ke);
      }, ie.prototype.redIAdd = function(Ke) {
        return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Ke);
      }, ie.prototype.redSub = function(Ke) {
        return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, Ke);
      }, ie.prototype.redISub = function(Ke) {
        return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, Ke);
      }, ie.prototype.redShl = function(Ke) {
        return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, Ke);
      }, ie.prototype.redMul = function(Ke) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ke), this.red.mul(this, Ke);
      }, ie.prototype.redIMul = function(Ke) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ke), this.red.imul(this, Ke);
      }, ie.prototype.redSqr = function() {
        return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ie.prototype.redISqr = function() {
        return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ie.prototype.redSqrt = function() {
        return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ie.prototype.redInvm = function() {
        return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ie.prototype.redNeg = function() {
        return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ie.prototype.redPow = function(Ke) {
        return ne(this.red && !Ke.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Ke);
      };
      var Ht = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function jt(Xe, Ke) {
        this.name = Xe, this.p = new ie(Ke, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      jt.prototype._tmp = function() {
        var Ke = new ie(null);
        return Ke.words = new Array(Math.ceil(this.n / 13)), Ke;
      }, jt.prototype.ireduce = function(Ke) {
        var Qe = Ke, bt;
        do
          this.split(Qe, this.tmp), Qe = this.imulK(Qe), Qe = Qe.iadd(this.tmp), bt = Qe.bitLength();
        while (bt > this.n);
        var wt = bt < this.n ? -1 : Qe.ucmp(this.p);
        return wt === 0 ? (Qe.words[0] = 0, Qe.length = 1) : wt > 0 ? Qe.isub(this.p) : Qe.strip !== void 0 ? Qe.strip() : Qe._strip(), Qe;
      }, jt.prototype.split = function(Ke, Qe) {
        Ke.iushrn(this.n, 0, Qe);
      }, jt.prototype.imulK = function(Ke) {
        return Ke.imul(this.k);
      };
      function Yt() {
        jt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      ae(Yt, jt), Yt.prototype.split = function(Ke, Qe) {
        for (var bt = 4194303, wt = Math.min(Ke.length, 9), xt = 0; xt < wt; xt++)
          Qe.words[xt] = Ke.words[xt];
        if (Qe.length = wt, Ke.length <= 9) {
          Ke.words[0] = 0, Ke.length = 1;
          return;
        }
        var Bt = Ke.words[9];
        for (Qe.words[Qe.length++] = Bt & bt, xt = 10; xt < Ke.length; xt++) {
          var $t = Ke.words[xt] | 0;
          Ke.words[xt - 10] = ($t & bt) << 4 | Bt >>> 22, Bt = $t;
        }
        Bt >>>= 22, Ke.words[xt - 10] = Bt, Bt === 0 && Ke.length > 10 ? Ke.length -= 10 : Ke.length -= 9;
      }, Yt.prototype.imulK = function(Ke) {
        Ke.words[Ke.length] = 0, Ke.words[Ke.length + 1] = 0, Ke.length += 2;
        for (var Qe = 0, bt = 0; bt < Ke.length; bt++) {
          var wt = Ke.words[bt] | 0;
          Qe += wt * 977, Ke.words[bt] = Qe & 67108863, Qe = wt * 64 + (Qe / 67108864 | 0);
        }
        return Ke.words[Ke.length - 1] === 0 && (Ke.length--, Ke.words[Ke.length - 1] === 0 && Ke.length--), Ke;
      };
      function Dt() {
        jt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      ae(Dt, jt);
      function Ct() {
        jt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      ae(Ct, jt);
      function Kt() {
        jt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      ae(Kt, jt), Kt.prototype.imulK = function(Ke) {
        for (var Qe = 0, bt = 0; bt < Ke.length; bt++) {
          var wt = (Ke.words[bt] | 0) * 19 + Qe, xt = wt & 67108863;
          wt >>>= 26, Ke.words[bt] = xt, Qe = wt;
        }
        return Qe !== 0 && (Ke.words[Ke.length++] = Qe), Ke;
      }, ie._prime = function(Ke) {
        if (Ht[Ke]) return Ht[Ke];
        var Qe;
        if (Ke === "k256")
          Qe = new Yt();
        else if (Ke === "p224")
          Qe = new Dt();
        else if (Ke === "p192")
          Qe = new Ct();
        else if (Ke === "p25519")
          Qe = new Kt();
        else
          throw new Error("Unknown prime " + Ke);
        return Ht[Ke] = Qe, Qe;
      };
      function Nt(Xe) {
        if (typeof Xe == "string") {
          var Ke = ie._prime(Xe);
          this.m = Ke.p, this.prime = Ke;
        } else
          ne(Xe.gtn(1), "modulus must be greater than 1"), this.m = Xe, this.prime = null;
      }
      Nt.prototype._verify1 = function(Ke) {
        ne(Ke.negative === 0, "red works only with positives"), ne(Ke.red, "red works only with red numbers");
      }, Nt.prototype._verify2 = function(Ke, Qe) {
        ne((Ke.negative | Qe.negative) === 0, "red works only with positives"), ne(
          Ke.red && Ke.red === Qe.red,
          "red works only with red numbers"
        );
      }, Nt.prototype.imod = function(Ke) {
        return this.prime ? this.prime.ireduce(Ke)._forceRed(this) : (oe(Ke, Ke.umod(this.m)._forceRed(this)), Ke);
      }, Nt.prototype.neg = function(Ke) {
        return Ke.isZero() ? Ke.clone() : this.m.sub(Ke)._forceRed(this);
      }, Nt.prototype.add = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.add(Qe);
        return bt.cmp(this.m) >= 0 && bt.isub(this.m), bt._forceRed(this);
      }, Nt.prototype.iadd = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.iadd(Qe);
        return bt.cmp(this.m) >= 0 && bt.isub(this.m), bt;
      }, Nt.prototype.sub = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.sub(Qe);
        return bt.cmpn(0) < 0 && bt.iadd(this.m), bt._forceRed(this);
      }, Nt.prototype.isub = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.isub(Qe);
        return bt.cmpn(0) < 0 && bt.iadd(this.m), bt;
      }, Nt.prototype.shl = function(Ke, Qe) {
        return this._verify1(Ke), this.imod(Ke.ushln(Qe));
      }, Nt.prototype.imul = function(Ke, Qe) {
        return this._verify2(Ke, Qe), this.imod(Ke.imul(Qe));
      }, Nt.prototype.mul = function(Ke, Qe) {
        return this._verify2(Ke, Qe), this.imod(Ke.mul(Qe));
      }, Nt.prototype.isqr = function(Ke) {
        return this.imul(Ke, Ke.clone());
      }, Nt.prototype.sqr = function(Ke) {
        return this.mul(Ke, Ke);
      }, Nt.prototype.sqrt = function(Ke) {
        if (Ke.isZero()) return Ke.clone();
        var Qe = this.m.andln(3);
        if (ne(Qe % 2 === 1), Qe === 3) {
          var bt = this.m.add(new ie(1)).iushrn(2);
          return this.pow(Ke, bt);
        }
        for (var wt = this.m.subn(1), xt = 0; !wt.isZero() && wt.andln(1) === 0; )
          xt++, wt.iushrn(1);
        ne(!wt.isZero());
        var Bt = new ie(1).toRed(this), $t = Bt.redNeg(), qt = this.m.subn(1).iushrn(1), Rt = this.m.bitLength();
        for (Rt = new ie(2 * Rt * Rt).toRed(this); this.pow(Rt, qt).cmp($t) !== 0; )
          Rt.redIAdd($t);
        for (var Lt = this.pow(Rt, wt), tr = this.pow(Ke, wt.addn(1).iushrn(1)), sr = this.pow(Ke, wt), Zt = xt; sr.cmp(Bt) !== 0; ) {
          for (var Wt = sr, Gt = 0; Wt.cmp(Bt) !== 0; Gt++)
            Wt = Wt.redSqr();
          ne(Gt < Zt);
          var rr = this.pow(Lt, new ie(1).iushln(Zt - Gt - 1));
          tr = tr.redMul(rr), Lt = rr.redSqr(), sr = sr.redMul(Lt), Zt = Gt;
        }
        return tr;
      }, Nt.prototype.invm = function(Ke) {
        var Qe = Ke._invmp(this.m);
        return Qe.negative !== 0 ? (Qe.negative = 0, this.imod(Qe).redNeg()) : this.imod(Qe);
      }, Nt.prototype.pow = function(Ke, Qe) {
        if (Qe.isZero()) return new ie(1).toRed(this);
        if (Qe.cmpn(1) === 0) return Ke.clone();
        var bt = 4, wt = new Array(1 << bt);
        wt[0] = new ie(1).toRed(this), wt[1] = Ke;
        for (var xt = 2; xt < wt.length; xt++)
          wt[xt] = this.mul(wt[xt - 1], Ke);
        var Bt = wt[0], $t = 0, qt = 0, Rt = Qe.bitLength() % 26;
        for (Rt === 0 && (Rt = 26), xt = Qe.length - 1; xt >= 0; xt--) {
          for (var Lt = Qe.words[xt], tr = Rt - 1; tr >= 0; tr--) {
            var sr = Lt >> tr & 1;
            if (Bt !== wt[0] && (Bt = this.sqr(Bt)), sr === 0 && $t === 0) {
              qt = 0;
              continue;
            }
            $t <<= 1, $t |= sr, qt++, !(qt !== bt && (xt !== 0 || tr !== 0)) && (Bt = this.mul(Bt, wt[$t]), qt = 0, $t = 0);
          }
          Rt = 26;
        }
        return Bt;
      }, Nt.prototype.convertTo = function(Ke) {
        var Qe = Ke.umod(this.m);
        return Qe === Ke ? Qe.clone() : Qe;
      }, Nt.prototype.convertFrom = function(Ke) {
        var Qe = Ke.clone();
        return Qe.red = null, Qe;
      }, ie.mont = function(Ke) {
        return new Je(Ke);
      };
      function Je(Xe) {
        Nt.call(this, Xe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      ae(Je, Nt), Je.prototype.convertTo = function(Ke) {
        return this.imod(Ke.ushln(this.shift));
      }, Je.prototype.convertFrom = function(Ke) {
        var Qe = this.imod(Ke.mul(this.rinv));
        return Qe.red = null, Qe;
      }, Je.prototype.imul = function(Ke, Qe) {
        if (Ke.isZero() || Qe.isZero())
          return Ke.words[0] = 0, Ke.length = 1, Ke;
        var bt = Ke.imul(Qe), wt = bt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xt = bt.isub(wt).iushrn(this.shift), Bt = xt;
        return xt.cmp(this.m) >= 0 ? Bt = xt.isub(this.m) : xt.cmpn(0) < 0 && (Bt = xt.iadd(this.m)), Bt._forceRed(this);
      }, Je.prototype.mul = function(Ke, Qe) {
        if (Ke.isZero() || Qe.isZero()) return new ie(0)._forceRed(this);
        var bt = Ke.mul(Qe), wt = bt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), xt = bt.isub(wt).iushrn(this.shift), Bt = xt;
        return xt.cmp(this.m) >= 0 ? Bt = xt.isub(this.m) : xt.cmpn(0) < 0 && (Bt = xt.iadd(this.m)), Bt._forceRed(this);
      }, Je.prototype.invm = function(Ke) {
        var Qe = this.imod(Ke._invmp(this.m).mul(this.r2));
        return Qe._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var B = requireBn(), z = requireBrowser$b(), Y = safeBufferExports.Buffer;
  function ne(se) {
    var le = se.modulus.byteLength(), ve;
    do
      ve = new B(z(le));
    while (ve.cmp(se.modulus) >= 0 || !ve.umod(se.prime1) || !ve.umod(se.prime2));
    return ve;
  }
  function ae(se) {
    var le = ne(se), ve = le.toRed(B.mont(se.modulus)).redPow(new B(se.publicExponent)).fromRed();
    return { blinder: ve, unblinder: le.invm(se.modulus) };
  }
  function ie(se, le) {
    var ve = ae(le), ge = le.modulus.byteLength(), oe = new B(se).mul(ve.blinder).umod(le.modulus), Ee = oe.toRed(B.mont(le.prime1)), Ce = oe.toRed(B.mont(le.prime2)), Pe = le.coefficient, Ve = le.prime1, ht = le.prime2, vt = Ee.redPow(le.exponent1).fromRed(), Pt = Ce.redPow(le.exponent2).fromRed(), _t = vt.isub(Pt).imul(Pe).umod(Ve).imul(ht);
    return Pt.iadd(_t).imul(ve.unblinder).umod(le.modulus).toArrayLike(Y, "be", ge);
  }
  return ie.getr = ne, browserifyRsa = ie, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(B) {
    var z = B;
    function Y(ie, se) {
      if (Array.isArray(ie))
        return ie.slice();
      if (!ie)
        return [];
      var le = [];
      if (typeof ie != "string") {
        for (var ve = 0; ve < ie.length; ve++)
          le[ve] = ie[ve] | 0;
        return le;
      }
      if (se === "hex") {
        ie = ie.replace(/[^a-z0-9]+/ig, ""), ie.length % 2 !== 0 && (ie = "0" + ie);
        for (var ve = 0; ve < ie.length; ve += 2)
          le.push(parseInt(ie[ve] + ie[ve + 1], 16));
      } else
        for (var ve = 0; ve < ie.length; ve++) {
          var ge = ie.charCodeAt(ve), oe = ge >> 8, Ee = ge & 255;
          oe ? le.push(oe, Ee) : le.push(Ee);
        }
      return le;
    }
    z.toArray = Y;
    function ne(ie) {
      return ie.length === 1 ? "0" + ie : ie;
    }
    z.zero2 = ne;
    function ae(ie) {
      for (var se = "", le = 0; le < ie.length; le++)
        se += ne(ie[le].toString(16));
      return se;
    }
    z.toHex = ae, z.encode = function(se, le) {
      return le === "hex" ? ae(se) : se;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(B) {
    var z = B, Y = requireBn$1(), ne = requireMinimalisticAssert(), ae = requireUtils$2();
    z.assert = ne, z.toArray = ae.toArray, z.zero2 = ae.zero2, z.toHex = ae.toHex, z.encode = ae.encode;
    function ie(oe, Ee, Ce) {
      var Pe = new Array(Math.max(oe.bitLength(), Ce) + 1), Ve;
      for (Ve = 0; Ve < Pe.length; Ve += 1)
        Pe[Ve] = 0;
      var ht = 1 << Ee + 1, vt = oe.clone();
      for (Ve = 0; Ve < Pe.length; Ve++) {
        var Pt, _t = vt.andln(ht - 1);
        vt.isOdd() ? (_t > (ht >> 1) - 1 ? Pt = (ht >> 1) - _t : Pt = _t, vt.isubn(Pt)) : Pt = 0, Pe[Ve] = Pt, vt.iushrn(1);
      }
      return Pe;
    }
    z.getNAF = ie;
    function se(oe, Ee) {
      var Ce = [
        [],
        []
      ];
      oe = oe.clone(), Ee = Ee.clone();
      for (var Pe = 0, Ve = 0, ht; oe.cmpn(-Pe) > 0 || Ee.cmpn(-Ve) > 0; ) {
        var vt = oe.andln(3) + Pe & 3, Pt = Ee.andln(3) + Ve & 3;
        vt === 3 && (vt = -1), Pt === 3 && (Pt = -1);
        var _t;
        vt & 1 ? (ht = oe.andln(7) + Pe & 7, (ht === 3 || ht === 5) && Pt === 2 ? _t = -vt : _t = vt) : _t = 0, Ce[0].push(_t);
        var kt;
        Pt & 1 ? (ht = Ee.andln(7) + Ve & 7, (ht === 3 || ht === 5) && vt === 2 ? kt = -Pt : kt = Pt) : kt = 0, Ce[1].push(kt), 2 * Pe === _t + 1 && (Pe = 1 - Pe), 2 * Ve === kt + 1 && (Ve = 1 - Ve), oe.iushrn(1), Ee.iushrn(1);
      }
      return Ce;
    }
    z.getJSF = se;
    function le(oe, Ee, Ce) {
      var Pe = "_" + Ee;
      oe.prototype[Ee] = function() {
        return this[Pe] !== void 0 ? this[Pe] : this[Pe] = Ce.call(this);
      };
    }
    z.cachedProperty = le;
    function ve(oe) {
      return typeof oe == "string" ? z.toArray(oe, "hex") : oe;
    }
    z.parseBytes = ve;
    function ge(oe) {
      return new Y(oe, "hex", "le");
    }
    z.intFromLE = ge;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.getNAF, ne = z.getJSF, ae = z.assert;
  function ie(le, ve) {
    this.type = le, this.p = new B(ve.p, 16), this.red = ve.prime ? B.red(ve.prime) : B.mont(this.p), this.zero = new B(0).toRed(this.red), this.one = new B(1).toRed(this.red), this.two = new B(2).toRed(this.red), this.n = ve.n && new B(ve.n, 16), this.g = ve.g && this.pointFromJSON(ve.g, ve.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var ge = this.n && this.p.div(this.n);
    !ge || ge.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = ie, ie.prototype.point = function() {
    throw new Error("Not implemented");
  }, ie.prototype.validate = function() {
    throw new Error("Not implemented");
  }, ie.prototype._fixedNafMul = function(ve, ge) {
    ae(ve.precomputed);
    var oe = ve._getDoubles(), Ee = Y(ge, 1, this._bitLength), Ce = (1 << oe.step + 1) - (oe.step % 2 === 0 ? 2 : 1);
    Ce /= 3;
    var Pe = [], Ve, ht;
    for (Ve = 0; Ve < Ee.length; Ve += oe.step) {
      ht = 0;
      for (var vt = Ve + oe.step - 1; vt >= Ve; vt--)
        ht = (ht << 1) + Ee[vt];
      Pe.push(ht);
    }
    for (var Pt = this.jpoint(null, null, null), _t = this.jpoint(null, null, null), kt = Ce; kt > 0; kt--) {
      for (Ve = 0; Ve < Pe.length; Ve++)
        ht = Pe[Ve], ht === kt ? _t = _t.mixedAdd(oe.points[Ve]) : ht === -kt && (_t = _t.mixedAdd(oe.points[Ve].neg()));
      Pt = Pt.add(_t);
    }
    return Pt.toP();
  }, ie.prototype._wnafMul = function(ve, ge) {
    var oe = 4, Ee = ve._getNAFPoints(oe);
    oe = Ee.wnd;
    for (var Ce = Ee.points, Pe = Y(ge, oe, this._bitLength), Ve = this.jpoint(null, null, null), ht = Pe.length - 1; ht >= 0; ht--) {
      for (var vt = 0; ht >= 0 && Pe[ht] === 0; ht--)
        vt++;
      if (ht >= 0 && vt++, Ve = Ve.dblp(vt), ht < 0)
        break;
      var Pt = Pe[ht];
      ae(Pt !== 0), ve.type === "affine" ? Pt > 0 ? Ve = Ve.mixedAdd(Ce[Pt - 1 >> 1]) : Ve = Ve.mixedAdd(Ce[-Pt - 1 >> 1].neg()) : Pt > 0 ? Ve = Ve.add(Ce[Pt - 1 >> 1]) : Ve = Ve.add(Ce[-Pt - 1 >> 1].neg());
    }
    return ve.type === "affine" ? Ve.toP() : Ve;
  }, ie.prototype._wnafMulAdd = function(ve, ge, oe, Ee, Ce) {
    var Pe = this._wnafT1, Ve = this._wnafT2, ht = this._wnafT3, vt = 0, Pt, _t, kt;
    for (Pt = 0; Pt < Ee; Pt++) {
      kt = ge[Pt];
      var Ot = kt._getNAFPoints(ve);
      Pe[Pt] = Ot.wnd, Ve[Pt] = Ot.points;
    }
    for (Pt = Ee - 1; Pt >= 1; Pt -= 2) {
      var Ht = Pt - 1, jt = Pt;
      if (Pe[Ht] !== 1 || Pe[jt] !== 1) {
        ht[Ht] = Y(oe[Ht], Pe[Ht], this._bitLength), ht[jt] = Y(oe[jt], Pe[jt], this._bitLength), vt = Math.max(ht[Ht].length, vt), vt = Math.max(ht[jt].length, vt);
        continue;
      }
      var Yt = [
        ge[Ht],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        ge[jt]
        /* 7 */
      ];
      ge[Ht].y.cmp(ge[jt].y) === 0 ? (Yt[1] = ge[Ht].add(ge[jt]), Yt[2] = ge[Ht].toJ().mixedAdd(ge[jt].neg())) : ge[Ht].y.cmp(ge[jt].y.redNeg()) === 0 ? (Yt[1] = ge[Ht].toJ().mixedAdd(ge[jt]), Yt[2] = ge[Ht].add(ge[jt].neg())) : (Yt[1] = ge[Ht].toJ().mixedAdd(ge[jt]), Yt[2] = ge[Ht].toJ().mixedAdd(ge[jt].neg()));
      var Dt = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Ct = ne(oe[Ht], oe[jt]);
      for (vt = Math.max(Ct[0].length, vt), ht[Ht] = new Array(vt), ht[jt] = new Array(vt), _t = 0; _t < vt; _t++) {
        var Kt = Ct[0][_t] | 0, Nt = Ct[1][_t] | 0;
        ht[Ht][_t] = Dt[(Kt + 1) * 3 + (Nt + 1)], ht[jt][_t] = 0, Ve[Ht] = Yt;
      }
    }
    var Je = this.jpoint(null, null, null), Xe = this._wnafT4;
    for (Pt = vt; Pt >= 0; Pt--) {
      for (var Ke = 0; Pt >= 0; ) {
        var Qe = !0;
        for (_t = 0; _t < Ee; _t++)
          Xe[_t] = ht[_t][Pt] | 0, Xe[_t] !== 0 && (Qe = !1);
        if (!Qe)
          break;
        Ke++, Pt--;
      }
      if (Pt >= 0 && Ke++, Je = Je.dblp(Ke), Pt < 0)
        break;
      for (_t = 0; _t < Ee; _t++) {
        var bt = Xe[_t];
        bt !== 0 && (bt > 0 ? kt = Ve[_t][bt - 1 >> 1] : bt < 0 && (kt = Ve[_t][-bt - 1 >> 1].neg()), kt.type === "affine" ? Je = Je.mixedAdd(kt) : Je = Je.add(kt));
      }
    }
    for (Pt = 0; Pt < Ee; Pt++)
      Ve[Pt] = null;
    return Ce ? Je : Je.toP();
  };
  function se(le, ve) {
    this.curve = le, this.type = ve, this.precomputed = null;
  }
  return ie.BasePoint = se, se.prototype.eq = function() {
    throw new Error("Not implemented");
  }, se.prototype.validate = function() {
    return this.curve.validate(this);
  }, ie.prototype.decodePoint = function(ve, ge) {
    ve = z.toArray(ve, ge);
    var oe = this.p.byteLength();
    if ((ve[0] === 4 || ve[0] === 6 || ve[0] === 7) && ve.length - 1 === 2 * oe) {
      ve[0] === 6 ? ae(ve[ve.length - 1] % 2 === 0) : ve[0] === 7 && ae(ve[ve.length - 1] % 2 === 1);
      var Ee = this.point(
        ve.slice(1, 1 + oe),
        ve.slice(1 + oe, 1 + 2 * oe)
      );
      return Ee;
    } else if ((ve[0] === 2 || ve[0] === 3) && ve.length - 1 === oe)
      return this.pointFromX(ve.slice(1, 1 + oe), ve[0] === 3);
    throw new Error("Unknown point format");
  }, se.prototype.encodeCompressed = function(ve) {
    return this.encode(ve, !0);
  }, se.prototype._encode = function(ve) {
    var ge = this.curve.p.byteLength(), oe = this.getX().toArray("be", ge);
    return ve ? [this.getY().isEven() ? 2 : 3].concat(oe) : [4].concat(oe, this.getY().toArray("be", ge));
  }, se.prototype.encode = function(ve, ge) {
    return z.encode(this._encode(ge), ve);
  }, se.prototype.precompute = function(ve) {
    if (this.precomputed)
      return this;
    var ge = {
      doubles: null,
      naf: null,
      beta: null
    };
    return ge.naf = this._getNAFPoints(8), ge.doubles = this._getDoubles(4, ve), ge.beta = this._getBeta(), this.precomputed = ge, this;
  }, se.prototype._hasDoubles = function(ve) {
    if (!this.precomputed)
      return !1;
    var ge = this.precomputed.doubles;
    return ge ? ge.points.length >= Math.ceil((ve.bitLength() + 1) / ge.step) : !1;
  }, se.prototype._getDoubles = function(ve, ge) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var oe = [this], Ee = this, Ce = 0; Ce < ge; Ce += ve) {
      for (var Pe = 0; Pe < ve; Pe++)
        Ee = Ee.dbl();
      oe.push(Ee);
    }
    return {
      step: ve,
      points: oe
    };
  }, se.prototype._getNAFPoints = function(ve) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var ge = [this], oe = (1 << ve) - 1, Ee = oe === 1 ? null : this.dbl(), Ce = 1; Ce < oe; Ce++)
      ge[Ce] = ge[Ce - 1].add(Ee);
    return {
      wnd: ve,
      points: ge
    };
  }, se.prototype._getBeta = function() {
    return null;
  }, se.prototype.dblp = function(ve) {
    for (var ge = this, oe = 0; oe < ve; oe++)
      ge = ge.dbl();
    return ge;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var B = requireUtils$1(), z = requireBn$1(), Y = requireInherits_browser(), ne = requireBase$1(), ae = B.assert;
  function ie(ve) {
    ne.call(this, "short", ve), this.a = new z(ve.a, 16).toRed(this.red), this.b = new z(ve.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ve), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Y(ie, ne), short = ie, ie.prototype._getEndomorphism = function(ge) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var oe, Ee;
      if (ge.beta)
        oe = new z(ge.beta, 16).toRed(this.red);
      else {
        var Ce = this._getEndoRoots(this.p);
        oe = Ce[0].cmp(Ce[1]) < 0 ? Ce[0] : Ce[1], oe = oe.toRed(this.red);
      }
      if (ge.lambda)
        Ee = new z(ge.lambda, 16);
      else {
        var Pe = this._getEndoRoots(this.n);
        this.g.mul(Pe[0]).x.cmp(this.g.x.redMul(oe)) === 0 ? Ee = Pe[0] : (Ee = Pe[1], ae(this.g.mul(Ee).x.cmp(this.g.x.redMul(oe)) === 0));
      }
      var Ve;
      return ge.basis ? Ve = ge.basis.map(function(ht) {
        return {
          a: new z(ht.a, 16),
          b: new z(ht.b, 16)
        };
      }) : Ve = this._getEndoBasis(Ee), {
        beta: oe,
        lambda: Ee,
        basis: Ve
      };
    }
  }, ie.prototype._getEndoRoots = function(ge) {
    var oe = ge === this.p ? this.red : z.mont(ge), Ee = new z(2).toRed(oe).redInvm(), Ce = Ee.redNeg(), Pe = new z(3).toRed(oe).redNeg().redSqrt().redMul(Ee), Ve = Ce.redAdd(Pe).fromRed(), ht = Ce.redSub(Pe).fromRed();
    return [Ve, ht];
  }, ie.prototype._getEndoBasis = function(ge) {
    for (var oe = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Ee = ge, Ce = this.n.clone(), Pe = new z(1), Ve = new z(0), ht = new z(0), vt = new z(1), Pt, _t, kt, Ot, Ht, jt, Yt, Dt = 0, Ct, Kt; Ee.cmpn(0) !== 0; ) {
      var Nt = Ce.div(Ee);
      Ct = Ce.sub(Nt.mul(Ee)), Kt = ht.sub(Nt.mul(Pe));
      var Je = vt.sub(Nt.mul(Ve));
      if (!kt && Ct.cmp(oe) < 0)
        Pt = Yt.neg(), _t = Pe, kt = Ct.neg(), Ot = Kt;
      else if (kt && ++Dt === 2)
        break;
      Yt = Ct, Ce = Ee, Ee = Ct, ht = Pe, Pe = Kt, vt = Ve, Ve = Je;
    }
    Ht = Ct.neg(), jt = Kt;
    var Xe = kt.sqr().add(Ot.sqr()), Ke = Ht.sqr().add(jt.sqr());
    return Ke.cmp(Xe) >= 0 && (Ht = Pt, jt = _t), kt.negative && (kt = kt.neg(), Ot = Ot.neg()), Ht.negative && (Ht = Ht.neg(), jt = jt.neg()), [
      { a: kt, b: Ot },
      { a: Ht, b: jt }
    ];
  }, ie.prototype._endoSplit = function(ge) {
    var oe = this.endo.basis, Ee = oe[0], Ce = oe[1], Pe = Ce.b.mul(ge).divRound(this.n), Ve = Ee.b.neg().mul(ge).divRound(this.n), ht = Pe.mul(Ee.a), vt = Ve.mul(Ce.a), Pt = Pe.mul(Ee.b), _t = Ve.mul(Ce.b), kt = ge.sub(ht).sub(vt), Ot = Pt.add(_t).neg();
    return { k1: kt, k2: Ot };
  }, ie.prototype.pointFromX = function(ge, oe) {
    ge = new z(ge, 16), ge.red || (ge = ge.toRed(this.red));
    var Ee = ge.redSqr().redMul(ge).redIAdd(ge.redMul(this.a)).redIAdd(this.b), Ce = Ee.redSqrt();
    if (Ce.redSqr().redSub(Ee).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Pe = Ce.fromRed().isOdd();
    return (oe && !Pe || !oe && Pe) && (Ce = Ce.redNeg()), this.point(ge, Ce);
  }, ie.prototype.validate = function(ge) {
    if (ge.inf)
      return !0;
    var oe = ge.x, Ee = ge.y, Ce = this.a.redMul(oe), Pe = oe.redSqr().redMul(oe).redIAdd(Ce).redIAdd(this.b);
    return Ee.redSqr().redISub(Pe).cmpn(0) === 0;
  }, ie.prototype._endoWnafMulAdd = function(ge, oe, Ee) {
    for (var Ce = this._endoWnafT1, Pe = this._endoWnafT2, Ve = 0; Ve < ge.length; Ve++) {
      var ht = this._endoSplit(oe[Ve]), vt = ge[Ve], Pt = vt._getBeta();
      ht.k1.negative && (ht.k1.ineg(), vt = vt.neg(!0)), ht.k2.negative && (ht.k2.ineg(), Pt = Pt.neg(!0)), Ce[Ve * 2] = vt, Ce[Ve * 2 + 1] = Pt, Pe[Ve * 2] = ht.k1, Pe[Ve * 2 + 1] = ht.k2;
    }
    for (var _t = this._wnafMulAdd(1, Ce, Pe, Ve * 2, Ee), kt = 0; kt < Ve * 2; kt++)
      Ce[kt] = null, Pe[kt] = null;
    return _t;
  };
  function se(ve, ge, oe, Ee) {
    ne.BasePoint.call(this, ve, "affine"), ge === null && oe === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new z(ge, 16), this.y = new z(oe, 16), Ee && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  Y(se, ne.BasePoint), ie.prototype.point = function(ge, oe, Ee) {
    return new se(this, ge, oe, Ee);
  }, ie.prototype.pointFromJSON = function(ge, oe) {
    return se.fromJSON(this, ge, oe);
  }, se.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ge = this.precomputed;
      if (ge && ge.beta)
        return ge.beta;
      var oe = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ge) {
        var Ee = this.curve, Ce = function(Pe) {
          return Ee.point(Pe.x.redMul(Ee.endo.beta), Pe.y);
        };
        ge.beta = oe, oe.precomputed = {
          beta: null,
          naf: ge.naf && {
            wnd: ge.naf.wnd,
            points: ge.naf.points.map(Ce)
          },
          doubles: ge.doubles && {
            step: ge.doubles.step,
            points: ge.doubles.points.map(Ce)
          }
        };
      }
      return oe;
    }
  }, se.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, se.fromJSON = function(ge, oe, Ee) {
    typeof oe == "string" && (oe = JSON.parse(oe));
    var Ce = ge.point(oe[0], oe[1], Ee);
    if (!oe[2])
      return Ce;
    function Pe(ht) {
      return ge.point(ht[0], ht[1], Ee);
    }
    var Ve = oe[2];
    return Ce.precomputed = {
      beta: null,
      doubles: Ve.doubles && {
        step: Ve.doubles.step,
        points: [Ce].concat(Ve.doubles.points.map(Pe))
      },
      naf: Ve.naf && {
        wnd: Ve.naf.wnd,
        points: [Ce].concat(Ve.naf.points.map(Pe))
      }
    }, Ce;
  }, se.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, se.prototype.isInfinity = function() {
    return this.inf;
  }, se.prototype.add = function(ge) {
    if (this.inf)
      return ge;
    if (ge.inf)
      return this;
    if (this.eq(ge))
      return this.dbl();
    if (this.neg().eq(ge))
      return this.curve.point(null, null);
    if (this.x.cmp(ge.x) === 0)
      return this.curve.point(null, null);
    var oe = this.y.redSub(ge.y);
    oe.cmpn(0) !== 0 && (oe = oe.redMul(this.x.redSub(ge.x).redInvm()));
    var Ee = oe.redSqr().redISub(this.x).redISub(ge.x), Ce = oe.redMul(this.x.redSub(Ee)).redISub(this.y);
    return this.curve.point(Ee, Ce);
  }, se.prototype.dbl = function() {
    if (this.inf)
      return this;
    var ge = this.y.redAdd(this.y);
    if (ge.cmpn(0) === 0)
      return this.curve.point(null, null);
    var oe = this.curve.a, Ee = this.x.redSqr(), Ce = ge.redInvm(), Pe = Ee.redAdd(Ee).redIAdd(Ee).redIAdd(oe).redMul(Ce), Ve = Pe.redSqr().redISub(this.x.redAdd(this.x)), ht = Pe.redMul(this.x.redSub(Ve)).redISub(this.y);
    return this.curve.point(Ve, ht);
  }, se.prototype.getX = function() {
    return this.x.fromRed();
  }, se.prototype.getY = function() {
    return this.y.fromRed();
  }, se.prototype.mul = function(ge) {
    return ge = new z(ge, 16), this.isInfinity() ? this : this._hasDoubles(ge) ? this.curve._fixedNafMul(this, ge) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ge]) : this.curve._wnafMul(this, ge);
  }, se.prototype.mulAdd = function(ge, oe, Ee) {
    var Ce = [this, oe], Pe = [ge, Ee];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ce, Pe) : this.curve._wnafMulAdd(1, Ce, Pe, 2);
  }, se.prototype.jmulAdd = function(ge, oe, Ee) {
    var Ce = [this, oe], Pe = [ge, Ee];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ce, Pe, !0) : this.curve._wnafMulAdd(1, Ce, Pe, 2, !0);
  }, se.prototype.eq = function(ge) {
    return this === ge || this.inf === ge.inf && (this.inf || this.x.cmp(ge.x) === 0 && this.y.cmp(ge.y) === 0);
  }, se.prototype.neg = function(ge) {
    if (this.inf)
      return this;
    var oe = this.curve.point(this.x, this.y.redNeg());
    if (ge && this.precomputed) {
      var Ee = this.precomputed, Ce = function(Pe) {
        return Pe.neg();
      };
      oe.precomputed = {
        naf: Ee.naf && {
          wnd: Ee.naf.wnd,
          points: Ee.naf.points.map(Ce)
        },
        doubles: Ee.doubles && {
          step: Ee.doubles.step,
          points: Ee.doubles.points.map(Ce)
        }
      };
    }
    return oe;
  }, se.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var ge = this.curve.jpoint(this.x, this.y, this.curve.one);
    return ge;
  };
  function le(ve, ge, oe, Ee) {
    ne.BasePoint.call(this, ve, "jacobian"), ge === null && oe === null && Ee === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new z(0)) : (this.x = new z(ge, 16), this.y = new z(oe, 16), this.z = new z(Ee, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return Y(le, ne.BasePoint), ie.prototype.jpoint = function(ge, oe, Ee) {
    return new le(this, ge, oe, Ee);
  }, le.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var ge = this.z.redInvm(), oe = ge.redSqr(), Ee = this.x.redMul(oe), Ce = this.y.redMul(oe).redMul(ge);
    return this.curve.point(Ee, Ce);
  }, le.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, le.prototype.add = function(ge) {
    if (this.isInfinity())
      return ge;
    if (ge.isInfinity())
      return this;
    var oe = ge.z.redSqr(), Ee = this.z.redSqr(), Ce = this.x.redMul(oe), Pe = ge.x.redMul(Ee), Ve = this.y.redMul(oe.redMul(ge.z)), ht = ge.y.redMul(Ee.redMul(this.z)), vt = Ce.redSub(Pe), Pt = Ve.redSub(ht);
    if (vt.cmpn(0) === 0)
      return Pt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var _t = vt.redSqr(), kt = _t.redMul(vt), Ot = Ce.redMul(_t), Ht = Pt.redSqr().redIAdd(kt).redISub(Ot).redISub(Ot), jt = Pt.redMul(Ot.redISub(Ht)).redISub(Ve.redMul(kt)), Yt = this.z.redMul(ge.z).redMul(vt);
    return this.curve.jpoint(Ht, jt, Yt);
  }, le.prototype.mixedAdd = function(ge) {
    if (this.isInfinity())
      return ge.toJ();
    if (ge.isInfinity())
      return this;
    var oe = this.z.redSqr(), Ee = this.x, Ce = ge.x.redMul(oe), Pe = this.y, Ve = ge.y.redMul(oe).redMul(this.z), ht = Ee.redSub(Ce), vt = Pe.redSub(Ve);
    if (ht.cmpn(0) === 0)
      return vt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Pt = ht.redSqr(), _t = Pt.redMul(ht), kt = Ee.redMul(Pt), Ot = vt.redSqr().redIAdd(_t).redISub(kt).redISub(kt), Ht = vt.redMul(kt.redISub(Ot)).redISub(Pe.redMul(_t)), jt = this.z.redMul(ht);
    return this.curve.jpoint(Ot, Ht, jt);
  }, le.prototype.dblp = function(ge) {
    if (ge === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!ge)
      return this.dbl();
    var oe;
    if (this.curve.zeroA || this.curve.threeA) {
      var Ee = this;
      for (oe = 0; oe < ge; oe++)
        Ee = Ee.dbl();
      return Ee;
    }
    var Ce = this.curve.a, Pe = this.curve.tinv, Ve = this.x, ht = this.y, vt = this.z, Pt = vt.redSqr().redSqr(), _t = ht.redAdd(ht);
    for (oe = 0; oe < ge; oe++) {
      var kt = Ve.redSqr(), Ot = _t.redSqr(), Ht = Ot.redSqr(), jt = kt.redAdd(kt).redIAdd(kt).redIAdd(Ce.redMul(Pt)), Yt = Ve.redMul(Ot), Dt = jt.redSqr().redISub(Yt.redAdd(Yt)), Ct = Yt.redISub(Dt), Kt = jt.redMul(Ct);
      Kt = Kt.redIAdd(Kt).redISub(Ht);
      var Nt = _t.redMul(vt);
      oe + 1 < ge && (Pt = Pt.redMul(Ht)), Ve = Dt, vt = Nt, _t = Kt;
    }
    return this.curve.jpoint(Ve, _t.redMul(Pe), vt);
  }, le.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, le.prototype._zeroDbl = function() {
    var ge, oe, Ee;
    if (this.zOne) {
      var Ce = this.x.redSqr(), Pe = this.y.redSqr(), Ve = Pe.redSqr(), ht = this.x.redAdd(Pe).redSqr().redISub(Ce).redISub(Ve);
      ht = ht.redIAdd(ht);
      var vt = Ce.redAdd(Ce).redIAdd(Ce), Pt = vt.redSqr().redISub(ht).redISub(ht), _t = Ve.redIAdd(Ve);
      _t = _t.redIAdd(_t), _t = _t.redIAdd(_t), ge = Pt, oe = vt.redMul(ht.redISub(Pt)).redISub(_t), Ee = this.y.redAdd(this.y);
    } else {
      var kt = this.x.redSqr(), Ot = this.y.redSqr(), Ht = Ot.redSqr(), jt = this.x.redAdd(Ot).redSqr().redISub(kt).redISub(Ht);
      jt = jt.redIAdd(jt);
      var Yt = kt.redAdd(kt).redIAdd(kt), Dt = Yt.redSqr(), Ct = Ht.redIAdd(Ht);
      Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct), ge = Dt.redISub(jt).redISub(jt), oe = Yt.redMul(jt.redISub(ge)).redISub(Ct), Ee = this.y.redMul(this.z), Ee = Ee.redIAdd(Ee);
    }
    return this.curve.jpoint(ge, oe, Ee);
  }, le.prototype._threeDbl = function() {
    var ge, oe, Ee;
    if (this.zOne) {
      var Ce = this.x.redSqr(), Pe = this.y.redSqr(), Ve = Pe.redSqr(), ht = this.x.redAdd(Pe).redSqr().redISub(Ce).redISub(Ve);
      ht = ht.redIAdd(ht);
      var vt = Ce.redAdd(Ce).redIAdd(Ce).redIAdd(this.curve.a), Pt = vt.redSqr().redISub(ht).redISub(ht);
      ge = Pt;
      var _t = Ve.redIAdd(Ve);
      _t = _t.redIAdd(_t), _t = _t.redIAdd(_t), oe = vt.redMul(ht.redISub(Pt)).redISub(_t), Ee = this.y.redAdd(this.y);
    } else {
      var kt = this.z.redSqr(), Ot = this.y.redSqr(), Ht = this.x.redMul(Ot), jt = this.x.redSub(kt).redMul(this.x.redAdd(kt));
      jt = jt.redAdd(jt).redIAdd(jt);
      var Yt = Ht.redIAdd(Ht);
      Yt = Yt.redIAdd(Yt);
      var Dt = Yt.redAdd(Yt);
      ge = jt.redSqr().redISub(Dt), Ee = this.y.redAdd(this.z).redSqr().redISub(Ot).redISub(kt);
      var Ct = Ot.redSqr();
      Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct), oe = jt.redMul(Yt.redISub(ge)).redISub(Ct);
    }
    return this.curve.jpoint(ge, oe, Ee);
  }, le.prototype._dbl = function() {
    var ge = this.curve.a, oe = this.x, Ee = this.y, Ce = this.z, Pe = Ce.redSqr().redSqr(), Ve = oe.redSqr(), ht = Ee.redSqr(), vt = Ve.redAdd(Ve).redIAdd(Ve).redIAdd(ge.redMul(Pe)), Pt = oe.redAdd(oe);
    Pt = Pt.redIAdd(Pt);
    var _t = Pt.redMul(ht), kt = vt.redSqr().redISub(_t.redAdd(_t)), Ot = _t.redISub(kt), Ht = ht.redSqr();
    Ht = Ht.redIAdd(Ht), Ht = Ht.redIAdd(Ht), Ht = Ht.redIAdd(Ht);
    var jt = vt.redMul(Ot).redISub(Ht), Yt = Ee.redAdd(Ee).redMul(Ce);
    return this.curve.jpoint(kt, jt, Yt);
  }, le.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var ge = this.x.redSqr(), oe = this.y.redSqr(), Ee = this.z.redSqr(), Ce = oe.redSqr(), Pe = ge.redAdd(ge).redIAdd(ge), Ve = Pe.redSqr(), ht = this.x.redAdd(oe).redSqr().redISub(ge).redISub(Ce);
    ht = ht.redIAdd(ht), ht = ht.redAdd(ht).redIAdd(ht), ht = ht.redISub(Ve);
    var vt = ht.redSqr(), Pt = Ce.redIAdd(Ce);
    Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt);
    var _t = Pe.redIAdd(ht).redSqr().redISub(Ve).redISub(vt).redISub(Pt), kt = oe.redMul(_t);
    kt = kt.redIAdd(kt), kt = kt.redIAdd(kt);
    var Ot = this.x.redMul(vt).redISub(kt);
    Ot = Ot.redIAdd(Ot), Ot = Ot.redIAdd(Ot);
    var Ht = this.y.redMul(_t.redMul(Pt.redISub(_t)).redISub(ht.redMul(vt)));
    Ht = Ht.redIAdd(Ht), Ht = Ht.redIAdd(Ht), Ht = Ht.redIAdd(Ht);
    var jt = this.z.redAdd(ht).redSqr().redISub(Ee).redISub(vt);
    return this.curve.jpoint(Ot, Ht, jt);
  }, le.prototype.mul = function(ge, oe) {
    return ge = new z(ge, oe), this.curve._wnafMul(this, ge);
  }, le.prototype.eq = function(ge) {
    if (ge.type === "affine")
      return this.eq(ge.toJ());
    if (this === ge)
      return !0;
    var oe = this.z.redSqr(), Ee = ge.z.redSqr();
    if (this.x.redMul(Ee).redISub(ge.x.redMul(oe)).cmpn(0) !== 0)
      return !1;
    var Ce = oe.redMul(this.z), Pe = Ee.redMul(ge.z);
    return this.y.redMul(Pe).redISub(ge.y.redMul(Ce)).cmpn(0) === 0;
  }, le.prototype.eqXToP = function(ge) {
    var oe = this.z.redSqr(), Ee = ge.toRed(this.curve.red).redMul(oe);
    if (this.x.cmp(Ee) === 0)
      return !0;
    for (var Ce = ge.clone(), Pe = this.curve.redN.redMul(oe); ; ) {
      if (Ce.iadd(this.curve.n), Ce.cmp(this.curve.p) >= 0)
        return !1;
      if (Ee.redIAdd(Pe), this.x.cmp(Ee) === 0)
        return !0;
    }
  }, le.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, le.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var B = requireBn$1(), z = requireInherits_browser(), Y = requireBase$1(), ne = requireUtils$1();
  function ae(se) {
    Y.call(this, "mont", se), this.a = new B(se.a, 16).toRed(this.red), this.b = new B(se.b, 16).toRed(this.red), this.i4 = new B(4).toRed(this.red).redInvm(), this.two = new B(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  z(ae, Y), mont = ae, ae.prototype.validate = function(le) {
    var ve = le.normalize().x, ge = ve.redSqr(), oe = ge.redMul(ve).redAdd(ge.redMul(this.a)).redAdd(ve), Ee = oe.redSqrt();
    return Ee.redSqr().cmp(oe) === 0;
  };
  function ie(se, le, ve) {
    Y.BasePoint.call(this, se, "projective"), le === null && ve === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new B(le, 16), this.z = new B(ve, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return z(ie, Y.BasePoint), ae.prototype.decodePoint = function(le, ve) {
    return this.point(ne.toArray(le, ve), 1);
  }, ae.prototype.point = function(le, ve) {
    return new ie(this, le, ve);
  }, ae.prototype.pointFromJSON = function(le) {
    return ie.fromJSON(this, le);
  }, ie.prototype.precompute = function() {
  }, ie.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, ie.fromJSON = function(le, ve) {
    return new ie(le, ve[0], ve[1] || le.one);
  }, ie.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, ie.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, ie.prototype.dbl = function() {
    var le = this.x.redAdd(this.z), ve = le.redSqr(), ge = this.x.redSub(this.z), oe = ge.redSqr(), Ee = ve.redSub(oe), Ce = ve.redMul(oe), Pe = Ee.redMul(oe.redAdd(this.curve.a24.redMul(Ee)));
    return this.curve.point(Ce, Pe);
  }, ie.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.diffAdd = function(le, ve) {
    var ge = this.x.redAdd(this.z), oe = this.x.redSub(this.z), Ee = le.x.redAdd(le.z), Ce = le.x.redSub(le.z), Pe = Ce.redMul(ge), Ve = Ee.redMul(oe), ht = ve.z.redMul(Pe.redAdd(Ve).redSqr()), vt = ve.x.redMul(Pe.redISub(Ve).redSqr());
    return this.curve.point(ht, vt);
  }, ie.prototype.mul = function(le) {
    for (var ve = le.clone(), ge = this, oe = this.curve.point(null, null), Ee = this, Ce = []; ve.cmpn(0) !== 0; ve.iushrn(1))
      Ce.push(ve.andln(1));
    for (var Pe = Ce.length - 1; Pe >= 0; Pe--)
      Ce[Pe] === 0 ? (ge = ge.diffAdd(oe, Ee), oe = oe.dbl()) : (oe = ge.diffAdd(oe, Ee), ge = ge.dbl());
    return oe;
  }, ie.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.eq = function(le) {
    return this.getX().cmp(le.getX()) === 0;
  }, ie.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, ie.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var B = requireUtils$1(), z = requireBn$1(), Y = requireInherits_browser(), ne = requireBase$1(), ae = B.assert;
  function ie(le) {
    this.twisted = (le.a | 0) !== 1, this.mOneA = this.twisted && (le.a | 0) === -1, this.extended = this.mOneA, ne.call(this, "edwards", le), this.a = new z(le.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new z(le.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new z(le.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), ae(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (le.c | 0) === 1;
  }
  Y(ie, ne), edwards = ie, ie.prototype._mulA = function(ve) {
    return this.mOneA ? ve.redNeg() : this.a.redMul(ve);
  }, ie.prototype._mulC = function(ve) {
    return this.oneC ? ve : this.c.redMul(ve);
  }, ie.prototype.jpoint = function(ve, ge, oe, Ee) {
    return this.point(ve, ge, oe, Ee);
  }, ie.prototype.pointFromX = function(ve, ge) {
    ve = new z(ve, 16), ve.red || (ve = ve.toRed(this.red));
    var oe = ve.redSqr(), Ee = this.c2.redSub(this.a.redMul(oe)), Ce = this.one.redSub(this.c2.redMul(this.d).redMul(oe)), Pe = Ee.redMul(Ce.redInvm()), Ve = Pe.redSqrt();
    if (Ve.redSqr().redSub(Pe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var ht = Ve.fromRed().isOdd();
    return (ge && !ht || !ge && ht) && (Ve = Ve.redNeg()), this.point(ve, Ve);
  }, ie.prototype.pointFromY = function(ve, ge) {
    ve = new z(ve, 16), ve.red || (ve = ve.toRed(this.red));
    var oe = ve.redSqr(), Ee = oe.redSub(this.c2), Ce = oe.redMul(this.d).redMul(this.c2).redSub(this.a), Pe = Ee.redMul(Ce.redInvm());
    if (Pe.cmp(this.zero) === 0) {
      if (ge)
        throw new Error("invalid point");
      return this.point(this.zero, ve);
    }
    var Ve = Pe.redSqrt();
    if (Ve.redSqr().redSub(Pe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return Ve.fromRed().isOdd() !== ge && (Ve = Ve.redNeg()), this.point(Ve, ve);
  }, ie.prototype.validate = function(ve) {
    if (ve.isInfinity())
      return !0;
    ve.normalize();
    var ge = ve.x.redSqr(), oe = ve.y.redSqr(), Ee = ge.redMul(this.a).redAdd(oe), Ce = this.c2.redMul(this.one.redAdd(this.d.redMul(ge).redMul(oe)));
    return Ee.cmp(Ce) === 0;
  };
  function se(le, ve, ge, oe, Ee) {
    ne.BasePoint.call(this, le, "projective"), ve === null && ge === null && oe === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new z(ve, 16), this.y = new z(ge, 16), this.z = oe ? new z(oe, 16) : this.curve.one, this.t = Ee && new z(Ee, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return Y(se, ne.BasePoint), ie.prototype.pointFromJSON = function(ve) {
    return se.fromJSON(this, ve);
  }, ie.prototype.point = function(ve, ge, oe, Ee) {
    return new se(this, ve, ge, oe, Ee);
  }, se.fromJSON = function(ve, ge) {
    return new se(ve, ge[0], ge[1], ge[2]);
  }, se.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, se.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, se.prototype._extDbl = function() {
    var ve = this.x.redSqr(), ge = this.y.redSqr(), oe = this.z.redSqr();
    oe = oe.redIAdd(oe);
    var Ee = this.curve._mulA(ve), Ce = this.x.redAdd(this.y).redSqr().redISub(ve).redISub(ge), Pe = Ee.redAdd(ge), Ve = Pe.redSub(oe), ht = Ee.redSub(ge), vt = Ce.redMul(Ve), Pt = Pe.redMul(ht), _t = Ce.redMul(ht), kt = Ve.redMul(Pe);
    return this.curve.point(vt, Pt, kt, _t);
  }, se.prototype._projDbl = function() {
    var ve = this.x.redAdd(this.y).redSqr(), ge = this.x.redSqr(), oe = this.y.redSqr(), Ee, Ce, Pe, Ve, ht, vt;
    if (this.curve.twisted) {
      Ve = this.curve._mulA(ge);
      var Pt = Ve.redAdd(oe);
      this.zOne ? (Ee = ve.redSub(ge).redSub(oe).redMul(Pt.redSub(this.curve.two)), Ce = Pt.redMul(Ve.redSub(oe)), Pe = Pt.redSqr().redSub(Pt).redSub(Pt)) : (ht = this.z.redSqr(), vt = Pt.redSub(ht).redISub(ht), Ee = ve.redSub(ge).redISub(oe).redMul(vt), Ce = Pt.redMul(Ve.redSub(oe)), Pe = Pt.redMul(vt));
    } else
      Ve = ge.redAdd(oe), ht = this.curve._mulC(this.z).redSqr(), vt = Ve.redSub(ht).redSub(ht), Ee = this.curve._mulC(ve.redISub(Ve)).redMul(vt), Ce = this.curve._mulC(Ve).redMul(ge.redISub(oe)), Pe = Ve.redMul(vt);
    return this.curve.point(Ee, Ce, Pe);
  }, se.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, se.prototype._extAdd = function(ve) {
    var ge = this.y.redSub(this.x).redMul(ve.y.redSub(ve.x)), oe = this.y.redAdd(this.x).redMul(ve.y.redAdd(ve.x)), Ee = this.t.redMul(this.curve.dd).redMul(ve.t), Ce = this.z.redMul(ve.z.redAdd(ve.z)), Pe = oe.redSub(ge), Ve = Ce.redSub(Ee), ht = Ce.redAdd(Ee), vt = oe.redAdd(ge), Pt = Pe.redMul(Ve), _t = ht.redMul(vt), kt = Pe.redMul(vt), Ot = Ve.redMul(ht);
    return this.curve.point(Pt, _t, Ot, kt);
  }, se.prototype._projAdd = function(ve) {
    var ge = this.z.redMul(ve.z), oe = ge.redSqr(), Ee = this.x.redMul(ve.x), Ce = this.y.redMul(ve.y), Pe = this.curve.d.redMul(Ee).redMul(Ce), Ve = oe.redSub(Pe), ht = oe.redAdd(Pe), vt = this.x.redAdd(this.y).redMul(ve.x.redAdd(ve.y)).redISub(Ee).redISub(Ce), Pt = ge.redMul(Ve).redMul(vt), _t, kt;
    return this.curve.twisted ? (_t = ge.redMul(ht).redMul(Ce.redSub(this.curve._mulA(Ee))), kt = Ve.redMul(ht)) : (_t = ge.redMul(ht).redMul(Ce.redSub(Ee)), kt = this.curve._mulC(Ve).redMul(ht)), this.curve.point(Pt, _t, kt);
  }, se.prototype.add = function(ve) {
    return this.isInfinity() ? ve : ve.isInfinity() ? this : this.curve.extended ? this._extAdd(ve) : this._projAdd(ve);
  }, se.prototype.mul = function(ve) {
    return this._hasDoubles(ve) ? this.curve._fixedNafMul(this, ve) : this.curve._wnafMul(this, ve);
  }, se.prototype.mulAdd = function(ve, ge, oe) {
    return this.curve._wnafMulAdd(1, [this, ge], [ve, oe], 2, !1);
  }, se.prototype.jmulAdd = function(ve, ge, oe) {
    return this.curve._wnafMulAdd(1, [this, ge], [ve, oe], 2, !0);
  }, se.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ve = this.z.redInvm();
    return this.x = this.x.redMul(ve), this.y = this.y.redMul(ve), this.t && (this.t = this.t.redMul(ve)), this.z = this.curve.one, this.zOne = !0, this;
  }, se.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, se.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, se.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, se.prototype.eq = function(ve) {
    return this === ve || this.getX().cmp(ve.getX()) === 0 && this.getY().cmp(ve.getY()) === 0;
  }, se.prototype.eqXToP = function(ve) {
    var ge = ve.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ge) === 0)
      return !0;
    for (var oe = ve.clone(), Ee = this.curve.redN.redMul(this.z); ; ) {
      if (oe.iadd(this.curve.n), oe.cmp(this.curve.p) >= 0)
        return !1;
      if (ge.redIAdd(Ee), this.x.cmp(ge) === 0)
        return !0;
    }
  }, se.prototype.toP = se.prototype.normalize, se.prototype.mixedAdd = se.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(B) {
    var z = B;
    z.base = requireBase$1(), z.short = requireShort(), z.mont = requireMont(), z.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser();
  utils$1.inherits = z;
  function Y(Je, Xe) {
    return (Je.charCodeAt(Xe) & 64512) !== 55296 || Xe < 0 || Xe + 1 >= Je.length ? !1 : (Je.charCodeAt(Xe + 1) & 64512) === 56320;
  }
  function ne(Je, Xe) {
    if (Array.isArray(Je))
      return Je.slice();
    if (!Je)
      return [];
    var Ke = [];
    if (typeof Je == "string")
      if (Xe) {
        if (Xe === "hex")
          for (Je = Je.replace(/[^a-z0-9]+/ig, ""), Je.length % 2 !== 0 && (Je = "0" + Je), bt = 0; bt < Je.length; bt += 2)
            Ke.push(parseInt(Je[bt] + Je[bt + 1], 16));
      } else for (var Qe = 0, bt = 0; bt < Je.length; bt++) {
        var wt = Je.charCodeAt(bt);
        wt < 128 ? Ke[Qe++] = wt : wt < 2048 ? (Ke[Qe++] = wt >> 6 | 192, Ke[Qe++] = wt & 63 | 128) : Y(Je, bt) ? (wt = 65536 + ((wt & 1023) << 10) + (Je.charCodeAt(++bt) & 1023), Ke[Qe++] = wt >> 18 | 240, Ke[Qe++] = wt >> 12 & 63 | 128, Ke[Qe++] = wt >> 6 & 63 | 128, Ke[Qe++] = wt & 63 | 128) : (Ke[Qe++] = wt >> 12 | 224, Ke[Qe++] = wt >> 6 & 63 | 128, Ke[Qe++] = wt & 63 | 128);
      }
    else
      for (bt = 0; bt < Je.length; bt++)
        Ke[bt] = Je[bt] | 0;
    return Ke;
  }
  utils$1.toArray = ne;
  function ae(Je) {
    for (var Xe = "", Ke = 0; Ke < Je.length; Ke++)
      Xe += le(Je[Ke].toString(16));
    return Xe;
  }
  utils$1.toHex = ae;
  function ie(Je) {
    var Xe = Je >>> 24 | Je >>> 8 & 65280 | Je << 8 & 16711680 | (Je & 255) << 24;
    return Xe >>> 0;
  }
  utils$1.htonl = ie;
  function se(Je, Xe) {
    for (var Ke = "", Qe = 0; Qe < Je.length; Qe++) {
      var bt = Je[Qe];
      Xe === "little" && (bt = ie(bt)), Ke += ve(bt.toString(16));
    }
    return Ke;
  }
  utils$1.toHex32 = se;
  function le(Je) {
    return Je.length === 1 ? "0" + Je : Je;
  }
  utils$1.zero2 = le;
  function ve(Je) {
    return Je.length === 7 ? "0" + Je : Je.length === 6 ? "00" + Je : Je.length === 5 ? "000" + Je : Je.length === 4 ? "0000" + Je : Je.length === 3 ? "00000" + Je : Je.length === 2 ? "000000" + Je : Je.length === 1 ? "0000000" + Je : Je;
  }
  utils$1.zero8 = ve;
  function ge(Je, Xe, Ke, Qe) {
    var bt = Ke - Xe;
    B(bt % 4 === 0);
    for (var wt = new Array(bt / 4), xt = 0, Bt = Xe; xt < wt.length; xt++, Bt += 4) {
      var $t;
      Qe === "big" ? $t = Je[Bt] << 24 | Je[Bt + 1] << 16 | Je[Bt + 2] << 8 | Je[Bt + 3] : $t = Je[Bt + 3] << 24 | Je[Bt + 2] << 16 | Je[Bt + 1] << 8 | Je[Bt], wt[xt] = $t >>> 0;
    }
    return wt;
  }
  utils$1.join32 = ge;
  function oe(Je, Xe) {
    for (var Ke = new Array(Je.length * 4), Qe = 0, bt = 0; Qe < Je.length; Qe++, bt += 4) {
      var wt = Je[Qe];
      Xe === "big" ? (Ke[bt] = wt >>> 24, Ke[bt + 1] = wt >>> 16 & 255, Ke[bt + 2] = wt >>> 8 & 255, Ke[bt + 3] = wt & 255) : (Ke[bt + 3] = wt >>> 24, Ke[bt + 2] = wt >>> 16 & 255, Ke[bt + 1] = wt >>> 8 & 255, Ke[bt] = wt & 255);
    }
    return Ke;
  }
  utils$1.split32 = oe;
  function Ee(Je, Xe) {
    return Je >>> Xe | Je << 32 - Xe;
  }
  utils$1.rotr32 = Ee;
  function Ce(Je, Xe) {
    return Je << Xe | Je >>> 32 - Xe;
  }
  utils$1.rotl32 = Ce;
  function Pe(Je, Xe) {
    return Je + Xe >>> 0;
  }
  utils$1.sum32 = Pe;
  function Ve(Je, Xe, Ke) {
    return Je + Xe + Ke >>> 0;
  }
  utils$1.sum32_3 = Ve;
  function ht(Je, Xe, Ke, Qe) {
    return Je + Xe + Ke + Qe >>> 0;
  }
  utils$1.sum32_4 = ht;
  function vt(Je, Xe, Ke, Qe, bt) {
    return Je + Xe + Ke + Qe + bt >>> 0;
  }
  utils$1.sum32_5 = vt;
  function Pt(Je, Xe, Ke, Qe) {
    var bt = Je[Xe], wt = Je[Xe + 1], xt = Qe + wt >>> 0, Bt = (xt < Qe ? 1 : 0) + Ke + bt;
    Je[Xe] = Bt >>> 0, Je[Xe + 1] = xt;
  }
  utils$1.sum64 = Pt;
  function _t(Je, Xe, Ke, Qe) {
    var bt = Xe + Qe >>> 0, wt = (bt < Xe ? 1 : 0) + Je + Ke;
    return wt >>> 0;
  }
  utils$1.sum64_hi = _t;
  function kt(Je, Xe, Ke, Qe) {
    var bt = Xe + Qe;
    return bt >>> 0;
  }
  utils$1.sum64_lo = kt;
  function Ot(Je, Xe, Ke, Qe, bt, wt, xt, Bt) {
    var $t = 0, qt = Xe;
    qt = qt + Qe >>> 0, $t += qt < Xe ? 1 : 0, qt = qt + wt >>> 0, $t += qt < wt ? 1 : 0, qt = qt + Bt >>> 0, $t += qt < Bt ? 1 : 0;
    var Rt = Je + Ke + bt + xt + $t;
    return Rt >>> 0;
  }
  utils$1.sum64_4_hi = Ot;
  function Ht(Je, Xe, Ke, Qe, bt, wt, xt, Bt) {
    var $t = Xe + Qe + wt + Bt;
    return $t >>> 0;
  }
  utils$1.sum64_4_lo = Ht;
  function jt(Je, Xe, Ke, Qe, bt, wt, xt, Bt, $t, qt) {
    var Rt = 0, Lt = Xe;
    Lt = Lt + Qe >>> 0, Rt += Lt < Xe ? 1 : 0, Lt = Lt + wt >>> 0, Rt += Lt < wt ? 1 : 0, Lt = Lt + Bt >>> 0, Rt += Lt < Bt ? 1 : 0, Lt = Lt + qt >>> 0, Rt += Lt < qt ? 1 : 0;
    var tr = Je + Ke + bt + xt + $t + Rt;
    return tr >>> 0;
  }
  utils$1.sum64_5_hi = jt;
  function Yt(Je, Xe, Ke, Qe, bt, wt, xt, Bt, $t, qt) {
    var Rt = Xe + Qe + wt + Bt + qt;
    return Rt >>> 0;
  }
  utils$1.sum64_5_lo = Yt;
  function Dt(Je, Xe, Ke) {
    var Qe = Xe << 32 - Ke | Je >>> Ke;
    return Qe >>> 0;
  }
  utils$1.rotr64_hi = Dt;
  function Ct(Je, Xe, Ke) {
    var Qe = Je << 32 - Ke | Xe >>> Ke;
    return Qe >>> 0;
  }
  utils$1.rotr64_lo = Ct;
  function Kt(Je, Xe, Ke) {
    return Je >>> Ke;
  }
  utils$1.shr64_hi = Kt;
  function Nt(Je, Xe, Ke) {
    var Qe = Je << 32 - Ke | Xe >>> Ke;
    return Qe >>> 0;
  }
  return utils$1.shr64_lo = Nt, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var B = requireUtils(), z = requireMinimalisticAssert();
  function Y() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = Y, Y.prototype.update = function(ae, ie) {
    if (ae = B.toArray(ae, ie), this.pending ? this.pending = this.pending.concat(ae) : this.pending = ae, this.pendingTotal += ae.length, this.pending.length >= this._delta8) {
      ae = this.pending;
      var se = ae.length % this._delta8;
      this.pending = ae.slice(ae.length - se, ae.length), this.pending.length === 0 && (this.pending = null), ae = B.join32(ae, 0, ae.length - se, this.endian);
      for (var le = 0; le < ae.length; le += this._delta32)
        this._update(ae, le, le + this._delta32);
    }
    return this;
  }, Y.prototype.digest = function(ae) {
    return this.update(this._pad()), z(this.pending === null), this._digest(ae);
  }, Y.prototype._pad = function() {
    var ae = this.pendingTotal, ie = this._delta8, se = ie - (ae + this.padLength) % ie, le = new Array(se + this.padLength);
    le[0] = 128;
    for (var ve = 1; ve < se; ve++)
      le[ve] = 0;
    if (ae <<= 3, this.endian === "big") {
      for (var ge = 8; ge < this.padLength; ge++)
        le[ve++] = 0;
      le[ve++] = 0, le[ve++] = 0, le[ve++] = 0, le[ve++] = 0, le[ve++] = ae >>> 24 & 255, le[ve++] = ae >>> 16 & 255, le[ve++] = ae >>> 8 & 255, le[ve++] = ae & 255;
    } else
      for (le[ve++] = ae & 255, le[ve++] = ae >>> 8 & 255, le[ve++] = ae >>> 16 & 255, le[ve++] = ae >>> 24 & 255, le[ve++] = 0, le[ve++] = 0, le[ve++] = 0, le[ve++] = 0, ge = 8; ge < this.padLength; ge++)
        le[ve++] = 0;
    return le;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var B = requireUtils(), z = B.rotr32;
  function Y(oe, Ee, Ce, Pe) {
    if (oe === 0)
      return ne(Ee, Ce, Pe);
    if (oe === 1 || oe === 3)
      return ie(Ee, Ce, Pe);
    if (oe === 2)
      return ae(Ee, Ce, Pe);
  }
  common.ft_1 = Y;
  function ne(oe, Ee, Ce) {
    return oe & Ee ^ ~oe & Ce;
  }
  common.ch32 = ne;
  function ae(oe, Ee, Ce) {
    return oe & Ee ^ oe & Ce ^ Ee & Ce;
  }
  common.maj32 = ae;
  function ie(oe, Ee, Ce) {
    return oe ^ Ee ^ Ce;
  }
  common.p32 = ie;
  function se(oe) {
    return z(oe, 2) ^ z(oe, 13) ^ z(oe, 22);
  }
  common.s0_256 = se;
  function le(oe) {
    return z(oe, 6) ^ z(oe, 11) ^ z(oe, 25);
  }
  common.s1_256 = le;
  function ve(oe) {
    return z(oe, 7) ^ z(oe, 18) ^ oe >>> 3;
  }
  common.g0_256 = ve;
  function ge(oe) {
    return z(oe, 17) ^ z(oe, 19) ^ oe >>> 10;
  }
  return common.g1_256 = ge, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireCommon(), ne = B.rotl32, ae = B.sum32, ie = B.sum32_5, se = Y.ft_1, le = z.BlockHash, ve = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ge() {
    if (!(this instanceof ge))
      return new ge();
    le.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return B.inherits(ge, le), _1 = ge, ge.blockSize = 512, ge.outSize = 160, ge.hmacStrength = 80, ge.padLength = 64, ge.prototype._update = function(Ee, Ce) {
    for (var Pe = this.W, Ve = 0; Ve < 16; Ve++)
      Pe[Ve] = Ee[Ce + Ve];
    for (; Ve < Pe.length; Ve++)
      Pe[Ve] = ne(Pe[Ve - 3] ^ Pe[Ve - 8] ^ Pe[Ve - 14] ^ Pe[Ve - 16], 1);
    var ht = this.h[0], vt = this.h[1], Pt = this.h[2], _t = this.h[3], kt = this.h[4];
    for (Ve = 0; Ve < Pe.length; Ve++) {
      var Ot = ~~(Ve / 20), Ht = ie(ne(ht, 5), se(Ot, vt, Pt, _t), kt, Pe[Ve], ve[Ot]);
      kt = _t, _t = Pt, Pt = ne(vt, 30), vt = ht, ht = Ht;
    }
    this.h[0] = ae(this.h[0], ht), this.h[1] = ae(this.h[1], vt), this.h[2] = ae(this.h[2], Pt), this.h[3] = ae(this.h[3], _t), this.h[4] = ae(this.h[4], kt);
  }, ge.prototype._digest = function(Ee) {
    return Ee === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireCommon(), ne = requireMinimalisticAssert(), ae = B.sum32, ie = B.sum32_4, se = B.sum32_5, le = Y.ch32, ve = Y.maj32, ge = Y.s0_256, oe = Y.s1_256, Ee = Y.g0_256, Ce = Y.g1_256, Pe = z.BlockHash, Ve = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ht() {
    if (!(this instanceof ht))
      return new ht();
    Pe.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = Ve, this.W = new Array(64);
  }
  return B.inherits(ht, Pe), _256 = ht, ht.blockSize = 512, ht.outSize = 256, ht.hmacStrength = 192, ht.padLength = 64, ht.prototype._update = function(Pt, _t) {
    for (var kt = this.W, Ot = 0; Ot < 16; Ot++)
      kt[Ot] = Pt[_t + Ot];
    for (; Ot < kt.length; Ot++)
      kt[Ot] = ie(Ce(kt[Ot - 2]), kt[Ot - 7], Ee(kt[Ot - 15]), kt[Ot - 16]);
    var Ht = this.h[0], jt = this.h[1], Yt = this.h[2], Dt = this.h[3], Ct = this.h[4], Kt = this.h[5], Nt = this.h[6], Je = this.h[7];
    for (ne(this.k.length === kt.length), Ot = 0; Ot < kt.length; Ot++) {
      var Xe = se(Je, oe(Ct), le(Ct, Kt, Nt), this.k[Ot], kt[Ot]), Ke = ae(ge(Ht), ve(Ht, jt, Yt));
      Je = Nt, Nt = Kt, Kt = Ct, Ct = ae(Dt, Xe), Dt = Yt, Yt = jt, jt = Ht, Ht = ae(Xe, Ke);
    }
    this.h[0] = ae(this.h[0], Ht), this.h[1] = ae(this.h[1], jt), this.h[2] = ae(this.h[2], Yt), this.h[3] = ae(this.h[3], Dt), this.h[4] = ae(this.h[4], Ct), this.h[5] = ae(this.h[5], Kt), this.h[6] = ae(this.h[6], Nt), this.h[7] = ae(this.h[7], Je);
  }, ht.prototype._digest = function(Pt) {
    return Pt === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var B = requireUtils(), z = require_256();
  function Y() {
    if (!(this instanceof Y))
      return new Y();
    z.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return B.inherits(Y, z), _224 = Y, Y.blockSize = 512, Y.outSize = 224, Y.hmacStrength = 192, Y.padLength = 64, Y.prototype._digest = function(ae) {
    return ae === "hex" ? B.toHex32(this.h.slice(0, 7), "big") : B.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireMinimalisticAssert(), ne = B.rotr64_hi, ae = B.rotr64_lo, ie = B.shr64_hi, se = B.shr64_lo, le = B.sum64, ve = B.sum64_hi, ge = B.sum64_lo, oe = B.sum64_4_hi, Ee = B.sum64_4_lo, Ce = B.sum64_5_hi, Pe = B.sum64_5_lo, Ve = z.BlockHash, ht = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function vt() {
    if (!(this instanceof vt))
      return new vt();
    Ve.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = ht, this.W = new Array(160);
  }
  B.inherits(vt, Ve), _512 = vt, vt.blockSize = 1024, vt.outSize = 512, vt.hmacStrength = 192, vt.padLength = 128, vt.prototype._prepareBlock = function(Ke, Qe) {
    for (var bt = this.W, wt = 0; wt < 32; wt++)
      bt[wt] = Ke[Qe + wt];
    for (; wt < bt.length; wt += 2) {
      var xt = Nt(bt[wt - 4], bt[wt - 3]), Bt = Je(bt[wt - 4], bt[wt - 3]), $t = bt[wt - 14], qt = bt[wt - 13], Rt = Ct(bt[wt - 30], bt[wt - 29]), Lt = Kt(bt[wt - 30], bt[wt - 29]), tr = bt[wt - 32], sr = bt[wt - 31];
      bt[wt] = oe(
        xt,
        Bt,
        $t,
        qt,
        Rt,
        Lt,
        tr,
        sr
      ), bt[wt + 1] = Ee(
        xt,
        Bt,
        $t,
        qt,
        Rt,
        Lt,
        tr,
        sr
      );
    }
  }, vt.prototype._update = function(Ke, Qe) {
    this._prepareBlock(Ke, Qe);
    var bt = this.W, wt = this.h[0], xt = this.h[1], Bt = this.h[2], $t = this.h[3], qt = this.h[4], Rt = this.h[5], Lt = this.h[6], tr = this.h[7], sr = this.h[8], Zt = this.h[9], Wt = this.h[10], Gt = this.h[11], rr = this.h[12], or = this.h[13], Xt = this.h[14], zt = this.h[15];
    Y(this.k.length === bt.length);
    for (var ur = 0; ur < bt.length; ur += 2) {
      var pr = Xt, vr = zt, _r = Yt(sr, Zt), xr = Dt(sr, Zt), Tr = Pt(sr, Zt, Wt, Gt, rr), hr = _t(sr, Zt, Wt, Gt, rr, or), Wr = this.k[ur], $r = this.k[ur + 1], Ur = bt[ur], Gr = bt[ur + 1], Rr = Ce(
        pr,
        vr,
        _r,
        xr,
        Tr,
        hr,
        Wr,
        $r,
        Ur,
        Gr
      ), Hr = Pe(
        pr,
        vr,
        _r,
        xr,
        Tr,
        hr,
        Wr,
        $r,
        Ur,
        Gr
      );
      pr = Ht(wt, xt), vr = jt(wt, xt), _r = kt(wt, xt, Bt, $t, qt), xr = Ot(wt, xt, Bt, $t, qt, Rt);
      var Xr = ve(pr, vr, _r, xr), qr = ge(pr, vr, _r, xr);
      Xt = rr, zt = or, rr = Wt, or = Gt, Wt = sr, Gt = Zt, sr = ve(Lt, tr, Rr, Hr), Zt = ge(tr, tr, Rr, Hr), Lt = qt, tr = Rt, qt = Bt, Rt = $t, Bt = wt, $t = xt, wt = ve(Rr, Hr, Xr, qr), xt = ge(Rr, Hr, Xr, qr);
    }
    le(this.h, 0, wt, xt), le(this.h, 2, Bt, $t), le(this.h, 4, qt, Rt), le(this.h, 6, Lt, tr), le(this.h, 8, sr, Zt), le(this.h, 10, Wt, Gt), le(this.h, 12, rr, or), le(this.h, 14, Xt, zt);
  }, vt.prototype._digest = function(Ke) {
    return Ke === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  };
  function Pt(Xe, Ke, Qe, bt, wt) {
    var xt = Xe & Qe ^ ~Xe & wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function _t(Xe, Ke, Qe, bt, wt, xt) {
    var Bt = Ke & bt ^ ~Ke & xt;
    return Bt < 0 && (Bt += 4294967296), Bt;
  }
  function kt(Xe, Ke, Qe, bt, wt) {
    var xt = Xe & Qe ^ Xe & wt ^ Qe & wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Ot(Xe, Ke, Qe, bt, wt, xt) {
    var Bt = Ke & bt ^ Ke & xt ^ bt & xt;
    return Bt < 0 && (Bt += 4294967296), Bt;
  }
  function Ht(Xe, Ke) {
    var Qe = ne(Xe, Ke, 28), bt = ne(Ke, Xe, 2), wt = ne(Ke, Xe, 7), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function jt(Xe, Ke) {
    var Qe = ae(Xe, Ke, 28), bt = ae(Ke, Xe, 2), wt = ae(Ke, Xe, 7), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Yt(Xe, Ke) {
    var Qe = ne(Xe, Ke, 14), bt = ne(Xe, Ke, 18), wt = ne(Ke, Xe, 9), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Dt(Xe, Ke) {
    var Qe = ae(Xe, Ke, 14), bt = ae(Xe, Ke, 18), wt = ae(Ke, Xe, 9), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Ct(Xe, Ke) {
    var Qe = ne(Xe, Ke, 1), bt = ne(Xe, Ke, 8), wt = ie(Xe, Ke, 7), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Kt(Xe, Ke) {
    var Qe = ae(Xe, Ke, 1), bt = ae(Xe, Ke, 8), wt = se(Xe, Ke, 7), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Nt(Xe, Ke) {
    var Qe = ne(Xe, Ke, 19), bt = ne(Ke, Xe, 29), wt = ie(Xe, Ke, 6), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  function Je(Xe, Ke) {
    var Qe = ae(Xe, Ke, 19), bt = ae(Ke, Xe, 29), wt = se(Xe, Ke, 6), xt = Qe ^ bt ^ wt;
    return xt < 0 && (xt += 4294967296), xt;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var B = requireUtils(), z = require_512();
  function Y() {
    if (!(this instanceof Y))
      return new Y();
    z.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return B.inherits(Y, z), _384 = Y, Y.blockSize = 1024, Y.outSize = 384, Y.hmacStrength = 192, Y.padLength = 128, Y.prototype._digest = function(ae) {
    return ae === "hex" ? B.toHex32(this.h.slice(0, 12), "big") : B.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = B.rotl32, ne = B.sum32, ae = B.sum32_3, ie = B.sum32_4, se = z.BlockHash;
  function le() {
    if (!(this instanceof le))
      return new le();
    se.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  B.inherits(le, se), ripemd.ripemd160 = le, le.blockSize = 512, le.outSize = 160, le.hmacStrength = 192, le.padLength = 64, le.prototype._update = function(vt, Pt) {
    for (var _t = this.h[0], kt = this.h[1], Ot = this.h[2], Ht = this.h[3], jt = this.h[4], Yt = _t, Dt = kt, Ct = Ot, Kt = Ht, Nt = jt, Je = 0; Je < 80; Je++) {
      var Xe = ne(
        Y(
          ie(_t, ve(Je, kt, Ot, Ht), vt[Ee[Je] + Pt], ge(Je)),
          Pe[Je]
        ),
        jt
      );
      _t = jt, jt = Ht, Ht = Y(Ot, 10), Ot = kt, kt = Xe, Xe = ne(
        Y(
          ie(Yt, ve(79 - Je, Dt, Ct, Kt), vt[Ce[Je] + Pt], oe(Je)),
          Ve[Je]
        ),
        Nt
      ), Yt = Nt, Nt = Kt, Kt = Y(Ct, 10), Ct = Dt, Dt = Xe;
    }
    Xe = ae(this.h[1], Ot, Kt), this.h[1] = ae(this.h[2], Ht, Nt), this.h[2] = ae(this.h[3], jt, Yt), this.h[3] = ae(this.h[4], _t, Dt), this.h[4] = ae(this.h[0], kt, Ct), this.h[0] = Xe;
  }, le.prototype._digest = function(vt) {
    return vt === "hex" ? B.toHex32(this.h, "little") : B.split32(this.h, "little");
  };
  function ve(ht, vt, Pt, _t) {
    return ht <= 15 ? vt ^ Pt ^ _t : ht <= 31 ? vt & Pt | ~vt & _t : ht <= 47 ? (vt | ~Pt) ^ _t : ht <= 63 ? vt & _t | Pt & ~_t : vt ^ (Pt | ~_t);
  }
  function ge(ht) {
    return ht <= 15 ? 0 : ht <= 31 ? 1518500249 : ht <= 47 ? 1859775393 : ht <= 63 ? 2400959708 : 2840853838;
  }
  function oe(ht) {
    return ht <= 15 ? 1352829926 : ht <= 31 ? 1548603684 : ht <= 47 ? 1836072691 : ht <= 63 ? 2053994217 : 0;
  }
  var Ee = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Ce = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Pe = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], Ve = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var B = requireUtils(), z = requireMinimalisticAssert();
  function Y(ne, ae, ie) {
    if (!(this instanceof Y))
      return new Y(ne, ae, ie);
    this.Hash = ne, this.blockSize = ne.blockSize / 8, this.outSize = ne.outSize / 8, this.inner = null, this.outer = null, this._init(B.toArray(ae, ie));
  }
  return hmac = Y, Y.prototype._init = function(ae) {
    ae.length > this.blockSize && (ae = new this.Hash().update(ae).digest()), z(ae.length <= this.blockSize);
    for (var ie = ae.length; ie < this.blockSize; ie++)
      ae.push(0);
    for (ie = 0; ie < ae.length; ie++)
      ae[ie] ^= 54;
    for (this.inner = new this.Hash().update(ae), ie = 0; ie < ae.length; ie++)
      ae[ie] ^= 106;
    this.outer = new this.Hash().update(ae);
  }, Y.prototype.update = function(ae, ie) {
    return this.inner.update(ae, ie), this;
  }, Y.prototype.digest = function(ae) {
    return this.outer.update(this.inner.digest()), this.outer.digest(ae);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(B) {
    var z = B;
    z.utils = requireUtils(), z.common = requireCommon$1(), z.sha = requireSha(), z.ripemd = requireRipemd(), z.hmac = requireHmac(), z.sha1 = z.sha.sha1, z.sha256 = z.sha.sha256, z.sha224 = z.sha.sha224, z.sha384 = z.sha.sha384, z.sha512 = z.sha.sha512, z.ripemd160 = z.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(B) {
    var z = B, Y = requireHash(), ne = requireCurve(), ae = requireUtils$1(), ie = ae.assert;
    function se(ge) {
      ge.type === "short" ? this.curve = new ne.short(ge) : ge.type === "edwards" ? this.curve = new ne.edwards(ge) : this.curve = new ne.mont(ge), this.g = this.curve.g, this.n = this.curve.n, this.hash = ge.hash, ie(this.g.validate(), "Invalid curve"), ie(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    z.PresetCurve = se;
    function le(ge, oe) {
      Object.defineProperty(z, ge, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var Ee = new se(oe);
          return Object.defineProperty(z, ge, {
            configurable: !0,
            enumerable: !0,
            value: Ee
          }), Ee;
        }
      });
    }
    le("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), le("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), le("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), le("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: Y.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), le("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: Y.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), le("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), le("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ve;
    try {
      ve = requireSecp256k1();
    } catch {
      ve = void 0;
    }
    le("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Y.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ve
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var B = requireHash(), z = requireUtils$2(), Y = requireMinimalisticAssert();
  function ne(ae) {
    if (!(this instanceof ne))
      return new ne(ae);
    this.hash = ae.hash, this.predResist = !!ae.predResist, this.outLen = this.hash.outSize, this.minEntropy = ae.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var ie = z.toArray(ae.entropy, ae.entropyEnc || "hex"), se = z.toArray(ae.nonce, ae.nonceEnc || "hex"), le = z.toArray(ae.pers, ae.persEnc || "hex");
    Y(
      ie.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(ie, se, le);
  }
  return hmacDrbg = ne, ne.prototype._init = function(ie, se, le) {
    var ve = ie.concat(se).concat(le);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ge = 0; ge < this.V.length; ge++)
      this.K[ge] = 0, this.V[ge] = 1;
    this._update(ve), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, ne.prototype._hmac = function() {
    return new B.hmac(this.hash, this.K);
  }, ne.prototype._update = function(ie) {
    var se = this._hmac().update(this.V).update([0]);
    ie && (se = se.update(ie)), this.K = se.digest(), this.V = this._hmac().update(this.V).digest(), ie && (this.K = this._hmac().update(this.V).update([1]).update(ie).digest(), this.V = this._hmac().update(this.V).digest());
  }, ne.prototype.reseed = function(ie, se, le, ve) {
    typeof se != "string" && (ve = le, le = se, se = null), ie = z.toArray(ie, se), le = z.toArray(le, ve), Y(
      ie.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(ie.concat(le || [])), this._reseed = 1;
  }, ne.prototype.generate = function(ie, se, le, ve) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof se != "string" && (ve = le, le = se, se = null), le && (le = z.toArray(le, ve || "hex"), this._update(le));
    for (var ge = []; ge.length < ie; )
      this.V = this._hmac().update(this.V).digest(), ge = ge.concat(this.V);
    var oe = ge.slice(0, ie);
    return this._update(le), this._reseed++, z.encode(oe, se);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.assert;
  function ne(ae, ie) {
    this.ec = ae, this.priv = null, this.pub = null, ie.priv && this._importPrivate(ie.priv, ie.privEnc), ie.pub && this._importPublic(ie.pub, ie.pubEnc);
  }
  return key$1 = ne, ne.fromPublic = function(ie, se, le) {
    return se instanceof ne ? se : new ne(ie, {
      pub: se,
      pubEnc: le
    });
  }, ne.fromPrivate = function(ie, se, le) {
    return se instanceof ne ? se : new ne(ie, {
      priv: se,
      privEnc: le
    });
  }, ne.prototype.validate = function() {
    var ie = this.getPublic();
    return ie.isInfinity() ? { result: !1, reason: "Invalid public key" } : ie.validate() ? ie.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, ne.prototype.getPublic = function(ie, se) {
    return typeof ie == "string" && (se = ie, ie = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), se ? this.pub.encode(se, ie) : this.pub;
  }, ne.prototype.getPrivate = function(ie) {
    return ie === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, ne.prototype._importPrivate = function(ie, se) {
    this.priv = new B(ie, se || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, ne.prototype._importPublic = function(ie, se) {
    if (ie.x || ie.y) {
      this.ec.curve.type === "mont" ? Y(ie.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Y(ie.x && ie.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ie.x, ie.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(ie, se);
  }, ne.prototype.derive = function(ie) {
    return ie.validate() || Y(ie.validate(), "public point not validated"), ie.mul(this.priv).getX();
  }, ne.prototype.sign = function(ie, se, le) {
    return this.ec.sign(ie, this, se, le);
  }, ne.prototype.verify = function(ie, se, le) {
    return this.ec.verify(ie, se, this, void 0, le);
  }, ne.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.assert;
  function ne(ve, ge) {
    if (ve instanceof ne)
      return ve;
    this._importDER(ve, ge) || (Y(ve.r && ve.s, "Signature without r or s"), this.r = new B(ve.r, 16), this.s = new B(ve.s, 16), ve.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ve.recoveryParam);
  }
  signature$1 = ne;
  function ae() {
    this.place = 0;
  }
  function ie(ve, ge) {
    var oe = ve[ge.place++];
    if (!(oe & 128))
      return oe;
    var Ee = oe & 15;
    if (Ee === 0 || Ee > 4 || ve[ge.place] === 0)
      return !1;
    for (var Ce = 0, Pe = 0, Ve = ge.place; Pe < Ee; Pe++, Ve++)
      Ce <<= 8, Ce |= ve[Ve], Ce >>>= 0;
    return Ce <= 127 ? !1 : (ge.place = Ve, Ce);
  }
  function se(ve) {
    for (var ge = 0, oe = ve.length - 1; !ve[ge] && !(ve[ge + 1] & 128) && ge < oe; )
      ge++;
    return ge === 0 ? ve : ve.slice(ge);
  }
  ne.prototype._importDER = function(ge, oe) {
    ge = z.toArray(ge, oe);
    var Ee = new ae();
    if (ge[Ee.place++] !== 48)
      return !1;
    var Ce = ie(ge, Ee);
    if (Ce === !1 || Ce + Ee.place !== ge.length || ge[Ee.place++] !== 2)
      return !1;
    var Pe = ie(ge, Ee);
    if (Pe === !1 || ge[Ee.place] & 128)
      return !1;
    var Ve = ge.slice(Ee.place, Pe + Ee.place);
    if (Ee.place += Pe, ge[Ee.place++] !== 2)
      return !1;
    var ht = ie(ge, Ee);
    if (ht === !1 || ge.length !== ht + Ee.place || ge[Ee.place] & 128)
      return !1;
    var vt = ge.slice(Ee.place, ht + Ee.place);
    if (Ve[0] === 0)
      if (Ve[1] & 128)
        Ve = Ve.slice(1);
      else
        return !1;
    if (vt[0] === 0)
      if (vt[1] & 128)
        vt = vt.slice(1);
      else
        return !1;
    return this.r = new B(Ve), this.s = new B(vt), this.recoveryParam = null, !0;
  };
  function le(ve, ge) {
    if (ge < 128) {
      ve.push(ge);
      return;
    }
    var oe = 1 + (Math.log(ge) / Math.LN2 >>> 3);
    for (ve.push(oe | 128); --oe; )
      ve.push(ge >>> (oe << 3) & 255);
    ve.push(ge);
  }
  return ne.prototype.toDER = function(ge) {
    var oe = this.r.toArray(), Ee = this.s.toArray();
    for (oe[0] & 128 && (oe = [0].concat(oe)), Ee[0] & 128 && (Ee = [0].concat(Ee)), oe = se(oe), Ee = se(Ee); !Ee[0] && !(Ee[1] & 128); )
      Ee = Ee.slice(1);
    var Ce = [2];
    le(Ce, oe.length), Ce = Ce.concat(oe), Ce.push(2), le(Ce, Ee.length);
    var Pe = Ce.concat(Ee), Ve = [48];
    return le(Ve, Pe.length), Ve = Ve.concat(Pe), z.encode(Ve, ge);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = requireBn$1(), z = requireHmacDrbg(), Y = requireUtils$1(), ne = requireCurves(), ae = requireBrorand(), ie = Y.assert, se = requireKey$1(), le = requireSignature$1();
  function ve(ge) {
    if (!(this instanceof ve))
      return new ve(ge);
    typeof ge == "string" && (ie(
      Object.prototype.hasOwnProperty.call(ne, ge),
      "Unknown curve " + ge
    ), ge = ne[ge]), ge instanceof ne.PresetCurve && (ge = { curve: ge }), this.curve = ge.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ge.curve.g, this.g.precompute(ge.curve.n.bitLength() + 1), this.hash = ge.hash || ge.curve.hash;
  }
  return ec = ve, ve.prototype.keyPair = function(oe) {
    return new se(this, oe);
  }, ve.prototype.keyFromPrivate = function(oe, Ee) {
    return se.fromPrivate(this, oe, Ee);
  }, ve.prototype.keyFromPublic = function(oe, Ee) {
    return se.fromPublic(this, oe, Ee);
  }, ve.prototype.genKeyPair = function(oe) {
    oe || (oe = {});
    for (var Ee = new z({
      hash: this.hash,
      pers: oe.pers,
      persEnc: oe.persEnc || "utf8",
      entropy: oe.entropy || ae(this.hash.hmacStrength),
      entropyEnc: oe.entropy && oe.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Ce = this.n.byteLength(), Pe = this.n.sub(new B(2)); ; ) {
      var Ve = new B(Ee.generate(Ce));
      if (!(Ve.cmp(Pe) > 0))
        return Ve.iaddn(1), this.keyFromPrivate(Ve);
    }
  }, ve.prototype._truncateToN = function(oe, Ee, Ce) {
    var Pe;
    if (B.isBN(oe) || typeof oe == "number")
      oe = new B(oe, 16), Pe = oe.byteLength();
    else if (typeof oe == "object")
      Pe = oe.length, oe = new B(oe, 16);
    else {
      var Ve = oe.toString();
      Pe = Ve.length + 1 >>> 1, oe = new B(Ve, 16);
    }
    typeof Ce != "number" && (Ce = Pe * 8);
    var ht = Ce - this.n.bitLength();
    return ht > 0 && (oe = oe.ushrn(ht)), !Ee && oe.cmp(this.n) >= 0 ? oe.sub(this.n) : oe;
  }, ve.prototype.sign = function(oe, Ee, Ce, Pe) {
    if (typeof Ce == "object" && (Pe = Ce, Ce = null), Pe || (Pe = {}), typeof oe != "string" && typeof oe != "number" && !B.isBN(oe)) {
      ie(
        typeof oe == "object" && oe && typeof oe.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), ie(oe.length >>> 0 === oe.length);
      for (var Ve = 0; Ve < oe.length; Ve++) ie((oe[Ve] & 255) === oe[Ve]);
    }
    Ee = this.keyFromPrivate(Ee, Ce), oe = this._truncateToN(oe, !1, Pe.msgBitLength), ie(!oe.isNeg(), "Can not sign a negative message");
    var ht = this.n.byteLength(), vt = Ee.getPrivate().toArray("be", ht), Pt = oe.toArray("be", ht);
    ie(new B(Pt).eq(oe), "Can not sign message");
    for (var _t = new z({
      hash: this.hash,
      entropy: vt,
      nonce: Pt,
      pers: Pe.pers,
      persEnc: Pe.persEnc || "utf8"
    }), kt = this.n.sub(new B(1)), Ot = 0; ; Ot++) {
      var Ht = Pe.k ? Pe.k(Ot) : new B(_t.generate(this.n.byteLength()));
      if (Ht = this._truncateToN(Ht, !0), !(Ht.cmpn(1) <= 0 || Ht.cmp(kt) >= 0)) {
        var jt = this.g.mul(Ht);
        if (!jt.isInfinity()) {
          var Yt = jt.getX(), Dt = Yt.umod(this.n);
          if (Dt.cmpn(0) !== 0) {
            var Ct = Ht.invm(this.n).mul(Dt.mul(Ee.getPrivate()).iadd(oe));
            if (Ct = Ct.umod(this.n), Ct.cmpn(0) !== 0) {
              var Kt = (jt.getY().isOdd() ? 1 : 0) | (Yt.cmp(Dt) !== 0 ? 2 : 0);
              return Pe.canonical && Ct.cmp(this.nh) > 0 && (Ct = this.n.sub(Ct), Kt ^= 1), new le({ r: Dt, s: Ct, recoveryParam: Kt });
            }
          }
        }
      }
    }
  }, ve.prototype.verify = function(oe, Ee, Ce, Pe, Ve) {
    Ve || (Ve = {}), oe = this._truncateToN(oe, !1, Ve.msgBitLength), Ce = this.keyFromPublic(Ce, Pe), Ee = new le(Ee, "hex");
    var ht = Ee.r, vt = Ee.s;
    if (ht.cmpn(1) < 0 || ht.cmp(this.n) >= 0 || vt.cmpn(1) < 0 || vt.cmp(this.n) >= 0)
      return !1;
    var Pt = vt.invm(this.n), _t = Pt.mul(oe).umod(this.n), kt = Pt.mul(ht).umod(this.n), Ot;
    return this.curve._maxwellTrick ? (Ot = this.g.jmulAdd(_t, Ce.getPublic(), kt), Ot.isInfinity() ? !1 : Ot.eqXToP(ht)) : (Ot = this.g.mulAdd(_t, Ce.getPublic(), kt), Ot.isInfinity() ? !1 : Ot.getX().umod(this.n).cmp(ht) === 0);
  }, ve.prototype.recoverPubKey = function(ge, oe, Ee, Ce) {
    ie((3 & Ee) === Ee, "The recovery param is more than two bits"), oe = new le(oe, Ce);
    var Pe = this.n, Ve = new B(ge), ht = oe.r, vt = oe.s, Pt = Ee & 1, _t = Ee >> 1;
    if (ht.cmp(this.curve.p.umod(this.curve.n)) >= 0 && _t)
      throw new Error("Unable to find sencond key candinate");
    _t ? ht = this.curve.pointFromX(ht.add(this.curve.n), Pt) : ht = this.curve.pointFromX(ht, Pt);
    var kt = oe.r.invm(Pe), Ot = Pe.sub(Ve).mul(kt).umod(Pe), Ht = vt.mul(kt).umod(Pe);
    return this.g.mulAdd(Ot, ht, Ht);
  }, ve.prototype.getKeyRecoveryParam = function(ge, oe, Ee, Ce) {
    if (oe = new le(oe, Ce), oe.recoveryParam !== null)
      return oe.recoveryParam;
    for (var Pe = 0; Pe < 4; Pe++) {
      var Ve;
      try {
        Ve = this.recoverPubKey(ge, oe, Pe);
      } catch {
        continue;
      }
      if (Ve.eq(Ee))
        return Pe;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var B = requireUtils$1(), z = B.assert, Y = B.parseBytes, ne = B.cachedProperty;
  function ae(ie, se) {
    this.eddsa = ie, this._secret = Y(se.secret), ie.isPoint(se.pub) ? this._pub = se.pub : this._pubBytes = Y(se.pub);
  }
  return ae.fromPublic = function(se, le) {
    return le instanceof ae ? le : new ae(se, { pub: le });
  }, ae.fromSecret = function(se, le) {
    return le instanceof ae ? le : new ae(se, { secret: le });
  }, ae.prototype.secret = function() {
    return this._secret;
  }, ne(ae, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), ne(ae, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), ne(ae, "privBytes", function() {
    var se = this.eddsa, le = this.hash(), ve = se.encodingLength - 1, ge = le.slice(0, se.encodingLength);
    return ge[0] &= 248, ge[ve] &= 127, ge[ve] |= 64, ge;
  }), ne(ae, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), ne(ae, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), ne(ae, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), ae.prototype.sign = function(se) {
    return z(this._secret, "KeyPair can only verify"), this.eddsa.sign(se, this);
  }, ae.prototype.verify = function(se, le) {
    return this.eddsa.verify(se, le, this);
  }, ae.prototype.getSecret = function(se) {
    return z(this._secret, "KeyPair is public only"), B.encode(this.secret(), se);
  }, ae.prototype.getPublic = function(se) {
    return B.encode(this.pubBytes(), se);
  }, key = ae, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.assert, ne = z.cachedProperty, ae = z.parseBytes;
  function ie(se, le) {
    this.eddsa = se, typeof le != "object" && (le = ae(le)), Array.isArray(le) && (Y(le.length === se.encodingLength * 2, "Signature has invalid size"), le = {
      R: le.slice(0, se.encodingLength),
      S: le.slice(se.encodingLength)
    }), Y(le.R && le.S, "Signature without R or S"), se.isPoint(le.R) && (this._R = le.R), le.S instanceof B && (this._S = le.S), this._Rencoded = Array.isArray(le.R) ? le.R : le.Rencoded, this._Sencoded = Array.isArray(le.S) ? le.S : le.Sencoded;
  }
  return ne(ie, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), ne(ie, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), ne(ie, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), ne(ie, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), ie.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, ie.prototype.toHex = function() {
    return z.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = ie, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var B = requireHash(), z = requireCurves(), Y = requireUtils$1(), ne = Y.assert, ae = Y.parseBytes, ie = requireKey(), se = requireSignature();
  function le(ve) {
    if (ne(ve === "ed25519", "only tested with ed25519 so far"), !(this instanceof le))
      return new le(ve);
    ve = z[ve].curve, this.curve = ve, this.g = ve.g, this.g.precompute(ve.n.bitLength() + 1), this.pointClass = ve.point().constructor, this.encodingLength = Math.ceil(ve.n.bitLength() / 8), this.hash = B.sha512;
  }
  return eddsa = le, le.prototype.sign = function(ge, oe) {
    ge = ae(ge);
    var Ee = this.keyFromSecret(oe), Ce = this.hashInt(Ee.messagePrefix(), ge), Pe = this.g.mul(Ce), Ve = this.encodePoint(Pe), ht = this.hashInt(Ve, Ee.pubBytes(), ge).mul(Ee.priv()), vt = Ce.add(ht).umod(this.curve.n);
    return this.makeSignature({ R: Pe, S: vt, Rencoded: Ve });
  }, le.prototype.verify = function(ge, oe, Ee) {
    if (ge = ae(ge), oe = this.makeSignature(oe), oe.S().gte(oe.eddsa.curve.n) || oe.S().isNeg())
      return !1;
    var Ce = this.keyFromPublic(Ee), Pe = this.hashInt(oe.Rencoded(), Ce.pubBytes(), ge), Ve = this.g.mul(oe.S()), ht = oe.R().add(Ce.pub().mul(Pe));
    return ht.eq(Ve);
  }, le.prototype.hashInt = function() {
    for (var ge = this.hash(), oe = 0; oe < arguments.length; oe++)
      ge.update(arguments[oe]);
    return Y.intFromLE(ge.digest()).umod(this.curve.n);
  }, le.prototype.keyFromPublic = function(ge) {
    return ie.fromPublic(this, ge);
  }, le.prototype.keyFromSecret = function(ge) {
    return ie.fromSecret(this, ge);
  }, le.prototype.makeSignature = function(ge) {
    return ge instanceof se ? ge : new se(this, ge);
  }, le.prototype.encodePoint = function(ge) {
    var oe = ge.getY().toArray("le", this.encodingLength);
    return oe[this.encodingLength - 1] |= ge.getX().isOdd() ? 128 : 0, oe;
  }, le.prototype.decodePoint = function(ge) {
    ge = Y.parseBytes(ge);
    var oe = ge.length - 1, Ee = ge.slice(0, oe).concat(ge[oe] & -129), Ce = (ge[oe] & 128) !== 0, Pe = Y.intFromLE(Ee);
    return this.curve.pointFromY(Pe, Ce);
  }, le.prototype.encodeInt = function(ge) {
    return ge.toArray("le", this.encodingLength);
  }, le.prototype.decodeInt = function(ge) {
    return Y.intFromLE(ge);
  }, le.prototype.isPoint = function(ge) {
    return ge instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var z = B;
    z.version = require$$0.version, z.utils = requireUtils$1(), z.rand = requireBrorand(), z.curve = requireCurve(), z.curves = requireCurves(), z.ec = requireEc(), z.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, z) {
      if (B.indexOf) return B.indexOf(z);
      for (var Y = 0; Y < B.length; Y++)
        if (B[Y] === z) return Y;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var z = [];
      for (var Y in B) z.push(Y);
      return z;
    }, forEach = function(B, z) {
      if (B.forEach) return B.forEach(z);
      for (var Y = 0; Y < B.length; Y++)
        z(B[Y], Y, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, z, Y) {
          Object.defineProperty(B, z, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Y
          });
        };
      } catch {
        return function(z, Y, ne) {
          z[Y] = ne;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(z) {
      if (!(this instanceof Script)) return new Script(z);
      this.code = z;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var z = document.createElement("iframe");
      z.style || (z.style = {}), z.style.display = "none", document.body.appendChild(z);
      var Y = z.contentWindow, ne = Y.eval, ae = Y.execScript;
      !ne && ae && (ae.call(Y, "null"), ne = Y.eval), forEach(Object_keys(B), function(le) {
        Y[le] = B[le];
      }), forEach(globals, function(le) {
        B[le] && (Y[le] = B[le]);
      });
      var ie = Object_keys(Y), se = ne.call(Y, this.code);
      return forEach(Object_keys(Y), function(le) {
        (le in B || indexOf(ie, le) === -1) && (B[le] = Y[le]);
      }), forEach(globals, function(le) {
        le in B || defineProp(B, le, Y[le]);
      }), document.body.removeChild(z), se;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var z = Script.createContext(B), Y = this.runInContext(z);
      return B && forEach(Object_keys(z), function(ne) {
        B[ne] = z[ne];
      }), Y;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(z) {
        var Y = Script(z);
        return Y[B].apply(Y, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var z = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(Y) {
        z[Y] = B[Y];
      }), z;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var z = requireAsn1$1(), Y = requireInherits_browser(), ne = B;
    ne.define = function(se, le) {
      return new ae(se, le);
    };
    function ae(ie, se) {
      this.name = ie, this.body = se, this.decoders = {}, this.encoders = {};
    }
    ae.prototype._createNamed = function(se) {
      var le;
      try {
        le = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        le = function(ge) {
          this._initNamed(ge);
        };
      }
      return Y(le, se), le.prototype._initNamed = function(ge) {
        se.call(this, ge);
      }, new le(this);
    }, ae.prototype._getDecoder = function(se) {
      return se = se || "der", this.decoders.hasOwnProperty(se) || (this.decoders[se] = this._createNamed(z.decoders[se])), this.decoders[se];
    }, ae.prototype.decode = function(se, le, ve) {
      return this._getDecoder(le).decode(se, ve);
    }, ae.prototype._getEncoder = function(se) {
      return se = se || "der", this.encoders.hasOwnProperty(se) || (this.encoders[se] = this._createNamed(z.encoders[se])), this.encoders[se];
    }, ae.prototype.encode = function(se, le, ve) {
      return this._getEncoder(le).encode(se, ve);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var B = requireInherits_browser();
  function z(ne) {
    this._reporterState = {
      obj: null,
      path: [],
      options: ne || {},
      errors: []
    };
  }
  reporter.Reporter = z, z.prototype.isError = function(ae) {
    return ae instanceof Y;
  }, z.prototype.save = function() {
    var ae = this._reporterState;
    return { obj: ae.obj, pathLen: ae.path.length };
  }, z.prototype.restore = function(ae) {
    var ie = this._reporterState;
    ie.obj = ae.obj, ie.path = ie.path.slice(0, ae.pathLen);
  }, z.prototype.enterKey = function(ae) {
    return this._reporterState.path.push(ae);
  }, z.prototype.exitKey = function(ae) {
    var ie = this._reporterState;
    ie.path = ie.path.slice(0, ae - 1);
  }, z.prototype.leaveKey = function(ae, ie, se) {
    var le = this._reporterState;
    this.exitKey(ae), le.obj !== null && (le.obj[ie] = se);
  }, z.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, z.prototype.enterObject = function() {
    var ae = this._reporterState, ie = ae.obj;
    return ae.obj = {}, ie;
  }, z.prototype.leaveObject = function(ae) {
    var ie = this._reporterState, se = ie.obj;
    return ie.obj = ae, se;
  }, z.prototype.error = function(ae) {
    var ie, se = this._reporterState, le = ae instanceof Y;
    if (le ? ie = ae : ie = new Y(se.path.map(function(ve) {
      return "[" + JSON.stringify(ve) + "]";
    }).join(""), ae.message || ae, ae.stack), !se.options.partial)
      throw ie;
    return le || se.errors.push(ie), ie;
  }, z.prototype.wrapResult = function(ae) {
    var ie = this._reporterState;
    return ie.options.partial ? {
      result: this.isError(ae) ? null : ae,
      errors: ie.errors
    } : ae;
  };
  function Y(ne, ae) {
    this.path = ne, this.rethrow(ae);
  }
  return B(Y, Error), Y.prototype.rethrow = function(ae) {
    if (this.message = ae + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Y), !this.stack)
      try {
        throw new Error(this.message);
      } catch (ie) {
        this.stack = ie.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = requireInherits_browser(), z = requireBase().Reporter, Y = require$$0$1.Buffer;
  function ne(ie, se) {
    if (z.call(this, se), !Y.isBuffer(ie)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = ie, this.offset = 0, this.length = ie.length;
  }
  B(ne, z), buffer.DecoderBuffer = ne, ne.prototype.save = function() {
    return { offset: this.offset, reporter: z.prototype.save.call(this) };
  }, ne.prototype.restore = function(se) {
    var le = new ne(this.base);
    return le.offset = se.offset, le.length = this.offset, this.offset = se.offset, z.prototype.restore.call(this, se.reporter), le;
  }, ne.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, ne.prototype.readUInt8 = function(se) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(se || "DecoderBuffer overrun");
  }, ne.prototype.skip = function(se, le) {
    if (!(this.offset + se <= this.length))
      return this.error(le || "DecoderBuffer overrun");
    var ve = new ne(this.base);
    return ve._reporterState = this._reporterState, ve.offset = this.offset, ve.length = this.offset + se, this.offset += se, ve;
  }, ne.prototype.raw = function(se) {
    return this.base.slice(se ? se.offset : this.offset, this.length);
  };
  function ae(ie, se) {
    if (Array.isArray(ie))
      this.length = 0, this.value = ie.map(function(le) {
        return le instanceof ae || (le = new ae(le, se)), this.length += le.length, le;
      }, this);
    else if (typeof ie == "number") {
      if (!(0 <= ie && ie <= 255))
        return se.error("non-byte EncoderBuffer value");
      this.value = ie, this.length = 1;
    } else if (typeof ie == "string")
      this.value = ie, this.length = Y.byteLength(ie);
    else if (Y.isBuffer(ie))
      this.value = ie, this.length = ie.length;
    else
      return se.error("Unsupported type: " + typeof ie);
  }
  return buffer.EncoderBuffer = ae, ae.prototype.join = function(se, le) {
    return se || (se = new Y(this.length)), le || (le = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ve) {
      ve.join(se, le), le += ve.length;
    }) : (typeof this.value == "number" ? se[le] = this.value : typeof this.value == "string" ? se.write(this.value, le) : Y.isBuffer(this.value) && this.value.copy(se, le), le += this.length)), se;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, z = requireBase().EncoderBuffer, Y = requireBase().DecoderBuffer, ne = requireMinimalisticAssert(), ae = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], ie = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(ae), se = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function le(ge, oe) {
    var Ee = {};
    this._baseState = Ee, Ee.enc = ge, Ee.parent = oe || null, Ee.children = null, Ee.tag = null, Ee.args = null, Ee.reverseArgs = null, Ee.choice = null, Ee.optional = !1, Ee.any = !1, Ee.obj = !1, Ee.use = null, Ee.useDecoder = null, Ee.key = null, Ee.default = null, Ee.explicit = null, Ee.implicit = null, Ee.contains = null, Ee.parent || (Ee.children = [], this._wrap());
  }
  node = le;
  var ve = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return le.prototype.clone = function() {
    var oe = this._baseState, Ee = {};
    ve.forEach(function(Pe) {
      Ee[Pe] = oe[Pe];
    });
    var Ce = new this.constructor(Ee.parent);
    return Ce._baseState = Ee, Ce;
  }, le.prototype._wrap = function() {
    var oe = this._baseState;
    ie.forEach(function(Ee) {
      this[Ee] = function() {
        var Pe = new this.constructor(this);
        return oe.children.push(Pe), Pe[Ee].apply(Pe, arguments);
      };
    }, this);
  }, le.prototype._init = function(oe) {
    var Ee = this._baseState;
    ne(Ee.parent === null), oe.call(this), Ee.children = Ee.children.filter(function(Ce) {
      return Ce._baseState.parent === this;
    }, this), ne.equal(Ee.children.length, 1, "Root node can have only one child");
  }, le.prototype._useArgs = function(oe) {
    var Ee = this._baseState, Ce = oe.filter(function(Pe) {
      return Pe instanceof this.constructor;
    }, this);
    oe = oe.filter(function(Pe) {
      return !(Pe instanceof this.constructor);
    }, this), Ce.length !== 0 && (ne(Ee.children === null), Ee.children = Ce, Ce.forEach(function(Pe) {
      Pe._baseState.parent = this;
    }, this)), oe.length !== 0 && (ne(Ee.args === null), Ee.args = oe, Ee.reverseArgs = oe.map(function(Pe) {
      if (typeof Pe != "object" || Pe.constructor !== Object)
        return Pe;
      var Ve = {};
      return Object.keys(Pe).forEach(function(ht) {
        ht == (ht | 0) && (ht |= 0);
        var vt = Pe[ht];
        Ve[vt] = ht;
      }), Ve;
    }));
  }, se.forEach(function(ge) {
    le.prototype[ge] = function() {
      var Ee = this._baseState;
      throw new Error(ge + " not implemented for encoding: " + Ee.enc);
    };
  }), ae.forEach(function(ge) {
    le.prototype[ge] = function() {
      var Ee = this._baseState, Ce = Array.prototype.slice.call(arguments);
      return ne(Ee.tag === null), Ee.tag = ge, this._useArgs(Ce), this;
    };
  }), le.prototype.use = function(oe) {
    ne(oe);
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.use = oe, this;
  }, le.prototype.optional = function() {
    var oe = this._baseState;
    return oe.optional = !0, this;
  }, le.prototype.def = function(oe) {
    var Ee = this._baseState;
    return ne(Ee.default === null), Ee.default = oe, Ee.optional = !0, this;
  }, le.prototype.explicit = function(oe) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.explicit = oe, this;
  }, le.prototype.implicit = function(oe) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.implicit = oe, this;
  }, le.prototype.obj = function() {
    var oe = this._baseState, Ee = Array.prototype.slice.call(arguments);
    return oe.obj = !0, Ee.length !== 0 && this._useArgs(Ee), this;
  }, le.prototype.key = function(oe) {
    var Ee = this._baseState;
    return ne(Ee.key === null), Ee.key = oe, this;
  }, le.prototype.any = function() {
    var oe = this._baseState;
    return oe.any = !0, this;
  }, le.prototype.choice = function(oe) {
    var Ee = this._baseState;
    return ne(Ee.choice === null), Ee.choice = oe, this._useArgs(Object.keys(oe).map(function(Ce) {
      return oe[Ce];
    })), this;
  }, le.prototype.contains = function(oe) {
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.contains = oe, this;
  }, le.prototype._decode = function(oe, Ee) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return oe.wrapResult(Ce.children[0]._decode(oe, Ee));
    var Pe = Ce.default, Ve = !0, ht = null;
    if (Ce.key !== null && (ht = oe.enterKey(Ce.key)), Ce.optional) {
      var vt = null;
      if (Ce.explicit !== null ? vt = Ce.explicit : Ce.implicit !== null ? vt = Ce.implicit : Ce.tag !== null && (vt = Ce.tag), vt === null && !Ce.any) {
        var Pt = oe.save();
        try {
          Ce.choice === null ? this._decodeGeneric(Ce.tag, oe, Ee) : this._decodeChoice(oe, Ee), Ve = !0;
        } catch {
          Ve = !1;
        }
        oe.restore(Pt);
      } else if (Ve = this._peekTag(oe, vt, Ce.any), oe.isError(Ve))
        return Ve;
    }
    var _t;
    if (Ce.obj && Ve && (_t = oe.enterObject()), Ve) {
      if (Ce.explicit !== null) {
        var kt = this._decodeTag(oe, Ce.explicit);
        if (oe.isError(kt))
          return kt;
        oe = kt;
      }
      var Ot = oe.offset;
      if (Ce.use === null && Ce.choice === null) {
        if (Ce.any)
          var Pt = oe.save();
        var Ht = this._decodeTag(
          oe,
          Ce.implicit !== null ? Ce.implicit : Ce.tag,
          Ce.any
        );
        if (oe.isError(Ht))
          return Ht;
        Ce.any ? Pe = oe.raw(Pt) : oe = Ht;
      }
      if (Ee && Ee.track && Ce.tag !== null && Ee.track(oe.path(), Ot, oe.length, "tagged"), Ee && Ee.track && Ce.tag !== null && Ee.track(oe.path(), oe.offset, oe.length, "content"), Ce.any ? Pe = Pe : Ce.choice === null ? Pe = this._decodeGeneric(Ce.tag, oe, Ee) : Pe = this._decodeChoice(oe, Ee), oe.isError(Pe))
        return Pe;
      if (!Ce.any && Ce.choice === null && Ce.children !== null && Ce.children.forEach(function(Dt) {
        Dt._decode(oe, Ee);
      }), Ce.contains && (Ce.tag === "octstr" || Ce.tag === "bitstr")) {
        var jt = new Y(Pe);
        Pe = this._getUse(Ce.contains, oe._reporterState.obj)._decode(jt, Ee);
      }
    }
    return Ce.obj && Ve && (Pe = oe.leaveObject(_t)), Ce.key !== null && (Pe !== null || Ve === !0) ? oe.leaveKey(ht, Ce.key, Pe) : ht !== null && oe.exitKey(ht), Pe;
  }, le.prototype._decodeGeneric = function(oe, Ee, Ce) {
    var Pe = this._baseState;
    return oe === "seq" || oe === "set" ? null : oe === "seqof" || oe === "setof" ? this._decodeList(Ee, oe, Pe.args[0], Ce) : /str$/.test(oe) ? this._decodeStr(Ee, oe, Ce) : oe === "objid" && Pe.args ? this._decodeObjid(Ee, Pe.args[0], Pe.args[1], Ce) : oe === "objid" ? this._decodeObjid(Ee, null, null, Ce) : oe === "gentime" || oe === "utctime" ? this._decodeTime(Ee, oe, Ce) : oe === "null_" ? this._decodeNull(Ee, Ce) : oe === "bool" ? this._decodeBool(Ee, Ce) : oe === "objDesc" ? this._decodeStr(Ee, oe, Ce) : oe === "int" || oe === "enum" ? this._decodeInt(Ee, Pe.args && Pe.args[0], Ce) : Pe.use !== null ? this._getUse(Pe.use, Ee._reporterState.obj)._decode(Ee, Ce) : Ee.error("unknown tag: " + oe);
  }, le.prototype._getUse = function(oe, Ee) {
    var Ce = this._baseState;
    return Ce.useDecoder = this._use(oe, Ee), ne(Ce.useDecoder._baseState.parent === null), Ce.useDecoder = Ce.useDecoder._baseState.children[0], Ce.implicit !== Ce.useDecoder._baseState.implicit && (Ce.useDecoder = Ce.useDecoder.clone(), Ce.useDecoder._baseState.implicit = Ce.implicit), Ce.useDecoder;
  }, le.prototype._decodeChoice = function(oe, Ee) {
    var Ce = this._baseState, Pe = null, Ve = !1;
    return Object.keys(Ce.choice).some(function(ht) {
      var vt = oe.save(), Pt = Ce.choice[ht];
      try {
        var _t = Pt._decode(oe, Ee);
        if (oe.isError(_t))
          return !1;
        Pe = { type: ht, value: _t }, Ve = !0;
      } catch {
        return oe.restore(vt), !1;
      }
      return !0;
    }, this), Ve ? Pe : oe.error("Choice not matched");
  }, le.prototype._createEncoderBuffer = function(oe) {
    return new z(oe, this.reporter);
  }, le.prototype._encode = function(oe, Ee, Ce) {
    var Pe = this._baseState;
    if (!(Pe.default !== null && Pe.default === oe)) {
      var Ve = this._encodeValue(oe, Ee, Ce);
      if (Ve !== void 0 && !this._skipDefault(Ve, Ee, Ce))
        return Ve;
    }
  }, le.prototype._encodeValue = function(oe, Ee, Ce) {
    var Pe = this._baseState;
    if (Pe.parent === null)
      return Pe.children[0]._encode(oe, Ee || new B());
    var Pt = null;
    if (this.reporter = Ee, Pe.optional && oe === void 0)
      if (Pe.default !== null)
        oe = Pe.default;
      else
        return;
    var Ve = null, ht = !1;
    if (Pe.any)
      Pt = this._createEncoderBuffer(oe);
    else if (Pe.choice)
      Pt = this._encodeChoice(oe, Ee);
    else if (Pe.contains)
      Ve = this._getUse(Pe.contains, Ce)._encode(oe, Ee), ht = !0;
    else if (Pe.children)
      Ve = Pe.children.map(function(Ot) {
        if (Ot._baseState.tag === "null_")
          return Ot._encode(null, Ee, oe);
        if (Ot._baseState.key === null)
          return Ee.error("Child should have a key");
        var Ht = Ee.enterKey(Ot._baseState.key);
        if (typeof oe != "object")
          return Ee.error("Child expected, but input is not object");
        var jt = Ot._encode(oe[Ot._baseState.key], Ee, oe);
        return Ee.leaveKey(Ht), jt;
      }, this).filter(function(Ot) {
        return Ot;
      }), Ve = this._createEncoderBuffer(Ve);
    else if (Pe.tag === "seqof" || Pe.tag === "setof") {
      if (!(Pe.args && Pe.args.length === 1))
        return Ee.error("Too many args for : " + Pe.tag);
      if (!Array.isArray(oe))
        return Ee.error("seqof/setof, but data is not Array");
      var vt = this.clone();
      vt._baseState.implicit = null, Ve = this._createEncoderBuffer(oe.map(function(Ot) {
        var Ht = this._baseState;
        return this._getUse(Ht.args[0], oe)._encode(Ot, Ee);
      }, vt));
    } else Pe.use !== null ? Pt = this._getUse(Pe.use, Ce)._encode(oe, Ee) : (Ve = this._encodePrimitive(Pe.tag, oe), ht = !0);
    var Pt;
    if (!Pe.any && Pe.choice === null) {
      var _t = Pe.implicit !== null ? Pe.implicit : Pe.tag, kt = Pe.implicit === null ? "universal" : "context";
      _t === null ? Pe.use === null && Ee.error("Tag could be omitted only for .use()") : Pe.use === null && (Pt = this._encodeComposite(_t, ht, kt, Ve));
    }
    return Pe.explicit !== null && (Pt = this._encodeComposite(Pe.explicit, !1, "context", Pt)), Pt;
  }, le.prototype._encodeChoice = function(oe, Ee) {
    var Ce = this._baseState, Pe = Ce.choice[oe.type];
    return Pe || ne(
      !1,
      oe.type + " not found in " + JSON.stringify(Object.keys(Ce.choice))
    ), Pe._encode(oe.value, Ee);
  }, le.prototype._encodePrimitive = function(oe, Ee) {
    var Ce = this._baseState;
    if (/str$/.test(oe))
      return this._encodeStr(Ee, oe);
    if (oe === "objid" && Ce.args)
      return this._encodeObjid(Ee, Ce.reverseArgs[0], Ce.args[1]);
    if (oe === "objid")
      return this._encodeObjid(Ee, null, null);
    if (oe === "gentime" || oe === "utctime")
      return this._encodeTime(Ee, oe);
    if (oe === "null_")
      return this._encodeNull();
    if (oe === "int" || oe === "enum")
      return this._encodeInt(Ee, Ce.args && Ce.reverseArgs[0]);
    if (oe === "bool")
      return this._encodeBool(Ee);
    if (oe === "objDesc")
      return this._encodeStr(Ee, oe);
    throw new Error("Unsupported tag: " + oe);
  }, le.prototype._isNumstr = function(oe) {
    return /^[0-9 ]*$/.test(oe);
  }, le.prototype._isPrintstr = function(oe) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(oe);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var z = B;
    z.Reporter = requireReporter().Reporter, z.DecoderBuffer = requireBuffer().DecoderBuffer, z.EncoderBuffer = requireBuffer().EncoderBuffer, z.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var z = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = z._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = z._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var z = B;
    z._reverse = function(ne) {
      var ae = {};
      return Object.keys(ne).forEach(function(ie) {
        (ie | 0) == ie && (ie = ie | 0);
        var se = ne[ie];
        ae[se] = ie;
      }), ae;
    }, z.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = requireInherits_browser(), z = requireAsn1$1(), Y = z.base, ne = z.bignum, ae = z.constants.der;
  function ie(ge) {
    this.enc = "der", this.name = ge.name, this.entity = ge, this.tree = new se(), this.tree._init(ge.body);
  }
  der_1$1 = ie, ie.prototype.decode = function(oe, Ee) {
    return oe instanceof Y.DecoderBuffer || (oe = new Y.DecoderBuffer(oe, Ee)), this.tree._decode(oe, Ee);
  };
  function se(ge) {
    Y.Node.call(this, "der", ge);
  }
  B(se, Y.Node), se.prototype._peekTag = function(oe, Ee, Ce) {
    if (oe.isEmpty())
      return !1;
    var Pe = oe.save(), Ve = le(oe, 'Failed to peek tag: "' + Ee + '"');
    return oe.isError(Ve) ? Ve : (oe.restore(Pe), Ve.tag === Ee || Ve.tagStr === Ee || Ve.tagStr + "of" === Ee || Ce);
  }, se.prototype._decodeTag = function(oe, Ee, Ce) {
    var Pe = le(
      oe,
      'Failed to decode tag of "' + Ee + '"'
    );
    if (oe.isError(Pe))
      return Pe;
    var Ve = ve(
      oe,
      Pe.primitive,
      'Failed to get length of "' + Ee + '"'
    );
    if (oe.isError(Ve))
      return Ve;
    if (!Ce && Pe.tag !== Ee && Pe.tagStr !== Ee && Pe.tagStr + "of" !== Ee)
      return oe.error('Failed to match tag: "' + Ee + '"');
    if (Pe.primitive || Ve !== null)
      return oe.skip(Ve, 'Failed to match body of: "' + Ee + '"');
    var ht = oe.save(), vt = this._skipUntilEnd(
      oe,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return oe.isError(vt) ? vt : (Ve = oe.offset - ht.offset, oe.restore(ht), oe.skip(Ve, 'Failed to match body of: "' + Ee + '"'));
  }, se.prototype._skipUntilEnd = function(oe, Ee) {
    for (; ; ) {
      var Ce = le(oe, Ee);
      if (oe.isError(Ce))
        return Ce;
      var Pe = ve(oe, Ce.primitive, Ee);
      if (oe.isError(Pe))
        return Pe;
      var Ve;
      if (Ce.primitive || Pe !== null ? Ve = oe.skip(Pe) : Ve = this._skipUntilEnd(oe, Ee), oe.isError(Ve))
        return Ve;
      if (Ce.tagStr === "end")
        break;
    }
  }, se.prototype._decodeList = function(oe, Ee, Ce, Pe) {
    for (var Ve = []; !oe.isEmpty(); ) {
      var ht = this._peekTag(oe, "end");
      if (oe.isError(ht))
        return ht;
      var vt = Ce.decode(oe, "der", Pe);
      if (oe.isError(vt) && ht)
        break;
      Ve.push(vt);
    }
    return Ve;
  }, se.prototype._decodeStr = function(oe, Ee) {
    if (Ee === "bitstr") {
      var Ce = oe.readUInt8();
      return oe.isError(Ce) ? Ce : { unused: Ce, data: oe.raw() };
    } else if (Ee === "bmpstr") {
      var Pe = oe.raw();
      if (Pe.length % 2 === 1)
        return oe.error("Decoding of string type: bmpstr length mismatch");
      for (var Ve = "", ht = 0; ht < Pe.length / 2; ht++)
        Ve += String.fromCharCode(Pe.readUInt16BE(ht * 2));
      return Ve;
    } else if (Ee === "numstr") {
      var vt = oe.raw().toString("ascii");
      return this._isNumstr(vt) ? vt : oe.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (Ee === "octstr")
        return oe.raw();
      if (Ee === "objDesc")
        return oe.raw();
      if (Ee === "printstr") {
        var Pt = oe.raw().toString("ascii");
        return this._isPrintstr(Pt) ? Pt : oe.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(Ee) ? oe.raw().toString() : oe.error("Decoding of string type: " + Ee + " unsupported");
    }
  }, se.prototype._decodeObjid = function(oe, Ee, Ce) {
    for (var Pe, Ve = [], ht = 0; !oe.isEmpty(); ) {
      var vt = oe.readUInt8();
      ht <<= 7, ht |= vt & 127, vt & 128 || (Ve.push(ht), ht = 0);
    }
    vt & 128 && Ve.push(ht);
    var Pt = Ve[0] / 40 | 0, _t = Ve[0] % 40;
    if (Ce ? Pe = Ve : Pe = [Pt, _t].concat(Ve.slice(1)), Ee) {
      var kt = Ee[Pe.join(" ")];
      kt === void 0 && (kt = Ee[Pe.join(".")]), kt !== void 0 && (Pe = kt);
    }
    return Pe;
  }, se.prototype._decodeTime = function(oe, Ee) {
    var Ce = oe.raw().toString();
    if (Ee === "gentime")
      var Pe = Ce.slice(0, 4) | 0, Ve = Ce.slice(4, 6) | 0, ht = Ce.slice(6, 8) | 0, vt = Ce.slice(8, 10) | 0, Pt = Ce.slice(10, 12) | 0, _t = Ce.slice(12, 14) | 0;
    else if (Ee === "utctime") {
      var Pe = Ce.slice(0, 2) | 0, Ve = Ce.slice(2, 4) | 0, ht = Ce.slice(4, 6) | 0, vt = Ce.slice(6, 8) | 0, Pt = Ce.slice(8, 10) | 0, _t = Ce.slice(10, 12) | 0;
      Pe < 70 ? Pe = 2e3 + Pe : Pe = 1900 + Pe;
    } else
      return oe.error("Decoding " + Ee + " time is not supported yet");
    return Date.UTC(Pe, Ve - 1, ht, vt, Pt, _t, 0);
  }, se.prototype._decodeNull = function(oe) {
    return null;
  }, se.prototype._decodeBool = function(oe) {
    var Ee = oe.readUInt8();
    return oe.isError(Ee) ? Ee : Ee !== 0;
  }, se.prototype._decodeInt = function(oe, Ee) {
    var Ce = oe.raw(), Pe = new ne(Ce);
    return Ee && (Pe = Ee[Pe.toString(10)] || Pe), Pe;
  }, se.prototype._use = function(oe, Ee) {
    return typeof oe == "function" && (oe = oe(Ee)), oe._getDecoder("der").tree;
  };
  function le(ge, oe) {
    var Ee = ge.readUInt8(oe);
    if (ge.isError(Ee))
      return Ee;
    var Ce = ae.tagClass[Ee >> 6], Pe = (Ee & 32) === 0;
    if ((Ee & 31) === 31) {
      var Ve = Ee;
      for (Ee = 0; (Ve & 128) === 128; ) {
        if (Ve = ge.readUInt8(oe), ge.isError(Ve))
          return Ve;
        Ee <<= 7, Ee |= Ve & 127;
      }
    } else
      Ee &= 31;
    var ht = ae.tag[Ee];
    return {
      cls: Ce,
      primitive: Pe,
      tag: Ee,
      tagStr: ht
    };
  }
  function ve(ge, oe, Ee) {
    var Ce = ge.readUInt8(Ee);
    if (ge.isError(Ce))
      return Ce;
    if (!oe && Ce === 128)
      return null;
    if (!(Ce & 128))
      return Ce;
    var Pe = Ce & 127;
    if (Pe > 4)
      return ge.error("length octect is too long");
    Ce = 0;
    for (var Ve = 0; Ve < Pe; Ve++) {
      Ce <<= 8;
      var ht = ge.readUInt8(Ee);
      if (ge.isError(ht))
        return ht;
      Ce |= ht;
    }
    return Ce;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = requireInherits_browser(), z = require$$0$1.Buffer, Y = requireDer$1();
  function ne(ae) {
    Y.call(this, ae), this.enc = "pem";
  }
  return B(ne, Y), pem$1 = ne, ne.prototype.decode = function(ie, se) {
    for (var le = ie.toString().split(/[\r\n]+/g), ve = se.label.toUpperCase(), ge = /^-----(BEGIN|END) ([^-]+)-----$/, oe = -1, Ee = -1, Ce = 0; Ce < le.length; Ce++) {
      var Pe = le[Ce].match(ge);
      if (Pe !== null && Pe[2] === ve)
        if (oe === -1) {
          if (Pe[1] !== "BEGIN")
            break;
          oe = Ce;
        } else {
          if (Pe[1] !== "END")
            break;
          Ee = Ce;
          break;
        }
    }
    if (oe === -1 || Ee === -1)
      throw new Error("PEM section not found for: " + ve);
    var Ve = le.slice(oe + 1, Ee).join("");
    Ve.replace(/[^a-z0-9\+\/=]+/gi, "");
    var ht = new z(Ve, "base64");
    return Y.prototype.decode.call(this, ht, se);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var z = B;
    z.der = requireDer$1(), z.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = requireInherits_browser(), z = require$$0$1.Buffer, Y = requireAsn1$1(), ne = Y.base, ae = Y.constants.der;
  function ie(ge) {
    this.enc = "der", this.name = ge.name, this.entity = ge, this.tree = new se(), this.tree._init(ge.body);
  }
  der_1 = ie, ie.prototype.encode = function(oe, Ee) {
    return this.tree._encode(oe, Ee).join();
  };
  function se(ge) {
    ne.Node.call(this, "der", ge);
  }
  B(se, ne.Node), se.prototype._encodeComposite = function(oe, Ee, Ce, Pe) {
    var Ve = ve(oe, Ee, Ce, this.reporter);
    if (Pe.length < 128) {
      var Pt = new z(2);
      return Pt[0] = Ve, Pt[1] = Pe.length, this._createEncoderBuffer([Pt, Pe]);
    }
    for (var ht = 1, vt = Pe.length; vt >= 256; vt >>= 8)
      ht++;
    var Pt = new z(2 + ht);
    Pt[0] = Ve, Pt[1] = 128 | ht;
    for (var vt = 1 + ht, _t = Pe.length; _t > 0; vt--, _t >>= 8)
      Pt[vt] = _t & 255;
    return this._createEncoderBuffer([Pt, Pe]);
  }, se.prototype._encodeStr = function(oe, Ee) {
    if (Ee === "bitstr")
      return this._createEncoderBuffer([oe.unused | 0, oe.data]);
    if (Ee === "bmpstr") {
      for (var Ce = new z(oe.length * 2), Pe = 0; Pe < oe.length; Pe++)
        Ce.writeUInt16BE(oe.charCodeAt(Pe), Pe * 2);
      return this._createEncoderBuffer(Ce);
    } else return Ee === "numstr" ? this._isNumstr(oe) ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : Ee === "printstr" ? this._isPrintstr(oe) ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(Ee) ? this._createEncoderBuffer(oe) : Ee === "objDesc" ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: " + Ee + " unsupported");
  }, se.prototype._encodeObjid = function(oe, Ee, Ce) {
    if (typeof oe == "string") {
      if (!Ee)
        return this.reporter.error("string objid given, but no values map found");
      if (!Ee.hasOwnProperty(oe))
        return this.reporter.error("objid not found in values map");
      oe = Ee[oe].split(/[\s\.]+/g);
      for (var Pe = 0; Pe < oe.length; Pe++)
        oe[Pe] |= 0;
    } else if (Array.isArray(oe)) {
      oe = oe.slice();
      for (var Pe = 0; Pe < oe.length; Pe++)
        oe[Pe] |= 0;
    }
    if (!Array.isArray(oe))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(oe));
    if (!Ce) {
      if (oe[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      oe.splice(0, 2, oe[0] * 40 + oe[1]);
    }
    for (var Ve = 0, Pe = 0; Pe < oe.length; Pe++) {
      var ht = oe[Pe];
      for (Ve++; ht >= 128; ht >>= 7)
        Ve++;
    }
    for (var vt = new z(Ve), Pt = vt.length - 1, Pe = oe.length - 1; Pe >= 0; Pe--) {
      var ht = oe[Pe];
      for (vt[Pt--] = ht & 127; (ht >>= 7) > 0; )
        vt[Pt--] = 128 | ht & 127;
    }
    return this._createEncoderBuffer(vt);
  };
  function le(ge) {
    return ge < 10 ? "0" + ge : ge;
  }
  se.prototype._encodeTime = function(oe, Ee) {
    var Ce, Pe = new Date(oe);
    return Ee === "gentime" ? Ce = [
      le(Pe.getFullYear()),
      le(Pe.getUTCMonth() + 1),
      le(Pe.getUTCDate()),
      le(Pe.getUTCHours()),
      le(Pe.getUTCMinutes()),
      le(Pe.getUTCSeconds()),
      "Z"
    ].join("") : Ee === "utctime" ? Ce = [
      le(Pe.getFullYear() % 100),
      le(Pe.getUTCMonth() + 1),
      le(Pe.getUTCDate()),
      le(Pe.getUTCHours()),
      le(Pe.getUTCMinutes()),
      le(Pe.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + Ee + " time is not supported yet"), this._encodeStr(Ce, "octstr");
  }, se.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, se.prototype._encodeInt = function(oe, Ee) {
    if (typeof oe == "string") {
      if (!Ee)
        return this.reporter.error("String int or enum given, but no values map");
      if (!Ee.hasOwnProperty(oe))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(oe));
      oe = Ee[oe];
    }
    if (typeof oe != "number" && !z.isBuffer(oe)) {
      var Ce = oe.toArray();
      !oe.sign && Ce[0] & 128 && Ce.unshift(0), oe = new z(Ce);
    }
    if (z.isBuffer(oe)) {
      var Pe = oe.length;
      oe.length === 0 && Pe++;
      var ht = new z(Pe);
      return oe.copy(ht), oe.length === 0 && (ht[0] = 0), this._createEncoderBuffer(ht);
    }
    if (oe < 128)
      return this._createEncoderBuffer(oe);
    if (oe < 256)
      return this._createEncoderBuffer([0, oe]);
    for (var Pe = 1, Ve = oe; Ve >= 256; Ve >>= 8)
      Pe++;
    for (var ht = new Array(Pe), Ve = ht.length - 1; Ve >= 0; Ve--)
      ht[Ve] = oe & 255, oe >>= 8;
    return ht[0] & 128 && ht.unshift(0), this._createEncoderBuffer(new z(ht));
  }, se.prototype._encodeBool = function(oe) {
    return this._createEncoderBuffer(oe ? 255 : 0);
  }, se.prototype._use = function(oe, Ee) {
    return typeof oe == "function" && (oe = oe(Ee)), oe._getEncoder("der").tree;
  }, se.prototype._skipDefault = function(oe, Ee, Ce) {
    var Pe = this._baseState, Ve;
    if (Pe.default === null)
      return !1;
    var ht = oe.join();
    if (Pe.defaultBuffer === void 0 && (Pe.defaultBuffer = this._encodeValue(Pe.default, Ee, Ce).join()), ht.length !== Pe.defaultBuffer.length)
      return !1;
    for (Ve = 0; Ve < ht.length; Ve++)
      if (ht[Ve] !== Pe.defaultBuffer[Ve])
        return !1;
    return !0;
  };
  function ve(ge, oe, Ee, Ce) {
    var Pe;
    if (ge === "seqof" ? ge = "seq" : ge === "setof" && (ge = "set"), ae.tagByName.hasOwnProperty(ge))
      Pe = ae.tagByName[ge];
    else if (typeof ge == "number" && (ge | 0) === ge)
      Pe = ge;
    else
      return Ce.error("Unknown tag: " + ge);
    return Pe >= 31 ? Ce.error("Multi-octet tag encoding unsupported") : (oe || (Pe |= 32), Pe |= ae.tagClassByName[Ee || "universal"] << 6, Pe);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = requireInherits_browser(), z = requireDer();
  function Y(ne) {
    z.call(this, ne), this.enc = "pem";
  }
  return B(Y, z), pem = Y, Y.prototype.encode = function(ae, ie) {
    for (var se = z.prototype.encode.call(this, ae), le = se.toString("base64"), ve = ["-----BEGIN " + ie.label + "-----"], ge = 0; ge < le.length; ge += 64)
      ve.push(le.slice(ge, ge + 64));
    return ve.push("-----END " + ie.label + "-----"), ve.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var z = B;
    z.der = requireDer(), z.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(B) {
    var z = B;
    z.bignum = requireBn$1(), z.define = requireApi().define, z.base = requireBase(), z.constants = requireConstants(), z.decoders = requireDecoders(), z.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var B = requireAsn1$1(), z = B.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Y = B.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), ne = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), ae = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(ne),
      this.key("subjectPublicKey").bitstr()
    );
  }), ie = B.define("RelativeDistinguishedName", function() {
    this.setof(Y);
  }), se = B.define("RDNSequence", function() {
    this.seqof(ie);
  }), le = B.define("Name", function() {
    this.choice({
      rdnSequence: this.use(se)
    });
  }), ve = B.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(z),
      this.key("notAfter").use(z)
    );
  }), ge = B.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), oe = B.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(ne),
      this.key("issuer").use(le),
      this.key("validity").use(ve),
      this.key("subject").use(le),
      this.key("subjectPublicKeyInfo").use(ae),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(ge).optional()
    );
  }), Ee = B.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(oe),
      this.key("signatureAlgorithm").use(ne),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = Ee, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var B = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var z = B.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = z;
  var Y = B.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = Y;
  var ne = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), ae = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(ne),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = ae;
  var ie = B.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(ne),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = ie;
  var se = B.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = se;
  var le = B.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = le, asn1$1.DSAparam = B.define("DSAparam", function() {
    this.int();
  });
  var ve = B.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), ge = B.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ve),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = ge, asn1$1.signature = B.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var B = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, z = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Y = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, ne = requireEvp_bytestokey(), ae = requireBrowser$6(), ie = safeBufferExports.Buffer;
  return fixProc = function(se, le) {
    var ve = se.toString(), ge = ve.match(B), oe;
    if (ge) {
      var Ce = "aes" + ge[1], Pe = ie.from(ge[2], "hex"), Ve = ie.from(ge[3].replace(/[\r\n]/g, ""), "base64"), ht = ne(le, Pe.slice(0, 8), parseInt(ge[1], 10)).key, vt = [], Pt = ae.createDecipheriv(Ce, ht, Pe);
      vt.push(Pt.update(Ve)), vt.push(Pt.final()), oe = ie.concat(vt);
    } else {
      var Ee = ve.match(Y);
      oe = ie.from(Ee[2].replace(/[\r\n]/g, ""), "base64");
    }
    var _t = ve.match(z)[1];
    return {
      tag: _t,
      data: oe
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var B = requireAsn1(), z = require$$1, Y = requireFixProc(), ne = requireBrowser$6(), ae = requireBrowser$7(), ie = safeBufferExports.Buffer;
  function se(ve, ge) {
    var oe = ve.algorithm.decrypt.kde.kdeparams.salt, Ee = parseInt(ve.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), Ce = z[ve.algorithm.decrypt.cipher.algo.join(".")], Pe = ve.algorithm.decrypt.cipher.iv, Ve = ve.subjectPrivateKey, ht = parseInt(Ce.split("-")[1], 10) / 8, vt = ae.pbkdf2Sync(ge, oe, Ee, ht, "sha1"), Pt = ne.createDecipheriv(Ce, vt, Pe), _t = [];
    return _t.push(Pt.update(Ve)), _t.push(Pt.final()), ie.concat(_t);
  }
  function le(ve) {
    var ge;
    typeof ve == "object" && !ie.isBuffer(ve) && (ge = ve.passphrase, ve = ve.key), typeof ve == "string" && (ve = ie.from(ve));
    var oe = Y(ve, ge), Ee = oe.tag, Ce = oe.data, Pe, Ve;
    switch (Ee) {
      case "CERTIFICATE":
        Ve = B.certificate.decode(Ce, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (Ve || (Ve = B.PublicKey.decode(Ce, "der")), Pe = Ve.algorithm.algorithm.join("."), Pe) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPublicKey.decode(Ve.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return Ve.subjectPrivateKey = Ve.subjectPublicKey, {
              type: "ec",
              data: Ve
            };
          case "1.2.840.10040.4.1":
            return Ve.algorithm.params.pub_key = B.DSAparam.decode(Ve.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: Ve.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Pe);
        }
      case "ENCRYPTED PRIVATE KEY":
        Ce = B.EncryptedPrivateKey.decode(Ce, "der"), Ce = se(Ce, ge);
      case "PRIVATE KEY":
        switch (Ve = B.PrivateKey.decode(Ce, "der"), Pe = Ve.algorithm.algorithm.join("."), Pe) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPrivateKey.decode(Ve.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: Ve.algorithm.curve,
              privateKey: B.ECPrivateKey.decode(Ve.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return Ve.algorithm.params.priv_key = B.DSAparam.decode(Ve.subjectPrivateKey, "der"), {
              type: "dsa",
              params: Ve.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Pe);
        }
      case "RSA PUBLIC KEY":
        return B.RSAPublicKey.decode(Ce, "der");
      case "RSA PRIVATE KEY":
        return B.RSAPrivateKey.decode(Ce, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: B.DSAPrivateKey.decode(Ce, "der")
        };
      case "EC PRIVATE KEY":
        return Ce = B.ECPrivateKey.decode(Ce, "der"), {
          curve: Ce.parameters.value,
          privateKey: Ce.privateKey
        };
      default:
        throw new Error("unknown key type " + Ee);
    }
  }
  return le.signature = B.signature, parseAsn1 = le, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports.Buffer, z = requireBrowser$8(), Y = requireBrowserifyRsa(), ne = requireElliptic().ec, ae = requireBn(), ie = requireParseAsn1(), se = require$$4, le = 1;
  function ve(Pt, _t, kt, Ot, Ht) {
    var jt = ie(_t);
    if (jt.curve) {
      if (Ot !== "ecdsa" && Ot !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ge(Pt, jt);
    } else if (jt.type === "dsa") {
      if (Ot !== "dsa")
        throw new Error("wrong private key type");
      return oe(Pt, jt, kt);
    }
    if (Ot !== "rsa" && Ot !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (_t.padding !== void 0 && _t.padding !== le)
      throw new Error("illegal or unsupported padding mode");
    Pt = B.concat([Ht, Pt]);
    for (var Yt = jt.modulus.byteLength(), Dt = [0, 1]; Pt.length + Dt.length + 1 < Yt; )
      Dt.push(255);
    Dt.push(0);
    for (var Ct = -1; ++Ct < Pt.length; )
      Dt.push(Pt[Ct]);
    var Kt = Y(Dt, jt);
    return Kt;
  }
  function ge(Pt, _t) {
    var kt = se[_t.curve.join(".")];
    if (!kt)
      throw new Error("unknown curve " + _t.curve.join("."));
    var Ot = new ne(kt), Ht = Ot.keyFromPrivate(_t.privateKey), jt = Ht.sign(Pt);
    return B.from(jt.toDER());
  }
  function oe(Pt, _t, kt) {
    for (var Ot = _t.params.priv_key, Ht = _t.params.p, jt = _t.params.q, Yt = _t.params.g, Dt = new ae(0), Ct, Kt = Pe(Pt, jt).mod(jt), Nt = !1, Je = Ce(Ot, jt, Pt, kt); Nt === !1; )
      Ct = ht(jt, Je, kt), Dt = vt(Yt, Ct, Ht, jt), Nt = Ct.invm(jt).imul(Kt.add(Ot.mul(Dt))).mod(jt), Nt.cmpn(0) === 0 && (Nt = !1, Dt = new ae(0));
    return Ee(Dt, Nt);
  }
  function Ee(Pt, _t) {
    Pt = Pt.toArray(), _t = _t.toArray(), Pt[0] & 128 && (Pt = [0].concat(Pt)), _t[0] & 128 && (_t = [0].concat(_t));
    var kt = Pt.length + _t.length + 4, Ot = [
      48,
      kt,
      2,
      Pt.length
    ];
    return Ot = Ot.concat(Pt, [2, _t.length], _t), B.from(Ot);
  }
  function Ce(Pt, _t, kt, Ot) {
    if (Pt = B.from(Pt.toArray()), Pt.length < _t.byteLength()) {
      var Ht = B.alloc(_t.byteLength() - Pt.length);
      Pt = B.concat([Ht, Pt]);
    }
    var jt = kt.length, Yt = Ve(kt, _t), Dt = B.alloc(jt);
    Dt.fill(1);
    var Ct = B.alloc(jt);
    return Ct = z(Ot, Ct).update(Dt).update(B.from([0])).update(Pt).update(Yt).digest(), Dt = z(Ot, Ct).update(Dt).digest(), Ct = z(Ot, Ct).update(Dt).update(B.from([1])).update(Pt).update(Yt).digest(), Dt = z(Ot, Ct).update(Dt).digest(), { k: Ct, v: Dt };
  }
  function Pe(Pt, _t) {
    var kt = new ae(Pt), Ot = (Pt.length << 3) - _t.bitLength();
    return Ot > 0 && kt.ishrn(Ot), kt;
  }
  function Ve(Pt, _t) {
    Pt = Pe(Pt, _t), Pt = Pt.mod(_t);
    var kt = B.from(Pt.toArray());
    if (kt.length < _t.byteLength()) {
      var Ot = B.alloc(_t.byteLength() - kt.length);
      kt = B.concat([Ot, kt]);
    }
    return kt;
  }
  function ht(Pt, _t, kt) {
    var Ot, Ht;
    do {
      for (Ot = B.alloc(0); Ot.length * 8 < Pt.bitLength(); )
        _t.v = z(kt, _t.k).update(_t.v).digest(), Ot = B.concat([Ot, _t.v]);
      Ht = Pe(Ot, Pt), _t.k = z(kt, _t.k).update(_t.v).update(B.from([0])).digest(), _t.v = z(kt, _t.k).update(_t.v).digest();
    } while (Ht.cmp(Pt) !== -1);
    return Ht;
  }
  function vt(Pt, _t, kt, Ot) {
    return Pt.toRed(ae.mont(kt)).redPow(_t).fromRed().mod(Ot);
  }
  return sign.exports = ve, sign.exports.getKey = Ce, sign.exports.makeKey = ht, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var B = safeBufferExports.Buffer, z = requireBn(), Y = requireElliptic().ec, ne = requireParseAsn1(), ae = require$$4;
  function ie(ge, oe, Ee, Ce, Pe) {
    var Ve = ne(Ee);
    if (Ve.type === "ec") {
      if (Ce !== "ecdsa" && Ce !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return se(ge, oe, Ve);
    } else if (Ve.type === "dsa") {
      if (Ce !== "dsa")
        throw new Error("wrong public key type");
      return le(ge, oe, Ve);
    }
    if (Ce !== "rsa" && Ce !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    oe = B.concat([Pe, oe]);
    for (var ht = Ve.modulus.byteLength(), vt = [1], Pt = 0; oe.length + vt.length + 2 < ht; )
      vt.push(255), Pt += 1;
    vt.push(0);
    for (var _t = -1; ++_t < oe.length; )
      vt.push(oe[_t]);
    vt = B.from(vt);
    var kt = z.mont(Ve.modulus);
    ge = new z(ge).toRed(kt), ge = ge.redPow(new z(Ve.publicExponent)), ge = B.from(ge.fromRed().toArray());
    var Ot = Pt < 8 ? 1 : 0;
    for (ht = Math.min(ge.length, vt.length), ge.length !== vt.length && (Ot = 1), _t = -1; ++_t < ht; )
      Ot |= ge[_t] ^ vt[_t];
    return Ot === 0;
  }
  function se(ge, oe, Ee) {
    var Ce = ae[Ee.data.algorithm.curve.join(".")];
    if (!Ce)
      throw new Error("unknown curve " + Ee.data.algorithm.curve.join("."));
    var Pe = new Y(Ce), Ve = Ee.data.subjectPrivateKey.data;
    return Pe.verify(oe, ge, Ve);
  }
  function le(ge, oe, Ee) {
    var Ce = Ee.data.p, Pe = Ee.data.q, Ve = Ee.data.g, ht = Ee.data.pub_key, vt = ne.signature.decode(ge, "der"), Pt = vt.s, _t = vt.r;
    ve(Pt, Pe), ve(_t, Pe);
    var kt = z.mont(Ce), Ot = Pt.invm(Pe), Ht = Ve.toRed(kt).redPow(new z(oe).mul(Ot).mod(Pe)).fromRed().mul(ht.toRed(kt).redPow(_t.mul(Ot).mod(Pe)).fromRed()).mod(Ce).mod(Pe);
    return Ht.cmp(_t) === 0;
  }
  function ve(ge, oe) {
    if (ge.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ge.cmp(oe) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = ie, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var B = safeBufferExports.Buffer, z = requireBrowser$9(), Y = requireReadableBrowser(), ne = requireInherits_browser(), ae = requireSign(), ie = requireVerify(), se = require$$6;
  Object.keys(se).forEach(function(Ee) {
    se[Ee].id = B.from(se[Ee].id, "hex"), se[Ee.toLowerCase()] = se[Ee];
  });
  function le(Ee) {
    Y.Writable.call(this);
    var Ce = se[Ee];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hashType = Ce.hash, this._hash = z(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  ne(le, Y.Writable), le.prototype._write = function(Ce, Pe, Ve) {
    this._hash.update(Ce), Ve();
  }, le.prototype.update = function(Ce, Pe) {
    return this._hash.update(typeof Ce == "string" ? B.from(Ce, Pe) : Ce), this;
  }, le.prototype.sign = function(Ce, Pe) {
    this.end();
    var Ve = this._hash.digest(), ht = ae(Ve, Ce, this._hashType, this._signType, this._tag);
    return Pe ? ht.toString(Pe) : ht;
  };
  function ve(Ee) {
    Y.Writable.call(this);
    var Ce = se[Ee];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hash = z(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  ne(ve, Y.Writable), ve.prototype._write = function(Ce, Pe, Ve) {
    this._hash.update(Ce), Ve();
  }, ve.prototype.update = function(Ce, Pe) {
    return this._hash.update(typeof Ce == "string" ? B.from(Ce, Pe) : Ce), this;
  }, ve.prototype.verify = function(Ce, Pe, Ve) {
    var ht = typeof Pe == "string" ? B.from(Pe, Ve) : Pe;
    this.end();
    var vt = this._hash.digest();
    return ie(ht, vt, Ce, this._signType, this._tag);
  };
  function ge(Ee) {
    return new le(Ee);
  }
  function oe(Ee) {
    return new ve(Ee);
  }
  return browser$3 = {
    Sign: ge,
    Verify: oe,
    createSign: ge,
    createVerify: oe
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var B = requireElliptic(), z = requireBn$1();
  browser$2 = function(se) {
    return new ne(se);
  };
  var Y = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Y.p224 = Y.secp224r1, Y.p256 = Y.secp256r1 = Y.prime256v1, Y.p192 = Y.secp192r1 = Y.prime192v1, Y.p384 = Y.secp384r1, Y.p521 = Y.secp521r1;
  function ne(ie) {
    this.curveType = Y[ie], this.curveType || (this.curveType = {
      name: ie
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  ne.prototype.generateKeys = function(ie, se) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(ie, se);
  }, ne.prototype.computeSecret = function(ie, se, le) {
    se = se || "utf8", Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, se));
    var ve = this.curve.keyFromPublic(ie).getPublic(), ge = ve.mul(this.keys.getPrivate()).getX();
    return ae(ge, le, this.curveType.byteLength);
  }, ne.prototype.getPublicKey = function(ie, se) {
    var le = this.keys.getPublic(se === "compressed", !0);
    return se === "hybrid" && (le[le.length - 1] % 2 ? le[0] = 7 : le[0] = 6), ae(le, ie);
  }, ne.prototype.getPrivateKey = function(ie) {
    return ae(this.keys.getPrivate(), ie);
  }, ne.prototype.setPublicKey = function(ie, se) {
    return se = se || "utf8", Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, se)), this.keys._importPublic(ie), this;
  }, ne.prototype.setPrivateKey = function(ie, se) {
    se = se || "utf8", Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, se));
    var le = new z(ie);
    return le = le.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(le), this;
  };
  function ae(ie, se, le) {
    Array.isArray(ie) || (ie = ie.toArray());
    var ve = new Buffer$1(ie);
    if (le && ve.length < le) {
      var ge = new Buffer$1(le - ve.length);
      ge.fill(0), ve = Buffer$1.concat([ge, ve]);
    }
    return se ? ve.toString(se) : ve;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var B = requireBrowser$9(), z = safeBufferExports.Buffer;
  mgf = function(ne, ae) {
    for (var ie = z.alloc(0), se = 0, le; ie.length < ae; )
      le = Y(se++), ie = z.concat([ie, B("sha1").update(ne).update(le).digest()]);
    return ie.slice(0, ae);
  };
  function Y(ne) {
    var ae = z.allocUnsafe(4);
    return ae.writeUInt32BE(ne, 0), ae;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(z, Y) {
    for (var ne = z.length, ae = -1; ++ae < ne; )
      z[ae] ^= Y[ae];
    return z;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var B = requireBn$1(), z = safeBufferExports.Buffer;
  function Y(ne, ae) {
    return z.from(ne.toRed(B.mont(ae.modulus)).redPow(new B(ae.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = Y, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var B = requireParseAsn1(), z = requireBrowser$b(), Y = requireBrowser$9(), ne = requireMgf(), ae = requireXor(), ie = requireBn$1(), se = requireWithPublic(), le = requireBrowserifyRsa(), ve = safeBufferExports.Buffer;
  publicEncrypt = function(Pe, Ve, ht) {
    var vt;
    Pe.padding ? vt = Pe.padding : ht ? vt = 1 : vt = 4;
    var Pt = B(Pe), _t;
    if (vt === 4)
      _t = ge(Pt, Ve);
    else if (vt === 1)
      _t = oe(Pt, Ve, ht);
    else if (vt === 3) {
      if (_t = new ie(Ve), _t.cmp(Pt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return ht ? le(_t, Pt) : se(_t, Pt);
  };
  function ge(Ce, Pe) {
    var Ve = Ce.modulus.byteLength(), ht = Pe.length, vt = Y("sha1").update(ve.alloc(0)).digest(), Pt = vt.length, _t = 2 * Pt;
    if (ht > Ve - _t - 2)
      throw new Error("message too long");
    var kt = ve.alloc(Ve - ht - _t - 2), Ot = Ve - Pt - 1, Ht = z(Pt), jt = ae(ve.concat([vt, kt, ve.alloc(1, 1), Pe], Ot), ne(Ht, Ot)), Yt = ae(Ht, ne(jt, Pt));
    return new ie(ve.concat([ve.alloc(1), Yt, jt], Ve));
  }
  function oe(Ce, Pe, Ve) {
    var ht = Pe.length, vt = Ce.modulus.byteLength();
    if (ht > vt - 11)
      throw new Error("message too long");
    var Pt;
    return Ve ? Pt = ve.alloc(vt - ht - 3, 255) : Pt = Ee(vt - ht - 3), new ie(ve.concat([ve.from([0, Ve ? 1 : 2]), Pt, ve.alloc(1), Pe], vt));
  }
  function Ee(Ce) {
    for (var Pe = ve.allocUnsafe(Ce), Ve = 0, ht = z(Ce * 2), vt = 0, Pt; Ve < Ce; )
      vt === ht.length && (ht = z(Ce * 2), vt = 0), Pt = ht[vt++], Pt && (Pe[Ve++] = Pt);
    return Pe;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var B = requireParseAsn1(), z = requireMgf(), Y = requireXor(), ne = requireBn$1(), ae = requireBrowserifyRsa(), ie = requireBrowser$9(), se = requireWithPublic(), le = safeBufferExports.Buffer;
  privateDecrypt = function(Ce, Pe, Ve) {
    var ht;
    Ce.padding ? ht = Ce.padding : Ve ? ht = 1 : ht = 4;
    var vt = B(Ce), Pt = vt.modulus.byteLength();
    if (Pe.length > Pt || new ne(Pe).cmp(vt.modulus) >= 0)
      throw new Error("decryption error");
    var _t;
    Ve ? _t = se(new ne(Pe), vt) : _t = ae(Pe, vt);
    var kt = le.alloc(Pt - _t.length);
    if (_t = le.concat([kt, _t], Pt), ht === 4)
      return ve(vt, _t);
    if (ht === 1)
      return ge(vt, _t, Ve);
    if (ht === 3)
      return _t;
    throw new Error("unknown padding");
  };
  function ve(Ee, Ce) {
    var Pe = Ee.modulus.byteLength(), Ve = ie("sha1").update(le.alloc(0)).digest(), ht = Ve.length;
    if (Ce[0] !== 0)
      throw new Error("decryption error");
    var vt = Ce.slice(1, ht + 1), Pt = Ce.slice(ht + 1), _t = Y(vt, z(Pt, ht)), kt = Y(Pt, z(_t, Pe - ht - 1));
    if (oe(Ve, kt.slice(0, ht)))
      throw new Error("decryption error");
    for (var Ot = ht; kt[Ot] === 0; )
      Ot++;
    if (kt[Ot++] !== 1)
      throw new Error("decryption error");
    return kt.slice(Ot);
  }
  function ge(Ee, Ce, Pe) {
    for (var Ve = Ce.slice(0, 2), ht = 2, vt = 0; Ce[ht++] !== 0; )
      if (ht >= Ce.length) {
        vt++;
        break;
      }
    var Pt = Ce.slice(2, ht - 1);
    if ((Ve.toString("hex") !== "0002" && !Pe || Ve.toString("hex") !== "0001" && Pe) && vt++, Pt.length < 8 && vt++, vt)
      throw new Error("decryption error");
    return Ce.slice(ht);
  }
  function oe(Ee, Ce) {
    Ee = le.from(Ee), Ce = le.from(Ce);
    var Pe = 0, Ve = Ee.length;
    Ee.length !== Ce.length && (Pe++, Ve = Math.min(Ee.length, Ce.length));
    for (var ht = -1; ++ht < Ve; )
      Pe += Ee[ht] ^ Ce[ht];
    return Pe;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(B) {
    B.publicEncrypt = requirePublicEncrypt(), B.privateDecrypt = requirePrivateDecrypt(), B.privateEncrypt = function(Y, ne) {
      return B.publicEncrypt(Y, ne, !0);
    }, B.publicDecrypt = function(Y, ne) {
      return B.privateDecrypt(Y, ne, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function B() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var z = safeBufferExports, Y = requireBrowser$b(), ne = z.Buffer, ae = z.kMaxLength, ie = commonjsGlobal.crypto || commonjsGlobal.msCrypto, se = Math.pow(2, 32) - 1;
  function le(Ce, Pe) {
    if (typeof Ce != "number" || Ce !== Ce)
      throw new TypeError("offset must be a number");
    if (Ce > se || Ce < 0)
      throw new TypeError("offset must be a uint32");
    if (Ce > ae || Ce > Pe)
      throw new RangeError("offset out of range");
  }
  function ve(Ce, Pe, Ve) {
    if (typeof Ce != "number" || Ce !== Ce)
      throw new TypeError("size must be a number");
    if (Ce > se || Ce < 0)
      throw new TypeError("size must be a uint32");
    if (Ce + Pe > Ve || Ce > ae)
      throw new RangeError("buffer too small");
  }
  ie && ie.getRandomValues || !process$1.browser ? (browser.randomFill = ge, browser.randomFillSync = Ee) : (browser.randomFill = B, browser.randomFillSync = B);
  function ge(Ce, Pe, Ve, ht) {
    if (!ne.isBuffer(Ce) && !(Ce instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Pe == "function")
      ht = Pe, Pe = 0, Ve = Ce.length;
    else if (typeof Ve == "function")
      ht = Ve, Ve = Ce.length - Pe;
    else if (typeof ht != "function")
      throw new TypeError('"cb" argument must be a function');
    return le(Pe, Ce.length), ve(Ve, Pe, Ce.length), oe(Ce, Pe, Ve, ht);
  }
  function oe(Ce, Pe, Ve, ht) {
    if (process$1.browser) {
      var vt = Ce.buffer, Pt = new Uint8Array(vt, Pe, Ve);
      if (ie.getRandomValues(Pt), ht) {
        process$1.nextTick(function() {
          ht(null, Ce);
        });
        return;
      }
      return Ce;
    }
    if (ht) {
      Y(Ve, function(kt, Ot) {
        if (kt)
          return ht(kt);
        Ot.copy(Ce, Pe), ht(null, Ce);
      });
      return;
    }
    var _t = Y(Ve);
    return _t.copy(Ce, Pe), Ce;
  }
  function Ee(Ce, Pe, Ve) {
    if (typeof Pe > "u" && (Pe = 0), !ne.isBuffer(Ce) && !(Ce instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return le(Pe, Ce.length), Ve === void 0 && (Ve = Ce.length - Pe), ve(Ve, Pe, Ce.length), oe(Ce, Pe, Ve);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var B = requireAlgos(), z = Object.keys(B), Y = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(z);
  cryptoBrowserify.getHashes = function() {
    return Y;
  };
  var ne = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = ne.pbkdf2, cryptoBrowserify.pbkdf2Sync = ne.pbkdf2Sync;
  var ae = requireBrowser$5();
  cryptoBrowserify.Cipher = ae.Cipher, cryptoBrowserify.createCipher = ae.createCipher, cryptoBrowserify.Cipheriv = ae.Cipheriv, cryptoBrowserify.createCipheriv = ae.createCipheriv, cryptoBrowserify.Decipher = ae.Decipher, cryptoBrowserify.createDecipher = ae.createDecipher, cryptoBrowserify.Decipheriv = ae.Decipheriv, cryptoBrowserify.createDecipheriv = ae.createDecipheriv, cryptoBrowserify.getCiphers = ae.getCiphers, cryptoBrowserify.listCiphers = ae.listCiphers;
  var ie = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = ie.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ie.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ie.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ie.createDiffieHellman, cryptoBrowserify.DiffieHellman = ie.DiffieHellman;
  var se = requireBrowser$3();
  cryptoBrowserify.createSign = se.createSign, cryptoBrowserify.Sign = se.Sign, cryptoBrowserify.createVerify = se.createVerify, cryptoBrowserify.Verify = se.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var le = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = le.publicEncrypt, cryptoBrowserify.privateEncrypt = le.privateEncrypt, cryptoBrowserify.publicDecrypt = le.publicDecrypt, cryptoBrowserify.privateDecrypt = le.privateDecrypt;
  var ve = requireBrowser();
  return cryptoBrowserify.randomFill = ve.randomFill, cryptoBrowserify.randomFillSync = ve.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const z = requireCryptoBrowserify(), Y = BigInt(0), ne = BigInt(1), ae = BigInt(2), ie = BigInt(3), se = BigInt(8), le = Object.freeze({
    a: Y,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: ne,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = le;
  const ve = (nr, Jt) => (nr + Jt / ae) / Jt, ge = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(nr) {
      const { n: Jt } = le, ir = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ar = -ne * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), dr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), yr = ir, gr = BigInt("0x100000000000000000000000000000000"), Er = ve(yr * nr, Jt), Pr = ve(-ar * nr, Jt);
      let Ar = Lt(nr - Er * ir - Pr * dr, Jt), Mr = Lt(-Er * ar - Pr * yr, Jt);
      const Cr = Ar > gr, er = Mr > gr;
      if (Cr && (Ar = Jt - Ar), er && (Mr = Jt - Mr), Ar > gr || Mr > gr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + nr);
      return { k1neg: Cr, k1: Ar, k2neg: er, k2: Mr };
    }
  }, oe = 32, Ee = 32, Ce = 32, Pe = oe + 1, Ve = 2 * oe + 1;
  function ht(nr) {
    const { a: Jt, b: ir } = le, ar = Lt(nr * nr), dr = Lt(ar * nr);
    return Lt(dr + Jt * nr + ir);
  }
  const vt = le.a === Y;
  class Pt extends Error {
    constructor(Jt) {
      super(Jt);
    }
  }
  function _t(nr) {
    if (!(nr instanceof kt))
      throw new TypeError("JacobianPoint expected");
  }
  class kt {
    constructor(Jt, ir, ar) {
      this.x = Jt, this.y = ir, this.z = ar;
    }
    static fromAffine(Jt) {
      if (!(Jt instanceof jt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Jt.equals(jt.ZERO) ? kt.ZERO : new kt(Jt.x, Jt.y, ne);
    }
    static toAffineBatch(Jt) {
      const ir = Wt(Jt.map((ar) => ar.z));
      return Jt.map((ar, dr) => ar.toAffine(ir[dr]));
    }
    static normalizeZ(Jt) {
      return kt.toAffineBatch(Jt).map(kt.fromAffine);
    }
    equals(Jt) {
      _t(Jt);
      const { x: ir, y: ar, z: dr } = this, { x: yr, y: gr, z: Er } = Jt, Pr = Lt(dr * dr), Ar = Lt(Er * Er), Mr = Lt(ir * Ar), Cr = Lt(yr * Pr), er = Lt(Lt(ar * Er) * Ar), br = Lt(Lt(gr * dr) * Pr);
      return Mr === Cr && er === br;
    }
    negate() {
      return new kt(this.x, Lt(-this.y), this.z);
    }
    double() {
      const { x: Jt, y: ir, z: ar } = this, dr = Lt(Jt * Jt), yr = Lt(ir * ir), gr = Lt(yr * yr), Er = Jt + yr, Pr = Lt(ae * (Lt(Er * Er) - dr - gr)), Ar = Lt(ie * dr), Mr = Lt(Ar * Ar), Cr = Lt(Mr - ae * Pr), er = Lt(Ar * (Pr - Cr) - se * gr), br = Lt(ae * ir * ar);
      return new kt(Cr, er, br);
    }
    add(Jt) {
      _t(Jt);
      const { x: ir, y: ar, z: dr } = this, { x: yr, y: gr, z: Er } = Jt;
      if (yr === Y || gr === Y)
        return this;
      if (ir === Y || ar === Y)
        return Jt;
      const Pr = Lt(dr * dr), Ar = Lt(Er * Er), Mr = Lt(ir * Ar), Cr = Lt(yr * Pr), er = Lt(Lt(ar * Er) * Ar), br = Lt(Lt(gr * dr) * Pr), wr = Lt(Cr - Mr), Sr = Lt(br - er);
      if (wr === Y)
        return Sr === Y ? this.double() : kt.ZERO;
      const Or = Lt(wr * wr), Fr = Lt(wr * Or), Ir = Lt(Mr * Or), Vr = Lt(Sr * Sr - Fr - ae * Ir), tn = Lt(Sr * (Ir - Vr) - er * Fr), Jr = Lt(dr * Er * wr);
      return new kt(Vr, tn, Jr);
    }
    subtract(Jt) {
      return this.add(Jt.negate());
    }
    multiplyUnsafe(Jt) {
      const ir = kt.ZERO;
      if (typeof Jt == "bigint" && Jt === Y)
        return ir;
      let ar = Rt(Jt);
      if (ar === ne)
        return this;
      if (!vt) {
        let Cr = ir, er = this;
        for (; ar > Y; )
          ar & ne && (Cr = Cr.add(er)), er = er.double(), ar >>= ne;
        return Cr;
      }
      let { k1neg: dr, k1: yr, k2neg: gr, k2: Er } = ge.splitScalar(ar), Pr = ir, Ar = ir, Mr = this;
      for (; yr > Y || Er > Y; )
        yr & ne && (Pr = Pr.add(Mr)), Er & ne && (Ar = Ar.add(Mr)), Mr = Mr.double(), yr >>= ne, Er >>= ne;
      return dr && (Pr = Pr.negate()), gr && (Ar = Ar.negate()), Ar = new kt(Lt(Ar.x * ge.beta), Ar.y, Ar.z), Pr.add(Ar);
    }
    precomputeWindow(Jt) {
      const ir = vt ? 128 / Jt + 1 : 256 / Jt + 1, ar = [];
      let dr = this, yr = dr;
      for (let gr = 0; gr < ir; gr++) {
        yr = dr, ar.push(yr);
        for (let Er = 1; Er < 2 ** (Jt - 1); Er++)
          yr = yr.add(dr), ar.push(yr);
        dr = yr.double();
      }
      return ar;
    }
    wNAF(Jt, ir) {
      !ir && this.equals(kt.BASE) && (ir = jt.BASE);
      const ar = ir && ir._WINDOW_SIZE || 1;
      if (256 % ar)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let dr = ir && Ht.get(ir);
      dr || (dr = this.precomputeWindow(ar), ir && ar !== 1 && (dr = kt.normalizeZ(dr), Ht.set(ir, dr)));
      let yr = kt.ZERO, gr = kt.BASE;
      const Er = 1 + (vt ? 128 / ar : 256 / ar), Pr = 2 ** (ar - 1), Ar = BigInt(2 ** ar - 1), Mr = 2 ** ar, Cr = BigInt(ar);
      for (let er = 0; er < Er; er++) {
        const br = er * Pr;
        let wr = Number(Jt & Ar);
        Jt >>= Cr, wr > Pr && (wr -= Mr, Jt += ne);
        const Sr = br, Or = br + Math.abs(wr) - 1, Fr = er % 2 !== 0, Ir = wr < 0;
        wr === 0 ? gr = gr.add(Ot(Fr, dr[Sr])) : yr = yr.add(Ot(Ir, dr[Or]));
      }
      return { p: yr, f: gr };
    }
    multiply(Jt, ir) {
      let ar = Rt(Jt), dr, yr;
      if (vt) {
        const { k1neg: gr, k1: Er, k2neg: Pr, k2: Ar } = ge.splitScalar(ar);
        let { p: Mr, f: Cr } = this.wNAF(Er, ir), { p: er, f: br } = this.wNAF(Ar, ir);
        Mr = Ot(gr, Mr), er = Ot(Pr, er), er = new kt(Lt(er.x * ge.beta), er.y, er.z), dr = Mr.add(er), yr = Cr.add(br);
      } else {
        const { p: gr, f: Er } = this.wNAF(ar, ir);
        dr = gr, yr = Er;
      }
      return kt.normalizeZ([dr, yr])[0];
    }
    toAffine(Jt) {
      const { x: ir, y: ar, z: dr } = this, yr = this.equals(kt.ZERO);
      Jt == null && (Jt = yr ? se : Zt(dr));
      const gr = Jt, Er = Lt(gr * gr), Pr = Lt(Er * gr), Ar = Lt(ir * Er), Mr = Lt(ar * Pr), Cr = Lt(dr * gr);
      if (yr)
        return jt.ZERO;
      if (Cr !== ne)
        throw new Error("invZ was invalid");
      return new jt(Ar, Mr);
    }
  }
  kt.BASE = new kt(le.Gx, le.Gy, ne), kt.ZERO = new kt(Y, ne, Y);
  function Ot(nr, Jt) {
    const ir = Jt.negate();
    return nr ? ir : Jt;
  }
  const Ht = /* @__PURE__ */ new WeakMap();
  class jt {
    constructor(Jt, ir) {
      this.x = Jt, this.y = ir;
    }
    _setWindowSize(Jt) {
      this._WINDOW_SIZE = Jt, Ht.delete(this);
    }
    hasEvenY() {
      return this.y % ae === Y;
    }
    static fromCompressedHex(Jt) {
      const ir = Jt.length === 32, ar = $t(ir ? Jt : Jt.subarray(1));
      if (!pr(ar))
        throw new Error("Point is not on curve");
      const dr = ht(ar);
      let yr = sr(dr);
      const gr = (yr & ne) === ne;
      ir ? gr && (yr = Lt(-yr)) : (Jt[0] & 1) === 1 !== gr && (yr = Lt(-yr));
      const Er = new jt(ar, yr);
      return Er.assertValidity(), Er;
    }
    static fromUncompressedHex(Jt) {
      const ir = $t(Jt.subarray(1, oe + 1)), ar = $t(Jt.subarray(oe + 1, oe * 2 + 1)), dr = new jt(ir, ar);
      return dr.assertValidity(), dr;
    }
    static fromHex(Jt) {
      const ir = qt(Jt), ar = ir.length, dr = ir[0];
      if (ar === oe)
        return this.fromCompressedHex(ir);
      if (ar === Pe && (dr === 2 || dr === 3))
        return this.fromCompressedHex(ir);
      if (ar === Ve && dr === 4)
        return this.fromUncompressedHex(ir);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Pe} compressed bytes or ${Ve} uncompressed bytes, not ${ar}`);
    }
    static fromPrivateKey(Jt) {
      return jt.BASE.multiply(_r(Jt));
    }
    static fromSignature(Jt, ir, ar) {
      const { r: dr, s: yr } = Tr(ir);
      if (![0, 1, 2, 3].includes(ar))
        throw new Error("Cannot recover: invalid recovery bit");
      const gr = rr(qt(Jt)), { n: Er } = le, Pr = ar === 2 || ar === 3 ? dr + Er : dr, Ar = Zt(Pr, Er), Mr = Lt(-gr * Ar, Er), Cr = Lt(yr * Ar, Er), er = ar & 1 ? "03" : "02", br = jt.fromHex(er + Qe(Pr)), wr = jt.BASE.multiplyAndAddUnsafe(br, Mr, Cr);
      if (!wr)
        throw new Error("Cannot recover signature: point at infinify");
      return wr.assertValidity(), wr;
    }
    toRawBytes(Jt = !1) {
      return Bt(this.toHex(Jt));
    }
    toHex(Jt = !1) {
      const ir = Qe(this.x);
      return Jt ? `${this.hasEvenY() ? "02" : "03"}${ir}` : `04${ir}${Qe(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Jt = "Point is not on elliptic curve", { x: ir, y: ar } = this;
      if (!pr(ir) || !pr(ar))
        throw new Error(Jt);
      const dr = Lt(ar * ar), yr = ht(ir);
      if (Lt(dr - yr) !== Y)
        throw new Error(Jt);
    }
    equals(Jt) {
      return this.x === Jt.x && this.y === Jt.y;
    }
    negate() {
      return new jt(this.x, Lt(-this.y));
    }
    double() {
      return kt.fromAffine(this).double().toAffine();
    }
    add(Jt) {
      return kt.fromAffine(this).add(kt.fromAffine(Jt)).toAffine();
    }
    subtract(Jt) {
      return this.add(Jt.negate());
    }
    multiply(Jt) {
      return kt.fromAffine(this).multiply(Jt, this).toAffine();
    }
    multiplyAndAddUnsafe(Jt, ir, ar) {
      const dr = kt.fromAffine(this), yr = ir === Y || ir === ne || this !== jt.BASE ? dr.multiplyUnsafe(ir) : dr.multiply(ir), gr = kt.fromAffine(Jt).multiplyUnsafe(ar), Er = yr.add(gr);
      return Er.equals(kt.ZERO) ? void 0 : Er.toAffine();
    }
  }
  B.Point = jt, jt.BASE = new jt(le.Gx, le.Gy), jt.ZERO = new jt(Y, Y);
  function Yt(nr) {
    return Number.parseInt(nr[0], 16) >= 8 ? "00" + nr : nr;
  }
  function Dt(nr) {
    if (nr.length < 2 || nr[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Xe(nr)}`);
    const Jt = nr[1], ir = nr.subarray(2, Jt + 2);
    if (!Jt || ir.length !== Jt)
      throw new Error("Invalid signature integer: wrong length");
    if (ir[0] === 0 && ir[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: $t(ir), left: nr.subarray(Jt + 2) };
  }
  function Ct(nr) {
    if (nr.length < 2 || nr[0] != 48)
      throw new Error(`Invalid signature tag: ${Xe(nr)}`);
    if (nr[1] !== nr.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Jt, left: ir } = Dt(nr.subarray(2)), { data: ar, left: dr } = Dt(ir);
    if (dr.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Xe(dr)}`);
    return { r: Jt, s: ar };
  }
  class Kt {
    constructor(Jt, ir) {
      this.r = Jt, this.s = ir, this.assertValidity();
    }
    static fromCompact(Jt) {
      const ir = Jt instanceof Uint8Array, ar = "Signature.fromCompact";
      if (typeof Jt != "string" && !ir)
        throw new TypeError(`${ar}: Expected string or Uint8Array`);
      const dr = ir ? Xe(Jt) : Jt;
      if (dr.length !== 128)
        throw new Error(`${ar}: Expected 64-byte hex`);
      return new Kt(xt(dr.slice(0, 64)), xt(dr.slice(64, 128)));
    }
    static fromDER(Jt) {
      const ir = Jt instanceof Uint8Array;
      if (typeof Jt != "string" && !ir)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: ar, s: dr } = Ct(ir ? Jt : Bt(Jt));
      return new Kt(ar, dr);
    }
    static fromHex(Jt) {
      return this.fromDER(Jt);
    }
    assertValidity() {
      const { r: Jt, s: ir } = this;
      if (!ur(Jt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!ur(ir))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Jt = le.n >> ne;
      return this.s > Jt;
    }
    normalizeS() {
      return this.hasHighS() ? new Kt(this.r, Lt(-this.s, le.n)) : this;
    }
    toDERRawBytes() {
      return Bt(this.toDERHex());
    }
    toDERHex() {
      const Jt = Yt(wt(this.s)), ir = Yt(wt(this.r)), ar = Jt.length / 2, dr = ir.length / 2, yr = wt(ar), gr = wt(dr);
      return `30${wt(dr + ar + 4)}02${gr}${ir}02${yr}${Jt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return Bt(this.toCompactHex());
    }
    toCompactHex() {
      return Qe(this.r) + Qe(this.s);
    }
  }
  B.Signature = Kt;
  function Nt(...nr) {
    if (!nr.every((ar) => ar instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (nr.length === 1)
      return nr[0];
    const Jt = nr.reduce((ar, dr) => ar + dr.length, 0), ir = new Uint8Array(Jt);
    for (let ar = 0, dr = 0; ar < nr.length; ar++) {
      const yr = nr[ar];
      ir.set(yr, dr), dr += yr.length;
    }
    return ir;
  }
  const Je = Array.from({ length: 256 }, (nr, Jt) => Jt.toString(16).padStart(2, "0"));
  function Xe(nr) {
    if (!(nr instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Jt = "";
    for (let ir = 0; ir < nr.length; ir++)
      Jt += Je[nr[ir]];
    return Jt;
  }
  const Ke = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Qe(nr) {
    if (typeof nr != "bigint")
      throw new Error("Expected bigint");
    if (!(Y <= nr && nr < Ke))
      throw new Error("Expected number 0 <= n < 2^256");
    return nr.toString(16).padStart(64, "0");
  }
  function bt(nr) {
    const Jt = Bt(Qe(nr));
    if (Jt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Jt;
  }
  function wt(nr) {
    const Jt = nr.toString(16);
    return Jt.length & 1 ? `0${Jt}` : Jt;
  }
  function xt(nr) {
    if (typeof nr != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof nr);
    return BigInt(`0x${nr}`);
  }
  function Bt(nr) {
    if (typeof nr != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof nr);
    if (nr.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + nr.length);
    const Jt = new Uint8Array(nr.length / 2);
    for (let ir = 0; ir < Jt.length; ir++) {
      const ar = ir * 2, dr = nr.slice(ar, ar + 2), yr = Number.parseInt(dr, 16);
      if (Number.isNaN(yr) || yr < 0)
        throw new Error("Invalid byte sequence");
      Jt[ir] = yr;
    }
    return Jt;
  }
  function $t(nr) {
    return xt(Xe(nr));
  }
  function qt(nr) {
    return nr instanceof Uint8Array ? Uint8Array.from(nr) : Bt(nr);
  }
  function Rt(nr) {
    if (typeof nr == "number" && Number.isSafeInteger(nr) && nr > 0)
      return BigInt(nr);
    if (typeof nr == "bigint" && ur(nr))
      return nr;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Lt(nr, Jt = le.P) {
    const ir = nr % Jt;
    return ir >= Y ? ir : Jt + ir;
  }
  function tr(nr, Jt) {
    const { P: ir } = le;
    let ar = nr;
    for (; Jt-- > Y; )
      ar *= ar, ar %= ir;
    return ar;
  }
  function sr(nr) {
    const { P: Jt } = le, ir = BigInt(6), ar = BigInt(11), dr = BigInt(22), yr = BigInt(23), gr = BigInt(44), Er = BigInt(88), Pr = nr * nr * nr % Jt, Ar = Pr * Pr * nr % Jt, Mr = tr(Ar, ie) * Ar % Jt, Cr = tr(Mr, ie) * Ar % Jt, er = tr(Cr, ae) * Pr % Jt, br = tr(er, ar) * er % Jt, wr = tr(br, dr) * br % Jt, Sr = tr(wr, gr) * wr % Jt, Or = tr(Sr, Er) * Sr % Jt, Fr = tr(Or, gr) * wr % Jt, Ir = tr(Fr, ie) * Ar % Jt, Vr = tr(Ir, yr) * br % Jt, tn = tr(Vr, ir) * Pr % Jt, Jr = tr(tn, ae);
    if (Jr * Jr % Jt !== nr)
      throw new Error("Cannot find square root");
    return Jr;
  }
  function Zt(nr, Jt = le.P) {
    if (nr === Y || Jt <= Y)
      throw new Error(`invert: expected positive integers, got n=${nr} mod=${Jt}`);
    let ir = Lt(nr, Jt), ar = Jt, dr = Y, yr = ne;
    for (; ir !== Y; ) {
      const Er = ar / ir, Pr = ar % ir, Ar = dr - yr * Er;
      ar = ir, ir = Pr, dr = yr, yr = Ar;
    }
    if (ar !== ne)
      throw new Error("invert: does not exist");
    return Lt(dr, Jt);
  }
  function Wt(nr, Jt = le.P) {
    const ir = new Array(nr.length), ar = nr.reduce((yr, gr, Er) => gr === Y ? yr : (ir[Er] = yr, Lt(yr * gr, Jt)), ne), dr = Zt(ar, Jt);
    return nr.reduceRight((yr, gr, Er) => gr === Y ? yr : (ir[Er] = Lt(yr * ir[Er], Jt), Lt(yr * gr, Jt)), dr), ir;
  }
  function Gt(nr) {
    const Jt = nr.length * 8 - Ee * 8, ir = $t(nr);
    return Jt > 0 ? ir >> BigInt(Jt) : ir;
  }
  function rr(nr, Jt = !1) {
    const ir = Gt(nr);
    if (Jt)
      return ir;
    const { n: ar } = le;
    return ir >= ar ? ir - ar : ir;
  }
  let or, Xt;
  class zt {
    constructor(Jt, ir) {
      if (this.hashLen = Jt, this.qByteLen = ir, typeof Jt != "number" || Jt < 2)
        throw new Error("hashLen must be a number");
      if (typeof ir != "number" || ir < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Jt).fill(1), this.k = new Uint8Array(Jt).fill(0), this.counter = 0;
    }
    hmac(...Jt) {
      return B.utils.hmacSha256(this.k, ...Jt);
    }
    hmacSync(...Jt) {
      return Xt(this.k, ...Jt);
    }
    checkSync() {
      if (typeof Xt != "function")
        throw new Pt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Jt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Jt), this.v = await this.hmac(this.v), Jt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Jt), this.v = await this.hmac(this.v));
    }
    reseedSync(Jt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Jt), this.v = this.hmacSync(this.v), Jt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Jt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Jt = 0;
      const ir = [];
      for (; Jt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const ar = this.v.slice();
        ir.push(ar), Jt += this.v.length;
      }
      return Nt(...ir);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Jt = 0;
      const ir = [];
      for (; Jt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const ar = this.v.slice();
        ir.push(ar), Jt += this.v.length;
      }
      return Nt(...ir);
    }
  }
  function ur(nr) {
    return Y < nr && nr < le.n;
  }
  function pr(nr) {
    return Y < nr && nr < le.P;
  }
  function vr(nr, Jt, ir, ar = !0) {
    const { n: dr } = le, yr = rr(nr, !0);
    if (!ur(yr))
      return;
    const gr = Zt(yr, dr), Er = jt.BASE.multiply(yr), Pr = Lt(Er.x, dr);
    if (Pr === Y)
      return;
    const Ar = Lt(gr * Lt(Jt + ir * Pr, dr), dr);
    if (Ar === Y)
      return;
    let Mr = new Kt(Pr, Ar), Cr = (Er.x === Mr.r ? 0 : 2) | Number(Er.y & ne);
    return ar && Mr.hasHighS() && (Mr = Mr.normalizeS(), Cr ^= 1), { sig: Mr, recovery: Cr };
  }
  function _r(nr) {
    let Jt;
    if (typeof nr == "bigint")
      Jt = nr;
    else if (typeof nr == "number" && Number.isSafeInteger(nr) && nr > 0)
      Jt = BigInt(nr);
    else if (typeof nr == "string") {
      if (nr.length !== 2 * Ee)
        throw new Error("Expected 32 bytes of private key");
      Jt = xt(nr);
    } else if (nr instanceof Uint8Array) {
      if (nr.length !== Ee)
        throw new Error("Expected 32 bytes of private key");
      Jt = $t(nr);
    } else
      throw new TypeError("Expected valid private key");
    if (!ur(Jt))
      throw new Error("Expected private key: 0 < key < n");
    return Jt;
  }
  function xr(nr) {
    return nr instanceof jt ? (nr.assertValidity(), nr) : jt.fromHex(nr);
  }
  function Tr(nr) {
    if (nr instanceof Kt)
      return nr.assertValidity(), nr;
    try {
      return Kt.fromDER(nr);
    } catch {
      return Kt.fromCompact(nr);
    }
  }
  function hr(nr, Jt = !1) {
    return jt.fromPrivateKey(nr).toRawBytes(Jt);
  }
  B.getPublicKey = hr;
  function Wr(nr, Jt, ir, ar = !1) {
    return jt.fromSignature(nr, Jt, ir).toRawBytes(ar);
  }
  B.recoverPublicKey = Wr;
  function $r(nr) {
    const Jt = nr instanceof Uint8Array, ir = typeof nr == "string", ar = (Jt || ir) && nr.length;
    return Jt ? ar === Pe || ar === Ve : ir ? ar === Pe * 2 || ar === Ve * 2 : nr instanceof jt;
  }
  function Ur(nr, Jt, ir = !1) {
    if ($r(nr))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!$r(Jt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const ar = xr(Jt);
    return ar.assertValidity(), ar.multiply(_r(nr)).toRawBytes(ir);
  }
  B.getSharedSecret = Ur;
  function Gr(nr) {
    const Jt = nr.length > oe ? nr.slice(0, oe) : nr;
    return $t(Jt);
  }
  function Rr(nr) {
    const Jt = Gr(nr), ir = Lt(Jt, le.n);
    return Hr(ir < Y ? Jt : ir);
  }
  function Hr(nr) {
    return bt(nr);
  }
  function Xr(nr, Jt, ir) {
    if (nr == null)
      throw new Error(`sign: expected valid message hash, not "${nr}"`);
    const ar = qt(nr), dr = _r(Jt), yr = [Hr(dr), Rr(ar)];
    if (ir != null) {
      ir === !0 && (ir = B.utils.randomBytes(oe));
      const Pr = qt(ir);
      if (Pr.length !== oe)
        throw new Error(`sign: Expected ${oe} bytes of extra data`);
      yr.push(Pr);
    }
    const gr = Nt(...yr), Er = Gr(ar);
    return { seed: gr, m: Er, d: dr };
  }
  function qr(nr, Jt) {
    const { sig: ir, recovery: ar } = nr, { der: dr, recovered: yr } = Object.assign({ canonical: !0, der: !0 }, Jt), gr = dr ? ir.toDERRawBytes() : ir.toCompactRawBytes();
    return yr ? [gr, ar] : gr;
  }
  async function zr(nr, Jt, ir = {}) {
    const { seed: ar, m: dr, d: yr } = Xr(nr, Jt, ir.extraEntropy), gr = new zt(Ce, Ee);
    await gr.reseed(ar);
    let Er;
    for (; !(Er = vr(await gr.generate(), dr, yr, ir.canonical)); )
      await gr.reseed();
    return qr(Er, ir);
  }
  B.sign = zr;
  function Qr(nr, Jt, ir = {}) {
    const { seed: ar, m: dr, d: yr } = Xr(nr, Jt, ir.extraEntropy), gr = new zt(Ce, Ee);
    gr.reseedSync(ar);
    let Er;
    for (; !(Er = vr(gr.generateSync(), dr, yr, ir.canonical)); )
      gr.reseedSync();
    return qr(Er, ir);
  }
  B.signSync = Qr;
  const Vt = { strict: !0 };
  function Ft(nr, Jt, ir, ar = Vt) {
    let dr;
    try {
      dr = Tr(nr), Jt = qt(Jt);
    } catch {
      return !1;
    }
    const { r: yr, s: gr } = dr;
    if (ar.strict && dr.hasHighS())
      return !1;
    const Er = rr(Jt);
    let Pr;
    try {
      Pr = xr(ir);
    } catch {
      return !1;
    }
    const { n: Ar } = le, Mr = Zt(gr, Ar), Cr = Lt(Er * Mr, Ar), er = Lt(yr * Mr, Ar), br = jt.BASE.multiplyAndAddUnsafe(Pr, Cr, er);
    return br ? Lt(br.x, Ar) === yr : !1;
  }
  B.verify = Ft;
  function Ut(nr) {
    return Lt($t(nr), le.n);
  }
  class Qt {
    constructor(Jt, ir) {
      this.r = Jt, this.s = ir, this.assertValidity();
    }
    static fromHex(Jt) {
      const ir = qt(Jt);
      if (ir.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${ir.length}`);
      const ar = $t(ir.subarray(0, 32)), dr = $t(ir.subarray(32, 64));
      return new Qt(ar, dr);
    }
    assertValidity() {
      const { r: Jt, s: ir } = this;
      if (!pr(Jt) || !ur(ir))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Qe(this.r) + Qe(this.s);
    }
    toRawBytes() {
      return Bt(this.toHex());
    }
  }
  function fr(nr) {
    return jt.fromPrivateKey(nr).toRawX();
  }
  class cr {
    constructor(Jt, ir, ar = B.utils.randomBytes()) {
      if (Jt == null)
        throw new TypeError(`sign: Expected valid message, not "${Jt}"`);
      this.m = qt(Jt);
      const { x: dr, scalar: yr } = this.getScalar(_r(ir));
      if (this.px = dr, this.d = yr, this.rand = qt(ar), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Jt) {
      const ir = jt.fromPrivateKey(Jt), ar = ir.hasEvenY() ? Jt : le.n - Jt;
      return { point: ir, scalar: ar, x: ir.toRawX() };
    }
    initNonce(Jt, ir) {
      return bt(Jt ^ $t(ir));
    }
    finalizeNonce(Jt) {
      const ir = Lt($t(Jt), le.n);
      if (ir === Y)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: ar, x: dr, scalar: yr } = this.getScalar(ir);
      return { R: ar, rx: dr, k: yr };
    }
    finalizeSig(Jt, ir, ar, dr) {
      return new Qt(Jt.x, Lt(ir + ar * dr, le.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Jt, d: ir, px: ar, rand: dr } = this, yr = B.utils.taggedHash, gr = this.initNonce(ir, await yr(Yr.aux, dr)), { R: Er, rx: Pr, k: Ar } = this.finalizeNonce(await yr(Yr.nonce, gr, ar, Jt)), Mr = Ut(await yr(Yr.challenge, Pr, ar, Jt)), Cr = this.finalizeSig(Er, Ar, Mr, ir);
      return await Dr(Cr, Jt, ar) || this.error(), Cr;
    }
    calcSync() {
      const { m: Jt, d: ir, px: ar, rand: dr } = this, yr = B.utils.taggedHashSync, gr = this.initNonce(ir, yr(Yr.aux, dr)), { R: Er, rx: Pr, k: Ar } = this.finalizeNonce(yr(Yr.nonce, gr, ar, Jt)), Mr = Ut(yr(Yr.challenge, Pr, ar, Jt)), Cr = this.finalizeSig(Er, Ar, Mr, ir);
      return Lr(Cr, Jt, ar) || this.error(), Cr;
    }
  }
  async function lr(nr, Jt, ir) {
    return new cr(nr, Jt, ir).calc();
  }
  function kr(nr, Jt, ir) {
    return new cr(nr, Jt, ir).calcSync();
  }
  function jr(nr, Jt, ir) {
    const ar = nr instanceof Qt, dr = ar ? nr : Qt.fromHex(nr);
    return ar && dr.assertValidity(), {
      ...dr,
      m: qt(Jt),
      P: xr(ir)
    };
  }
  function Br(nr, Jt, ir, ar) {
    const dr = jt.BASE.multiplyAndAddUnsafe(Jt, _r(ir), Lt(-ar, le.n));
    return !(!dr || !dr.hasEvenY() || dr.x !== nr);
  }
  async function Dr(nr, Jt, ir) {
    try {
      const { r: ar, s: dr, m: yr, P: gr } = jr(nr, Jt, ir), Er = Ut(await B.utils.taggedHash(Yr.challenge, bt(ar), gr.toRawX(), yr));
      return Br(ar, gr, dr, Er);
    } catch {
      return !1;
    }
  }
  function Lr(nr, Jt, ir) {
    try {
      const { r: ar, s: dr, m: yr, P: gr } = jr(nr, Jt, ir), Er = Ut(B.utils.taggedHashSync(Yr.challenge, bt(ar), gr.toRawX(), yr));
      return Br(ar, gr, dr, Er);
    } catch (ar) {
      if (ar instanceof Pt)
        throw ar;
      return !1;
    }
  }
  B.schnorr = {
    Signature: Qt,
    getPublicKey: fr,
    sign: lr,
    verify: Dr,
    signSync: kr,
    verifySync: Lr
  }, jt.BASE._setWindowSize(8);
  const Nr = {
    node: z,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Yr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Zr = {};
  B.utils = {
    bytesToHex: Xe,
    hexToBytes: Bt,
    concatBytes: Nt,
    mod: Lt,
    invert: Zt,
    isValidPrivateKey(nr) {
      try {
        return _r(nr), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: bt,
    _normalizePrivateKey: _r,
    hashToPrivateKey: (nr) => {
      nr = qt(nr);
      const Jt = Ee + 8;
      if (nr.length < Jt || nr.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const ir = Lt($t(nr), le.n - ne) + ne;
      return bt(ir);
    },
    randomBytes: (nr = 32) => {
      if (Nr.web)
        return Nr.web.getRandomValues(new Uint8Array(nr));
      if (Nr.node) {
        const { randomBytes: Jt } = Nr.node;
        return Uint8Array.from(Jt(nr));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(Ee + 8)),
    precompute(nr = 8, Jt = jt.BASE) {
      const ir = Jt === jt.BASE ? Jt : new jt(Jt.x, Jt.y);
      return ir._setWindowSize(nr), ir.multiply(ie), ir;
    },
    sha256: async (...nr) => {
      if (Nr.web) {
        const Jt = await Nr.web.subtle.digest("SHA-256", Nt(...nr));
        return new Uint8Array(Jt);
      } else if (Nr.node) {
        const { createHash: Jt } = Nr.node, ir = Jt("sha256");
        return nr.forEach((ar) => ir.update(ar)), Uint8Array.from(ir.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (nr, ...Jt) => {
      if (Nr.web) {
        const ir = await Nr.web.subtle.importKey("raw", nr, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), ar = Nt(...Jt), dr = await Nr.web.subtle.sign("HMAC", ir, ar);
        return new Uint8Array(dr);
      } else if (Nr.node) {
        const { createHmac: ir } = Nr.node, ar = ir("sha256", nr);
        return Jt.forEach((dr) => ar.update(dr)), Uint8Array.from(ar.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (nr, ...Jt) => {
      let ir = Zr[nr];
      if (ir === void 0) {
        const ar = await B.utils.sha256(Uint8Array.from(nr, (dr) => dr.charCodeAt(0)));
        ir = Nt(ar, ar), Zr[nr] = ir;
      }
      return B.utils.sha256(ir, ...Jt);
    },
    taggedHashSync: (nr, ...Jt) => {
      if (typeof or != "function")
        throw new Pt("sha256Sync is undefined, you need to set it");
      let ir = Zr[nr];
      if (ir === void 0) {
        const ar = or(Uint8Array.from(nr, (dr) => dr.charCodeAt(0)));
        ir = Nt(ar, ar), Zr[nr] = ir;
      }
      return or(ir, ...Jt);
    },
    _JacobianPoint: kt
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return or;
      },
      set(nr) {
        or || (or = nr);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Xt;
      },
      set(nr) {
        Xt || (Xt = nr);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const z = paramBytesForAlg[B];
  if (z)
    return z;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, z) {
  const Y = signatureAsBytes(B), ne = getParamBytesForAlg(z), ae = ne + 1, ie = Y.length;
  let se = 0;
  if (Y[se++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let le = Y[se++];
  if (le === (MAX_OCTET | 1) && (le = Y[se++]), ie - se < le)
    throw new Error(`"seq" specified length of "${le}", only "${ie - se}" remaining`);
  if (Y[se++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ve = Y[se++];
  if (ie - se - 2 < ve)
    throw new Error(`"r" specified length of "${ve}", only "${ie - se - 2}" available`);
  if (ae < ve)
    throw new Error(`"r" specified length of "${ve}", max of "${ae}" is acceptable`);
  const ge = se;
  if (se += ve, Y[se++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const oe = Y[se++];
  if (ie - se !== oe)
    throw new Error(`"s" specified length of "${oe}", expected "${ie - se}"`);
  if (ae < oe)
    throw new Error(`"s" specified length of "${oe}", max of "${ae}" is acceptable`);
  const Ee = se;
  if (se += oe, se !== ie)
    throw new Error(`Expected to consume entire array, but "${ie - se}" bytes remain`);
  const Ce = ne - ve, Pe = ne - oe, Ve = new Uint8Array(Ce + ve + Pe + oe);
  for (se = 0; se < Ce; ++se)
    Ve[se] = 0;
  Ve.set(Y.subarray(ge + Math.max(-Ce, 0), ge + ve), se), se = ne;
  for (const ht = se; se < ht + Pe; ++se)
    Ve[se] = 0;
  return Ve.set(Y.subarray(Ee + Math.max(-Pe, 0), Ee + oe), se), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(Ve));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, z, Y) {
  let ne = 0;
  for (; z + ne < Y && B[z + ne] === 0; )
    ++ne;
  return B[z + ne] >= MAX_OCTET && --ne, ne;
}
function joseToDer(B, z) {
  B = signatureAsBytes(B);
  const Y = getParamBytesForAlg(z), ne = B.length;
  if (ne !== Y * 2)
    throw new TypeError(`"${z}" signatures must be "${Y * 2}" bytes, saw "${ne}"`);
  const ae = countPadding(B, 0, Y), ie = countPadding(B, Y, B.length), se = Y - ae, le = Y - ie, ve = 2 + se + 1 + 1 + le, ge = ve < MAX_OCTET, oe = new Uint8Array((ge ? 2 : 3) + ve);
  let Ee = 0;
  return oe[Ee++] = ENCODED_TAG_SEQ, ge ? oe[Ee++] = ve : (oe[Ee++] = MAX_OCTET | 1, oe[Ee++] = ve & 255), oe[Ee++] = ENCODED_TAG_INT, oe[Ee++] = se, ae < 0 ? (oe[Ee++] = 0, oe.set(B.subarray(0, Y), Ee), Ee += Y) : (oe.set(B.subarray(ae, Y), Ee), Ee += Y - ae), oe[Ee++] = ENCODED_TAG_INT, oe[Ee++] = le, ie < 0 ? (oe[Ee++] = 0, oe.set(B.subarray(Y), Ee)) : oe.set(B.subarray(Y + ie), Ee), oe;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(z) {
    super(), this.name = "MissingParametersError", this.message = z || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(z) {
    super(), this.name = "InvalidTokenError", this.message = z || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (B, ...z) => {
  const Y = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return z.forEach((ne) => Y.update(ne)), Y.digest();
};
class SECP256K1Client {
  static derivePublicKey(z, Y = !0) {
    return z.length === 66 && (z = z.slice(0, 64)), z.length < 64 && (z = z.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(z, Y));
  }
  static signHash(z, Y, ne = "jose") {
    if (!z || !Y)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const ae = secp.signSync(z, Y.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (ne === "der")
      return (0, utils_1$2.bytesToHex)(ae);
    if (ne === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(ae, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(z) {
    return (0, ecdsaSigFormatter_1.joseToDer)(z, "ES256");
  }
  static verifyHash(z, Y, ne) {
    if (!z || !Y || !ne)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(Y, z, ne, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const z = secp256k1$1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return z.SECP256K1Client;
  } });
  const Y = {
    ES256K: z.SECP256K1Client
  };
  B.cryptoClients = Y;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function ae(ie) {
    return ie instanceof Y ? ie : new Y(function(se) {
      se(ie);
    });
  }
  return new (Y || (Y = Promise))(function(ie, se) {
    function le(oe) {
      try {
        ge(ne.next(oe));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ve(oe) {
      try {
        ge(ne.throw(oe));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ge(oe) {
      oe.done ? ie(oe.value) : ae(oe.value).then(le, ve);
    }
    ge((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const Y = typeof B == "string" ? new TextEncoder().encode(B) : B, ne = yield crypto.subtle.digest("SHA-256", Y);
        return new Uint8Array(ne);
      } else {
        const Y = requireCryptoBrowserify();
        if (!Y.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(Y.createHash("sha256").update(B).digest());
      }
    } catch (z) {
      return console.log(z), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function ae(ie) {
    return ie instanceof Y ? ie : new Y(function(se) {
      se(ie);
    });
  }
  return new (Y || (Y = Promise))(function(ie, se) {
    function le(oe) {
      try {
        ge(ne.next(oe));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ve(oe) {
      try {
        ge(ne.throw(oe));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ge(oe) {
      oe.done ? ie(oe.value) : ae(oe.value).then(le, ve);
    }
    ge((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(B, z) {
  const Y = [], ne = base64url$2.encode(JSON.stringify(z));
  Y.push(ne);
  const ae = base64url$2.encode(JSON.stringify(B));
  return Y.push(ae), Y.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof z != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (z = z.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(z))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[z], this.rawPrivateKey = Y;
  }
  header(z = {}) {
    const Y = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, Y, z);
  }
  sign(z, Y = !1, ne = {}) {
    const ae = this.header(ne), ie = createSigningInput(z, ae), se = (0, sha256_1$1.hashSha256)(ie);
    return this.createWithSignedHash(z, Y, ae, ie, se);
  }
  signAsync(z, Y = !1, ne = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const ae = this.header(ne), ie = createSigningInput(z, ae), se = yield (0, sha256_1$1.hashSha256Async)(ie);
      return this.createWithSignedHash(z, Y, ae, ie, se);
    });
  }
  createWithSignedHash(z, Y, ne, ae, ie) {
    const se = this.cryptoClient.signHash(ie, this.rawPrivateKey);
    return Y ? {
      header: [base64url$2.encode(JSON.stringify(ne))],
      payload: JSON.stringify(z),
      signature: [se]
    } : [ae, se].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof z != "string")
      throw "signing algorithm parameter must be a string";
    if (z = z.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(z))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[z], this.rawPublicKey = Y;
  }
  verify(z) {
    return typeof z == "string" ? this.verifyCompact(z, !1) : typeof z == "object" ? this.verifyExpanded(z, !1) : !1;
  }
  verifyAsync(z) {
    return typeof z == "string" ? this.verifyCompact(z, !0) : typeof z == "object" ? this.verifyExpanded(z, !0) : Promise.resolve(!1);
  }
  verifyCompact(z, Y) {
    const ne = z.split("."), ae = ne[0] + "." + ne[1], ie = (se) => {
      const le = this.cryptoClient.loadSignature(ne[2]);
      return this.cryptoClient.verifyHash(se, le, this.rawPublicKey);
    };
    if (Y)
      return (0, sha256_1.hashSha256Async)(ae).then((se) => ie(se));
    {
      const se = (0, sha256_1.hashSha256)(ae);
      return ie(se);
    }
  }
  verifyExpanded(z, Y) {
    const ne = [z.header.join("."), base64url$1.encode(z.payload)].join(".");
    let ae = !0;
    const ie = (se) => (z.signature.map((le) => {
      const ve = this.cryptoClient.loadSignature(le);
      this.cryptoClient.verifyHash(se, ve, this.rawPublicKey) || (ae = !1);
    }), ae);
    if (Y)
      return (0, sha256_1.hashSha256Async)(ne).then((se) => ie(se));
    {
      const se = (0, sha256_1.hashSha256)(ne);
      return ie(se);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const z = B.split("."), Y = JSON.parse(base64url.decode(z[0])), ne = JSON.parse(base64url.decode(z[1])), ae = z[2];
    return {
      header: Y,
      payload: ne,
      signature: ae
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let z = B.payload;
    B.payload[0] !== "{" && (z = base64url.decode(z));
    const Y = [];
    return B.header.map((ne) => {
      const ae = JSON.parse(base64url.decode(ne));
      Y.push(ae);
    }), {
      header: Y,
      payload: JSON.parse(z),
      signature: B.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(B) {
  var z = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ne, ae, ie, se) {
    se === void 0 && (se = ie);
    var le = Object.getOwnPropertyDescriptor(ae, ie);
    (!le || ("get" in le ? !ae.__esModule : le.writable || le.configurable)) && (le = { enumerable: !0, get: function() {
      return ae[ie];
    } }), Object.defineProperty(ne, se, le);
  } : function(ne, ae, ie, se) {
    se === void 0 && (se = ie), ne[se] = ae[ie];
  }), Y = commonjsGlobal && commonjsGlobal.__exportStar || function(ne, ae) {
    for (var ie in ne) ie !== "default" && !Object.prototype.hasOwnProperty.call(ae, ie) && z(ae, ne, ie);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), Y(signer, B), Y(verifier, B), Y(decode$i, B), Y(errors$1, B), Y(cryptoClients, B);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const B = Array(256).fill(-1);
  for (let z = 0; z < r.length; ++z) B[r.charCodeAt(z)] = z;
})();
var s, i, o, h$1 = (s = function(B, z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.bech32m = z.bech32 = void 0;
  const Y = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ne = {};
  for (let Ee = 0; Ee < 32; Ee++) {
    const Ce = Y.charAt(Ee);
    ne[Ce] = Ee;
  }
  function ae(Ee) {
    const Ce = Ee >> 25;
    return (33554431 & Ee) << 5 ^ 996825010 & -(Ce >> 0 & 1) ^ 642813549 & -(Ce >> 1 & 1) ^ 513874426 & -(Ce >> 2 & 1) ^ 1027748829 & -(Ce >> 3 & 1) ^ 705979059 & -(Ce >> 4 & 1);
  }
  function ie(Ee) {
    let Ce = 1;
    for (let Pe = 0; Pe < Ee.length; ++Pe) {
      const Ve = Ee.charCodeAt(Pe);
      if (Ve < 33 || Ve > 126) return "Invalid prefix (" + Ee + ")";
      Ce = ae(Ce) ^ Ve >> 5;
    }
    Ce = ae(Ce);
    for (let Pe = 0; Pe < Ee.length; ++Pe) {
      const Ve = Ee.charCodeAt(Pe);
      Ce = ae(Ce) ^ 31 & Ve;
    }
    return Ce;
  }
  function se(Ee, Ce, Pe, Ve) {
    let ht = 0, vt = 0;
    const Pt = (1 << Pe) - 1, _t = [];
    for (let kt = 0; kt < Ee.length; ++kt) for (ht = ht << Ce | Ee[kt], vt += Ce; vt >= Pe; ) vt -= Pe, _t.push(ht >> vt & Pt);
    if (Ve) vt > 0 && _t.push(ht << Pe - vt & Pt);
    else {
      if (vt >= Ce) return "Excess padding";
      if (ht << Pe - vt & Pt) return "Non-zero padding";
    }
    return _t;
  }
  function le(Ee) {
    return se(Ee, 8, 5, !0);
  }
  function ve(Ee) {
    const Ce = se(Ee, 5, 8, !1);
    if (Array.isArray(Ce)) return Ce;
  }
  function ge(Ee) {
    const Ce = se(Ee, 5, 8, !1);
    if (Array.isArray(Ce)) return Ce;
    throw new Error(Ce);
  }
  function oe(Ee) {
    let Ce;
    function Pe(Ve, ht) {
      if (ht = ht || 90, Ve.length < 8) return Ve + " too short";
      if (Ve.length > ht) return "Exceeds length limit";
      const vt = Ve.toLowerCase(), Pt = Ve.toUpperCase();
      if (Ve !== vt && Ve !== Pt) return "Mixed-case string " + Ve;
      const _t = (Ve = vt).lastIndexOf("1");
      if (_t === -1) return "No separator character for " + Ve;
      if (_t === 0) return "Missing prefix for " + Ve;
      const kt = Ve.slice(0, _t), Ot = Ve.slice(_t + 1);
      if (Ot.length < 6) return "Data too short";
      let Ht = ie(kt);
      if (typeof Ht == "string") return Ht;
      const jt = [];
      for (let Yt = 0; Yt < Ot.length; ++Yt) {
        const Dt = Ot.charAt(Yt), Ct = ne[Dt];
        if (Ct === void 0) return "Unknown character " + Dt;
        Ht = ae(Ht) ^ Ct, Yt + 6 >= Ot.length || jt.push(Ct);
      }
      return Ht !== Ce ? "Invalid checksum for " + Ve : { prefix: kt, words: jt };
    }
    return Ce = Ee === "bech32" ? 1 : 734539939, { decodeUnsafe: function(Ve, ht) {
      const vt = Pe(Ve, ht);
      if (typeof vt == "object") return vt;
    }, decode: function(Ve, ht) {
      const vt = Pe(Ve, ht);
      if (typeof vt == "object") return vt;
      throw new Error(vt);
    }, encode: function(Ve, ht, vt) {
      if (vt = vt || 90, Ve.length + 7 + ht.length > vt) throw new TypeError("Exceeds length limit");
      let Pt = ie(Ve = Ve.toLowerCase());
      if (typeof Pt == "string") throw new Error(Pt);
      let _t = Ve + "1";
      for (let kt = 0; kt < ht.length; ++kt) {
        const Ot = ht[kt];
        if (Ot >> 5) throw new Error("Non 5-bit word");
        Pt = ae(Pt) ^ Ot, _t += Y.charAt(Ot);
      }
      for (let kt = 0; kt < 6; ++kt) Pt = ae(Pt);
      Pt ^= Ce;
      for (let kt = 0; kt < 6; ++kt) _t += Y.charAt(Pt >> 5 * (5 - kt) & 31);
      return _t;
    }, toWords: le, fromWordsUnsafe: ve, fromWords: ge };
  }
  z.bech32 = oe("bech32"), z.bech32m = oe("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
function getProviderById(B) {
  return B == null ? void 0 : B.split(".").reduce((z, Y) => z == null ? void 0 : z[Y], window);
}
var BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Testnet4 = "Testnet4", B.Signet = "Signet", B.Regtest = "Regtest", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), RpcErrorCode = /* @__PURE__ */ ((B) => (B[B.PARSE_ERROR = -32700] = "PARSE_ERROR", B[B.INVALID_REQUEST = -32600] = "INVALID_REQUEST", B[B.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", B[B.INVALID_PARAMS = -32602] = "INVALID_PARAMS", B[B.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", B[B.USER_REJECTION = -32e3] = "USER_REJECTION", B[B.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", B[B.ACCESS_DENIED = -32002] = "ACCESS_DENIED", B))(RpcErrorCode || {}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((B) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var request = async (B, z, Y) => {
  var ie;
  let ne = ((ie = window.XverseProviders) == null ? void 0 : ie.BitcoinProvider) || window.BitcoinProvider;
  if (ne = await getProviderById(Y), !ne)
    throw new Error("no wallet provider was found");
  if (!B)
    throw new Error("A wallet method is required");
  const ae = await ne.request(B, z);
  return is(rpcErrorResponseMessageSchema, ae) ? {
    status: "error",
    error: ae.error
  } : is(rpcSuccessResponseMessageSchema, ae) ? {
    status: "success",
    result: ae.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: ae
    }
  };
};
async function waitForUnisatExtensionReady() {
  let B = 0;
  const z = 20;
  for (; B < z; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const Y = await window.unisat.getAccounts();
        if (Y && Y.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((Y) => {
      setTimeout(Y, 100);
    });
  }
  return !1;
}
BitcoinNetworkType.Mainnet, BitcoinNetworkType.Testnet, BitcoinNetworkType.Signet;
const getXverseAddresses = async (B) => {
  var ae;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((ae = window.XverseProviders) == null ? void 0 : ae.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const Y = [], ne = await request(
    "wallet_connect",
    {
      message: "Provide access to Payment address and Ordinals address",
      addresses: ["ordinals", "payment"]
    },
    "XverseProviders.BitcoinProvider"
  );
  if (ne.status === "error")
    throw new Error("Failed to connect to Xverse");
  if (ne.status === "success") {
    if (console.log("==>response", ne.result), !ne.result || !ne.result.addresses || ne.result.addresses.length !== 2)
      throw new BrowserWalletSigningError(
        "Failed to retrieve addresses using selected wallet"
      );
    ne.result.addresses.forEach((ie) => {
      console.log("==>format", "format");
      try {
        const se = getAddressFormat(ie.address, B);
        let le = ie.publicKey;
        se === "taproot" && (le = Buffer$1.from(ie.publicKey, "hex").length === 33 ? le : `02${le}`), Y.push({
          publicKey: le,
          address: ie.address,
          format: se
        });
      } catch {
        throw new Error(`Wrong network type: ${B}. To switch networks in Xverse wallet, go to Settings () > click on Network > Switch to Testnet4 and save your settings.`);
      }
    });
  }
  return Y;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work\  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: B,
  wallet: z,
  chain: Y = Chain.BITCOIN
}, { readOnly: ne = !1 } = {}) => {
  switch (z) {
    case Wallet.UNISAT: {
      const ie = await getAddresses$3(B === "testnet4" ? "testnet" : B, Y, { readOnly: ne });
      if (!ie || ie.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const se = ie[0];
      return {
        address: {
          ordinals: se.address,
          payments: se.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: se.publicKey
        },
        format: {
          ordinals: se.format,
          payments: se.format
        }
      };
    }
    case Wallet.XVERSE: {
      const ae = await getXverseAddresses(B);
      if (console.log("==>xverse", ae), !ae || ae.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const ie = ae.find(
        (le) => le.format === "p2sh-p2wpkh" || le.format === "segwit"
      );
      if (!ie)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const se = ae.find(
        (le) => le.format === "taproot"
      );
      if (!se)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: se.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: se.format,
          payments: ie.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const ae = await getAddresses$2(B);
      if (!ae || ae.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const ie = ae.find(
        (le) => le.format === "segwit" || le.format === "p2sh-p2wpkh"
      );
      if (!ie)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const se = ae.find(
        (le) => le.format === "taproot"
      );
      if (!se)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: se.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: se.format,
          payments: ie.format
        }
      };
    }
    case Wallet.LEATHER: {
      const ae = await getAddresses$1(B);
      if (!ae || ae.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const ie = ae.find(
        (le) => le.format === "segwit"
      );
      if (!ie)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const se = ae.find(
        (le) => le.format === "taproot"
      );
      if (!se)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: se.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: se.format,
          payments: ie.format
        }
      };
    }
    case Wallet.OKX: {
      const ae = await getAddresses(B);
      if (!ae || ae.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const ie = ae[0];
      return {
        address: {
          ordinals: ie.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: ie.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: ie.format,
          payments: ie.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: B,
  onError: z
}) {
  const {
    updateAddress: Y,
    network: ne,
    updateWallet: ae,
    updatePublicKey: ie,
    updateFormat: se,
    disconnectWallet: le,
    address: ve,
    publicKey: ge,
    format: oe,
    wallet: Ee,
    chain: Ce
  } = useOrdConnect(), Pe = (ht, vt) => {
    z(vt.message ?? vt.toString()), console.error(`Error while connecting to ${ht} wallet`, vt), le(), vt instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[ht],
      "_blank",
      "noopener,noreferrer"
    );
  }, Ve = async (ht, { readOnly: vt = !1 } = {}) => {
    try {
      const { address: Pt, publicKey: _t, format: kt } = await connectWallet(
        { network: ne, wallet: ht, chain: Ce },
        { readOnly: vt }
      );
      return Y({
        ordinals: Pt.ordinals,
        payments: Pt.payments
      }), ie({
        ordinals: _t.ordinals,
        payments: _t.payments
      }), ae(ht), se({
        ordinals: kt.ordinals,
        payments: kt.payments
      }), B(), !0;
    } catch (Pt) {
      return console.log("===>err", Pt), Pe(ht, Pt), !1;
    }
  };
  return useEffect(() => {
    if (Ee !== Wallet.UNISAT)
      return;
    let ht = !0, vt = !1;
    const Pt = () => Ve(Wallet.UNISAT);
    return ve && ge && oe && (async () => {
      const kt = await waitForUnisatExtensionReady();
      if (ht) {
        if (!kt) {
          le();
          return;
        }
        vt = await Ve(Wallet.UNISAT, {
          readOnly: !0
        }), ht && vt && window.unisat.addListener("accountsChanged", Pt);
      }
    })(), () => {
      ht = !1, vt && window.unisat.removeListener("accountsChanged", Pt);
    };
  }, [Ee]), { connectWallet: Ve };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  onConnect: z,
  icon: Y,
  renderAvatar: ne,
  isPreferred: ae
}) {
  const ie = isMobileUserAgent(), { wallet: se, address: le } = useOrdConnect(), [ve, ge] = useState(!1), oe = WALLET_TO_NAME[B], Ee = async () => {
    ge(!0);
    try {
      await z();
    } catch {
    }
    ge(!1);
  }, Ce = se === B && le.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Ee,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: Y, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: oe }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: ie ? "Available on app" : "" })
        ] }),
        se === B && le.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          ne ? ne(le.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: ie ? 12 : 16,
              variant: "beam",
              name: le.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(le.ordinals) })
        ] }) : null,
        !Ce && ae ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        ve ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: ie ? 20 : 24,
            height: ie ? 20 : 24,
            alt: `${oe} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: ie ? 20 : 24,
            height: ie ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: B,
  closeModal: z,
  renderAvatar: Y,
  preferredWallet: ne,
  walletsOrder: ae,
  visibleWallets: ie
}) {
  const [se, le] = useState(""), { connectWallet: ve } = useConnect({
    onClose: z,
    onError: (Pe) => le(Pe)
  }), { network: ge, chain: oe } = useOrdConnect(), Ee = isMobileUserAgent(), Ce = useMemo(() => {
    const Ve = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ve(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: Ee && ge !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ve(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: Ee,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ve(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ve(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ve(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: Ee,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((vt) => (ie || []).includes(vt.wallet)).filter(
      (vt) => vt.chains.includes(oe) && !vt.hidden
    );
    return ae ? Ve.map((vt) => {
      const Pt = ae.findIndex(
        (_t) => _t === vt.wallet
      );
      return Pt >= 0 ? { ...vt, order: Pt } : vt;
    }).sort((vt, Pt) => vt.order - Pt.order) : Ve;
  }, [Ee, ge, ae, ve, ie, oe]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ze$1, { appear: !0, show: B, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    yt$1,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: z,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[oe],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: z,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: Ce.map((Pe, Ve) => {
                  const ht = Ve === Ce.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Pe.wallet,
                        onConnect: async () => {
                          le("");
                          const vt = Pe.onConnect().then((_t) => (_t && le(""), _t)), Pt = await Promise.race([
                            vt,
                            new Promise((_t) => {
                              setTimeout(() => _t("timeout"), 5e3);
                            })
                          ]);
                          return typeof Pt == "string" ? (le(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), vt) : Pt;
                        },
                        icon: Pe.icon,
                        renderAvatar: Y,
                        isPreferred: ne === Pe.wallet
                      }
                    ),
                    !ht && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Pe.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: se })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: B,
  onViewProfile: z,
  onChangeWalletClick: Y,
  onDisconnectWalletClick: ne,
  renderAvatar: ae,
  preferredWallet: ie,
  walletsOrder: se
}) {
  const {
    address: le,
    disconnectWallet: ve,
    network: ge,
    isModalOpen: oe,
    openModal: Ee,
    closeModal: Ce,
    visibleWallets: Pe
  } = useOrdConnect(), Ve = useHasMounted(), ht = () => B ? null : le != null && le.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: le.ordinals,
      network: ge,
      onViewProfile: z,
      onChangeWallet: () => {
        Ee(), Y == null || Y();
      },
      onDisconnectWallet: () => {
        ve(), ne == null || ne();
      },
      renderAvatar: ae
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !Ve, openModal: Ee });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    ht(),
    Ve ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: oe,
        closeModal: Ce,
        renderAvatar: ae,
        preferredWallet: ie,
        walletsOrder: se,
        visibleWallets: Pe
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var z, Y, ne, ae = _t.prototype = { constructor: _t, toString: null, valueOf: null }, ie = new _t(1), se = 20, le = 4, ve = -7, ge = 21, oe = -1e7, Ee = 1e7, Ce = !1, Pe = 1, Ve = 0, ht = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, vt = "0123456789abcdefghijklmnopqrstuvwxyz", Pt = !0;
  function _t(Dt, Ct) {
    var Kt, Nt, Je, Xe, Ke, Qe, bt, wt, xt = this;
    if (!(xt instanceof _t)) return new _t(Dt, Ct);
    if (Ct == null) {
      if (Dt && Dt._isBigNumber === !0) {
        xt.s = Dt.s, !Dt.c || Dt.e > Ee ? xt.c = xt.e = null : Dt.e < oe ? xt.c = [xt.e = 0] : (xt.e = Dt.e, xt.c = Dt.c.slice());
        return;
      }
      if ((Qe = typeof Dt == "number") && Dt * 0 == 0) {
        if (xt.s = 1 / Dt < 0 ? (Dt = -Dt, -1) : 1, Dt === ~~Dt) {
          for (Xe = 0, Ke = Dt; Ke >= 10; Ke /= 10, Xe++) ;
          Xe > Ee ? xt.c = xt.e = null : (xt.e = Xe, xt.c = [Dt]);
          return;
        }
        wt = String(Dt);
      } else {
        if (!isNumeric.test(wt = String(Dt))) return ne(xt, wt, Qe);
        xt.s = wt.charCodeAt(0) == 45 ? (wt = wt.slice(1), -1) : 1;
      }
      (Xe = wt.indexOf(".")) > -1 && (wt = wt.replace(".", "")), (Ke = wt.search(/e/i)) > 0 ? (Xe < 0 && (Xe = Ke), Xe += +wt.slice(Ke + 1), wt = wt.substring(0, Ke)) : Xe < 0 && (Xe = wt.length);
    } else {
      if (intCheck(Ct, 2, vt.length, "Base"), Ct == 10 && Pt)
        return xt = new _t(Dt), jt(xt, se + xt.e + 1, le);
      if (wt = String(Dt), Qe = typeof Dt == "number") {
        if (Dt * 0 != 0) return ne(xt, wt, Qe, Ct);
        if (xt.s = 1 / Dt < 0 ? (wt = wt.slice(1), -1) : 1, _t.DEBUG && wt.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Dt);
      } else
        xt.s = wt.charCodeAt(0) === 45 ? (wt = wt.slice(1), -1) : 1;
      for (Kt = vt.slice(0, Ct), Xe = Ke = 0, bt = wt.length; Ke < bt; Ke++)
        if (Kt.indexOf(Nt = wt.charAt(Ke)) < 0) {
          if (Nt == ".") {
            if (Ke > Xe) {
              Xe = bt;
              continue;
            }
          } else if (!Je && (wt == wt.toUpperCase() && (wt = wt.toLowerCase()) || wt == wt.toLowerCase() && (wt = wt.toUpperCase()))) {
            Je = !0, Ke = -1, Xe = 0;
            continue;
          }
          return ne(xt, String(Dt), Qe, Ct);
        }
      Qe = !1, wt = Y(wt, Ct, 10, xt.s), (Xe = wt.indexOf(".")) > -1 ? wt = wt.replace(".", "") : Xe = wt.length;
    }
    for (Ke = 0; wt.charCodeAt(Ke) === 48; Ke++) ;
    for (bt = wt.length; wt.charCodeAt(--bt) === 48; ) ;
    if (wt = wt.slice(Ke, ++bt)) {
      if (bt -= Ke, Qe && _t.DEBUG && bt > 15 && (Dt > MAX_SAFE_INTEGER$2 || Dt !== mathfloor(Dt)))
        throw Error(tooManyDigits + xt.s * Dt);
      if ((Xe = Xe - Ke - 1) > Ee)
        xt.c = xt.e = null;
      else if (Xe < oe)
        xt.c = [xt.e = 0];
      else {
        if (xt.e = Xe, xt.c = [], Ke = (Xe + 1) % LOG_BASE, Xe < 0 && (Ke += LOG_BASE), Ke < bt) {
          for (Ke && xt.c.push(+wt.slice(0, Ke)), bt -= LOG_BASE; Ke < bt; )
            xt.c.push(+wt.slice(Ke, Ke += LOG_BASE));
          Ke = LOG_BASE - (wt = wt.slice(Ke)).length;
        } else
          Ke -= bt;
        for (; Ke--; wt += "0") ;
        xt.c.push(+wt);
      }
    } else
      xt.c = [xt.e = 0];
  }
  _t.clone = clone, _t.ROUND_UP = 0, _t.ROUND_DOWN = 1, _t.ROUND_CEIL = 2, _t.ROUND_FLOOR = 3, _t.ROUND_HALF_UP = 4, _t.ROUND_HALF_DOWN = 5, _t.ROUND_HALF_EVEN = 6, _t.ROUND_HALF_CEIL = 7, _t.ROUND_HALF_FLOOR = 8, _t.EUCLID = 9, _t.config = _t.set = function(Dt) {
    var Ct, Kt;
    if (Dt != null)
      if (typeof Dt == "object") {
        if (Dt.hasOwnProperty(Ct = "DECIMAL_PLACES") && (Kt = Dt[Ct], intCheck(Kt, 0, MAX, Ct), se = Kt), Dt.hasOwnProperty(Ct = "ROUNDING_MODE") && (Kt = Dt[Ct], intCheck(Kt, 0, 8, Ct), le = Kt), Dt.hasOwnProperty(Ct = "EXPONENTIAL_AT") && (Kt = Dt[Ct], Kt && Kt.pop ? (intCheck(Kt[0], -1e9, 0, Ct), intCheck(Kt[1], 0, MAX, Ct), ve = Kt[0], ge = Kt[1]) : (intCheck(Kt, -1e9, MAX, Ct), ve = -(ge = Kt < 0 ? -Kt : Kt))), Dt.hasOwnProperty(Ct = "RANGE"))
          if (Kt = Dt[Ct], Kt && Kt.pop)
            intCheck(Kt[0], -1e9, -1, Ct), intCheck(Kt[1], 1, MAX, Ct), oe = Kt[0], Ee = Kt[1];
          else if (intCheck(Kt, -1e9, MAX, Ct), Kt)
            oe = -(Ee = Kt < 0 ? -Kt : Kt);
          else
            throw Error(bignumberError + Ct + " cannot be zero: " + Kt);
        if (Dt.hasOwnProperty(Ct = "CRYPTO"))
          if (Kt = Dt[Ct], Kt === !!Kt)
            if (Kt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Ce = Kt;
              else
                throw Ce = !Kt, Error(bignumberError + "crypto unavailable");
            else
              Ce = Kt;
          else
            throw Error(bignumberError + Ct + " not true or false: " + Kt);
        if (Dt.hasOwnProperty(Ct = "MODULO_MODE") && (Kt = Dt[Ct], intCheck(Kt, 0, 9, Ct), Pe = Kt), Dt.hasOwnProperty(Ct = "POW_PRECISION") && (Kt = Dt[Ct], intCheck(Kt, 0, MAX, Ct), Ve = Kt), Dt.hasOwnProperty(Ct = "FORMAT"))
          if (Kt = Dt[Ct], typeof Kt == "object") ht = Kt;
          else throw Error(bignumberError + Ct + " not an object: " + Kt);
        if (Dt.hasOwnProperty(Ct = "ALPHABET"))
          if (Kt = Dt[Ct], typeof Kt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Kt))
            Pt = Kt.slice(0, 10) == "0123456789", vt = Kt;
          else
            throw Error(bignumberError + Ct + " invalid: " + Kt);
      } else
        throw Error(bignumberError + "Object expected: " + Dt);
    return {
      DECIMAL_PLACES: se,
      ROUNDING_MODE: le,
      EXPONENTIAL_AT: [ve, ge],
      RANGE: [oe, Ee],
      CRYPTO: Ce,
      MODULO_MODE: Pe,
      POW_PRECISION: Ve,
      FORMAT: ht,
      ALPHABET: vt
    };
  }, _t.isBigNumber = function(Dt) {
    if (!Dt || Dt._isBigNumber !== !0) return !1;
    if (!_t.DEBUG) return !0;
    var Ct, Kt, Nt = Dt.c, Je = Dt.e, Xe = Dt.s;
    e: if ({}.toString.call(Nt) == "[object Array]") {
      if ((Xe === 1 || Xe === -1) && Je >= -1e9 && Je <= MAX && Je === mathfloor(Je)) {
        if (Nt[0] === 0) {
          if (Je === 0 && Nt.length === 1) return !0;
          break e;
        }
        if (Ct = (Je + 1) % LOG_BASE, Ct < 1 && (Ct += LOG_BASE), String(Nt[0]).length == Ct) {
          for (Ct = 0; Ct < Nt.length; Ct++)
            if (Kt = Nt[Ct], Kt < 0 || Kt >= BASE || Kt !== mathfloor(Kt)) break e;
          if (Kt !== 0) return !0;
        }
      }
    } else if (Nt === null && Je === null && (Xe === null || Xe === 1 || Xe === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Dt);
  }, _t.maximum = _t.max = function() {
    return Ot(arguments, -1);
  }, _t.minimum = _t.min = function() {
    return Ot(arguments, 1);
  }, _t.random = function() {
    var Dt = 9007199254740992, Ct = Math.random() * Dt & 2097151 ? function() {
      return mathfloor(Math.random() * Dt);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Kt) {
      var Nt, Je, Xe, Ke, Qe, bt = 0, wt = [], xt = new _t(ie);
      if (Kt == null ? Kt = se : intCheck(Kt, 0, MAX), Ke = mathceil(Kt / LOG_BASE), Ce)
        if (crypto.getRandomValues) {
          for (Nt = crypto.getRandomValues(new Uint32Array(Ke *= 2)); bt < Ke; )
            Qe = Nt[bt] * 131072 + (Nt[bt + 1] >>> 11), Qe >= 9e15 ? (Je = crypto.getRandomValues(new Uint32Array(2)), Nt[bt] = Je[0], Nt[bt + 1] = Je[1]) : (wt.push(Qe % 1e14), bt += 2);
          bt = Ke / 2;
        } else if (crypto.randomBytes) {
          for (Nt = crypto.randomBytes(Ke *= 7); bt < Ke; )
            Qe = (Nt[bt] & 31) * 281474976710656 + Nt[bt + 1] * 1099511627776 + Nt[bt + 2] * 4294967296 + Nt[bt + 3] * 16777216 + (Nt[bt + 4] << 16) + (Nt[bt + 5] << 8) + Nt[bt + 6], Qe >= 9e15 ? crypto.randomBytes(7).copy(Nt, bt) : (wt.push(Qe % 1e14), bt += 7);
          bt = Ke / 7;
        } else
          throw Ce = !1, Error(bignumberError + "crypto unavailable");
      if (!Ce)
        for (; bt < Ke; )
          Qe = Ct(), Qe < 9e15 && (wt[bt++] = Qe % 1e14);
      for (Ke = wt[--bt], Kt %= LOG_BASE, Ke && Kt && (Qe = POWS_TEN[LOG_BASE - Kt], wt[bt] = mathfloor(Ke / Qe) * Qe); wt[bt] === 0; wt.pop(), bt--) ;
      if (bt < 0)
        wt = [Xe = 0];
      else {
        for (Xe = -1; wt[0] === 0; wt.splice(0, 1), Xe -= LOG_BASE) ;
        for (bt = 1, Qe = wt[0]; Qe >= 10; Qe /= 10, bt++) ;
        bt < LOG_BASE && (Xe -= LOG_BASE - bt);
      }
      return xt.e = Xe, xt.c = wt, xt;
    };
  }(), _t.sum = function() {
    for (var Dt = 1, Ct = arguments, Kt = new _t(Ct[0]); Dt < Ct.length; ) Kt = Kt.plus(Ct[Dt++]);
    return Kt;
  }, Y = /* @__PURE__ */ function() {
    var Dt = "0123456789";
    function Ct(Kt, Nt, Je, Xe) {
      for (var Ke, Qe = [0], bt, wt = 0, xt = Kt.length; wt < xt; ) {
        for (bt = Qe.length; bt--; Qe[bt] *= Nt) ;
        for (Qe[0] += Xe.indexOf(Kt.charAt(wt++)), Ke = 0; Ke < Qe.length; Ke++)
          Qe[Ke] > Je - 1 && (Qe[Ke + 1] == null && (Qe[Ke + 1] = 0), Qe[Ke + 1] += Qe[Ke] / Je | 0, Qe[Ke] %= Je);
      }
      return Qe.reverse();
    }
    return function(Kt, Nt, Je, Xe, Ke) {
      var Qe, bt, wt, xt, Bt, $t, qt, Rt, Lt = Kt.indexOf("."), tr = se, sr = le;
      for (Lt >= 0 && (xt = Ve, Ve = 0, Kt = Kt.replace(".", ""), Rt = new _t(Nt), $t = Rt.pow(Kt.length - Lt), Ve = xt, Rt.c = Ct(
        toFixedPoint(coeffToString($t.c), $t.e, "0"),
        10,
        Je,
        Dt
      ), Rt.e = Rt.c.length), qt = Ct(Kt, Nt, Je, Ke ? (Qe = vt, Dt) : (Qe = Dt, vt)), wt = xt = qt.length; qt[--xt] == 0; qt.pop()) ;
      if (!qt[0]) return Qe.charAt(0);
      if (Lt < 0 ? --wt : ($t.c = qt, $t.e = wt, $t.s = Xe, $t = z($t, Rt, tr, sr, Je), qt = $t.c, Bt = $t.r, wt = $t.e), bt = wt + tr + 1, Lt = qt[bt], xt = Je / 2, Bt = Bt || bt < 0 || qt[bt + 1] != null, Bt = sr < 4 ? (Lt != null || Bt) && (sr == 0 || sr == ($t.s < 0 ? 3 : 2)) : Lt > xt || Lt == xt && (sr == 4 || Bt || sr == 6 && qt[bt - 1] & 1 || sr == ($t.s < 0 ? 8 : 7)), bt < 1 || !qt[0])
        Kt = Bt ? toFixedPoint(Qe.charAt(1), -tr, Qe.charAt(0)) : Qe.charAt(0);
      else {
        if (qt.length = bt, Bt)
          for (--Je; ++qt[--bt] > Je; )
            qt[bt] = 0, bt || (++wt, qt = [1].concat(qt));
        for (xt = qt.length; !qt[--xt]; ) ;
        for (Lt = 0, Kt = ""; Lt <= xt; Kt += Qe.charAt(qt[Lt++])) ;
        Kt = toFixedPoint(Kt, wt, Qe.charAt(0));
      }
      return Kt;
    };
  }(), z = /* @__PURE__ */ function() {
    function Dt(Nt, Je, Xe) {
      var Ke, Qe, bt, wt, xt = 0, Bt = Nt.length, $t = Je % SQRT_BASE, qt = Je / SQRT_BASE | 0;
      for (Nt = Nt.slice(); Bt--; )
        bt = Nt[Bt] % SQRT_BASE, wt = Nt[Bt] / SQRT_BASE | 0, Ke = qt * bt + wt * $t, Qe = $t * bt + Ke % SQRT_BASE * SQRT_BASE + xt, xt = (Qe / Xe | 0) + (Ke / SQRT_BASE | 0) + qt * wt, Nt[Bt] = Qe % Xe;
      return xt && (Nt = [xt].concat(Nt)), Nt;
    }
    function Ct(Nt, Je, Xe, Ke) {
      var Qe, bt;
      if (Xe != Ke)
        bt = Xe > Ke ? 1 : -1;
      else
        for (Qe = bt = 0; Qe < Xe; Qe++)
          if (Nt[Qe] != Je[Qe]) {
            bt = Nt[Qe] > Je[Qe] ? 1 : -1;
            break;
          }
      return bt;
    }
    function Kt(Nt, Je, Xe, Ke) {
      for (var Qe = 0; Xe--; )
        Nt[Xe] -= Qe, Qe = Nt[Xe] < Je[Xe] ? 1 : 0, Nt[Xe] = Qe * Ke + Nt[Xe] - Je[Xe];
      for (; !Nt[0] && Nt.length > 1; Nt.splice(0, 1)) ;
    }
    return function(Nt, Je, Xe, Ke, Qe) {
      var bt, wt, xt, Bt, $t, qt, Rt, Lt, tr, sr, Zt, Wt, Gt, rr, or, Xt, zt, ur = Nt.s == Je.s ? 1 : -1, pr = Nt.c, vr = Je.c;
      if (!pr || !pr[0] || !vr || !vr[0])
        return new _t(
          // Return NaN if either NaN, or both Infinity or 0.
          !Nt.s || !Je.s || (pr ? vr && pr[0] == vr[0] : !vr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            pr && pr[0] == 0 || !vr ? ur * 0 : ur / 0
          )
        );
      for (Lt = new _t(ur), tr = Lt.c = [], wt = Nt.e - Je.e, ur = Xe + wt + 1, Qe || (Qe = BASE, wt = bitFloor(Nt.e / LOG_BASE) - bitFloor(Je.e / LOG_BASE), ur = ur / LOG_BASE | 0), xt = 0; vr[xt] == (pr[xt] || 0); xt++) ;
      if (vr[xt] > (pr[xt] || 0) && wt--, ur < 0)
        tr.push(1), Bt = !0;
      else {
        for (rr = pr.length, Xt = vr.length, xt = 0, ur += 2, $t = mathfloor(Qe / (vr[0] + 1)), $t > 1 && (vr = Dt(vr, $t, Qe), pr = Dt(pr, $t, Qe), Xt = vr.length, rr = pr.length), Gt = Xt, sr = pr.slice(0, Xt), Zt = sr.length; Zt < Xt; sr[Zt++] = 0) ;
        zt = vr.slice(), zt = [0].concat(zt), or = vr[0], vr[1] >= Qe / 2 && or++;
        do {
          if ($t = 0, bt = Ct(vr, sr, Xt, Zt), bt < 0) {
            if (Wt = sr[0], Xt != Zt && (Wt = Wt * Qe + (sr[1] || 0)), $t = mathfloor(Wt / or), $t > 1)
              for ($t >= Qe && ($t = Qe - 1), qt = Dt(vr, $t, Qe), Rt = qt.length, Zt = sr.length; Ct(qt, sr, Rt, Zt) == 1; )
                $t--, Kt(qt, Xt < Rt ? zt : vr, Rt, Qe), Rt = qt.length, bt = 1;
            else
              $t == 0 && (bt = $t = 1), qt = vr.slice(), Rt = qt.length;
            if (Rt < Zt && (qt = [0].concat(qt)), Kt(sr, qt, Zt, Qe), Zt = sr.length, bt == -1)
              for (; Ct(vr, sr, Xt, Zt) < 1; )
                $t++, Kt(sr, Xt < Zt ? zt : vr, Zt, Qe), Zt = sr.length;
          } else bt === 0 && ($t++, sr = [0]);
          tr[xt++] = $t, sr[0] ? sr[Zt++] = pr[Gt] || 0 : (sr = [pr[Gt]], Zt = 1);
        } while ((Gt++ < rr || sr[0] != null) && ur--);
        Bt = sr[0] != null, tr[0] || tr.splice(0, 1);
      }
      if (Qe == BASE) {
        for (xt = 1, ur = tr[0]; ur >= 10; ur /= 10, xt++) ;
        jt(Lt, Xe + (Lt.e = xt + wt * LOG_BASE - 1) + 1, Ke, Bt);
      } else
        Lt.e = wt, Lt.r = +Bt;
      return Lt;
    };
  }();
  function kt(Dt, Ct, Kt, Nt) {
    var Je, Xe, Ke, Qe, bt;
    if (Kt == null ? Kt = le : intCheck(Kt, 0, 8), !Dt.c) return Dt.toString();
    if (Je = Dt.c[0], Ke = Dt.e, Ct == null)
      bt = coeffToString(Dt.c), bt = Nt == 1 || Nt == 2 && (Ke <= ve || Ke >= ge) ? toExponential(bt, Ke) : toFixedPoint(bt, Ke, "0");
    else if (Dt = jt(new _t(Dt), Ct, Kt), Xe = Dt.e, bt = coeffToString(Dt.c), Qe = bt.length, Nt == 1 || Nt == 2 && (Ct <= Xe || Xe <= ve)) {
      for (; Qe < Ct; bt += "0", Qe++) ;
      bt = toExponential(bt, Xe);
    } else if (Ct -= Ke, bt = toFixedPoint(bt, Xe, "0"), Xe + 1 > Qe) {
      if (--Ct > 0) for (bt += "."; Ct--; bt += "0") ;
    } else if (Ct += Xe - Qe, Ct > 0)
      for (Xe + 1 == Qe && (bt += "."); Ct--; bt += "0") ;
    return Dt.s < 0 && Je ? "-" + bt : bt;
  }
  function Ot(Dt, Ct) {
    for (var Kt, Nt, Je = 1, Xe = new _t(Dt[0]); Je < Dt.length; Je++)
      Nt = new _t(Dt[Je]), (!Nt.s || (Kt = compare(Xe, Nt)) === Ct || Kt === 0 && Xe.s === Ct) && (Xe = Nt);
    return Xe;
  }
  function Ht(Dt, Ct, Kt) {
    for (var Nt = 1, Je = Ct.length; !Ct[--Je]; Ct.pop()) ;
    for (Je = Ct[0]; Je >= 10; Je /= 10, Nt++) ;
    return (Kt = Nt + Kt * LOG_BASE - 1) > Ee ? Dt.c = Dt.e = null : Kt < oe ? Dt.c = [Dt.e = 0] : (Dt.e = Kt, Dt.c = Ct), Dt;
  }
  ne = /* @__PURE__ */ function() {
    var Dt = /^(-?)0([xbo])(?=\w[\w.]*$)/i, Ct = /^([^.]+)\.$/, Kt = /^\.([^.]+)$/, Nt = /^-?(Infinity|NaN)$/, Je = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Xe, Ke, Qe, bt) {
      var wt, xt = Qe ? Ke : Ke.replace(Je, "");
      if (Nt.test(xt))
        Xe.s = isNaN(xt) ? null : xt < 0 ? -1 : 1;
      else {
        if (!Qe && (xt = xt.replace(Dt, function(Bt, $t, qt) {
          return wt = (qt = qt.toLowerCase()) == "x" ? 16 : qt == "b" ? 2 : 8, !bt || bt == wt ? $t : Bt;
        }), bt && (wt = bt, xt = xt.replace(Ct, "$1").replace(Kt, "0.$1")), Ke != xt))
          return new _t(xt, wt);
        if (_t.DEBUG)
          throw Error(bignumberError + "Not a" + (bt ? " base " + bt : "") + " number: " + Ke);
        Xe.s = null;
      }
      Xe.c = Xe.e = null;
    };
  }();
  function jt(Dt, Ct, Kt, Nt) {
    var Je, Xe, Ke, Qe, bt, wt, xt, Bt = Dt.c, $t = POWS_TEN;
    if (Bt) {
      e: {
        for (Je = 1, Qe = Bt[0]; Qe >= 10; Qe /= 10, Je++) ;
        if (Xe = Ct - Je, Xe < 0)
          Xe += LOG_BASE, Ke = Ct, bt = Bt[wt = 0], xt = mathfloor(bt / $t[Je - Ke - 1] % 10);
        else if (wt = mathceil((Xe + 1) / LOG_BASE), wt >= Bt.length)
          if (Nt) {
            for (; Bt.length <= wt; Bt.push(0)) ;
            bt = xt = 0, Je = 1, Xe %= LOG_BASE, Ke = Xe - LOG_BASE + 1;
          } else
            break e;
        else {
          for (bt = Qe = Bt[wt], Je = 1; Qe >= 10; Qe /= 10, Je++) ;
          Xe %= LOG_BASE, Ke = Xe - LOG_BASE + Je, xt = Ke < 0 ? 0 : mathfloor(bt / $t[Je - Ke - 1] % 10);
        }
        if (Nt = Nt || Ct < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        Bt[wt + 1] != null || (Ke < 0 ? bt : bt % $t[Je - Ke - 1]), Nt = Kt < 4 ? (xt || Nt) && (Kt == 0 || Kt == (Dt.s < 0 ? 3 : 2)) : xt > 5 || xt == 5 && (Kt == 4 || Nt || Kt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Xe > 0 ? Ke > 0 ? bt / $t[Je - Ke] : 0 : Bt[wt - 1]) % 10 & 1 || Kt == (Dt.s < 0 ? 8 : 7)), Ct < 1 || !Bt[0])
          return Bt.length = 0, Nt ? (Ct -= Dt.e + 1, Bt[0] = $t[(LOG_BASE - Ct % LOG_BASE) % LOG_BASE], Dt.e = -Ct || 0) : Bt[0] = Dt.e = 0, Dt;
        if (Xe == 0 ? (Bt.length = wt, Qe = 1, wt--) : (Bt.length = wt + 1, Qe = $t[LOG_BASE - Xe], Bt[wt] = Ke > 0 ? mathfloor(bt / $t[Je - Ke] % $t[Ke]) * Qe : 0), Nt)
          for (; ; )
            if (wt == 0) {
              for (Xe = 1, Ke = Bt[0]; Ke >= 10; Ke /= 10, Xe++) ;
              for (Ke = Bt[0] += Qe, Qe = 1; Ke >= 10; Ke /= 10, Qe++) ;
              Xe != Qe && (Dt.e++, Bt[0] == BASE && (Bt[0] = 1));
              break;
            } else {
              if (Bt[wt] += Qe, Bt[wt] != BASE) break;
              Bt[wt--] = 0, Qe = 1;
            }
        for (Xe = Bt.length; Bt[--Xe] === 0; Bt.pop()) ;
      }
      Dt.e > Ee ? Dt.c = Dt.e = null : Dt.e < oe && (Dt.c = [Dt.e = 0]);
    }
    return Dt;
  }
  function Yt(Dt) {
    var Ct, Kt = Dt.e;
    return Kt === null ? Dt.toString() : (Ct = coeffToString(Dt.c), Ct = Kt <= ve || Kt >= ge ? toExponential(Ct, Kt) : toFixedPoint(Ct, Kt, "0"), Dt.s < 0 ? "-" + Ct : Ct);
  }
  return ae.absoluteValue = ae.abs = function() {
    var Dt = new _t(this);
    return Dt.s < 0 && (Dt.s = 1), Dt;
  }, ae.comparedTo = function(Dt, Ct) {
    return compare(this, new _t(Dt, Ct));
  }, ae.decimalPlaces = ae.dp = function(Dt, Ct) {
    var Kt, Nt, Je, Xe = this;
    if (Dt != null)
      return intCheck(Dt, 0, MAX), Ct == null ? Ct = le : intCheck(Ct, 0, 8), jt(new _t(Xe), Dt + Xe.e + 1, Ct);
    if (!(Kt = Xe.c)) return null;
    if (Nt = ((Je = Kt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Je = Kt[Je]) for (; Je % 10 == 0; Je /= 10, Nt--) ;
    return Nt < 0 && (Nt = 0), Nt;
  }, ae.dividedBy = ae.div = function(Dt, Ct) {
    return z(this, new _t(Dt, Ct), se, le);
  }, ae.dividedToIntegerBy = ae.idiv = function(Dt, Ct) {
    return z(this, new _t(Dt, Ct), 0, 1);
  }, ae.exponentiatedBy = ae.pow = function(Dt, Ct) {
    var Kt, Nt, Je, Xe, Ke, Qe, bt, wt, xt, Bt = this;
    if (Dt = new _t(Dt), Dt.c && !Dt.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Yt(Dt));
    if (Ct != null && (Ct = new _t(Ct)), Qe = Dt.e > 14, !Bt.c || !Bt.c[0] || Bt.c[0] == 1 && !Bt.e && Bt.c.length == 1 || !Dt.c || !Dt.c[0])
      return xt = new _t(Math.pow(+Yt(Bt), Qe ? Dt.s * (2 - isOdd(Dt)) : +Yt(Dt))), Ct ? xt.mod(Ct) : xt;
    if (bt = Dt.s < 0, Ct) {
      if (Ct.c ? !Ct.c[0] : !Ct.s) return new _t(NaN);
      Nt = !bt && Bt.isInteger() && Ct.isInteger(), Nt && (Bt = Bt.mod(Ct));
    } else {
      if (Dt.e > 9 && (Bt.e > 0 || Bt.e < -1 || (Bt.e == 0 ? Bt.c[0] > 1 || Qe && Bt.c[1] >= 24e7 : Bt.c[0] < 8e13 || Qe && Bt.c[0] <= 9999975e7)))
        return Xe = Bt.s < 0 && isOdd(Dt) ? -0 : 0, Bt.e > -1 && (Xe = 1 / Xe), new _t(bt ? 1 / Xe : Xe);
      Ve && (Xe = mathceil(Ve / LOG_BASE + 2));
    }
    for (Qe ? (Kt = new _t(0.5), bt && (Dt.s = 1), wt = isOdd(Dt)) : (Je = Math.abs(+Yt(Dt)), wt = Je % 2), xt = new _t(ie); ; ) {
      if (wt) {
        if (xt = xt.times(Bt), !xt.c) break;
        Xe ? xt.c.length > Xe && (xt.c.length = Xe) : Nt && (xt = xt.mod(Ct));
      }
      if (Je) {
        if (Je = mathfloor(Je / 2), Je === 0) break;
        wt = Je % 2;
      } else if (Dt = Dt.times(Kt), jt(Dt, Dt.e + 1, 1), Dt.e > 14)
        wt = isOdd(Dt);
      else {
        if (Je = +Yt(Dt), Je === 0) break;
        wt = Je % 2;
      }
      Bt = Bt.times(Bt), Xe ? Bt.c && Bt.c.length > Xe && (Bt.c.length = Xe) : Nt && (Bt = Bt.mod(Ct));
    }
    return Nt ? xt : (bt && (xt = ie.div(xt)), Ct ? xt.mod(Ct) : Xe ? jt(xt, Ve, le, Ke) : xt);
  }, ae.integerValue = function(Dt) {
    var Ct = new _t(this);
    return Dt == null ? Dt = le : intCheck(Dt, 0, 8), jt(Ct, Ct.e + 1, Dt);
  }, ae.isEqualTo = ae.eq = function(Dt, Ct) {
    return compare(this, new _t(Dt, Ct)) === 0;
  }, ae.isFinite = function() {
    return !!this.c;
  }, ae.isGreaterThan = ae.gt = function(Dt, Ct) {
    return compare(this, new _t(Dt, Ct)) > 0;
  }, ae.isGreaterThanOrEqualTo = ae.gte = function(Dt, Ct) {
    return (Ct = compare(this, new _t(Dt, Ct))) === 1 || Ct === 0;
  }, ae.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, ae.isLessThan = ae.lt = function(Dt, Ct) {
    return compare(this, new _t(Dt, Ct)) < 0;
  }, ae.isLessThanOrEqualTo = ae.lte = function(Dt, Ct) {
    return (Ct = compare(this, new _t(Dt, Ct))) === -1 || Ct === 0;
  }, ae.isNaN = function() {
    return !this.s;
  }, ae.isNegative = function() {
    return this.s < 0;
  }, ae.isPositive = function() {
    return this.s > 0;
  }, ae.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, ae.minus = function(Dt, Ct) {
    var Kt, Nt, Je, Xe, Ke = this, Qe = Ke.s;
    if (Dt = new _t(Dt, Ct), Ct = Dt.s, !Qe || !Ct) return new _t(NaN);
    if (Qe != Ct)
      return Dt.s = -Ct, Ke.plus(Dt);
    var bt = Ke.e / LOG_BASE, wt = Dt.e / LOG_BASE, xt = Ke.c, Bt = Dt.c;
    if (!bt || !wt) {
      if (!xt || !Bt) return xt ? (Dt.s = -Ct, Dt) : new _t(Bt ? Ke : NaN);
      if (!xt[0] || !Bt[0])
        return Bt[0] ? (Dt.s = -Ct, Dt) : new _t(xt[0] ? Ke : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          le == 3 ? -0 : 0
        ));
    }
    if (bt = bitFloor(bt), wt = bitFloor(wt), xt = xt.slice(), Qe = bt - wt) {
      for ((Xe = Qe < 0) ? (Qe = -Qe, Je = xt) : (wt = bt, Je = Bt), Je.reverse(), Ct = Qe; Ct--; Je.push(0)) ;
      Je.reverse();
    } else
      for (Nt = (Xe = (Qe = xt.length) < (Ct = Bt.length)) ? Qe : Ct, Qe = Ct = 0; Ct < Nt; Ct++)
        if (xt[Ct] != Bt[Ct]) {
          Xe = xt[Ct] < Bt[Ct];
          break;
        }
    if (Xe && (Je = xt, xt = Bt, Bt = Je, Dt.s = -Dt.s), Ct = (Nt = Bt.length) - (Kt = xt.length), Ct > 0) for (; Ct--; xt[Kt++] = 0) ;
    for (Ct = BASE - 1; Nt > Qe; ) {
      if (xt[--Nt] < Bt[Nt]) {
        for (Kt = Nt; Kt && !xt[--Kt]; xt[Kt] = Ct) ;
        --xt[Kt], xt[Nt] += BASE;
      }
      xt[Nt] -= Bt[Nt];
    }
    for (; xt[0] == 0; xt.splice(0, 1), --wt) ;
    return xt[0] ? Ht(Dt, xt, wt) : (Dt.s = le == 3 ? -1 : 1, Dt.c = [Dt.e = 0], Dt);
  }, ae.modulo = ae.mod = function(Dt, Ct) {
    var Kt, Nt, Je = this;
    return Dt = new _t(Dt, Ct), !Je.c || !Dt.s || Dt.c && !Dt.c[0] ? new _t(NaN) : !Dt.c || Je.c && !Je.c[0] ? new _t(Je) : (Pe == 9 ? (Nt = Dt.s, Dt.s = 1, Kt = z(Je, Dt, 0, 3), Dt.s = Nt, Kt.s *= Nt) : Kt = z(Je, Dt, 0, Pe), Dt = Je.minus(Kt.times(Dt)), !Dt.c[0] && Pe == 1 && (Dt.s = Je.s), Dt);
  }, ae.multipliedBy = ae.times = function(Dt, Ct) {
    var Kt, Nt, Je, Xe, Ke, Qe, bt, wt, xt, Bt, $t, qt, Rt, Lt, tr, sr = this, Zt = sr.c, Wt = (Dt = new _t(Dt, Ct)).c;
    if (!Zt || !Wt || !Zt[0] || !Wt[0])
      return !sr.s || !Dt.s || Zt && !Zt[0] && !Wt || Wt && !Wt[0] && !Zt ? Dt.c = Dt.e = Dt.s = null : (Dt.s *= sr.s, !Zt || !Wt ? Dt.c = Dt.e = null : (Dt.c = [0], Dt.e = 0)), Dt;
    for (Nt = bitFloor(sr.e / LOG_BASE) + bitFloor(Dt.e / LOG_BASE), Dt.s *= sr.s, bt = Zt.length, Bt = Wt.length, bt < Bt && (Rt = Zt, Zt = Wt, Wt = Rt, Je = bt, bt = Bt, Bt = Je), Je = bt + Bt, Rt = []; Je--; Rt.push(0)) ;
    for (Lt = BASE, tr = SQRT_BASE, Je = Bt; --Je >= 0; ) {
      for (Kt = 0, $t = Wt[Je] % tr, qt = Wt[Je] / tr | 0, Ke = bt, Xe = Je + Ke; Xe > Je; )
        wt = Zt[--Ke] % tr, xt = Zt[Ke] / tr | 0, Qe = qt * wt + xt * $t, wt = $t * wt + Qe % tr * tr + Rt[Xe] + Kt, Kt = (wt / Lt | 0) + (Qe / tr | 0) + qt * xt, Rt[Xe--] = wt % Lt;
      Rt[Xe] = Kt;
    }
    return Kt ? ++Nt : Rt.splice(0, 1), Ht(Dt, Rt, Nt);
  }, ae.negated = function() {
    var Dt = new _t(this);
    return Dt.s = -Dt.s || null, Dt;
  }, ae.plus = function(Dt, Ct) {
    var Kt, Nt = this, Je = Nt.s;
    if (Dt = new _t(Dt, Ct), Ct = Dt.s, !Je || !Ct) return new _t(NaN);
    if (Je != Ct)
      return Dt.s = -Ct, Nt.minus(Dt);
    var Xe = Nt.e / LOG_BASE, Ke = Dt.e / LOG_BASE, Qe = Nt.c, bt = Dt.c;
    if (!Xe || !Ke) {
      if (!Qe || !bt) return new _t(Je / 0);
      if (!Qe[0] || !bt[0]) return bt[0] ? Dt : new _t(Qe[0] ? Nt : Je * 0);
    }
    if (Xe = bitFloor(Xe), Ke = bitFloor(Ke), Qe = Qe.slice(), Je = Xe - Ke) {
      for (Je > 0 ? (Ke = Xe, Kt = bt) : (Je = -Je, Kt = Qe), Kt.reverse(); Je--; Kt.push(0)) ;
      Kt.reverse();
    }
    for (Je = Qe.length, Ct = bt.length, Je - Ct < 0 && (Kt = bt, bt = Qe, Qe = Kt, Ct = Je), Je = 0; Ct; )
      Je = (Qe[--Ct] = Qe[Ct] + bt[Ct] + Je) / BASE | 0, Qe[Ct] = BASE === Qe[Ct] ? 0 : Qe[Ct] % BASE;
    return Je && (Qe = [Je].concat(Qe), ++Ke), Ht(Dt, Qe, Ke);
  }, ae.precision = ae.sd = function(Dt, Ct) {
    var Kt, Nt, Je, Xe = this;
    if (Dt != null && Dt !== !!Dt)
      return intCheck(Dt, 1, MAX), Ct == null ? Ct = le : intCheck(Ct, 0, 8), jt(new _t(Xe), Dt, Ct);
    if (!(Kt = Xe.c)) return null;
    if (Je = Kt.length - 1, Nt = Je * LOG_BASE + 1, Je = Kt[Je]) {
      for (; Je % 10 == 0; Je /= 10, Nt--) ;
      for (Je = Kt[0]; Je >= 10; Je /= 10, Nt++) ;
    }
    return Dt && Xe.e + 1 > Nt && (Nt = Xe.e + 1), Nt;
  }, ae.shiftedBy = function(Dt) {
    return intCheck(Dt, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + Dt);
  }, ae.squareRoot = ae.sqrt = function() {
    var Dt, Ct, Kt, Nt, Je, Xe = this, Ke = Xe.c, Qe = Xe.s, bt = Xe.e, wt = se + 4, xt = new _t("0.5");
    if (Qe !== 1 || !Ke || !Ke[0])
      return new _t(!Qe || Qe < 0 && (!Ke || Ke[0]) ? NaN : Ke ? Xe : 1 / 0);
    if (Qe = Math.sqrt(+Yt(Xe)), Qe == 0 || Qe == 1 / 0 ? (Ct = coeffToString(Ke), (Ct.length + bt) % 2 == 0 && (Ct += "0"), Qe = Math.sqrt(+Ct), bt = bitFloor((bt + 1) / 2) - (bt < 0 || bt % 2), Qe == 1 / 0 ? Ct = "5e" + bt : (Ct = Qe.toExponential(), Ct = Ct.slice(0, Ct.indexOf("e") + 1) + bt), Kt = new _t(Ct)) : Kt = new _t(Qe + ""), Kt.c[0]) {
      for (bt = Kt.e, Qe = bt + wt, Qe < 3 && (Qe = 0); ; )
        if (Je = Kt, Kt = xt.times(Je.plus(z(Xe, Je, wt, 1))), coeffToString(Je.c).slice(0, Qe) === (Ct = coeffToString(Kt.c)).slice(0, Qe))
          if (Kt.e < bt && --Qe, Ct = Ct.slice(Qe - 3, Qe + 1), Ct == "9999" || !Nt && Ct == "4999") {
            if (!Nt && (jt(Je, Je.e + se + 2, 0), Je.times(Je).eq(Xe))) {
              Kt = Je;
              break;
            }
            wt += 4, Qe += 4, Nt = 1;
          } else {
            (!+Ct || !+Ct.slice(1) && Ct.charAt(0) == "5") && (jt(Kt, Kt.e + se + 2, 1), Dt = !Kt.times(Kt).eq(Xe));
            break;
          }
    }
    return jt(Kt, Kt.e + se + 1, le, Dt);
  }, ae.toExponential = function(Dt, Ct) {
    return Dt != null && (intCheck(Dt, 0, MAX), Dt++), kt(this, Dt, Ct, 1);
  }, ae.toFixed = function(Dt, Ct) {
    return Dt != null && (intCheck(Dt, 0, MAX), Dt = Dt + this.e + 1), kt(this, Dt, Ct);
  }, ae.toFormat = function(Dt, Ct, Kt) {
    var Nt, Je = this;
    if (Kt == null)
      Dt != null && Ct && typeof Ct == "object" ? (Kt = Ct, Ct = null) : Dt && typeof Dt == "object" ? (Kt = Dt, Dt = Ct = null) : Kt = ht;
    else if (typeof Kt != "object")
      throw Error(bignumberError + "Argument not an object: " + Kt);
    if (Nt = Je.toFixed(Dt, Ct), Je.c) {
      var Xe, Ke = Nt.split("."), Qe = +Kt.groupSize, bt = +Kt.secondaryGroupSize, wt = Kt.groupSeparator || "", xt = Ke[0], Bt = Ke[1], $t = Je.s < 0, qt = $t ? xt.slice(1) : xt, Rt = qt.length;
      if (bt && (Xe = Qe, Qe = bt, bt = Xe, Rt -= Xe), Qe > 0 && Rt > 0) {
        for (Xe = Rt % Qe || Qe, xt = qt.substr(0, Xe); Xe < Rt; Xe += Qe) xt += wt + qt.substr(Xe, Qe);
        bt > 0 && (xt += wt + qt.slice(Xe)), $t && (xt = "-" + xt);
      }
      Nt = Bt ? xt + (Kt.decimalSeparator || "") + ((bt = +Kt.fractionGroupSize) ? Bt.replace(
        new RegExp("\\d{" + bt + "}\\B", "g"),
        "$&" + (Kt.fractionGroupSeparator || "")
      ) : Bt) : xt;
    }
    return (Kt.prefix || "") + Nt + (Kt.suffix || "");
  }, ae.toFraction = function(Dt) {
    var Ct, Kt, Nt, Je, Xe, Ke, Qe, bt, wt, xt, Bt, $t, qt = this, Rt = qt.c;
    if (Dt != null && (Qe = new _t(Dt), !Qe.isInteger() && (Qe.c || Qe.s !== 1) || Qe.lt(ie)))
      throw Error(bignumberError + "Argument " + (Qe.isInteger() ? "out of range: " : "not an integer: ") + Yt(Qe));
    if (!Rt) return new _t(qt);
    for (Ct = new _t(ie), wt = Kt = new _t(ie), Nt = bt = new _t(ie), $t = coeffToString(Rt), Xe = Ct.e = $t.length - qt.e - 1, Ct.c[0] = POWS_TEN[(Ke = Xe % LOG_BASE) < 0 ? LOG_BASE + Ke : Ke], Dt = !Dt || Qe.comparedTo(Ct) > 0 ? Xe > 0 ? Ct : wt : Qe, Ke = Ee, Ee = 1 / 0, Qe = new _t($t), bt.c[0] = 0; xt = z(Qe, Ct, 0, 1), Je = Kt.plus(xt.times(Nt)), Je.comparedTo(Dt) != 1; )
      Kt = Nt, Nt = Je, wt = bt.plus(xt.times(Je = wt)), bt = Je, Ct = Qe.minus(xt.times(Je = Ct)), Qe = Je;
    return Je = z(Dt.minus(Kt), Nt, 0, 1), bt = bt.plus(Je.times(wt)), Kt = Kt.plus(Je.times(Nt)), bt.s = wt.s = qt.s, Xe = Xe * 2, Bt = z(wt, Nt, Xe, le).minus(qt).abs().comparedTo(
      z(bt, Kt, Xe, le).minus(qt).abs()
    ) < 1 ? [wt, Nt] : [bt, Kt], Ee = Ke, Bt;
  }, ae.toNumber = function() {
    return +Yt(this);
  }, ae.toPrecision = function(Dt, Ct) {
    return Dt != null && intCheck(Dt, 1, MAX), kt(this, Dt, Ct, 2);
  }, ae.toString = function(Dt) {
    var Ct, Kt = this, Nt = Kt.s, Je = Kt.e;
    return Je === null ? Nt ? (Ct = "Infinity", Nt < 0 && (Ct = "-" + Ct)) : Ct = "NaN" : (Dt == null ? Ct = Je <= ve || Je >= ge ? toExponential(coeffToString(Kt.c), Je) : toFixedPoint(coeffToString(Kt.c), Je, "0") : Dt === 10 && Pt ? (Kt = jt(new _t(Kt), se + Je + 1, le), Ct = toFixedPoint(coeffToString(Kt.c), Kt.e, "0")) : (intCheck(Dt, 2, vt.length, "Base"), Ct = Y(toFixedPoint(coeffToString(Kt.c), Je, "0"), 10, Dt, Nt, !0)), Nt < 0 && Kt.c[0] && (Ct = "-" + Ct)), Ct;
  }, ae.valueOf = ae.toJSON = function() {
    return Yt(this);
  }, ae._isBigNumber = !0, ae[Symbol.toStringTag] = "BigNumber", ae[Symbol.for("nodejs.util.inspect.custom")] = ae.valueOf, B != null && _t.set(B), _t;
}
function bitFloor(B) {
  var z = B | 0;
  return B > 0 || B === z ? z : z - 1;
}
function coeffToString(B) {
  for (var z, Y, ne = 1, ae = B.length, ie = B[0] + ""; ne < ae; ) {
    for (z = B[ne++] + "", Y = LOG_BASE - z.length; Y--; z = "0" + z) ;
    ie += z;
  }
  for (ae = ie.length; ie.charCodeAt(--ae) === 48; ) ;
  return ie.slice(0, ae + 1 || 1);
}
function compare(B, z) {
  var Y, ne, ae = B.c, ie = z.c, se = B.s, le = z.s, ve = B.e, ge = z.e;
  if (!se || !le) return null;
  if (Y = ae && !ae[0], ne = ie && !ie[0], Y || ne) return Y ? ne ? 0 : -le : se;
  if (se != le) return se;
  if (Y = se < 0, ne = ve == ge, !ae || !ie) return ne ? 0 : !ae ^ Y ? 1 : -1;
  if (!ne) return ve > ge ^ Y ? 1 : -1;
  for (le = (ve = ae.length) < (ge = ie.length) ? ve : ge, se = 0; se < le; se++) if (ae[se] != ie[se]) return ae[se] > ie[se] ^ Y ? 1 : -1;
  return ve == ge ? 0 : ve > ge ^ Y ? 1 : -1;
}
function intCheck(B, z, Y, ne) {
  if (B < z || B > Y || B !== mathfloor(B))
    throw Error(bignumberError + (ne || "Argument") + (typeof B == "number" ? B < z || B > Y ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var z = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == z && B.c[z] % 2 != 0;
}
function toExponential(B, z) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (z < 0 ? "e" : "e+") + z;
}
function toFixedPoint(B, z, Y) {
  var ne, ae;
  if (z < 0) {
    for (ae = Y + "."; ++z; ae += Y) ;
    B = ae + B;
  } else if (ne = B.length, ++z > ne) {
    for (ae = Y, z -= ne; --z; ae += Y) ;
    B += ae;
  } else z < ne && (B = B.slice(0, z) + "." + B.slice(z));
  return B;
}
var BigNumber = clone();
function useBalance() {
  const { network: B, publicKey: z, format: Y, chain: ne } = useOrdConnect(), [ae, ie] = useState(null), [se, le] = useState(!1);
  return { getBalance: useCallback(async () => {
    le(!0);
    try {
      if (ie(null), !Y || !Y.payments || !z || !z.payments)
        throw new Error("No wallet is connected");
      const { address: ge } = getAddressesFromPublicKey(
        z.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[Y.payments],
        ne
      )[0], Ee = await new JsonRpcDatasource({
        chain: ne,
        network: B
      }).getBalance({ address: ge }), Ce = Number(
        new BigNumber(Ee).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return le(!1), Ce;
    } catch (ge) {
      throw ie(ge.message), le(!1), ge;
    }
  }, [Y, B, z]), error: ae, loading: se };
}
async function signPsbt({
  address: B,
  wallet: z,
  network: Y,
  psbt: ne,
  options: ae
}) {
  var ve, ge;
  if ((ve = ae == null ? void 0 : ae.signingIndexes) != null && ve.length && ((ge = ae == null ? void 0 : ae.inputsToSign) != null && ge.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const ie = (ae == null ? void 0 : ae.finalize) ?? !0, se = (ae == null ? void 0 : ae.extractTx) ?? !0, le = () => ne.data.inputs.map((oe, Ee) => Ee);
  if (z === Wallet.MAGICEDEN)
    return await signPsbt$1(ne, {
      network: Y,
      inputsToSign: (ae == null ? void 0 : ae.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ae == null ? void 0 : ae.signingIndexes) ?? le(),
          sigHash: ae == null ? void 0 : ae.sigHash
        }
      ],
      finalize: ie,
      extractTx: se
    });
  if (z === Wallet.UNISAT)
    return await signPsbt$2(ne, {
      finalize: ie,
      extractTx: se
    });
  if (z === Wallet.XVERSE)
    return await signPsbt$3(ne, {
      network: Y,
      inputsToSign: (ae == null ? void 0 : ae.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ae == null ? void 0 : ae.signingIndexes) ?? le(),
          // If signingIndexes is not provided, just sign everything
          sigHash: ae == null ? void 0 : ae.sigHash
        }
      ],
      finalize: ie,
      extractTx: se
    });
  if (z === Wallet.LEATHER)
    return await signPsbt$4(ne, {
      network: Y,
      finalize: ie,
      extractTx: se,
      allowedSighash: ae != null && ae.sigHash ? [ae == null ? void 0 : ae.sigHash] : [],
      signAtIndexes: (ae == null ? void 0 : ae.signingIndexes) ?? le()
      // If signingIndexes is not provided, just sign everything
    });
  if (z === Wallet.OKX)
    return await signPsbt$5(ne, {
      finalize: ie,
      extractTx: se,
      network: Y,
      inputsToSign: (ae == null ? void 0 : ae.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ae == null ? void 0 : ae.signingIndexes) ?? le(),
          // If signingIndexes is not provided, just sign everything
          sigHash: ae == null ? void 0 : ae.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: ae } = useOrdConnect(), [ie, se] = useState(null), [le, ve] = useState(!1);
  return { send: useCallback(
    async (oe, Ee, Ce, Pe = !0) => {
      ve(!0);
      try {
        if (se(null), !Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Ve = new PSBTBuilder({
          address: Y.payments,
          feeRate: Ce,
          network: z,
          chain: ae,
          publicKey: ne.payments,
          outputs: [
            {
              address: oe,
              value: Ee
            }
          ]
        });
        await Ve.prepare();
        const ht = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Ve.toPSBT()
        });
        if (Pe) {
          const Pt = await new JsonRpcDatasource({ network: z, chain: ae }).relay({ hex: ht.hex });
          return ve(!1), Pt;
        }
        return ve(!1), ht.hex;
      } catch (Ve) {
        return se(Ve.message), ve(!1), null;
      }
    },
    [Y, z, ne, B]
  ), error: ie, loading: le };
}
function useSendV2() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: ae } = useOrdConnect(), [ie, se] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ve,
      satoshis: ge,
      feeRate: oe,
      relay: Ee = !0,
      rbf: Ce = !1
    }) => {
      se(!0);
      try {
        if (!Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Pe = new PSBTBuilder({
          address: Y.payments,
          feeRate: oe,
          network: z,
          chain: ae,
          publicKey: ne.payments,
          outputs: [
            {
              address: ve,
              value: ge
            }
          ]
        });
        Pe.setRBF(Ce), await Pe.prepare();
        const Ve = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Pe.toPSBT()
        });
        if (Ee) {
          const vt = await new JsonRpcDatasource({ network: z, chain: ae }).relay({ hex: Ve.hex });
          return se(!1), {
            txId: vt
          };
        }
        return se(!1), {
          signedPsbtHex: Ve.hex
        };
      } catch (Pe) {
        return se(!1), {
          error: Pe.message
        };
      }
    },
    [Y, z, ne, B]
  ), isLoading: ie };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const z = B[3];
  if (z === 0 || 5 + z >= B.length || B[4 + z] !== 2) return !1;
  const Y = B[5 + z];
  return !(Y === 0 || 6 + z + Y !== B.length || B[4] & 128 || z > 1 && B[4] === 0 && !(B[5] & 128) || B[z + 6] & 128 || Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128));
}
bip66.check = check$d;
function decode$h(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const z = B[3];
  if (z === 0) throw new Error("R length is zero");
  if (5 + z >= B.length) throw new Error("R length is too long");
  if (B[4 + z] !== 2) throw new Error("Expected DER integer (2)");
  const Y = B[5 + z];
  if (Y === 0) throw new Error("S length is zero");
  if (6 + z + Y !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (z > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[z + 6] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + z),
    s: B.slice(6 + z)
  };
}
bip66.decode = decode$h;
function encode$i(B, z) {
  const Y = B.length, ne = z.length;
  if (Y === 0) throw new Error("R length is zero");
  if (ne === 0) throw new Error("S length is zero");
  if (Y > 33) throw new Error("R length is too long");
  if (ne > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (z[0] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (ne > 1 && z[0] === 0 && !(z[1] & 128))
    throw new Error("S value excessively padded");
  const ae = Buffer$1.allocUnsafe(6 + Y + ne);
  return ae[0] = 48, ae[1] = ae.length - 2, ae[2] = 2, ae[3] = B.length, B.copy(ae, 4), ae[4 + Y] = 2, ae[5 + Y] = z.length, z.copy(ae, 6 + Y), ae;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const z = OPS$7[B];
  REVERSE_OPS[z] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(B, z, Y) {
  const ne = encodingLength$2(z);
  return ne === 1 ? B.writeUInt8(z, Y) : ne === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, Y), B.writeUInt8(z, Y + 1)) : ne === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, Y), B.writeUInt16LE(z, Y + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, Y), B.writeUInt32LE(z, Y + 1)), ne;
}
push_data.encode = encode$h;
function decode$g(B, z) {
  const Y = B.readUInt8(z);
  let ne, ae;
  if (Y < ops_1.OPS.OP_PUSHDATA1)
    ne = Y, ae = 1;
  else if (Y === ops_1.OPS.OP_PUSHDATA1) {
    if (z + 2 > B.length) return null;
    ne = B.readUInt8(z + 1), ae = 2;
  } else if (Y === ops_1.OPS.OP_PUSHDATA2) {
    if (z + 3 > B.length) return null;
    ne = B.readUInt16LE(z + 1), ae = 3;
  } else {
    if (z + 5 > B.length) return null;
    if (Y !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    ne = B.readUInt32LE(z + 1), ae = 5;
  }
  return {
    opcode: Y,
    number: ne,
    size: ae
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(B, z, Y) {
  z = z || 4, Y = Y === void 0 ? !0 : Y;
  const ne = B.length;
  if (ne === 0) return 0;
  if (ne > z) throw new TypeError("Script number overflow");
  if (Y && !(B[ne - 1] & 127) && (ne <= 1 || !(B[ne - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (ne === 5) {
    const ie = B.readUInt32LE(0), se = B.readUInt8(4);
    return se & 128 ? -((se & -129) * 4294967296 + ie) : se * 4294967296 + ie;
  }
  let ae = 0;
  for (let ie = 0; ie < ne; ++ie)
    ae |= B[ie] << 8 * ie;
  return B[ne - 1] & 128 ? -(ae & ~(128 << 8 * (ne - 1))) : ae;
}
script_number.decode = decode$f;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$g(B) {
  let z = Math.abs(B);
  const Y = scriptNumSize(z), ne = Buffer$1.allocUnsafe(Y), ae = B < 0;
  for (let ie = 0; ie < Y; ++ie)
    ne.writeUInt8(z & 255, ie), z >>= 8;
  return ne[Y - 1] & 128 ? ne.writeUInt8(ae ? 128 : 0, Y - 1) : ae && (ne[Y - 1] |= 128), ne;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, z) {
  Error.captureStackTrace && Error.captureStackTrace(B, z);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, z, Y) {
  var ne = getValue(z);
  return "Expected " + tfJSON$1(B) + ", got" + (Y !== "" ? " " + Y : "") + (ne !== "" ? " " + ne : "");
}
function TfTypeError$1(B, z, Y) {
  Y = Y || getValueTypeName$1(z), this.message = tfErrorString(B, z, Y), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = z, this.__valueTypeName = Y;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, z, Y, ne, ae) {
  var ie = '" of type ';
  return z === "key" && (ie = '" with key type '), tfErrorString('property "' + tfJSON$1(Y) + ie + tfJSON$1(B), ne, ae);
}
function TfPropertyTypeError$1(B, z, Y, ne, ae) {
  B ? (ae = ae || getValueTypeName$1(ne), this.message = tfPropertyErrorString(B, Y, z, ne, ae)) : this.message = 'Unexpected property "' + z + '"', captureStackTrace(this, TfTypeError$1), this.__label = Y, this.__property = z, this.__type = B, this.__value = ne, this.__valueTypeName = ae;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, z) {
  return new TfTypeError$1(B, {}, z);
}
function tfSubError$1(B, z, Y) {
  return B instanceof TfPropertyTypeError$1 ? (z = z + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    z,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    z,
    Y,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, z = errors;
  function Y(jt) {
    return Buffer$1.isBuffer(jt);
  }
  function ne(jt) {
    return typeof jt == "string" && /^([0-9a-f]{2})+$/i.test(jt);
  }
  function ae(jt, Yt) {
    var Dt = jt.toJSON();
    function Ct(Kt) {
      if (!jt(Kt)) return !1;
      if (Kt.length === Yt) return !0;
      throw z.tfCustomError(Dt + "(Length: " + Yt + ")", Dt + "(Length: " + Kt.length + ")");
    }
    return Ct.toJSON = function() {
      return Dt;
    }, Ct;
  }
  var ie = ae.bind(null, B.Array), se = ae.bind(null, Y), le = ae.bind(null, ne), ve = ae.bind(null, B.String);
  function ge(jt, Yt, Dt) {
    Dt = Dt || B.Number;
    function Ct(Kt, Nt) {
      return Dt(Kt, Nt) && Kt > jt && Kt < Yt;
    }
    return Ct.toJSON = function() {
      return `${Dt.toJSON()} between [${jt}, ${Yt}]`;
    }, Ct;
  }
  var oe = Math.pow(2, 53) - 1;
  function Ee(jt) {
    return typeof jt == "number" && isFinite(jt);
  }
  function Ce(jt) {
    return jt << 24 >> 24 === jt;
  }
  function Pe(jt) {
    return jt << 16 >> 16 === jt;
  }
  function Ve(jt) {
    return (jt | 0) === jt;
  }
  function ht(jt) {
    return typeof jt == "number" && jt >= -oe && jt <= oe && Math.floor(jt) === jt;
  }
  function vt(jt) {
    return (jt & 255) === jt;
  }
  function Pt(jt) {
    return (jt & 65535) === jt;
  }
  function _t(jt) {
    return jt >>> 0 === jt;
  }
  function kt(jt) {
    return typeof jt == "number" && jt >= 0 && jt <= oe && Math.floor(jt) === jt;
  }
  var Ot = {
    ArrayN: ie,
    Buffer: Y,
    BufferN: se,
    Finite: Ee,
    Hex: ne,
    HexN: le,
    Int8: Ce,
    Int16: Pe,
    Int32: Ve,
    Int53: ht,
    Range: ge,
    StringN: ve,
    UInt8: vt,
    UInt16: Pt,
    UInt32: _t,
    UInt53: kt
  };
  for (var Ht in Ot)
    Ot[Ht].toJSON = (function(jt) {
      return jt;
    }).bind(null, Ht);
  return extra = Ot, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function B(z, Y) {
    z = compile(z), Y = Y || {};
    function ne(ae, ie) {
      return !NATIVE.Array(ae) || NATIVE.Nil(ae) || Y.minLength !== void 0 && ae.length < Y.minLength || Y.maxLength !== void 0 && ae.length > Y.maxLength || Y.length !== void 0 && ae.length !== Y.length ? !1 : ae.every(function(se, le) {
        try {
          return typeforce$3(z, se, ie);
        } catch (ve) {
          throw tfSubError(ve, le);
        }
      });
    }
    return ne.toJSON = function() {
      var ae = "[" + tfJSON(z) + "]";
      return Y.length !== void 0 ? ae += "{" + Y.length + "}" : (Y.minLength !== void 0 || Y.maxLength !== void 0) && (ae += "{" + (Y.minLength === void 0 ? 0 : Y.minLength) + "," + (Y.maxLength === void 0 ? 1 / 0 : Y.maxLength) + "}"), ae;
    }, ne;
  },
  maybe: function B(z) {
    z = compile(z);
    function Y(ne, ae) {
      return NATIVE.Nil(ne) || z(ne, ae, B);
    }
    return Y.toJSON = function() {
      return "?" + tfJSON(z);
    }, Y;
  },
  map: function B(z, Y) {
    z = compile(z), Y && (Y = compile(Y));
    function ne(ae, ie) {
      if (!NATIVE.Object(ae) || NATIVE.Nil(ae)) return !1;
      for (var se in ae) {
        try {
          Y && typeforce$3(Y, se, ie);
        } catch (ve) {
          throw tfSubError(ve, se, "key");
        }
        try {
          var le = ae[se];
          typeforce$3(z, le, ie);
        } catch (ve) {
          throw tfSubError(ve, se);
        }
      }
      return !0;
    }
    return Y ? ne.toJSON = function() {
      return "{" + tfJSON(Y) + ": " + tfJSON(z) + "}";
    } : ne.toJSON = function() {
      return "{" + tfJSON(z) + "}";
    }, ne;
  },
  object: function B(z) {
    var Y = {};
    for (var ne in z)
      Y[ne] = compile(z[ne]);
    function ae(ie, se) {
      if (!NATIVE.Object(ie) || NATIVE.Nil(ie)) return !1;
      var le;
      try {
        for (le in Y) {
          var ve = Y[le], ge = ie[le];
          typeforce$3(ve, ge, se);
        }
      } catch (oe) {
        throw tfSubError(oe, le);
      }
      if (se) {
        for (le in ie)
          if (!Y[le])
            throw new TfPropertyTypeError(void 0, le);
      }
      return !0;
    }
    return ae.toJSON = function() {
      return tfJSON(Y);
    }, ae;
  },
  anyOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ae) {
      return z.some(function(ie) {
        try {
          return typeforce$3(ie, ne, ae);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join("|");
    }, Y;
  },
  allOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ae) {
      return z.every(function(ie) {
        try {
          return typeforce$3(ie, ne, ae);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join(" & ");
    }, Y;
  },
  quacksLike: function B(z) {
    function Y(ne) {
      return z === getValueTypeName(ne);
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  },
  tuple: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ae) {
      return NATIVE.Nil(ne) || NATIVE.Nil(ne.length) || ae && ne.length !== z.length ? !1 : z.every(function(ie, se) {
        try {
          return typeforce$3(ie, ne[se], ae);
        } catch (le) {
          throw tfSubError(le, se);
        }
      });
    }
    return Y.toJSON = function() {
      return "(" + z.map(tfJSON).join(", ") + ")";
    }, Y;
  },
  value: function B(z) {
    function Y(ne) {
      return ne === z;
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$3(B, z, Y, ne) {
  if (NATIVE.Function(B)) {
    if (B(z, Y)) return !0;
    throw new TfTypeError(ne || B, z);
  }
  return typeforce$3(compile(B), z, Y);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const z = require$$0$1;
  B.typeforce = typeforce_1;
  const Y = z.Buffer.alloc(32, 0), ne = z.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function ae(oe, Ee) {
    return oe.length !== Ee.length ? !1 : oe.every((Ce, Pe) => Ce.equals(Ee[Pe]));
  }
  B.stacksEqual = ae;
  function ie(oe) {
    if (!z.Buffer.isBuffer(oe) || oe.length < 33) return !1;
    const Ee = oe[0], Ce = oe.slice(1, 33);
    if (Ce.compare(Y) === 0 || Ce.compare(ne) >= 0) return !1;
    if ((Ee === 2 || Ee === 3) && oe.length === 33)
      return !0;
    const Pe = oe.slice(33);
    return Pe.compare(Y) === 0 || Pe.compare(ne) >= 0 ? !1 : Ee === 4 && oe.length === 65;
  }
  B.isPoint = ie;
  const se = 21 * 1e14;
  function le(oe) {
    return B.typeforce.UInt53(oe) && oe <= se;
  }
  B.Satoshi = le, B.TAPLEAF_VERSION_MASK = 254;
  function ve(oe) {
    return !oe || !("output" in oe) || !z.Buffer.isBuffer(oe.output) ? !1 : oe.version !== void 0 ? (oe.version & B.TAPLEAF_VERSION_MASK) === oe.version : !0;
  }
  B.isTapleaf = ve;
  function ge(oe) {
    return (0, B.Array)(oe) ? oe.length !== 2 ? !1 : oe.every((Ee) => ge(Ee)) : ve(oe);
  }
  B.isTaptree = ge, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, z = requireScript(), Y = types$4, { typeforce: ne } = Y, ae = Buffer$1.alloc(1, 0);
  function ie(ge) {
    let oe = 0;
    for (; ge[oe] === 0; ) ++oe;
    return oe === ge.length ? ae : (ge = ge.slice(oe), ge[0] & 128 ? Buffer$1.concat([ae, ge], 1 + ge.length) : ge);
  }
  function se(ge) {
    ge[0] === 0 && (ge = ge.slice(1));
    const oe = Buffer$1.alloc(32, 0), Ee = Math.max(0, 32 - ge.length);
    return ge.copy(oe, Ee), oe;
  }
  function le(ge) {
    const oe = ge.readUInt8(ge.length - 1);
    if (!(0, z.isDefinedHashType)(oe))
      throw new Error("Invalid hashType " + oe);
    const Ee = B.decode(ge.slice(0, -1)), Ce = se(Ee.r), Pe = se(Ee.s);
    return { signature: Buffer$1.concat([Ce, Pe], 64), hashType: oe };
  }
  script_signature.decode = le;
  function ve(ge, oe) {
    if (ne(
      {
        signature: Y.BufferN(64),
        hashType: Y.UInt8
      },
      { signature: ge, hashType: oe }
    ), !(0, z.isDefinedHashType)(oe))
      throw new Error("Invalid hashType " + oe);
    const Ee = Buffer$1.allocUnsafe(1);
    Ee.writeUInt8(oe, 0);
    const Ce = ie(ge.slice(0, 32)), Pe = ie(ge.slice(32, 64));
    return Buffer$1.concat([B.encode(Ce, Pe), Ee]);
  }
  return script_signature.encode = ve, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const z = bip66, Y = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return Y.OPS;
      }
    });
    const ne = push_data, ae = script_number, ie = requireScript_signature(), se = types$4, { typeforce: le } = se, ve = Y.OPS.OP_RESERVED;
    function ge(Ct) {
      return se.Number(Ct) && (Ct === Y.OPS.OP_0 || Ct >= Y.OPS.OP_1 && Ct <= Y.OPS.OP_16 || Ct === Y.OPS.OP_1NEGATE);
    }
    function oe(Ct) {
      return se.Buffer(Ct) || ge(Ct);
    }
    function Ee(Ct) {
      return se.Array(Ct) && Ct.every(oe);
    }
    B.isPushOnly = Ee;
    function Ce(Ct) {
      return Ct.length - Ct.filter(oe).length;
    }
    B.countNonPushOnlyOPs = Ce;
    function Pe(Ct) {
      if (Ct.length === 0) return Y.OPS.OP_0;
      if (Ct.length === 1) {
        if (Ct[0] >= 1 && Ct[0] <= 16) return ve + Ct[0];
        if (Ct[0] === 129) return Y.OPS.OP_1NEGATE;
      }
    }
    function Ve(Ct) {
      return Buffer$1.isBuffer(Ct);
    }
    function ht(Ct) {
      return se.Array(Ct);
    }
    function vt(Ct) {
      return Buffer$1.isBuffer(Ct);
    }
    function Pt(Ct) {
      if (Ve(Ct)) return Ct;
      le(se.Array, Ct);
      const Kt = Ct.reduce((Xe, Ke) => vt(Ke) ? Ke.length === 1 && Pe(Ke) !== void 0 ? Xe + 1 : Xe + ne.encodingLength(Ke.length) + Ke.length : Xe + 1, 0), Nt = Buffer$1.allocUnsafe(Kt);
      let Je = 0;
      if (Ct.forEach((Xe) => {
        if (vt(Xe)) {
          const Ke = Pe(Xe);
          if (Ke !== void 0) {
            Nt.writeUInt8(Ke, Je), Je += 1;
            return;
          }
          Je += ne.encode(Nt, Xe.length, Je), Xe.copy(Nt, Je), Je += Xe.length;
        } else
          Nt.writeUInt8(Xe, Je), Je += 1;
      }), Je !== Nt.length) throw new Error("Could not decode chunks");
      return Nt;
    }
    B.compile = Pt;
    function _t(Ct) {
      if (ht(Ct)) return Ct;
      le(se.Buffer, Ct);
      const Kt = [];
      let Nt = 0;
      for (; Nt < Ct.length; ) {
        const Je = Ct[Nt];
        if (Je > Y.OPS.OP_0 && Je <= Y.OPS.OP_PUSHDATA4) {
          const Xe = ne.decode(Ct, Nt);
          if (Xe === null || (Nt += Xe.size, Nt + Xe.number > Ct.length)) return null;
          const Ke = Ct.slice(Nt, Nt + Xe.number);
          Nt += Xe.number;
          const Qe = Pe(Ke);
          Qe !== void 0 ? Kt.push(Qe) : Kt.push(Ke);
        } else
          Kt.push(Je), Nt += 1;
      }
      return Kt;
    }
    B.decompile = _t;
    function kt(Ct) {
      if (Ve(Ct) && (Ct = _t(Ct)), !Ct)
        throw new Error("Could not convert invalid chunks to ASM");
      return Ct.map((Kt) => {
        if (vt(Kt)) {
          const Nt = Pe(Kt);
          if (Nt === void 0) return Kt.toString("hex");
          Kt = Nt;
        }
        return Y.REVERSE_OPS[Kt];
      }).join(" ");
    }
    B.toASM = kt;
    function Ot(Ct) {
      return le(se.String, Ct), Pt(
        Ct.split(" ").map((Kt) => Y.OPS[Kt] !== void 0 ? Y.OPS[Kt] : (le(se.Hex, Kt), Buffer$1.from(Kt, "hex")))
      );
    }
    B.fromASM = Ot;
    function Ht(Ct) {
      return Ct = _t(Ct), le(Ee, Ct), Ct.map((Kt) => vt(Kt) ? Kt : Kt === Y.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : ae.encode(Kt - ve));
    }
    B.toStack = Ht;
    function jt(Ct) {
      return se.isPoint(Ct);
    }
    B.isCanonicalPubKey = jt;
    function Yt(Ct) {
      const Kt = Ct & -129;
      return Kt > 0 && Kt < 4;
    }
    B.isDefinedHashType = Yt;
    function Dt(Ct) {
      return !Buffer$1.isBuffer(Ct) || !Yt(Ct[Ct.length - 1]) ? !1 : z.check(Ct.slice(0, -1));
    }
    B.isCanonicalScriptSignature = Dt, B.number = ae, B.signature = ie;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, z, Y) {
  Object.defineProperty(B, z, {
    configurable: !0,
    enumerable: !0,
    get() {
      const ne = Y.call(this);
      return this[z] = ne, ne;
    },
    set(ne) {
      Object.defineProperty(this, z, {
        configurable: !0,
        enumerable: !0,
        value: ne,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let z;
  return () => (z !== void 0 || (z = B()), z);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, z) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const ne = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(ne, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(ne, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), z.validate && B.output) {
    const ae = bscript$9.decompile(B.output);
    if (ae[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!ae.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, ne.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(ne, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, z) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {});
  function Y(ve) {
    return bscript$8.isCanonicalScriptSignature(ve) || (z.allowIncomplete && ve === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(Y)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const ae = { network: B.network || networks_1$6.bitcoin };
  let ie = [], se = !1;
  function le(ve) {
    se || (se = !0, ie = bscript$8.decompile(ve), ae.m = ie[0] - OP_INT_BASE, ae.n = ie[ie.length - 2] - OP_INT_BASE, ae.pubkeys = ie.slice(1, -2));
  }
  if (lazy$5.prop(ae, "output", () => {
    if (B.m && ae.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + ae.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(ae, "m", () => {
    if (ae.output)
      return le(ae.output), ae.m;
  }), lazy$5.prop(ae, "n", () => {
    if (ae.pubkeys)
      return ae.pubkeys.length;
  }), lazy$5.prop(ae, "pubkeys", () => {
    if (B.output)
      return le(B.output), ae.pubkeys;
  }), lazy$5.prop(ae, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(ae, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(ae, "witness", () => {
    if (ae.input)
      return [];
  }), lazy$5.prop(ae, "name", () => {
    if (!(!ae.m || !ae.n))
      return `p2ms(${ae.m} of ${ae.n})`;
  }), z.validate) {
    if (B.output) {
      if (le(B.output), !types_1$6.typeforce.Number(ie[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(ie[ie.length - 2]))
        throw new TypeError("Output is invalid");
      if (ie[ie.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (ae.m <= 0 || ae.n > 16 || ae.m > ae.n || ae.n !== ie.length - 3)
        throw new TypeError("Output is invalid");
      if (!ae.pubkeys.every((ve) => (0, types_1$6.isPoint)(ve)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== ae.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== ae.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, ae.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (ae.n = B.pubkeys.length, ae.n < ae.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < ae.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > ae.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (ae.signatures.length === 0 || !ae.signatures.every(Y))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, ae.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(ae, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, z) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$4.value(() => bscript$7.decompile(B.input)), ae = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(ae, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(ae, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(ae, "signature", () => {
    if (B.input)
      return Y()[0];
  }), lazy$4.prop(ae, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(ae, "witness", () => {
    if (ae.input)
      return [];
  }), z.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(ae.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(ae.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(ae.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (Y().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(ae.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(ae, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, z) => z)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let z of [idxL, idxR])
    z.push(z[B].map((Y) => Rho[Y]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, z) => B.map((Y) => shifts[z][Y])), shiftsR = /* @__PURE__ */ idxR.map((B, z) => B.map((Y) => shifts[z][Y])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(B, z, Y, ne) {
  return B === 0 ? z ^ Y ^ ne : B === 1 ? z & Y | ~z & ne : B === 2 ? (z | ~Y) ^ ne : B === 3 ? z & ne | Y & ~ne : z ^ (Y | ~ne);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: z, h1: Y, h2: ne, h3: ae, h4: ie } = this;
    return [z, Y, ne, ae, ie];
  }
  set(z, Y, ne, ae, ie) {
    this.h0 = z | 0, this.h1 = Y | 0, this.h2 = ne | 0, this.h3 = ae | 0, this.h4 = ie | 0;
  }
  process(z, Y) {
    for (let Pe = 0; Pe < 16; Pe++, Y += 4)
      R_BUF[Pe] = z.getUint32(Y, !0);
    let ne = this.h0 | 0, ae = ne, ie = this.h1 | 0, se = ie, le = this.h2 | 0, ve = le, ge = this.h3 | 0, oe = ge, Ee = this.h4 | 0, Ce = Ee;
    for (let Pe = 0; Pe < 5; Pe++) {
      const Ve = 4 - Pe, ht = Kl[Pe], vt = Kr[Pe], Pt = idxL[Pe], _t = idxR[Pe], kt = shiftsL[Pe], Ot = shiftsR[Pe];
      for (let Ht = 0; Ht < 16; Ht++) {
        const jt = (0, utils_js_1$1.rotl)(ne + f(Pe, ie, le, ge) + R_BUF[Pt[Ht]] + ht, kt[Ht]) + Ee | 0;
        ne = Ee, Ee = ge, ge = (0, utils_js_1$1.rotl)(le, 10) | 0, le = ie, ie = jt;
      }
      for (let Ht = 0; Ht < 16; Ht++) {
        const jt = (0, utils_js_1$1.rotl)(ae + f(Ve, se, ve, oe) + R_BUF[_t[Ht]] + vt, Ot[Ht]) + Ce | 0;
        ae = Ce, Ce = oe, oe = (0, utils_js_1$1.rotl)(ve, 10) | 0, ve = se, se = jt;
      }
    }
    this.set(this.h1 + le + oe | 0, this.h2 + ge + Ce | 0, this.h3 + Ee + ae | 0, this.h4 + ne + se | 0, this.h0 + ie + ve | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: ae, E: ie } = this;
    return [z, Y, ne, ae, ie];
  }
  set(z, Y, ne, ae, ie) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = ae | 0, this.E = ie | 0;
  }
  process(z, Y) {
    for (let ve = 0; ve < 16; ve++, Y += 4)
      SHA1_W[ve] = z.getUint32(Y, !1);
    for (let ve = 16; ve < 80; ve++)
      SHA1_W[ve] = (0, utils_js_1.rotl)(SHA1_W[ve - 3] ^ SHA1_W[ve - 8] ^ SHA1_W[ve - 14] ^ SHA1_W[ve - 16], 1);
    let { A: ne, B: ae, C: ie, D: se, E: le } = this;
    for (let ve = 0; ve < 80; ve++) {
      let ge, oe;
      ve < 20 ? (ge = (0, _md_js_1.Chi)(ae, ie, se), oe = 1518500249) : ve < 40 ? (ge = ae ^ ie ^ se, oe = 1859775393) : ve < 60 ? (ge = (0, _md_js_1.Maj)(ae, ie, se), oe = 2400959708) : (ge = ae ^ ie ^ se, oe = 3395469782);
      const Ee = (0, utils_js_1.rotl)(ne, 5) + ge + le + oe + SHA1_W[ve] | 0;
      le = se, se = ie, ie = (0, utils_js_1.rotl)(ae, 30), ae = ne, ne = Ee;
    }
    ne = ne + this.A | 0, ae = ae + this.B | 0, ie = ie + this.C | 0, se = se + this.D | 0, le = le + this.E | 0, this.set(ne, ae, ie, se, le);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const z = ripemd160, Y = sha1, ne = sha256$4;
  function ae(oe) {
    return Buffer$1.from((0, z.ripemd160)(Uint8Array.from(oe)));
  }
  B.ripemd160 = ae;
  function ie(oe) {
    return Buffer$1.from((0, Y.sha1)(Uint8Array.from(oe)));
  }
  B.sha1 = ie;
  function se(oe) {
    return Buffer$1.from((0, ne.sha256)(Uint8Array.from(oe)));
  }
  B.sha256 = se;
  function le(oe) {
    return Buffer$1.from(
      (0, z.ripemd160)((0, ne.sha256)(Uint8Array.from(oe)))
    );
  }
  B.hash160 = le;
  function ve(oe) {
    return Buffer$1.from(
      (0, ne.sha256)((0, ne.sha256)(Uint8Array.from(oe)))
    );
  }
  B.hash256 = ve, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function ge(oe, Ee) {
    return se(Buffer$1.concat([B.TAGGED_HASH_PREFIXES[oe], Ee]));
  }
  B.taggedHash = ge;
})(crypto$1);
function base$1(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var z = new Uint8Array(256), Y = 0; Y < z.length; Y++)
    z[Y] = 255;
  for (var ne = 0; ne < B.length; ne++) {
    var ae = B.charAt(ne), ie = ae.charCodeAt(0);
    if (z[ie] !== 255)
      throw new TypeError(ae + " is ambiguous");
    z[ie] = ne;
  }
  var se = B.length, le = B.charAt(0), ve = Math.log(se) / Math.log(256), ge = Math.log(256) / Math.log(se);
  function oe(Pe) {
    if (Pe instanceof Uint8Array || (ArrayBuffer.isView(Pe) ? Pe = new Uint8Array(Pe.buffer, Pe.byteOffset, Pe.byteLength) : Array.isArray(Pe) && (Pe = Uint8Array.from(Pe))), !(Pe instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Pe.length === 0)
      return "";
    for (var Ve = 0, ht = 0, vt = 0, Pt = Pe.length; vt !== Pt && Pe[vt] === 0; )
      vt++, Ve++;
    for (var _t = (Pt - vt) * ge + 1 >>> 0, kt = new Uint8Array(_t); vt !== Pt; ) {
      for (var Ot = Pe[vt], Ht = 0, jt = _t - 1; (Ot !== 0 || Ht < ht) && jt !== -1; jt--, Ht++)
        Ot += 256 * kt[jt] >>> 0, kt[jt] = Ot % se >>> 0, Ot = Ot / se >>> 0;
      if (Ot !== 0)
        throw new Error("Non-zero carry");
      ht = Ht, vt++;
    }
    for (var Yt = _t - ht; Yt !== _t && kt[Yt] === 0; )
      Yt++;
    for (var Dt = le.repeat(Ve); Yt < _t; ++Yt)
      Dt += B.charAt(kt[Yt]);
    return Dt;
  }
  function Ee(Pe) {
    if (typeof Pe != "string")
      throw new TypeError("Expected String");
    if (Pe.length === 0)
      return new Uint8Array();
    for (var Ve = 0, ht = 0, vt = 0; Pe[Ve] === le; )
      ht++, Ve++;
    for (var Pt = (Pe.length - Ve) * ve + 1 >>> 0, _t = new Uint8Array(Pt); Pe[Ve]; ) {
      var kt = z[Pe.charCodeAt(Ve)];
      if (kt === 255)
        return;
      for (var Ot = 0, Ht = Pt - 1; (kt !== 0 || Ot < vt) && Ht !== -1; Ht--, Ot++)
        kt += se * _t[Ht] >>> 0, _t[Ht] = kt % 256 >>> 0, kt = kt / 256 >>> 0;
      if (kt !== 0)
        throw new Error("Non-zero carry");
      vt = Ot, Ve++;
    }
    for (var jt = Pt - vt; jt !== Pt && _t[jt] === 0; )
      jt++;
    for (var Yt = new Uint8Array(ht + (Pt - jt)), Dt = ht; jt !== Pt; )
      Yt[Dt++] = _t[jt++];
    return Yt;
  }
  function Ce(Pe) {
    var Ve = Ee(Pe);
    if (Ve)
      return Ve;
    throw new Error("Non-base" + se + " character");
  }
  return {
    encode: oe,
    decodeUnsafe: Ee,
    decode: Ce
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(B) {
  function z(ie) {
    var se = Uint8Array.from(ie), le = B(se), ve = se.length + 4, ge = new Uint8Array(ve);
    return ge.set(se, 0), ge.set(le.subarray(0, 4), se.length), base58.encode(ge, ve);
  }
  function Y(ie) {
    var se = ie.slice(0, -4), le = ie.slice(-4), ve = B(se);
    if (!(le[0] ^ ve[0] | le[1] ^ ve[1] | le[2] ^ ve[2] | le[3] ^ ve[3]))
      return se;
  }
  function ne(ie) {
    var se = base58.decodeUnsafe(ie);
    if (se)
      return Y(se);
  }
  function ae(ie) {
    var se = base58.decode(ie), le = Y(se);
    if (!le) throw new Error("Invalid checksum");
    return le;
  }
  return {
    encode: z,
    decode: ae,
    decodeUnsafe: ne
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(B) {
  return sha256(sha256(B));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$3.value(() => {
    const se = Buffer$1.from(bs58check$1.decode(B.address)), le = se.readUInt8(0), ve = se.slice(1);
    return { version: le, hash: ve };
  }), ne = lazy$3.value(() => bscript$6.decompile(B.input)), ae = B.network || networks_1$4.bitcoin, ie = { name: "p2pkh", network: ae };
  if (lazy$3.prop(ie, "address", () => {
    if (!ie.hash) return;
    const se = Buffer$1.allocUnsafe(21);
    return se.writeUInt8(ae.pubKeyHash, 0), ie.hash.copy(se, 1), bs58check$1.encode(se);
  }), lazy$3.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return Y().hash;
    if (B.pubkey || ie.pubkey) return bcrypto$5.hash160(B.pubkey || ie.pubkey);
  }), lazy$3.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        ie.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(ie, "pubkey", () => {
    if (B.input)
      return ne()[1];
  }), lazy$3.prop(ie, "signature", () => {
    if (B.input)
      return ne()[0];
  }), lazy$3.prop(ie, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(ie, "witness", () => {
    if (ie.input)
      return [];
  }), z.validate) {
    let se = Buffer$1.from([]);
    if (B.address) {
      if (Y().version !== ae.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (Y().hash.length !== 20) throw new TypeError("Invalid address");
      se = Y().hash;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const le = B.output.slice(3, 23);
      if (se.length > 0 && !se.equals(le))
        throw new TypeError("Hash mismatch");
      se = le;
    }
    if (B.pubkey) {
      const le = bcrypto$5.hash160(B.pubkey);
      if (se.length > 0 && !se.equals(le))
        throw new TypeError("Hash mismatch");
      se = le;
    }
    if (B.input) {
      const le = ne();
      if (le.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(le[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(le[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(le[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(le[1]))
        throw new TypeError("Pubkey mismatch");
      const ve = bcrypto$5.hash160(le[1]);
      if (se.length > 0 && !se.equals(ve))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ie, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let Y = B.network;
  Y || (Y = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const ne = { network: Y }, ae = lazy$2.value(() => {
    const le = Buffer$1.from(bs58check.decode(B.address)), ve = le.readUInt8(0), ge = le.slice(1);
    return { version: ve, hash: ge };
  }), ie = lazy$2.value(() => bscript$5.decompile(B.input)), se = lazy$2.value(() => {
    const le = ie(), ve = le[le.length - 1];
    return {
      network: Y,
      output: ve === OPS$2.OP_FALSE ? Buffer$1.from([]) : ve,
      input: bscript$5.compile(le.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(ne, "address", () => {
    if (!ne.hash) return;
    const le = Buffer$1.allocUnsafe(21);
    return le.writeUInt8(ne.network.scriptHash, 0), ne.hash.copy(le, 1), bs58check.encode(le);
  }), lazy$2.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return ae().hash;
    if (ne.redeem && ne.redeem.output) return bcrypto$4.hash160(ne.redeem.output);
  }), lazy$2.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, ne.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(ne, "redeem", () => {
    if (B.input)
      return se();
  }), lazy$2.prop(ne, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(ne, "witness", () => {
    if (ne.redeem && ne.redeem.witness) return ne.redeem.witness;
    if (ne.input) return [];
  }), lazy$2.prop(ne, "name", () => {
    const le = ["p2sh"];
    return ne.redeem !== void 0 && ne.redeem.name !== void 0 && le.push(ne.redeem.name), le.join("-");
  }), z.validate) {
    let le = Buffer$1.from([]);
    if (B.address) {
      if (ae().version !== Y.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (ae().hash.length !== 20) throw new TypeError("Invalid address");
      le = ae().hash;
    }
    if (B.hash) {
      if (le.length > 0 && !le.equals(B.hash))
        throw new TypeError("Hash mismatch");
      le = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const ge = B.output.slice(2, 22);
      if (le.length > 0 && !le.equals(ge))
        throw new TypeError("Hash mismatch");
      le = ge;
    }
    const ve = (ge) => {
      if (ge.output) {
        const oe = bscript$5.decompile(ge.output);
        if (!oe || oe.length < 1)
          throw new TypeError("Redeem.output too short");
        if (ge.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(oe) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const Ee = bcrypto$4.hash160(ge.output);
        if (le.length > 0 && !le.equals(Ee))
          throw new TypeError("Hash mismatch");
        le = Ee;
      }
      if (ge.input) {
        const oe = ge.input.length > 0, Ee = ge.witness && ge.witness.length > 0;
        if (!oe && !Ee) throw new TypeError("Empty input");
        if (oe && Ee)
          throw new TypeError("Input and witness provided");
        if (oe) {
          const Ce = bscript$5.decompile(ge.input);
          if (!bscript$5.isPushOnly(Ce))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const ge = ie();
      if (!ge || ge.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(se().output))
        throw new TypeError("Input is invalid");
      ve(se());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== Y)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const ge = se();
        if (B.redeem.output && !B.redeem.output.equals(ge.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(ge.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ve(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(ne, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET.length; B++) {
  const z = ALPHABET.charAt(B);
  ALPHABET_MAP[z] = B;
}
function polymodStep(B) {
  const z = B >> 25;
  return (B & 33554431) << 5 ^ -(z >> 0 & 1) & 996825010 ^ -(z >> 1 & 1) & 642813549 ^ -(z >> 2 & 1) & 513874426 ^ -(z >> 3 & 1) & 1027748829 ^ -(z >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let z = 1;
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    if (ne < 33 || ne > 126)
      return "Invalid prefix (" + B + ")";
    z = polymodStep(z) ^ ne >> 5;
  }
  z = polymodStep(z);
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    z = polymodStep(z) ^ ne & 31;
  }
  return z;
}
function convert$2(B, z, Y, ne) {
  let ae = 0, ie = 0;
  const se = (1 << Y) - 1, le = [];
  for (let ve = 0; ve < B.length; ++ve)
    for (ae = ae << z | B[ve], ie += z; ie >= Y; )
      ie -= Y, le.push(ae >> ie & se);
  if (ne)
    ie > 0 && le.push(ae << Y - ie & se);
  else {
    if (ie >= z)
      return "Excess padding";
    if (ae << Y - ie & se)
      return "Non-zero padding";
  }
  return le;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
}
function fromWords(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
  throw new Error(z);
}
function getLibraryFromEncoding(B) {
  let z;
  B === "bech32" ? z = 1 : z = 734539939;
  function Y(se, le, ve) {
    if (ve = ve || 90, se.length + 7 + le.length > ve)
      throw new TypeError("Exceeds length limit");
    se = se.toLowerCase();
    let ge = prefixChk(se);
    if (typeof ge == "string")
      throw new Error(ge);
    let oe = se + "1";
    for (let Ee = 0; Ee < le.length; ++Ee) {
      const Ce = le[Ee];
      if (Ce >> 5)
        throw new Error("Non 5-bit word");
      ge = polymodStep(ge) ^ Ce, oe += ALPHABET.charAt(Ce);
    }
    for (let Ee = 0; Ee < 6; ++Ee)
      ge = polymodStep(ge);
    ge ^= z;
    for (let Ee = 0; Ee < 6; ++Ee) {
      const Ce = ge >> (5 - Ee) * 5 & 31;
      oe += ALPHABET.charAt(Ce);
    }
    return oe;
  }
  function ne(se, le) {
    if (le = le || 90, se.length < 8)
      return se + " too short";
    if (se.length > le)
      return "Exceeds length limit";
    const ve = se.toLowerCase(), ge = se.toUpperCase();
    if (se !== ve && se !== ge)
      return "Mixed-case string " + se;
    se = ve;
    const oe = se.lastIndexOf("1");
    if (oe === -1)
      return "No separator character for " + se;
    if (oe === 0)
      return "Missing prefix for " + se;
    const Ee = se.slice(0, oe), Ce = se.slice(oe + 1);
    if (Ce.length < 6)
      return "Data too short";
    let Pe = prefixChk(Ee);
    if (typeof Pe == "string")
      return Pe;
    const Ve = [];
    for (let ht = 0; ht < Ce.length; ++ht) {
      const vt = Ce.charAt(ht), Pt = ALPHABET_MAP[vt];
      if (Pt === void 0)
        return "Unknown character " + vt;
      Pe = polymodStep(Pe) ^ Pt, !(ht + 6 >= Ce.length) && Ve.push(Pt);
    }
    return Pe !== z ? "Invalid checksum for " + se : { prefix: Ee, words: Ve };
  }
  function ae(se, le) {
    const ve = ne(se, le);
    if (typeof ve == "object")
      return ve;
  }
  function ie(se, le) {
    const ve = ne(se, le);
    if (typeof ve == "object")
      return ve;
    throw new Error(ve);
  }
  return {
    decodeUnsafe: ae,
    decode: ie,
    encode: Y,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy$1.value(() => {
    const ie = bech32_1$1.bech32.decode(B.address), se = ie.words.shift(), le = bech32_1$1.bech32.fromWords(ie.words);
    return {
      version: se,
      prefix: ie.prefix,
      data: Buffer$1.from(le)
    };
  }), ne = B.network || networks_1$2.bitcoin, ae = { name: "p2wpkh", network: ne };
  if (lazy$1.prop(ae, "address", () => {
    if (!ae.hash) return;
    const ie = bech32_1$1.bech32.toWords(ae.hash);
    return ie.unshift(0), bech32_1$1.bech32.encode(ne.bech32, ie);
  }), lazy$1.prop(ae, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return Y().data;
    if (B.pubkey || ae.pubkey) return bcrypto$3.hash160(B.pubkey || ae.pubkey);
  }), lazy$1.prop(ae, "output", () => {
    if (ae.hash)
      return bscript$4.compile([OPS$1.OP_0, ae.hash]);
  }), lazy$1.prop(ae, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(ae, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(ae, "input", () => {
    if (ae.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(ae, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), z.validate) {
    let ie = Buffer$1.from([]);
    if (B.address) {
      if (ne && ne.bech32 !== Y().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 20)
        throw new TypeError("Invalid address data");
      ie = Y().data;
    }
    if (B.hash) {
      if (ie.length > 0 && !ie.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ie = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (ie.length > 0 && !ie.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      ie = B.output.slice(2);
    }
    if (B.pubkey) {
      const se = bcrypto$3.hash160(B.pubkey);
      if (ie.length > 0 && !ie.equals(se))
        throw new TypeError("Hash mismatch");
      if (ie = se, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const se = bcrypto$3.hash160(B.witness[1]);
      if (ie.length > 0 && !ie.equals(se))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ae, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$1.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy.value(() => {
    const se = bech32_1.bech32.decode(B.address), le = se.words.shift(), ve = bech32_1.bech32.fromWords(se.words);
    return {
      version: le,
      prefix: se.prefix,
      data: Buffer$1.from(ve)
    };
  }), ne = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let ae = B.network;
  ae || (ae = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const ie = { network: ae };
  if (lazy.prop(ie, "address", () => {
    if (!ie.hash) return;
    const se = bech32_1.bech32.toWords(ie.hash);
    return se.unshift(0), bech32_1.bech32.encode(ae.bech32, se);
  }), lazy.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return Y().data;
    if (ie.redeem && ie.redeem.output) return bcrypto$2.sha256(ie.redeem.output);
  }), lazy.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$3.compile([OPS.OP_0, ie.hash]);
  }), lazy.prop(ie, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(ie, "input", () => {
    if (ie.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(ie, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const se = bscript$3.toStack(ne());
      return ie.redeem = Object.assign({ witness: se }, B.redeem), ie.redeem.input = EMPTY_BUFFER$1, [].concat(se, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(ie, "name", () => {
    const se = ["p2wsh"];
    return ie.redeem !== void 0 && ie.redeem.name !== void 0 && se.push(ie.redeem.name), se.join("-");
  }), z.validate) {
    let se = Buffer$1.from([]);
    if (B.address) {
      if (Y().prefix !== ae.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 32)
        throw new TypeError("Invalid address data");
      se = Y().data;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const le = B.output.slice(2);
      if (se.length > 0 && !se.equals(le))
        throw new TypeError("Hash mismatch");
      se = le;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== ae)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const le = bscript$3.decompile(B.redeem.output);
        if (!le || le.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(le) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ve = bcrypto$2.sha256(B.redeem.output);
        if (se.length > 0 && !se.equals(ve))
          throw new TypeError("Hash mismatch");
        se = ve;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(ne()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && ne().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const le = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(le))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(le) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(ie, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (B) => Buffer$1.from(B, "hex");
function verifyEcc(B) {
  assert(typeof B.isXOnlyPoint == "function"), assert(
    B.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    B.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((z) => {
    const Y = B.xOnlyPointAddTweak(h(z.pubkey), h(z.tweak));
    z.result === null ? assert(Y === null) : (assert(Y !== null), assert(Y.parity === z.parity), assert(Buffer$1.from(Y.xOnlyPubkey).equals(h(z.result))));
  });
}
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(B, z, Y) {
  if (checkUInt53$1(B), z || (z = Buffer.allocUnsafe(encodingLength$1(B))), !Buffer.isBuffer(z)) throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), encode$f.bytes = 1) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), encode$f.bytes = 3) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), encode$f.bytes = 5) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), encode$f.bytes = 9), z;
}
function decode$e(B, z) {
  if (!Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  var Y = B.readUInt8(z);
  if (Y < 253)
    return decode$e.bytes = 1, Y;
  if (Y === 253)
    return decode$e.bytes = 3, B.readUInt16LE(z + 1);
  if (Y === 254)
    return decode$e.bytes = 5, B.readUInt32LE(z + 1);
  decode$e.bytes = 9;
  var ne = B.readUInt32LE(z + 1), ae = B.readUInt32LE(z + 5), ie = ae * 4294967296 + ne;
  return checkUInt53$1(ie), ie;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint$1(ne + Y, 9007199254740991), ne + Y;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, z, Y) {
  return verifuint$1(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(B) {
  const z = Buffer$1.allocUnsafe(B.length);
  return B.copy(z), z;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(z) {
    return new BufferWriter(Buffer$1.alloc(z));
  }
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  writeUInt8(z) {
    this.offset = this.buffer.writeUInt8(z, this.offset);
  }
  writeInt32(z) {
    this.offset = this.buffer.writeInt32LE(z, this.offset);
  }
  writeUInt32(z) {
    this.offset = this.buffer.writeUInt32LE(z, this.offset);
  }
  writeUInt64(z) {
    this.offset = writeUInt64LE$1(this.buffer, z, this.offset);
  }
  writeVarInt(z) {
    varuint$7.encode(z, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(z) {
    if (this.buffer.length < this.offset + z.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += z.copy(this.buffer, this.offset);
  }
  writeVarSlice(z) {
    this.writeVarInt(z.length), this.writeSlice(z);
  }
  writeVector(z) {
    this.writeVarInt(z.length), z.forEach((Y) => this.writeVarSlice(Y));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  readUInt8() {
    const z = this.buffer.readUInt8(this.offset);
    return this.offset++, z;
  }
  readInt32() {
    const z = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt32() {
    const z = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt64() {
    const z = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, z;
  }
  readVarInt() {
    const z = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, z;
  }
  readSlice(z) {
    if (this.buffer.length < this.offset + z)
      throw new Error("Cannot read slice out of bounds");
    const Y = this.buffer.slice(this.offset, this.offset + z);
    return this.offset += z, Y;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const z = this.readVarInt(), Y = [];
    for (let ne = 0; ne < z; ne++) Y.push(this.readVarSlice());
    return Y;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const z = require$$0$1, Y = ecc_lib, ne = crypto$1, ae = bufferutils, ie = types$4;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const se = (ht) => "left" in ht && "right" in ht;
  function le(ht, vt) {
    if (ht.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${ht.length}, expected min 33.`
      );
    const Pt = (ht.length - 33) / 32;
    let _t = vt;
    for (let kt = 0; kt < Pt; kt++) {
      const Ot = ht.slice(33 + 32 * kt, 65 + 32 * kt);
      _t.compare(Ot) < 0 ? _t = Pe(_t, Ot) : _t = Pe(Ot, _t);
    }
    return _t;
  }
  B.rootHashFromPath = le;
  function ve(ht) {
    if ((0, ie.isTapleaf)(ht))
      return { hash: oe(ht) };
    const vt = [ve(ht[0]), ve(ht[1])];
    vt.sort((kt, Ot) => kt.hash.compare(Ot.hash));
    const [Pt, _t] = vt;
    return {
      hash: Pe(Pt.hash, _t.hash),
      left: Pt,
      right: _t
    };
  }
  B.toHashTree = ve;
  function ge(ht, vt) {
    if (se(ht)) {
      const Pt = ge(ht.left, vt);
      if (Pt !== void 0) return [...Pt, ht.right.hash];
      const _t = ge(ht.right, vt);
      if (_t !== void 0) return [..._t, ht.left.hash];
    } else if (ht.hash.equals(vt))
      return [];
  }
  B.findScriptPath = ge;
  function oe(ht) {
    const vt = ht.version || B.LEAF_VERSION_TAPSCRIPT;
    return ne.taggedHash(
      "TapLeaf",
      z.Buffer.concat([
        z.Buffer.from([vt]),
        Ve(ht.output)
      ])
    );
  }
  B.tapleafHash = oe;
  function Ee(ht, vt) {
    return ne.taggedHash(
      "TapTweak",
      z.Buffer.concat(vt ? [ht, vt] : [ht])
    );
  }
  B.tapTweakHash = Ee;
  function Ce(ht, vt) {
    if (!z.Buffer.isBuffer(ht) || ht.length !== 32 || vt && vt.length !== 32) return null;
    const Pt = Ee(ht, vt), _t = (0, Y.getEccLib)().xOnlyPointAddTweak(ht, Pt);
    return !_t || _t.xOnlyPubkey === null ? null : {
      parity: _t.parity,
      x: z.Buffer.from(_t.xOnlyPubkey)
    };
  }
  B.tweakKey = Ce;
  function Pe(ht, vt) {
    return ne.taggedHash("TapBranch", z.Buffer.concat([ht, vt]));
  }
  function Ve(ht) {
    const vt = ae.varuint.encodingLength(ht.length), Pt = z.Buffer.allocUnsafe(vt);
    return ae.varuint.encode(ht.length, Pt), z.Buffer.concat([Pt, ht]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = require$$0$1, z = networks, Y = requireScript(), ne = types$4, ae = ecc_lib, ie = bip341, se = lazy$7, le = dist, ve = requireAddress(), ge = Y.OPS, oe = 1, Ee = 80;
  function Ce(Pe, Ve) {
    if (!Pe.address && !Pe.output && !Pe.pubkey && !Pe.internalPubkey && !(Pe.witness && Pe.witness.length > 1))
      throw new TypeError("Not enough data");
    Ve = Object.assign({ validate: !0 }, Ve || {}), (0, ne.typeforce)(
      {
        address: ne.typeforce.maybe(ne.typeforce.String),
        input: ne.typeforce.maybe(ne.typeforce.BufferN(0)),
        network: ne.typeforce.maybe(ne.typeforce.Object),
        output: ne.typeforce.maybe(ne.typeforce.BufferN(34)),
        internalPubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        hash: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        pubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        signature: ne.typeforce.maybe(
          ne.typeforce.anyOf(
            ne.typeforce.BufferN(64),
            ne.typeforce.BufferN(65)
          )
        ),
        witness: ne.typeforce.maybe(
          ne.typeforce.arrayOf(ne.typeforce.Buffer)
        ),
        scriptTree: ne.typeforce.maybe(ne.isTaptree),
        redeem: ne.typeforce.maybe({
          output: ne.typeforce.maybe(ne.typeforce.Buffer),
          redeemVersion: ne.typeforce.maybe(ne.typeforce.Number),
          witness: ne.typeforce.maybe(
            ne.typeforce.arrayOf(ne.typeforce.Buffer)
          )
        }),
        redeemVersion: ne.typeforce.maybe(ne.typeforce.Number)
      },
      Pe
    );
    const ht = se.value(() => (0, ve.fromBech32)(Pe.address)), vt = se.value(() => {
      if (!(!Pe.witness || !Pe.witness.length))
        return Pe.witness.length >= 2 && Pe.witness[Pe.witness.length - 1][0] === Ee ? Pe.witness.slice(0, -1) : Pe.witness.slice();
    }), Pt = se.value(() => {
      if (Pe.scriptTree) return (0, ie.toHashTree)(Pe.scriptTree);
      if (Pe.hash) return { hash: Pe.hash };
    }), _t = Pe.network || z.bitcoin, kt = { name: "p2tr", network: _t };
    if (se.prop(kt, "address", () => {
      if (!kt.pubkey) return;
      const Ot = le.bech32m.toWords(kt.pubkey);
      return Ot.unshift(oe), le.bech32m.encode(_t.bech32, Ot);
    }), se.prop(kt, "hash", () => {
      const Ot = Pt();
      if (Ot) return Ot.hash;
      const Ht = vt();
      if (Ht && Ht.length > 1) {
        const jt = Ht[Ht.length - 1], Yt = jt[0] & ne.TAPLEAF_VERSION_MASK, Dt = Ht[Ht.length - 2], Ct = (0, ie.tapleafHash)({
          output: Dt,
          version: Yt
        });
        return (0, ie.rootHashFromPath)(jt, Ct);
      }
      return null;
    }), se.prop(kt, "output", () => {
      if (kt.pubkey)
        return Y.compile([ge.OP_1, kt.pubkey]);
    }), se.prop(kt, "redeemVersion", () => Pe.redeemVersion ? Pe.redeemVersion : Pe.redeem && Pe.redeem.redeemVersion !== void 0 && Pe.redeem.redeemVersion !== null ? Pe.redeem.redeemVersion : ie.LEAF_VERSION_TAPSCRIPT), se.prop(kt, "redeem", () => {
      const Ot = vt();
      if (!(!Ot || Ot.length < 2))
        return {
          output: Ot[Ot.length - 2],
          witness: Ot.slice(0, -2),
          redeemVersion: Ot[Ot.length - 1][0] & ne.TAPLEAF_VERSION_MASK
        };
    }), se.prop(kt, "pubkey", () => {
      if (Pe.pubkey) return Pe.pubkey;
      if (Pe.output) return Pe.output.slice(2);
      if (Pe.address) return ht().data;
      if (kt.internalPubkey) {
        const Ot = (0, ie.tweakKey)(kt.internalPubkey, kt.hash);
        if (Ot) return Ot.x;
      }
    }), se.prop(kt, "internalPubkey", () => {
      if (Pe.internalPubkey) return Pe.internalPubkey;
      const Ot = vt();
      if (Ot && Ot.length > 1)
        return Ot[Ot.length - 1].slice(1, 33);
    }), se.prop(kt, "signature", () => {
      if (Pe.signature) return Pe.signature;
      const Ot = vt();
      if (!(!Ot || Ot.length !== 1))
        return Ot[0];
    }), se.prop(kt, "witness", () => {
      if (Pe.witness) return Pe.witness;
      const Ot = Pt();
      if (Ot && Pe.redeem && Pe.redeem.output && Pe.internalPubkey) {
        const Ht = (0, ie.tapleafHash)({
          output: Pe.redeem.output,
          version: kt.redeemVersion
        }), jt = (0, ie.findScriptPath)(Ot, Ht);
        if (!jt) return;
        const Yt = (0, ie.tweakKey)(Pe.internalPubkey, Ot.hash);
        if (!Yt) return;
        const Dt = B.Buffer.concat(
          [
            B.Buffer.from([kt.redeemVersion | Yt.parity]),
            Pe.internalPubkey
          ].concat(jt)
        );
        return [Pe.redeem.output, Dt];
      }
      if (Pe.signature) return [Pe.signature];
    }), Ve.validate) {
      let Ot = B.Buffer.from([]);
      if (Pe.address) {
        if (_t && _t.bech32 !== ht().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (ht().version !== oe)
          throw new TypeError("Invalid address version");
        if (ht().data.length !== 32)
          throw new TypeError("Invalid address data");
        Ot = ht().data;
      }
      if (Pe.pubkey) {
        if (Ot.length > 0 && !Ot.equals(Pe.pubkey))
          throw new TypeError("Pubkey mismatch");
        Ot = Pe.pubkey;
      }
      if (Pe.output) {
        if (Pe.output.length !== 34 || Pe.output[0] !== ge.OP_1 || Pe.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (Ot.length > 0 && !Ot.equals(Pe.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        Ot = Pe.output.slice(2);
      }
      if (Pe.internalPubkey) {
        const Yt = (0, ie.tweakKey)(Pe.internalPubkey, kt.hash);
        if (Ot.length > 0 && !Ot.equals(Yt.x))
          throw new TypeError("Pubkey mismatch");
        Ot = Yt.x;
      }
      if (Ot && Ot.length && !(0, ae.getEccLib)().isXOnlyPoint(Ot))
        throw new TypeError("Invalid pubkey for p2tr");
      const Ht = Pt();
      if (Pe.hash && Ht && !Pe.hash.equals(Ht.hash))
        throw new TypeError("Hash mismatch");
      if (Pe.redeem && Pe.redeem.output && Ht) {
        const Yt = (0, ie.tapleafHash)({
          output: Pe.redeem.output,
          version: kt.redeemVersion
        });
        if (!(0, ie.findScriptPath)(Ht, Yt))
          throw new TypeError("Redeem script not in tree");
      }
      const jt = vt();
      if (Pe.redeem && kt.redeem) {
        if (Pe.redeem.redeemVersion && Pe.redeem.redeemVersion !== kt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Pe.redeem.output) {
          if (Y.decompile(Pe.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (kt.redeem.output && !Pe.redeem.output.equals(kt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Pe.redeem.witness && kt.redeem.witness && !(0, ne.stacksEqual)(Pe.redeem.witness, kt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (jt && jt.length)
        if (jt.length === 1) {
          if (Pe.signature && !Pe.signature.equals(jt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Yt = jt[jt.length - 1];
          if (Yt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Yt.length}, expected min 33.`
            );
          if ((Yt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Yt.length} is incorrect!`
            );
          const Dt = (Yt.length - 33) / 32;
          if (Dt > 128)
            throw new TypeError(
              `The script path is too long. Got ${Dt}, expected max 128.`
            );
          const Ct = Yt.slice(1, 33);
          if (Pe.internalPubkey && !Pe.internalPubkey.equals(Ct))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, ae.getEccLib)().isXOnlyPoint(Ct))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Kt = Yt[0] & ne.TAPLEAF_VERSION_MASK, Nt = jt[jt.length - 2], Je = (0, ie.tapleafHash)({
            output: Nt,
            version: Kt
          }), Xe = (0, ie.rootHashFromPath)(Yt, Je), Ke = (0, ie.tweakKey)(Ct, Xe);
          if (!Ke)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (Ot.length && !Ot.equals(Ke.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (Ke.parity !== (Yt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(kt, Pe);
  }
  return p2tr.p2tr = Ce, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const z = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return z.p2data;
      }
    });
    const Y = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return Y.p2ms;
      }
    });
    const ne = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return ne.p2pk;
      }
    });
    const ae = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return ae.p2pkh;
      }
    });
    const ie = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return ie.p2sh;
      }
    });
    const se = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return se.p2wpkh;
      }
    });
    const le = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return le.p2wsh;
      }
    });
    const ve = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return ve.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks, z = requirePayments(), Y = requireScript(), ne = types$4, ae = dist, ie = bs58check$2, se = 40, le = 2, ve = 16, ge = 2, oe = 80, Ee = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Ce(kt, Ot) {
    const Ht = kt.slice(2);
    if (Ht.length < le || Ht.length > se)
      throw new TypeError("Invalid program length for segwit address");
    const jt = kt[0] - oe;
    if (jt < ge || jt > ve)
      throw new TypeError("Invalid version for segwit address");
    if (kt[1] !== Ht.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(Ee), vt(Ht, jt, Ot.bech32);
  }
  function Pe(kt) {
    const Ot = Buffer$1.from(ie.decode(kt));
    if (Ot.length < 21) throw new TypeError(kt + " is too short");
    if (Ot.length > 21) throw new TypeError(kt + " is too long");
    const Ht = Ot.readUInt8(0), jt = Ot.slice(1);
    return { version: Ht, hash: jt };
  }
  address.fromBase58Check = Pe;
  function Ve(kt) {
    let Ot, Ht;
    try {
      Ot = ae.bech32.decode(kt);
    } catch {
    }
    if (Ot) {
      if (Ht = Ot.words[0], Ht !== 0) throw new TypeError(kt + " uses wrong encoding");
    } else if (Ot = ae.bech32m.decode(kt), Ht = Ot.words[0], Ht === 0) throw new TypeError(kt + " uses wrong encoding");
    const jt = ae.bech32.fromWords(Ot.words.slice(1));
    return {
      version: Ht,
      prefix: Ot.prefix,
      data: Buffer$1.from(jt)
    };
  }
  address.fromBech32 = Ve;
  function ht(kt, Ot) {
    (0, ne.typeforce)(
      (0, ne.tuple)(ne.Hash160bit, ne.UInt8),
      arguments
    );
    const Ht = Buffer$1.allocUnsafe(21);
    return Ht.writeUInt8(Ot, 0), kt.copy(Ht, 1), ie.encode(Ht);
  }
  address.toBase58Check = ht;
  function vt(kt, Ot, Ht) {
    const jt = ae.bech32.toWords(kt);
    return jt.unshift(Ot), Ot === 0 ? ae.bech32.encode(Ht, jt) : ae.bech32m.encode(Ht, jt);
  }
  address.toBech32 = vt;
  function Pt(kt, Ot) {
    Ot = Ot || B.bitcoin;
    try {
      return z.p2pkh({ output: kt, network: Ot }).address;
    } catch {
    }
    try {
      return z.p2sh({ output: kt, network: Ot }).address;
    } catch {
    }
    try {
      return z.p2wpkh({ output: kt, network: Ot }).address;
    } catch {
    }
    try {
      return z.p2wsh({ output: kt, network: Ot }).address;
    } catch {
    }
    try {
      return z.p2tr({ output: kt, network: Ot }).address;
    } catch {
    }
    try {
      return Ce(kt, Ot);
    } catch {
    }
    throw new Error(Y.toASM(kt) + " has no matching Address");
  }
  address.fromOutputScript = Pt;
  function _t(kt, Ot) {
    Ot = Ot || B.bitcoin;
    let Ht, jt;
    try {
      Ht = Pe(kt);
    } catch {
    }
    if (Ht) {
      if (Ht.version === Ot.pubKeyHash)
        return z.p2pkh({ hash: Ht.hash }).output;
      if (Ht.version === Ot.scriptHash)
        return z.p2sh({ hash: Ht.hash }).output;
    } else {
      try {
        jt = Ve(kt);
      } catch {
      }
      if (jt) {
        if (jt.prefix !== Ot.bech32)
          throw new Error(kt + " has an invalid prefix");
        if (jt.version === 0) {
          if (jt.data.length === 20)
            return z.p2wpkh({ hash: jt.data }).output;
          if (jt.data.length === 32)
            return z.p2wsh({ hash: jt.data }).output;
        } else if (jt.version === 1) {
          if (jt.data.length === 32)
            return z.p2tr({ pubkey: jt.data }).output;
        } else if (jt.version >= ge && jt.version <= ve && jt.data.length >= le && jt.data.length <= se)
          return console.warn(Ee), Y.compile([
            jt.version + oe,
            jt.data
          ]);
      }
    }
    throw new Error(kt + " has no matching Script");
  }
  return address.toOutputScript = _t, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, z) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof z != "function")
    throw TypeError("Expected digest Function");
  let Y = B.length;
  const ne = B.concat();
  for (; Y > 1; ) {
    let ae = 0;
    for (let ie = 0; ie < Y; ie += 2, ++ae) {
      const se = ne[ie], le = ie + 1 === Y ? se : ne[ie + 1], ve = Buffer$1.concat([se, le]);
      ne[ae] = z(ve);
    }
    Y = ae;
  }
  return ne[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + z;
}
function vectorSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + B.reduce((Y, ne) => Y + varSliceSize(ne), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(z, Y) {
    const ne = new bufferutils_1$2.BufferReader(z), ae = new Transaction();
    ae.version = ne.readInt32();
    const ie = ne.readUInt8(), se = ne.readUInt8();
    let le = !1;
    ie === Transaction.ADVANCED_TRANSACTION_MARKER && se === Transaction.ADVANCED_TRANSACTION_FLAG ? le = !0 : ne.offset -= 2;
    const ve = ne.readVarInt();
    for (let oe = 0; oe < ve; ++oe)
      ae.ins.push({
        hash: ne.readSlice(32),
        index: ne.readUInt32(),
        script: ne.readVarSlice(),
        sequence: ne.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const ge = ne.readVarInt();
    for (let oe = 0; oe < ge; ++oe)
      ae.outs.push({
        value: ne.readUInt64(),
        script: ne.readVarSlice()
      });
    if (le) {
      for (let oe = 0; oe < ve; ++oe)
        ae.ins[oe].witness = ne.readVector();
      if (!ae.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (ae.locktime = ne.readUInt32(), Y) return ae;
    if (ne.offset !== z.length)
      throw new Error("Transaction has unexpected data");
    return ae;
  }
  static fromHex(z) {
    return Transaction.fromBuffer(Buffer$1.from(z, "hex"), !1);
  }
  static isCoinbaseHash(z) {
    typeforce$1(types$1.Hash256bit, z);
    for (let Y = 0; Y < 32; ++Y)
      if (z[Y] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(z, Y, ne, ae) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(ne) && (ne = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: z,
      index: Y,
      script: ae || EMPTY_BUFFER,
      sequence: ne,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(z, Y) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: z,
      value: Y
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((z) => z.witness.length !== 0);
  }
  weight() {
    const z = this.byteLength(!1), Y = this.byteLength(!0);
    return z * 3 + Y;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(z = !0) {
    const Y = z && this.hasWitnesses();
    return (Y ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((ne, ae) => ne + 40 + varSliceSize(ae.script), 0) + this.outs.reduce((ne, ae) => ne + 8 + varSliceSize(ae.script), 0) + (Y ? this.ins.reduce((ne, ae) => ne + vectorSize(ae.witness), 0) : 0);
  }
  clone() {
    const z = new Transaction();
    return z.version = this.version, z.locktime = this.locktime, z.ins = this.ins.map((Y) => ({
      hash: Y.hash,
      index: Y.index,
      script: Y.script,
      sequence: Y.sequence,
      witness: Y.witness
    })), z.outs = this.outs.map((Y) => ({
      script: Y.script,
      value: Y.value
    })), z;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(z, Y, ne) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), z >= this.ins.length) return ONE;
    const ae = bscript$2.compile(
      bscript$2.decompile(Y).filter((le) => le !== script_1.OPS.OP_CODESEPARATOR)
    ), ie = this.clone();
    if ((ne & 31) === Transaction.SIGHASH_NONE)
      ie.outs = [], ie.ins.forEach((le, ve) => {
        ve !== z && (le.sequence = 0);
      });
    else if ((ne & 31) === Transaction.SIGHASH_SINGLE) {
      if (z >= this.outs.length) return ONE;
      ie.outs.length = z + 1;
      for (let le = 0; le < z; le++)
        ie.outs[le] = BLANK_OUTPUT;
      ie.ins.forEach((le, ve) => {
        ve !== z && (le.sequence = 0);
      });
    }
    ne & Transaction.SIGHASH_ANYONECANPAY ? (ie.ins = [ie.ins[z]], ie.ins[0].script = ae) : (ie.ins.forEach((le) => {
      le.script = EMPTY_BUFFER;
    }), ie.ins[z].script = ae);
    const se = Buffer$1.allocUnsafe(ie.byteLength(!1) + 4);
    return se.writeInt32LE(ne, se.length - 4), ie.__toBuffer(se, 0, !1), bcrypto$1.hash256(se);
  }
  hashForWitnessV1(z, Y, ne, ae, ie, se) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), ne.length !== this.ins.length || Y.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const le = ae === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : ae & Transaction.SIGHASH_OUTPUT_MASK, ge = (ae & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, oe = le === Transaction.SIGHASH_NONE, Ee = le === Transaction.SIGHASH_SINGLE;
    let Ce = EMPTY_BUFFER, Pe = EMPTY_BUFFER, Ve = EMPTY_BUFFER, ht = EMPTY_BUFFER, vt = EMPTY_BUFFER;
    if (!ge) {
      let Ot = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Ht) => {
        Ot.writeSlice(Ht.hash), Ot.writeUInt32(Ht.index);
      }), Ce = bcrypto$1.sha256(Ot.end()), Ot = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), ne.forEach((Ht) => Ot.writeUInt64(Ht)), Pe = bcrypto$1.sha256(Ot.end()), Ot = bufferutils_1$2.BufferWriter.withCapacity(
        Y.map(varSliceSize).reduce((Ht, jt) => Ht + jt)
      ), Y.forEach(
        (Ht) => Ot.writeVarSlice(Ht)
      ), Ve = bcrypto$1.sha256(Ot.end()), Ot = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Ht) => Ot.writeUInt32(Ht.sequence)), ht = bcrypto$1.sha256(Ot.end());
    }
    if (oe || Ee) {
      if (Ee && z < this.outs.length) {
        const Ot = this.outs[z], Ht = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(Ot.script)
        );
        Ht.writeUInt64(Ot.value), Ht.writeVarSlice(Ot.script), vt = bcrypto$1.sha256(Ht.end());
      }
    } else {
      const Ot = this.outs.map((jt) => 8 + varSliceSize(jt.script)).reduce((jt, Yt) => jt + Yt), Ht = bufferutils_1$2.BufferWriter.withCapacity(Ot);
      this.outs.forEach((jt) => {
        Ht.writeUInt64(jt.value), Ht.writeVarSlice(jt.script);
      }), vt = bcrypto$1.sha256(Ht.end());
    }
    const Pt = (ie ? 2 : 0) + (se ? 1 : 0), _t = 174 - (ge ? 49 : 0) - (oe ? 32 : 0) + (se ? 32 : 0) + (ie ? 37 : 0), kt = bufferutils_1$2.BufferWriter.withCapacity(_t);
    if (kt.writeUInt8(ae), kt.writeInt32(this.version), kt.writeUInt32(this.locktime), kt.writeSlice(Ce), kt.writeSlice(Pe), kt.writeSlice(Ve), kt.writeSlice(ht), oe || Ee || kt.writeSlice(vt), kt.writeUInt8(Pt), ge) {
      const Ot = this.ins[z];
      kt.writeSlice(Ot.hash), kt.writeUInt32(Ot.index), kt.writeUInt64(ne[z]), kt.writeVarSlice(Y[z]), kt.writeUInt32(Ot.sequence);
    } else
      kt.writeUInt32(z);
    if (se) {
      const Ot = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(se)
      );
      Ot.writeVarSlice(se), kt.writeSlice(bcrypto$1.sha256(Ot.end()));
    }
    return Ee && kt.writeSlice(vt), ie && (kt.writeSlice(ie), kt.writeUInt8(0), kt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), kt.end()])
    );
  }
  hashForWitnessV0(z, Y, ne, ae) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let ie = Buffer$1.from([]), se, le = ZERO, ve = ZERO, ge = ZERO;
    if (ae & Transaction.SIGHASH_ANYONECANPAY || (ie = Buffer$1.allocUnsafe(36 * this.ins.length), se = new bufferutils_1$2.BufferWriter(ie, 0), this.ins.forEach((Ee) => {
      se.writeSlice(Ee.hash), se.writeUInt32(Ee.index);
    }), ve = bcrypto$1.hash256(ie)), !(ae & Transaction.SIGHASH_ANYONECANPAY) && (ae & 31) !== Transaction.SIGHASH_SINGLE && (ae & 31) !== Transaction.SIGHASH_NONE && (ie = Buffer$1.allocUnsafe(4 * this.ins.length), se = new bufferutils_1$2.BufferWriter(ie, 0), this.ins.forEach((Ee) => {
      se.writeUInt32(Ee.sequence);
    }), ge = bcrypto$1.hash256(ie)), (ae & 31) !== Transaction.SIGHASH_SINGLE && (ae & 31) !== Transaction.SIGHASH_NONE) {
      const Ee = this.outs.reduce((Ce, Pe) => Ce + 8 + varSliceSize(Pe.script), 0);
      ie = Buffer$1.allocUnsafe(Ee), se = new bufferutils_1$2.BufferWriter(ie, 0), this.outs.forEach((Ce) => {
        se.writeUInt64(Ce.value), se.writeVarSlice(Ce.script);
      }), le = bcrypto$1.hash256(ie);
    } else if ((ae & 31) === Transaction.SIGHASH_SINGLE && z < this.outs.length) {
      const Ee = this.outs[z];
      ie = Buffer$1.allocUnsafe(8 + varSliceSize(Ee.script)), se = new bufferutils_1$2.BufferWriter(ie, 0), se.writeUInt64(Ee.value), se.writeVarSlice(Ee.script), le = bcrypto$1.hash256(ie);
    }
    ie = Buffer$1.allocUnsafe(156 + varSliceSize(Y)), se = new bufferutils_1$2.BufferWriter(ie, 0);
    const oe = this.ins[z];
    return se.writeInt32(this.version), se.writeSlice(ve), se.writeSlice(ge), se.writeSlice(oe.hash), se.writeUInt32(oe.index), se.writeVarSlice(Y), se.writeUInt64(ne), se.writeUInt32(oe.sequence), se.writeSlice(le), se.writeUInt32(this.locktime), se.writeUInt32(ae), bcrypto$1.hash256(ie);
  }
  getHash(z) {
    return z && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, z));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(z, Y) {
    return this.__toBuffer(z, Y, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[z].script = Y;
  }
  setWitness(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[z].witness = Y;
  }
  __toBuffer(z, Y, ne = !1) {
    z || (z = Buffer$1.allocUnsafe(this.byteLength(ne)));
    const ae = new bufferutils_1$2.BufferWriter(
      z,
      Y || 0
    );
    ae.writeInt32(this.version);
    const ie = ne && this.hasWitnesses();
    return ie && (ae.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), ae.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), ae.writeVarInt(this.ins.length), this.ins.forEach((se) => {
      ae.writeSlice(se.hash), ae.writeUInt32(se.index), ae.writeVarSlice(se.script), ae.writeUInt32(se.sequence);
    }), ae.writeVarInt(this.outs.length), this.outs.forEach((se) => {
      isOutput(se) ? ae.writeUInt64(se.value) : ae.writeSlice(se.valueBuffer), ae.writeVarSlice(se.script);
    }), ie && this.ins.forEach((se) => {
      ae.writeVector(se.witness);
    }), ae.writeUInt32(this.locktime), Y !== void 0 ? z.slice(Y, ae.offset) : z;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(z) {
    if (z.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const Y = new bufferutils_1$1.BufferReader(z), ne = new Block();
    if (ne.version = Y.readInt32(), ne.prevHash = Y.readSlice(32), ne.merkleRoot = Y.readSlice(32), ne.timestamp = Y.readUInt32(), ne.bits = Y.readUInt32(), ne.nonce = Y.readUInt32(), z.length === 80) return ne;
    const ae = () => {
      const le = transaction_1$3.Transaction.fromBuffer(
        Y.buffer.slice(Y.offset),
        !0
      );
      return Y.offset += le.byteLength(), le;
    }, ie = Y.readVarInt();
    ne.transactions = [];
    for (let le = 0; le < ie; ++le) {
      const ve = ae();
      ne.transactions.push(ve);
    }
    const se = ne.getWitnessCommit();
    return se && (ne.witnessCommit = se), ne;
  }
  static fromHex(z) {
    return Block.fromBuffer(Buffer$1.from(z, "hex"));
  }
  static calculateTarget(z) {
    const Y = ((z & 4278190080) >> 24) - 3, ne = z & 8388607, ae = Buffer$1.alloc(32, 0);
    return ae.writeUIntBE(ne, 29 - Y, 3), ae;
  }
  static calculateMerkleRoot(z, Y) {
    if (typeforce([{ getHash: types.Function }], z), z.length === 0) throw errorMerkleNoTxes;
    if (Y && !txesHaveWitnessCommit(z))
      throw errorWitnessNotSegwit;
    const ne = z.map(
      (ie) => ie.getHash(Y)
    ), ae = (0, merkle_1.fastMerkleRoot)(ne, bcrypto.hash256);
    return Y ? bcrypto.hash256(
      Buffer$1.concat([ae, z[0].ins[0].witness[0]])
    ) : ae;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const z = this.transactions[0].outs.filter(
      (ne) => ne.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((ne) => ne.script.slice(6, 38));
    if (z.length === 0) return null;
    const Y = z[z.length - 1];
    return Y instanceof Buffer$1 && Y.length === 32 ? Y : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const z = this.byteLength(!1, !1), Y = this.byteLength(!1, !0);
    return z * 3 + Y;
  }
  byteLength(z, Y = !0) {
    return z || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((ne, ae) => ne + ae.byteLength(Y), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const z = /* @__PURE__ */ new Date(0);
    return z.setUTCSeconds(this.timestamp), z;
  }
  // TODO: buffer, offset compatibility
  toBuffer(z) {
    const Y = Buffer$1.allocUnsafe(this.byteLength(z)), ne = new bufferutils_1$1.BufferWriter(Y);
    return ne.writeInt32(this.version), ne.writeSlice(this.prevHash), ne.writeSlice(this.merkleRoot), ne.writeUInt32(this.timestamp), ne.writeUInt32(this.bits), ne.writeUInt32(this.nonce), z || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      Y,
      ne.offset
    ), ne.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((ae) => {
      const ie = ae.byteLength();
      ae.toBuffer(Y, ne.offset), ne.offset += ie;
    })), Y;
  }
  toHex(z) {
    return this.toBuffer(z).toString("hex");
  }
  checkTxRoots() {
    const z = this.hasWitnessCommit();
    return !z && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (z ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const z = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), Y = Block.calculateTarget(this.bits);
    return z.compare(Y) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const z = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(z) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const z = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(z) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (z) => typeof z == "object" && z.ins instanceof Array && z.ins.some(
      (Y) => typeof Y == "object" && Y.witness instanceof Array && Y.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(z) {
    z[z.UNSIGNED_TX = 0] = "UNSIGNED_TX", z[z.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(z) {
    z[z.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", z[z.WITNESS_UTXO = 1] = "WITNESS_UTXO", z[z.PARTIAL_SIG = 2] = "PARTIAL_SIG", z[z.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", z[z.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", z[z.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", z[z.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", z[z.POR_COMMITMENT = 9] = "POR_COMMITMENT", z[z.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", z[z.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", z[z.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", z[z.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", z[z.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(z) {
    z[z.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", z[z.TAP_TREE = 6] = "TAP_TREE", z[z.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (B) => [...Array(B).keys()];
function decode$d(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const z = B.key.slice(1), Y = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: z,
    path: "m"
  };
  for (const ne of range$2(B.value.length / 4 - 1)) {
    const ae = B.value.readUInt32LE(ne * 4 + 4), ie = !!(ae & 2147483648), se = ae & 2147483647;
    Y.path += "/" + se.toString(10) + (ie ? "'" : "");
  }
  return Y;
}
globalXpub$1.decode = decode$d;
function encode$e(B) {
  const z = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), Y = Buffer$1.concat([z, B.extendedPubkey]), ne = B.path.split("/"), ae = Buffer$1.allocUnsafe(ne.length * 4);
  B.masterFingerprint.copy(ae, 0);
  let ie = 4;
  return ne.slice(1).forEach((se) => {
    const le = se.slice(-1) === "'";
    let ve = 2147483647 & parseInt(le ? se.slice(0, -1) : se, 10);
    le && (ve += 2147483648), ae.writeUInt32LE(ve, ie), ie += 4;
  }), {
    key: Y,
    value: ae
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const z = B.extendedPubkey, Y = B.masterFingerprint, ne = B.path;
  return Buffer$1.isBuffer(z) && z.length === 78 && [2, 3].indexOf(z[45]) > -1 && Buffer$1.isBuffer(Y) && Y.length === 4 && typeof ne == "string" && !!ne.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, z, Y) {
  const ne = z.extendedPubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ae) => ae.extendedPubkey.equals(z.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(B) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(B) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$1.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, z) {
  return !!B && !!z && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(B) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$1.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, z) {
  return !!B && !!z && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(B) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$1.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, z) {
  return !!B && !!z && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(B) {
  const z = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([z, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$1.isBuffer(B.pubkey) && Buffer$1.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$1.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const z = B[3];
  if (z > 33 || z < 1 || B[3 + z + 1] !== 2) return !1;
  const Y = B[3 + z + 2];
  return !(Y > 33 || Y < 1 || B.length !== 3 + z + 2 + Y + 2);
}
function canAddToArray$2(B, z, Y) {
  const ne = z.pubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ae) => ae.pubkey.equals(z.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(B) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, z) {
  return !!B && !!z && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(B) {
  const z = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), Y = Buffer$1.allocUnsafe(4);
  return Y.writeUInt32LE(B, 0), {
    key: z,
    value: Y
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, z) {
  return !!B && !!z && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(B) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$1.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, z) {
  return !!B && !!z && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const z = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== z)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const Y = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: Y, leafVersion: z };
}
tapLeafScript$1.decode = decode$5;
function encode$5(B) {
  const z = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), Y = Buffer$1.from([B.leafVersion]);
  return {
    key: Buffer$1.concat([z, B.controlBlock]),
    value: Buffer$1.concat([B.script, Y])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$1.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$1.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, z, Y) {
  const ne = z.controlBlock.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ae) => ae.controlBlock.equals(z.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(B) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$1.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, z) {
  return !!B && !!z && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const z = B.key.slice(1, 33), Y = B.key.slice(33);
  return {
    pubkey: z,
    leafHash: Y,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(B) {
  const z = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([z, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$1.isBuffer(B.pubkey) && Buffer$1.isBuffer(B.leafHash) && Buffer$1.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, z, Y) {
  const ne = z.pubkey.toString("hex") + z.leafHash.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter(
    (ae) => ae.pubkey.equals(z.pubkey) && ae.leafHash.equals(z.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(B, z, Y) {
  if (checkUInt53(B), z || (z = Buffer$1.allocUnsafe(encodingLength(B))), !Buffer$1.isBuffer(z))
    throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), Object.assign(encode$2, { bytes: 1 })) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), Object.assign(encode$2, { bytes: 3 })) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), Object.assign(encode$2, { bytes: 5 })) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), Object.assign(encode$2, { bytes: 9 })), z;
}
varint.encode = encode$2;
function decode$2(B, z) {
  if (!Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  const Y = B.readUInt8(z);
  if (Y < 253)
    return Object.assign(decode$2, { bytes: 1 }), Y;
  if (Y === 253)
    return Object.assign(decode$2, { bytes: 3 }), B.readUInt16LE(z + 1);
  if (Y === 254)
    return Object.assign(decode$2, { bytes: 5 }), B.readUInt32LE(z + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const ne = B.readUInt32LE(z + 1), ie = B.readUInt32LE(z + 5) * 4294967296 + ne;
    return checkUInt53(ie), ie;
  }
}
varint.decode = decode$2;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(B) {
  const z = B.map(keyValToBuffer);
  return z.push(Buffer$1.from([0])), Buffer$1.concat(z);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const z = B.key.length, Y = B.value.length, ne = varuint$6.encodingLength(z), ae = varuint$6.encodingLength(Y), ie = Buffer$1.allocUnsafe(
    ne + z + ae + Y
  );
  return varuint$6.encode(z, ie, 0), B.key.copy(ie, ne), varuint$6.encode(Y, ie, ne + z), B.value.copy(ie, ne + z + ae), ie;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint(ne + Y, 9007199254740991), ne + Y;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, z, Y) {
  return verifuint(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const z = tools_1$2.readUInt64LE(B.value, 0);
  let Y = 8;
  const ne = varuint$5.decode(B.value, Y);
  Y += varuint$5.encodingLength(ne);
  const ae = B.value.slice(Y);
  if (ae.length !== ne)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: ae,
    value: z
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(B) {
  const { script: z, value: Y } = B, ne = varuint$5.encodingLength(z.length), ae = Buffer$1.allocUnsafe(8 + ne + z.length);
  return tools_1$2.writeUInt64LE(ae, Y, 0), varuint$5.encode(z.length, ae, 8), z.copy(ae, 8 + ne), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: ae
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$1.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, z) {
  return !!B && !!z && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let z = 0;
  const Y = [];
  for (; z < B.value.length; ) {
    const ne = B.value[z++], ae = B.value[z++], ie = varuint$4.decode(B.value, z);
    z += varuint$4.encodingLength(ie), Y.push({
      depth: ne,
      leafVersion: ae,
      script: B.value.slice(z, z + ie)
    }), z += ie;
  }
  return { leaves: Y };
}
tapTree$1.decode = decode;
function encode(B) {
  const z = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), Y = [].concat(
    ...B.leaves.map((ne) => [
      Buffer$1.of(ne.depth, ne.leafVersion),
      varuint$4.encode(ne.script.length),
      ne.script
    ])
  );
  return {
    key: z,
    value: Buffer$1.concat(Y)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (z) => z.depth >= 0 && z.depth <= 128 && (z.leafVersion & 254) === z.leafVersion && Buffer$1.isBuffer(z.script)
  );
}
tapTree$1.check = check;
function canAdd(B, z) {
  return !!B && !!z && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, z = isValidDERKey) {
  function Y(le) {
    if (le.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + le.key.toString("hex")
      );
    const ve = le.key.slice(1);
    if (!z(ve))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + le.key.toString("hex")
      );
    if (le.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const ge = {
      masterFingerprint: le.value.slice(0, 4),
      pubkey: ve,
      path: "m"
    };
    for (const oe of range$1(le.value.length / 4 - 1)) {
      const Ee = le.value.readUInt32LE(oe * 4 + 4), Ce = !!(Ee & 2147483648), Pe = Ee & 2147483647;
      ge.path += "/" + Pe.toString(10) + (Ce ? "'" : "");
    }
    return ge;
  }
  function ne(le) {
    const ve = Buffer$1.from([B]), ge = Buffer$1.concat([ve, le.pubkey]), oe = le.path.split("/"), Ee = Buffer$1.allocUnsafe(oe.length * 4);
    le.masterFingerprint.copy(Ee, 0);
    let Ce = 4;
    return oe.slice(1).forEach((Pe) => {
      const Ve = Pe.slice(-1) === "'";
      let ht = 2147483647 & parseInt(Ve ? Pe.slice(0, -1) : Pe, 10);
      Ve && (ht += 2147483648), Ee.writeUInt32LE(ht, Ce), Ce += 4;
    }), {
      key: ge,
      value: Ee
    };
  }
  const ae = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function ie(le) {
    return Buffer$1.isBuffer(le.pubkey) && Buffer$1.isBuffer(le.masterFingerprint) && typeof le.path == "string" && z(le.pubkey) && le.masterFingerprint.length === 4;
  }
  function se(le, ve, ge) {
    const oe = ve.pubkey.toString("hex");
    return ge.has(oe) ? !1 : (ge.add(oe), le.filter((Ee) => Ee.pubkey.equals(ve.pubkey)).length === 0);
  }
  return {
    decode: Y,
    encode: ne,
    check: ie,
    expected: ae,
    canAddToArray: se
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return z;
  function z(Y) {
    let ne;
    if (B.includes(Y.key[0]) && (ne = Y.key.slice(1), !(ne.length === 33 || ne.length === 65) || ![2, 3, 4].includes(ne[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Y.key.toString("hex")
      );
    return ne;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function z(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + se.key.toString("hex")
      );
    return se.value;
  }
  function Y(se) {
    return {
      key: Buffer$1.from([B]),
      value: se
    };
  }
  const ne = "Buffer";
  function ae(se) {
    return Buffer$1.isBuffer(se);
  }
  function ie(se, le) {
    return !!se && !!le && se.redeemScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ae,
    expected: ne,
    canAdd: ie
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const z = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function Y(se) {
    const le = varuint$3.decode(se.value), ve = varuint$3.encodingLength(le), ge = z.decode({
      key: se.key,
      value: se.value.slice(ve + le * 32)
    }), oe = new Array(le);
    for (let Ee = 0, Ce = ve; Ee < le; Ee++, Ce += 32)
      oe[Ee] = se.value.slice(Ce, Ce + 32);
    return Object.assign({}, ge, { leafHashes: oe });
  }
  function ne(se) {
    const le = z.encode(se), ve = varuint$3.encodingLength(se.leafHashes.length), ge = Buffer$1.allocUnsafe(ve);
    varuint$3.encode(se.leafHashes.length, ge);
    const oe = Buffer$1.concat([ge, ...se.leafHashes, le.value]);
    return Object.assign({}, le, { value: oe });
  }
  const ae = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function ie(se) {
    return Array.isArray(se.leafHashes) && se.leafHashes.every(
      (le) => Buffer$1.isBuffer(le) && le.length === 32
    ) && z.check(se);
  }
  return {
    decode: Y,
    encode: ne,
    check: ie,
    expected: ae,
    canAddToArray: z.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function z(se) {
    if (se.key[0] !== B || se.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + se.key.toString("hex")
      );
    if (se.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return se.value;
  }
  function Y(se) {
    return { key: Buffer$1.from([B]), value: se };
  }
  const ne = "Buffer";
  function ae(se) {
    return Buffer$1.isBuffer(se) && se.length === 32;
  }
  function ie(se, le) {
    return !!se && !!le && se.tapInternalKey === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ae,
    expected: ne,
    canAdd: ie
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function z(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + se.key.toString("hex")
      );
    return se.value;
  }
  function Y(se) {
    return {
      key: Buffer$1.from([B]),
      value: se
    };
  }
  const ne = "Buffer";
  function ae(se) {
    return Buffer$1.isBuffer(se);
  }
  function ie(se, le) {
    return !!se && !!le && se.witnessScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ae,
    expected: ne,
    canAdd: ie
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, z) {
  let Y = 0;
  function ne() {
    const vt = varuint$2.decode(B, Y);
    Y += varuint$2.encodingLength(vt);
    const Pt = B.slice(Y, Y + vt);
    return Y += vt, Pt;
  }
  function ae() {
    const vt = B.readUInt32BE(Y);
    return Y += 4, vt;
  }
  function ie() {
    const vt = B.readUInt8(Y);
    return Y += 1, vt;
  }
  function se() {
    const vt = ne(), Pt = ne();
    return {
      key: vt,
      value: Pt
    };
  }
  function le() {
    if (Y >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const vt = B.readUInt8(Y) === 0;
    return vt && Y++, vt;
  }
  if (ae() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (ie() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ve = [], ge = {};
  for (; !le(); ) {
    const vt = se(), Pt = vt.key.toString("hex");
    if (ge[Pt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + Pt
      );
    ge[Pt] = 1, ve.push(vt);
  }
  const oe = ve.filter(
    (vt) => vt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (oe.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const Ee = z(oe[0].value), { inputCount: Ce, outputCount: Pe } = Ee.getInputOutputCounts(), Ve = [], ht = [];
  for (const vt of tools_1$1.range(Ce)) {
    const Pt = {}, _t = [];
    for (; !le(); ) {
      const kt = se(), Ot = kt.key.toString("hex");
      if (Pt[Ot])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + vt + " key " + Ot
        );
      Pt[Ot] = 1, _t.push(kt);
    }
    Ve.push(_t);
  }
  for (const vt of tools_1$1.range(Pe)) {
    const Pt = {}, _t = [];
    for (; !le(); ) {
      const kt = se(), Ot = kt.key.toString("hex");
      if (Pt[Ot])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + vt + " key " + Ot
        );
      Pt[Ot] = 1, _t.push(kt);
    }
    ht.push(_t);
  }
  return psbtFromKeyVals(Ee, {
    globalMapKeyVals: ve,
    inputKeyVals: Ve,
    outputKeyVals: ht
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, z, Y) {
  if (!z.equals(Buffer$1.from([Y])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${z.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: z, inputKeyVals: Y, outputKeyVals: ne }) {
  const ae = {
    unsignedTx: B
  };
  let ie = 0;
  for (const oe of z)
    switch (oe.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          oe.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), ie > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        ie++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        ae.globalXpub === void 0 && (ae.globalXpub = []), ae.globalXpub.push(convert$1.globals.globalXpub.decode(oe));
        break;
      default:
        ae.unknownKeyVals || (ae.unknownKeyVals = []), ae.unknownKeyVals.push(oe);
    }
  const se = Y.length, le = ne.length, ve = [], ge = [];
  for (const oe of tools_1$1.range(se)) {
    const Ee = {};
    for (const Ce of Y[oe])
      switch (convert$1.inputs.checkPubkey(Ce), Ce.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), Ee.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          Ee.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), Ee.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          Ee.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          Ee.partialSig === void 0 && (Ee.partialSig = []), Ee.partialSig.push(convert$1.inputs.partialSig.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), Ee.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          Ee.sighashType = convert$1.inputs.sighashType.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.inputs.redeemScript.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.inputs.witnessScript.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), Ee.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), Ee.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Ce
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), Ee.porCommitment = convert$1.inputs.porCommitment.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), Ee.tapKeySig = convert$1.inputs.tapKeySig.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          Ee.tapScriptSig === void 0 && (Ee.tapScriptSig = []), Ee.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          Ee.tapLeafScript === void 0 && (Ee.tapLeafScript = []), Ee.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), Ee.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Ce);
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Ce);
      }
    ve.push(Ee);
  }
  for (const oe of tools_1$1.range(le)) {
    const Ee = {};
    for (const Ce of ne[oe])
      switch (convert$1.outputs.checkPubkey(Ce), Ce.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.outputs.redeemScript.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.outputs.witnessScript.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), Ee.tapTree = convert$1.outputs.tapTree.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Ce)
          );
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Ce);
      }
    ge.push(Ee);
  }
  return { globalMap: ae, inputs: ve, outputs: ge };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: z, outputs: Y }) {
  const { globalKeyVals: ne, inputKeyVals: ae, outputKeyVals: ie } = psbtToKeyVals({
    globalMap: B,
    inputs: z,
    outputs: Y
  }), se = tools_1.keyValsToBuffer(ne), le = (Ee) => Ee.length === 0 ? [Buffer$1.from([0])] : Ee.map(tools_1.keyValsToBuffer), ve = le(ae), ge = le(ie), oe = Buffer$1.allocUnsafe(5);
  return oe.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [oe, se].concat(ve, ge)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, z) => B.key.compare(z.key);
function keyValsFromMap(B, z) {
  const Y = /* @__PURE__ */ new Set(), ne = Object.entries(B).reduce((ie, [se, le]) => {
    if (se === "unknownKeyVals") return ie;
    const ve = z[se];
    if (ve === void 0) return ie;
    const ge = (Array.isArray(le) ? le : [le]).map(
      ve.encode
    );
    return ge.map((Ee) => Ee.key.toString("hex")).forEach((Ee) => {
      if (Y.has(Ee))
        throw new Error("Serialize Error: Duplicate key: " + Ee);
      Y.add(Ee);
    }), ie.concat(ge);
  }, []), ae = B.unknownKeyVals ? B.unknownKeyVals.filter((ie) => !Y.has(ie.key.toString("hex"))) : [];
  return ne.concat(ae).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: z, outputs: Y }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: z.map((ne) => keyValsFromMap(ne, convert.inputs)),
    outputKeyVals: Y.map((ne) => keyValsFromMap(ne, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function z(Y) {
    for (var ne in Y) B.hasOwnProperty(ne) || (B[ne] = Y[ne]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), z(fromBuffer), z(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const z = B[0], Y = parser_1$1.psbtToKeyVals(z), ne = B.slice(1);
  if (ne.length === 0) throw new Error("Combine: Nothing to combine");
  const ae = getTx(z);
  if (ae === void 0)
    throw new Error("Combine: Self missing transaction");
  const ie = getKeySet(Y.globalKeyVals), se = Y.inputKeyVals.map(getKeySet), le = Y.outputKeyVals.map(getKeySet);
  for (const ve of ne) {
    const ge = getTx(ve);
    if (ge === void 0 || !ge.toBuffer().equals(ae.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const oe = parser_1$1.psbtToKeyVals(ve);
    getKeySet(oe.globalKeyVals).forEach(
      keyPusher(
        ie,
        Y.globalKeyVals,
        oe.globalKeyVals
      )
    ), oe.inputKeyVals.map(getKeySet).forEach(
      (Ve, ht) => Ve.forEach(
        keyPusher(
          se[ht],
          Y.inputKeyVals[ht],
          oe.inputKeyVals[ht]
        )
      )
    ), oe.outputKeyVals.map(getKeySet).forEach(
      (Ve, ht) => Ve.forEach(
        keyPusher(
          le[ht],
          Y.outputKeyVals[ht],
          oe.outputKeyVals[ht]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(ae, {
    globalMapKeyVals: Y.globalKeyVals,
    inputKeyVals: Y.inputKeyVals,
    outputKeyVals: Y.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, z, Y) {
  return (ne) => {
    if (B.has(ne)) return;
    const ae = Y.filter((ie) => ie.key.toString("hex") === ne)[0];
    z.push(ae), B.add(ne);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const z = /* @__PURE__ */ new Set();
  return B.forEach((Y) => {
    const ne = Y.key.toString("hex");
    if (z.has(ne))
      throw new Error("Combine: KeyValue Map keys should be unique");
    z.add(ne);
  }), z;
}
var utils = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const z = converter;
  function Y(Pe, Ve) {
    const ht = Pe[Ve];
    if (ht === void 0) throw new Error(`No input #${Ve}`);
    return ht;
  }
  B.checkForInput = Y;
  function ne(Pe, Ve) {
    const ht = Pe[Ve];
    if (ht === void 0) throw new Error(`No output #${Ve}`);
    return ht;
  }
  B.checkForOutput = ne;
  function ae(Pe, Ve, ht) {
    if (Pe.key[0] < ht)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (Ve && Ve.filter((vt) => vt.key.equals(Pe.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Pe.key.toString("hex")}`);
  }
  B.checkHasKey = ae;
  function ie(Pe) {
    let Ve = 0;
    return Object.keys(Pe).forEach((ht) => {
      Number(isNaN(Number(ht))) && Ve++;
    }), Ve;
  }
  B.getEnumLength = ie;
  function se(Pe, Ve) {
    let ht = !1;
    if (Ve.nonWitnessUtxo || Ve.witnessUtxo) {
      const vt = !!Ve.redeemScript, Pt = !!Ve.witnessScript, _t = !vt || !!Ve.finalScriptSig, kt = !Pt || !!Ve.finalScriptWitness, Ot = !!Ve.finalScriptSig || !!Ve.finalScriptWitness;
      ht = _t && kt && Ot;
    }
    if (ht === !1)
      throw new Error(
        `Input #${Pe} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = se;
  function le(Pe, Ve, ht, vt) {
    throw new Error(
      `Data for ${Pe} key ${Ve} is incorrect: Expected ${ht} and got ${JSON.stringify(vt)}`
    );
  }
  function ve(Pe) {
    return (Ve, ht) => {
      for (const vt of Object.keys(Ve)) {
        const Pt = Ve[vt], { canAdd: _t, canAddToArray: kt, check: Ot, expected: Ht } = (
          // @ts-ignore
          z[Pe + "s"][vt] || {}
        ), jt = !!kt;
        if (Ot)
          if (jt) {
            if (!Array.isArray(Pt) || // @ts-ignore
            ht[vt] && !Array.isArray(ht[vt]))
              throw new Error(`Key type ${vt} must be an array`);
            Pt.every(Ot) || le(Pe, vt, Ht, Pt);
            const Yt = ht[vt] || [], Dt = /* @__PURE__ */ new Set();
            if (!Pt.every((Ct) => kt(Yt, Ct, Dt)))
              throw new Error("Can not add duplicate data to array");
            ht[vt] = Yt.concat(Pt);
          } else {
            if (Ot(Pt) || le(Pe, vt, Ht, Pt), !_t(ht, Pt))
              throw new Error(`Can not add duplicate data to ${Pe}`);
            ht[vt] = Pt;
          }
      }
    };
  }
  B.updateGlobal = ve("global"), B.updateInput = ve("input"), B.updateOutput = ve("output");
  function ge(Pe, Ve) {
    const ht = Pe.length - 1, vt = Y(Pe, ht);
    B.updateInput(Ve, vt);
  }
  B.addInputAttributes = ge;
  function oe(Pe, Ve) {
    const ht = Pe.length - 1, vt = ne(Pe, ht);
    B.updateOutput(Ve, vt);
  }
  B.addOutputAttributes = oe;
  function Ee(Pe, Ve) {
    if (!Buffer$1.isBuffer(Ve) || Ve.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return Ve.writeUInt32LE(Pe, 0), Ve;
  }
  B.defaultVersionSetter = Ee;
  function Ce(Pe, Ve) {
    if (!Buffer$1.isBuffer(Ve) || Ve.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return Ve.writeUInt32LE(Pe, Ve.length - 4), Ve;
  }
  B.defaultLocktimeSetter = Ce;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(z) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: z
    };
  }
  static fromBase64(z, Y) {
    const ne = Buffer$1.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y) {
    const ne = Buffer$1.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y) {
    const ne = parser_1.psbtFromBuffer(z, Y), ae = new this(ne.globalMap.unsignedTx);
    return Object.assign(ae, ne), ae;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(z) {
    return utils_1$1.updateGlobal(z, this.globalMap), this;
  }
  updateInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.updateInput(Y, ne), this;
  }
  updateOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.updateOutput(Y, ne), this;
  }
  addUnknownKeyValToGlobal(z) {
    return utils_1$1.checkHasKey(
      z,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addInput(z) {
    this.globalMap.unsignedTx.addInput(z), this.inputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.inputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (ae) => this.addUnknownKeyValToInput(ne, ae)
    ), utils_1$1.addInputAttributes(this.inputs, z), this;
  }
  addOutput(z) {
    this.globalMap.unsignedTx.addOutput(z), this.outputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.outputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (ae) => this.addUnknownKeyValToOutput(ne, ae)
    ), utils_1$1.addOutputAttributes(this.outputs, z), this;
  }
  clearFinalizedInput(z) {
    const Y = utils_1$1.checkForInput(this.inputs, z);
    utils_1$1.inputCheckUncleanFinalized(z, Y);
    for (const ne of Object.keys(Y))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(ne) || delete Y[ne];
    return this;
  }
  combine(...z) {
    const Y = combiner_1.combine([this].concat(z));
    return Object.assign(this, Y), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(B) {
  return (z) => {
    try {
      return B({ output: z }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let z = Buffer$1.allocUnsafe(0);
  function Y(se) {
    z = Buffer$1.concat([z, Buffer$1.from(se)]);
  }
  function ne(se) {
    const le = z.length, ve = varuint$1.encodingLength(se);
    z = Buffer$1.concat([z, Buffer$1.allocUnsafe(ve)]), varuint$1.encode(se, z, le);
  }
  function ae(se) {
    ne(se.length), Y(se);
  }
  function ie(se) {
    ne(se.length), se.forEach(ae);
  }
  return ie(B), z;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, z) {
  const Y = (0, crypto_1.hash160)(B), ne = B.slice(1, 33), ae = bscript$1.decompile(z);
  if (ae === null) throw new Error("Unknown script error");
  return ae.findIndex((ie) => typeof ie == "number" ? !1 : ie.equals(B) || ie.equals(Y) || ie.equals(ne));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, z) {
  return pubkeyPositionInScript(B, z) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, z) {
  return extractPartialSigs(B).some(
    (ne) => signatureBlocksAction(ne, bscript$1.signature.decode, z)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, z, Y) {
  const { hashType: ne } = z(B), ae = [];
  switch (ne & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && ae.push("addInput"), ne & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      ae.push("addOutput"), ae.push("setInputSequence");
      break;
  }
  return ae.indexOf(Y) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let z = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    z = getPsigsFromInputFinalScripts(B);
  } else
    z = B.partialSig;
  return z.map((Y) => Y.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const z = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], Y = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return z.concat(Y).filter((ne) => Buffer$1.isBuffer(ne) && bscript$1.isCanonicalScriptSignature(ne)).map((ne) => ({ signature: ne }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(B, z, Y) {
  const ne = findTapLeafToFinalize(
    z,
    B,
    Y
  );
  try {
    const ie = sortSignatures(z, ne).concat(ne.script).concat(ne.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(ie)
    };
  } catch (ae) {
    throw new Error(`Can not finalize taproot input #${B}: ${ae}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, z) {
  const Y = z ? Buffer$1.from([z]) : Buffer$1.from([]);
  return Buffer$1.concat([B, Y]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, z) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || z && (0, psbtutils_1$1.isP2TR)(z));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootInputFields(B, z, Y), checkIfTapLeafInTree(B, z, Y);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootOutputFields(B, z, Y), checkTaprootScriptPubkey(B, z);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, z) {
  if (!z.tapTree && !z.tapInternalKey) return;
  const Y = z.tapInternalKey || B.tapInternalKey, ne = z.tapTree || B.tapTree;
  if (Y) {
    const { script: ae } = B, ie = getTaprootScripPubkey(Y, ne);
    if (ae && !ae.equals(ie))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, z) {
  const Y = z && tapTreeFromList(z.leaves), { output: ne } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: Y
  });
  return ne;
}
function tweakInternalPubKey(B, z) {
  const Y = z.tapInternalKey, ne = Y && (0, bip341_1$1.tweakKey)(Y, z.tapMerkleRoot);
  if (!ne)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${Y && Y.toString("hex")}`
    );
  return ne.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, z) {
  return extractTaprootSigs(B).some(
    (ne) => (0, psbtutils_2.signatureBlocksAction)(ne, decodeSchnorrSignature, z)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const z = [];
  if (B.tapKeySig && z.push(B.tapKeySig), B.tapScriptSig && z.push(...B.tapScriptSig.map((Y) => Y.signature)), !z.length) {
    const Y = getTapKeySigFromWithness(B.finalScriptWitness);
    Y && z.push(Y);
  }
  return z;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const z = B.slice(2);
  if (z.length === 64 || z.length === 65) return z;
}
function _tapTreeToList(B, z = [], Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (z.push({
    depth: Y,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), z) : (B[0] && _tapTreeToList(B[0], z, Y + 1), B[1] && _tapTreeToList(B[1], z, Y + 1), z) : [];
}
function instertLeavesInTree(B) {
  let z;
  for (const Y of B)
    if (z = instertLeafInTree(Y, z), !z) throw new Error("No room left to insert tapleaf in tree");
  return z;
}
function instertLeafInTree(B, z, Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === Y)
    return z ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(z)) return;
  const ne = instertLeafInTree(B, z && z[0], Y + 1);
  if (ne) return [ne, z && z[1]];
  const ae = instertLeafInTree(B, z && z[1], Y + 1);
  if (ae) return [z && z[0], ae];
}
function checkMixedTaprootAndNonTaprootInputFields(B, z, Y) {
  const ne = isTaprootInput(B) && hasNonTaprootFields(z), ae = hasNonTaprootFields(B) && isTaprootInput(z), ie = B === z && isTaprootInput(z) && hasNonTaprootFields(z);
  if (ne || ae || ie)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, z, Y) {
  const ne = isTaprootOutput(B) && hasNonTaprootFields(z), ae = hasNonTaprootFields(B) && isTaprootOutput(z), ie = B === z && isTaprootOutput(z) && hasNonTaprootFields(z);
  if (ne || ae || ie)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, z, Y) {
  if (z.tapMerkleRoot) {
    const ne = (z.tapLeafScript || []).every(
      (ie) => isTapLeafInTree(ie, z.tapMerkleRoot)
    ), ae = (B.tapLeafScript || []).every(
      (ie) => isTapLeafInTree(ie, z.tapMerkleRoot)
    );
    if (!ne || !ae)
      throw new Error(
        `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(z.tapLeafScript || []).every(
    (ae) => isTapLeafInTree(ae, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, z) {
  if (!z) return !0;
  const Y = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    Y
  ).equals(z);
}
function sortSignatures(B, z) {
  const Y = (0, bip341_1$1.tapleafHash)({
    output: z.script,
    version: z.leafVersion
  });
  return (B.tapScriptSig || []).filter((ne) => ne.leafHash.equals(Y)).map((ne) => addPubkeyPositionInScript(z.script, ne)).sort((ne, ae) => ae.positionInScript - ne.positionInScript).map((ne) => ne.signature);
}
function addPubkeyPositionInScript(B, z) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        z.pubkey,
        B
      )
    },
    z
  );
}
function findTapLeafToFinalize(B, z, Y) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${z}. No tapleaf script signature provided.`
    );
  const ne = (B.tapLeafScript || []).sort((ae, ie) => ae.controlBlock.length - ie.controlBlock.length).find(
    (ae) => canFinalizeLeaf(ae, B.tapScriptSig, Y)
  );
  if (!ne)
    throw new Error(
      `Can not finalize taproot input #${z}. Signature for tapleaf script not found.`
    );
  return ne;
}
function canFinalizeLeaf(B, z, Y) {
  const ne = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!Y || Y.equals(ne)) && z.find((ie) => ie.leafHash.equals(ne)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(z, Y = {}) {
    const ne = Buffer$1.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y = {}) {
    const ne = Buffer$1.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y = {}) {
    const ne = bip174_1.Psbt.fromBuffer(z, transactionFromBuffer), ae = new Psbt(Y, ne);
    return checkTxForDupeIns(ae.__CACHE.__TX, ae.__CACHE), ae;
  }
  constructor(z = {}, Y = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = Y, this.opts = Object.assign({}, DEFAULT_OPTS, z), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const ne = (ae, ie, se, le) => Object.defineProperty(ae, ie, {
      enumerable: se,
      writable: le
    });
    ne(this, "__CACHE", !1, !0), ne(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(z) {
    this.setVersion(z);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(z) {
    this.setLocktime(z);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((z) => ({
      hash: (0, bufferutils_1.cloneBuffer)(z.hash),
      index: z.index,
      sequence: z.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((z) => {
      let Y;
      try {
        Y = (0, address_1.fromOutputScript)(
          z.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(z.script),
        value: z.value,
        address: Y
      };
    });
  }
  combine(...z) {
    return this.data.combine(...z.map((Y) => Y.data)), this;
  }
  clone() {
    const z = Psbt.fromBuffer(this.data.toBuffer());
    return z.opts = JSON.parse(JSON.stringify(this.opts)), z;
  }
  setMaximumFeeRate(z) {
    check32Bit(z), this.opts.maximumFeeRate = z;
  }
  setVersion(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const Y = this.__CACHE;
    return Y.__TX.version = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const Y = this.__CACHE;
    return Y.__TX.locktime = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(z, Y) {
    check32Bit(Y), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const ne = this.__CACHE;
    if (ne.__TX.ins.length <= z)
      throw new Error("Input index too high");
    return ne.__TX.ins[z].sequence = Y, ne.__EXTRACTED_TX = void 0, this;
  }
  addInputs(z) {
    return z.forEach((Y) => this.addInput(Y)), this;
  }
  addInput(z) {
    if (arguments.length > 1 || !z || z.hash === void 0 || z.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(z, z, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), z.witnessScript && checkInvalidP2WSH(z.witnessScript);
    const Y = this.__CACHE;
    this.data.addInput(z);
    const ne = Y.__TX.ins[Y.__TX.ins.length - 1];
    checkTxInputCache(Y, ne);
    const ae = this.data.inputs.length - 1, ie = this.data.inputs[ae];
    return ie.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, ie, ae), Y.__FEE = void 0, Y.__FEE_RATE = void 0, Y.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(z) {
    return z.forEach((Y) => this.addOutput(Y)), this;
  }
  addOutput(z) {
    if (arguments.length > 1 || !z || z.value === void 0 || z.address === void 0 && z.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: Y } = z;
    if (typeof Y == "string") {
      const { network: ae } = this.opts, ie = (0, address_1.toOutputScript)(Y, ae);
      z = Object.assign({}, z, { script: ie });
    }
    (0, bip371_1.checkTaprootOutputFields)(z, z, "addOutput");
    const ne = this.__CACHE;
    return this.data.addOutput(z), ne.__FEE = void 0, ne.__FEE_RATE = void 0, ne.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(z) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const Y = this.__CACHE;
    if (z || checkFees(this, Y, this.opts), Y.__EXTRACTED_TX) return Y.__EXTRACTED_TX;
    const ne = Y.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, ne, Y, !0), ne;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((z) => this.finalizeInput(z)), this;
  }
  finalizeInput(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ne) ? this._finalizeTaprootInput(
      z,
      ne,
      void 0,
      Y
    ) : this._finalizeInput(z, ne, Y);
  }
  finalizeTaprootInput(z, Y, ne = bip371_1.tapScriptFinalizer) {
    const ae = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(ae))
      return this._finalizeTaprootInput(
        z,
        ae,
        Y,
        ne
      );
    throw new Error(`Cannot finalize input #${z}. Not Taproot.`);
  }
  _finalizeInput(z, Y, ne = getFinalScripts) {
    const { script: ae, isP2SH: ie, isP2WSH: se, isSegwit: le } = getScriptFromInput(
      z,
      Y,
      this.__CACHE
    );
    if (!ae) throw new Error(`No script found for input #${z}`);
    checkPartialSigSighashes(Y);
    const { finalScriptSig: ve, finalScriptWitness: ge } = ne(
      z,
      Y,
      ae,
      le,
      ie,
      se
    );
    if (ve && this.data.updateInput(z, { finalScriptSig: ve }), ge && this.data.updateInput(z, { finalScriptWitness: ge }), !ve && !ge)
      throw new Error(`Unknown error finalizing input #${z}`);
    return this.data.clearFinalizedInput(z), this;
  }
  _finalizeTaprootInput(z, Y, ne, ae = bip371_1.tapScriptFinalizer) {
    if (!Y.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${z}. Missing withness utxo.`
      );
    if (Y.tapKeySig) {
      const ie = payments.p2tr({
        output: Y.witnessUtxo.script,
        signature: Y.tapKeySig
      }), se = (0, psbtutils_1.witnessStackToScriptWitness)(
        ie.witness
      );
      this.data.updateInput(z, { finalScriptWitness: se });
    } else {
      const { finalScriptWitness: ie } = ae(
        z,
        Y,
        ne
      );
      this.data.updateInput(z, { finalScriptWitness: ie });
    }
    return this.data.clearFinalizedInput(z), this;
  }
  getInputType(z) {
    const Y = (0, utils_1.checkForInput)(this.data.inputs, z), ne = getScriptFromUtxo(z, Y, this.__CACHE), ae = getMeaningfulScript(
      ne,
      z,
      "input",
      Y.redeemScript || redeemFromFinalScriptSig(Y.finalScriptSig),
      Y.witnessScript || redeemFromFinalWitnessScript(Y.finalScriptWitness)
    ), ie = ae.type === "raw" ? "" : ae.type + "-", se = classifyScript(ae.meaningfulScript);
    return ie + se;
  }
  inputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return pubkeyInInput(Y, ne, z, this.__CACHE);
  }
  inputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z), ae = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(ae);
  }
  outputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z);
    return pubkeyInOutput(Y, ne, z, this.__CACHE);
  }
  outputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z), ae = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(ae);
  }
  validateSignaturesOfAllInputs(z) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (ne) => this.validateSignaturesOfInput(ne, z)
    ).reduce((ne, ae) => ae === !0 && ne, !0);
  }
  validateSignaturesOfInput(z, Y, ne) {
    const ae = this.data.inputs[z];
    return (0, bip371_1.isTaprootInput)(ae) ? this.validateSignaturesOfTaprootInput(
      z,
      Y,
      ne
    ) : this._validateSignaturesOfInput(z, Y, ne);
  }
  _validateSignaturesOfInput(z, Y, ne) {
    const ae = this.data.inputs[z], ie = (ae || {}).partialSig;
    if (!ae || !ie || ie.length < 1)
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    const se = ne ? ie.filter((Ee) => Ee.pubkey.equals(ne)) : ie;
    if (se.length < 1) throw new Error("No signatures for this pubkey");
    const le = [];
    let ve, ge, oe;
    for (const Ee of se) {
      const Ce = bscript.signature.decode(Ee.signature), { hash: Pe, script: Ve } = oe !== Ce.hashType ? getHashForSig(
        z,
        Object.assign({}, ae, { sighashType: Ce.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ve, script: ge };
      oe = Ce.hashType, ve = Pe, ge = Ve, checkScriptForPubkey(Ee.pubkey, Ve, "verify"), le.push(Y(Ee.pubkey, Pe, Ce.signature));
    }
    return le.every((Ee) => Ee === !0);
  }
  validateSignaturesOfTaprootInput(z, Y, ne) {
    const ae = this.data.inputs[z], ie = (ae || {}).tapKeySig, se = (ae || {}).tapScriptSig;
    if (!ae && !ie && !(se && !se.length))
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    ne = ne && (0, bip371_1.toXOnly)(ne);
    const le = ne ? getTaprootHashesForSig(
      z,
      ae,
      this.data.inputs,
      ne,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      z,
      ae,
      this.data.inputs,
      this.__CACHE
    );
    if (!le.length) throw new Error("No signatures for this pubkey");
    const ve = le.find((oe) => !oe.leafHash);
    let ge = 0;
    if (ie && ve) {
      if (!Y(
        ve.pubkey,
        ve.hash,
        trimTaprootSig(ie)
      )) return !1;
      ge++;
    }
    if (se)
      for (const oe of se) {
        const Ee = le.find((Ce) => oe.pubkey.equals(Ce.pubkey));
        if (Ee) {
          if (!Y(
            oe.pubkey,
            Ee.hash,
            trimTaprootSig(oe.signature)
          )) return !1;
          ge++;
        }
      }
    return ge > 0;
  }
  signAllInputsHD(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!z || !z.publicKey || !z.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const ne = [];
    for (const ae of range(this.data.inputs.length))
      try {
        this.signInputHD(ae, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((ae) => ae === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ne, ae) => {
      if (!z || !z.publicKey || !z.fingerprint)
        return ae(new Error("Need HDSigner to sign input"));
      const ie = [], se = [];
      for (const le of range(this.data.inputs.length))
        se.push(
          this.signInputHDAsync(le, z, Y).then(
            () => {
              ie.push(!0);
            },
            () => {
              ie.push(!1);
            }
          )
        );
      return Promise.all(se).then(() => {
        if (ie.every((le) => le === !1))
          return ae(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInputHD(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!Y || !Y.publicKey || !Y.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(z, this.data.inputs, Y).forEach((ie) => this.signInput(z, ie, ne)), this;
  }
  signInputHDAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ae, ie) => {
      if (!Y || !Y.publicKey || !Y.fingerprint)
        return ie(new Error("Need HDSigner to sign input"));
      const le = getSignersFromHD(z, this.data.inputs, Y).map(
        (ve) => this.signInputAsync(z, ve, ne)
      );
      return Promise.all(le).then(() => {
        ae();
      }).catch(ie);
    });
  }
  signAllInputs(z, Y) {
    if (!z || !z.publicKey)
      throw new Error("Need Signer to sign input");
    const ne = [];
    for (const ae of range(this.data.inputs.length))
      try {
        this.signInput(ae, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((ae) => ae === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(z, Y) {
    return new Promise((ne, ae) => {
      if (!z || !z.publicKey)
        return ae(new Error("Need Signer to sign input"));
      const ie = [], se = [];
      for (const [le] of this.data.inputs.entries())
        se.push(
          this.signInputAsync(le, z, Y).then(
            () => {
              ie.push(!0);
            },
            () => {
              ie.push(!1);
            }
          )
        );
      return Promise.all(se).then(() => {
        if (ie.every((le) => le === !1))
          return ae(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInput(z, Y, ne) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const ae = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ae) ? this._signTaprootInput(
      z,
      ae,
      Y,
      void 0,
      ne
    ) : this._signInput(z, Y, ne);
  }
  signTaprootInput(z, Y, ne, ae) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(ie))
      return this._signTaprootInput(
        z,
        ie,
        Y,
        ne,
        ae
      );
    throw new Error(`Input #${z} is not of type Taproot.`);
  }
  _signInput(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: ae, sighashType: ie } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    ), se = [
      {
        pubkey: Y.publicKey,
        signature: bscript.signature.encode(Y.sign(ae), ie)
      }
    ];
    return this.data.updateInput(z, { partialSig: se }), this;
  }
  _signTaprootInput(z, Y, ne, ae, ie = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const se = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      ae,
      ie
    ), le = se.filter((ge) => !ge.leafHash).map(
      (ge) => (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(ge.hash),
        Y.sighashType
      )
    )[0], ve = se.filter((ge) => !!ge.leafHash).map((ge) => ({
      pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(ge.hash),
        Y.sighashType
      ),
      leafHash: ge.leafHash
    }));
    return le && this.data.updateInput(z, { tapKeySig: le }), ve.length && this.data.updateInput(z, { tapScriptSig: ve }), this;
  }
  signInputAsync(z, Y, ne) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const ae = (0, utils_1.checkForInput)(this.data.inputs, z);
      return (0, bip371_1.isTaprootInput)(ae) ? this._signTaprootInputAsync(
        z,
        ae,
        Y,
        void 0,
        ne
      ) : this._signInputAsync(z, Y, ne);
    });
  }
  signTaprootInputAsync(z, Y, ne, ae) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
      if ((0, bip371_1.isTaprootInput)(ie))
        return this._signTaprootInputAsync(
          z,
          ie,
          Y,
          ne,
          ae
        );
      throw new Error(`Input #${z} is not of type Taproot.`);
    });
  }
  _signInputAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: ae, sighashType: ie } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    );
    return Promise.resolve(Y.sign(ae)).then((se) => {
      const le = [
        {
          pubkey: Y.publicKey,
          signature: bscript.signature.encode(se, ie)
        }
      ];
      this.data.updateInput(z, { partialSig: le });
    });
  }
  async _signTaprootInputAsync(z, Y, ne, ae, ie = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const se = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      ae,
      ie
    ), le = [], ve = se.filter((oe) => !oe.leafHash)[0];
    if (ve) {
      const oe = Promise.resolve(
        ne.signSchnorr(ve.hash)
      ).then((Ee) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          Ee,
          Y.sighashType
        )
      }));
      le.push(oe);
    }
    const ge = se.filter((oe) => !!oe.leafHash);
    if (ge.length) {
      const oe = ge.map((Ee) => Promise.resolve(ne.signSchnorr(Ee.hash)).then(
        (Ce) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Ce,
              Y.sighashType
            ),
            leafHash: Ee.leafHash
          }
        ] })
      ));
      le.push(...oe);
    }
    return Promise.all(le).then((oe) => {
      oe.forEach((Ee) => this.data.updateInput(z, Ee));
    });
  }
  checkTaprootHashesForSig(z, Y, ne, ae, ie) {
    if (typeof ne.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${z}.`
      );
    const se = getTaprootHashesForSig(
      z,
      Y,
      this.data.inputs,
      ne.publicKey,
      this.__CACHE,
      ae,
      ie
    );
    if (!se || !se.length)
      throw new Error(
        `Can not sign for input #${z} with the key ${ne.publicKey.toString(
          "hex"
        )}`
      );
    return se;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(z) {
    return this.data.updateGlobal(z), this;
  }
  updateInput(z, Y) {
    return Y.witnessScript && checkInvalidP2WSH(Y.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[z],
      Y,
      "updateInput"
    ), this.data.updateInput(z, Y), Y.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[z],
      z
    ), this;
  }
  updateOutput(z, Y) {
    const ne = this.data.outputs[z];
    return (0, bip371_1.checkTaprootOutputFields)(
      ne,
      Y,
      "updateOutput"
    ), this.data.updateOutput(z, Y), this;
  }
  addUnknownKeyValToGlobal(z) {
    return this.data.addUnknownKeyValToGlobal(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    return this.data.addUnknownKeyValToInput(z, Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    return this.data.addUnknownKeyValToOutput(z, Y), this;
  }
  clearFinalizedInput(z) {
    return this.data.clearFinalizedInput(z), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(z = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(z), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(z) {
    if (z.hash === void 0 || z.index === void 0 || !Buffer$1.isBuffer(z.hash) && typeof z.hash != "string" || typeof z.index != "number")
      throw new Error("Error adding input.");
    const Y = typeof z.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(z.hash, "hex")) : z.hash;
    this.tx.addInput(Y, z.index, z.sequence);
  }
  addOutput(z) {
    if (z.script === void 0 || z.value === void 0 || !Buffer$1.isBuffer(z.script) || typeof z.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(z.script, z.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, z, Y) {
  switch (Y) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const ne = payments.p2ms({ output: z });
      return hasSigs(ne.m, B.partialSig, ne.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, z, Y) {
  if (!z) return !1;
  let ne;
  if (Y ? ne = Y.map((ae) => {
    const ie = compressPubkey(ae);
    return z.find((se) => se.pubkey.equals(ie));
  }).filter((ae) => !!ae) : ne = z, ne.length > B) throw new Error("Too many signatures");
  return ne.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (z) => !(!z.masterFingerprint.equals(B.fingerprint) || !B.derivePath(z.path).publicKey.equals(z.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, z, Y) {
  const ne = z.__FEE_RATE || B.getFeeRate(), ae = z.__EXTRACTED_TX.virtualSize(), ie = ne * ae;
  if (ne >= Y.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(ie / 1e8).toFixed(8)} in fees, which is ${ne} satoshi per byte for a transaction with a VSize of ${ae} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, z) {
  B.forEach((Y) => {
    if ((0, bip371_1.isTaprootInput)(Y) ? (0, bip371_1.checkTaprootInputForSigs)(Y, z) : (0, psbtutils_1.checkInputForSig)(Y, z))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: z, sighashType: Y } = B;
  z.forEach((ne) => {
    const { hashType: ae } = bscript.signature.decode(ne.signature);
    if (Y !== ae)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, z, Y) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, z))
    throw new Error(
      `Can not ${Y} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (Y) => Y.script && Y.script.length === 0 && Y.witness && Y.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, z) {
  B.ins.forEach((Y) => {
    checkTxInputCache(z, Y);
  });
}
function checkTxInputCache(B, z) {
  const Y = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(z.hash)).toString("hex") + ":" + z.index;
  if (B.__TX_IN_CACHE[Y]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[Y] = 1;
}
function scriptCheckerFactory(B, z) {
  return (Y, ne, ae, ie) => {
    const se = B({
      redeem: { output: ae }
    }).output;
    if (!ne.equals(se))
      throw new Error(
        `${z} for ${ie} #${Y} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, z, Y, ne) {
  if (!Y.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${z}`);
  if (B === "__FEE_RATE" && ne.__FEE_RATE) return ne.__FEE_RATE;
  if (B === "__FEE" && ne.__FEE) return ne.__FEE;
  let ae, ie = !0;
  if (ne.__EXTRACTED_TX ? (ae = ne.__EXTRACTED_TX, ie = !1) : ae = ne.__TX.clone(), inputFinalizeGetAmts(Y, ae, ne, ie), B === "__FEE_RATE") return ne.__FEE_RATE;
  if (B === "__FEE") return ne.__FEE;
}
function getFinalScripts(B, z, Y, ne, ae, ie) {
  const se = classifyScript(Y);
  if (!canFinalize(z, Y, se))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    Y,
    se,
    z.partialSig,
    ne,
    ae,
    ie
  );
}
function prepareFinalScripts(B, z, Y, ne, ae, ie) {
  let se, le;
  const ve = getPayment(B, z, Y), ge = ie ? payments.p2wsh({ redeem: ve }) : null, oe = ae ? payments.p2sh({ redeem: ge || ve }) : null;
  return ne ? (ge ? le = (0, psbtutils_1.witnessStackToScriptWitness)(
    ge.witness
  ) : le = (0, psbtutils_1.witnessStackToScriptWitness)(
    ve.witness
  ), oe && (se = oe.input)) : oe ? se = oe.input : se = ve.input, {
    finalScriptSig: se,
    finalScriptWitness: le
  };
}
function getHashAndSighashType(B, z, Y, ne, ae) {
  const ie = (0, utils_1.checkForInput)(B, z), { hash: se, sighashType: le, script: ve } = getHashForSig(
    z,
    ie,
    ne,
    !1,
    ae
  );
  return checkScriptForPubkey(Y, ve, "sign"), {
    hash: se,
    sighashType: le
  };
}
function getHashForSig(B, z, Y, ne, ae) {
  const ie = Y.__TX, se = z.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(se, ae);
  let le, ve;
  if (z.nonWitnessUtxo) {
    const Ee = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), Ce = ie.ins[B].hash, Pe = Ee.getHash();
    if (!Ce.equals(Pe))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const Ve = ie.ins[B].index;
    ve = Ee.outs[Ve];
  } else if (z.witnessUtxo)
    ve = z.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: ge, type: oe } = getMeaningfulScript(
    ve.script,
    B,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(oe) >= 0)
    le = ie.hashForWitnessV0(
      B,
      ge,
      ve.value,
      se
    );
  else if ((0, psbtutils_1.isP2WPKH)(ge)) {
    const Ee = payments.p2pkh({
      hash: ge.slice(2)
    }).output;
    le = ie.hashForWitnessV0(
      B,
      Ee,
      ve.value,
      se
    );
  } else {
    if (z.nonWitnessUtxo === void 0 && Y.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${ge.toString("hex")}`
      );
    !ne && Y.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), le = ie.hashForSignature(
      B,
      ge,
      se
    );
  }
  return {
    script: ge,
    sighashType: se,
    hash: le
  };
}
function getAllTaprootHashesForSig(B, z, Y, ne) {
  const ae = [];
  if (z.tapInternalKey) {
    const se = getPrevoutTaprootKey(B, z, ne);
    se && ae.push(se);
  }
  if (z.tapScriptSig) {
    const se = z.tapScriptSig.map((le) => le.pubkey);
    ae.push(...se);
  }
  return ae.map(
    (se) => getTaprootHashesForSig(B, z, Y, se, ne)
  ).flat();
}
function getPrevoutTaprootKey(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return (0, psbtutils_1.isP2TR)(ne) ? ne.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, z, Y, ne, ae, ie, se) {
  const le = ae.__TX, ve = z.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ve, se);
  const ge = Y.map(
    (Ve, ht) => getScriptAndAmountFromUtxo(ht, Ve, ae)
  ), oe = ge.map((Ve) => Ve.script), Ee = ge.map((Ve) => Ve.value), Ce = [];
  if (z.tapInternalKey && !ie) {
    const Ve = getPrevoutTaprootKey(B, z, ae) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(ne).equals(Ve)) {
      const ht = le.hashForWitnessV1(
        B,
        oe,
        Ee,
        ve
      );
      Ce.push({ pubkey: ne, hash: ht });
    }
  }
  const Pe = (z.tapLeafScript || []).filter((Ve) => (0, psbtutils_1.pubkeyInScript)(ne, Ve.script)).map((Ve) => {
    const ht = (0, bip341_1.tapleafHash)({
      output: Ve.script,
      version: Ve.leafVersion
    });
    return Object.assign({ hash: ht }, Ve);
  }).filter(
    (Ve) => !ie || ie.equals(Ve.hash)
  ).map((Ve) => {
    const ht = le.hashForWitnessV1(
      B,
      oe,
      Ee,
      ve,
      Ve.hash
    );
    return {
      pubkey: ne,
      hash: ht,
      leafHash: Ve.hash
    };
  });
  return Ce.concat(Pe);
}
function checkSighashTypeAllowed(B, z) {
  if (z && z.indexOf(B) < 0) {
    const Y = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${Y}`
    );
  }
}
function getPayment(B, z, Y) {
  let ne;
  switch (z) {
    case "multisig":
      const ae = getSortedSigs(B, Y);
      ne = payments.p2ms({
        output: B,
        signatures: ae
      });
      break;
    case "pubkey":
      ne = payments.p2pk({
        output: B,
        signature: Y[0].signature
      });
      break;
    case "pubkeyhash":
      ne = payments.p2pkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
    case "witnesspubkeyhash":
      ne = payments.p2wpkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
  }
  return ne;
}
function getScriptFromInput(B, z, Y) {
  const ne = Y.__TX, ae = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (ae.isP2SH = !!z.redeemScript, ae.isP2WSH = !!z.witnessScript, z.witnessScript)
    ae.script = z.witnessScript;
  else if (z.redeemScript)
    ae.script = z.redeemScript;
  else if (z.nonWitnessUtxo) {
    const ie = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), se = ne.ins[B].index;
    ae.script = ie.outs[se].script;
  } else z.witnessUtxo && (ae.script = z.witnessUtxo.script);
  return (z.witnessScript || (0, psbtutils_1.isP2WPKH)(ae.script)) && (ae.isSegwit = !0), ae;
}
function getSignersFromHD(B, z, Y) {
  const ne = (0, utils_1.checkForInput)(z, B);
  if (!ne.bip32Derivation || ne.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const ae = ne.bip32Derivation.map((se) => {
    if (se.masterFingerprint.equals(Y.fingerprint))
      return se;
  }).filter((se) => !!se);
  if (ae.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return ae.map((se) => {
    const le = Y.derivePath(se.path);
    if (!se.pubkey.equals(le.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return le;
  });
}
function getSortedSigs(B, z) {
  return payments.p2ms({ output: B }).pubkeys.map((ne) => (z.filter((ae) => ae.pubkey.equals(ne))[0] || {}).signature).filter((ne) => !!ne);
}
function scriptWitnessToWitnessStack(B) {
  let z = 0;
  function Y(se) {
    return z += se, B.slice(z - se, z);
  }
  function ne() {
    const se = varuint.decode(B, z);
    return z += varuint.decode.bytes, se;
  }
  function ae() {
    return Y(ne());
  }
  function ie() {
    const se = ne(), le = [];
    for (let ve = 0; ve < se; ve++) le.push(ae());
    return le;
  }
  return ie();
}
function sighashTypeToString(B) {
  let z = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      z += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      z += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      z += "SIGHASH_NONE";
      break;
  }
  return z;
}
function addNonWitnessTxCache(B, z, Y) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[Y] = z.nonWitnessUtxo;
  const ne = transaction_1.Transaction.fromBuffer(z.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[Y] = ne;
  const ae = B, ie = Y;
  delete z.nonWitnessUtxo, Object.defineProperty(z, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const se = ae.__NON_WITNESS_UTXO_BUF_CACHE[ie], le = ae.__NON_WITNESS_UTXO_TX_CACHE[ie];
      if (se !== void 0)
        return se;
      {
        const ve = le.toBuffer();
        return ae.__NON_WITNESS_UTXO_BUF_CACHE[ie] = ve, ve;
      }
    },
    set(se) {
      ae.__NON_WITNESS_UTXO_BUF_CACHE[ie] = se;
    }
  });
}
function inputFinalizeGetAmts(B, z, Y, ne) {
  let ae = 0;
  B.forEach((ve, ge) => {
    if (ne && ve.finalScriptSig && (z.ins[ge].script = ve.finalScriptSig), ne && ve.finalScriptWitness && (z.ins[ge].witness = scriptWitnessToWitnessStack(
      ve.finalScriptWitness
    )), ve.witnessUtxo)
      ae += ve.witnessUtxo.value;
    else if (ve.nonWitnessUtxo) {
      const oe = nonWitnessUtxoTxFromCache(Y, ve, ge), Ee = z.ins[ge].index, Ce = oe.outs[Ee];
      ae += Ce.value;
    }
  });
  const ie = z.outs.reduce((ve, ge) => ve + ge.value, 0), se = ae - ie;
  if (se < 0)
    throw new Error("Outputs are spending more than Inputs");
  const le = z.virtualSize();
  Y.__FEE = se, Y.__EXTRACTED_TX = z, Y.__FEE_RATE = Math.floor(se / le);
}
function nonWitnessUtxoTxFromCache(B, z, Y) {
  const ne = B.__NON_WITNESS_UTXO_TX_CACHE;
  return ne[Y] || addNonWitnessTxCache(B, z, Y), ne[Y];
}
function getScriptFromUtxo(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return ne;
}
function getScriptAndAmountFromUtxo(B, z, Y) {
  if (z.witnessUtxo !== void 0)
    return {
      script: z.witnessUtxo.script,
      value: z.witnessUtxo.value
    };
  if (z.nonWitnessUtxo !== void 0) {
    const ae = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ).outs[Y.__TX.ins[B].index];
    return { script: ae.script, value: ae.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, z, Y, ne) {
  const ae = getScriptFromUtxo(Y, z, ne), { meaningfulScript: ie } = getMeaningfulScript(
    ae,
    Y,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ie);
}
function pubkeyInOutput(B, z, Y, ne) {
  const ae = ne.__TX.outs[Y].script, { meaningfulScript: ie } = getMeaningfulScript(
    ae,
    Y,
    "output",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ie);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const z = bscript.decompile(B);
  if (!z) return;
  const Y = z[z.length - 1];
  if (!(!Buffer$1.isBuffer(Y) || isPubkeyLike(Y) || isSigLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const z = scriptWitnessToWitnessStack(B), Y = z[z.length - 1];
  if (!(isPubkeyLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const z = B[64] & 1, Y = B.slice(0, 33);
    return Y[0] = 2 | z, Y;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, z, Y, ne, ae) {
  const ie = (0, psbtutils_1.isP2SHScript)(B), se = ie && ne && (0, psbtutils_1.isP2WSHScript)(ne), le = (0, psbtutils_1.isP2WSHScript)(B);
  if (ie && ne === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((le || se) && ae === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ve;
  return se ? (ve = ae, checkRedeemScript(z, B, ne, Y), checkWitnessScript(z, ne, ae, Y), checkInvalidP2WSH(ve)) : le ? (ve = ae, checkWitnessScript(z, B, ae, Y), checkInvalidP2WSH(ve)) : ie ? (ve = ne, checkRedeemScript(z, B, ne, Y)) : ve = B, {
    meaningfulScript: ve,
    type: se ? "p2sh-p2wsh" : ie ? "p2sh" : le ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const z = requireAddress();
  B.address = z;
  const Y = crypto$1;
  B.crypto = Y;
  const ne = networks;
  B.networks = ne;
  const ae = requirePayments();
  B.payments = ae;
  const ie = requireScript();
  B.script = ie;
  var se = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return se.Block;
    }
  });
  var le = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return le.Psbt;
    }
  });
  var ve = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return ve.OPS;
    }
  });
  var ge = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return ge.Transaction;
    }
  });
  var oe = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return oe.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: B, publicKey: z, format: Y, wallet: ne } = useOrdConnect(), [ae, ie] = useState(null), [se, le] = useState(!1);
  return { sign: useCallback(
    async (ge, oe, Ee) => {
      le(!0);
      try {
        if (ie(null), !Y || !z || !ne)
          throw new Error("No wallet is connected");
        const Ce = src$1.Psbt.fromBase64(oe), Pe = await signPsbt({
          address: ge,
          wallet: ne,
          network: B,
          psbt: Ce,
          options: Ee
        });
        return le(!1), Pe;
      } catch (Ce) {
        throw ie(Ce.message), le(!1), Ce;
      }
    },
    [Y, B, z, ne]
  ), error: ae, loading: se };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signXverseMessage(B, z, Y) {
  if (!B || !Y || !z)
    throw new OrditSDKError("Invalid options provided");
  let ne, ae = null;
  const ie = await request("signMessage", {
    address: z,
    message: B
  }, "XverseProviders.BitcoinProvider");
  if (console.log("xxxresponse", ie), !ie)
    throw new BrowserWalletSigningError(
      "Failed to sign message using selected wallet"
    );
  if (ie.status === "success")
    ne = Buffer$1.from(ie.result.signature, "base64").toString("hex"), ae = ie.result.signature;
  else throw ie.error.code === RpcErrorCode.USER_REJECTION ? new BrowserWalletRequestCancelledByUserError() : new Error("Failed to sign message");
  return { hex: ne, base64: ae };
}
async function signMessage({
  message: B,
  wallet: z,
  address: Y,
  network: ne,
  format: ae
}) {
  if (z === Wallet.MAGICEDEN) {
    const { base64: ie } = await signMessage$1(B, Y, ne);
    return ie;
  }
  if (z === Wallet.UNISAT) {
    const { base64: ie } = await signMessage$2(B, "bip322-simple");
    return ie;
  }
  if (z === Wallet.XVERSE) {
    const { base64: ie } = await signXverseMessage(B, Y, ne);
    return ie;
  }
  if (z === Wallet.LEATHER) {
    const ie = leatherPaymentTypeFromFormat(ae), { base64: se } = await signMessage$3(B, {
      paymentType: ie,
      network: ne
    });
    return se;
  }
  if (z === Wallet.OKX) {
    const { base64: ie } = await signMessage$4(B, "bip322-simple", ne);
    return ie;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: z,
    publicKey: Y,
    format: ne,
    address: ae
  } = useOrdConnect(), [ie, se] = useState(null), [le, ve] = useState(!1);
  return { signMsg: useCallback(
    async (oe, Ee) => {
      ve(!0);
      try {
        if (se(null), !ne || !Y || !z)
          throw new Error("No wallet is connected");
        if (ae.ordinals !== oe && ae.payments !== oe)
          throw new Error("Address supplied is not connected address");
        const Ce = await signMessage({
          address: oe,
          wallet: z,
          message: Ee,
          network: B,
          format: ae.ordinals === oe ? ne.ordinals : ne.payments
        });
        return ve(!1), Ce;
      } catch (Ce) {
        throw console.log("==>err", Ce), se(Ce.message), ve(!1), Ce;
      }
    },
    [ne, B, Y, z, ae]
  ), error: ie, isLoading: le };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
