(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as C$2 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletRequestCancelledByUserError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { createPortal } from "react-dom";
import { signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(A) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(A, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(A, 0);
  try {
    return cachedSetTimeout(A, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, A, 0);
    } catch {
      return cachedSetTimeout.call(this, A, 0);
    }
  }
}
function runClearTimeout(A) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(A);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(A);
  try {
    return cachedClearTimeout(A);
  } catch {
    try {
      return cachedClearTimeout.call(null, A);
    } catch {
      return cachedClearTimeout.call(this, A);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var A = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var B = queue.length; B; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < B; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, B = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(A);
  }
}
process.nextTick = function(A) {
  var B = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var L = 1; L < arguments.length; L++)
      B[L - 1] = arguments[L];
  queue.push(new Item(A, B)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(A, B) {
  this.fun = A, this.array = B;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(A) {
  return [];
};
process.binding = function(A) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(A) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.fragment"), K = Object.prototype.hasOwnProperty, V = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, W = { key: !0, ref: !0, __self: !0, __source: !0 };
  function J(ne, ie, ce) {
    var re, oe = {}, ke = null, Ce = null;
    ce !== void 0 && (ke = "" + ce), ie.key !== void 0 && (ke = "" + ie.key), ie.ref !== void 0 && (Ce = ie.ref);
    for (re in ie) K.call(ie, re) && !W.hasOwnProperty(re) && (oe[re] = ie[re]);
    if (ne && ne.defaultProps) for (re in ie = ne.defaultProps, ie) oe[re] === void 0 && (oe[re] = ie[re]);
    return { $$typeof: B, type: ne, key: ke, ref: Ce, props: oe, _owner: V.current };
  }
  return reactJsxRuntime_production_min.Fragment = L, reactJsxRuntime_production_min.jsx = J, reactJsxRuntime_production_min.jsxs = J, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), J = Symbol.for("react.provider"), ne = Symbol.for("react.context"), ie = Symbol.for("react.forward_ref"), ce = Symbol.for("react.suspense"), re = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), ke = Symbol.for("react.lazy"), Ce = Symbol.for("react.offscreen"), it = Symbol.iterator, at = "@@iterator";
    function ct(Dt) {
      if (Dt === null || typeof Dt != "object")
        return null;
      var er = it && Dt[it] || Dt[at];
      return typeof er == "function" ? er : null;
    }
    var dt = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ot(Dt) {
      {
        for (var er = arguments.length, ir = new Array(er > 1 ? er - 1 : 0), fr = 1; fr < er; fr++)
          ir[fr - 1] = arguments[fr];
        yt("error", Dt, ir);
      }
    }
    function yt(Dt, er, ir) {
      {
        var fr = dt.ReactDebugCurrentFrame, Ar = fr.getStackAddendum();
        Ar !== "" && (er += "%s", ir = ir.concat([Ar]));
        var Sr = ir.map(function(gr) {
          return String(gr);
        });
        Sr.unshift("Warning: " + er), Function.prototype.apply.call(console[Dt], console, Sr);
      }
    }
    var mt = !1, Tt = !1, Pt = !1, Nt = !1, St = !1, vt;
    vt = Symbol.for("react.module.reference");
    function It(Dt) {
      return !!(typeof Dt == "string" || typeof Dt == "function" || Dt === K || Dt === W || St || Dt === V || Dt === ce || Dt === re || Nt || Dt === Ce || mt || Tt || Pt || typeof Dt == "object" && Dt !== null && (Dt.$$typeof === ke || Dt.$$typeof === oe || Dt.$$typeof === J || Dt.$$typeof === ne || Dt.$$typeof === ie || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Dt.$$typeof === vt || Dt.getModuleId !== void 0));
    }
    function wt(Dt, er, ir) {
      var fr = Dt.displayName;
      if (fr)
        return fr;
      var Ar = er.displayName || er.name || "";
      return Ar !== "" ? ir + "(" + Ar + ")" : ir;
    }
    function Oe(Dt) {
      return Dt.displayName || "Context";
    }
    function rt(Dt) {
      if (Dt == null)
        return null;
      if (typeof Dt.tag == "number" && ot("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Dt == "function")
        return Dt.displayName || Dt.name || null;
      if (typeof Dt == "string")
        return Dt;
      switch (Dt) {
        case K:
          return "Fragment";
        case L:
          return "Portal";
        case W:
          return "Profiler";
        case V:
          return "StrictMode";
        case ce:
          return "Suspense";
        case re:
          return "SuspenseList";
      }
      if (typeof Dt == "object")
        switch (Dt.$$typeof) {
          case ne:
            var er = Dt;
            return Oe(er) + ".Consumer";
          case J:
            var ir = Dt;
            return Oe(ir._context) + ".Provider";
          case ie:
            return wt(Dt, Dt.render, "ForwardRef");
          case oe:
            var fr = Dt.displayName || null;
            return fr !== null ? fr : rt(Dt.type) || "Memo";
          case ke: {
            var Ar = Dt, Sr = Ar._payload, gr = Ar._init;
            try {
              return rt(gr(Sr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var pe = Object.assign, nt = 0, st, ft, ht, bt, ut, gt, lt;
    function $t() {
    }
    $t.__reactDisabledLog = !0;
    function jt() {
      {
        if (nt === 0) {
          st = console.log, ft = console.info, ht = console.warn, bt = console.error, ut = console.group, gt = console.groupCollapsed, lt = console.groupEnd;
          var Dt = {
            configurable: !0,
            enumerable: !0,
            value: $t,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Dt,
            log: Dt,
            warn: Dt,
            error: Dt,
            group: Dt,
            groupCollapsed: Dt,
            groupEnd: Dt
          });
        }
        nt++;
      }
    }
    function Jt() {
      {
        if (nt--, nt === 0) {
          var Dt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: pe({}, Dt, {
              value: st
            }),
            info: pe({}, Dt, {
              value: ft
            }),
            warn: pe({}, Dt, {
              value: ht
            }),
            error: pe({}, Dt, {
              value: bt
            }),
            group: pe({}, Dt, {
              value: ut
            }),
            groupCollapsed: pe({}, Dt, {
              value: gt
            }),
            groupEnd: pe({}, Dt, {
              value: lt
            })
          });
        }
        nt < 0 && ot("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Lt = dt.ReactCurrentDispatcher, Rt;
    function Mt(Dt, er, ir) {
      {
        if (Rt === void 0)
          try {
            throw Error();
          } catch (Ar) {
            var fr = Ar.stack.trim().match(/\n( *(at )?)/);
            Rt = fr && fr[1] || "";
          }
        return `
` + Rt + Dt;
      }
    }
    var Kt = !1, zt;
    {
      var Ct = typeof WeakMap == "function" ? WeakMap : Map;
      zt = new Ct();
    }
    function kt(Dt, er) {
      if (!Dt || Kt)
        return "";
      {
        var ir = zt.get(Dt);
        if (ir !== void 0)
          return ir;
      }
      var fr;
      Kt = !0;
      var Ar = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Sr;
      Sr = Lt.current, Lt.current = null, jt();
      try {
        if (er) {
          var gr = function() {
            throw Error();
          };
          if (Object.defineProperty(gr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(gr, []);
            } catch (Fr) {
              fr = Fr;
            }
            Reflect.construct(Dt, [], gr);
          } else {
            try {
              gr.call();
            } catch (Fr) {
              fr = Fr;
            }
            Dt.call(gr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Fr) {
            fr = Fr;
          }
          Dt();
        }
      } catch (Fr) {
        if (Fr && fr && typeof Fr.stack == "string") {
          for (var Tr = Fr.stack.split(`
`), Nr = fr.stack.split(`
`), Cr = Tr.length - 1, qr = Nr.length - 1; Cr >= 1 && qr >= 0 && Tr[Cr] !== Nr[qr]; )
            qr--;
          for (; Cr >= 1 && qr >= 0; Cr--, qr--)
            if (Tr[Cr] !== Nr[qr]) {
              if (Cr !== 1 || qr !== 1)
                do
                  if (Cr--, qr--, qr < 0 || Tr[Cr] !== Nr[qr]) {
                    var Ur = `
` + Tr[Cr].replace(" at new ", " at ");
                    return Dt.displayName && Ur.includes("<anonymous>") && (Ur = Ur.replace("<anonymous>", Dt.displayName)), typeof Dt == "function" && zt.set(Dt, Ur), Ur;
                  }
                while (Cr >= 1 && qr >= 0);
              break;
            }
        }
      } finally {
        Kt = !1, Lt.current = Sr, Jt(), Error.prepareStackTrace = Ar;
      }
      var Dr = Dt ? Dt.displayName || Dt.name : "", Lr = Dr ? Mt(Dr) : "";
      return typeof Dt == "function" && zt.set(Dt, Lr), Lr;
    }
    function Vt(Dt, er, ir) {
      return kt(Dt, !1);
    }
    function nr(Dt) {
      var er = Dt.prototype;
      return !!(er && er.isReactComponent);
    }
    function ar(Dt, er, ir) {
      if (Dt == null)
        return "";
      if (typeof Dt == "function")
        return kt(Dt, nr(Dt));
      if (typeof Dt == "string")
        return Mt(Dt);
      switch (Dt) {
        case ce:
          return Mt("Suspense");
        case re:
          return Mt("SuspenseList");
      }
      if (typeof Dt == "object")
        switch (Dt.$$typeof) {
          case ie:
            return Vt(Dt.render);
          case oe:
            return ar(Dt.type, er, ir);
          case ke: {
            var fr = Dt, Ar = fr._payload, Sr = fr._init;
            try {
              return ar(Sr(Ar), er, ir);
            } catch {
            }
          }
        }
      return "";
    }
    var sr = Object.prototype.hasOwnProperty, lr = {}, dr = dt.ReactDebugCurrentFrame;
    function rr(Dt) {
      if (Dt) {
        var er = Dt._owner, ir = ar(Dt.type, Dt._source, er ? er.type : null);
        dr.setExtraStackFrame(ir);
      } else
        dr.setExtraStackFrame(null);
    }
    function Pr(Dt, er, ir, fr, Ar) {
      {
        var Sr = Function.call.bind(sr);
        for (var gr in Dt)
          if (Sr(Dt, gr)) {
            var Tr = void 0;
            try {
              if (typeof Dt[gr] != "function") {
                var Nr = Error((fr || "React class") + ": " + ir + " type `" + gr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Dt[gr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Nr.name = "Invariant Violation", Nr;
              }
              Tr = Dt[gr](er, gr, fr, ir, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Cr) {
              Tr = Cr;
            }
            Tr && !(Tr instanceof Error) && (rr(Ar), ot("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", fr || "React class", ir, gr, typeof Tr), rr(null)), Tr instanceof Error && !(Tr.message in lr) && (lr[Tr.message] = !0, rr(Ar), ot("Failed %s type: %s", ir, Tr.message), rr(null));
          }
      }
    }
    var ur = Array.isArray;
    function pr(Dt) {
      return ur(Dt);
    }
    function br(Dt) {
      {
        var er = typeof Symbol == "function" && Symbol.toStringTag, ir = er && Dt[Symbol.toStringTag] || Dt.constructor.name || "Object";
        return ir;
      }
    }
    function hr(Dt) {
      try {
        return xr(Dt), !1;
      } catch {
        return !0;
      }
    }
    function xr(Dt) {
      return "" + Dt;
    }
    function Mr(Dt) {
      if (hr(Dt))
        return ot("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", br(Dt)), xr(Dt);
    }
    var _r = dt.ReactCurrentOwner, Rr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, kr, Ot;
    function At(Dt) {
      if (sr.call(Dt, "ref")) {
        var er = Object.getOwnPropertyDescriptor(Dt, "ref").get;
        if (er && er.isReactWarning)
          return !1;
      }
      return Dt.ref !== void 0;
    }
    function Bt(Dt) {
      if (sr.call(Dt, "key")) {
        var er = Object.getOwnPropertyDescriptor(Dt, "key").get;
        if (er && er.isReactWarning)
          return !1;
      }
      return Dt.key !== void 0;
    }
    function Ut(Dt, er) {
      typeof Dt.ref == "string" && _r.current;
    }
    function Xt(Dt, er) {
      {
        var ir = function() {
          kr || (kr = !0, ot("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", er));
        };
        ir.isReactWarning = !0, Object.defineProperty(Dt, "key", {
          get: ir,
          configurable: !0
        });
      }
    }
    function Zt(Dt, er) {
      {
        var ir = function() {
          Ot || (Ot = !0, ot("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", er));
        };
        ir.isReactWarning = !0, Object.defineProperty(Dt, "ref", {
          get: ir,
          configurable: !0
        });
      }
    }
    var tr = function(Dt, er, ir, fr, Ar, Sr, gr) {
      var Tr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: B,
        // Built-in properties that belong on the element
        type: Dt,
        key: er,
        ref: ir,
        props: gr,
        // Record the component responsible for creating this element.
        _owner: Sr
      };
      return Tr._store = {}, Object.defineProperty(Tr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Tr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: fr
      }), Object.defineProperty(Tr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ar
      }), Object.freeze && (Object.freeze(Tr.props), Object.freeze(Tr)), Tr;
    };
    function vr(Dt, er, ir, fr, Ar) {
      {
        var Sr, gr = {}, Tr = null, Nr = null;
        ir !== void 0 && (Mr(ir), Tr = "" + ir), Bt(er) && (Mr(er.key), Tr = "" + er.key), At(er) && (Nr = er.ref, Ut(er, Ar));
        for (Sr in er)
          sr.call(er, Sr) && !Rr.hasOwnProperty(Sr) && (gr[Sr] = er[Sr]);
        if (Dt && Dt.defaultProps) {
          var Cr = Dt.defaultProps;
          for (Sr in Cr)
            gr[Sr] === void 0 && (gr[Sr] = Cr[Sr]);
        }
        if (Tr || Nr) {
          var qr = typeof Dt == "function" ? Dt.displayName || Dt.name || "Unknown" : Dt;
          Tr && Xt(gr, qr), Nr && Zt(gr, qr);
        }
        return tr(Dt, Tr, Nr, Ar, fr, _r.current, gr);
      }
    }
    var Br = dt.ReactCurrentOwner, yr = dt.ReactDebugCurrentFrame;
    function $r(Dt) {
      if (Dt) {
        var er = Dt._owner, ir = ar(Dt.type, Dt._source, er ? er.type : null);
        yr.setExtraStackFrame(ir);
      } else
        yr.setExtraStackFrame(null);
    }
    var Er;
    Er = !1;
    function wr(Dt) {
      return typeof Dt == "object" && Dt !== null && Dt.$$typeof === B;
    }
    function Ir() {
      {
        if (Br.current) {
          var Dt = rt(Br.current.type);
          if (Dt)
            return `

Check the render method of \`` + Dt + "`.";
        }
        return "";
      }
    }
    function Or(Dt) {
      return "";
    }
    var Wt = {};
    function Ft(Dt) {
      {
        var er = Ir();
        if (!er) {
          var ir = typeof Dt == "string" ? Dt : Dt.displayName || Dt.name;
          ir && (er = `

Check the top-level render call using <` + ir + ">.");
        }
        return er;
      }
    }
    function Gt(Dt, er) {
      {
        if (!Dt._store || Dt._store.validated || Dt.key != null)
          return;
        Dt._store.validated = !0;
        var ir = Ft(er);
        if (Wt[ir])
          return;
        Wt[ir] = !0;
        var fr = "";
        Dt && Dt._owner && Dt._owner !== Br.current && (fr = " It was passed a child from " + rt(Dt._owner.type) + "."), $r(Dt), ot('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ir, fr), $r(null);
      }
    }
    function xt(Dt, er) {
      {
        if (typeof Dt != "object")
          return;
        if (pr(Dt))
          for (var ir = 0; ir < Dt.length; ir++) {
            var fr = Dt[ir];
            wr(fr) && Gt(fr, er);
          }
        else if (wr(Dt))
          Dt._store && (Dt._store.validated = !0);
        else if (Dt) {
          var Ar = ct(Dt);
          if (typeof Ar == "function" && Ar !== Dt.entries)
            for (var Sr = Ar.call(Dt), gr; !(gr = Sr.next()).done; )
              wr(gr.value) && Gt(gr.value, er);
        }
      }
    }
    function pt(Dt) {
      {
        var er = Dt.type;
        if (er == null || typeof er == "string")
          return;
        var ir;
        if (typeof er == "function")
          ir = er.propTypes;
        else if (typeof er == "object" && (er.$$typeof === ie || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        er.$$typeof === oe))
          ir = er.propTypes;
        else
          return;
        if (ir) {
          var fr = rt(er);
          Pr(ir, Dt.props, "prop", fr, Dt);
        } else if (er.PropTypes !== void 0 && !Er) {
          Er = !0;
          var Ar = rt(er);
          ot("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ar || "Unknown");
        }
        typeof er.getDefaultProps == "function" && !er.getDefaultProps.isReactClassApproved && ot("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Et(Dt) {
      {
        for (var er = Object.keys(Dt.props), ir = 0; ir < er.length; ir++) {
          var fr = er[ir];
          if (fr !== "children" && fr !== "key") {
            $r(Dt), ot("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", fr), $r(null);
            break;
          }
        }
        Dt.ref !== null && ($r(Dt), ot("Invalid attribute `ref` supplied to `React.Fragment`."), $r(null));
      }
    }
    var qt = {};
    function Ht(Dt, er, ir, fr, Ar, Sr) {
      {
        var gr = It(Dt);
        if (!gr) {
          var Tr = "";
          (Dt === void 0 || typeof Dt == "object" && Dt !== null && Object.keys(Dt).length === 0) && (Tr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Nr = Or();
          Nr ? Tr += Nr : Tr += Ir();
          var Cr;
          Dt === null ? Cr = "null" : pr(Dt) ? Cr = "array" : Dt !== void 0 && Dt.$$typeof === B ? (Cr = "<" + (rt(Dt.type) || "Unknown") + " />", Tr = " Did you accidentally export a JSX literal instead of a component?") : Cr = typeof Dt, ot("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Cr, Tr);
        }
        var qr = vr(Dt, er, ir, Ar, Sr);
        if (qr == null)
          return qr;
        if (gr) {
          var Ur = er.children;
          if (Ur !== void 0)
            if (fr)
              if (pr(Ur)) {
                for (var Dr = 0; Dr < Ur.length; Dr++)
                  xt(Ur[Dr], Dt);
                Object.freeze && Object.freeze(Ur);
              } else
                ot("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              xt(Ur, Dt);
        }
        if (sr.call(er, "key")) {
          var Lr = rt(Dt), Fr = Object.keys(er).filter(function(Wr) {
            return Wr !== "key";
          }), jr = Fr.length > 0 ? "{key: someKey, " + Fr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!qt[Lr + jr]) {
            var Hr = Fr.length > 0 ? "{" + Fr.join(": ..., ") + ": ...}" : "{}";
            ot(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, jr, Lr, Hr, Lr), qt[Lr + jr] = !0;
          }
        }
        return Dt === K ? Et(qr) : pt(qr), qr;
      }
    }
    function Yt(Dt, er, ir) {
      return Ht(Dt, er, ir, !0);
    }
    function Qt(Dt, er, ir) {
      return Ht(Dt, er, ir, !1);
    }
    var or = Qt, cr = Yt;
    reactJsxRuntime_development.Fragment = K, reactJsxRuntime_development.jsx = or, reactJsxRuntime_development.jsxs = cr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [A, B] = useState(!1);
  return useEffect(() => {
    B(!0);
  }, []), A;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(A) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${A} even though environment is not a browser.`
  );
  const B = `${KEY_PREFIX}_${A}`;
  try {
    const L = window.localStorage.getItem(B);
    return L != null ? JSON.parse(L) : null;
  } catch (L) {
    return console.error(`Error retrieving ${B} from localStorage`, L), null;
  }
}
function setItemToLocalStorage(A, B) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${A} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${A}`;
  try {
    B ? window.localStorage.setItem(L, JSON.stringify(B)) : window.localStorage.removeItem(L);
  } catch (K) {
    console.error(`Error saving ${L} to localStorage`, K);
  }
}
function useLocalStorage(A, B, L = {}) {
  const { initializeWithValue: K = !0 } = L, V = useCallback(() => {
    const ie = getItemFromLocalStorage(A);
    return ie || (setItemToLocalStorage(A, B), B);
  }, [B, A]), [W, J] = useState(() => K ? V() : B), ne = useCallback(
    (ie) => {
      setItemToLocalStorage(A, ie), J(ie);
    },
    [A]
  );
  return useEffect(() => {
    J(V());
  }, [A]), [W, ne];
}
var Network = /* @__PURE__ */ ((A) => (A.MAINNET = "mainnet", A.TESTNET = "testnet", A.SIGNET = "signet", A))(Network || {}), Wallet = /* @__PURE__ */ ((A) => (A.UNISAT = "unisat", A.XVERSE = "xverse", A.MAGICEDEN = "magiceden", A.LEATHER = "leather", A.OKX = "okx", A))(Wallet || {}), Chain = /* @__PURE__ */ ((A) => (A.BITCOIN = "bitcoin", A.FRACTAL_BITCOIN = "fractal-bitcoin", A))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: A,
  network: B,
  visibleWallets: L,
  chain: K = "bitcoin",
  ssr: V = !1
}) {
  if (!B)
    throw new Error("Network cannot be empty");
  if (!L || L.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [W, J] = useState(B), [ne, ie] = useState(L), [ce, re] = useState(K), [oe, ke] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !V }
  ), [Ce, it] = useLocalStorage(WALLET, null, {
    initializeWithValue: !V
  }), [at, ct] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !V }
  ), [dt, ot] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !V }
  ), [yt, mt] = useState(!1), Tt = useCallback(() => mt(!0), []), Pt = useCallback(() => mt(!1), []), Nt = useCallback(() => {
    ke(EMPTY_BIADDRESS_OBJECT), ct(EMPTY_BIADDRESS_OBJECT), ot(EMPTY_BIADDRESS_OBJECT), it(null);
  }, [ke, ot, ct, it]), St = useMemo(
    () => ({
      address: oe,
      updateAddress: ke,
      publicKey: at,
      updatePublicKey: ct,
      network: W,
      updateNetwork: (vt) => {
        J(Ce === "xverse" && vt === "testnet" ? "testnet4" : vt);
      },
      wallet: Ce,
      updateWallet: (vt) => {
        (W === "testnet" || W === "testnet4") && J(vt === "xverse" ? "testnet4" : "testnet"), it(vt);
      },
      isModalOpen: yt,
      openModal: Tt,
      closeModal: Pt,
      format: dt,
      updateFormat: ot,
      disconnectWallet: Nt,
      chain: ce,
      updateChain: re,
      visibleWallets: ne,
      updateVisibleWallets: ie
    }),
    [
      oe,
      ke,
      at,
      ct,
      W,
      J,
      Ce,
      it,
      yt,
      Tt,
      Pt,
      dt,
      ot,
      Nt,
      ce,
      re
    ]
  );
  return useEffect(() => {
    J(B);
  }, [B]), useEffect(() => {
    ce !== K && (Nt(), re(K));
  }, [K, ce, Nt]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: St, children: A });
}
function useOrdConnect() {
  const A = useContext(OrdConnectContext);
  if (console.log("+context", A), !A)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return A;
}
var build = { exports: {} };
(function(A, B) {
  (function(L, K) {
    A.exports = K(C__default);
  })(commonjsGlobal, function(L) {
    return function(K) {
      var V = {};
      function W(J) {
        if (V[J]) return V[J].exports;
        var ne = V[J] = { i: J, l: !1, exports: {} };
        return K[J].call(ne.exports, ne, ne.exports, W), ne.l = !0, ne.exports;
      }
      return W.m = K, W.c = V, W.d = function(J, ne, ie) {
        W.o(J, ne) || Object.defineProperty(J, ne, { enumerable: !0, get: ie });
      }, W.r = function(J) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(J, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(J, "__esModule", { value: !0 });
      }, W.t = function(J, ne) {
        if (1 & ne && (J = W(J)), 8 & ne || 4 & ne && typeof J == "object" && J && J.__esModule) return J;
        var ie = /* @__PURE__ */ Object.create(null);
        if (W.r(ie), Object.defineProperty(ie, "default", { enumerable: !0, value: J }), 2 & ne && typeof J != "string") for (var ce in J) W.d(ie, ce, (function(re) {
          return J[re];
        }).bind(null, ce));
        return ie;
      }, W.n = function(J) {
        var ne = J && J.__esModule ? function() {
          return J.default;
        } : function() {
          return J;
        };
        return W.d(ne, "a", ne), ne;
      }, W.o = function(J, ne) {
        return Object.prototype.hasOwnProperty.call(J, ne);
      }, W.p = "/", W(W.s = 1);
    }([function(K, V) {
      K.exports = L;
    }, function(K, V, W) {
      K.exports = W(2);
    }, function(K, V, W) {
      function J(ot, yt) {
        if (ot == null) return {};
        var mt, Tt, Pt = function(St, vt) {
          if (St == null) return {};
          var It, wt, Oe = {}, rt = Object.keys(St);
          for (wt = 0; wt < rt.length; wt++) It = rt[wt], vt.indexOf(It) >= 0 || (Oe[It] = St[It]);
          return Oe;
        }(ot, yt);
        if (Object.getOwnPropertySymbols) {
          var Nt = Object.getOwnPropertySymbols(ot);
          for (Tt = 0; Tt < Nt.length; Tt++) mt = Nt[Tt], yt.indexOf(mt) >= 0 || Object.prototype.propertyIsEnumerable.call(ot, mt) && (Pt[mt] = ot[mt]);
        }
        return Pt;
      }
      W.r(V);
      var ne = W(0), ie = W.n(ne), ce = function(ot) {
        for (var yt = 0, mt = 0; mt < ot.length; mt++)
          yt = (yt << 5) - yt + ot.charCodeAt(mt), yt &= yt;
        return Math.abs(yt);
      }, re = function(ot, yt) {
        return Math.floor(ot / Math.pow(10, yt) % 10);
      }, oe = function(ot, yt) {
        return !(re(ot, yt) % 2);
      }, ke = function(ot, yt, mt) {
        var Tt = ot % yt;
        return mt && re(ot, mt) % 2 === 0 ? -Tt : Tt;
      }, Ce = function(ot, yt, mt) {
        return yt[ot % mt];
      }, it = function(ot) {
        var yt = ot.name, mt = ot.colors, Tt = ot.title, Pt = ot.square, Nt = ot.size, St = J(ot, ["name", "colors", "title", "square", "size"]), vt = function(wt, Oe) {
          var rt = ce(wt), pe = Oe && Oe.length;
          return Array.from({ length: 3 }, function(nt, st) {
            return { color: Ce(rt + st, Oe, pe), translateX: ke(rt * (st + 1), 8, 1), translateY: ke(rt * (st + 1), 8, 2), scale: 1.2 + ke(rt * (st + 1), 4) / 10, rotate: ke(rt * (st + 1), 360, 1) };
          });
        }(yt, mt), It = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, St), Tt && ne.createElement("title", null, yt), ne.createElement("mask", { id: It, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: Pt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(It, ")") }, ne.createElement("rect", { width: 80, height: 80, fill: vt[0].color }), ne.createElement("path", { filter: "url(#filter_".concat(It, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: vt[1].color, transform: "translate(" + vt[1].translateX + " " + vt[1].translateY + ") rotate(" + vt[1].rotate + " 40 40) scale(" + vt[2].scale + ")" }), ne.createElement("path", { filter: "url(#filter_".concat(It, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: vt[2].color, transform: "translate(" + vt[2].translateX + " " + vt[2].translateY + ") rotate(" + vt[2].rotate + " 40 40) scale(" + vt[2].scale + ")" })), ne.createElement("defs", null, ne.createElement("filter", { id: "filter_".concat(It), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, ne.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), ne.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), ne.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, at = { pixel: function(ot) {
        var yt = ot.name, mt = ot.colors, Tt = ot.title, Pt = ot.square, Nt = ot.size, St = J(ot, ["name", "colors", "title", "square", "size"]), vt = function(wt, Oe) {
          var rt = ce(wt), pe = Oe && Oe.length;
          return Array.from({ length: 64 }, function(nt, st) {
            return Ce(rt % (st + 1), Oe, pe);
          });
        }(yt, mt), It = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, St), Tt && ne.createElement("title", null, yt), ne.createElement("mask", { id: It, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: Pt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(It, ")") }, ne.createElement("rect", { width: 10, height: 10, fill: vt[0] }), ne.createElement("rect", { x: 20, width: 10, height: 10, fill: vt[1] }), ne.createElement("rect", { x: 40, width: 10, height: 10, fill: vt[2] }), ne.createElement("rect", { x: 60, width: 10, height: 10, fill: vt[3] }), ne.createElement("rect", { x: 10, width: 10, height: 10, fill: vt[4] }), ne.createElement("rect", { x: 30, width: 10, height: 10, fill: vt[5] }), ne.createElement("rect", { x: 50, width: 10, height: 10, fill: vt[6] }), ne.createElement("rect", { x: 70, width: 10, height: 10, fill: vt[7] }), ne.createElement("rect", { y: 10, width: 10, height: 10, fill: vt[8] }), ne.createElement("rect", { y: 20, width: 10, height: 10, fill: vt[9] }), ne.createElement("rect", { y: 30, width: 10, height: 10, fill: vt[10] }), ne.createElement("rect", { y: 40, width: 10, height: 10, fill: vt[11] }), ne.createElement("rect", { y: 50, width: 10, height: 10, fill: vt[12] }), ne.createElement("rect", { y: 60, width: 10, height: 10, fill: vt[13] }), ne.createElement("rect", { y: 70, width: 10, height: 10, fill: vt[14] }), ne.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: vt[15] }), ne.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: vt[16] }), ne.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: vt[17] }), ne.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: vt[18] }), ne.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: vt[19] }), ne.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: vt[20] }), ne.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: vt[21] }), ne.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: vt[22] }), ne.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: vt[23] }), ne.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: vt[24] }), ne.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: vt[25] }), ne.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: vt[26] }), ne.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: vt[27] }), ne.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: vt[28] }), ne.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: vt[29] }), ne.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: vt[30] }), ne.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: vt[31] }), ne.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: vt[32] }), ne.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: vt[33] }), ne.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: vt[34] }), ne.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: vt[35] }), ne.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: vt[36] }), ne.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: vt[37] }), ne.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: vt[38] }), ne.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: vt[39] }), ne.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: vt[40] }), ne.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: vt[41] }), ne.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: vt[42] }), ne.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: vt[43] }), ne.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: vt[44] }), ne.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: vt[45] }), ne.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: vt[46] }), ne.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: vt[47] }), ne.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: vt[48] }), ne.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: vt[49] }), ne.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: vt[50] }), ne.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: vt[51] }), ne.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: vt[52] }), ne.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: vt[53] }), ne.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: vt[54] }), ne.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: vt[55] }), ne.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: vt[56] }), ne.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: vt[57] }), ne.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: vt[58] }), ne.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: vt[59] }), ne.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: vt[60] }), ne.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: vt[61] }), ne.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: vt[62] }), ne.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: vt[63] })));
      }, bauhaus: function(ot) {
        var yt = ot.name, mt = ot.colors, Tt = ot.title, Pt = ot.square, Nt = ot.size, St = J(ot, ["name", "colors", "title", "square", "size"]), vt = function(wt, Oe) {
          var rt = ce(wt), pe = Oe && Oe.length;
          return Array.from({ length: 4 }, function(nt, st) {
            return { color: Ce(rt + st, Oe, pe), translateX: ke(rt * (st + 1), 40 - (st + 17), 1), translateY: ke(rt * (st + 1), 40 - (st + 17), 2), rotate: ke(rt * (st + 1), 360), isSquare: oe(rt, 2) };
          });
        }(yt, mt), It = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, St), Tt && ne.createElement("title", null, yt), ne.createElement("mask", { id: It, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: Pt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(It, ")") }, ne.createElement("rect", { width: 80, height: 80, fill: vt[0].color }), ne.createElement("rect", { x: 10, y: 30, width: 80, height: vt[1].isSquare ? 80 : 10, fill: vt[1].color, transform: "translate(" + vt[1].translateX + " " + vt[1].translateY + ") rotate(" + vt[1].rotate + " 40 40)" }), ne.createElement("circle", { cx: 40, cy: 40, fill: vt[2].color, r: 16, transform: "translate(" + vt[2].translateX + " " + vt[2].translateY + ")" }), ne.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: vt[3].color, transform: "translate(" + vt[3].translateX + " " + vt[3].translateY + ") rotate(" + vt[3].rotate + " 40 40)" })));
      }, ring: function(ot) {
        var yt = ot.name, mt = ot.colors, Tt = ot.title, Pt = ot.square, Nt = ot.size, St = J(ot, ["name", "colors", "title", "square", "size"]), vt = function(wt, Oe) {
          var rt = ce(Oe), pe = wt && wt.length, nt = Array.from({ length: 5 }, function(ft, ht) {
            return Ce(rt + ht, wt, pe);
          }), st = [];
          return st[0] = nt[0], st[1] = nt[1], st[2] = nt[1], st[3] = nt[2], st[4] = nt[2], st[5] = nt[3], st[6] = nt[3], st[7] = nt[0], st[8] = nt[4], st;
        }(mt, yt), It = ie.a.useId();
        return ie.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, St), Tt && ie.a.createElement("title", null, yt), ie.a.createElement("mask", { id: It, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ie.a.createElement("rect", { width: 90, height: 90, rx: Pt ? void 0 : 180, fill: "#FFFFFF" })), ie.a.createElement("g", { mask: "url(#".concat(It, ")") }, ie.a.createElement("path", { d: "M0 0h90v45H0z", fill: vt[0] }), ie.a.createElement("path", { d: "M0 45h90v45H0z", fill: vt[1] }), ie.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: vt[2] }), ie.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: vt[3] }), ie.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: vt[4] }), ie.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: vt[5] }), ie.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: vt[6] }), ie.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: vt[7] }), ie.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: vt[8] })));
      }, beam: function(ot) {
        var yt = ot.name, mt = ot.colors, Tt = ot.title, Pt = ot.square, Nt = ot.size, St = J(ot, ["name", "colors", "title", "square", "size"]), vt = function(wt, Oe) {
          var rt, pe = ce(wt), nt = Oe && Oe.length, st = Ce(pe, Oe, nt), ft = ke(pe, 10, 1), ht = ft < 5 ? ft + 4 : ft, bt = ke(pe, 10, 2), ut = bt < 5 ? bt + 4 : bt;
          return { wrapperColor: st, faceColor: (rt = st, rt.slice(0, 1) === "#" && (rt = rt.slice(1)), (299 * parseInt(rt.substr(0, 2), 16) + 587 * parseInt(rt.substr(2, 2), 16) + 114 * parseInt(rt.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Ce(pe + 13, Oe, nt), wrapperTranslateX: ht, wrapperTranslateY: ut, wrapperRotate: ke(pe, 360), wrapperScale: 1 + ke(pe, 3) / 10, isMouthOpen: oe(pe, 2), isCircle: oe(pe, 1), eyeSpread: ke(pe, 5), mouthSpread: ke(pe, 3), faceRotate: ke(pe, 10, 3), faceTranslateX: ht > 6 ? ht / 2 : ke(pe, 8, 1), faceTranslateY: ut > 6 ? ut / 2 : ke(pe, 7, 2) };
        }(yt, mt), It = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, St), Tt && ne.createElement("title", null, yt), ne.createElement("mask", { id: It, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, ne.createElement("rect", { width: 36, height: 36, rx: Pt ? void 0 : 72, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(It, ")") }, ne.createElement("rect", { width: 36, height: 36, fill: vt.backgroundColor }), ne.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + vt.wrapperTranslateX + " " + vt.wrapperTranslateY + ") rotate(" + vt.wrapperRotate + " 18 18) scale(" + vt.wrapperScale + ")", fill: vt.wrapperColor, rx: vt.isCircle ? 36 : 6 }), ne.createElement("g", { transform: "translate(" + vt.faceTranslateX + " " + vt.faceTranslateY + ") rotate(" + vt.faceRotate + " 18 18)" }, vt.isMouthOpen ? ne.createElement("path", { d: "M15 " + (19 + vt.mouthSpread) + "c2 1 4 1 6 0", stroke: vt.faceColor, fill: "none", strokeLinecap: "round" }) : ne.createElement("path", { d: "M13," + (19 + vt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: vt.faceColor }), ne.createElement("rect", { x: 14 - vt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: vt.faceColor }), ne.createElement("rect", { x: 20 + vt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: vt.faceColor }))));
      }, sunset: function(ot) {
        var yt = ot.name, mt = ot.colors, Tt = ot.title, Pt = ot.square, Nt = ot.size, St = J(ot, ["name", "colors", "title", "square", "size"]), vt = function(Oe, rt) {
          var pe = ce(Oe), nt = rt && rt.length;
          return Array.from({ length: 4 }, function(st, ft) {
            return Ce(pe + ft, rt, nt);
          });
        }(yt, mt), It = yt.replace(/\s/g, ""), wt = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Nt, height: Nt }, St), Tt && ne.createElement("title", null, yt), ne.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: Pt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(wt, ")") }, ne.createElement("path", { fill: "url(#gradient_paint0_linear_" + It + ")", d: "M0 0h80v40H0z" }), ne.createElement("path", { fill: "url(#gradient_paint1_linear_" + It + ")", d: "M0 40h80v40H0z" })), ne.createElement("defs", null, ne.createElement("linearGradient", { id: "gradient_paint0_linear_" + It, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, ne.createElement("stop", { stopColor: vt[0] }), ne.createElement("stop", { offset: 1, stopColor: vt[1] })), ne.createElement("linearGradient", { id: "gradient_paint1_linear_" + It, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, ne.createElement("stop", { stopColor: vt[2] }), ne.createElement("stop", { offset: 1, stopColor: vt[3] }))));
      }, marble: it }, ct = { geometric: "beam", abstract: "bauhaus" }, dt = function(ot) {
        var yt = ot.variant, mt = yt === void 0 ? "marble" : yt, Tt = ot.colors, Pt = Tt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Tt, Nt = ot.name, St = Nt === void 0 ? "Clara Barton" : Nt, vt = ot.title, It = vt !== void 0 && vt, wt = ot.size, Oe = ot.square, rt = Oe !== void 0 && Oe, pe = J(ot, ["variant", "colors", "name", "title", "size", "square"]), nt = at[ct[mt] || mt] || it;
        return ie.a.createElement(nt, Object.assign({ colors: Pt, name: St, title: It, size: wt, square: rt }, pe));
      };
      V.default = dt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
var i$7 = Object.defineProperty, d$5 = (A, B, L) => B in A ? i$7(A, B, { enumerable: !0, configurable: !0, writable: !0, value: L }) : A[B] = L, r$4 = (A, B, L) => (d$5(A, typeof B != "symbol" ? B + "" : B, L), L);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$5 = (A, B) => {
  s$a.isServer ? useEffect(A, B) : useLayoutEffect(A, B);
};
function s$9(A) {
  let B = useRef(A);
  return l$5(() => {
    B.current = A;
  }, [A]), B;
}
let o$6 = function(A) {
  let B = s$9(A);
  return C__default.useCallback((...L) => B.current(...L), [B]);
};
function t$7(A) {
  typeof queueMicrotask == "function" ? queueMicrotask(A) : Promise.resolve().then(A).catch((B) => setTimeout(() => {
    throw B;
  }));
}
function o$5() {
  let A = [], B = { addEventListener(L, K, V, W) {
    return L.addEventListener(K, V, W), B.add(() => L.removeEventListener(K, V, W));
  }, requestAnimationFrame(...L) {
    let K = requestAnimationFrame(...L);
    return B.add(() => cancelAnimationFrame(K));
  }, nextFrame(...L) {
    return B.requestAnimationFrame(() => B.requestAnimationFrame(...L));
  }, setTimeout(...L) {
    let K = setTimeout(...L);
    return B.add(() => clearTimeout(K));
  }, microTask(...L) {
    let K = { current: !0 };
    return t$7(() => {
      K.current && L[0]();
    }), B.add(() => {
      K.current = !1;
    });
  }, style(L, K, V) {
    let W = L.style.getPropertyValue(K);
    return Object.assign(L.style, { [K]: V }), this.add(() => {
      Object.assign(L.style, { [K]: W });
    });
  }, group(L) {
    let K = o$5();
    return L(K), this.add(() => K.dispose());
  }, add(L) {
    return A.push(L), () => {
      let K = A.indexOf(L);
      if (K >= 0) for (let V of A.splice(K, 1)) V();
    };
  }, dispose() {
    for (let L of A.splice(0)) L();
  } };
  return B;
}
function p$3() {
  let [A] = useState(o$5);
  return useEffect(() => () => A.dispose(), [A]), A;
}
function s$8() {
  let A = typeof document > "u";
  return "useSyncExternalStore" in C$2 ? ((B) => B.useSyncExternalStore)(C$2)(() => () => {
  }, () => !1, () => !A) : !1;
}
function l$4() {
  let A = s$8(), [B, L] = C$2.useState(s$a.isHandoffComplete);
  return B && s$a.isHandoffComplete === !1 && L(!1), C$2.useEffect(() => {
    B !== !0 && L(!0);
  }, [B]), C$2.useEffect(() => s$a.handoff(), []), A ? !1 : B;
}
var o$4;
let I$5 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let A = l$4(), [B, L] = C__default.useState(A ? () => s$a.nextId() : null);
  return l$5(() => {
    B === null && L(s$a.nextId());
  }, [B]), B != null ? "" + B : void 0;
};
function u$7(A, B, ...L) {
  if (A in B) {
    let V = B[A];
    return typeof V == "function" ? V(...L) : V;
  }
  let K = new Error(`Tried to handle "${A}" but there is no handler defined. Only defined handlers are: ${Object.keys(B).map((V) => `"${V}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(K, u$7), K;
}
function o$3(A) {
  return s$a.isServer ? null : A instanceof Node ? A.ownerDocument : A != null && A.hasOwnProperty("current") && A.current instanceof Node ? A.current.ownerDocument : document;
}
let c$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((A) => `${A}:not([tabindex='-1'])`).join(",");
var M$2 = ((A) => (A[A.First = 1] = "First", A[A.Previous = 2] = "Previous", A[A.Next = 4] = "Next", A[A.Last = 8] = "Last", A[A.WrapAround = 16] = "WrapAround", A[A.NoScroll = 32] = "NoScroll", A))(M$2 || {}), N$2 = ((A) => (A[A.Error = 0] = "Error", A[A.Overflow = 1] = "Overflow", A[A.Success = 2] = "Success", A[A.Underflow = 3] = "Underflow", A))(N$2 || {}), F$3 = ((A) => (A[A.Previous = -1] = "Previous", A[A.Next = 1] = "Next", A))(F$3 || {});
function f$6(A = document.body) {
  return A == null ? [] : Array.from(A.querySelectorAll(c$5)).sort((B, L) => Math.sign((B.tabIndex || Number.MAX_SAFE_INTEGER) - (L.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((A) => (A[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A))(T$2 || {});
function h$4(A, B = 0) {
  var L;
  return A === ((L = o$3(A)) == null ? void 0 : L.body) ? !1 : u$7(B, { 0() {
    return A.matches(c$5);
  }, 1() {
    let K = A;
    for (; K !== null; ) {
      if (K.matches(c$5)) return !0;
      K = K.parentElement;
    }
    return !1;
  } });
}
function D$3(A) {
  let B = o$3(A);
  o$5().nextFrame(() => {
    B && !h$4(B.activeElement, 0) && y$3(A);
  });
}
var w$2 = ((A) => (A[A.Keyboard = 0] = "Keyboard", A[A.Mouse = 1] = "Mouse", A))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (A) => {
  A.metaKey || A.altKey || A.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (A) => {
  A.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : A.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(A) {
  A == null || A.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(A) {
  var B, L;
  return (L = (B = A == null ? void 0 : A.matches) == null ? void 0 : B.call(A, S$5)) != null ? L : !1;
}
function I$4(A, B = (L) => L) {
  return A.slice().sort((L, K) => {
    let V = B(L), W = B(K);
    if (V === null || W === null) return 0;
    let J = V.compareDocumentPosition(W);
    return J & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : J & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$2(A, B) {
  return O$1(f$6(), B, { relativeTo: A });
}
function O$1(A, B, { sorted: L = !0, relativeTo: K = null, skipElements: V = [] } = {}) {
  let W = Array.isArray(A) ? A.length > 0 ? A[0].ownerDocument : document : A.ownerDocument, J = Array.isArray(A) ? L ? I$4(A) : A : f$6(A);
  V.length > 0 && J.length > 1 && (J = J.filter((Ce) => !V.includes(Ce))), K = K ?? W.activeElement;
  let ne = (() => {
    if (B & 5) return 1;
    if (B & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ie = (() => {
    if (B & 1) return 0;
    if (B & 2) return Math.max(0, J.indexOf(K)) - 1;
    if (B & 4) return Math.max(0, J.indexOf(K)) + 1;
    if (B & 8) return J.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ce = B & 32 ? { preventScroll: !0 } : {}, re = 0, oe = J.length, ke;
  do {
    if (re >= oe || re + oe <= 0) return 0;
    let Ce = ie + re;
    if (B & 16) Ce = (Ce + oe) % oe;
    else {
      if (Ce < 0) return 3;
      if (Ce >= oe) return 1;
    }
    ke = J[Ce], ke == null || ke.focus(ce), re += ne;
  } while (ke !== W.activeElement);
  return B & 6 && H(ke) && ke.select(), 2;
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$6() || i$6();
}
function d$4(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function V(W) {
      K.current(W);
    }
    return document.addEventListener(A, V, L), () => document.removeEventListener(A, V, L);
  }, [A, L]);
}
function s$7(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function V(W) {
      K.current(W);
    }
    return window.addEventListener(A, V, L), () => window.removeEventListener(A, V, L);
  }, [A, L]);
}
function y$2(A, B, L = !0) {
  let K = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      K.current = L;
    });
  }, [L]);
  function V(J, ne) {
    if (!K.current || J.defaultPrevented) return;
    let ie = ne(J);
    if (ie === null || !ie.getRootNode().contains(ie) || !ie.isConnected) return;
    let ce = function re(oe) {
      return typeof oe == "function" ? re(oe()) : Array.isArray(oe) || oe instanceof Set ? oe : [oe];
    }(A);
    for (let re of ce) {
      if (re === null) continue;
      let oe = re instanceof HTMLElement ? re : re.current;
      if (oe != null && oe.contains(ie) || J.composed && J.composedPath().includes(oe)) return;
    }
    return !h$4(ie, T$2.Loose) && ie.tabIndex !== -1 && J.preventDefault(), B(J, ie);
  }
  let W = useRef(null);
  d$4("pointerdown", (J) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = J.composedPath) == null ? void 0 : ne.call(J)) == null ? void 0 : ie[0]) || J.target);
  }, !0), d$4("mousedown", (J) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = J.composedPath) == null ? void 0 : ne.call(J)) == null ? void 0 : ie[0]) || J.target);
  }, !0), d$4("click", (J) => {
    n$3() || W.current && (V(J, () => W.current), W.current = null);
  }, !0), d$4("touchend", (J) => V(J, () => J.target instanceof HTMLElement ? J.target : null), !0), s$7("blur", (J) => V(J, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...A) {
  return useMemo(() => o$3(...A), [...A]);
}
function i$5(A) {
  var B;
  if (A.type) return A.type;
  let L = (B = A.as) != null ? B : "button";
  if (typeof L == "string" && L.toLowerCase() === "button") return "button";
}
function T$1(A, B) {
  let [L, K] = useState(() => i$5(A));
  return l$5(() => {
    K(i$5(A));
  }, [A.type, A.as]), l$5(() => {
    L || B.current && B.current instanceof HTMLButtonElement && !B.current.hasAttribute("type") && K("button");
  }, [L, B]), L;
}
let u$6 = Symbol();
function T(A, B = !0) {
  return Object.assign(A, { [u$6]: B });
}
function y$1(...A) {
  let B = useRef(A);
  useEffect(() => {
    B.current = A;
  }, [A]);
  let L = o$6((K) => {
    for (let V of B.current) V != null && (typeof V == "function" ? V(K) : V.current = K);
  });
  return A.every((K) => K == null || (K == null ? void 0 : K[u$6])) ? void 0 : L;
}
function t$5(A) {
  return [A.screenX, A.screenY];
}
function u$5() {
  let A = useRef([-1, -1]);
  return { wasMoved(B) {
    let L = t$5(B);
    return A.current[0] === L[0] && A.current[1] === L[1] ? !1 : (A.current = L, !0);
  }, update(B) {
    A.current = t$5(B);
  } };
}
function F$2({ container: A, accept: B, walk: L, enabled: K = !0 }) {
  let V = useRef(B), W = useRef(L);
  useEffect(() => {
    V.current = B, W.current = L;
  }, [B, L]), l$5(() => {
    if (!A || !K) return;
    let J = o$3(A);
    if (!J) return;
    let ne = V.current, ie = W.current, ce = Object.assign((oe) => ne(oe), { acceptNode: ne }), re = J.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, ce, !1);
    for (; re.nextNode(); ) ie(re.currentNode);
  }, [A, K, V, W]);
}
function m$2(A, B) {
  let L = useRef([]), K = o$6(A);
  useEffect(() => {
    let V = [...L.current];
    for (let [W, J] of B.entries()) if (L.current[W] !== J) {
      let ne = K(B, V);
      return L.current = B, ne;
    }
  }, [K, ...B]);
}
function t$4(...A) {
  return Array.from(new Set(A.flatMap((B) => typeof B == "string" ? B.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((A) => (A[A.None = 0] = "None", A[A.RenderStrategy = 1] = "RenderStrategy", A[A.Static = 2] = "Static", A))(O || {}), v$1 = ((A) => (A[A.Unmount = 0] = "Unmount", A[A.Hidden = 1] = "Hidden", A))(v$1 || {});
function C$1({ ourProps: A, theirProps: B, slot: L, defaultTag: K, features: V, visible: W = !0, name: J, mergeRefs: ne }) {
  ne = ne ?? k$1;
  let ie = R(B, A);
  if (W) return m$1(ie, L, K, J, ne);
  let ce = V ?? 0;
  if (ce & 2) {
    let { static: re = !1, ...oe } = ie;
    if (re) return m$1(oe, L, K, J, ne);
  }
  if (ce & 1) {
    let { unmount: re = !0, ...oe } = ie;
    return u$7(re ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...oe, hidden: !0, style: { display: "none" } }, L, K, J, ne);
    } });
  }
  return m$1(ie, L, K, J, ne);
}
function m$1(A, B = {}, L, K, V) {
  let { as: W = L, children: J, refName: ne = "ref", ...ie } = F$1(A, ["unmount", "static"]), ce = A.ref !== void 0 ? { [ne]: A.ref } : {}, re = typeof J == "function" ? J(B) : J;
  "className" in ie && ie.className && typeof ie.className == "function" && (ie.className = ie.className(B));
  let oe = {};
  if (B) {
    let ke = !1, Ce = [];
    for (let [it, at] of Object.entries(B)) typeof at == "boolean" && (ke = !0), at === !0 && Ce.push(it);
    ke && (oe["data-headlessui-state"] = Ce.join(" "));
  }
  if (W === Fragment && Object.keys(x$2(ie)).length > 0) {
    if (!isValidElement(re) || Array.isArray(re) && re.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${K} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(ie).map((at) => `  - ${at}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((at) => `  - ${at}`).join(`
`)].join(`
`));
    let ke = re.props, Ce = typeof (ke == null ? void 0 : ke.className) == "function" ? (...at) => t$4(ke == null ? void 0 : ke.className(...at), ie.className) : t$4(ke == null ? void 0 : ke.className, ie.className), it = Ce ? { className: Ce } : {};
    return cloneElement(re, Object.assign({}, R(re.props, x$2(F$1(ie, ["ref"]))), oe, ce, { ref: V(re.ref, ce.ref) }, it));
  }
  return createElement(W, Object.assign({}, F$1(ie, ["ref"]), W !== Fragment && ce, W !== Fragment && oe), re);
}
function k$1(...A) {
  return A.every((B) => B == null) ? void 0 : (B) => {
    for (let L of A) L != null && (typeof L == "function" ? L(B) : L.current = B);
  };
}
function R(...A) {
  if (A.length === 0) return {};
  if (A.length === 1) return A[0];
  let B = {}, L = {};
  for (let K of A) for (let V in K) V.startsWith("on") && typeof K[V] == "function" ? (L[V] != null || (L[V] = []), L[V].push(K[V])) : B[V] = K[V];
  if (B.disabled || B["aria-disabled"]) return Object.assign(B, Object.fromEntries(Object.keys(L).map((K) => [K, void 0])));
  for (let K in L) Object.assign(B, { [K](V, ...W) {
    let J = L[K];
    for (let ne of J) {
      if ((V instanceof Event || (V == null ? void 0 : V.nativeEvent) instanceof Event) && V.defaultPrevented) return;
      ne(V, ...W);
    }
  } });
  return B;
}
function U$3(A) {
  var B;
  return Object.assign(forwardRef(A), { displayName: (B = A.displayName) != null ? B : A.name });
}
function x$2(A) {
  let B = Object.assign({}, A);
  for (let L in B) B[L] === void 0 && delete B[L];
  return B;
}
function F$1(A, B = []) {
  let L = Object.assign({}, A);
  for (let K of B) K in L && delete L[K];
  return L;
}
let p$2 = "div";
var s$6 = ((A) => (A[A.None = 1] = "None", A[A.Focusable = 2] = "Focusable", A[A.Hidden = 4] = "Hidden", A))(s$6 || {});
function l$3(A, B) {
  var L;
  let { features: K = 1, ...V } = A, W = { ref: B, "aria-hidden": (K & 2) === 2 ? !0 : (L = V["aria-hidden"]) != null ? L : void 0, hidden: (K & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(K & 4) === 4 && (K & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: W, theirProps: V, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let u$4 = U$3(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((A) => (A[A.Open = 1] = "Open", A[A.Closed = 2] = "Closed", A[A.Closing = 4] = "Closing", A[A.Opening = 8] = "Opening", A))(d$3 || {});
function u$3() {
  return useContext(n$1);
}
function s$5({ value: A, children: B }) {
  return C__default.createElement(n$1.Provider, { value: A }, B);
}
function t$3(A) {
  function B() {
    document.readyState !== "loading" && (A(), document.removeEventListener("DOMContentLoaded", B));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", B), B());
}
let t$2 = [];
t$3(() => {
  function A(B) {
    B.target instanceof HTMLElement && B.target !== document.body && t$2[0] !== B.target && (t$2.unshift(B.target), t$2 = t$2.filter((L) => L != null && L.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", A, { capture: !0 }), window.addEventListener("mousedown", A, { capture: !0 }), window.addEventListener("focus", A, { capture: !0 }), document.body.addEventListener("click", A, { capture: !0 }), document.body.addEventListener("mousedown", A, { capture: !0 }), document.body.addEventListener("focus", A, { capture: !0 });
});
function r$3(A) {
  let B = A.parentElement, L = null;
  for (; B && !(B instanceof HTMLFieldSetElement); ) B instanceof HTMLLegendElement && (L = B), B = B.parentElement;
  let K = (B == null ? void 0 : B.getAttribute("disabled")) === "";
  return K && i$4(L) ? !1 : K;
}
function i$4(A) {
  if (!A) return !1;
  let B = A.previousElementSibling;
  for (; B !== null; ) {
    if (B instanceof HTMLLegendElement) return !1;
    B = B.previousElementSibling;
  }
  return !0;
}
function u$2(A) {
  throw new Error("Unexpected object: " + A);
}
var c$4 = ((A) => (A[A.First = 0] = "First", A[A.Previous = 1] = "Previous", A[A.Next = 2] = "Next", A[A.Last = 3] = "Last", A[A.Specific = 4] = "Specific", A[A.Nothing = 5] = "Nothing", A))(c$4 || {});
function f$5(A, B) {
  let L = B.resolveItems();
  if (L.length <= 0) return null;
  let K = B.resolveActiveIndex(), V = K ?? -1;
  switch (A.focus) {
    case 0: {
      for (let W = 0; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 1: {
      for (let W = V - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 2: {
      for (let W = V + 1; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 3: {
      for (let W = L.length - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 4: {
      for (let W = 0; W < L.length; ++W) if (B.resolveId(L[W], W, L) === A.id) return W;
      return K;
    }
    case 5:
      return null;
    default:
      u$2(A);
  }
}
var o$2 = ((A) => (A.Space = " ", A.Enter = "Enter", A.Escape = "Escape", A.Backspace = "Backspace", A.Delete = "Delete", A.ArrowLeft = "ArrowLeft", A.ArrowUp = "ArrowUp", A.ArrowRight = "ArrowRight", A.ArrowDown = "ArrowDown", A.Home = "Home", A.End = "End", A.PageUp = "PageUp", A.PageDown = "PageDown", A.Tab = "Tab", A))(o$2 || {});
function E(A, B, L, K) {
  let V = s$9(L);
  useEffect(() => {
    A = A ?? window;
    function W(J) {
      V.current(J);
    }
    return A.addEventListener(B, W, K), () => A.removeEventListener(B, W, K);
  }, [A, B, K]);
}
function f$4() {
  let A = useRef(!1);
  return l$5(() => (A.current = !0, () => {
    A.current = !1;
  }), []), A;
}
function c$3(A) {
  let B = o$6(A), L = useRef(!1);
  useEffect(() => (L.current = !1, () => {
    L.current = !0, t$7(() => {
      L.current && B();
    });
  }), [B]);
}
var s$4 = ((A) => (A[A.Forwards = 0] = "Forwards", A[A.Backwards = 1] = "Backwards", A))(s$4 || {});
function n() {
  let A = useRef(0);
  return s$7("keydown", (B) => {
    B.key === "Tab" && (A.current = B.shiftKey ? 1 : 0);
  }, !0), A;
}
function P(A) {
  if (!A) return /* @__PURE__ */ new Set();
  if (typeof A == "function") return new Set(A());
  let B = /* @__PURE__ */ new Set();
  for (let L of A.current) L.current instanceof HTMLElement && B.add(L.current);
  return B;
}
let X = "div";
var _$1 = ((A) => (A[A.None = 1] = "None", A[A.InitialFocus = 2] = "InitialFocus", A[A.TabLock = 4] = "TabLock", A[A.FocusLock = 8] = "FocusLock", A[A.RestoreFocus = 16] = "RestoreFocus", A[A.All = 30] = "All", A))(_$1 || {});
function z(A, B) {
  let L = useRef(null), K = y$1(L, B), { initialFocus: V, containers: W, features: J = 30, ...ne } = A;
  l$4() || (J = 1);
  let ie = n$2(L);
  Y({ ownerDocument: ie }, !!(J & 16));
  let ce = Z({ ownerDocument: ie, container: L, initialFocus: V }, !!(J & 2));
  $({ ownerDocument: ie, container: L, containers: W, previousActiveElement: ce }, !!(J & 8));
  let re = n(), oe = o$6((at) => {
    let ct = L.current;
    ct && ((dt) => dt())(() => {
      u$7(re.current, { [s$4.Forwards]: () => {
        O$1(ct, M$2.First, { skipElements: [at.relatedTarget] });
      }, [s$4.Backwards]: () => {
        O$1(ct, M$2.Last, { skipElements: [at.relatedTarget] });
      } });
    });
  }), ke = p$3(), Ce = useRef(!1), it = { ref: K, onKeyDown(at) {
    at.key == "Tab" && (Ce.current = !0, ke.requestAnimationFrame(() => {
      Ce.current = !1;
    }));
  }, onBlur(at) {
    let ct = P(W);
    L.current instanceof HTMLElement && ct.add(L.current);
    let dt = at.relatedTarget;
    dt instanceof HTMLElement && dt.dataset.headlessuiFocusGuard !== "true" && (S$4(ct, dt) || (Ce.current ? O$1(L.current, u$7(re.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: at.target }) : at.target instanceof HTMLElement && y$3(at.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(J & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: oe, features: s$6.Focusable }), C$1({ ourProps: it, theirProps: ne, defaultTag: X, name: "FocusTrap" }), !!(J & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: oe, features: s$6.Focusable }));
}
let D$2 = U$3(z), de$1 = Object.assign(D$2, { features: _$1 });
function Q(A = !0) {
  let B = useRef(t$2.slice());
  return m$2(([L], [K]) => {
    K === !0 && L === !1 && t$7(() => {
      B.current.splice(0);
    }), K === !1 && L === !0 && (B.current = t$2.slice());
  }, [A, t$2, B]), o$6(() => {
    var L;
    return (L = B.current.find((K) => K != null && K.isConnected)) != null ? L : null;
  });
}
function Y({ ownerDocument: A }, B) {
  let L = Q(B);
  m$2(() => {
    B || (A == null ? void 0 : A.activeElement) === (A == null ? void 0 : A.body) && y$3(L());
  }, [B]), c$3(() => {
    B && y$3(L());
  });
}
function Z({ ownerDocument: A, container: B, initialFocus: L }, K) {
  let V = useRef(null), W = f$4();
  return m$2(() => {
    if (!K) return;
    let J = B.current;
    J && t$7(() => {
      if (!W.current) return;
      let ne = A == null ? void 0 : A.activeElement;
      if (L != null && L.current) {
        if ((L == null ? void 0 : L.current) === ne) {
          V.current = ne;
          return;
        }
      } else if (J.contains(ne)) {
        V.current = ne;
        return;
      }
      L != null && L.current ? y$3(L.current) : O$1(J, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), V.current = A == null ? void 0 : A.activeElement;
    });
  }, [K]), V;
}
function $({ ownerDocument: A, container: B, containers: L, previousActiveElement: K }, V) {
  let W = f$4();
  E(A == null ? void 0 : A.defaultView, "focus", (J) => {
    if (!V || !W.current) return;
    let ne = P(L);
    B.current instanceof HTMLElement && ne.add(B.current);
    let ie = K.current;
    if (!ie) return;
    let ce = J.target;
    ce && ce instanceof HTMLElement ? S$4(ne, ce) ? (K.current = ce, y$3(ce)) : (J.preventDefault(), J.stopPropagation(), y$3(ie)) : y$3(K.current);
  }, !0);
}
function S$4(A, B) {
  for (let L of A) if (L.contains(B)) return !0;
  return !1;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function l$2(A) {
  return C__default.createElement(e.Provider, { value: A.force }, A.children);
}
function F(A) {
  let B = a$5(), L = useContext(_), K = n$2(A), [V, W] = useState(() => {
    if (!B && L !== null || s$a.isServer) return null;
    let J = K == null ? void 0 : K.getElementById("headlessui-portal-root");
    if (J) return J;
    if (K === null) return null;
    let ne = K.createElement("div");
    return ne.setAttribute("id", "headlessui-portal-root"), K.body.appendChild(ne);
  });
  return useEffect(() => {
    V !== null && (K != null && K.body.contains(V) || K == null || K.body.appendChild(V));
  }, [V, K]), useEffect(() => {
    B || L !== null && W(L.current);
  }, [L, W, B]), V;
}
let U$2 = Fragment;
function N$1(A, B) {
  let L = A, K = useRef(null), V = y$1(T((re) => {
    K.current = re;
  }), B), W = n$2(K), J = F(K), [ne] = useState(() => {
    var re;
    return s$a.isServer ? null : (re = W == null ? void 0 : W.createElement("div")) != null ? re : null;
  }), ie = useContext(f$3), ce = l$4();
  return l$5(() => {
    !J || !ne || J.contains(ne) || (ne.setAttribute("data-headlessui-portal", ""), J.appendChild(ne));
  }, [J, ne]), l$5(() => {
    if (ne && ie) return ie.register(ne);
  }, [ie, ne]), c$3(() => {
    var re;
    !J || !ne || (ne instanceof Node && J.contains(ne) && J.removeChild(ne), J.childNodes.length <= 0 && ((re = J.parentElement) == null || re.removeChild(J)));
  }), ce ? !J || !ne ? null : createPortal(C$1({ ourProps: { ref: V }, theirProps: L, defaultTag: U$2, name: "Portal" }), ne) : null;
}
let S$3 = Fragment, _ = createContext(null);
function j(A, B) {
  let { target: L, ...K } = A, V = { ref: y$1(B) };
  return C__default.createElement(_.Provider, { value: L }, C$1({ ourProps: V, theirProps: K, defaultTag: S$3, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee() {
  let A = useContext(f$3), B = useRef([]), L = o$6((W) => (B.current.push(W), A && A.register(W), () => K(W))), K = o$6((W) => {
    let J = B.current.indexOf(W);
    J !== -1 && B.current.splice(J, 1), A && A.unregister(W);
  }), V = useMemo(() => ({ register: L, unregister: K, portals: B }), [L, K, B]);
  return [B, useMemo(() => function({ children: W }) {
    return C__default.createElement(f$3.Provider, { value: V }, W);
  }, [V])];
}
let D$1 = U$3(N$1), I$3 = U$3(j), te = Object.assign(D$1, { Group: I$3 });
function i$3(A, B) {
  return A === B && (A !== 0 || 1 / A === 1 / B) || A !== A && B !== B;
}
const d$2 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$3, useLayoutEffect: f$2, useDebugValue: p$1 } = C$2;
function y(A, B, L) {
  const K = B(), [{ inst: V }, W] = u$1({ inst: { value: K, getSnapshot: B } });
  return f$2(() => {
    V.value = K, V.getSnapshot = B, r$2(V) && W({ inst: V });
  }, [A, K, B]), h$3(() => (r$2(V) && W({ inst: V }), A(() => {
    r$2(V) && W({ inst: V });
  })), [A]), p$1(K), K;
}
function r$2(A) {
  const B = A.getSnapshot, L = A.value;
  try {
    const K = B();
    return !d$2(L, K);
  } catch {
    return !0;
  }
}
function t$1(A, B, L) {
  return B();
}
const r$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$3 = !r$1, c$2 = s$3 ? t$1 : y, a$4 = "useSyncExternalStore" in C$2 ? ((A) => A.useSyncExternalStore)(C$2) : c$2;
function S$2(A) {
  return a$4(A.subscribe, A.getSnapshot, A.getSnapshot);
}
function a$3(A, B) {
  let L = A(), K = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return L;
  }, subscribe(V) {
    return K.add(V), () => K.delete(V);
  }, dispatch(V, ...W) {
    let J = B[V].call(L, ...W);
    J && (L = J, K.forEach((ne) => ne()));
  } };
}
function c$1() {
  let A;
  return { before({ doc: B }) {
    var L;
    let K = B.documentElement;
    A = ((L = B.defaultView) != null ? L : window).innerWidth - K.clientWidth;
  }, after({ doc: B, d: L }) {
    let K = B.documentElement, V = K.clientWidth - K.offsetWidth, W = A - V;
    L.style(K, "paddingRight", `${W}px`);
  } };
}
function d$1() {
  return t$6() ? { before({ doc: A, d: B, meta: L }) {
    function K(V) {
      return L.containers.flatMap((W) => W()).some((W) => W.contains(V));
    }
    B.microTask(() => {
      var V;
      if (window.getComputedStyle(A.documentElement).scrollBehavior !== "auto") {
        let ne = o$5();
        ne.style(A.documentElement, "scrollBehavior", "auto"), B.add(() => B.microTask(() => ne.dispose()));
      }
      let W = (V = window.scrollY) != null ? V : window.pageYOffset, J = null;
      B.addEventListener(A, "click", (ne) => {
        if (ne.target instanceof HTMLElement) try {
          let ie = ne.target.closest("a");
          if (!ie) return;
          let { hash: ce } = new URL(ie.href), re = A.querySelector(ce);
          re && !K(re) && (J = re);
        } catch {
        }
      }, !0), B.addEventListener(A, "touchstart", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && K(ie.parentElement); ) ie = ie.parentElement;
          B.style(ie, "overscrollBehavior", "contain");
        } else B.style(ne.target, "touchAction", "none");
      }), B.addEventListener(A, "touchmove", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && ie.dataset.headlessuiPortal !== "" && !(ie.scrollHeight > ie.clientHeight || ie.scrollWidth > ie.clientWidth); ) ie = ie.parentElement;
          ie.dataset.headlessuiPortal === "" && ne.preventDefault();
        } else ne.preventDefault();
      }, { passive: !1 }), B.add(() => {
        var ne;
        let ie = (ne = window.scrollY) != null ? ne : window.pageYOffset;
        W !== ie && window.scrollTo(0, W), J && J.isConnected && (J.scrollIntoView({ block: "nearest" }), J = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: A, d: B }) {
    B.style(A.documentElement, "overflow", "hidden");
  } };
}
function m(A) {
  let B = {};
  for (let L of A) Object.assign(B, L(B));
  return B;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(A, B) {
  var L;
  let K = (L = this.get(A)) != null ? L : { doc: A, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return K.count++, K.meta.add(B), this.set(A, K), this;
}, POP(A, B) {
  let L = this.get(A);
  return L && (L.count--, L.meta.delete(B)), this;
}, SCROLL_PREVENT({ doc: A, d: B, meta: L }) {
  let K = { doc: A, d: B, meta: m(L) }, V = [d$1(), c$1(), l$1()];
  V.forEach(({ before: W }) => W == null ? void 0 : W(K)), V.forEach(({ after: W }) => W == null ? void 0 : W(K));
}, SCROLL_ALLOW({ d: A }) {
  A.dispose();
}, TEARDOWN({ doc: A }) {
  this.delete(A);
} });
a$2.subscribe(() => {
  let A = a$2.getSnapshot(), B = /* @__PURE__ */ new Map();
  for (let [L] of A) B.set(L, L.documentElement.style.overflow);
  for (let L of A.values()) {
    let K = B.get(L.doc) === "hidden", V = L.count !== 0;
    (V && !K || !V && K) && a$2.dispatch(L.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", L), L.count === 0 && a$2.dispatch("TEARDOWN", L);
  }
});
function p(A, B, L) {
  let K = S$2(a$2), V = A ? K.get(A) : void 0, W = V ? V.count > 0 : !1;
  return l$5(() => {
    if (!(!A || !B)) return a$2.dispatch("PUSH", A, L), () => a$2.dispatch("POP", A, L);
  }, [B, A]), W;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(A, B = !0) {
  l$5(() => {
    var L;
    if (!B) return;
    let K = typeof A == "function" ? A() : A.current;
    if (!K) return;
    function V() {
      var J;
      if (!K) return;
      let ne = (J = t.get(K)) != null ? J : 1;
      if (ne === 1 ? t.delete(K) : t.set(K, ne - 1), ne !== 1) return;
      let ie = u.get(K);
      ie && (ie["aria-hidden"] === null ? K.removeAttribute("aria-hidden") : K.setAttribute("aria-hidden", ie["aria-hidden"]), K.inert = ie.inert, u.delete(K));
    }
    let W = (L = t.get(K)) != null ? L : 0;
    return t.set(K, W + 1), W !== 0 || (u.set(K, { "aria-hidden": K.getAttribute("aria-hidden"), inert: K.inert }), K.setAttribute("aria-hidden", "true"), K.inert = !0), V;
  }, [A, B]);
}
function N({ defaultContainers: A = [], portals: B, mainTreeNodeRef: L } = {}) {
  var K;
  let V = useRef((K = L == null ? void 0 : L.current) != null ? K : null), W = n$2(V), J = o$6(() => {
    var ne, ie, ce;
    let re = [];
    for (let oe of A) oe !== null && (oe instanceof HTMLElement ? re.push(oe) : "current" in oe && oe.current instanceof HTMLElement && re.push(oe.current));
    if (B != null && B.current) for (let oe of B.current) re.push(oe);
    for (let oe of (ne = W == null ? void 0 : W.querySelectorAll("html > *, body > *")) != null ? ne : []) oe !== document.body && oe !== document.head && oe instanceof HTMLElement && oe.id !== "headlessui-portal-root" && (oe.contains(V.current) || oe.contains((ce = (ie = V.current) == null ? void 0 : ie.getRootNode()) == null ? void 0 : ce.host) || re.some((ke) => oe.contains(ke)) || re.push(oe));
    return re;
  });
  return { resolveContainers: J, contains: o$6((ne) => J().some((ie) => ie.contains(ne))), mainTreeNodeRef: V, MainTreeNode: useMemo(() => function() {
    return L != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: V });
  }, [V, L]) };
}
let a$1 = createContext(() => {
});
a$1.displayName = "StackContext";
var s$2 = ((A) => (A[A.Add = 0] = "Add", A[A.Remove = 1] = "Remove", A))(s$2 || {});
function x$1() {
  return useContext(a$1);
}
function b$2({ children: A, onUpdate: B, type: L, element: K, enabled: V }) {
  let W = x$1(), J = o$6((...ne) => {
    B == null || B(...ne), W(...ne);
  });
  return l$5(() => {
    let ne = V === void 0 || V === !0;
    return ne && J(0, L, K), () => {
      ne && J(1, L, K);
    };
  }, [J, L, K, V]), C__default.createElement(a$1.Provider, { value: J }, A);
}
let d = createContext(null);
function f$1() {
  let A = useContext(d);
  if (A === null) {
    let B = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(B, f$1), B;
  }
  return A;
}
function w$1() {
  let [A, B] = useState([]);
  return [A.length > 0 ? A.join(" ") : void 0, useMemo(() => function(L) {
    let K = o$6((W) => (B((J) => [...J, W]), () => B((J) => {
      let ne = J.slice(), ie = ne.indexOf(W);
      return ie !== -1 && ne.splice(ie, 1), ne;
    }))), V = useMemo(() => ({ register: K, slot: L.slot, name: L.name, props: L.props }), [K, L.slot, L.name, L.props]);
    return C__default.createElement(d.Provider, { value: V }, L.children);
  }, [B])];
}
let I$2 = "p";
function S$1(A, B) {
  let L = I$5(), { id: K = `headlessui-description-${L}`, ...V } = A, W = f$1(), J = y$1(B);
  l$5(() => W.register(K), [K, W.register]);
  let ne = { ref: J, ...W.props, id: K };
  return C$1({ ourProps: ne, theirProps: V, slot: W.slot || {}, defaultTag: I$2, name: W.name || "Description" });
}
let h$2 = U$3(S$1), G = Object.assign(h$2, {});
var Me$1 = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(Me$1 || {}), we = ((A) => (A[A.SetTitleId = 0] = "SetTitleId", A))(we || {});
let He$1 = { 0(A, B) {
  return A.titleId === B.id ? A : { ...A, titleId: B.id };
} }, I$1 = createContext(null);
I$1.displayName = "DialogContext";
function b$1(A) {
  let B = useContext(I$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, b$1), L;
  }
  return B;
}
function Be(A, B, L = () => [document.body]) {
  p(A, B, (K) => {
    var V;
    return { containers: [...(V = K.containers) != null ? V : [], L] };
  });
}
function Ge(A, B) {
  return u$7(B.type, He$1, A, B);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-${L}`, open: V, onClose: W, initialFocus: J, role: ne = "dialog", __demoMode: ie = !1, ...ce } = A, [re, oe] = useState(0), ke = useRef(!1);
  ne = function() {
    return ne === "dialog" || ne === "alertdialog" ? ne : (ke.current || (ke.current = !0, console.warn(`Invalid role [${ne}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Ce = u$3();
  V === void 0 && Ce !== null && (V = (Ce & d$3.Open) === d$3.Open);
  let it = useRef(null), at = y$1(it, B), ct = n$2(it), dt = A.hasOwnProperty("open") || Ce !== null, ot = A.hasOwnProperty("onClose");
  if (!dt && !ot) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!dt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!ot) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof V != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${V}`);
  if (typeof W != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${W}`);
  let yt = V ? 0 : 1, [mt, Tt] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), Pt = o$6(() => W(!1)), Nt = o$6((Ct) => Tt({ type: 0, id: Ct })), St = l$4() ? ie ? !1 : yt === 0 : !1, vt = re > 1, It = useContext(I$1) !== null, [wt, Oe] = ee(), rt = { get current() {
    var Ct;
    return (Ct = mt.panelRef.current) != null ? Ct : it.current;
  } }, { resolveContainers: pe, mainTreeNodeRef: nt, MainTreeNode: st } = N({ portals: wt, defaultContainers: [rt] }), ft = vt ? "parent" : "leaf", ht = Ce !== null ? (Ce & d$3.Closing) === d$3.Closing : !1, bt = It || ht ? !1 : St, ut = useCallback(() => {
    var Ct, kt;
    return (kt = Array.from((Ct = ct == null ? void 0 : ct.querySelectorAll("body > *")) != null ? Ct : []).find((Vt) => Vt.id === "headlessui-portal-root" ? !1 : Vt.contains(nt.current) && Vt instanceof HTMLElement)) != null ? kt : null;
  }, [nt]);
  b$3(ut, bt);
  let gt = vt ? !0 : St, lt = useCallback(() => {
    var Ct, kt;
    return (kt = Array.from((Ct = ct == null ? void 0 : ct.querySelectorAll("[data-headlessui-portal]")) != null ? Ct : []).find((Vt) => Vt.contains(nt.current) && Vt instanceof HTMLElement)) != null ? kt : null;
  }, [nt]);
  b$3(lt, gt), y$2(pe, (Ct) => {
    Ct.preventDefault(), Pt();
  }, !(!St || vt));
  let jt = !(vt || yt !== 0);
  E(ct == null ? void 0 : ct.defaultView, "keydown", (Ct) => {
    jt && (Ct.defaultPrevented || Ct.key === o$2.Escape && (Ct.preventDefault(), Ct.stopPropagation(), Pt()));
  }), Be(ct, !(ht || yt !== 0 || It), pe), useEffect(() => {
    if (yt !== 0 || !it.current) return;
    let Ct = new ResizeObserver((kt) => {
      for (let Vt of kt) {
        let nr = Vt.target.getBoundingClientRect();
        nr.x === 0 && nr.y === 0 && nr.width === 0 && nr.height === 0 && Pt();
      }
    });
    return Ct.observe(it.current), () => Ct.disconnect();
  }, [yt, it, Pt]);
  let [Lt, Rt] = w$1(), Mt = useMemo(() => [{ dialogState: yt, close: Pt, setTitleId: Nt }, mt], [yt, mt, Pt, Nt]), Kt = useMemo(() => ({ open: yt === 0 }), [yt]), zt = { ref: at, id: K, role: ne, "aria-modal": yt === 0 ? !0 : void 0, "aria-labelledby": mt.titleId, "aria-describedby": Lt };
  return C__default.createElement(b$2, { type: "Dialog", enabled: yt === 0, element: it, onUpdate: o$6((Ct, kt) => {
    kt === "Dialog" && u$7(Ct, { [s$2.Add]: () => oe((Vt) => Vt + 1), [s$2.Remove]: () => oe((Vt) => Vt - 1) });
  }) }, C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$1.Provider, { value: Mt }, C__default.createElement(te.Group, { target: it }, C__default.createElement(l$2, { force: !1 }, C__default.createElement(Rt, { slot: Kt, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: J, containers: pe, features: St ? u$7(ft, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(Oe, null, C$1({ ourProps: zt, theirProps: ce, slot: Kt, defaultTag: Ne$1, features: Ue, visible: yt === 0, name: "Dialog" }))))))))), C__default.createElement(st, null));
}
let $e = "div";
function Ye(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-overlay-${L}`, ...V } = A, [{ dialogState: W, close: J }] = b$1("Dialog.Overlay"), ne = y$1(B), ie = o$6((re) => {
    if (re.target === re.currentTarget) {
      if (r$3(re.currentTarget)) return re.preventDefault();
      re.preventDefault(), re.stopPropagation(), J();
    }
  }), ce = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0, onClick: ie }, theirProps: V, slot: ce, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-backdrop-${L}`, ...V } = A, [{ dialogState: W }, J] = b$1("Dialog.Backdrop"), ne = y$1(B);
  useEffect(() => {
    if (J.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [J.panelRef]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0 }, theirProps: V, slot: ie, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-panel-${L}`, ...V } = A, [{ dialogState: W }, J] = b$1("Dialog.Panel"), ne = y$1(B, J.panelRef), ie = useMemo(() => ({ open: W === 0 }), [W]), ce = o$6((re) => {
    re.stopPropagation();
  });
  return C$1({ ourProps: { ref: ne, id: K, onClick: ce }, theirProps: V, slot: ie, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-title-${L}`, ...V } = A, [{ dialogState: W, setTitleId: J }] = b$1("Dialog.Title"), ne = y$1(B);
  useEffect(() => (J(K), () => J(null)), [K, J]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K }, theirProps: V, slot: ie, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(A) {
  var B, L;
  let K = (B = A.innerText) != null ? B : "", V = A.cloneNode(!0);
  if (!(V instanceof HTMLElement)) return K;
  let W = !1;
  for (let ne of V.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ne.remove(), W = !0;
  let J = W ? (L = V.innerText) != null ? L : "" : K;
  return a.test(J) && (J = J.replace(a, "")), J;
}
function g$1(A) {
  let B = A.getAttribute("aria-label");
  if (typeof B == "string") return B.trim();
  let L = A.getAttribute("aria-labelledby");
  if (L) {
    let K = L.split(" ").map((V) => {
      let W = document.getElementById(V);
      if (W) {
        let J = W.getAttribute("aria-label");
        return typeof J == "string" ? J.trim() : o$1(W).trim();
      }
      return null;
    }).filter(Boolean);
    if (K.length > 0) return K.join(", ");
  }
  return o$1(A).trim();
}
function s$1(A) {
  let B = useRef(""), L = useRef("");
  return o$6(() => {
    let K = A.current;
    if (!K) return "";
    let V = K.innerText;
    if (B.current === V) return L.current;
    let W = g$1(K).trim().toLowerCase();
    return B.current = V, L.current = W, W;
  });
}
var me = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(me || {}), de = ((A) => (A[A.Pointer = 0] = "Pointer", A[A.Other = 1] = "Other", A))(de || {}), fe = ((A) => (A[A.OpenMenu = 0] = "OpenMenu", A[A.CloseMenu = 1] = "CloseMenu", A[A.GoToItem = 2] = "GoToItem", A[A.Search = 3] = "Search", A[A.ClearSearch = 4] = "ClearSearch", A[A.RegisterItem = 5] = "RegisterItem", A[A.UnregisterItem = 6] = "UnregisterItem", A))(fe || {});
function w(A, B = (L) => L) {
  let L = A.activeItemIndex !== null ? A.items[A.activeItemIndex] : null, K = I$4(B(A.items.slice()), (W) => W.dataRef.current.domRef.current), V = L ? K.indexOf(L) : null;
  return V === -1 && (V = null), { items: K, activeItemIndex: V };
}
let Te = { 1(A) {
  return A.menuState === 1 ? A : { ...A, activeItemIndex: null, menuState: 1 };
}, 0(A) {
  return A.menuState === 0 ? A : { ...A, __demoMode: !1, menuState: 0 };
}, 2: (A, B) => {
  var L;
  let K = w(A), V = f$5(B, { resolveItems: () => K.items, resolveActiveIndex: () => K.activeItemIndex, resolveId: (W) => W.id, resolveDisabled: (W) => W.dataRef.current.disabled });
  return { ...A, ...K, searchQuery: "", activeItemIndex: V, activationTrigger: (L = B.trigger) != null ? L : 1 };
}, 3: (A, B) => {
  let L = A.searchQuery !== "" ? 0 : 1, K = A.searchQuery + B.value.toLowerCase(), V = (A.activeItemIndex !== null ? A.items.slice(A.activeItemIndex + L).concat(A.items.slice(0, A.activeItemIndex + L)) : A.items).find((J) => {
    var ne;
    return ((ne = J.dataRef.current.textValue) == null ? void 0 : ne.startsWith(K)) && !J.dataRef.current.disabled;
  }), W = V ? A.items.indexOf(V) : -1;
  return W === -1 || W === A.activeItemIndex ? { ...A, searchQuery: K } : { ...A, searchQuery: K, activeItemIndex: W, activationTrigger: 1 };
}, 4(A) {
  return A.searchQuery === "" ? A : { ...A, searchQuery: "", searchActiveItemIndex: null };
}, 5: (A, B) => {
  let L = w(A, (K) => [...K, { id: B.id, dataRef: B.dataRef }]);
  return { ...A, ...L };
}, 6: (A, B) => {
  let L = w(A, (K) => {
    let V = K.findIndex((W) => W.id === B.id);
    return V !== -1 && K.splice(V, 1), K;
  });
  return { ...A, ...L, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C(A) {
  let B = useContext(U$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, C), L;
  }
  return B;
}
function ye$1(A, B) {
  return u$7(B.type, Te, A, B);
}
let Ie = Fragment;
function Me(A, B) {
  let { __demoMode: L = !1, ...K } = A, V = useReducer(ye$1, { __demoMode: L, menuState: L ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: W, itemsRef: J, buttonRef: ne }, ie] = V, ce = y$1(B);
  y$2([ne, J], (Ce, it) => {
    var at;
    ie({ type: 1 }), h$4(it, T$2.Loose) || (Ce.preventDefault(), (at = ne.current) == null || at.focus());
  }, W === 0);
  let re = o$6(() => {
    ie({ type: 1 });
  }), oe = useMemo(() => ({ open: W === 0, close: re }), [W, re]), ke = { ref: ce };
  return C__default.createElement(U$1.Provider, { value: V }, C__default.createElement(s$5, { value: u$7(W, { 0: d$3.Open, 1: d$3.Closed }) }, C$1({ ourProps: ke, theirProps: K, slot: oe, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(A, B) {
  var L;
  let K = I$5(), { id: V = `headlessui-menu-button-${K}`, ...W } = A, [J, ne] = C("Menu.Button"), ie = y$1(J.buttonRef, B), ce = p$3(), re = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), ce.nextFrame(() => ne({ type: 2, focus: c$4.First }));
        break;
      case o$2.ArrowUp:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), ce.nextFrame(() => ne({ type: 2, focus: c$4.Last }));
        break;
    }
  }), oe = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
        at.preventDefault();
        break;
    }
  }), ke = o$6((at) => {
    if (r$3(at.currentTarget)) return at.preventDefault();
    A.disabled || (J.menuState === 0 ? (ne({ type: 1 }), ce.nextFrame(() => {
      var ct;
      return (ct = J.buttonRef.current) == null ? void 0 : ct.focus({ preventScroll: !0 });
    })) : (at.preventDefault(), ne({ type: 0 })));
  }), Ce = useMemo(() => ({ open: J.menuState === 0 }), [J]), it = { ref: ie, id: V, type: T$1(A, J.buttonRef), "aria-haspopup": "menu", "aria-controls": (L = J.itemsRef.current) == null ? void 0 : L.id, "aria-expanded": J.menuState === 0, onKeyDown: re, onKeyUp: oe, onClick: ke };
  return C$1({ ourProps: it, theirProps: W, slot: Ce, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O.RenderStrategy | O.Static;
function Ee(A, B) {
  var L, K;
  let V = I$5(), { id: W = `headlessui-menu-items-${V}`, ...J } = A, [ne, ie] = C("Menu.Items"), ce = y$1(ne.itemsRef, B), re = n$2(ne.itemsRef), oe = p$3(), ke = u$3(), Ce = ke !== null ? (ke & d$3.Open) === d$3.Open : ne.menuState === 0;
  useEffect(() => {
    let ot = ne.itemsRef.current;
    ot && ne.menuState === 0 && ot !== (re == null ? void 0 : re.activeElement) && ot.focus({ preventScroll: !0 });
  }, [ne.menuState, ne.itemsRef, re]), F$2({ container: ne.itemsRef.current, enabled: ne.menuState === 0, accept(ot) {
    return ot.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : ot.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(ot) {
    ot.setAttribute("role", "none");
  } });
  let it = o$6((ot) => {
    var yt, mt;
    switch (oe.dispose(), ot.key) {
      case o$2.Space:
        if (ne.searchQuery !== "") return ot.preventDefault(), ot.stopPropagation(), ie({ type: 3, value: ot.key });
      case o$2.Enter:
        if (ot.preventDefault(), ot.stopPropagation(), ie({ type: 1 }), ne.activeItemIndex !== null) {
          let { dataRef: Tt } = ne.items[ne.activeItemIndex];
          (mt = (yt = Tt.current) == null ? void 0 : yt.domRef.current) == null || mt.click();
        }
        D$3(ne.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return ot.preventDefault(), ot.stopPropagation(), ie({ type: 2, focus: c$4.Next });
      case o$2.ArrowUp:
        return ot.preventDefault(), ot.stopPropagation(), ie({ type: 2, focus: c$4.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return ot.preventDefault(), ot.stopPropagation(), ie({ type: 2, focus: c$4.First });
      case o$2.End:
      case o$2.PageDown:
        return ot.preventDefault(), ot.stopPropagation(), ie({ type: 2, focus: c$4.Last });
      case o$2.Escape:
        ot.preventDefault(), ot.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          var Tt;
          return (Tt = ne.buttonRef.current) == null ? void 0 : Tt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        ot.preventDefault(), ot.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          _$2(ne.buttonRef.current, ot.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        ot.key.length === 1 && (ie({ type: 3, value: ot.key }), oe.setTimeout(() => ie({ type: 4 }), 350));
        break;
    }
  }), at = o$6((ot) => {
    switch (ot.key) {
      case o$2.Space:
        ot.preventDefault();
        break;
    }
  }), ct = useMemo(() => ({ open: ne.menuState === 0 }), [ne]), dt = { "aria-activedescendant": ne.activeItemIndex === null || (L = ne.items[ne.activeItemIndex]) == null ? void 0 : L.id, "aria-labelledby": (K = ne.buttonRef.current) == null ? void 0 : K.id, id: W, onKeyDown: it, onKeyUp: at, role: "menu", tabIndex: 0, ref: ce };
  return C$1({ ourProps: dt, theirProps: J, slot: ct, defaultTag: Ae, features: be, visible: Ce, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(A, B) {
  let L = I$5(), { id: K = `headlessui-menu-item-${L}`, disabled: V = !1, ...W } = A, [J, ne] = C("Menu.Item"), ie = J.activeItemIndex !== null ? J.items[J.activeItemIndex].id === K : !1, ce = useRef(null), re = y$1(B, ce);
  l$5(() => {
    if (J.__demoMode || J.menuState !== 0 || !ie || J.activationTrigger === 0) return;
    let Tt = o$5();
    return Tt.requestAnimationFrame(() => {
      var Pt, Nt;
      (Nt = (Pt = ce.current) == null ? void 0 : Pt.scrollIntoView) == null || Nt.call(Pt, { block: "nearest" });
    }), Tt.dispose;
  }, [J.__demoMode, ce, ie, J.menuState, J.activationTrigger, J.activeItemIndex]);
  let oe = s$1(ce), ke = useRef({ disabled: V, domRef: ce, get textValue() {
    return oe();
  } });
  l$5(() => {
    ke.current.disabled = V;
  }, [ke, V]), l$5(() => (ne({ type: 5, id: K, dataRef: ke }), () => ne({ type: 6, id: K })), [ke, K]);
  let Ce = o$6(() => {
    ne({ type: 1 });
  }), it = o$6((Tt) => {
    if (V) return Tt.preventDefault();
    ne({ type: 1 }), D$3(J.buttonRef.current);
  }), at = o$6(() => {
    if (V) return ne({ type: 2, focus: c$4.Nothing });
    ne({ type: 2, focus: c$4.Specific, id: K });
  }), ct = u$5(), dt = o$6((Tt) => ct.update(Tt)), ot = o$6((Tt) => {
    ct.wasMoved(Tt) && (V || ie || ne({ type: 2, focus: c$4.Specific, id: K, trigger: 0 }));
  }), yt = o$6((Tt) => {
    ct.wasMoved(Tt) && (V || ie && ne({ type: 2, focus: c$4.Nothing }));
  }), mt = useMemo(() => ({ active: ie, disabled: V, close: Ce }), [ie, V, Ce]);
  return C$1({ ourProps: { id: K, ref: re, role: "menuitem", tabIndex: V === !0 ? void 0 : -1, "aria-disabled": V === !0 ? !0 : void 0, disabled: void 0, onClick: it, onFocus: at, onPointerEnter: dt, onMouseEnter: dt, onPointerMove: ot, onMouseMove: ot, onPointerLeave: yt, onMouseLeave: yt }, theirProps: W, slot: mt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c(A = 0) {
  let [B, L] = useState(A), K = f$4(), V = useCallback((ie) => {
    K.current && L((ce) => ce | ie);
  }, [B, K]), W = useCallback((ie) => !!(B & ie), [B]), J = useCallback((ie) => {
    K.current && L((ce) => ce & ~ie);
  }, [L, K]), ne = useCallback((ie) => {
    K.current && L((ce) => ce ^ ie);
  }, [L]);
  return { flags: B, addFlag: V, hasFlag: W, removeFlag: J, toggleFlag: ne };
}
function l(A) {
  let B = { called: !1 };
  return (...L) => {
    if (!B.called) return B.called = !0, A(...L);
  };
}
function g(A, ...B) {
  A && B.length > 0 && A.classList.add(...B);
}
function v(A, ...B) {
  A && B.length > 0 && A.classList.remove(...B);
}
function b(A, B) {
  let L = o$5();
  if (!A) return L.dispose;
  let { transitionDuration: K, transitionDelay: V } = getComputedStyle(A), [W, J] = [K, V].map((ie) => {
    let [ce = 0] = ie.split(",").filter(Boolean).map((re) => re.includes("ms") ? parseFloat(re) : parseFloat(re) * 1e3).sort((re, oe) => oe - re);
    return ce;
  }), ne = W + J;
  if (ne !== 0) {
    L.group((ce) => {
      ce.setTimeout(() => {
        B(), ce.dispose();
      }, ne), ce.addEventListener(A, "transitionrun", (re) => {
        re.target === re.currentTarget && ce.dispose();
      });
    });
    let ie = L.addEventListener(A, "transitionend", (ce) => {
      ce.target === ce.currentTarget && (B(), ie());
    });
  } else B();
  return L.add(() => B()), L.dispose;
}
function M$1(A, B, L, K) {
  let V = L ? "enter" : "leave", W = o$5(), J = K !== void 0 ? l(K) : () => {
  };
  V === "enter" && (A.removeAttribute("hidden"), A.style.display = "");
  let ne = u$7(V, { enter: () => B.enter, leave: () => B.leave }), ie = u$7(V, { enter: () => B.enterTo, leave: () => B.leaveTo }), ce = u$7(V, { enter: () => B.enterFrom, leave: () => B.leaveFrom });
  return v(A, ...B.base, ...B.enter, ...B.enterTo, ...B.enterFrom, ...B.leave, ...B.leaveFrom, ...B.leaveTo, ...B.entered), g(A, ...B.base, ...ne, ...ce), W.nextFrame(() => {
    v(A, ...B.base, ...ne, ...ce), g(A, ...B.base, ...ne, ...ie), b(A, () => (v(A, ...B.base, ...ne), g(A, ...B.base, ...B.entered), J()));
  }), W.dispose;
}
function D({ immediate: A, container: B, direction: L, classes: K, onStart: V, onStop: W }) {
  let J = f$4(), ne = p$3(), ie = s$9(L);
  l$5(() => {
    A && (ie.current = "enter");
  }, [A]), l$5(() => {
    let ce = o$5();
    ne.add(ce.dispose);
    let re = B.current;
    if (re && ie.current !== "idle" && J.current) return ce.dispose(), V.current(ie.current), ce.add(M$1(re, K.current, ie.current === "enter", () => {
      ce.dispose(), W.current(ie.current);
    })), ce.dispose;
  }, [L]);
}
function S(A = "") {
  return A.split(/\s+/).filter((B) => B.length > 1);
}
let I = createContext(null);
I.displayName = "TransitionContext";
var Se = ((A) => (A.Visible = "visible", A.Hidden = "hidden", A))(Se || {});
function ye() {
  let A = useContext(I);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
function xe() {
  let A = useContext(M);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(A) {
  return "children" in A ? U(A.children) : A.current.filter(({ el: B }) => B.current !== null).filter(({ state: B }) => B === "visible").length > 0;
}
function se(A, B) {
  let L = s$9(A), K = useRef([]), V = f$4(), W = p$3(), J = o$6((Ce, it = v$1.Hidden) => {
    let at = K.current.findIndex(({ el: ct }) => ct === Ce);
    at !== -1 && (u$7(it, { [v$1.Unmount]() {
      K.current.splice(at, 1);
    }, [v$1.Hidden]() {
      K.current[at].state = "hidden";
    } }), W.microTask(() => {
      var ct;
      !U(K) && V.current && ((ct = L.current) == null || ct.call(L));
    }));
  }), ne = o$6((Ce) => {
    let it = K.current.find(({ el: at }) => at === Ce);
    return it ? it.state !== "visible" && (it.state = "visible") : K.current.push({ el: Ce, state: "visible" }), () => J(Ce, v$1.Unmount);
  }), ie = useRef([]), ce = useRef(Promise.resolve()), re = useRef({ enter: [], leave: [], idle: [] }), oe = o$6((Ce, it, at) => {
    ie.current.splice(0), B && (B.chains.current[it] = B.chains.current[it].filter(([ct]) => ct !== Ce)), B == null || B.chains.current[it].push([Ce, new Promise((ct) => {
      ie.current.push(ct);
    })]), B == null || B.chains.current[it].push([Ce, new Promise((ct) => {
      Promise.all(re.current[it].map(([dt, ot]) => ot)).then(() => ct());
    })]), it === "enter" ? ce.current = ce.current.then(() => B == null ? void 0 : B.wait.current).then(() => at(it)) : at(it);
  }), ke = o$6((Ce, it, at) => {
    Promise.all(re.current[it].splice(0).map(([ct, dt]) => dt)).then(() => {
      var ct;
      (ct = ie.current.shift()) == null || ct();
    }).then(() => at(it));
  });
  return useMemo(() => ({ children: K, register: ne, unregister: J, onStart: oe, onStop: ke, wait: ce, chains: re }), [ne, J, K, oe, ke, re, ce]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(A) {
  var B;
  let L = {};
  for (let K of Pe) L[K] = (B = A[K]) != null ? B : Ne;
  return L;
}
function Re(A) {
  let B = useRef(ae(A));
  return useEffect(() => {
    B.current = ae(A);
  }, [A]), B;
}
let De = "div", le = O.RenderStrategy;
function He(A, B) {
  var L, K;
  let { beforeEnter: V, afterEnter: W, beforeLeave: J, afterLeave: ne, enter: ie, enterFrom: ce, enterTo: re, entered: oe, leave: ke, leaveFrom: Ce, leaveTo: it, ...at } = A, ct = useRef(null), dt = y$1(ct, B), ot = (L = at.unmount) == null || L ? v$1.Unmount : v$1.Hidden, { show: yt, appear: mt, initial: Tt } = ye(), [Pt, Nt] = useState(yt ? "visible" : "hidden"), St = xe(), { register: vt, unregister: It } = St;
  useEffect(() => vt(ct), [vt, ct]), useEffect(() => {
    if (ot === v$1.Hidden && ct.current) {
      if (yt && Pt !== "visible") {
        Nt("visible");
        return;
      }
      return u$7(Pt, { hidden: () => It(ct), visible: () => vt(ct) });
    }
  }, [Pt, ct, vt, It, yt, ot]);
  let wt = s$9({ base: S(at.className), enter: S(ie), enterFrom: S(ce), enterTo: S(re), entered: S(oe), leave: S(ke), leaveFrom: S(Ce), leaveTo: S(it) }), Oe = Re({ beforeEnter: V, afterEnter: W, beforeLeave: J, afterLeave: ne }), rt = l$4();
  useEffect(() => {
    if (rt && Pt === "visible" && ct.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [ct, Pt, rt]);
  let pe = Tt && !mt, nt = mt && yt && Tt, st = !rt || pe ? "idle" : yt ? "enter" : "leave", ft = c(0), ht = o$6((jt) => u$7(jt, { enter: () => {
    ft.addFlag(d$3.Opening), Oe.current.beforeEnter();
  }, leave: () => {
    ft.addFlag(d$3.Closing), Oe.current.beforeLeave();
  }, idle: () => {
  } })), bt = o$6((jt) => u$7(jt, { enter: () => {
    ft.removeFlag(d$3.Opening), Oe.current.afterEnter();
  }, leave: () => {
    ft.removeFlag(d$3.Closing), Oe.current.afterLeave();
  }, idle: () => {
  } })), ut = se(() => {
    Nt("hidden"), It(ct);
  }, St), gt = useRef(!1);
  D({ immediate: nt, container: ct, classes: wt, direction: st, onStart: s$9((jt) => {
    gt.current = !0, ut.onStart(ct, jt, ht);
  }), onStop: s$9((jt) => {
    gt.current = !1, ut.onStop(ct, jt, bt), jt === "leave" && !U(ut) && (Nt("hidden"), It(ct));
  }) });
  let lt = at, $t = { ref: dt };
  return nt ? lt = { ...lt, className: t$4(at.className, ...wt.current.enter, ...wt.current.enterFrom) } : gt.current && (lt.className = t$4(at.className, (K = ct.current) == null ? void 0 : K.className), lt.className === "" && delete lt.className), C__default.createElement(M.Provider, { value: ut }, C__default.createElement(s$5, { value: u$7(Pt, { visible: d$3.Open, hidden: d$3.Closed }) | ft.flags }, C$1({ ourProps: $t, theirProps: lt, defaultTag: De, features: le, visible: Pt === "visible", name: "Transition.Child" })));
}
function Fe(A, B) {
  let { show: L, appear: K = !1, unmount: V = !0, ...W } = A, J = useRef(null), ne = y$1(J, B);
  l$4();
  let ie = u$3();
  if (L === void 0 && ie !== null && (L = (ie & d$3.Open) === d$3.Open), ![!0, !1].includes(L)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [ce, re] = useState(L ? "visible" : "hidden"), oe = se(() => {
    re("hidden");
  }), [ke, Ce] = useState(!0), it = useRef([L]);
  l$5(() => {
    ke !== !1 && it.current[it.current.length - 1] !== L && (it.current.push(L), Ce(!1));
  }, [it, L]);
  let at = useMemo(() => ({ show: L, appear: K, initial: ke }), [L, K, ke]);
  useEffect(() => {
    if (L) re("visible");
    else if (!U(oe)) re("hidden");
    else {
      let yt = J.current;
      if (!yt) return;
      let mt = yt.getBoundingClientRect();
      mt.x === 0 && mt.y === 0 && mt.width === 0 && mt.height === 0 && re("hidden");
    }
  }, [L, oe]);
  let ct = { unmount: V }, dt = o$6(() => {
    var yt;
    ke && Ce(!1), (yt = A.beforeEnter) == null || yt.call(A);
  }), ot = o$6(() => {
    var yt;
    ke && Ce(!1), (yt = A.beforeLeave) == null || yt.call(A);
  });
  return C__default.createElement(M.Provider, { value: oe }, C__default.createElement(I.Provider, { value: at }, C$1({ ourProps: { ...ct, as: Fragment, children: C__default.createElement(ue, { ref: ne, ...ct, ...W, beforeEnter: dt, beforeLeave: ot }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: ce === "visible", name: "Transition" })));
}
function _e(A, B) {
  let L = useContext(I) !== null, K = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !L && K ? C__default.createElement(q, { ref: B, ...A }) : C__default.createElement(ue, { ref: B, ...A }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(A, B = 4, L = 5) {
  if (A.length <= B + L)
    return A;
  const K = A.slice(0, B), V = A.slice(A.length - L);
  return `${K}...${V}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: A,
  network: B,
  onViewProfile: L,
  onChangeWallet: K,
  onDisconnectWallet: V,
  renderAvatar: W
}) {
  const { wallet: J } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    qe$1,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: ne }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            W ? W(A, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: A,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[J],
                alt: `${J} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(A) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[B] ?? B })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${ne ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => L == null ? void 0 : L(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(A) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => K == null ? void 0 : K(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => V == null ? void 0 : V(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: A,
  disabled: B
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: A,
      disabled: B,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength$1(A) {
  var B = getLens$1(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength$1(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray$1(A) {
  var B, L = getLens$1(A), K = L[0], V = L[1], W = new Arr$1(_byteLength$1(A, K, V)), J = 0, ne = V > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup$1[A.charCodeAt(ie)] << 18 | revLookup$1[A.charCodeAt(ie + 1)] << 12 | revLookup$1[A.charCodeAt(ie + 2)] << 6 | revLookup$1[A.charCodeAt(ie + 3)], W[J++] = B >> 16 & 255, W[J++] = B >> 8 & 255, W[J++] = B & 255;
  return V === 2 && (B = revLookup$1[A.charCodeAt(ie)] << 2 | revLookup$1[A.charCodeAt(ie + 1)] >> 4, W[J++] = B & 255), V === 1 && (B = revLookup$1[A.charCodeAt(ie)] << 10 | revLookup$1[A.charCodeAt(ie + 1)] << 4 | revLookup$1[A.charCodeAt(ie + 2)] >> 2, W[J++] = B >> 8 & 255, W[J++] = B & 255), W;
}
function tripletToBase64$1(A) {
  return lookup$1[A >> 18 & 63] + lookup$1[A >> 12 & 63] + lookup$1[A >> 6 & 63] + lookup$1[A & 63];
}
function encodeChunk$1(A, B, L) {
  for (var K, V = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), V.push(tripletToBase64$1(K));
  return V.join("");
}
function fromByteArray$1(A) {
  for (var B, L = A.length, K = L % 3, V = [], W = 16383, J = 0, ne = L - K; J < ne; J += W)
    V.push(encodeChunk$1(A, J, J + W > ne ? ne : J + W));
  return K === 1 ? (B = A[L - 1], V.push(
    lookup$1[B >> 2] + lookup$1[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], V.push(
    lookup$1[B >> 10] + lookup$1[B >> 4 & 63] + lookup$1[B << 2 & 63] + "="
  )), V.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(A, B, L, K, V) {
  var W, J, ne = V * 8 - K - 1, ie = (1 << ne) - 1, ce = ie >> 1, re = -7, oe = L ? V - 1 : 0, ke = L ? -1 : 1, Ce = A[B + oe];
  for (oe += ke, W = Ce & (1 << -re) - 1, Ce >>= -re, re += ne; re > 0; W = W * 256 + A[B + oe], oe += ke, re -= 8)
    ;
  for (J = W & (1 << -re) - 1, W >>= -re, re += K; re > 0; J = J * 256 + A[B + oe], oe += ke, re -= 8)
    ;
  if (W === 0)
    W = 1 - ce;
  else {
    if (W === ie)
      return J ? NaN : (Ce ? -1 : 1) * (1 / 0);
    J = J + Math.pow(2, K), W = W - ce;
  }
  return (Ce ? -1 : 1) * J * Math.pow(2, W - K);
};
ieee754.write = function(A, B, L, K, V, W) {
  var J, ne, ie, ce = W * 8 - V - 1, re = (1 << ce) - 1, oe = re >> 1, ke = V === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ce = K ? 0 : W - 1, it = K ? 1 : -1, at = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
  for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (ne = isNaN(B) ? 1 : 0, J = re) : (J = Math.floor(Math.log(B) / Math.LN2), B * (ie = Math.pow(2, -J)) < 1 && (J--, ie *= 2), J + oe >= 1 ? B += ke / ie : B += ke * Math.pow(2, 1 - oe), B * ie >= 2 && (J++, ie /= 2), J + oe >= re ? (ne = 0, J = re) : J + oe >= 1 ? (ne = (B * ie - 1) * Math.pow(2, V), J = J + oe) : (ne = B * Math.pow(2, oe - 1) * Math.pow(2, V), J = 0)); V >= 8; A[L + Ce] = ne & 255, Ce += it, ne /= 256, V -= 8)
    ;
  for (J = J << V | ne, ce += V; ce > 0; A[L + Ce] = J & 255, Ce += it, J /= 256, ce -= 8)
    ;
  A[L + Ce - it] |= at * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(A) {
  const B = base64Js$1, L = ieee754, K = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  A.Buffer = re, A.SlowBuffer = Tt, A.INSPECT_MAX_BYTES = 50;
  const V = 2147483647;
  A.kMaxLength = V;
  const { Uint8Array: W, ArrayBuffer: J, SharedArrayBuffer: ne } = globalThis;
  re.TYPED_ARRAY_SUPPORT = ie(), !re.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ie() {
    try {
      const Ot = new W(1), At = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(At, W.prototype), Object.setPrototypeOf(Ot, At), Ot.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(re.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (re.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(re.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (re.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ce(Ot) {
    if (Ot > V)
      throw new RangeError('The value "' + Ot + '" is invalid for option "size"');
    const At = new W(Ot);
    return Object.setPrototypeOf(At, re.prototype), At;
  }
  function re(Ot, At, Bt) {
    if (typeof Ot == "number") {
      if (typeof At == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return it(Ot);
    }
    return oe(Ot, At, Bt);
  }
  re.poolSize = 8192;
  function oe(Ot, At, Bt) {
    if (typeof Ot == "string")
      return at(Ot, At);
    if (J.isView(Ot))
      return dt(Ot);
    if (Ot == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ot
      );
    if (xr(Ot, J) || Ot && xr(Ot.buffer, J) || typeof ne < "u" && (xr(Ot, ne) || Ot && xr(Ot.buffer, ne)))
      return ot(Ot, At, Bt);
    if (typeof Ot == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ut = Ot.valueOf && Ot.valueOf();
    if (Ut != null && Ut !== Ot)
      return re.from(Ut, At, Bt);
    const Xt = yt(Ot);
    if (Xt) return Xt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ot[Symbol.toPrimitive] == "function")
      return re.from(Ot[Symbol.toPrimitive]("string"), At, Bt);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ot
    );
  }
  re.from = function(Ot, At, Bt) {
    return oe(Ot, At, Bt);
  }, Object.setPrototypeOf(re.prototype, W.prototype), Object.setPrototypeOf(re, W);
  function ke(Ot) {
    if (typeof Ot != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Ot < 0)
      throw new RangeError('The value "' + Ot + '" is invalid for option "size"');
  }
  function Ce(Ot, At, Bt) {
    return ke(Ot), Ot <= 0 ? ce(Ot) : At !== void 0 ? typeof Bt == "string" ? ce(Ot).fill(At, Bt) : ce(Ot).fill(At) : ce(Ot);
  }
  re.alloc = function(Ot, At, Bt) {
    return Ce(Ot, At, Bt);
  };
  function it(Ot) {
    return ke(Ot), ce(Ot < 0 ? 0 : mt(Ot) | 0);
  }
  re.allocUnsafe = function(Ot) {
    return it(Ot);
  }, re.allocUnsafeSlow = function(Ot) {
    return it(Ot);
  };
  function at(Ot, At) {
    if ((typeof At != "string" || At === "") && (At = "utf8"), !re.isEncoding(At))
      throw new TypeError("Unknown encoding: " + At);
    const Bt = Pt(Ot, At) | 0;
    let Ut = ce(Bt);
    const Xt = Ut.write(Ot, At);
    return Xt !== Bt && (Ut = Ut.slice(0, Xt)), Ut;
  }
  function ct(Ot) {
    const At = Ot.length < 0 ? 0 : mt(Ot.length) | 0, Bt = ce(At);
    for (let Ut = 0; Ut < At; Ut += 1)
      Bt[Ut] = Ot[Ut] & 255;
    return Bt;
  }
  function dt(Ot) {
    if (xr(Ot, W)) {
      const At = new W(Ot);
      return ot(At.buffer, At.byteOffset, At.byteLength);
    }
    return ct(Ot);
  }
  function ot(Ot, At, Bt) {
    if (At < 0 || Ot.byteLength < At)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Ot.byteLength < At + (Bt || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ut;
    return At === void 0 && Bt === void 0 ? Ut = new W(Ot) : Bt === void 0 ? Ut = new W(Ot, At) : Ut = new W(Ot, At, Bt), Object.setPrototypeOf(Ut, re.prototype), Ut;
  }
  function yt(Ot) {
    if (re.isBuffer(Ot)) {
      const At = mt(Ot.length) | 0, Bt = ce(At);
      return Bt.length === 0 || Ot.copy(Bt, 0, 0, At), Bt;
    }
    if (Ot.length !== void 0)
      return typeof Ot.length != "number" || Mr(Ot.length) ? ce(0) : ct(Ot);
    if (Ot.type === "Buffer" && Array.isArray(Ot.data))
      return ct(Ot.data);
  }
  function mt(Ot) {
    if (Ot >= V)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + V.toString(16) + " bytes");
    return Ot | 0;
  }
  function Tt(Ot) {
    return +Ot != Ot && (Ot = 0), re.alloc(+Ot);
  }
  re.isBuffer = function(At) {
    return At != null && At._isBuffer === !0 && At !== re.prototype;
  }, re.compare = function(At, Bt) {
    if (xr(At, W) && (At = re.from(At, At.offset, At.byteLength)), xr(Bt, W) && (Bt = re.from(Bt, Bt.offset, Bt.byteLength)), !re.isBuffer(At) || !re.isBuffer(Bt))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (At === Bt) return 0;
    let Ut = At.length, Xt = Bt.length;
    for (let Zt = 0, tr = Math.min(Ut, Xt); Zt < tr; ++Zt)
      if (At[Zt] !== Bt[Zt]) {
        Ut = At[Zt], Xt = Bt[Zt];
        break;
      }
    return Ut < Xt ? -1 : Xt < Ut ? 1 : 0;
  }, re.isEncoding = function(At) {
    switch (String(At).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, re.concat = function(At, Bt) {
    if (!Array.isArray(At))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (At.length === 0)
      return re.alloc(0);
    let Ut;
    if (Bt === void 0)
      for (Bt = 0, Ut = 0; Ut < At.length; ++Ut)
        Bt += At[Ut].length;
    const Xt = re.allocUnsafe(Bt);
    let Zt = 0;
    for (Ut = 0; Ut < At.length; ++Ut) {
      let tr = At[Ut];
      if (xr(tr, W))
        Zt + tr.length > Xt.length ? (re.isBuffer(tr) || (tr = re.from(tr)), tr.copy(Xt, Zt)) : W.prototype.set.call(
          Xt,
          tr,
          Zt
        );
      else if (re.isBuffer(tr))
        tr.copy(Xt, Zt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Zt += tr.length;
    }
    return Xt;
  };
  function Pt(Ot, At) {
    if (re.isBuffer(Ot))
      return Ot.length;
    if (J.isView(Ot) || xr(Ot, J))
      return Ot.byteLength;
    if (typeof Ot != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ot
      );
    const Bt = Ot.length, Ut = arguments.length > 2 && arguments[2] === !0;
    if (!Ut && Bt === 0) return 0;
    let Xt = !1;
    for (; ; )
      switch (At) {
        case "ascii":
        case "latin1":
        case "binary":
          return Bt;
        case "utf8":
        case "utf-8":
          return Pr(Ot).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Bt * 2;
        case "hex":
          return Bt >>> 1;
        case "base64":
          return br(Ot).length;
        default:
          if (Xt)
            return Ut ? -1 : Pr(Ot).length;
          At = ("" + At).toLowerCase(), Xt = !0;
      }
  }
  re.byteLength = Pt;
  function Nt(Ot, At, Bt) {
    let Ut = !1;
    if ((At === void 0 || At < 0) && (At = 0), At > this.length || ((Bt === void 0 || Bt > this.length) && (Bt = this.length), Bt <= 0) || (Bt >>>= 0, At >>>= 0, Bt <= At))
      return "";
    for (Ot || (Ot = "utf8"); ; )
      switch (Ot) {
        case "hex":
          return lt(this, At, Bt);
        case "utf8":
        case "utf-8":
          return ft(this, At, Bt);
        case "ascii":
          return ut(this, At, Bt);
        case "latin1":
        case "binary":
          return gt(this, At, Bt);
        case "base64":
          return st(this, At, Bt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return $t(this, At, Bt);
        default:
          if (Ut) throw new TypeError("Unknown encoding: " + Ot);
          Ot = (Ot + "").toLowerCase(), Ut = !0;
      }
  }
  re.prototype._isBuffer = !0;
  function St(Ot, At, Bt) {
    const Ut = Ot[At];
    Ot[At] = Ot[Bt], Ot[Bt] = Ut;
  }
  re.prototype.swap16 = function() {
    const At = this.length;
    if (At % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Bt = 0; Bt < At; Bt += 2)
      St(this, Bt, Bt + 1);
    return this;
  }, re.prototype.swap32 = function() {
    const At = this.length;
    if (At % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Bt = 0; Bt < At; Bt += 4)
      St(this, Bt, Bt + 3), St(this, Bt + 1, Bt + 2);
    return this;
  }, re.prototype.swap64 = function() {
    const At = this.length;
    if (At % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Bt = 0; Bt < At; Bt += 8)
      St(this, Bt, Bt + 7), St(this, Bt + 1, Bt + 6), St(this, Bt + 2, Bt + 5), St(this, Bt + 3, Bt + 4);
    return this;
  }, re.prototype.toString = function() {
    const At = this.length;
    return At === 0 ? "" : arguments.length === 0 ? ft(this, 0, At) : Nt.apply(this, arguments);
  }, re.prototype.toLocaleString = re.prototype.toString, re.prototype.equals = function(At) {
    if (!re.isBuffer(At)) throw new TypeError("Argument must be a Buffer");
    return this === At ? !0 : re.compare(this, At) === 0;
  }, re.prototype.inspect = function() {
    let At = "";
    const Bt = A.INSPECT_MAX_BYTES;
    return At = this.toString("hex", 0, Bt).replace(/(.{2})/g, "$1 ").trim(), this.length > Bt && (At += " ... "), "<Buffer " + At + ">";
  }, K && (re.prototype[K] = re.prototype.inspect), re.prototype.compare = function(At, Bt, Ut, Xt, Zt) {
    if (xr(At, W) && (At = re.from(At, At.offset, At.byteLength)), !re.isBuffer(At))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof At
      );
    if (Bt === void 0 && (Bt = 0), Ut === void 0 && (Ut = At ? At.length : 0), Xt === void 0 && (Xt = 0), Zt === void 0 && (Zt = this.length), Bt < 0 || Ut > At.length || Xt < 0 || Zt > this.length)
      throw new RangeError("out of range index");
    if (Xt >= Zt && Bt >= Ut)
      return 0;
    if (Xt >= Zt)
      return -1;
    if (Bt >= Ut)
      return 1;
    if (Bt >>>= 0, Ut >>>= 0, Xt >>>= 0, Zt >>>= 0, this === At) return 0;
    let tr = Zt - Xt, vr = Ut - Bt;
    const Br = Math.min(tr, vr), yr = this.slice(Xt, Zt), $r = At.slice(Bt, Ut);
    for (let Er = 0; Er < Br; ++Er)
      if (yr[Er] !== $r[Er]) {
        tr = yr[Er], vr = $r[Er];
        break;
      }
    return tr < vr ? -1 : vr < tr ? 1 : 0;
  };
  function vt(Ot, At, Bt, Ut, Xt) {
    if (Ot.length === 0) return -1;
    if (typeof Bt == "string" ? (Ut = Bt, Bt = 0) : Bt > 2147483647 ? Bt = 2147483647 : Bt < -2147483648 && (Bt = -2147483648), Bt = +Bt, Mr(Bt) && (Bt = Xt ? 0 : Ot.length - 1), Bt < 0 && (Bt = Ot.length + Bt), Bt >= Ot.length) {
      if (Xt) return -1;
      Bt = Ot.length - 1;
    } else if (Bt < 0)
      if (Xt) Bt = 0;
      else return -1;
    if (typeof At == "string" && (At = re.from(At, Ut)), re.isBuffer(At))
      return At.length === 0 ? -1 : It(Ot, At, Bt, Ut, Xt);
    if (typeof At == "number")
      return At = At & 255, typeof W.prototype.indexOf == "function" ? Xt ? W.prototype.indexOf.call(Ot, At, Bt) : W.prototype.lastIndexOf.call(Ot, At, Bt) : It(Ot, [At], Bt, Ut, Xt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function It(Ot, At, Bt, Ut, Xt) {
    let Zt = 1, tr = Ot.length, vr = At.length;
    if (Ut !== void 0 && (Ut = String(Ut).toLowerCase(), Ut === "ucs2" || Ut === "ucs-2" || Ut === "utf16le" || Ut === "utf-16le")) {
      if (Ot.length < 2 || At.length < 2)
        return -1;
      Zt = 2, tr /= 2, vr /= 2, Bt /= 2;
    }
    function Br($r, Er) {
      return Zt === 1 ? $r[Er] : $r.readUInt16BE(Er * Zt);
    }
    let yr;
    if (Xt) {
      let $r = -1;
      for (yr = Bt; yr < tr; yr++)
        if (Br(Ot, yr) === Br(At, $r === -1 ? 0 : yr - $r)) {
          if ($r === -1 && ($r = yr), yr - $r + 1 === vr) return $r * Zt;
        } else
          $r !== -1 && (yr -= yr - $r), $r = -1;
    } else
      for (Bt + vr > tr && (Bt = tr - vr), yr = Bt; yr >= 0; yr--) {
        let $r = !0;
        for (let Er = 0; Er < vr; Er++)
          if (Br(Ot, yr + Er) !== Br(At, Er)) {
            $r = !1;
            break;
          }
        if ($r) return yr;
      }
    return -1;
  }
  re.prototype.includes = function(At, Bt, Ut) {
    return this.indexOf(At, Bt, Ut) !== -1;
  }, re.prototype.indexOf = function(At, Bt, Ut) {
    return vt(this, At, Bt, Ut, !0);
  }, re.prototype.lastIndexOf = function(At, Bt, Ut) {
    return vt(this, At, Bt, Ut, !1);
  };
  function wt(Ot, At, Bt, Ut) {
    Bt = Number(Bt) || 0;
    const Xt = Ot.length - Bt;
    Ut ? (Ut = Number(Ut), Ut > Xt && (Ut = Xt)) : Ut = Xt;
    const Zt = At.length;
    Ut > Zt / 2 && (Ut = Zt / 2);
    let tr;
    for (tr = 0; tr < Ut; ++tr) {
      const vr = parseInt(At.substr(tr * 2, 2), 16);
      if (Mr(vr)) return tr;
      Ot[Bt + tr] = vr;
    }
    return tr;
  }
  function Oe(Ot, At, Bt, Ut) {
    return hr(Pr(At, Ot.length - Bt), Ot, Bt, Ut);
  }
  function rt(Ot, At, Bt, Ut) {
    return hr(ur(At), Ot, Bt, Ut);
  }
  function pe(Ot, At, Bt, Ut) {
    return hr(br(At), Ot, Bt, Ut);
  }
  function nt(Ot, At, Bt, Ut) {
    return hr(pr(At, Ot.length - Bt), Ot, Bt, Ut);
  }
  re.prototype.write = function(At, Bt, Ut, Xt) {
    if (Bt === void 0)
      Xt = "utf8", Ut = this.length, Bt = 0;
    else if (Ut === void 0 && typeof Bt == "string")
      Xt = Bt, Ut = this.length, Bt = 0;
    else if (isFinite(Bt))
      Bt = Bt >>> 0, isFinite(Ut) ? (Ut = Ut >>> 0, Xt === void 0 && (Xt = "utf8")) : (Xt = Ut, Ut = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Zt = this.length - Bt;
    if ((Ut === void 0 || Ut > Zt) && (Ut = Zt), At.length > 0 && (Ut < 0 || Bt < 0) || Bt > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Xt || (Xt = "utf8");
    let tr = !1;
    for (; ; )
      switch (Xt) {
        case "hex":
          return wt(this, At, Bt, Ut);
        case "utf8":
        case "utf-8":
          return Oe(this, At, Bt, Ut);
        case "ascii":
        case "latin1":
        case "binary":
          return rt(this, At, Bt, Ut);
        case "base64":
          return pe(this, At, Bt, Ut);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return nt(this, At, Bt, Ut);
        default:
          if (tr) throw new TypeError("Unknown encoding: " + Xt);
          Xt = ("" + Xt).toLowerCase(), tr = !0;
      }
  }, re.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function st(Ot, At, Bt) {
    return At === 0 && Bt === Ot.length ? B.fromByteArray(Ot) : B.fromByteArray(Ot.slice(At, Bt));
  }
  function ft(Ot, At, Bt) {
    Bt = Math.min(Ot.length, Bt);
    const Ut = [];
    let Xt = At;
    for (; Xt < Bt; ) {
      const Zt = Ot[Xt];
      let tr = null, vr = Zt > 239 ? 4 : Zt > 223 ? 3 : Zt > 191 ? 2 : 1;
      if (Xt + vr <= Bt) {
        let Br, yr, $r, Er;
        switch (vr) {
          case 1:
            Zt < 128 && (tr = Zt);
            break;
          case 2:
            Br = Ot[Xt + 1], (Br & 192) === 128 && (Er = (Zt & 31) << 6 | Br & 63, Er > 127 && (tr = Er));
            break;
          case 3:
            Br = Ot[Xt + 1], yr = Ot[Xt + 2], (Br & 192) === 128 && (yr & 192) === 128 && (Er = (Zt & 15) << 12 | (Br & 63) << 6 | yr & 63, Er > 2047 && (Er < 55296 || Er > 57343) && (tr = Er));
            break;
          case 4:
            Br = Ot[Xt + 1], yr = Ot[Xt + 2], $r = Ot[Xt + 3], (Br & 192) === 128 && (yr & 192) === 128 && ($r & 192) === 128 && (Er = (Zt & 15) << 18 | (Br & 63) << 12 | (yr & 63) << 6 | $r & 63, Er > 65535 && Er < 1114112 && (tr = Er));
        }
      }
      tr === null ? (tr = 65533, vr = 1) : tr > 65535 && (tr -= 65536, Ut.push(tr >>> 10 & 1023 | 55296), tr = 56320 | tr & 1023), Ut.push(tr), Xt += vr;
    }
    return bt(Ut);
  }
  const ht = 4096;
  function bt(Ot) {
    const At = Ot.length;
    if (At <= ht)
      return String.fromCharCode.apply(String, Ot);
    let Bt = "", Ut = 0;
    for (; Ut < At; )
      Bt += String.fromCharCode.apply(
        String,
        Ot.slice(Ut, Ut += ht)
      );
    return Bt;
  }
  function ut(Ot, At, Bt) {
    let Ut = "";
    Bt = Math.min(Ot.length, Bt);
    for (let Xt = At; Xt < Bt; ++Xt)
      Ut += String.fromCharCode(Ot[Xt] & 127);
    return Ut;
  }
  function gt(Ot, At, Bt) {
    let Ut = "";
    Bt = Math.min(Ot.length, Bt);
    for (let Xt = At; Xt < Bt; ++Xt)
      Ut += String.fromCharCode(Ot[Xt]);
    return Ut;
  }
  function lt(Ot, At, Bt) {
    const Ut = Ot.length;
    (!At || At < 0) && (At = 0), (!Bt || Bt < 0 || Bt > Ut) && (Bt = Ut);
    let Xt = "";
    for (let Zt = At; Zt < Bt; ++Zt)
      Xt += _r[Ot[Zt]];
    return Xt;
  }
  function $t(Ot, At, Bt) {
    const Ut = Ot.slice(At, Bt);
    let Xt = "";
    for (let Zt = 0; Zt < Ut.length - 1; Zt += 2)
      Xt += String.fromCharCode(Ut[Zt] + Ut[Zt + 1] * 256);
    return Xt;
  }
  re.prototype.slice = function(At, Bt) {
    const Ut = this.length;
    At = ~~At, Bt = Bt === void 0 ? Ut : ~~Bt, At < 0 ? (At += Ut, At < 0 && (At = 0)) : At > Ut && (At = Ut), Bt < 0 ? (Bt += Ut, Bt < 0 && (Bt = 0)) : Bt > Ut && (Bt = Ut), Bt < At && (Bt = At);
    const Xt = this.subarray(At, Bt);
    return Object.setPrototypeOf(Xt, re.prototype), Xt;
  };
  function jt(Ot, At, Bt) {
    if (Ot % 1 !== 0 || Ot < 0) throw new RangeError("offset is not uint");
    if (Ot + At > Bt) throw new RangeError("Trying to access beyond buffer length");
  }
  re.prototype.readUintLE = re.prototype.readUIntLE = function(At, Bt, Ut) {
    At = At >>> 0, Bt = Bt >>> 0, Ut || jt(At, Bt, this.length);
    let Xt = this[At], Zt = 1, tr = 0;
    for (; ++tr < Bt && (Zt *= 256); )
      Xt += this[At + tr] * Zt;
    return Xt;
  }, re.prototype.readUintBE = re.prototype.readUIntBE = function(At, Bt, Ut) {
    At = At >>> 0, Bt = Bt >>> 0, Ut || jt(At, Bt, this.length);
    let Xt = this[At + --Bt], Zt = 1;
    for (; Bt > 0 && (Zt *= 256); )
      Xt += this[At + --Bt] * Zt;
    return Xt;
  }, re.prototype.readUint8 = re.prototype.readUInt8 = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 1, this.length), this[At];
  }, re.prototype.readUint16LE = re.prototype.readUInt16LE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 2, this.length), this[At] | this[At + 1] << 8;
  }, re.prototype.readUint16BE = re.prototype.readUInt16BE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 2, this.length), this[At] << 8 | this[At + 1];
  }, re.prototype.readUint32LE = re.prototype.readUInt32LE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 4, this.length), (this[At] | this[At + 1] << 8 | this[At + 2] << 16) + this[At + 3] * 16777216;
  }, re.prototype.readUint32BE = re.prototype.readUInt32BE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 4, this.length), this[At] * 16777216 + (this[At + 1] << 16 | this[At + 2] << 8 | this[At + 3]);
  }, re.prototype.readBigUInt64LE = Rr(function(At) {
    At = At >>> 0, sr(At, "offset");
    const Bt = this[At], Ut = this[At + 7];
    (Bt === void 0 || Ut === void 0) && lr(At, this.length - 8);
    const Xt = Bt + this[++At] * 2 ** 8 + this[++At] * 2 ** 16 + this[++At] * 2 ** 24, Zt = this[++At] + this[++At] * 2 ** 8 + this[++At] * 2 ** 16 + Ut * 2 ** 24;
    return BigInt(Xt) + (BigInt(Zt) << BigInt(32));
  }), re.prototype.readBigUInt64BE = Rr(function(At) {
    At = At >>> 0, sr(At, "offset");
    const Bt = this[At], Ut = this[At + 7];
    (Bt === void 0 || Ut === void 0) && lr(At, this.length - 8);
    const Xt = Bt * 2 ** 24 + this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + this[++At], Zt = this[++At] * 2 ** 24 + this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + Ut;
    return (BigInt(Xt) << BigInt(32)) + BigInt(Zt);
  }), re.prototype.readIntLE = function(At, Bt, Ut) {
    At = At >>> 0, Bt = Bt >>> 0, Ut || jt(At, Bt, this.length);
    let Xt = this[At], Zt = 1, tr = 0;
    for (; ++tr < Bt && (Zt *= 256); )
      Xt += this[At + tr] * Zt;
    return Zt *= 128, Xt >= Zt && (Xt -= Math.pow(2, 8 * Bt)), Xt;
  }, re.prototype.readIntBE = function(At, Bt, Ut) {
    At = At >>> 0, Bt = Bt >>> 0, Ut || jt(At, Bt, this.length);
    let Xt = Bt, Zt = 1, tr = this[At + --Xt];
    for (; Xt > 0 && (Zt *= 256); )
      tr += this[At + --Xt] * Zt;
    return Zt *= 128, tr >= Zt && (tr -= Math.pow(2, 8 * Bt)), tr;
  }, re.prototype.readInt8 = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 1, this.length), this[At] & 128 ? (255 - this[At] + 1) * -1 : this[At];
  }, re.prototype.readInt16LE = function(At, Bt) {
    At = At >>> 0, Bt || jt(At, 2, this.length);
    const Ut = this[At] | this[At + 1] << 8;
    return Ut & 32768 ? Ut | 4294901760 : Ut;
  }, re.prototype.readInt16BE = function(At, Bt) {
    At = At >>> 0, Bt || jt(At, 2, this.length);
    const Ut = this[At + 1] | this[At] << 8;
    return Ut & 32768 ? Ut | 4294901760 : Ut;
  }, re.prototype.readInt32LE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 4, this.length), this[At] | this[At + 1] << 8 | this[At + 2] << 16 | this[At + 3] << 24;
  }, re.prototype.readInt32BE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 4, this.length), this[At] << 24 | this[At + 1] << 16 | this[At + 2] << 8 | this[At + 3];
  }, re.prototype.readBigInt64LE = Rr(function(At) {
    At = At >>> 0, sr(At, "offset");
    const Bt = this[At], Ut = this[At + 7];
    (Bt === void 0 || Ut === void 0) && lr(At, this.length - 8);
    const Xt = this[At + 4] + this[At + 5] * 2 ** 8 + this[At + 6] * 2 ** 16 + (Ut << 24);
    return (BigInt(Xt) << BigInt(32)) + BigInt(Bt + this[++At] * 2 ** 8 + this[++At] * 2 ** 16 + this[++At] * 2 ** 24);
  }), re.prototype.readBigInt64BE = Rr(function(At) {
    At = At >>> 0, sr(At, "offset");
    const Bt = this[At], Ut = this[At + 7];
    (Bt === void 0 || Ut === void 0) && lr(At, this.length - 8);
    const Xt = (Bt << 24) + // Overflow
    this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + this[++At];
    return (BigInt(Xt) << BigInt(32)) + BigInt(this[++At] * 2 ** 24 + this[++At] * 2 ** 16 + this[++At] * 2 ** 8 + Ut);
  }), re.prototype.readFloatLE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 4, this.length), L.read(this, At, !0, 23, 4);
  }, re.prototype.readFloatBE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 4, this.length), L.read(this, At, !1, 23, 4);
  }, re.prototype.readDoubleLE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 8, this.length), L.read(this, At, !0, 52, 8);
  }, re.prototype.readDoubleBE = function(At, Bt) {
    return At = At >>> 0, Bt || jt(At, 8, this.length), L.read(this, At, !1, 52, 8);
  };
  function Jt(Ot, At, Bt, Ut, Xt, Zt) {
    if (!re.isBuffer(Ot)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (At > Xt || At < Zt) throw new RangeError('"value" argument is out of bounds');
    if (Bt + Ut > Ot.length) throw new RangeError("Index out of range");
  }
  re.prototype.writeUintLE = re.prototype.writeUIntLE = function(At, Bt, Ut, Xt) {
    if (At = +At, Bt = Bt >>> 0, Ut = Ut >>> 0, !Xt) {
      const vr = Math.pow(2, 8 * Ut) - 1;
      Jt(this, At, Bt, Ut, vr, 0);
    }
    let Zt = 1, tr = 0;
    for (this[Bt] = At & 255; ++tr < Ut && (Zt *= 256); )
      this[Bt + tr] = At / Zt & 255;
    return Bt + Ut;
  }, re.prototype.writeUintBE = re.prototype.writeUIntBE = function(At, Bt, Ut, Xt) {
    if (At = +At, Bt = Bt >>> 0, Ut = Ut >>> 0, !Xt) {
      const vr = Math.pow(2, 8 * Ut) - 1;
      Jt(this, At, Bt, Ut, vr, 0);
    }
    let Zt = Ut - 1, tr = 1;
    for (this[Bt + Zt] = At & 255; --Zt >= 0 && (tr *= 256); )
      this[Bt + Zt] = At / tr & 255;
    return Bt + Ut;
  }, re.prototype.writeUint8 = re.prototype.writeUInt8 = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 1, 255, 0), this[Bt] = At & 255, Bt + 1;
  }, re.prototype.writeUint16LE = re.prototype.writeUInt16LE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 2, 65535, 0), this[Bt] = At & 255, this[Bt + 1] = At >>> 8, Bt + 2;
  }, re.prototype.writeUint16BE = re.prototype.writeUInt16BE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 2, 65535, 0), this[Bt] = At >>> 8, this[Bt + 1] = At & 255, Bt + 2;
  }, re.prototype.writeUint32LE = re.prototype.writeUInt32LE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 4, 4294967295, 0), this[Bt + 3] = At >>> 24, this[Bt + 2] = At >>> 16, this[Bt + 1] = At >>> 8, this[Bt] = At & 255, Bt + 4;
  }, re.prototype.writeUint32BE = re.prototype.writeUInt32BE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 4, 4294967295, 0), this[Bt] = At >>> 24, this[Bt + 1] = At >>> 16, this[Bt + 2] = At >>> 8, this[Bt + 3] = At & 255, Bt + 4;
  };
  function Lt(Ot, At, Bt, Ut, Xt) {
    ar(At, Ut, Xt, Ot, Bt, 7);
    let Zt = Number(At & BigInt(4294967295));
    Ot[Bt++] = Zt, Zt = Zt >> 8, Ot[Bt++] = Zt, Zt = Zt >> 8, Ot[Bt++] = Zt, Zt = Zt >> 8, Ot[Bt++] = Zt;
    let tr = Number(At >> BigInt(32) & BigInt(4294967295));
    return Ot[Bt++] = tr, tr = tr >> 8, Ot[Bt++] = tr, tr = tr >> 8, Ot[Bt++] = tr, tr = tr >> 8, Ot[Bt++] = tr, Bt;
  }
  function Rt(Ot, At, Bt, Ut, Xt) {
    ar(At, Ut, Xt, Ot, Bt, 7);
    let Zt = Number(At & BigInt(4294967295));
    Ot[Bt + 7] = Zt, Zt = Zt >> 8, Ot[Bt + 6] = Zt, Zt = Zt >> 8, Ot[Bt + 5] = Zt, Zt = Zt >> 8, Ot[Bt + 4] = Zt;
    let tr = Number(At >> BigInt(32) & BigInt(4294967295));
    return Ot[Bt + 3] = tr, tr = tr >> 8, Ot[Bt + 2] = tr, tr = tr >> 8, Ot[Bt + 1] = tr, tr = tr >> 8, Ot[Bt] = tr, Bt + 8;
  }
  re.prototype.writeBigUInt64LE = Rr(function(At, Bt = 0) {
    return Lt(this, At, Bt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), re.prototype.writeBigUInt64BE = Rr(function(At, Bt = 0) {
    return Rt(this, At, Bt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), re.prototype.writeIntLE = function(At, Bt, Ut, Xt) {
    if (At = +At, Bt = Bt >>> 0, !Xt) {
      const Br = Math.pow(2, 8 * Ut - 1);
      Jt(this, At, Bt, Ut, Br - 1, -Br);
    }
    let Zt = 0, tr = 1, vr = 0;
    for (this[Bt] = At & 255; ++Zt < Ut && (tr *= 256); )
      At < 0 && vr === 0 && this[Bt + Zt - 1] !== 0 && (vr = 1), this[Bt + Zt] = (At / tr >> 0) - vr & 255;
    return Bt + Ut;
  }, re.prototype.writeIntBE = function(At, Bt, Ut, Xt) {
    if (At = +At, Bt = Bt >>> 0, !Xt) {
      const Br = Math.pow(2, 8 * Ut - 1);
      Jt(this, At, Bt, Ut, Br - 1, -Br);
    }
    let Zt = Ut - 1, tr = 1, vr = 0;
    for (this[Bt + Zt] = At & 255; --Zt >= 0 && (tr *= 256); )
      At < 0 && vr === 0 && this[Bt + Zt + 1] !== 0 && (vr = 1), this[Bt + Zt] = (At / tr >> 0) - vr & 255;
    return Bt + Ut;
  }, re.prototype.writeInt8 = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 1, 127, -128), At < 0 && (At = 255 + At + 1), this[Bt] = At & 255, Bt + 1;
  }, re.prototype.writeInt16LE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 2, 32767, -32768), this[Bt] = At & 255, this[Bt + 1] = At >>> 8, Bt + 2;
  }, re.prototype.writeInt16BE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 2, 32767, -32768), this[Bt] = At >>> 8, this[Bt + 1] = At & 255, Bt + 2;
  }, re.prototype.writeInt32LE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 4, 2147483647, -2147483648), this[Bt] = At & 255, this[Bt + 1] = At >>> 8, this[Bt + 2] = At >>> 16, this[Bt + 3] = At >>> 24, Bt + 4;
  }, re.prototype.writeInt32BE = function(At, Bt, Ut) {
    return At = +At, Bt = Bt >>> 0, Ut || Jt(this, At, Bt, 4, 2147483647, -2147483648), At < 0 && (At = 4294967295 + At + 1), this[Bt] = At >>> 24, this[Bt + 1] = At >>> 16, this[Bt + 2] = At >>> 8, this[Bt + 3] = At & 255, Bt + 4;
  }, re.prototype.writeBigInt64LE = Rr(function(At, Bt = 0) {
    return Lt(this, At, Bt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), re.prototype.writeBigInt64BE = Rr(function(At, Bt = 0) {
    return Rt(this, At, Bt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Mt(Ot, At, Bt, Ut, Xt, Zt) {
    if (Bt + Ut > Ot.length) throw new RangeError("Index out of range");
    if (Bt < 0) throw new RangeError("Index out of range");
  }
  function Kt(Ot, At, Bt, Ut, Xt) {
    return At = +At, Bt = Bt >>> 0, Xt || Mt(Ot, At, Bt, 4), L.write(Ot, At, Bt, Ut, 23, 4), Bt + 4;
  }
  re.prototype.writeFloatLE = function(At, Bt, Ut) {
    return Kt(this, At, Bt, !0, Ut);
  }, re.prototype.writeFloatBE = function(At, Bt, Ut) {
    return Kt(this, At, Bt, !1, Ut);
  };
  function zt(Ot, At, Bt, Ut, Xt) {
    return At = +At, Bt = Bt >>> 0, Xt || Mt(Ot, At, Bt, 8), L.write(Ot, At, Bt, Ut, 52, 8), Bt + 8;
  }
  re.prototype.writeDoubleLE = function(At, Bt, Ut) {
    return zt(this, At, Bt, !0, Ut);
  }, re.prototype.writeDoubleBE = function(At, Bt, Ut) {
    return zt(this, At, Bt, !1, Ut);
  }, re.prototype.copy = function(At, Bt, Ut, Xt) {
    if (!re.isBuffer(At)) throw new TypeError("argument should be a Buffer");
    if (Ut || (Ut = 0), !Xt && Xt !== 0 && (Xt = this.length), Bt >= At.length && (Bt = At.length), Bt || (Bt = 0), Xt > 0 && Xt < Ut && (Xt = Ut), Xt === Ut || At.length === 0 || this.length === 0) return 0;
    if (Bt < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ut < 0 || Ut >= this.length) throw new RangeError("Index out of range");
    if (Xt < 0) throw new RangeError("sourceEnd out of bounds");
    Xt > this.length && (Xt = this.length), At.length - Bt < Xt - Ut && (Xt = At.length - Bt + Ut);
    const Zt = Xt - Ut;
    return this === At && typeof W.prototype.copyWithin == "function" ? this.copyWithin(Bt, Ut, Xt) : W.prototype.set.call(
      At,
      this.subarray(Ut, Xt),
      Bt
    ), Zt;
  }, re.prototype.fill = function(At, Bt, Ut, Xt) {
    if (typeof At == "string") {
      if (typeof Bt == "string" ? (Xt = Bt, Bt = 0, Ut = this.length) : typeof Ut == "string" && (Xt = Ut, Ut = this.length), Xt !== void 0 && typeof Xt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Xt == "string" && !re.isEncoding(Xt))
        throw new TypeError("Unknown encoding: " + Xt);
      if (At.length === 1) {
        const tr = At.charCodeAt(0);
        (Xt === "utf8" && tr < 128 || Xt === "latin1") && (At = tr);
      }
    } else typeof At == "number" ? At = At & 255 : typeof At == "boolean" && (At = Number(At));
    if (Bt < 0 || this.length < Bt || this.length < Ut)
      throw new RangeError("Out of range index");
    if (Ut <= Bt)
      return this;
    Bt = Bt >>> 0, Ut = Ut === void 0 ? this.length : Ut >>> 0, At || (At = 0);
    let Zt;
    if (typeof At == "number")
      for (Zt = Bt; Zt < Ut; ++Zt)
        this[Zt] = At;
    else {
      const tr = re.isBuffer(At) ? At : re.from(At, Xt), vr = tr.length;
      if (vr === 0)
        throw new TypeError('The value "' + At + '" is invalid for argument "value"');
      for (Zt = 0; Zt < Ut - Bt; ++Zt)
        this[Zt + Bt] = tr[Zt % vr];
    }
    return this;
  };
  const Ct = {};
  function kt(Ot, At, Bt) {
    Ct[Ot] = class extends Bt {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: At.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Ot}]`, this.stack, delete this.name;
      }
      get code() {
        return Ot;
      }
      set code(Xt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Xt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Ot}]: ${this.message}`;
      }
    };
  }
  kt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Ot) {
      return Ot ? `${Ot} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), kt(
    "ERR_INVALID_ARG_TYPE",
    function(Ot, At) {
      return `The "${Ot}" argument must be of type number. Received type ${typeof At}`;
    },
    TypeError
  ), kt(
    "ERR_OUT_OF_RANGE",
    function(Ot, At, Bt) {
      let Ut = `The value of "${Ot}" is out of range.`, Xt = Bt;
      return Number.isInteger(Bt) && Math.abs(Bt) > 2 ** 32 ? Xt = Vt(String(Bt)) : typeof Bt == "bigint" && (Xt = String(Bt), (Bt > BigInt(2) ** BigInt(32) || Bt < -(BigInt(2) ** BigInt(32))) && (Xt = Vt(Xt)), Xt += "n"), Ut += ` It must be ${At}. Received ${Xt}`, Ut;
    },
    RangeError
  );
  function Vt(Ot) {
    let At = "", Bt = Ot.length;
    const Ut = Ot[0] === "-" ? 1 : 0;
    for (; Bt >= Ut + 4; Bt -= 3)
      At = `_${Ot.slice(Bt - 3, Bt)}${At}`;
    return `${Ot.slice(0, Bt)}${At}`;
  }
  function nr(Ot, At, Bt) {
    sr(At, "offset"), (Ot[At] === void 0 || Ot[At + Bt] === void 0) && lr(At, Ot.length - (Bt + 1));
  }
  function ar(Ot, At, Bt, Ut, Xt, Zt) {
    if (Ot > Bt || Ot < At) {
      const tr = typeof At == "bigint" ? "n" : "";
      let vr;
      throw At === 0 || At === BigInt(0) ? vr = `>= 0${tr} and < 2${tr} ** ${(Zt + 1) * 8}${tr}` : vr = `>= -(2${tr} ** ${(Zt + 1) * 8 - 1}${tr}) and < 2 ** ${(Zt + 1) * 8 - 1}${tr}`, new Ct.ERR_OUT_OF_RANGE("value", vr, Ot);
    }
    nr(Ut, Xt, Zt);
  }
  function sr(Ot, At) {
    if (typeof Ot != "number")
      throw new Ct.ERR_INVALID_ARG_TYPE(At, "number", Ot);
  }
  function lr(Ot, At, Bt) {
    throw Math.floor(Ot) !== Ot ? (sr(Ot, Bt), new Ct.ERR_OUT_OF_RANGE("offset", "an integer", Ot)) : At < 0 ? new Ct.ERR_BUFFER_OUT_OF_BOUNDS() : new Ct.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${At}`,
      Ot
    );
  }
  const dr = /[^+/0-9A-Za-z-_]/g;
  function rr(Ot) {
    if (Ot = Ot.split("=")[0], Ot = Ot.trim().replace(dr, ""), Ot.length < 2) return "";
    for (; Ot.length % 4 !== 0; )
      Ot = Ot + "=";
    return Ot;
  }
  function Pr(Ot, At) {
    At = At || 1 / 0;
    let Bt;
    const Ut = Ot.length;
    let Xt = null;
    const Zt = [];
    for (let tr = 0; tr < Ut; ++tr) {
      if (Bt = Ot.charCodeAt(tr), Bt > 55295 && Bt < 57344) {
        if (!Xt) {
          if (Bt > 56319) {
            (At -= 3) > -1 && Zt.push(239, 191, 189);
            continue;
          } else if (tr + 1 === Ut) {
            (At -= 3) > -1 && Zt.push(239, 191, 189);
            continue;
          }
          Xt = Bt;
          continue;
        }
        if (Bt < 56320) {
          (At -= 3) > -1 && Zt.push(239, 191, 189), Xt = Bt;
          continue;
        }
        Bt = (Xt - 55296 << 10 | Bt - 56320) + 65536;
      } else Xt && (At -= 3) > -1 && Zt.push(239, 191, 189);
      if (Xt = null, Bt < 128) {
        if ((At -= 1) < 0) break;
        Zt.push(Bt);
      } else if (Bt < 2048) {
        if ((At -= 2) < 0) break;
        Zt.push(
          Bt >> 6 | 192,
          Bt & 63 | 128
        );
      } else if (Bt < 65536) {
        if ((At -= 3) < 0) break;
        Zt.push(
          Bt >> 12 | 224,
          Bt >> 6 & 63 | 128,
          Bt & 63 | 128
        );
      } else if (Bt < 1114112) {
        if ((At -= 4) < 0) break;
        Zt.push(
          Bt >> 18 | 240,
          Bt >> 12 & 63 | 128,
          Bt >> 6 & 63 | 128,
          Bt & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Zt;
  }
  function ur(Ot) {
    const At = [];
    for (let Bt = 0; Bt < Ot.length; ++Bt)
      At.push(Ot.charCodeAt(Bt) & 255);
    return At;
  }
  function pr(Ot, At) {
    let Bt, Ut, Xt;
    const Zt = [];
    for (let tr = 0; tr < Ot.length && !((At -= 2) < 0); ++tr)
      Bt = Ot.charCodeAt(tr), Ut = Bt >> 8, Xt = Bt % 256, Zt.push(Xt), Zt.push(Ut);
    return Zt;
  }
  function br(Ot) {
    return B.toByteArray(rr(Ot));
  }
  function hr(Ot, At, Bt, Ut) {
    let Xt;
    for (Xt = 0; Xt < Ut && !(Xt + Bt >= At.length || Xt >= Ot.length); ++Xt)
      At[Xt + Bt] = Ot[Xt];
    return Xt;
  }
  function xr(Ot, At) {
    return Ot instanceof At || Ot != null && Ot.constructor != null && Ot.constructor.name != null && Ot.constructor.name === At.name;
  }
  function Mr(Ot) {
    return Ot !== Ot;
  }
  const _r = function() {
    const Ot = "0123456789abcdef", At = new Array(256);
    for (let Bt = 0; Bt < 16; ++Bt) {
      const Ut = Bt * 16;
      for (let Xt = 0; Xt < 16; ++Xt)
        At[Ut + Xt] = Ot[Bt] + Ot[Xt];
    }
    return At;
  }();
  function Rr(Ot) {
    return typeof BigInt > "u" ? kr : Ot;
  }
  function kr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$2 = buffer$1.Buffer;
var store2;
function getGlobalMessage(A) {
  return store2 == null ? void 0 : store2.get(A);
}
var store3;
function getSchemaMessage(A) {
  return store3 == null ? void 0 : store3.get(A);
}
var store4;
function getSpecificMessage(A, B) {
  var L;
  return (L = store4 == null ? void 0 : store4.get(A)) == null ? void 0 : L.get(B);
}
function _stringify(A) {
  var L, K;
  const B = typeof A;
  return B === "string" ? `"${A}"` : B === "number" || B === "bigint" || B === "boolean" ? `${A}` : B === "object" || B === "function" ? (A && ((K = (L = Object.getPrototypeOf(A)) == null ? void 0 : L.constructor) == null ? void 0 : K.name)) ?? "null" : B;
}
function _addIssue(A, B, L, K, V) {
  const W = V && "input" in V ? V.input : L.value, J = (V == null ? void 0 : V.expected) ?? A.expects ?? null, ne = (V == null ? void 0 : V.received) ?? _stringify(W), ie = {
    kind: A.kind,
    type: A.type,
    input: W,
    expected: J,
    received: ne,
    message: `Invalid ${B}: ${J ? `Expected ${J} but r` : "R"}eceived ${ne}`,
    requirement: A.requirement,
    path: V == null ? void 0 : V.path,
    issues: V == null ? void 0 : V.issues,
    lang: K.lang,
    abortEarly: K.abortEarly,
    abortPipeEarly: K.abortPipeEarly
  }, ce = A.kind === "schema", re = (V == null ? void 0 : V.message) ?? A.message ?? getSpecificMessage(A.reference, ie.lang) ?? (ce ? getSchemaMessage(ie.lang) : null) ?? K.message ?? getGlobalMessage(ie.lang);
  re && (ie.message = typeof re == "function" ? (
    // @ts-expect-error
    re(ie)
  ) : re), ce && (L.typed = !1), L.issues ? L.issues.push(ie) : L.issues = [ie];
}
function _isValidObjectKey(A, B) {
  return Object.hasOwn(A, B) && B !== "__proto__" && B !== "prototype" && B !== "constructor";
}
function _joinExpects(A, B) {
  const L = [...new Set(A)];
  return L.length > 1 ? `(${L.join(` ${B} `)})` : L[0] ?? "never";
}
function check$e(A, B) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: A,
    message: B,
    _run(L, K) {
      return L.typed && !this.requirement(L.value) && _addIssue(this, "input", L, K), L;
    }
  };
}
function maxLength(A, B) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${A}`,
    requirement: A,
    message: B,
    _run(L, K) {
      return L.typed && L.value.length > this.requirement && _addIssue(this, "length", L, K, {
        received: `${L.value.length}`
      }), L;
    }
  };
}
function minLength(A, B) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${A}`,
    requirement: A,
    message: B,
    _run(L, K) {
      return L.typed && L.value.length < this.requirement && _addIssue(this, "length", L, K, {
        received: `${L.value.length}`
      }), L;
    }
  };
}
function getDefault(A, B, L) {
  return typeof A.default == "function" ? (
    // @ts-expect-error
    A.default(B, L)
  ) : (
    // @ts-expect-error
    A.default
  );
}
function array(A, B) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: A,
    message: B,
    _run(L, K) {
      var W;
      const V = L.value;
      if (Array.isArray(V)) {
        L.typed = !0, L.value = [];
        for (let J = 0; J < V.length; J++) {
          const ne = V[J], ie = this.item._run({ typed: !1, value: ne }, K);
          if (ie.issues) {
            const ce = {
              type: "array",
              origin: "value",
              input: V,
              key: J,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(ce) : re.path = [ce], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), L.value.push(ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function boolean(A) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "boolean" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function enum_(A, B) {
  const L = Object.entries(A).filter(([K]) => isNaN(+K)).map(([, K]) => K);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(L.map(_stringify), "|"),
    async: !1,
    enum: A,
    options: L,
    message: B,
    _run(K, V) {
      return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, V), K;
    }
  };
}
function literal(A, B) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(A),
    async: !1,
    literal: A,
    message: B,
    _run(L, K) {
      return L.value === this.literal ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function looseObject(A, B) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const V = L.value;
      if (V && typeof V == "object") {
        L.typed = !0, L.value = {};
        for (const J in this.entries) {
          const ne = V[J], ie = this.entries[J]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const ce = {
              type: "object",
              origin: "value",
              input: V,
              key: J,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(ce) : re.path = [ce], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || J in V) && (L.value[J] = ie.value);
        }
        if (!L.issues || !K.abortEarly)
          for (const J in V)
            _isValidObjectKey(V, J) && !(J in this.entries) && (L.value[J] = V[J]);
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function nonOptional(A, B) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: A,
    message: B,
    _run(L, K) {
      return L.value === void 0 ? (_addIssue(this, "type", L, K), L) : this.wrapped._run(L, K);
    }
  };
}
function null_(A) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === null ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function nullish(A, ...B) {
  const L = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${A.expects} | null | undefined)`,
    async: !1,
    wrapped: A,
    _run(K, V) {
      return (K.value === null || K.value === void 0) && ("default" in this && (K.value = getDefault(
        this,
        K,
        V
      )), K.value === null || K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, V);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function number(A) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "number" && !isNaN(B.value) ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function object(A, B) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const V = L.value;
      if (V && typeof V == "object") {
        L.typed = !0, L.value = {};
        for (const J in this.entries) {
          const ne = V[J], ie = this.entries[J]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const ce = {
              type: "object",
              origin: "value",
              input: V,
              key: J,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(ce) : re.path = [ce], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || J in V) && (L.value[J] = ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function optional(A, ...B) {
  const L = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${A.expects} | undefined)`,
    async: !1,
    wrapped: A,
    _run(K, V) {
      return K.value === void 0 && ("default" in this && (K.value = getDefault(
        this,
        K,
        V
      )), K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, V);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function picklist(A, B) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(A.map(_stringify), "|"),
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      return this.options.includes(L.value) ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function record(A, B, L) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: A,
    value: B,
    message: L,
    _run(K, V) {
      var J, ne;
      const W = K.value;
      if (W && typeof W == "object") {
        K.typed = !0, K.value = {};
        for (const ie in W)
          if (_isValidObjectKey(W, ie)) {
            const ce = W[ie], re = this.key._run(
              { typed: !1, value: ie },
              V
            );
            if (re.issues) {
              const ke = {
                type: "object",
                origin: "key",
                input: W,
                key: ie,
                value: ce
              };
              for (const Ce of re.issues)
                Ce.path = [ke], (J = K.issues) == null || J.push(Ce);
              if (K.issues || (K.issues = re.issues), V.abortEarly) {
                K.typed = !1;
                break;
              }
            }
            const oe = this.value._run(
              { typed: !1, value: ce },
              V
            );
            if (oe.issues) {
              const ke = {
                type: "object",
                origin: "value",
                input: W,
                key: ie,
                value: ce
              };
              for (const Ce of oe.issues)
                Ce.path ? Ce.path.unshift(ke) : Ce.path = [ke], (ne = K.issues) == null || ne.push(Ce);
              if (K.issues || (K.issues = oe.issues), V.abortEarly) {
                K.typed = !1;
                break;
              }
            }
            (!re.typed || !oe.typed) && (K.typed = !1), re.typed && (K.value[re.value] = oe.value);
          }
      } else
        _addIssue(this, "type", K, V);
      return K;
    }
  };
}
function string(A) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "string" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function _subIssues(A) {
  let B;
  if (A)
    for (const L of A)
      B ? B.push(...L.issues) : B = L.issues;
  return B;
}
function union(A, B) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      A.map((L) => L.expects),
      "|"
    ),
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      let V, W, J;
      for (const ne of this.options) {
        const ie = ne._run(
          { typed: !1, value: L.value },
          K
        );
        if (ie.typed)
          if (ie.issues)
            W ? W.push(ie) : W = [ie];
          else {
            V = ie;
            break;
          }
        else
          J ? J.push(ie) : J = [ie];
      }
      if (V)
        return V;
      if (W) {
        if (W.length === 1)
          return W[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(W)
        }), L.typed = !0;
      } else {
        if ((J == null ? void 0 : J.length) === 1)
          return J[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(J)
        });
      }
      return L;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(A) {
      return A.typed = !0, A;
    }
  };
}
function variant(A, B, L) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: A,
    options: B,
    message: L,
    _run(K, V) {
      const W = K.value;
      if (W && typeof W == "object") {
        let J, ne = 0, ie = this.key, ce = [];
        const re = (oe, ke) => {
          for (const Ce of oe.options) {
            if (Ce.type === "variant")
              re(Ce, new Set(ke).add(Ce.key));
            else {
              let it = !0, at = 0;
              for (const ct of ke) {
                if (Ce.entries[ct]._run(
                  // @ts-expect-error
                  { typed: !1, value: W[ct] },
                  V
                ).issues) {
                  it = !1, ie !== ct && (ne < at || ne === at && ct in W && !(ie in W)) && (ne = at, ie = ct, ce = []), ie === ct && ce.push(
                    Ce.entries[ct].expects
                  );
                  break;
                }
                at++;
              }
              if (it) {
                const ct = Ce._run(
                  { typed: !1, value: W },
                  V
                );
                (!J || !J.typed && ct.typed) && (J = ct);
              }
            }
            if (J && !J.issues)
              break;
          }
        };
        if (re(this, /* @__PURE__ */ new Set([this.key])), J)
          return J;
        _addIssue(this, "type", K, V, {
          // @ts-expect-error
          input: W[ie],
          expected: _joinExpects(ce, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: W,
              key: ie,
              // @ts-expect-error
              value: W[ie]
            }
          ]
        });
      } else
        _addIssue(this, "type", K, V);
      return K;
    }
  };
}
function omit(A, B) {
  const L = {
    ...A.entries
  };
  for (const K of B)
    delete L[K];
  return { ...A, entries: L };
}
function pipe(...A) {
  return {
    ...A[0],
    pipe: A,
    _run(B, L) {
      for (const K of A)
        if (K.kind !== "metadata") {
          if (B.issues && (K.kind === "schema" || K.kind === "transformation")) {
            B.typed = !1;
            break;
          }
          (!B.issues || !L.abortEarly && !L.abortPipeEarly) && (B = K._run(B, L));
        }
      return B;
    }
  };
}
function unwrap(A) {
  return A.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength(A) {
  var B = getLens(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray(A) {
  var B, L = getLens(A), K = L[0], V = L[1], W = new Arr(_byteLength(A, K, V)), J = 0, ne = V > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup[A.charCodeAt(ie)] << 18 | revLookup[A.charCodeAt(ie + 1)] << 12 | revLookup[A.charCodeAt(ie + 2)] << 6 | revLookup[A.charCodeAt(ie + 3)], W[J++] = B >> 16 & 255, W[J++] = B >> 8 & 255, W[J++] = B & 255;
  return V === 2 && (B = revLookup[A.charCodeAt(ie)] << 2 | revLookup[A.charCodeAt(ie + 1)] >> 4, W[J++] = B & 255), V === 1 && (B = revLookup[A.charCodeAt(ie)] << 10 | revLookup[A.charCodeAt(ie + 1)] << 4 | revLookup[A.charCodeAt(ie + 2)] >> 2, W[J++] = B >> 8 & 255, W[J++] = B & 255), W;
}
function tripletToBase64(A) {
  return lookup[A >> 18 & 63] + lookup[A >> 12 & 63] + lookup[A >> 6 & 63] + lookup[A & 63];
}
function encodeChunk(A, B, L) {
  for (var K, V = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), V.push(tripletToBase64(K));
  return V.join("");
}
function fromByteArray(A) {
  for (var B, L = A.length, K = L % 3, V = [], W = 16383, J = 0, ne = L - K; J < ne; J += W)
    V.push(encodeChunk(A, J, J + W > ne ? ne : J + W));
  return K === 1 ? (B = A[L - 1], V.push(
    lookup[B >> 2] + lookup[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], V.push(
    lookup[B >> 10] + lookup[B >> 4 & 63] + lookup[B << 2 & 63] + "="
  )), V.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(A) {
  return `${A}${"=".repeat(4 - (A.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(A) {
  return A.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(A) {
  return pad(A).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(A) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(A)));
}
base64Url.encode = encode$j;
function decode$j(A) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(A))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(A) {
  if (!Number.isSafeInteger(A) || A < 0)
    throw new Error("positive integer expected, got " + A);
}
function isBytes(A) {
  return A instanceof Uint8Array || ArrayBuffer.isView(A) && A.constructor.name === "Uint8Array";
}
function abytes(A, ...B) {
  if (!isBytes(A))
    throw new Error("Uint8Array expected");
  if (B.length > 0 && !B.includes(A.length))
    throw new Error("Uint8Array expected of length " + B + ", got length=" + A.length);
}
function ahash(A) {
  if (typeof A != "function" || typeof A.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(A.outputLen), anumber(A.blockLen);
}
function aexists(A, B = !0) {
  if (A.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (B && A.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(A, B) {
  abytes(A);
  const L = B.outputLen;
  if (A.length < L)
    throw new Error("digestInto() expects output buffer of length at least " + L);
}
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(A) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.Hash = A.nextTick = A.byteSwapIfBE = A.isLE = void 0, A.isBytes = K, A.u8 = V, A.u32 = W, A.createView = J, A.rotr = ne, A.rotl = ie, A.byteSwap = ce, A.byteSwap32 = re, A.bytesToHex = ke, A.hexToBytes = at, A.asyncLoop = dt, A.utf8ToBytes = ot, A.toBytes = yt, A.concatBytes = mt, A.checkOpts = Pt, A.wrapConstructor = Nt, A.wrapConstructorWithOpts = St, A.wrapXOFConstructorWithOpts = vt, A.randomBytes = It;
  const B = crypto$2, L = _assert;
  function K(wt) {
    return wt instanceof Uint8Array || ArrayBuffer.isView(wt) && wt.constructor.name === "Uint8Array";
  }
  function V(wt) {
    return new Uint8Array(wt.buffer, wt.byteOffset, wt.byteLength);
  }
  function W(wt) {
    return new Uint32Array(wt.buffer, wt.byteOffset, Math.floor(wt.byteLength / 4));
  }
  function J(wt) {
    return new DataView(wt.buffer, wt.byteOffset, wt.byteLength);
  }
  function ne(wt, Oe) {
    return wt << 32 - Oe | wt >>> Oe;
  }
  function ie(wt, Oe) {
    return wt << Oe | wt >>> 32 - Oe >>> 0;
  }
  A.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function ce(wt) {
    return wt << 24 & 4278190080 | wt << 8 & 16711680 | wt >>> 8 & 65280 | wt >>> 24 & 255;
  }
  A.byteSwapIfBE = A.isLE ? (wt) => wt : (wt) => ce(wt);
  function re(wt) {
    for (let Oe = 0; Oe < wt.length; Oe++)
      wt[Oe] = ce(wt[Oe]);
  }
  const oe = /* @__PURE__ */ Array.from({ length: 256 }, (wt, Oe) => Oe.toString(16).padStart(2, "0"));
  function ke(wt) {
    (0, L.abytes)(wt);
    let Oe = "";
    for (let rt = 0; rt < wt.length; rt++)
      Oe += oe[wt[rt]];
    return Oe;
  }
  const Ce = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function it(wt) {
    if (wt >= Ce._0 && wt <= Ce._9)
      return wt - Ce._0;
    if (wt >= Ce.A && wt <= Ce.F)
      return wt - (Ce.A - 10);
    if (wt >= Ce.a && wt <= Ce.f)
      return wt - (Ce.a - 10);
  }
  function at(wt) {
    if (typeof wt != "string")
      throw new Error("hex string expected, got " + typeof wt);
    const Oe = wt.length, rt = Oe / 2;
    if (Oe % 2)
      throw new Error("hex string expected, got unpadded hex of length " + Oe);
    const pe = new Uint8Array(rt);
    for (let nt = 0, st = 0; nt < rt; nt++, st += 2) {
      const ft = it(wt.charCodeAt(st)), ht = it(wt.charCodeAt(st + 1));
      if (ft === void 0 || ht === void 0) {
        const bt = wt[st] + wt[st + 1];
        throw new Error('hex string expected, got non-hex character "' + bt + '" at index ' + st);
      }
      pe[nt] = ft * 16 + ht;
    }
    return pe;
  }
  const ct = async () => {
  };
  A.nextTick = ct;
  async function dt(wt, Oe, rt) {
    let pe = Date.now();
    for (let nt = 0; nt < wt; nt++) {
      rt(nt);
      const st = Date.now() - pe;
      st >= 0 && st < Oe || (await (0, A.nextTick)(), pe += st);
    }
  }
  function ot(wt) {
    if (typeof wt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof wt);
    return new Uint8Array(new TextEncoder().encode(wt));
  }
  function yt(wt) {
    return typeof wt == "string" && (wt = ot(wt)), (0, L.abytes)(wt), wt;
  }
  function mt(...wt) {
    let Oe = 0;
    for (let pe = 0; pe < wt.length; pe++) {
      const nt = wt[pe];
      (0, L.abytes)(nt), Oe += nt.length;
    }
    const rt = new Uint8Array(Oe);
    for (let pe = 0, nt = 0; pe < wt.length; pe++) {
      const st = wt[pe];
      rt.set(st, nt), nt += st.length;
    }
    return rt;
  }
  class Tt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  A.Hash = Tt;
  function Pt(wt, Oe) {
    if (Oe !== void 0 && {}.toString.call(Oe) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(wt, Oe);
  }
  function Nt(wt) {
    const Oe = (pe) => wt().update(yt(pe)).digest(), rt = wt();
    return Oe.outputLen = rt.outputLen, Oe.blockLen = rt.blockLen, Oe.create = () => wt(), Oe;
  }
  function St(wt) {
    const Oe = (pe, nt) => wt(nt).update(yt(pe)).digest(), rt = wt({});
    return Oe.outputLen = rt.outputLen, Oe.blockLen = rt.blockLen, Oe.create = (pe) => wt(pe), Oe;
  }
  function vt(wt) {
    const Oe = (pe, nt) => wt(nt).update(yt(pe)).digest(), rt = wt({});
    return Oe.outputLen = rt.outputLen, Oe.blockLen = rt.blockLen, Oe.create = (pe) => wt(pe), Oe;
  }
  function It(wt = 32) {
    if (B.crypto && typeof B.crypto.getRandomValues == "function")
      return B.crypto.getRandomValues(new Uint8Array(wt));
    if (B.crypto && typeof B.crypto.randomBytes == "function")
      return B.crypto.randomBytes(wt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.hmac = A.HMAC = void 0;
  const B = _assert, L = utils$5;
  class K extends L.Hash {
    constructor(J, ne) {
      super(), this.finished = !1, this.destroyed = !1, (0, B.ahash)(J);
      const ie = (0, L.toBytes)(ne);
      if (this.iHash = J.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ce = this.blockLen, re = new Uint8Array(ce);
      re.set(ie.length > ce ? J.create().update(ie).digest() : ie);
      for (let oe = 0; oe < re.length; oe++)
        re[oe] ^= 54;
      this.iHash.update(re), this.oHash = J.create();
      for (let oe = 0; oe < re.length; oe++)
        re[oe] ^= 106;
      this.oHash.update(re), re.fill(0);
    }
    update(J) {
      return (0, B.aexists)(this), this.iHash.update(J), this;
    }
    digestInto(J) {
      (0, B.aexists)(this), (0, B.abytes)(J, this.outputLen), this.finished = !0, this.iHash.digestInto(J), this.oHash.update(J), this.oHash.digestInto(J), this.destroy();
    }
    digest() {
      const J = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(J), J;
    }
    _cloneInto(J) {
      J || (J = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ne, iHash: ie, finished: ce, destroyed: re, blockLen: oe, outputLen: ke } = this;
      return J = J, J.finished = ce, J.destroyed = re, J.blockLen = oe, J.outputLen = ke, J.oHash = ne._cloneInto(J.oHash), J.iHash = ie._cloneInto(J.iHash), J;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  A.HMAC = K;
  const V = (W, J, ne) => new K(W, J).update(ne).digest();
  A.hmac = V, A.hmac.create = (W, J) => new K(W, J);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(A, B, L, K) {
  if (typeof A.setBigUint64 == "function")
    return A.setBigUint64(B, L, K);
  const V = BigInt(32), W = BigInt(4294967295), J = Number(L >> V & W), ne = Number(L & W), ie = K ? 4 : 0, ce = K ? 0 : 4;
  A.setUint32(B + ie, J, K), A.setUint32(B + ce, ne, K);
}
function Chi(A, B, L) {
  return A & B ^ ~A & L;
}
function Maj(A, B, L) {
  return A & B ^ A & L ^ B & L;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(B, L, K, V) {
    super(), this.blockLen = B, this.outputLen = L, this.padOffset = K, this.isLE = V, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(B), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(B) {
    (0, _assert_js_1.aexists)(this);
    const { view: L, buffer: K, blockLen: V } = this;
    B = (0, utils_js_1$3.toBytes)(B);
    const W = B.length;
    for (let J = 0; J < W; ) {
      const ne = Math.min(V - this.pos, W - J);
      if (ne === V) {
        const ie = (0, utils_js_1$3.createView)(B);
        for (; V <= W - J; J += V)
          this.process(ie, J);
        continue;
      }
      K.set(B.subarray(J, J + ne), this.pos), this.pos += ne, J += ne, this.pos === V && (this.process(L, 0), this.pos = 0);
    }
    return this.length += B.length, this.roundClean(), this;
  }
  digestInto(B) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(B, this), this.finished = !0;
    const { buffer: L, view: K, blockLen: V, isLE: W } = this;
    let { pos: J } = this;
    L[J++] = 128, this.buffer.subarray(J).fill(0), this.padOffset > V - J && (this.process(K, 0), J = 0);
    for (let oe = J; oe < V; oe++)
      L[oe] = 0;
    setBigUint64(K, V - 8, BigInt(this.length * 8), W), this.process(K, 0);
    const ne = (0, utils_js_1$3.createView)(B), ie = this.outputLen;
    if (ie % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ce = ie / 4, re = this.get();
    if (ce > re.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let oe = 0; oe < ce; oe++)
      ne.setUint32(4 * oe, re[oe], W);
  }
  digest() {
    const { buffer: B, outputLen: L } = this;
    this.digestInto(B);
    const K = B.slice(0, L);
    return this.destroy(), K;
  }
  _cloneInto(B) {
    B || (B = new this.constructor()), B.set(...this.get());
    const { blockLen: L, buffer: K, length: V, finished: W, destroyed: J, pos: ne } = this;
    return B.length = V, B.pos = ne, B.finished = W, B.destroyed = J, V % L && B.buffer.set(K), B;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: V, E: W, F: J, G: ne, H: ie } = this;
    return [B, L, K, V, W, J, ne, ie];
  }
  // prettier-ignore
  set(B, L, K, V, W, J, ne, ie) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = V | 0, this.E = W | 0, this.F = J | 0, this.G = ne | 0, this.H = ie | 0;
  }
  process(B, L) {
    for (let oe = 0; oe < 16; oe++, L += 4)
      SHA256_W[oe] = B.getUint32(L, !1);
    for (let oe = 16; oe < 64; oe++) {
      const ke = SHA256_W[oe - 15], Ce = SHA256_W[oe - 2], it = (0, utils_js_1$2.rotr)(ke, 7) ^ (0, utils_js_1$2.rotr)(ke, 18) ^ ke >>> 3, at = (0, utils_js_1$2.rotr)(Ce, 17) ^ (0, utils_js_1$2.rotr)(Ce, 19) ^ Ce >>> 10;
      SHA256_W[oe] = at + SHA256_W[oe - 7] + it + SHA256_W[oe - 16] | 0;
    }
    let { A: K, B: V, C: W, D: J, E: ne, F: ie, G: ce, H: re } = this;
    for (let oe = 0; oe < 64; oe++) {
      const ke = (0, utils_js_1$2.rotr)(ne, 6) ^ (0, utils_js_1$2.rotr)(ne, 11) ^ (0, utils_js_1$2.rotr)(ne, 25), Ce = re + ke + (0, _md_js_1$2.Chi)(ne, ie, ce) + SHA256_K[oe] + SHA256_W[oe] | 0, at = ((0, utils_js_1$2.rotr)(K, 2) ^ (0, utils_js_1$2.rotr)(K, 13) ^ (0, utils_js_1$2.rotr)(K, 22)) + (0, _md_js_1$2.Maj)(K, V, W) | 0;
      re = ce, ce = ie, ie = ne, ne = J + Ce | 0, J = W, W = V, V = K, K = Ce + at | 0;
    }
    K = K + this.A | 0, V = V + this.B | 0, W = W + this.C | 0, J = J + this.D | 0, ne = ne + this.E | 0, ie = ie + this.F | 0, ce = ce + this.G | 0, re = re + this.H | 0, this.set(K, V, W, J, ne, ie, ce, re);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$4.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} }, dist$1 = {};
(function(A) {
  Object.defineProperties(A, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  var B = {}, L = {};
  L.byteLength = re, L.toByteArray = ke, L.fromByteArray = at;
  for (var K = [], V = [], W = typeof Uint8Array < "u" ? Uint8Array : Array, J = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ne = 0, ie = J.length; ne < ie; ++ne)
    K[ne] = J[ne], V[J.charCodeAt(ne)] = ne;
  V[45] = 62, V[95] = 63;
  function ce(ot) {
    var yt = ot.length;
    if (yt % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var mt = ot.indexOf("=");
    mt === -1 && (mt = yt);
    var Tt = mt === yt ? 0 : 4 - mt % 4;
    return [mt, Tt];
  }
  function re(ot) {
    var yt = ce(ot), mt = yt[0], Tt = yt[1];
    return (mt + Tt) * 3 / 4 - Tt;
  }
  function oe(ot, yt, mt) {
    return (yt + mt) * 3 / 4 - mt;
  }
  function ke(ot) {
    var yt, mt = ce(ot), Tt = mt[0], Pt = mt[1], Nt = new W(oe(ot, Tt, Pt)), St = 0, vt = Pt > 0 ? Tt - 4 : Tt, It;
    for (It = 0; It < vt; It += 4)
      yt = V[ot.charCodeAt(It)] << 18 | V[ot.charCodeAt(It + 1)] << 12 | V[ot.charCodeAt(It + 2)] << 6 | V[ot.charCodeAt(It + 3)], Nt[St++] = yt >> 16 & 255, Nt[St++] = yt >> 8 & 255, Nt[St++] = yt & 255;
    return Pt === 2 && (yt = V[ot.charCodeAt(It)] << 2 | V[ot.charCodeAt(It + 1)] >> 4, Nt[St++] = yt & 255), Pt === 1 && (yt = V[ot.charCodeAt(It)] << 10 | V[ot.charCodeAt(It + 1)] << 4 | V[ot.charCodeAt(It + 2)] >> 2, Nt[St++] = yt >> 8 & 255, Nt[St++] = yt & 255), Nt;
  }
  function Ce(ot) {
    return K[ot >> 18 & 63] + K[ot >> 12 & 63] + K[ot >> 6 & 63] + K[ot & 63];
  }
  function it(ot, yt, mt) {
    for (var Tt, Pt = [], Nt = yt; Nt < mt; Nt += 3)
      Tt = (ot[Nt] << 16 & 16711680) + (ot[Nt + 1] << 8 & 65280) + (ot[Nt + 2] & 255), Pt.push(Ce(Tt));
    return Pt.join("");
  }
  function at(ot) {
    for (var yt, mt = ot.length, Tt = mt % 3, Pt = [], Nt = 16383, St = 0, vt = mt - Tt; St < vt; St += Nt)
      Pt.push(it(ot, St, St + Nt > vt ? vt : St + Nt));
    return Tt === 1 ? (yt = ot[mt - 1], Pt.push(
      K[yt >> 2] + K[yt << 4 & 63] + "=="
    )) : Tt === 2 && (yt = (ot[mt - 2] << 8) + ot[mt - 1], Pt.push(
      K[yt >> 10] + K[yt >> 4 & 63] + K[yt << 2 & 63] + "="
    )), Pt.join("");
  }
  var ct = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  ct.read = function(ot, yt, mt, Tt, Pt) {
    var Nt, St, vt = Pt * 8 - Tt - 1, It = (1 << vt) - 1, wt = It >> 1, Oe = -7, rt = mt ? Pt - 1 : 0, pe = mt ? -1 : 1, nt = ot[yt + rt];
    for (rt += pe, Nt = nt & (1 << -Oe) - 1, nt >>= -Oe, Oe += vt; Oe > 0; Nt = Nt * 256 + ot[yt + rt], rt += pe, Oe -= 8)
      ;
    for (St = Nt & (1 << -Oe) - 1, Nt >>= -Oe, Oe += Tt; Oe > 0; St = St * 256 + ot[yt + rt], rt += pe, Oe -= 8)
      ;
    if (Nt === 0)
      Nt = 1 - wt;
    else {
      if (Nt === It)
        return St ? NaN : (nt ? -1 : 1) * (1 / 0);
      St = St + Math.pow(2, Tt), Nt = Nt - wt;
    }
    return (nt ? -1 : 1) * St * Math.pow(2, Nt - Tt);
  }, ct.write = function(ot, yt, mt, Tt, Pt, Nt) {
    var St, vt, It, wt = Nt * 8 - Pt - 1, Oe = (1 << wt) - 1, rt = Oe >> 1, pe = Pt === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, nt = Tt ? 0 : Nt - 1, st = Tt ? 1 : -1, ft = yt < 0 || yt === 0 && 1 / yt < 0 ? 1 : 0;
    for (yt = Math.abs(yt), isNaN(yt) || yt === 1 / 0 ? (vt = isNaN(yt) ? 1 : 0, St = Oe) : (St = Math.floor(Math.log(yt) / Math.LN2), yt * (It = Math.pow(2, -St)) < 1 && (St--, It *= 2), St + rt >= 1 ? yt += pe / It : yt += pe * Math.pow(2, 1 - rt), yt * It >= 2 && (St++, It /= 2), St + rt >= Oe ? (vt = 0, St = Oe) : St + rt >= 1 ? (vt = (yt * It - 1) * Math.pow(2, Pt), St = St + rt) : (vt = yt * Math.pow(2, rt - 1) * Math.pow(2, Pt), St = 0)); Pt >= 8; ot[mt + nt] = vt & 255, nt += st, vt /= 256, Pt -= 8)
      ;
    for (St = St << Pt | vt, wt += Pt; wt > 0; ot[mt + nt] = St & 255, nt += st, St /= 256, wt -= 8)
      ;
    ot[mt + nt - st] |= ft * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(ot) {
    const yt = L, mt = ct, Tt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    ot.Buffer = Oe, ot.SlowBuffer = $t, ot.INSPECT_MAX_BYTES = 50;
    const Pt = 2147483647;
    ot.kMaxLength = Pt;
    const { Uint8Array: Nt, ArrayBuffer: St, SharedArrayBuffer: vt } = globalThis;
    Oe.TYPED_ARRAY_SUPPORT = It(), !Oe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function It() {
      try {
        const xt = new Nt(1), pt = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(pt, Nt.prototype), Object.setPrototypeOf(xt, pt), xt.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(Oe.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (Oe.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(Oe.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (Oe.isBuffer(this))
          return this.byteOffset;
      }
    });
    function wt(xt) {
      if (xt > Pt)
        throw new RangeError('The value "' + xt + '" is invalid for option "size"');
      const pt = new Nt(xt);
      return Object.setPrototypeOf(pt, Oe.prototype), pt;
    }
    function Oe(xt, pt, Et) {
      if (typeof xt == "number") {
        if (typeof pt == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return st(xt);
      }
      return rt(xt, pt, Et);
    }
    Oe.poolSize = 8192;
    function rt(xt, pt, Et) {
      if (typeof xt == "string")
        return ft(xt, pt);
      if (St.isView(xt))
        return bt(xt);
      if (xt == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof xt
        );
      if (Ir(xt, St) || xt && Ir(xt.buffer, St) || typeof vt < "u" && (Ir(xt, vt) || xt && Ir(xt.buffer, vt)))
        return ut(xt, pt, Et);
      if (typeof xt == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const qt = xt.valueOf && xt.valueOf();
      if (qt != null && qt !== xt)
        return Oe.from(qt, pt, Et);
      const Ht = gt(xt);
      if (Ht) return Ht;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof xt[Symbol.toPrimitive] == "function")
        return Oe.from(xt[Symbol.toPrimitive]("string"), pt, Et);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof xt
      );
    }
    Oe.from = function(xt, pt, Et) {
      return rt(xt, pt, Et);
    }, Object.setPrototypeOf(Oe.prototype, Nt.prototype), Object.setPrototypeOf(Oe, Nt);
    function pe(xt) {
      if (typeof xt != "number")
        throw new TypeError('"size" argument must be of type number');
      if (xt < 0)
        throw new RangeError('The value "' + xt + '" is invalid for option "size"');
    }
    function nt(xt, pt, Et) {
      return pe(xt), xt <= 0 ? wt(xt) : pt !== void 0 ? typeof Et == "string" ? wt(xt).fill(pt, Et) : wt(xt).fill(pt) : wt(xt);
    }
    Oe.alloc = function(xt, pt, Et) {
      return nt(xt, pt, Et);
    };
    function st(xt) {
      return pe(xt), wt(xt < 0 ? 0 : lt(xt) | 0);
    }
    Oe.allocUnsafe = function(xt) {
      return st(xt);
    }, Oe.allocUnsafeSlow = function(xt) {
      return st(xt);
    };
    function ft(xt, pt) {
      if ((typeof pt != "string" || pt === "") && (pt = "utf8"), !Oe.isEncoding(pt))
        throw new TypeError("Unknown encoding: " + pt);
      const Et = jt(xt, pt) | 0;
      let qt = wt(Et);
      const Ht = qt.write(xt, pt);
      return Ht !== Et && (qt = qt.slice(0, Ht)), qt;
    }
    function ht(xt) {
      const pt = xt.length < 0 ? 0 : lt(xt.length) | 0, Et = wt(pt);
      for (let qt = 0; qt < pt; qt += 1)
        Et[qt] = xt[qt] & 255;
      return Et;
    }
    function bt(xt) {
      if (Ir(xt, Nt)) {
        const pt = new Nt(xt);
        return ut(pt.buffer, pt.byteOffset, pt.byteLength);
      }
      return ht(xt);
    }
    function ut(xt, pt, Et) {
      if (pt < 0 || xt.byteLength < pt)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (xt.byteLength < pt + (Et || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let qt;
      return pt === void 0 && Et === void 0 ? qt = new Nt(xt) : Et === void 0 ? qt = new Nt(xt, pt) : qt = new Nt(xt, pt, Et), Object.setPrototypeOf(qt, Oe.prototype), qt;
    }
    function gt(xt) {
      if (Oe.isBuffer(xt)) {
        const pt = lt(xt.length) | 0, Et = wt(pt);
        return Et.length === 0 || xt.copy(Et, 0, 0, pt), Et;
      }
      if (xt.length !== void 0)
        return typeof xt.length != "number" || Or(xt.length) ? wt(0) : ht(xt);
      if (xt.type === "Buffer" && Array.isArray(xt.data))
        return ht(xt.data);
    }
    function lt(xt) {
      if (xt >= Pt)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Pt.toString(16) + " bytes");
      return xt | 0;
    }
    function $t(xt) {
      return +xt != xt && (xt = 0), Oe.alloc(+xt);
    }
    Oe.isBuffer = function(pt) {
      return pt != null && pt._isBuffer === !0 && pt !== Oe.prototype;
    }, Oe.compare = function(pt, Et) {
      if (Ir(pt, Nt) && (pt = Oe.from(pt, pt.offset, pt.byteLength)), Ir(Et, Nt) && (Et = Oe.from(Et, Et.offset, Et.byteLength)), !Oe.isBuffer(pt) || !Oe.isBuffer(Et))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (pt === Et) return 0;
      let qt = pt.length, Ht = Et.length;
      for (let Yt = 0, Qt = Math.min(qt, Ht); Yt < Qt; ++Yt)
        if (pt[Yt] !== Et[Yt]) {
          qt = pt[Yt], Ht = Et[Yt];
          break;
        }
      return qt < Ht ? -1 : Ht < qt ? 1 : 0;
    }, Oe.isEncoding = function(pt) {
      switch (String(pt).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, Oe.concat = function(pt, Et) {
      if (!Array.isArray(pt))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (pt.length === 0)
        return Oe.alloc(0);
      let qt;
      if (Et === void 0)
        for (Et = 0, qt = 0; qt < pt.length; ++qt)
          Et += pt[qt].length;
      const Ht = Oe.allocUnsafe(Et);
      let Yt = 0;
      for (qt = 0; qt < pt.length; ++qt) {
        let Qt = pt[qt];
        if (Ir(Qt, Nt))
          Yt + Qt.length > Ht.length ? (Oe.isBuffer(Qt) || (Qt = Oe.from(Qt)), Qt.copy(Ht, Yt)) : Nt.prototype.set.call(
            Ht,
            Qt,
            Yt
          );
        else if (Oe.isBuffer(Qt))
          Qt.copy(Ht, Yt);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Yt += Qt.length;
      }
      return Ht;
    };
    function jt(xt, pt) {
      if (Oe.isBuffer(xt))
        return xt.length;
      if (St.isView(xt) || Ir(xt, St))
        return xt.byteLength;
      if (typeof xt != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof xt
        );
      const Et = xt.length, qt = arguments.length > 2 && arguments[2] === !0;
      if (!qt && Et === 0) return 0;
      let Ht = !1;
      for (; ; )
        switch (pt) {
          case "ascii":
          case "latin1":
          case "binary":
            return Et;
          case "utf8":
          case "utf-8":
            return Br(xt).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Et * 2;
          case "hex":
            return Et >>> 1;
          case "base64":
            return Er(xt).length;
          default:
            if (Ht)
              return qt ? -1 : Br(xt).length;
            pt = ("" + pt).toLowerCase(), Ht = !0;
        }
    }
    Oe.byteLength = jt;
    function Jt(xt, pt, Et) {
      let qt = !1;
      if ((pt === void 0 || pt < 0) && (pt = 0), pt > this.length || ((Et === void 0 || Et > this.length) && (Et = this.length), Et <= 0) || (Et >>>= 0, pt >>>= 0, Et <= pt))
        return "";
      for (xt || (xt = "utf8"); ; )
        switch (xt) {
          case "hex":
            return Pr(this, pt, Et);
          case "utf8":
          case "utf-8":
            return ar(this, pt, Et);
          case "ascii":
            return dr(this, pt, Et);
          case "latin1":
          case "binary":
            return rr(this, pt, Et);
          case "base64":
            return nr(this, pt, Et);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ur(this, pt, Et);
          default:
            if (qt) throw new TypeError("Unknown encoding: " + xt);
            xt = (xt + "").toLowerCase(), qt = !0;
        }
    }
    Oe.prototype._isBuffer = !0;
    function Lt(xt, pt, Et) {
      const qt = xt[pt];
      xt[pt] = xt[Et], xt[Et] = qt;
    }
    Oe.prototype.swap16 = function() {
      const pt = this.length;
      if (pt % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let Et = 0; Et < pt; Et += 2)
        Lt(this, Et, Et + 1);
      return this;
    }, Oe.prototype.swap32 = function() {
      const pt = this.length;
      if (pt % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let Et = 0; Et < pt; Et += 4)
        Lt(this, Et, Et + 3), Lt(this, Et + 1, Et + 2);
      return this;
    }, Oe.prototype.swap64 = function() {
      const pt = this.length;
      if (pt % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let Et = 0; Et < pt; Et += 8)
        Lt(this, Et, Et + 7), Lt(this, Et + 1, Et + 6), Lt(this, Et + 2, Et + 5), Lt(this, Et + 3, Et + 4);
      return this;
    }, Oe.prototype.toString = function() {
      const pt = this.length;
      return pt === 0 ? "" : arguments.length === 0 ? ar(this, 0, pt) : Jt.apply(this, arguments);
    }, Oe.prototype.toLocaleString = Oe.prototype.toString, Oe.prototype.equals = function(pt) {
      if (!Oe.isBuffer(pt)) throw new TypeError("Argument must be a Buffer");
      return this === pt ? !0 : Oe.compare(this, pt) === 0;
    }, Oe.prototype.inspect = function() {
      let pt = "";
      const Et = ot.INSPECT_MAX_BYTES;
      return pt = this.toString("hex", 0, Et).replace(/(.{2})/g, "$1 ").trim(), this.length > Et && (pt += " ... "), "<Buffer " + pt + ">";
    }, Tt && (Oe.prototype[Tt] = Oe.prototype.inspect), Oe.prototype.compare = function(pt, Et, qt, Ht, Yt) {
      if (Ir(pt, Nt) && (pt = Oe.from(pt, pt.offset, pt.byteLength)), !Oe.isBuffer(pt))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof pt
        );
      if (Et === void 0 && (Et = 0), qt === void 0 && (qt = pt ? pt.length : 0), Ht === void 0 && (Ht = 0), Yt === void 0 && (Yt = this.length), Et < 0 || qt > pt.length || Ht < 0 || Yt > this.length)
        throw new RangeError("out of range index");
      if (Ht >= Yt && Et >= qt)
        return 0;
      if (Ht >= Yt)
        return -1;
      if (Et >= qt)
        return 1;
      if (Et >>>= 0, qt >>>= 0, Ht >>>= 0, Yt >>>= 0, this === pt) return 0;
      let Qt = Yt - Ht, or = qt - Et;
      const cr = Math.min(Qt, or), Dt = this.slice(Ht, Yt), er = pt.slice(Et, qt);
      for (let ir = 0; ir < cr; ++ir)
        if (Dt[ir] !== er[ir]) {
          Qt = Dt[ir], or = er[ir];
          break;
        }
      return Qt < or ? -1 : or < Qt ? 1 : 0;
    };
    function Rt(xt, pt, Et, qt, Ht) {
      if (xt.length === 0) return -1;
      if (typeof Et == "string" ? (qt = Et, Et = 0) : Et > 2147483647 ? Et = 2147483647 : Et < -2147483648 && (Et = -2147483648), Et = +Et, Or(Et) && (Et = Ht ? 0 : xt.length - 1), Et < 0 && (Et = xt.length + Et), Et >= xt.length) {
        if (Ht) return -1;
        Et = xt.length - 1;
      } else if (Et < 0)
        if (Ht) Et = 0;
        else return -1;
      if (typeof pt == "string" && (pt = Oe.from(pt, qt)), Oe.isBuffer(pt))
        return pt.length === 0 ? -1 : Mt(xt, pt, Et, qt, Ht);
      if (typeof pt == "number")
        return pt = pt & 255, typeof Nt.prototype.indexOf == "function" ? Ht ? Nt.prototype.indexOf.call(xt, pt, Et) : Nt.prototype.lastIndexOf.call(xt, pt, Et) : Mt(xt, [pt], Et, qt, Ht);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Mt(xt, pt, Et, qt, Ht) {
      let Yt = 1, Qt = xt.length, or = pt.length;
      if (qt !== void 0 && (qt = String(qt).toLowerCase(), qt === "ucs2" || qt === "ucs-2" || qt === "utf16le" || qt === "utf-16le")) {
        if (xt.length < 2 || pt.length < 2)
          return -1;
        Yt = 2, Qt /= 2, or /= 2, Et /= 2;
      }
      function cr(er, ir) {
        return Yt === 1 ? er[ir] : er.readUInt16BE(ir * Yt);
      }
      let Dt;
      if (Ht) {
        let er = -1;
        for (Dt = Et; Dt < Qt; Dt++)
          if (cr(xt, Dt) === cr(pt, er === -1 ? 0 : Dt - er)) {
            if (er === -1 && (er = Dt), Dt - er + 1 === or) return er * Yt;
          } else
            er !== -1 && (Dt -= Dt - er), er = -1;
      } else
        for (Et + or > Qt && (Et = Qt - or), Dt = Et; Dt >= 0; Dt--) {
          let er = !0;
          for (let ir = 0; ir < or; ir++)
            if (cr(xt, Dt + ir) !== cr(pt, ir)) {
              er = !1;
              break;
            }
          if (er) return Dt;
        }
      return -1;
    }
    Oe.prototype.includes = function(pt, Et, qt) {
      return this.indexOf(pt, Et, qt) !== -1;
    }, Oe.prototype.indexOf = function(pt, Et, qt) {
      return Rt(this, pt, Et, qt, !0);
    }, Oe.prototype.lastIndexOf = function(pt, Et, qt) {
      return Rt(this, pt, Et, qt, !1);
    };
    function Kt(xt, pt, Et, qt) {
      Et = Number(Et) || 0;
      const Ht = xt.length - Et;
      qt ? (qt = Number(qt), qt > Ht && (qt = Ht)) : qt = Ht;
      const Yt = pt.length;
      qt > Yt / 2 && (qt = Yt / 2);
      let Qt;
      for (Qt = 0; Qt < qt; ++Qt) {
        const or = parseInt(pt.substr(Qt * 2, 2), 16);
        if (Or(or)) return Qt;
        xt[Et + Qt] = or;
      }
      return Qt;
    }
    function zt(xt, pt, Et, qt) {
      return wr(Br(pt, xt.length - Et), xt, Et, qt);
    }
    function Ct(xt, pt, Et, qt) {
      return wr(yr(pt), xt, Et, qt);
    }
    function kt(xt, pt, Et, qt) {
      return wr(Er(pt), xt, Et, qt);
    }
    function Vt(xt, pt, Et, qt) {
      return wr($r(pt, xt.length - Et), xt, Et, qt);
    }
    Oe.prototype.write = function(pt, Et, qt, Ht) {
      if (Et === void 0)
        Ht = "utf8", qt = this.length, Et = 0;
      else if (qt === void 0 && typeof Et == "string")
        Ht = Et, qt = this.length, Et = 0;
      else if (isFinite(Et))
        Et = Et >>> 0, isFinite(qt) ? (qt = qt >>> 0, Ht === void 0 && (Ht = "utf8")) : (Ht = qt, qt = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const Yt = this.length - Et;
      if ((qt === void 0 || qt > Yt) && (qt = Yt), pt.length > 0 && (qt < 0 || Et < 0) || Et > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      Ht || (Ht = "utf8");
      let Qt = !1;
      for (; ; )
        switch (Ht) {
          case "hex":
            return Kt(this, pt, Et, qt);
          case "utf8":
          case "utf-8":
            return zt(this, pt, Et, qt);
          case "ascii":
          case "latin1":
          case "binary":
            return Ct(this, pt, Et, qt);
          case "base64":
            return kt(this, pt, Et, qt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Vt(this, pt, Et, qt);
          default:
            if (Qt) throw new TypeError("Unknown encoding: " + Ht);
            Ht = ("" + Ht).toLowerCase(), Qt = !0;
        }
    }, Oe.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function nr(xt, pt, Et) {
      return pt === 0 && Et === xt.length ? yt.fromByteArray(xt) : yt.fromByteArray(xt.slice(pt, Et));
    }
    function ar(xt, pt, Et) {
      Et = Math.min(xt.length, Et);
      const qt = [];
      let Ht = pt;
      for (; Ht < Et; ) {
        const Yt = xt[Ht];
        let Qt = null, or = Yt > 239 ? 4 : Yt > 223 ? 3 : Yt > 191 ? 2 : 1;
        if (Ht + or <= Et) {
          let cr, Dt, er, ir;
          switch (or) {
            case 1:
              Yt < 128 && (Qt = Yt);
              break;
            case 2:
              cr = xt[Ht + 1], (cr & 192) === 128 && (ir = (Yt & 31) << 6 | cr & 63, ir > 127 && (Qt = ir));
              break;
            case 3:
              cr = xt[Ht + 1], Dt = xt[Ht + 2], (cr & 192) === 128 && (Dt & 192) === 128 && (ir = (Yt & 15) << 12 | (cr & 63) << 6 | Dt & 63, ir > 2047 && (ir < 55296 || ir > 57343) && (Qt = ir));
              break;
            case 4:
              cr = xt[Ht + 1], Dt = xt[Ht + 2], er = xt[Ht + 3], (cr & 192) === 128 && (Dt & 192) === 128 && (er & 192) === 128 && (ir = (Yt & 15) << 18 | (cr & 63) << 12 | (Dt & 63) << 6 | er & 63, ir > 65535 && ir < 1114112 && (Qt = ir));
          }
        }
        Qt === null ? (Qt = 65533, or = 1) : Qt > 65535 && (Qt -= 65536, qt.push(Qt >>> 10 & 1023 | 55296), Qt = 56320 | Qt & 1023), qt.push(Qt), Ht += or;
      }
      return lr(qt);
    }
    const sr = 4096;
    function lr(xt) {
      const pt = xt.length;
      if (pt <= sr)
        return String.fromCharCode.apply(String, xt);
      let Et = "", qt = 0;
      for (; qt < pt; )
        Et += String.fromCharCode.apply(
          String,
          xt.slice(qt, qt += sr)
        );
      return Et;
    }
    function dr(xt, pt, Et) {
      let qt = "";
      Et = Math.min(xt.length, Et);
      for (let Ht = pt; Ht < Et; ++Ht)
        qt += String.fromCharCode(xt[Ht] & 127);
      return qt;
    }
    function rr(xt, pt, Et) {
      let qt = "";
      Et = Math.min(xt.length, Et);
      for (let Ht = pt; Ht < Et; ++Ht)
        qt += String.fromCharCode(xt[Ht]);
      return qt;
    }
    function Pr(xt, pt, Et) {
      const qt = xt.length;
      (!pt || pt < 0) && (pt = 0), (!Et || Et < 0 || Et > qt) && (Et = qt);
      let Ht = "";
      for (let Yt = pt; Yt < Et; ++Yt)
        Ht += Wt[xt[Yt]];
      return Ht;
    }
    function ur(xt, pt, Et) {
      const qt = xt.slice(pt, Et);
      let Ht = "";
      for (let Yt = 0; Yt < qt.length - 1; Yt += 2)
        Ht += String.fromCharCode(qt[Yt] + qt[Yt + 1] * 256);
      return Ht;
    }
    Oe.prototype.slice = function(pt, Et) {
      const qt = this.length;
      pt = ~~pt, Et = Et === void 0 ? qt : ~~Et, pt < 0 ? (pt += qt, pt < 0 && (pt = 0)) : pt > qt && (pt = qt), Et < 0 ? (Et += qt, Et < 0 && (Et = 0)) : Et > qt && (Et = qt), Et < pt && (Et = pt);
      const Ht = this.subarray(pt, Et);
      return Object.setPrototypeOf(Ht, Oe.prototype), Ht;
    };
    function pr(xt, pt, Et) {
      if (xt % 1 !== 0 || xt < 0) throw new RangeError("offset is not uint");
      if (xt + pt > Et) throw new RangeError("Trying to access beyond buffer length");
    }
    Oe.prototype.readUintLE = Oe.prototype.readUIntLE = function(pt, Et, qt) {
      pt = pt >>> 0, Et = Et >>> 0, qt || pr(pt, Et, this.length);
      let Ht = this[pt], Yt = 1, Qt = 0;
      for (; ++Qt < Et && (Yt *= 256); )
        Ht += this[pt + Qt] * Yt;
      return Ht;
    }, Oe.prototype.readUintBE = Oe.prototype.readUIntBE = function(pt, Et, qt) {
      pt = pt >>> 0, Et = Et >>> 0, qt || pr(pt, Et, this.length);
      let Ht = this[pt + --Et], Yt = 1;
      for (; Et > 0 && (Yt *= 256); )
        Ht += this[pt + --Et] * Yt;
      return Ht;
    }, Oe.prototype.readUint8 = Oe.prototype.readUInt8 = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 1, this.length), this[pt];
    }, Oe.prototype.readUint16LE = Oe.prototype.readUInt16LE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 2, this.length), this[pt] | this[pt + 1] << 8;
    }, Oe.prototype.readUint16BE = Oe.prototype.readUInt16BE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 2, this.length), this[pt] << 8 | this[pt + 1];
    }, Oe.prototype.readUint32LE = Oe.prototype.readUInt32LE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 4, this.length), (this[pt] | this[pt + 1] << 8 | this[pt + 2] << 16) + this[pt + 3] * 16777216;
    }, Oe.prototype.readUint32BE = Oe.prototype.readUInt32BE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 4, this.length), this[pt] * 16777216 + (this[pt + 1] << 16 | this[pt + 2] << 8 | this[pt + 3]);
    }, Oe.prototype.readBigUInt64LE = Ft(function(pt) {
      pt = pt >>> 0, Xt(pt, "offset");
      const Et = this[pt], qt = this[pt + 7];
      (Et === void 0 || qt === void 0) && Zt(pt, this.length - 8);
      const Ht = Et + this[++pt] * 2 ** 8 + this[++pt] * 2 ** 16 + this[++pt] * 2 ** 24, Yt = this[++pt] + this[++pt] * 2 ** 8 + this[++pt] * 2 ** 16 + qt * 2 ** 24;
      return BigInt(Ht) + (BigInt(Yt) << BigInt(32));
    }), Oe.prototype.readBigUInt64BE = Ft(function(pt) {
      pt = pt >>> 0, Xt(pt, "offset");
      const Et = this[pt], qt = this[pt + 7];
      (Et === void 0 || qt === void 0) && Zt(pt, this.length - 8);
      const Ht = Et * 2 ** 24 + this[++pt] * 2 ** 16 + this[++pt] * 2 ** 8 + this[++pt], Yt = this[++pt] * 2 ** 24 + this[++pt] * 2 ** 16 + this[++pt] * 2 ** 8 + qt;
      return (BigInt(Ht) << BigInt(32)) + BigInt(Yt);
    }), Oe.prototype.readIntLE = function(pt, Et, qt) {
      pt = pt >>> 0, Et = Et >>> 0, qt || pr(pt, Et, this.length);
      let Ht = this[pt], Yt = 1, Qt = 0;
      for (; ++Qt < Et && (Yt *= 256); )
        Ht += this[pt + Qt] * Yt;
      return Yt *= 128, Ht >= Yt && (Ht -= Math.pow(2, 8 * Et)), Ht;
    }, Oe.prototype.readIntBE = function(pt, Et, qt) {
      pt = pt >>> 0, Et = Et >>> 0, qt || pr(pt, Et, this.length);
      let Ht = Et, Yt = 1, Qt = this[pt + --Ht];
      for (; Ht > 0 && (Yt *= 256); )
        Qt += this[pt + --Ht] * Yt;
      return Yt *= 128, Qt >= Yt && (Qt -= Math.pow(2, 8 * Et)), Qt;
    }, Oe.prototype.readInt8 = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 1, this.length), this[pt] & 128 ? (255 - this[pt] + 1) * -1 : this[pt];
    }, Oe.prototype.readInt16LE = function(pt, Et) {
      pt = pt >>> 0, Et || pr(pt, 2, this.length);
      const qt = this[pt] | this[pt + 1] << 8;
      return qt & 32768 ? qt | 4294901760 : qt;
    }, Oe.prototype.readInt16BE = function(pt, Et) {
      pt = pt >>> 0, Et || pr(pt, 2, this.length);
      const qt = this[pt + 1] | this[pt] << 8;
      return qt & 32768 ? qt | 4294901760 : qt;
    }, Oe.prototype.readInt32LE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 4, this.length), this[pt] | this[pt + 1] << 8 | this[pt + 2] << 16 | this[pt + 3] << 24;
    }, Oe.prototype.readInt32BE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 4, this.length), this[pt] << 24 | this[pt + 1] << 16 | this[pt + 2] << 8 | this[pt + 3];
    }, Oe.prototype.readBigInt64LE = Ft(function(pt) {
      pt = pt >>> 0, Xt(pt, "offset");
      const Et = this[pt], qt = this[pt + 7];
      (Et === void 0 || qt === void 0) && Zt(pt, this.length - 8);
      const Ht = this[pt + 4] + this[pt + 5] * 2 ** 8 + this[pt + 6] * 2 ** 16 + (qt << 24);
      return (BigInt(Ht) << BigInt(32)) + BigInt(Et + this[++pt] * 2 ** 8 + this[++pt] * 2 ** 16 + this[++pt] * 2 ** 24);
    }), Oe.prototype.readBigInt64BE = Ft(function(pt) {
      pt = pt >>> 0, Xt(pt, "offset");
      const Et = this[pt], qt = this[pt + 7];
      (Et === void 0 || qt === void 0) && Zt(pt, this.length - 8);
      const Ht = (Et << 24) + // Overflow
      this[++pt] * 2 ** 16 + this[++pt] * 2 ** 8 + this[++pt];
      return (BigInt(Ht) << BigInt(32)) + BigInt(this[++pt] * 2 ** 24 + this[++pt] * 2 ** 16 + this[++pt] * 2 ** 8 + qt);
    }), Oe.prototype.readFloatLE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 4, this.length), mt.read(this, pt, !0, 23, 4);
    }, Oe.prototype.readFloatBE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 4, this.length), mt.read(this, pt, !1, 23, 4);
    }, Oe.prototype.readDoubleLE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 8, this.length), mt.read(this, pt, !0, 52, 8);
    }, Oe.prototype.readDoubleBE = function(pt, Et) {
      return pt = pt >>> 0, Et || pr(pt, 8, this.length), mt.read(this, pt, !1, 52, 8);
    };
    function br(xt, pt, Et, qt, Ht, Yt) {
      if (!Oe.isBuffer(xt)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (pt > Ht || pt < Yt) throw new RangeError('"value" argument is out of bounds');
      if (Et + qt > xt.length) throw new RangeError("Index out of range");
    }
    Oe.prototype.writeUintLE = Oe.prototype.writeUIntLE = function(pt, Et, qt, Ht) {
      if (pt = +pt, Et = Et >>> 0, qt = qt >>> 0, !Ht) {
        const or = Math.pow(2, 8 * qt) - 1;
        br(this, pt, Et, qt, or, 0);
      }
      let Yt = 1, Qt = 0;
      for (this[Et] = pt & 255; ++Qt < qt && (Yt *= 256); )
        this[Et + Qt] = pt / Yt & 255;
      return Et + qt;
    }, Oe.prototype.writeUintBE = Oe.prototype.writeUIntBE = function(pt, Et, qt, Ht) {
      if (pt = +pt, Et = Et >>> 0, qt = qt >>> 0, !Ht) {
        const or = Math.pow(2, 8 * qt) - 1;
        br(this, pt, Et, qt, or, 0);
      }
      let Yt = qt - 1, Qt = 1;
      for (this[Et + Yt] = pt & 255; --Yt >= 0 && (Qt *= 256); )
        this[Et + Yt] = pt / Qt & 255;
      return Et + qt;
    }, Oe.prototype.writeUint8 = Oe.prototype.writeUInt8 = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 1, 255, 0), this[Et] = pt & 255, Et + 1;
    }, Oe.prototype.writeUint16LE = Oe.prototype.writeUInt16LE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 2, 65535, 0), this[Et] = pt & 255, this[Et + 1] = pt >>> 8, Et + 2;
    }, Oe.prototype.writeUint16BE = Oe.prototype.writeUInt16BE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 2, 65535, 0), this[Et] = pt >>> 8, this[Et + 1] = pt & 255, Et + 2;
    }, Oe.prototype.writeUint32LE = Oe.prototype.writeUInt32LE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 4, 4294967295, 0), this[Et + 3] = pt >>> 24, this[Et + 2] = pt >>> 16, this[Et + 1] = pt >>> 8, this[Et] = pt & 255, Et + 4;
    }, Oe.prototype.writeUint32BE = Oe.prototype.writeUInt32BE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 4, 4294967295, 0), this[Et] = pt >>> 24, this[Et + 1] = pt >>> 16, this[Et + 2] = pt >>> 8, this[Et + 3] = pt & 255, Et + 4;
    };
    function hr(xt, pt, Et, qt, Ht) {
      Ut(pt, qt, Ht, xt, Et, 7);
      let Yt = Number(pt & BigInt(4294967295));
      xt[Et++] = Yt, Yt = Yt >> 8, xt[Et++] = Yt, Yt = Yt >> 8, xt[Et++] = Yt, Yt = Yt >> 8, xt[Et++] = Yt;
      let Qt = Number(pt >> BigInt(32) & BigInt(4294967295));
      return xt[Et++] = Qt, Qt = Qt >> 8, xt[Et++] = Qt, Qt = Qt >> 8, xt[Et++] = Qt, Qt = Qt >> 8, xt[Et++] = Qt, Et;
    }
    function xr(xt, pt, Et, qt, Ht) {
      Ut(pt, qt, Ht, xt, Et, 7);
      let Yt = Number(pt & BigInt(4294967295));
      xt[Et + 7] = Yt, Yt = Yt >> 8, xt[Et + 6] = Yt, Yt = Yt >> 8, xt[Et + 5] = Yt, Yt = Yt >> 8, xt[Et + 4] = Yt;
      let Qt = Number(pt >> BigInt(32) & BigInt(4294967295));
      return xt[Et + 3] = Qt, Qt = Qt >> 8, xt[Et + 2] = Qt, Qt = Qt >> 8, xt[Et + 1] = Qt, Qt = Qt >> 8, xt[Et] = Qt, Et + 8;
    }
    Oe.prototype.writeBigUInt64LE = Ft(function(pt, Et = 0) {
      return hr(this, pt, Et, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Oe.prototype.writeBigUInt64BE = Ft(function(pt, Et = 0) {
      return xr(this, pt, Et, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Oe.prototype.writeIntLE = function(pt, Et, qt, Ht) {
      if (pt = +pt, Et = Et >>> 0, !Ht) {
        const cr = Math.pow(2, 8 * qt - 1);
        br(this, pt, Et, qt, cr - 1, -cr);
      }
      let Yt = 0, Qt = 1, or = 0;
      for (this[Et] = pt & 255; ++Yt < qt && (Qt *= 256); )
        pt < 0 && or === 0 && this[Et + Yt - 1] !== 0 && (or = 1), this[Et + Yt] = (pt / Qt >> 0) - or & 255;
      return Et + qt;
    }, Oe.prototype.writeIntBE = function(pt, Et, qt, Ht) {
      if (pt = +pt, Et = Et >>> 0, !Ht) {
        const cr = Math.pow(2, 8 * qt - 1);
        br(this, pt, Et, qt, cr - 1, -cr);
      }
      let Yt = qt - 1, Qt = 1, or = 0;
      for (this[Et + Yt] = pt & 255; --Yt >= 0 && (Qt *= 256); )
        pt < 0 && or === 0 && this[Et + Yt + 1] !== 0 && (or = 1), this[Et + Yt] = (pt / Qt >> 0) - or & 255;
      return Et + qt;
    }, Oe.prototype.writeInt8 = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 1, 127, -128), pt < 0 && (pt = 255 + pt + 1), this[Et] = pt & 255, Et + 1;
    }, Oe.prototype.writeInt16LE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 2, 32767, -32768), this[Et] = pt & 255, this[Et + 1] = pt >>> 8, Et + 2;
    }, Oe.prototype.writeInt16BE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 2, 32767, -32768), this[Et] = pt >>> 8, this[Et + 1] = pt & 255, Et + 2;
    }, Oe.prototype.writeInt32LE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 4, 2147483647, -2147483648), this[Et] = pt & 255, this[Et + 1] = pt >>> 8, this[Et + 2] = pt >>> 16, this[Et + 3] = pt >>> 24, Et + 4;
    }, Oe.prototype.writeInt32BE = function(pt, Et, qt) {
      return pt = +pt, Et = Et >>> 0, qt || br(this, pt, Et, 4, 2147483647, -2147483648), pt < 0 && (pt = 4294967295 + pt + 1), this[Et] = pt >>> 24, this[Et + 1] = pt >>> 16, this[Et + 2] = pt >>> 8, this[Et + 3] = pt & 255, Et + 4;
    }, Oe.prototype.writeBigInt64LE = Ft(function(pt, Et = 0) {
      return hr(this, pt, Et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Oe.prototype.writeBigInt64BE = Ft(function(pt, Et = 0) {
      return xr(this, pt, Et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Mr(xt, pt, Et, qt, Ht, Yt) {
      if (Et + qt > xt.length) throw new RangeError("Index out of range");
      if (Et < 0) throw new RangeError("Index out of range");
    }
    function _r(xt, pt, Et, qt, Ht) {
      return pt = +pt, Et = Et >>> 0, Ht || Mr(xt, pt, Et, 4), mt.write(xt, pt, Et, qt, 23, 4), Et + 4;
    }
    Oe.prototype.writeFloatLE = function(pt, Et, qt) {
      return _r(this, pt, Et, !0, qt);
    }, Oe.prototype.writeFloatBE = function(pt, Et, qt) {
      return _r(this, pt, Et, !1, qt);
    };
    function Rr(xt, pt, Et, qt, Ht) {
      return pt = +pt, Et = Et >>> 0, Ht || Mr(xt, pt, Et, 8), mt.write(xt, pt, Et, qt, 52, 8), Et + 8;
    }
    Oe.prototype.writeDoubleLE = function(pt, Et, qt) {
      return Rr(this, pt, Et, !0, qt);
    }, Oe.prototype.writeDoubleBE = function(pt, Et, qt) {
      return Rr(this, pt, Et, !1, qt);
    }, Oe.prototype.copy = function(pt, Et, qt, Ht) {
      if (!Oe.isBuffer(pt)) throw new TypeError("argument should be a Buffer");
      if (qt || (qt = 0), !Ht && Ht !== 0 && (Ht = this.length), Et >= pt.length && (Et = pt.length), Et || (Et = 0), Ht > 0 && Ht < qt && (Ht = qt), Ht === qt || pt.length === 0 || this.length === 0) return 0;
      if (Et < 0)
        throw new RangeError("targetStart out of bounds");
      if (qt < 0 || qt >= this.length) throw new RangeError("Index out of range");
      if (Ht < 0) throw new RangeError("sourceEnd out of bounds");
      Ht > this.length && (Ht = this.length), pt.length - Et < Ht - qt && (Ht = pt.length - Et + qt);
      const Yt = Ht - qt;
      return this === pt && typeof Nt.prototype.copyWithin == "function" ? this.copyWithin(Et, qt, Ht) : Nt.prototype.set.call(
        pt,
        this.subarray(qt, Ht),
        Et
      ), Yt;
    }, Oe.prototype.fill = function(pt, Et, qt, Ht) {
      if (typeof pt == "string") {
        if (typeof Et == "string" ? (Ht = Et, Et = 0, qt = this.length) : typeof qt == "string" && (Ht = qt, qt = this.length), Ht !== void 0 && typeof Ht != "string")
          throw new TypeError("encoding must be a string");
        if (typeof Ht == "string" && !Oe.isEncoding(Ht))
          throw new TypeError("Unknown encoding: " + Ht);
        if (pt.length === 1) {
          const Qt = pt.charCodeAt(0);
          (Ht === "utf8" && Qt < 128 || Ht === "latin1") && (pt = Qt);
        }
      } else typeof pt == "number" ? pt = pt & 255 : typeof pt == "boolean" && (pt = Number(pt));
      if (Et < 0 || this.length < Et || this.length < qt)
        throw new RangeError("Out of range index");
      if (qt <= Et)
        return this;
      Et = Et >>> 0, qt = qt === void 0 ? this.length : qt >>> 0, pt || (pt = 0);
      let Yt;
      if (typeof pt == "number")
        for (Yt = Et; Yt < qt; ++Yt)
          this[Yt] = pt;
      else {
        const Qt = Oe.isBuffer(pt) ? pt : Oe.from(pt, Ht), or = Qt.length;
        if (or === 0)
          throw new TypeError('The value "' + pt + '" is invalid for argument "value"');
        for (Yt = 0; Yt < qt - Et; ++Yt)
          this[Yt + Et] = Qt[Yt % or];
      }
      return this;
    };
    const kr = {};
    function Ot(xt, pt, Et) {
      kr[xt] = class extends Et {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: pt.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${xt}]`, this.stack, delete this.name;
        }
        get code() {
          return xt;
        }
        set code(Ht) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: Ht,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${xt}]: ${this.message}`;
        }
      };
    }
    Ot(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(xt) {
        return xt ? `${xt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Ot(
      "ERR_INVALID_ARG_TYPE",
      function(xt, pt) {
        return `The "${xt}" argument must be of type number. Received type ${typeof pt}`;
      },
      TypeError
    ), Ot(
      "ERR_OUT_OF_RANGE",
      function(xt, pt, Et) {
        let qt = `The value of "${xt}" is out of range.`, Ht = Et;
        return Number.isInteger(Et) && Math.abs(Et) > 2 ** 32 ? Ht = At(String(Et)) : typeof Et == "bigint" && (Ht = String(Et), (Et > BigInt(2) ** BigInt(32) || Et < -(BigInt(2) ** BigInt(32))) && (Ht = At(Ht)), Ht += "n"), qt += ` It must be ${pt}. Received ${Ht}`, qt;
      },
      RangeError
    );
    function At(xt) {
      let pt = "", Et = xt.length;
      const qt = xt[0] === "-" ? 1 : 0;
      for (; Et >= qt + 4; Et -= 3)
        pt = `_${xt.slice(Et - 3, Et)}${pt}`;
      return `${xt.slice(0, Et)}${pt}`;
    }
    function Bt(xt, pt, Et) {
      Xt(pt, "offset"), (xt[pt] === void 0 || xt[pt + Et] === void 0) && Zt(pt, xt.length - (Et + 1));
    }
    function Ut(xt, pt, Et, qt, Ht, Yt) {
      if (xt > Et || xt < pt) {
        const Qt = typeof pt == "bigint" ? "n" : "";
        let or;
        throw pt === 0 || pt === BigInt(0) ? or = `>= 0${Qt} and < 2${Qt} ** ${(Yt + 1) * 8}${Qt}` : or = `>= -(2${Qt} ** ${(Yt + 1) * 8 - 1}${Qt}) and < 2 ** ${(Yt + 1) * 8 - 1}${Qt}`, new kr.ERR_OUT_OF_RANGE("value", or, xt);
      }
      Bt(qt, Ht, Yt);
    }
    function Xt(xt, pt) {
      if (typeof xt != "number")
        throw new kr.ERR_INVALID_ARG_TYPE(pt, "number", xt);
    }
    function Zt(xt, pt, Et) {
      throw Math.floor(xt) !== xt ? (Xt(xt, Et), new kr.ERR_OUT_OF_RANGE("offset", "an integer", xt)) : pt < 0 ? new kr.ERR_BUFFER_OUT_OF_BOUNDS() : new kr.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${pt}`,
        xt
      );
    }
    const tr = /[^+/0-9A-Za-z-_]/g;
    function vr(xt) {
      if (xt = xt.split("=")[0], xt = xt.trim().replace(tr, ""), xt.length < 2) return "";
      for (; xt.length % 4 !== 0; )
        xt = xt + "=";
      return xt;
    }
    function Br(xt, pt) {
      pt = pt || 1 / 0;
      let Et;
      const qt = xt.length;
      let Ht = null;
      const Yt = [];
      for (let Qt = 0; Qt < qt; ++Qt) {
        if (Et = xt.charCodeAt(Qt), Et > 55295 && Et < 57344) {
          if (!Ht) {
            if (Et > 56319) {
              (pt -= 3) > -1 && Yt.push(239, 191, 189);
              continue;
            } else if (Qt + 1 === qt) {
              (pt -= 3) > -1 && Yt.push(239, 191, 189);
              continue;
            }
            Ht = Et;
            continue;
          }
          if (Et < 56320) {
            (pt -= 3) > -1 && Yt.push(239, 191, 189), Ht = Et;
            continue;
          }
          Et = (Ht - 55296 << 10 | Et - 56320) + 65536;
        } else Ht && (pt -= 3) > -1 && Yt.push(239, 191, 189);
        if (Ht = null, Et < 128) {
          if ((pt -= 1) < 0) break;
          Yt.push(Et);
        } else if (Et < 2048) {
          if ((pt -= 2) < 0) break;
          Yt.push(
            Et >> 6 | 192,
            Et & 63 | 128
          );
        } else if (Et < 65536) {
          if ((pt -= 3) < 0) break;
          Yt.push(
            Et >> 12 | 224,
            Et >> 6 & 63 | 128,
            Et & 63 | 128
          );
        } else if (Et < 1114112) {
          if ((pt -= 4) < 0) break;
          Yt.push(
            Et >> 18 | 240,
            Et >> 12 & 63 | 128,
            Et >> 6 & 63 | 128,
            Et & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Yt;
    }
    function yr(xt) {
      const pt = [];
      for (let Et = 0; Et < xt.length; ++Et)
        pt.push(xt.charCodeAt(Et) & 255);
      return pt;
    }
    function $r(xt, pt) {
      let Et, qt, Ht;
      const Yt = [];
      for (let Qt = 0; Qt < xt.length && !((pt -= 2) < 0); ++Qt)
        Et = xt.charCodeAt(Qt), qt = Et >> 8, Ht = Et % 256, Yt.push(Ht), Yt.push(qt);
      return Yt;
    }
    function Er(xt) {
      return yt.toByteArray(vr(xt));
    }
    function wr(xt, pt, Et, qt) {
      let Ht;
      for (Ht = 0; Ht < qt && !(Ht + Et >= pt.length || Ht >= xt.length); ++Ht)
        pt[Ht + Et] = xt[Ht];
      return Ht;
    }
    function Ir(xt, pt) {
      return xt instanceof pt || xt != null && xt.constructor != null && xt.constructor.name != null && xt.constructor.name === pt.name;
    }
    function Or(xt) {
      return xt !== xt;
    }
    const Wt = function() {
      const xt = "0123456789abcdef", pt = new Array(256);
      for (let Et = 0; Et < 16; ++Et) {
        const qt = Et * 16;
        for (let Ht = 0; Ht < 16; ++Ht)
          pt[qt + Ht] = xt[Et] + xt[Ht];
      }
      return pt;
    }();
    function Ft(xt) {
      return typeof BigInt > "u" ? Gt : xt;
    }
    function Gt() {
      throw new Error("BigInt not supported");
    }
  })(B);
  const dt = B.Buffer;
  A.Blob = B.Blob, A.BlobOptions = B.BlobOptions, A.Buffer = B.Buffer, A.File = B.File, A.FileOptions = B.FileOptions, A.INSPECT_MAX_BYTES = B.INSPECT_MAX_BYTES, A.SlowBuffer = B.SlowBuffer, A.TranscodeEncoding = B.TranscodeEncoding, A.atob = B.atob, A.btoa = B.btoa, A.constants = B.constants, A.default = dt, A.isAscii = B.isAscii, A.isUtf8 = B.isUtf8, A.kMaxLength = B.kMaxLength, A.kStringMaxLength = B.kStringMaxLength, A.resolveObjectURL = B.resolveObjectURL, A.transcode = B.transcode;
})(dist$1);
const Buffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(A, B) {
  var L = dist$1, K = L.Buffer;
  function V(J, ne) {
    for (var ie in J)
      ne[ie] = J[ie];
  }
  K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (V(L, B), B.Buffer = W);
  function W(J, ne, ie) {
    return K(J, ne, ie);
  }
  W.prototype = Object.create(K.prototype), V(K, W), W.from = function(J, ne, ie) {
    if (typeof J == "number")
      throw new TypeError("Argument must not be a number");
    return K(J, ne, ie);
  }, W.alloc = function(J, ne, ie) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    var ce = K(J);
    return ne !== void 0 ? typeof ie == "string" ? ce.fill(ne, ie) : ce.fill(ne) : ce.fill(0), ce;
  }, W.allocUnsafe = function(J) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    return K(J);
  }, W.allocUnsafeSlow = function(J) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    return L.SlowBuffer(J);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var A = 65536, B = 4294967295;
  function L() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var K = safeBufferExports.Buffer, V = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  V && V.getRandomValues ? browser$b.exports = W : browser$b.exports = L;
  function W(J, ne) {
    if (J > B) throw new RangeError("requested too many random bytes");
    var ie = K.allocUnsafe(J);
    if (J > 0)
      if (J > A)
        for (var ce = 0; ce < J; ce += A)
          V.getRandomValues(ie.slice(ce, ce + A));
      else
        V.getRandomValues(ie);
    return typeof ne == "function" ? process$1.nextTick(function() {
      ne(null, ie);
    }) : ie;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(B, L) {
    L && (B.super_ = L, B.prototype = Object.create(L.prototype, {
      constructor: {
        value: B,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(B, L) {
    if (L) {
      B.super_ = L;
      var K = function() {
      };
      K.prototype = L.prototype, B.prototype = new K(), B.prototype.constructor = B;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var A = typeof Reflect == "object" ? Reflect : null, B = A && typeof A.apply == "function" ? A.apply : function(Tt, Pt, Nt) {
    return Function.prototype.apply.call(Tt, Pt, Nt);
  }, L;
  A && typeof A.ownKeys == "function" ? L = A.ownKeys : Object.getOwnPropertySymbols ? L = function(Tt) {
    return Object.getOwnPropertyNames(Tt).concat(Object.getOwnPropertySymbols(Tt));
  } : L = function(Tt) {
    return Object.getOwnPropertyNames(Tt);
  };
  function K(mt) {
    console && console.warn && console.warn(mt);
  }
  var V = Number.isNaN || function(Tt) {
    return Tt !== Tt;
  };
  function W() {
    W.init.call(this);
  }
  events.exports = W, events.exports.once = dt, W.EventEmitter = W, W.prototype._events = void 0, W.prototype._eventsCount = 0, W.prototype._maxListeners = void 0;
  var J = 10;
  function ne(mt) {
    if (typeof mt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof mt);
  }
  Object.defineProperty(W, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return J;
    },
    set: function(mt) {
      if (typeof mt != "number" || mt < 0 || V(mt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + mt + ".");
      J = mt;
    }
  }), W.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, W.prototype.setMaxListeners = function(Tt) {
    if (typeof Tt != "number" || Tt < 0 || V(Tt))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Tt + ".");
    return this._maxListeners = Tt, this;
  };
  function ie(mt) {
    return mt._maxListeners === void 0 ? W.defaultMaxListeners : mt._maxListeners;
  }
  W.prototype.getMaxListeners = function() {
    return ie(this);
  }, W.prototype.emit = function(Tt) {
    for (var Pt = [], Nt = 1; Nt < arguments.length; Nt++) Pt.push(arguments[Nt]);
    var St = Tt === "error", vt = this._events;
    if (vt !== void 0)
      St = St && vt.error === void 0;
    else if (!St)
      return !1;
    if (St) {
      var It;
      if (Pt.length > 0 && (It = Pt[0]), It instanceof Error)
        throw It;
      var wt = new Error("Unhandled error." + (It ? " (" + It.message + ")" : ""));
      throw wt.context = It, wt;
    }
    var Oe = vt[Tt];
    if (Oe === void 0)
      return !1;
    if (typeof Oe == "function")
      B(Oe, this, Pt);
    else
      for (var rt = Oe.length, pe = it(Oe, rt), Nt = 0; Nt < rt; ++Nt)
        B(pe[Nt], this, Pt);
    return !0;
  };
  function ce(mt, Tt, Pt, Nt) {
    var St, vt, It;
    if (ne(Pt), vt = mt._events, vt === void 0 ? (vt = mt._events = /* @__PURE__ */ Object.create(null), mt._eventsCount = 0) : (vt.newListener !== void 0 && (mt.emit(
      "newListener",
      Tt,
      Pt.listener ? Pt.listener : Pt
    ), vt = mt._events), It = vt[Tt]), It === void 0)
      It = vt[Tt] = Pt, ++mt._eventsCount;
    else if (typeof It == "function" ? It = vt[Tt] = Nt ? [Pt, It] : [It, Pt] : Nt ? It.unshift(Pt) : It.push(Pt), St = ie(mt), St > 0 && It.length > St && !It.warned) {
      It.warned = !0;
      var wt = new Error("Possible EventEmitter memory leak detected. " + It.length + " " + String(Tt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      wt.name = "MaxListenersExceededWarning", wt.emitter = mt, wt.type = Tt, wt.count = It.length, K(wt);
    }
    return mt;
  }
  W.prototype.addListener = function(Tt, Pt) {
    return ce(this, Tt, Pt, !1);
  }, W.prototype.on = W.prototype.addListener, W.prototype.prependListener = function(Tt, Pt) {
    return ce(this, Tt, Pt, !0);
  };
  function re() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function oe(mt, Tt, Pt) {
    var Nt = { fired: !1, wrapFn: void 0, target: mt, type: Tt, listener: Pt }, St = re.bind(Nt);
    return St.listener = Pt, Nt.wrapFn = St, St;
  }
  W.prototype.once = function(Tt, Pt) {
    return ne(Pt), this.on(Tt, oe(this, Tt, Pt)), this;
  }, W.prototype.prependOnceListener = function(Tt, Pt) {
    return ne(Pt), this.prependListener(Tt, oe(this, Tt, Pt)), this;
  }, W.prototype.removeListener = function(Tt, Pt) {
    var Nt, St, vt, It, wt;
    if (ne(Pt), St = this._events, St === void 0)
      return this;
    if (Nt = St[Tt], Nt === void 0)
      return this;
    if (Nt === Pt || Nt.listener === Pt)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete St[Tt], St.removeListener && this.emit("removeListener", Tt, Nt.listener || Pt));
    else if (typeof Nt != "function") {
      for (vt = -1, It = Nt.length - 1; It >= 0; It--)
        if (Nt[It] === Pt || Nt[It].listener === Pt) {
          wt = Nt[It].listener, vt = It;
          break;
        }
      if (vt < 0)
        return this;
      vt === 0 ? Nt.shift() : at(Nt, vt), Nt.length === 1 && (St[Tt] = Nt[0]), St.removeListener !== void 0 && this.emit("removeListener", Tt, wt || Pt);
    }
    return this;
  }, W.prototype.off = W.prototype.removeListener, W.prototype.removeAllListeners = function(Tt) {
    var Pt, Nt, St;
    if (Nt = this._events, Nt === void 0)
      return this;
    if (Nt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Nt[Tt] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Nt[Tt]), this;
    if (arguments.length === 0) {
      var vt = Object.keys(Nt), It;
      for (St = 0; St < vt.length; ++St)
        It = vt[St], It !== "removeListener" && this.removeAllListeners(It);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (Pt = Nt[Tt], typeof Pt == "function")
      this.removeListener(Tt, Pt);
    else if (Pt !== void 0)
      for (St = Pt.length - 1; St >= 0; St--)
        this.removeListener(Tt, Pt[St]);
    return this;
  };
  function ke(mt, Tt, Pt) {
    var Nt = mt._events;
    if (Nt === void 0)
      return [];
    var St = Nt[Tt];
    return St === void 0 ? [] : typeof St == "function" ? Pt ? [St.listener || St] : [St] : Pt ? ct(St) : it(St, St.length);
  }
  W.prototype.listeners = function(Tt) {
    return ke(this, Tt, !0);
  }, W.prototype.rawListeners = function(Tt) {
    return ke(this, Tt, !1);
  }, W.listenerCount = function(mt, Tt) {
    return typeof mt.listenerCount == "function" ? mt.listenerCount(Tt) : Ce.call(mt, Tt);
  }, W.prototype.listenerCount = Ce;
  function Ce(mt) {
    var Tt = this._events;
    if (Tt !== void 0) {
      var Pt = Tt[mt];
      if (typeof Pt == "function")
        return 1;
      if (Pt !== void 0)
        return Pt.length;
    }
    return 0;
  }
  W.prototype.eventNames = function() {
    return this._eventsCount > 0 ? L(this._events) : [];
  };
  function it(mt, Tt) {
    for (var Pt = new Array(Tt), Nt = 0; Nt < Tt; ++Nt)
      Pt[Nt] = mt[Nt];
    return Pt;
  }
  function at(mt, Tt) {
    for (; Tt + 1 < mt.length; Tt++)
      mt[Tt] = mt[Tt + 1];
    mt.pop();
  }
  function ct(mt) {
    for (var Tt = new Array(mt.length), Pt = 0; Pt < Tt.length; ++Pt)
      Tt[Pt] = mt[Pt].listener || mt[Pt];
    return Tt;
  }
  function dt(mt, Tt) {
    return new Promise(function(Pt, Nt) {
      function St(It) {
        mt.removeListener(Tt, vt), Nt(It);
      }
      function vt() {
        typeof mt.removeListener == "function" && mt.removeListener("error", St), Pt([].slice.call(arguments));
      }
      yt(mt, Tt, vt, { once: !0 }), Tt !== "error" && ot(mt, St, { once: !0 });
    });
  }
  function ot(mt, Tt, Pt) {
    typeof mt.on == "function" && yt(mt, "error", Tt, Pt);
  }
  function yt(mt, Tt, Pt, Nt) {
    if (typeof mt.on == "function")
      Nt.once ? mt.once(Tt, Pt) : mt.on(Tt, Pt);
    else if (typeof mt.addEventListener == "function")
      mt.addEventListener(Tt, function St(vt) {
        Nt.once && mt.removeEventListener(Tt, St), Pt(vt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof mt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var B = {}, L = Symbol("test"), K = Object(L);
    if (typeof L == "string" || Object.prototype.toString.call(L) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]")
      return !1;
    var V = 42;
    B[L] = V;
    for (var W in B)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0)
      return !1;
    var J = Object.getOwnPropertySymbols(B);
    if (J.length !== 1 || J[0] !== L || !Object.prototype.propertyIsEnumerable.call(B, L))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var ne = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(B, L)
      );
      if (ne.value !== V || ne.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var A = requireShams$1();
  return shams = function() {
    return A() && !!Symbol.toStringTag;
  }, shams;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(B) {
    return B !== B;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var A = require_isNaN();
  return sign$1 = function(L) {
    return A(L) || L === 0 ? L : L < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var A = requireGOPD();
  if (A)
    try {
      A([], "length");
    } catch {
      A = null;
    }
  return gopd = A, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var A = Object.defineProperty || !1;
  if (A)
    try {
      A({}, "a", { value: 1 });
    } catch {
      A = !1;
    }
  return esDefineProperty = A, esDefineProperty;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var A = typeof Symbol < "u" && Symbol, B = requireShams$1();
  return hasSymbols = function() {
    return typeof A != "function" || typeof Symbol != "function" || typeof A("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : B();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var A = requireEsObjectAtoms();
  return Object_getPrototypeOf = A.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var A = "Function.prototype.bind called on incompatible ", B = Object.prototype.toString, L = Math.max, K = "[object Function]", V = function(ie, ce) {
    for (var re = [], oe = 0; oe < ie.length; oe += 1)
      re[oe] = ie[oe];
    for (var ke = 0; ke < ce.length; ke += 1)
      re[ke + ie.length] = ce[ke];
    return re;
  }, W = function(ie, ce) {
    for (var re = [], oe = ce, ke = 0; oe < ie.length; oe += 1, ke += 1)
      re[ke] = ie[oe];
    return re;
  }, J = function(ne, ie) {
    for (var ce = "", re = 0; re < ne.length; re += 1)
      ce += ne[re], re + 1 < ne.length && (ce += ie);
    return ce;
  };
  return implementation = function(ie) {
    var ce = this;
    if (typeof ce != "function" || B.apply(ce) !== K)
      throw new TypeError(A + ce);
    for (var re = W(arguments, 1), oe, ke = function() {
      if (this instanceof oe) {
        var dt = ce.apply(
          this,
          V(re, arguments)
        );
        return Object(dt) === dt ? dt : this;
      }
      return ce.apply(
        ie,
        V(re, arguments)
      );
    }, Ce = L(0, ce.length - re.length), it = [], at = 0; at < Ce; at++)
      it[at] = "$" + at;
    if (oe = Function("binder", "return function (" + J(it, ",") + "){ return binder.apply(this,arguments); }")(ke), ce.prototype) {
      var ct = function() {
      };
      ct.prototype = ce.prototype, oe.prototype = new ct(), ct.prototype = null;
    }
    return oe;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var A = requireImplementation();
  return functionBind = Function.prototype.bind || A, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var A = requireFunctionBind(), B = requireFunctionApply(), L = requireFunctionCall(), K = requireReflectApply();
  return actualApply = K || A.call(L, B), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var A = requireFunctionBind(), B = requireType(), L = requireFunctionCall(), K = requireActualApply();
  return callBindApplyHelpers = function(W) {
    if (W.length < 1 || typeof W[0] != "function")
      throw new B("a function is required");
    return K(A, L, W);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var A = requireCallBindApplyHelpers(), B = requireGopd(), L;
  try {
    L = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (J) {
    if (!J || typeof J != "object" || !("code" in J) || J.code !== "ERR_PROTO_ACCESS")
      throw J;
  }
  var K = !!L && B && B(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), V = Object, W = V.getPrototypeOf;
  return get = K && typeof K.get == "function" ? A([K.get]) : typeof W == "function" ? (
    /** @type {import('./get')} */
    function(ne) {
      return W(ne == null ? ne : V(ne));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var A = requireReflect_getPrototypeOf(), B = requireObject_getPrototypeOf(), L = requireGet();
  return getProto = A ? function(V) {
    return A(V);
  } : B ? function(V) {
    if (!V || typeof V != "object" && typeof V != "function")
      throw new TypeError("getProto: not an object");
    return B(V);
  } : L ? function(V) {
    return L(V);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var A = Function.prototype.call, B = Object.prototype.hasOwnProperty, L = requireFunctionBind();
  return hasown = L.call(A, B), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var A, B = requireEsObjectAtoms(), L = requireEsErrors(), K = require_eval(), V = requireRange(), W = requireRef(), J = requireSyntax(), ne = requireType(), ie = requireUri(), ce = requireAbs(), re = requireFloor(), oe = requireMax(), ke = requireMin(), Ce = requirePow(), it = requireRound(), at = requireSign$1(), ct = Function, dt = function(Kt) {
    try {
      return ct('"use strict"; return (' + Kt + ").constructor;")();
    } catch {
    }
  }, ot = requireGopd(), yt = requireEsDefineProperty(), mt = function() {
    throw new ne();
  }, Tt = ot ? function() {
    try {
      return arguments.callee, mt;
    } catch {
      try {
        return ot(arguments, "callee").get;
      } catch {
        return mt;
      }
    }
  }() : mt, Pt = requireHasSymbols()(), Nt = requireGetProto(), St = requireObject_getPrototypeOf(), vt = requireReflect_getPrototypeOf(), It = requireFunctionApply(), wt = requireFunctionCall(), Oe = {}, rt = typeof Uint8Array > "u" || !Nt ? A : Nt(Uint8Array), pe = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? A : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? A : ArrayBuffer,
    "%ArrayIteratorPrototype%": Pt && Nt ? Nt([][Symbol.iterator]()) : A,
    "%AsyncFromSyncIteratorPrototype%": A,
    "%AsyncFunction%": Oe,
    "%AsyncGenerator%": Oe,
    "%AsyncGeneratorFunction%": Oe,
    "%AsyncIteratorPrototype%": Oe,
    "%Atomics%": typeof Atomics > "u" ? A : Atomics,
    "%BigInt%": typeof BigInt > "u" ? A : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? A : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? A : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? A : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": L,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": K,
    "%Float32Array%": typeof Float32Array > "u" ? A : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? A : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? A : FinalizationRegistry,
    "%Function%": ct,
    "%GeneratorFunction%": Oe,
    "%Int8Array%": typeof Int8Array > "u" ? A : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? A : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? A : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Pt && Nt ? Nt(Nt([][Symbol.iterator]())) : A,
    "%JSON%": typeof JSON == "object" ? JSON : A,
    "%Map%": typeof Map > "u" ? A : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Pt || !Nt ? A : Nt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": B,
    "%Object.getOwnPropertyDescriptor%": ot,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? A : Promise,
    "%Proxy%": typeof Proxy > "u" ? A : Proxy,
    "%RangeError%": V,
    "%ReferenceError%": W,
    "%Reflect%": typeof Reflect > "u" ? A : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? A : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Pt || !Nt ? A : Nt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? A : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Pt && Nt ? Nt(""[Symbol.iterator]()) : A,
    "%Symbol%": Pt ? Symbol : A,
    "%SyntaxError%": J,
    "%ThrowTypeError%": Tt,
    "%TypedArray%": rt,
    "%TypeError%": ne,
    "%Uint8Array%": typeof Uint8Array > "u" ? A : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? A : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? A : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? A : Uint32Array,
    "%URIError%": ie,
    "%WeakMap%": typeof WeakMap > "u" ? A : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? A : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? A : WeakSet,
    "%Function.prototype.call%": wt,
    "%Function.prototype.apply%": It,
    "%Object.defineProperty%": yt,
    "%Object.getPrototypeOf%": St,
    "%Math.abs%": ce,
    "%Math.floor%": re,
    "%Math.max%": oe,
    "%Math.min%": ke,
    "%Math.pow%": Ce,
    "%Math.round%": it,
    "%Math.sign%": at,
    "%Reflect.getPrototypeOf%": vt
  };
  if (Nt)
    try {
      null.error;
    } catch (Kt) {
      var nt = Nt(Nt(Kt));
      pe["%Error.prototype%"] = nt;
    }
  var st = function Kt(zt) {
    var Ct;
    if (zt === "%AsyncFunction%")
      Ct = dt("async function () {}");
    else if (zt === "%GeneratorFunction%")
      Ct = dt("function* () {}");
    else if (zt === "%AsyncGeneratorFunction%")
      Ct = dt("async function* () {}");
    else if (zt === "%AsyncGenerator%") {
      var kt = Kt("%AsyncGeneratorFunction%");
      kt && (Ct = kt.prototype);
    } else if (zt === "%AsyncIteratorPrototype%") {
      var Vt = Kt("%AsyncGenerator%");
      Vt && Nt && (Ct = Nt(Vt.prototype));
    }
    return pe[zt] = Ct, Ct;
  }, ft = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ht = requireFunctionBind(), bt = requireHasown(), ut = ht.call(wt, Array.prototype.concat), gt = ht.call(It, Array.prototype.splice), lt = ht.call(wt, String.prototype.replace), $t = ht.call(wt, String.prototype.slice), jt = ht.call(wt, RegExp.prototype.exec), Jt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Lt = /\\(\\)?/g, Rt = function(zt) {
    var Ct = $t(zt, 0, 1), kt = $t(zt, -1);
    if (Ct === "%" && kt !== "%")
      throw new J("invalid intrinsic syntax, expected closing `%`");
    if (kt === "%" && Ct !== "%")
      throw new J("invalid intrinsic syntax, expected opening `%`");
    var Vt = [];
    return lt(zt, Jt, function(nr, ar, sr, lr) {
      Vt[Vt.length] = sr ? lt(lr, Lt, "$1") : ar || nr;
    }), Vt;
  }, Mt = function(zt, Ct) {
    var kt = zt, Vt;
    if (bt(ft, kt) && (Vt = ft[kt], kt = "%" + Vt[0] + "%"), bt(pe, kt)) {
      var nr = pe[kt];
      if (nr === Oe && (nr = st(kt)), typeof nr > "u" && !Ct)
        throw new ne("intrinsic " + zt + " exists, but is not available. Please file an issue!");
      return {
        alias: Vt,
        name: kt,
        value: nr
      };
    }
    throw new J("intrinsic " + zt + " does not exist!");
  };
  return getIntrinsic = function(zt, Ct) {
    if (typeof zt != "string" || zt.length === 0)
      throw new ne("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Ct != "boolean")
      throw new ne('"allowMissing" argument must be a boolean');
    if (jt(/^%?[^%]*%?$/, zt) === null)
      throw new J("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var kt = Rt(zt), Vt = kt.length > 0 ? kt[0] : "", nr = Mt("%" + Vt + "%", Ct), ar = nr.name, sr = nr.value, lr = !1, dr = nr.alias;
    dr && (Vt = dr[0], gt(kt, ut([0, 1], dr)));
    for (var rr = 1, Pr = !0; rr < kt.length; rr += 1) {
      var ur = kt[rr], pr = $t(ur, 0, 1), br = $t(ur, -1);
      if ((pr === '"' || pr === "'" || pr === "`" || br === '"' || br === "'" || br === "`") && pr !== br)
        throw new J("property names with quotes must have matching quotes");
      if ((ur === "constructor" || !Pr) && (lr = !0), Vt += "." + ur, ar = "%" + Vt + "%", bt(pe, ar))
        sr = pe[ar];
      else if (sr != null) {
        if (!(ur in sr)) {
          if (!Ct)
            throw new ne("base intrinsic for " + zt + " exists, but the property is not available.");
          return;
        }
        if (ot && rr + 1 >= kt.length) {
          var hr = ot(sr, ur);
          Pr = !!hr, Pr && "get" in hr && !("originalValue" in hr.get) ? sr = hr.get : sr = sr[ur];
        } else
          Pr = bt(sr, ur), sr = sr[ur];
        Pr && !lr && (pe[ar] = sr);
      }
    }
    return sr;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var A = requireGetIntrinsic(), B = requireCallBindApplyHelpers(), L = B([A("%String.prototype.indexOf%")]);
  return callBound = function(V, W) {
    var J = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      A(V, !!W)
    );
    return typeof J == "function" && L(V, ".prototype.") > -1 ? B([J]) : J;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var A = requireShams()(), B = requireCallBound(), L = B("Object.prototype.toString"), K = function(ne) {
    return A && ne && typeof ne == "object" && Symbol.toStringTag in ne ? !1 : L(ne) === "[object Arguments]";
  }, V = function(ne) {
    return K(ne) ? !0 : ne !== null && typeof ne == "object" && "length" in ne && typeof ne.length == "number" && ne.length >= 0 && L(ne) !== "[object Array]" && "callee" in ne && L(ne.callee) === "[object Function]";
  }, W = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = V, isArguments = W ? K : V, isArguments;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var A = requireCallBound(), B = requireShams()(), L = requireHasown(), K = requireGopd(), V;
  if (B) {
    var W = A("RegExp.prototype.exec"), J = {}, ne = function() {
      throw J;
    }, ie = {
      toString: ne,
      valueOf: ne
    };
    typeof Symbol.toPrimitive == "symbol" && (ie[Symbol.toPrimitive] = ne), V = function(ke) {
      if (!ke || typeof ke != "object")
        return !1;
      var Ce = (
        /** @type {NonNullable<typeof gOPD>} */
        K(
          /** @type {{ lastIndex?: unknown }} */
          ke,
          "lastIndex"
        )
      ), it = Ce && L(Ce, "value");
      if (!it)
        return !1;
      try {
        W(
          ke,
          /** @type {string} */
          /** @type {unknown} */
          ie
        );
      } catch (at) {
        return at === J;
      }
    };
  } else {
    var ce = A("Object.prototype.toString"), re = "[object RegExp]";
    V = function(ke) {
      return !ke || typeof ke != "object" && typeof ke != "function" ? !1 : ce(ke) === re;
    };
  }
  return isRegex = V, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var A = requireCallBound(), B = requireIsRegex(), L = A("RegExp.prototype.exec"), K = requireType();
  return safeRegexTest = function(W) {
    if (!B(W))
      throw new K("`regex` must be a RegExp");
    return function(ne) {
      return L(W, ne) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var A = requireCallBound(), B = requireSafeRegexTest(), L = B(/^\s*(?:function)?\*/), K = requireShams()(), V = requireGetProto(), W = A("Object.prototype.toString"), J = A("Function.prototype.toString"), ne = function() {
    if (!K)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, ie;
  return isGeneratorFunction = function(re) {
    if (typeof re != "function")
      return !1;
    if (L(J(re)))
      return !0;
    if (!K) {
      var oe = W(re);
      return oe === "[object GeneratorFunction]";
    }
    if (!V)
      return !1;
    if (typeof ie > "u") {
      var ke = ne();
      ie = ke ? (
        /** @type {GeneratorFunctionConstructor} */
        V(ke)
      ) : !1;
    }
    return V(re) === ie;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var A = Function.prototype.toString, B = typeof Reflect == "object" && Reflect !== null && Reflect.apply, L, K;
  if (typeof B == "function" && typeof Object.defineProperty == "function")
    try {
      L = Object.defineProperty({}, "length", {
        get: function() {
          throw K;
        }
      }), K = {}, B(function() {
        throw 42;
      }, null, L);
    } catch (ot) {
      ot !== K && (B = null);
    }
  else
    B = null;
  var V = /^\s*class\b/, W = function(yt) {
    try {
      var mt = A.call(yt);
      return V.test(mt);
    } catch {
      return !1;
    }
  }, J = function(yt) {
    try {
      return W(yt) ? !1 : (A.call(yt), !0);
    } catch {
      return !1;
    }
  }, ne = Object.prototype.toString, ie = "[object Object]", ce = "[object Function]", re = "[object GeneratorFunction]", oe = "[object HTMLAllCollection]", ke = "[object HTML document.all class]", Ce = "[object HTMLCollection]", it = typeof Symbol == "function" && !!Symbol.toStringTag, at = !(0 in [,]), ct = function() {
    return !1;
  };
  if (typeof document == "object") {
    var dt = document.all;
    ne.call(dt) === ne.call(document.all) && (ct = function(yt) {
      if ((at || !yt) && (typeof yt > "u" || typeof yt == "object"))
        try {
          var mt = ne.call(yt);
          return (mt === oe || mt === ke || mt === Ce || mt === ie) && yt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = B ? function(yt) {
    if (ct(yt))
      return !0;
    if (!yt || typeof yt != "function" && typeof yt != "object")
      return !1;
    try {
      B(yt, null, L);
    } catch (mt) {
      if (mt !== K)
        return !1;
    }
    return !W(yt) && J(yt);
  } : function(yt) {
    if (ct(yt))
      return !0;
    if (!yt || typeof yt != "function" && typeof yt != "object")
      return !1;
    if (it)
      return J(yt);
    if (W(yt))
      return !1;
    var mt = ne.call(yt);
    return mt !== ce && mt !== re && !/^\[object HTML/.test(mt) ? !1 : J(yt);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var A = requireIsCallable(), B = Object.prototype.toString, L = Object.prototype.hasOwnProperty, K = function(ie, ce, re) {
    for (var oe = 0, ke = ie.length; oe < ke; oe++)
      L.call(ie, oe) && (re == null ? ce(ie[oe], oe, ie) : ce.call(re, ie[oe], oe, ie));
  }, V = function(ie, ce, re) {
    for (var oe = 0, ke = ie.length; oe < ke; oe++)
      re == null ? ce(ie.charAt(oe), oe, ie) : ce.call(re, ie.charAt(oe), oe, ie);
  }, W = function(ie, ce, re) {
    for (var oe in ie)
      L.call(ie, oe) && (re == null ? ce(ie[oe], oe, ie) : ce.call(re, ie[oe], oe, ie));
  };
  function J(ne) {
    return B.call(ne) === "[object Array]";
  }
  return forEach = function(ie, ce, re) {
    if (!A(ce))
      throw new TypeError("iterator must be a function");
    var oe;
    arguments.length >= 3 && (oe = re), J(ie) ? K(ie, ce, oe) : typeof ie == "string" ? V(ie, ce, oe) : W(ie, ce, oe);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var A = requirePossibleTypedArrayNames(), B = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], V = 0; V < A.length; V++)
      typeof B[A[V]] == "function" && (K[K.length] = A[V]);
    return K;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var A = requireEsDefineProperty(), B = requireSyntax(), L = requireType(), K = requireGopd();
  return defineDataProperty = function(W, J, ne) {
    if (!W || typeof W != "object" && typeof W != "function")
      throw new L("`obj` must be an object or a function`");
    if (typeof J != "string" && typeof J != "symbol")
      throw new L("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new L("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new L("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new L("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new L("`loose`, if provided, must be a boolean");
    var ie = arguments.length > 3 ? arguments[3] : null, ce = arguments.length > 4 ? arguments[4] : null, re = arguments.length > 5 ? arguments[5] : null, oe = arguments.length > 6 ? arguments[6] : !1, ke = !!K && K(W, J);
    if (A)
      A(W, J, {
        configurable: re === null && ke ? ke.configurable : !re,
        enumerable: ie === null && ke ? ke.enumerable : !ie,
        value: ne,
        writable: ce === null && ke ? ke.writable : !ce
      });
    else if (oe || !ie && !ce && !re)
      W[J] = ne;
    else
      throw new B("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var A = requireEsDefineProperty(), B = function() {
    return !!A;
  };
  return B.hasArrayLengthDefineBug = function() {
    if (!A)
      return null;
    try {
      return A([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = B, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var A = requireGetIntrinsic(), B = requireDefineDataProperty(), L = requireHasPropertyDescriptors()(), K = requireGopd(), V = requireType(), W = A("%Math.floor%");
  return setFunctionLength = function(ne, ie) {
    if (typeof ne != "function")
      throw new V("`fn` is not a function");
    if (typeof ie != "number" || ie < 0 || ie > 4294967295 || W(ie) !== ie)
      throw new V("`length` must be a positive 32-bit integer");
    var ce = arguments.length > 2 && !!arguments[2], re = !0, oe = !0;
    if ("length" in ne && K) {
      var ke = K(ne, "length");
      ke && !ke.configurable && (re = !1), ke && !ke.writable && (oe = !1);
    }
    return (re || oe || !ce) && (L ? B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie,
      !0,
      !0
    ) : B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie
    )), ne;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var A = requireFunctionBind(), B = requireFunctionApply(), L = requireActualApply();
  return applyBind = function() {
    return L(A, B, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(A) {
    var B = requireSetFunctionLength(), L = requireEsDefineProperty(), K = requireCallBindApplyHelpers(), V = requireApplyBind();
    A.exports = function(J) {
      var ne = K(arguments), ie = J.length - (arguments.length - 1);
      return B(
        ne,
        1 + (ie > 0 ? ie : 0),
        !0
      );
    }, L ? L(A.exports, "apply", { value: V }) : A.exports.apply = V;
  }(callBind)), callBind.exports;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var A = requireForEach(), B = requireAvailableTypedArrays(), L = requireCallBind(), K = requireCallBound(), V = requireGopd(), W = K("Object.prototype.toString"), J = requireShams()(), ne = typeof globalThis > "u" ? commonjsGlobal : globalThis, ie = B(), ce = K("String.prototype.slice"), re = Object.getPrototypeOf, oe = K("Array.prototype.indexOf", !0) || function(ct, dt) {
    for (var ot = 0; ot < ct.length; ot += 1)
      if (ct[ot] === dt)
        return ot;
    return -1;
  }, ke = { __proto__: null };
  J && V && re ? A(ie, function(at) {
    var ct = new ne[at]();
    if (Symbol.toStringTag in ct) {
      var dt = re(ct), ot = V(dt, Symbol.toStringTag);
      if (!ot) {
        var yt = re(dt);
        ot = V(yt, Symbol.toStringTag);
      }
      ke["$" + at] = L(ot.get);
    }
  }) : A(ie, function(at) {
    var ct = new ne[at](), dt = ct.slice || ct.set;
    dt && (ke["$" + at] = L(dt));
  });
  var Ce = function(ct) {
    var dt = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(ot, yt) {
        if (!dt)
          try {
            "$" + ot(ct) === yt && (dt = ce(yt, 1));
          } catch {
          }
      }
    ), dt;
  }, it = function(ct) {
    var dt = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(ot, yt) {
        if (!dt)
          try {
            ot(ct), dt = ce(yt, 1);
          } catch {
          }
      }
    ), dt;
  };
  return whichTypedArray = function(ct) {
    if (!ct || typeof ct != "object")
      return !1;
    if (!J) {
      var dt = ce(W(ct), 8, -1);
      return oe(ie, dt) > -1 ? dt : dt !== "Object" ? !1 : it(ct);
    }
    return V ? Ce(ct) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var A = requireWhichTypedArray();
  return isTypedArray = function(L) {
    return !!A(L);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(A) {
    var B = requireIsArguments(), L = requireIsGeneratorFunction(), K = requireWhichTypedArray(), V = requireIsTypedArray();
    function W(rr) {
      return rr.call.bind(rr);
    }
    var J = typeof BigInt < "u", ne = typeof Symbol < "u", ie = W(Object.prototype.toString), ce = W(Number.prototype.valueOf), re = W(String.prototype.valueOf), oe = W(Boolean.prototype.valueOf);
    if (J)
      var ke = W(BigInt.prototype.valueOf);
    if (ne)
      var Ce = W(Symbol.prototype.valueOf);
    function it(rr, Pr) {
      if (typeof rr != "object")
        return !1;
      try {
        return Pr(rr), !0;
      } catch {
        return !1;
      }
    }
    A.isArgumentsObject = B, A.isGeneratorFunction = L, A.isTypedArray = V;
    function at(rr) {
      return typeof Promise < "u" && rr instanceof Promise || rr !== null && typeof rr == "object" && typeof rr.then == "function" && typeof rr.catch == "function";
    }
    A.isPromise = at;
    function ct(rr) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(rr) : V(rr) || $t(rr);
    }
    A.isArrayBufferView = ct;
    function dt(rr) {
      return K(rr) === "Uint8Array";
    }
    A.isUint8Array = dt;
    function ot(rr) {
      return K(rr) === "Uint8ClampedArray";
    }
    A.isUint8ClampedArray = ot;
    function yt(rr) {
      return K(rr) === "Uint16Array";
    }
    A.isUint16Array = yt;
    function mt(rr) {
      return K(rr) === "Uint32Array";
    }
    A.isUint32Array = mt;
    function Tt(rr) {
      return K(rr) === "Int8Array";
    }
    A.isInt8Array = Tt;
    function Pt(rr) {
      return K(rr) === "Int16Array";
    }
    A.isInt16Array = Pt;
    function Nt(rr) {
      return K(rr) === "Int32Array";
    }
    A.isInt32Array = Nt;
    function St(rr) {
      return K(rr) === "Float32Array";
    }
    A.isFloat32Array = St;
    function vt(rr) {
      return K(rr) === "Float64Array";
    }
    A.isFloat64Array = vt;
    function It(rr) {
      return K(rr) === "BigInt64Array";
    }
    A.isBigInt64Array = It;
    function wt(rr) {
      return K(rr) === "BigUint64Array";
    }
    A.isBigUint64Array = wt;
    function Oe(rr) {
      return ie(rr) === "[object Map]";
    }
    Oe.working = typeof Map < "u" && Oe(/* @__PURE__ */ new Map());
    function rt(rr) {
      return typeof Map > "u" ? !1 : Oe.working ? Oe(rr) : rr instanceof Map;
    }
    A.isMap = rt;
    function pe(rr) {
      return ie(rr) === "[object Set]";
    }
    pe.working = typeof Set < "u" && pe(/* @__PURE__ */ new Set());
    function nt(rr) {
      return typeof Set > "u" ? !1 : pe.working ? pe(rr) : rr instanceof Set;
    }
    A.isSet = nt;
    function st(rr) {
      return ie(rr) === "[object WeakMap]";
    }
    st.working = typeof WeakMap < "u" && st(/* @__PURE__ */ new WeakMap());
    function ft(rr) {
      return typeof WeakMap > "u" ? !1 : st.working ? st(rr) : rr instanceof WeakMap;
    }
    A.isWeakMap = ft;
    function ht(rr) {
      return ie(rr) === "[object WeakSet]";
    }
    ht.working = typeof WeakSet < "u" && ht(/* @__PURE__ */ new WeakSet());
    function bt(rr) {
      return ht(rr);
    }
    A.isWeakSet = bt;
    function ut(rr) {
      return ie(rr) === "[object ArrayBuffer]";
    }
    ut.working = typeof ArrayBuffer < "u" && ut(new ArrayBuffer());
    function gt(rr) {
      return typeof ArrayBuffer > "u" ? !1 : ut.working ? ut(rr) : rr instanceof ArrayBuffer;
    }
    A.isArrayBuffer = gt;
    function lt(rr) {
      return ie(rr) === "[object DataView]";
    }
    lt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && lt(new DataView(new ArrayBuffer(1), 0, 1));
    function $t(rr) {
      return typeof DataView > "u" ? !1 : lt.working ? lt(rr) : rr instanceof DataView;
    }
    A.isDataView = $t;
    var jt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function Jt(rr) {
      return ie(rr) === "[object SharedArrayBuffer]";
    }
    function Lt(rr) {
      return typeof jt > "u" ? !1 : (typeof Jt.working > "u" && (Jt.working = Jt(new jt())), Jt.working ? Jt(rr) : rr instanceof jt);
    }
    A.isSharedArrayBuffer = Lt;
    function Rt(rr) {
      return ie(rr) === "[object AsyncFunction]";
    }
    A.isAsyncFunction = Rt;
    function Mt(rr) {
      return ie(rr) === "[object Map Iterator]";
    }
    A.isMapIterator = Mt;
    function Kt(rr) {
      return ie(rr) === "[object Set Iterator]";
    }
    A.isSetIterator = Kt;
    function zt(rr) {
      return ie(rr) === "[object Generator]";
    }
    A.isGeneratorObject = zt;
    function Ct(rr) {
      return ie(rr) === "[object WebAssembly.Module]";
    }
    A.isWebAssemblyCompiledModule = Ct;
    function kt(rr) {
      return it(rr, ce);
    }
    A.isNumberObject = kt;
    function Vt(rr) {
      return it(rr, re);
    }
    A.isStringObject = Vt;
    function nr(rr) {
      return it(rr, oe);
    }
    A.isBooleanObject = nr;
    function ar(rr) {
      return J && it(rr, ke);
    }
    A.isBigIntObject = ar;
    function sr(rr) {
      return ne && it(rr, Ce);
    }
    A.isSymbolObject = sr;
    function lr(rr) {
      return kt(rr) || Vt(rr) || nr(rr) || ar(rr) || sr(rr);
    }
    A.isBoxedPrimitive = lr;
    function dr(rr) {
      return typeof Uint8Array < "u" && (gt(rr) || Lt(rr));
    }
    A.isAnyArrayBuffer = dr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(rr) {
      Object.defineProperty(A, rr, {
        enumerable: !1,
        value: function() {
          throw new Error(rr + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(B) {
    return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(A) {
    var B = Object.getOwnPropertyDescriptors || function($t) {
      for (var jt = Object.keys($t), Jt = {}, Lt = 0; Lt < jt.length; Lt++)
        Jt[jt[Lt]] = Object.getOwnPropertyDescriptor($t, jt[Lt]);
      return Jt;
    }, L = /%[sdj%]/g;
    A.format = function(lt) {
      if (!Tt(lt)) {
        for (var $t = [], jt = 0; jt < arguments.length; jt++)
          $t.push(J(arguments[jt]));
        return $t.join(" ");
      }
      for (var jt = 1, Jt = arguments, Lt = Jt.length, Rt = String(lt).replace(L, function(Kt) {
        if (Kt === "%%") return "%";
        if (jt >= Lt) return Kt;
        switch (Kt) {
          case "%s":
            return String(Jt[jt++]);
          case "%d":
            return Number(Jt[jt++]);
          case "%j":
            try {
              return JSON.stringify(Jt[jt++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Kt;
        }
      }), Mt = Jt[jt]; jt < Lt; Mt = Jt[++jt])
        ot(Mt) || !vt(Mt) ? Rt += " " + Mt : Rt += " " + J(Mt);
      return Rt;
    }, A.deprecate = function(lt, $t) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return lt;
      if (typeof process$1 > "u")
        return function() {
          return A.deprecate(lt, $t).apply(this, arguments);
        };
      var jt = !1;
      function Jt() {
        if (!jt) {
          if (process$1.throwDeprecation)
            throw new Error($t);
          process$1.traceDeprecation ? console.trace($t) : console.error($t), jt = !0;
        }
        return lt.apply(this, arguments);
      }
      return Jt;
    };
    var K = {}, V = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var W = process$1.env.NODE_DEBUG;
      W = W.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), V = new RegExp("^" + W + "$", "i");
    }
    A.debuglog = function(lt) {
      if (lt = lt.toUpperCase(), !K[lt])
        if (V.test(lt)) {
          var $t = process$1.pid;
          K[lt] = function() {
            var jt = A.format.apply(A, arguments);
            console.error("%s %d: %s", lt, $t, jt);
          };
        } else
          K[lt] = function() {
          };
      return K[lt];
    };
    function J(lt, $t) {
      var jt = {
        seen: [],
        stylize: ie
      };
      return arguments.length >= 3 && (jt.depth = arguments[2]), arguments.length >= 4 && (jt.colors = arguments[3]), dt($t) ? jt.showHidden = $t : $t && A._extend(jt, $t), Nt(jt.showHidden) && (jt.showHidden = !1), Nt(jt.depth) && (jt.depth = 2), Nt(jt.colors) && (jt.colors = !1), Nt(jt.customInspect) && (jt.customInspect = !0), jt.colors && (jt.stylize = ne), re(jt, lt, jt.depth);
    }
    A.inspect = J, J.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, J.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function ne(lt, $t) {
      var jt = J.styles[$t];
      return jt ? "\x1B[" + J.colors[jt][0] + "m" + lt + "\x1B[" + J.colors[jt][1] + "m" : lt;
    }
    function ie(lt, $t) {
      return lt;
    }
    function ce(lt) {
      var $t = {};
      return lt.forEach(function(jt, Jt) {
        $t[jt] = !0;
      }), $t;
    }
    function re(lt, $t, jt) {
      if (lt.customInspect && $t && Oe($t.inspect) && // Filter out the util module, it's inspect function is special
      $t.inspect !== A.inspect && // Also filter out any prototype objects using the circular check.
      !($t.constructor && $t.constructor.prototype === $t)) {
        var Jt = $t.inspect(jt, lt);
        return Tt(Jt) || (Jt = re(lt, Jt, jt)), Jt;
      }
      var Lt = oe(lt, $t);
      if (Lt)
        return Lt;
      var Rt = Object.keys($t), Mt = ce(Rt);
      if (lt.showHidden && (Rt = Object.getOwnPropertyNames($t)), wt($t) && (Rt.indexOf("message") >= 0 || Rt.indexOf("description") >= 0))
        return ke($t);
      if (Rt.length === 0) {
        if (Oe($t)) {
          var Kt = $t.name ? ": " + $t.name : "";
          return lt.stylize("[Function" + Kt + "]", "special");
        }
        if (St($t))
          return lt.stylize(RegExp.prototype.toString.call($t), "regexp");
        if (It($t))
          return lt.stylize(Date.prototype.toString.call($t), "date");
        if (wt($t))
          return ke($t);
      }
      var zt = "", Ct = !1, kt = ["{", "}"];
      if (ct($t) && (Ct = !0, kt = ["[", "]"]), Oe($t)) {
        var Vt = $t.name ? ": " + $t.name : "";
        zt = " [Function" + Vt + "]";
      }
      if (St($t) && (zt = " " + RegExp.prototype.toString.call($t)), It($t) && (zt = " " + Date.prototype.toUTCString.call($t)), wt($t) && (zt = " " + ke($t)), Rt.length === 0 && (!Ct || $t.length == 0))
        return kt[0] + zt + kt[1];
      if (jt < 0)
        return St($t) ? lt.stylize(RegExp.prototype.toString.call($t), "regexp") : lt.stylize("[Object]", "special");
      lt.seen.push($t);
      var nr;
      return Ct ? nr = Ce(lt, $t, jt, Mt, Rt) : nr = Rt.map(function(ar) {
        return it(lt, $t, jt, Mt, ar, Ct);
      }), lt.seen.pop(), at(nr, zt, kt);
    }
    function oe(lt, $t) {
      if (Nt($t))
        return lt.stylize("undefined", "undefined");
      if (Tt($t)) {
        var jt = "'" + JSON.stringify($t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return lt.stylize(jt, "string");
      }
      if (mt($t))
        return lt.stylize("" + $t, "number");
      if (dt($t))
        return lt.stylize("" + $t, "boolean");
      if (ot($t))
        return lt.stylize("null", "null");
    }
    function ke(lt) {
      return "[" + Error.prototype.toString.call(lt) + "]";
    }
    function Ce(lt, $t, jt, Jt, Lt) {
      for (var Rt = [], Mt = 0, Kt = $t.length; Mt < Kt; ++Mt)
        ht($t, String(Mt)) ? Rt.push(it(
          lt,
          $t,
          jt,
          Jt,
          String(Mt),
          !0
        )) : Rt.push("");
      return Lt.forEach(function(zt) {
        zt.match(/^\d+$/) || Rt.push(it(
          lt,
          $t,
          jt,
          Jt,
          zt,
          !0
        ));
      }), Rt;
    }
    function it(lt, $t, jt, Jt, Lt, Rt) {
      var Mt, Kt, zt;
      if (zt = Object.getOwnPropertyDescriptor($t, Lt) || { value: $t[Lt] }, zt.get ? zt.set ? Kt = lt.stylize("[Getter/Setter]", "special") : Kt = lt.stylize("[Getter]", "special") : zt.set && (Kt = lt.stylize("[Setter]", "special")), ht(Jt, Lt) || (Mt = "[" + Lt + "]"), Kt || (lt.seen.indexOf(zt.value) < 0 ? (ot(jt) ? Kt = re(lt, zt.value, null) : Kt = re(lt, zt.value, jt - 1), Kt.indexOf(`
`) > -1 && (Rt ? Kt = Kt.split(`
`).map(function(Ct) {
        return "  " + Ct;
      }).join(`
`).slice(2) : Kt = `
` + Kt.split(`
`).map(function(Ct) {
        return "   " + Ct;
      }).join(`
`))) : Kt = lt.stylize("[Circular]", "special")), Nt(Mt)) {
        if (Rt && Lt.match(/^\d+$/))
          return Kt;
        Mt = JSON.stringify("" + Lt), Mt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Mt = Mt.slice(1, -1), Mt = lt.stylize(Mt, "name")) : (Mt = Mt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Mt = lt.stylize(Mt, "string"));
      }
      return Mt + ": " + Kt;
    }
    function at(lt, $t, jt) {
      var Jt = lt.reduce(function(Lt, Rt) {
        return Rt.indexOf(`
`) >= 0, Lt + Rt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return Jt > 60 ? jt[0] + ($t === "" ? "" : $t + `
 `) + " " + lt.join(`,
  `) + " " + jt[1] : jt[0] + $t + " " + lt.join(", ") + " " + jt[1];
    }
    A.types = requireTypes();
    function ct(lt) {
      return Array.isArray(lt);
    }
    A.isArray = ct;
    function dt(lt) {
      return typeof lt == "boolean";
    }
    A.isBoolean = dt;
    function ot(lt) {
      return lt === null;
    }
    A.isNull = ot;
    function yt(lt) {
      return lt == null;
    }
    A.isNullOrUndefined = yt;
    function mt(lt) {
      return typeof lt == "number";
    }
    A.isNumber = mt;
    function Tt(lt) {
      return typeof lt == "string";
    }
    A.isString = Tt;
    function Pt(lt) {
      return typeof lt == "symbol";
    }
    A.isSymbol = Pt;
    function Nt(lt) {
      return lt === void 0;
    }
    A.isUndefined = Nt;
    function St(lt) {
      return vt(lt) && pe(lt) === "[object RegExp]";
    }
    A.isRegExp = St, A.types.isRegExp = St;
    function vt(lt) {
      return typeof lt == "object" && lt !== null;
    }
    A.isObject = vt;
    function It(lt) {
      return vt(lt) && pe(lt) === "[object Date]";
    }
    A.isDate = It, A.types.isDate = It;
    function wt(lt) {
      return vt(lt) && (pe(lt) === "[object Error]" || lt instanceof Error);
    }
    A.isError = wt, A.types.isNativeError = wt;
    function Oe(lt) {
      return typeof lt == "function";
    }
    A.isFunction = Oe;
    function rt(lt) {
      return lt === null || typeof lt == "boolean" || typeof lt == "number" || typeof lt == "string" || typeof lt == "symbol" || // ES6 symbol
      typeof lt > "u";
    }
    A.isPrimitive = rt, A.isBuffer = requireIsBufferBrowser();
    function pe(lt) {
      return Object.prototype.toString.call(lt);
    }
    function nt(lt) {
      return lt < 10 ? "0" + lt.toString(10) : lt.toString(10);
    }
    var st = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function ft() {
      var lt = /* @__PURE__ */ new Date(), $t = [
        nt(lt.getHours()),
        nt(lt.getMinutes()),
        nt(lt.getSeconds())
      ].join(":");
      return [lt.getDate(), st[lt.getMonth()], $t].join(" ");
    }
    A.log = function() {
      console.log("%s - %s", ft(), A.format.apply(A, arguments));
    }, A.inherits = requireInherits_browser(), A._extend = function(lt, $t) {
      if (!$t || !vt($t)) return lt;
      for (var jt = Object.keys($t), Jt = jt.length; Jt--; )
        lt[jt[Jt]] = $t[jt[Jt]];
      return lt;
    };
    function ht(lt, $t) {
      return Object.prototype.hasOwnProperty.call(lt, $t);
    }
    var bt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    A.promisify = function($t) {
      if (typeof $t != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (bt && $t[bt]) {
        var jt = $t[bt];
        if (typeof jt != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(jt, bt, {
          value: jt,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), jt;
      }
      function jt() {
        for (var Jt, Lt, Rt = new Promise(function(zt, Ct) {
          Jt = zt, Lt = Ct;
        }), Mt = [], Kt = 0; Kt < arguments.length; Kt++)
          Mt.push(arguments[Kt]);
        Mt.push(function(zt, Ct) {
          zt ? Lt(zt) : Jt(Ct);
        });
        try {
          $t.apply(this, Mt);
        } catch (zt) {
          Lt(zt);
        }
        return Rt;
      }
      return Object.setPrototypeOf(jt, Object.getPrototypeOf($t)), bt && Object.defineProperty(jt, bt, {
        value: jt,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        jt,
        B($t)
      );
    }, A.promisify.custom = bt;
    function ut(lt, $t) {
      if (!lt) {
        var jt = new Error("Promise was rejected with a falsy value");
        jt.reason = lt, lt = jt;
      }
      return $t(lt);
    }
    function gt(lt) {
      if (typeof lt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function $t() {
        for (var jt = [], Jt = 0; Jt < arguments.length; Jt++)
          jt.push(arguments[Jt]);
        var Lt = jt.pop();
        if (typeof Lt != "function")
          throw new TypeError("The last argument must be of type Function");
        var Rt = this, Mt = function() {
          return Lt.apply(Rt, arguments);
        };
        lt.apply(this, jt).then(
          function(Kt) {
            process$1.nextTick(Mt.bind(null, null, Kt));
          },
          function(Kt) {
            process$1.nextTick(ut.bind(null, Kt, Mt));
          }
        );
      }
      return Object.setPrototypeOf($t, Object.getPrototypeOf(lt)), Object.defineProperties(
        $t,
        B(lt)
      ), $t;
    }
    A.callbackify = gt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function A(it, at) {
    var ct = Object.keys(it);
    if (Object.getOwnPropertySymbols) {
      var dt = Object.getOwnPropertySymbols(it);
      at && (dt = dt.filter(function(ot) {
        return Object.getOwnPropertyDescriptor(it, ot).enumerable;
      })), ct.push.apply(ct, dt);
    }
    return ct;
  }
  function B(it) {
    for (var at = 1; at < arguments.length; at++) {
      var ct = arguments[at] != null ? arguments[at] : {};
      at % 2 ? A(Object(ct), !0).forEach(function(dt) {
        L(it, dt, ct[dt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(it, Object.getOwnPropertyDescriptors(ct)) : A(Object(ct)).forEach(function(dt) {
        Object.defineProperty(it, dt, Object.getOwnPropertyDescriptor(ct, dt));
      });
    }
    return it;
  }
  function L(it, at, ct) {
    return at = J(at), at in it ? Object.defineProperty(it, at, { value: ct, enumerable: !0, configurable: !0, writable: !0 }) : it[at] = ct, it;
  }
  function K(it, at) {
    if (!(it instanceof at))
      throw new TypeError("Cannot call a class as a function");
  }
  function V(it, at) {
    for (var ct = 0; ct < at.length; ct++) {
      var dt = at[ct];
      dt.enumerable = dt.enumerable || !1, dt.configurable = !0, "value" in dt && (dt.writable = !0), Object.defineProperty(it, J(dt.key), dt);
    }
  }
  function W(it, at, ct) {
    return at && V(it.prototype, at), Object.defineProperty(it, "prototype", { writable: !1 }), it;
  }
  function J(it) {
    var at = ne(it, "string");
    return typeof at == "symbol" ? at : String(at);
  }
  function ne(it, at) {
    if (typeof it != "object" || it === null) return it;
    var ct = it[Symbol.toPrimitive];
    if (ct !== void 0) {
      var dt = ct.call(it, at);
      if (typeof dt != "object") return dt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(it);
  }
  var ie = dist$1, ce = ie.Buffer, re = requireUtil$1(), oe = re.inspect, ke = oe && oe.custom || "inspect";
  function Ce(it, at, ct) {
    ce.prototype.copy.call(it, at, ct);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function it() {
      K(this, it), this.head = null, this.tail = null, this.length = 0;
    }
    return W(it, [{
      key: "push",
      value: function(ct) {
        var dt = {
          data: ct,
          next: null
        };
        this.length > 0 ? this.tail.next = dt : this.head = dt, this.tail = dt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ct) {
        var dt = {
          data: ct,
          next: this.head
        };
        this.length === 0 && (this.tail = dt), this.head = dt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ct = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ct;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ct) {
        if (this.length === 0) return "";
        for (var dt = this.head, ot = "" + dt.data; dt = dt.next; ) ot += ct + dt.data;
        return ot;
      }
    }, {
      key: "concat",
      value: function(ct) {
        if (this.length === 0) return ce.alloc(0);
        for (var dt = ce.allocUnsafe(ct >>> 0), ot = this.head, yt = 0; ot; )
          Ce(ot.data, dt, yt), yt += ot.data.length, ot = ot.next;
        return dt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ct, dt) {
        var ot;
        return ct < this.head.data.length ? (ot = this.head.data.slice(0, ct), this.head.data = this.head.data.slice(ct)) : ct === this.head.data.length ? ot = this.shift() : ot = dt ? this._getString(ct) : this._getBuffer(ct), ot;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ct) {
        var dt = this.head, ot = 1, yt = dt.data;
        for (ct -= yt.length; dt = dt.next; ) {
          var mt = dt.data, Tt = ct > mt.length ? mt.length : ct;
          if (Tt === mt.length ? yt += mt : yt += mt.slice(0, ct), ct -= Tt, ct === 0) {
            Tt === mt.length ? (++ot, dt.next ? this.head = dt.next : this.head = this.tail = null) : (this.head = dt, dt.data = mt.slice(Tt));
            break;
          }
          ++ot;
        }
        return this.length -= ot, yt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ct) {
        var dt = ce.allocUnsafe(ct), ot = this.head, yt = 1;
        for (ot.data.copy(dt), ct -= ot.data.length; ot = ot.next; ) {
          var mt = ot.data, Tt = ct > mt.length ? mt.length : ct;
          if (mt.copy(dt, dt.length - ct, 0, Tt), ct -= Tt, ct === 0) {
            Tt === mt.length ? (++yt, ot.next ? this.head = ot.next : this.head = this.tail = null) : (this.head = ot, ot.data = mt.slice(Tt));
            break;
          }
          ++yt;
        }
        return this.length -= yt, dt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: ke,
      value: function(ct, dt) {
        return oe(this, B(B({}, dt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), it;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function A(J, ne) {
    var ie = this, ce = this._readableState && this._readableState.destroyed, re = this._writableState && this._writableState.destroyed;
    return ce || re ? (ne ? ne(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(V, this, J)) : process$1.nextTick(V, this, J)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(oe) {
      !ne && oe ? ie._writableState ? ie._writableState.errorEmitted ? process$1.nextTick(L, ie) : (ie._writableState.errorEmitted = !0, process$1.nextTick(B, ie, oe)) : process$1.nextTick(B, ie, oe) : ne ? (process$1.nextTick(L, ie), ne(oe)) : process$1.nextTick(L, ie);
    }), this);
  }
  function B(J, ne) {
    V(J, ne), L(J);
  }
  function L(J) {
    J._writableState && !J._writableState.emitClose || J._readableState && !J._readableState.emitClose || J.emit("close");
  }
  function K() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function V(J, ne) {
    J.emit("error", ne);
  }
  function W(J, ne) {
    var ie = J._readableState, ce = J._writableState;
    ie && ie.autoDestroy || ce && ce.autoDestroy ? J.destroy(ne) : J.emit("error", ne);
  }
  return destroy_1$1 = {
    destroy: A,
    undestroy: K,
    errorOrDestroy: W
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function A(ne, ie) {
    ne.prototype = Object.create(ie.prototype), ne.prototype.constructor = ne, ne.__proto__ = ie;
  }
  var B = {};
  function L(ne, ie, ce) {
    ce || (ce = Error);
    function re(ke, Ce, it) {
      return typeof ie == "string" ? ie : ie(ke, Ce, it);
    }
    var oe = /* @__PURE__ */ function(ke) {
      A(Ce, ke);
      function Ce(it, at, ct) {
        return ke.call(this, re(it, at, ct)) || this;
      }
      return Ce;
    }(ce);
    oe.prototype.name = ce.name, oe.prototype.code = ne, B[ne] = oe;
  }
  function K(ne, ie) {
    if (Array.isArray(ne)) {
      var ce = ne.length;
      return ne = ne.map(function(re) {
        return String(re);
      }), ce > 2 ? "one of ".concat(ie, " ").concat(ne.slice(0, ce - 1).join(", "), ", or ") + ne[ce - 1] : ce === 2 ? "one of ".concat(ie, " ").concat(ne[0], " or ").concat(ne[1]) : "of ".concat(ie, " ").concat(ne[0]);
    } else
      return "of ".concat(ie, " ").concat(String(ne));
  }
  function V(ne, ie, ce) {
    return ne.substr(0, ie.length) === ie;
  }
  function W(ne, ie, ce) {
    return (ce === void 0 || ce > ne.length) && (ce = ne.length), ne.substring(ce - ie.length, ce) === ie;
  }
  function J(ne, ie, ce) {
    return typeof ce != "number" && (ce = 0), ce + ie.length > ne.length ? !1 : ne.indexOf(ie, ce) !== -1;
  }
  return L("ERR_INVALID_OPT_VALUE", function(ne, ie) {
    return 'The value "' + ie + '" is invalid for option "' + ne + '"';
  }, TypeError), L("ERR_INVALID_ARG_TYPE", function(ne, ie, ce) {
    var re;
    typeof ie == "string" && V(ie, "not ") ? (re = "must not be", ie = ie.replace(/^not /, "")) : re = "must be";
    var oe;
    if (W(ne, " argument"))
      oe = "The ".concat(ne, " ").concat(re, " ").concat(K(ie, "type"));
    else {
      var ke = J(ne, ".") ? "property" : "argument";
      oe = 'The "'.concat(ne, '" ').concat(ke, " ").concat(re, " ").concat(K(ie, "type"));
    }
    return oe += ". Received type ".concat(typeof ce), oe;
  }, TypeError), L("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), L("ERR_METHOD_NOT_IMPLEMENTED", function(ne) {
    return "The " + ne + " method is not implemented";
  }), L("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), L("ERR_STREAM_DESTROYED", function(ne) {
    return "Cannot call " + ne + " after a stream was destroyed";
  }), L("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), L("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), L("ERR_STREAM_WRITE_AFTER_END", "write after end"), L("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), L("ERR_UNKNOWN_ENCODING", function(ne) {
    return "Unknown encoding: " + ne;
  }, TypeError), L("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = B, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var A = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function B(K, V, W) {
    return K.highWaterMark != null ? K.highWaterMark : V ? K[W] : null;
  }
  function L(K, V, W, J) {
    var ne = B(V, J, W);
    if (ne != null) {
      if (!(isFinite(ne) && Math.floor(ne) === ne) || ne < 0) {
        var ie = J ? W : "highWaterMark";
        throw new A(ie, ne);
      }
      return Math.floor(ne);
    }
    return K.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: L
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = A;
  function A(L, K) {
    if (B("noDeprecation"))
      return L;
    var V = !1;
    function W() {
      if (!V) {
        if (B("throwDeprecation"))
          throw new Error(K);
        B("traceDeprecation") ? console.trace(K) : console.warn(K), V = !0;
      }
      return L.apply(this, arguments);
    }
    return W;
  }
  function B(L) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[L];
    return K == null ? !1 : String(K).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = St;
  function A(Lt) {
    var Rt = this;
    this.next = null, this.entry = null, this.finish = function() {
      Jt(Rt, Lt);
    };
  }
  var B;
  St.WritableState = Pt;
  var L = {
    deprecate: requireBrowser$a()
  }, K = requireStreamBrowser$1(), V = dist$1.Buffer, W = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function J(Lt) {
    return V.from(Lt);
  }
  function ne(Lt) {
    return V.isBuffer(Lt) || Lt instanceof W;
  }
  var ie = requireDestroy$1(), ce = requireState(), re = ce.getHighWaterMark, oe = requireErrorsBrowser().codes, ke = oe.ERR_INVALID_ARG_TYPE, Ce = oe.ERR_METHOD_NOT_IMPLEMENTED, it = oe.ERR_MULTIPLE_CALLBACK, at = oe.ERR_STREAM_CANNOT_PIPE, ct = oe.ERR_STREAM_DESTROYED, dt = oe.ERR_STREAM_NULL_VALUES, ot = oe.ERR_STREAM_WRITE_AFTER_END, yt = oe.ERR_UNKNOWN_ENCODING, mt = ie.errorOrDestroy;
  requireInherits_browser()(St, K);
  function Tt() {
  }
  function Pt(Lt, Rt, Mt) {
    B = B || require_stream_duplex$1(), Lt = Lt || {}, typeof Mt != "boolean" && (Mt = Rt instanceof B), this.objectMode = !!Lt.objectMode, Mt && (this.objectMode = this.objectMode || !!Lt.writableObjectMode), this.highWaterMark = re(this, Lt, "writableHighWaterMark", Mt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Kt = Lt.decodeStrings === !1;
    this.decodeStrings = !Kt, this.defaultEncoding = Lt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(zt) {
      st(Rt, zt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Lt.emitClose !== !1, this.autoDestroy = !!Lt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
  }
  Pt.prototype.getBuffer = function() {
    for (var Rt = this.bufferedRequest, Mt = []; Rt; )
      Mt.push(Rt), Rt = Rt.next;
    return Mt;
  }, function() {
    try {
      Object.defineProperty(Pt.prototype, "buffer", {
        get: L.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Nt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Nt = Function.prototype[Symbol.hasInstance], Object.defineProperty(St, Symbol.hasInstance, {
    value: function(Rt) {
      return Nt.call(this, Rt) ? !0 : this !== St ? !1 : Rt && Rt._writableState instanceof Pt;
    }
  })) : Nt = function(Rt) {
    return Rt instanceof this;
  };
  function St(Lt) {
    B = B || require_stream_duplex$1();
    var Rt = this instanceof B;
    if (!Rt && !Nt.call(St, this)) return new St(Lt);
    this._writableState = new Pt(Lt, this, Rt), this.writable = !0, Lt && (typeof Lt.write == "function" && (this._write = Lt.write), typeof Lt.writev == "function" && (this._writev = Lt.writev), typeof Lt.destroy == "function" && (this._destroy = Lt.destroy), typeof Lt.final == "function" && (this._final = Lt.final)), K.call(this);
  }
  St.prototype.pipe = function() {
    mt(this, new at());
  };
  function vt(Lt, Rt) {
    var Mt = new ot();
    mt(Lt, Mt), process$1.nextTick(Rt, Mt);
  }
  function It(Lt, Rt, Mt, Kt) {
    var zt;
    return Mt === null ? zt = new dt() : typeof Mt != "string" && !Rt.objectMode && (zt = new ke("chunk", ["string", "Buffer"], Mt)), zt ? (mt(Lt, zt), process$1.nextTick(Kt, zt), !1) : !0;
  }
  St.prototype.write = function(Lt, Rt, Mt) {
    var Kt = this._writableState, zt = !1, Ct = !Kt.objectMode && ne(Lt);
    return Ct && !V.isBuffer(Lt) && (Lt = J(Lt)), typeof Rt == "function" && (Mt = Rt, Rt = null), Ct ? Rt = "buffer" : Rt || (Rt = Kt.defaultEncoding), typeof Mt != "function" && (Mt = Tt), Kt.ending ? vt(this, Mt) : (Ct || It(this, Kt, Lt, Mt)) && (Kt.pendingcb++, zt = Oe(this, Kt, Ct, Lt, Rt, Mt)), zt;
  }, St.prototype.cork = function() {
    this._writableState.corked++;
  }, St.prototype.uncork = function() {
    var Lt = this._writableState;
    Lt.corked && (Lt.corked--, !Lt.writing && !Lt.corked && !Lt.bufferProcessing && Lt.bufferedRequest && bt(this, Lt));
  }, St.prototype.setDefaultEncoding = function(Rt) {
    if (typeof Rt == "string" && (Rt = Rt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Rt + "").toLowerCase()) > -1)) throw new yt(Rt);
    return this._writableState.defaultEncoding = Rt, this;
  }, Object.defineProperty(St.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function wt(Lt, Rt, Mt) {
    return !Lt.objectMode && Lt.decodeStrings !== !1 && typeof Rt == "string" && (Rt = V.from(Rt, Mt)), Rt;
  }
  Object.defineProperty(St.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Oe(Lt, Rt, Mt, Kt, zt, Ct) {
    if (!Mt) {
      var kt = wt(Rt, Kt, zt);
      Kt !== kt && (Mt = !0, zt = "buffer", Kt = kt);
    }
    var Vt = Rt.objectMode ? 1 : Kt.length;
    Rt.length += Vt;
    var nr = Rt.length < Rt.highWaterMark;
    if (nr || (Rt.needDrain = !0), Rt.writing || Rt.corked) {
      var ar = Rt.lastBufferedRequest;
      Rt.lastBufferedRequest = {
        chunk: Kt,
        encoding: zt,
        isBuf: Mt,
        callback: Ct,
        next: null
      }, ar ? ar.next = Rt.lastBufferedRequest : Rt.bufferedRequest = Rt.lastBufferedRequest, Rt.bufferedRequestCount += 1;
    } else
      rt(Lt, Rt, !1, Vt, Kt, zt, Ct);
    return nr;
  }
  function rt(Lt, Rt, Mt, Kt, zt, Ct, kt) {
    Rt.writelen = Kt, Rt.writecb = kt, Rt.writing = !0, Rt.sync = !0, Rt.destroyed ? Rt.onwrite(new ct("write")) : Mt ? Lt._writev(zt, Rt.onwrite) : Lt._write(zt, Ct, Rt.onwrite), Rt.sync = !1;
  }
  function pe(Lt, Rt, Mt, Kt, zt) {
    --Rt.pendingcb, Mt ? (process$1.nextTick(zt, Kt), process$1.nextTick($t, Lt, Rt), Lt._writableState.errorEmitted = !0, mt(Lt, Kt)) : (zt(Kt), Lt._writableState.errorEmitted = !0, mt(Lt, Kt), $t(Lt, Rt));
  }
  function nt(Lt) {
    Lt.writing = !1, Lt.writecb = null, Lt.length -= Lt.writelen, Lt.writelen = 0;
  }
  function st(Lt, Rt) {
    var Mt = Lt._writableState, Kt = Mt.sync, zt = Mt.writecb;
    if (typeof zt != "function") throw new it();
    if (nt(Mt), Rt) pe(Lt, Mt, Kt, Rt, zt);
    else {
      var Ct = ut(Mt) || Lt.destroyed;
      !Ct && !Mt.corked && !Mt.bufferProcessing && Mt.bufferedRequest && bt(Lt, Mt), Kt ? process$1.nextTick(ft, Lt, Mt, Ct, zt) : ft(Lt, Mt, Ct, zt);
    }
  }
  function ft(Lt, Rt, Mt, Kt) {
    Mt || ht(Lt, Rt), Rt.pendingcb--, Kt(), $t(Lt, Rt);
  }
  function ht(Lt, Rt) {
    Rt.length === 0 && Rt.needDrain && (Rt.needDrain = !1, Lt.emit("drain"));
  }
  function bt(Lt, Rt) {
    Rt.bufferProcessing = !0;
    var Mt = Rt.bufferedRequest;
    if (Lt._writev && Mt && Mt.next) {
      var Kt = Rt.bufferedRequestCount, zt = new Array(Kt), Ct = Rt.corkedRequestsFree;
      Ct.entry = Mt;
      for (var kt = 0, Vt = !0; Mt; )
        zt[kt] = Mt, Mt.isBuf || (Vt = !1), Mt = Mt.next, kt += 1;
      zt.allBuffers = Vt, rt(Lt, Rt, !0, Rt.length, zt, "", Ct.finish), Rt.pendingcb++, Rt.lastBufferedRequest = null, Ct.next ? (Rt.corkedRequestsFree = Ct.next, Ct.next = null) : Rt.corkedRequestsFree = new A(Rt), Rt.bufferedRequestCount = 0;
    } else {
      for (; Mt; ) {
        var nr = Mt.chunk, ar = Mt.encoding, sr = Mt.callback, lr = Rt.objectMode ? 1 : nr.length;
        if (rt(Lt, Rt, !1, lr, nr, ar, sr), Mt = Mt.next, Rt.bufferedRequestCount--, Rt.writing)
          break;
      }
      Mt === null && (Rt.lastBufferedRequest = null);
    }
    Rt.bufferedRequest = Mt, Rt.bufferProcessing = !1;
  }
  St.prototype._write = function(Lt, Rt, Mt) {
    Mt(new Ce("_write()"));
  }, St.prototype._writev = null, St.prototype.end = function(Lt, Rt, Mt) {
    var Kt = this._writableState;
    return typeof Lt == "function" ? (Mt = Lt, Lt = null, Rt = null) : typeof Rt == "function" && (Mt = Rt, Rt = null), Lt != null && this.write(Lt, Rt), Kt.corked && (Kt.corked = 1, this.uncork()), Kt.ending || jt(this, Kt, Mt), this;
  }, Object.defineProperty(St.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ut(Lt) {
    return Lt.ending && Lt.length === 0 && Lt.bufferedRequest === null && !Lt.finished && !Lt.writing;
  }
  function gt(Lt, Rt) {
    Lt._final(function(Mt) {
      Rt.pendingcb--, Mt && mt(Lt, Mt), Rt.prefinished = !0, Lt.emit("prefinish"), $t(Lt, Rt);
    });
  }
  function lt(Lt, Rt) {
    !Rt.prefinished && !Rt.finalCalled && (typeof Lt._final == "function" && !Rt.destroyed ? (Rt.pendingcb++, Rt.finalCalled = !0, process$1.nextTick(gt, Lt, Rt)) : (Rt.prefinished = !0, Lt.emit("prefinish")));
  }
  function $t(Lt, Rt) {
    var Mt = ut(Rt);
    if (Mt && (lt(Lt, Rt), Rt.pendingcb === 0 && (Rt.finished = !0, Lt.emit("finish"), Rt.autoDestroy))) {
      var Kt = Lt._readableState;
      (!Kt || Kt.autoDestroy && Kt.endEmitted) && Lt.destroy();
    }
    return Mt;
  }
  function jt(Lt, Rt, Mt) {
    Rt.ending = !0, $t(Lt, Rt), Mt && (Rt.finished ? process$1.nextTick(Mt) : Lt.once("finish", Mt)), Rt.ended = !0, Lt.writable = !1;
  }
  function Jt(Lt, Rt, Mt) {
    var Kt = Lt.entry;
    for (Lt.entry = null; Kt; ) {
      var zt = Kt.callback;
      Rt.pendingcb--, zt(Mt), Kt = Kt.next;
    }
    Rt.corkedRequestsFree.next = Lt;
  }
  return Object.defineProperty(St.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Rt) {
      this._writableState && (this._writableState.destroyed = Rt);
    }
  }), St.prototype.destroy = ie.destroy, St.prototype._undestroy = ie.undestroy, St.prototype._destroy = function(Lt, Rt) {
    Rt(Lt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var A = Object.keys || function(ce) {
    var re = [];
    for (var oe in ce) re.push(oe);
    return re;
  };
  _stream_duplex$1 = J;
  var B = require_stream_readable$1(), L = require_stream_writable$1();
  requireInherits_browser()(J, B);
  for (var K = A(L.prototype), V = 0; V < K.length; V++) {
    var W = K[V];
    J.prototype[W] || (J.prototype[W] = L.prototype[W]);
  }
  function J(ce) {
    if (!(this instanceof J)) return new J(ce);
    B.call(this, ce), L.call(this, ce), this.allowHalfOpen = !0, ce && (ce.readable === !1 && (this.readable = !1), ce.writable === !1 && (this.writable = !1), ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ne)));
  }
  Object.defineProperty(J.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(J.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(J.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ne() {
    this._writableState.ended || process$1.nextTick(ie, this);
  }
  function ie(ce) {
    ce.end();
  }
  return Object.defineProperty(J.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(re) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = re, this._writableState.destroyed = re);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var A = safeBufferExports.Buffer, B = A.isEncoding || function(dt) {
    switch (dt = "" + dt, dt && dt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function L(dt) {
    if (!dt) return "utf8";
    for (var ot; ; )
      switch (dt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return dt;
        default:
          if (ot) return;
          dt = ("" + dt).toLowerCase(), ot = !0;
      }
  }
  function K(dt) {
    var ot = L(dt);
    if (typeof ot != "string" && (A.isEncoding === B || !B(dt))) throw new Error("Unknown encoding: " + dt);
    return ot || dt;
  }
  string_decoder.StringDecoder = V;
  function V(dt) {
    this.encoding = K(dt);
    var ot;
    switch (this.encoding) {
      case "utf16le":
        this.text = oe, this.end = ke, ot = 4;
        break;
      case "utf8":
        this.fillLast = ie, ot = 4;
        break;
      case "base64":
        this.text = Ce, this.end = it, ot = 3;
        break;
      default:
        this.write = at, this.end = ct;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = A.allocUnsafe(ot);
  }
  V.prototype.write = function(dt) {
    if (dt.length === 0) return "";
    var ot, yt;
    if (this.lastNeed) {
      if (ot = this.fillLast(dt), ot === void 0) return "";
      yt = this.lastNeed, this.lastNeed = 0;
    } else
      yt = 0;
    return yt < dt.length ? ot ? ot + this.text(dt, yt) : this.text(dt, yt) : ot || "";
  }, V.prototype.end = re, V.prototype.text = ce, V.prototype.fillLast = function(dt) {
    if (this.lastNeed <= dt.length)
      return dt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    dt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, dt.length), this.lastNeed -= dt.length;
  };
  function W(dt) {
    return dt <= 127 ? 0 : dt >> 5 === 6 ? 2 : dt >> 4 === 14 ? 3 : dt >> 3 === 30 ? 4 : dt >> 6 === 2 ? -1 : -2;
  }
  function J(dt, ot, yt) {
    var mt = ot.length - 1;
    if (mt < yt) return 0;
    var Tt = W(ot[mt]);
    return Tt >= 0 ? (Tt > 0 && (dt.lastNeed = Tt - 1), Tt) : --mt < yt || Tt === -2 ? 0 : (Tt = W(ot[mt]), Tt >= 0 ? (Tt > 0 && (dt.lastNeed = Tt - 2), Tt) : --mt < yt || Tt === -2 ? 0 : (Tt = W(ot[mt]), Tt >= 0 ? (Tt > 0 && (Tt === 2 ? Tt = 0 : dt.lastNeed = Tt - 3), Tt) : 0));
  }
  function ne(dt, ot, yt) {
    if ((ot[0] & 192) !== 128)
      return dt.lastNeed = 0, "�";
    if (dt.lastNeed > 1 && ot.length > 1) {
      if ((ot[1] & 192) !== 128)
        return dt.lastNeed = 1, "�";
      if (dt.lastNeed > 2 && ot.length > 2 && (ot[2] & 192) !== 128)
        return dt.lastNeed = 2, "�";
    }
  }
  function ie(dt) {
    var ot = this.lastTotal - this.lastNeed, yt = ne(this, dt);
    if (yt !== void 0) return yt;
    if (this.lastNeed <= dt.length)
      return dt.copy(this.lastChar, ot, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    dt.copy(this.lastChar, ot, 0, dt.length), this.lastNeed -= dt.length;
  }
  function ce(dt, ot) {
    var yt = J(this, dt, ot);
    if (!this.lastNeed) return dt.toString("utf8", ot);
    this.lastTotal = yt;
    var mt = dt.length - (yt - this.lastNeed);
    return dt.copy(this.lastChar, 0, mt), dt.toString("utf8", ot, mt);
  }
  function re(dt) {
    var ot = dt && dt.length ? this.write(dt) : "";
    return this.lastNeed ? ot + "�" : ot;
  }
  function oe(dt, ot) {
    if ((dt.length - ot) % 2 === 0) {
      var yt = dt.toString("utf16le", ot);
      if (yt) {
        var mt = yt.charCodeAt(yt.length - 1);
        if (mt >= 55296 && mt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = dt[dt.length - 2], this.lastChar[1] = dt[dt.length - 1], yt.slice(0, -1);
      }
      return yt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = dt[dt.length - 1], dt.toString("utf16le", ot, dt.length - 1);
  }
  function ke(dt) {
    var ot = dt && dt.length ? this.write(dt) : "";
    if (this.lastNeed) {
      var yt = this.lastTotal - this.lastNeed;
      return ot + this.lastChar.toString("utf16le", 0, yt);
    }
    return ot;
  }
  function Ce(dt, ot) {
    var yt = (dt.length - ot) % 3;
    return yt === 0 ? dt.toString("base64", ot) : (this.lastNeed = 3 - yt, this.lastTotal = 3, yt === 1 ? this.lastChar[0] = dt[dt.length - 1] : (this.lastChar[0] = dt[dt.length - 2], this.lastChar[1] = dt[dt.length - 1]), dt.toString("base64", ot, dt.length - yt));
  }
  function it(dt) {
    var ot = dt && dt.length ? this.write(dt) : "";
    return this.lastNeed ? ot + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ot;
  }
  function at(dt) {
    return dt.toString(this.encoding);
  }
  function ct(dt) {
    return dt && dt.length ? this.write(dt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var A = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function B(W) {
    var J = !1;
    return function() {
      if (!J) {
        J = !0;
        for (var ne = arguments.length, ie = new Array(ne), ce = 0; ce < ne; ce++)
          ie[ce] = arguments[ce];
        W.apply(this, ie);
      }
    };
  }
  function L() {
  }
  function K(W) {
    return W.setHeader && typeof W.abort == "function";
  }
  function V(W, J, ne) {
    if (typeof J == "function") return V(W, null, J);
    J || (J = {}), ne = B(ne || L);
    var ie = J.readable || J.readable !== !1 && W.readable, ce = J.writable || J.writable !== !1 && W.writable, re = function() {
      W.writable || ke();
    }, oe = W._writableState && W._writableState.finished, ke = function() {
      ce = !1, oe = !0, ie || ne.call(W);
    }, Ce = W._readableState && W._readableState.endEmitted, it = function() {
      ie = !1, Ce = !0, ce || ne.call(W);
    }, at = function(yt) {
      ne.call(W, yt);
    }, ct = function() {
      var yt;
      if (ie && !Ce)
        return (!W._readableState || !W._readableState.ended) && (yt = new A()), ne.call(W, yt);
      if (ce && !oe)
        return (!W._writableState || !W._writableState.ended) && (yt = new A()), ne.call(W, yt);
    }, dt = function() {
      W.req.on("finish", ke);
    };
    return K(W) ? (W.on("complete", ke), W.on("abort", ct), W.req ? dt() : W.on("request", dt)) : ce && !W._writableState && (W.on("end", re), W.on("close", re)), W.on("end", it), W.on("finish", ke), J.error !== !1 && W.on("error", at), W.on("close", ct), function() {
      W.removeListener("complete", ke), W.removeListener("abort", ct), W.removeListener("request", dt), W.req && W.req.removeListener("finish", ke), W.removeListener("end", re), W.removeListener("close", re), W.removeListener("finish", ke), W.removeListener("end", it), W.removeListener("error", at), W.removeListener("close", ct);
    };
  }
  return endOfStream = V, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var A;
  function B(yt, mt, Tt) {
    return mt = L(mt), mt in yt ? Object.defineProperty(yt, mt, { value: Tt, enumerable: !0, configurable: !0, writable: !0 }) : yt[mt] = Tt, yt;
  }
  function L(yt) {
    var mt = K(yt, "string");
    return typeof mt == "symbol" ? mt : String(mt);
  }
  function K(yt, mt) {
    if (typeof yt != "object" || yt === null) return yt;
    var Tt = yt[Symbol.toPrimitive];
    if (Tt !== void 0) {
      var Pt = Tt.call(yt, mt);
      if (typeof Pt != "object") return Pt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (mt === "string" ? String : Number)(yt);
  }
  var V = requireEndOfStream(), W = Symbol("lastResolve"), J = Symbol("lastReject"), ne = Symbol("error"), ie = Symbol("ended"), ce = Symbol("lastPromise"), re = Symbol("handlePromise"), oe = Symbol("stream");
  function ke(yt, mt) {
    return {
      value: yt,
      done: mt
    };
  }
  function Ce(yt) {
    var mt = yt[W];
    if (mt !== null) {
      var Tt = yt[oe].read();
      Tt !== null && (yt[ce] = null, yt[W] = null, yt[J] = null, mt(ke(Tt, !1)));
    }
  }
  function it(yt) {
    process$1.nextTick(Ce, yt);
  }
  function at(yt, mt) {
    return function(Tt, Pt) {
      yt.then(function() {
        if (mt[ie]) {
          Tt(ke(void 0, !0));
          return;
        }
        mt[re](Tt, Pt);
      }, Pt);
    };
  }
  var ct = Object.getPrototypeOf(function() {
  }), dt = Object.setPrototypeOf((A = {
    get stream() {
      return this[oe];
    },
    next: function() {
      var mt = this, Tt = this[ne];
      if (Tt !== null)
        return Promise.reject(Tt);
      if (this[ie])
        return Promise.resolve(ke(void 0, !0));
      if (this[oe].destroyed)
        return new Promise(function(vt, It) {
          process$1.nextTick(function() {
            mt[ne] ? It(mt[ne]) : vt(ke(void 0, !0));
          });
        });
      var Pt = this[ce], Nt;
      if (Pt)
        Nt = new Promise(at(Pt, this));
      else {
        var St = this[oe].read();
        if (St !== null)
          return Promise.resolve(ke(St, !1));
        Nt = new Promise(this[re]);
      }
      return this[ce] = Nt, Nt;
    }
  }, B(A, Symbol.asyncIterator, function() {
    return this;
  }), B(A, "return", function() {
    var mt = this;
    return new Promise(function(Tt, Pt) {
      mt[oe].destroy(null, function(Nt) {
        if (Nt) {
          Pt(Nt);
          return;
        }
        Tt(ke(void 0, !0));
      });
    });
  }), A), ct), ot = function(mt) {
    var Tt, Pt = Object.create(dt, (Tt = {}, B(Tt, oe, {
      value: mt,
      writable: !0
    }), B(Tt, W, {
      value: null,
      writable: !0
    }), B(Tt, J, {
      value: null,
      writable: !0
    }), B(Tt, ne, {
      value: null,
      writable: !0
    }), B(Tt, ie, {
      value: mt._readableState.endEmitted,
      writable: !0
    }), B(Tt, re, {
      value: function(St, vt) {
        var It = Pt[oe].read();
        It ? (Pt[ce] = null, Pt[W] = null, Pt[J] = null, St(ke(It, !1))) : (Pt[W] = St, Pt[J] = vt);
      },
      writable: !0
    }), Tt));
    return Pt[ce] = null, V(mt, function(Nt) {
      if (Nt && Nt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var St = Pt[J];
        St !== null && (Pt[ce] = null, Pt[W] = null, Pt[J] = null, St(Nt)), Pt[ne] = Nt;
        return;
      }
      var vt = Pt[W];
      vt !== null && (Pt[ce] = null, Pt[W] = null, Pt[J] = null, vt(ke(void 0, !0))), Pt[ie] = !0;
    }), mt.on("readable", it.bind(null, Pt)), Pt;
  };
  return async_iterator = ot, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = vt;
  var A;
  vt.ReadableState = St, requireEvents().EventEmitter;
  var B = function(kt, Vt) {
    return kt.listeners(Vt).length;
  }, L = requireStreamBrowser$1(), K = dist$1.Buffer, V = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function W(Ct) {
    return K.from(Ct);
  }
  function J(Ct) {
    return K.isBuffer(Ct) || Ct instanceof V;
  }
  var ne = requireUtil$1(), ie;
  ne && ne.debuglog ? ie = ne.debuglog("stream") : ie = function() {
  };
  var ce = requireBuffer_list(), re = requireDestroy$1(), oe = requireState(), ke = oe.getHighWaterMark, Ce = requireErrorsBrowser().codes, it = Ce.ERR_INVALID_ARG_TYPE, at = Ce.ERR_STREAM_PUSH_AFTER_EOF, ct = Ce.ERR_METHOD_NOT_IMPLEMENTED, dt = Ce.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ot, yt, mt;
  requireInherits_browser()(vt, L);
  var Tt = re.errorOrDestroy, Pt = ["error", "close", "destroy", "pause", "resume"];
  function Nt(Ct, kt, Vt) {
    if (typeof Ct.prependListener == "function") return Ct.prependListener(kt, Vt);
    !Ct._events || !Ct._events[kt] ? Ct.on(kt, Vt) : Array.isArray(Ct._events[kt]) ? Ct._events[kt].unshift(Vt) : Ct._events[kt] = [Vt, Ct._events[kt]];
  }
  function St(Ct, kt, Vt) {
    A = A || require_stream_duplex$1(), Ct = Ct || {}, typeof Vt != "boolean" && (Vt = kt instanceof A), this.objectMode = !!Ct.objectMode, Vt && (this.objectMode = this.objectMode || !!Ct.readableObjectMode), this.highWaterMark = ke(this, Ct, "readableHighWaterMark", Vt), this.buffer = new ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Ct.emitClose !== !1, this.autoDestroy = !!Ct.autoDestroy, this.destroyed = !1, this.defaultEncoding = Ct.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ct.encoding && (ot || (ot = requireString_decoder().StringDecoder), this.decoder = new ot(Ct.encoding), this.encoding = Ct.encoding);
  }
  function vt(Ct) {
    if (A = A || require_stream_duplex$1(), !(this instanceof vt)) return new vt(Ct);
    var kt = this instanceof A;
    this._readableState = new St(Ct, this, kt), this.readable = !0, Ct && (typeof Ct.read == "function" && (this._read = Ct.read), typeof Ct.destroy == "function" && (this._destroy = Ct.destroy)), L.call(this);
  }
  Object.defineProperty(vt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(kt) {
      this._readableState && (this._readableState.destroyed = kt);
    }
  }), vt.prototype.destroy = re.destroy, vt.prototype._undestroy = re.undestroy, vt.prototype._destroy = function(Ct, kt) {
    kt(Ct);
  }, vt.prototype.push = function(Ct, kt) {
    var Vt = this._readableState, nr;
    return Vt.objectMode ? nr = !0 : typeof Ct == "string" && (kt = kt || Vt.defaultEncoding, kt !== Vt.encoding && (Ct = K.from(Ct, kt), kt = ""), nr = !0), It(this, Ct, kt, !1, nr);
  }, vt.prototype.unshift = function(Ct) {
    return It(this, Ct, null, !0, !1);
  };
  function It(Ct, kt, Vt, nr, ar) {
    ie("readableAddChunk", kt);
    var sr = Ct._readableState;
    if (kt === null)
      sr.reading = !1, st(Ct, sr);
    else {
      var lr;
      if (ar || (lr = Oe(sr, kt)), lr)
        Tt(Ct, lr);
      else if (sr.objectMode || kt && kt.length > 0)
        if (typeof kt != "string" && !sr.objectMode && Object.getPrototypeOf(kt) !== K.prototype && (kt = W(kt)), nr)
          sr.endEmitted ? Tt(Ct, new dt()) : wt(Ct, sr, kt, !0);
        else if (sr.ended)
          Tt(Ct, new at());
        else {
          if (sr.destroyed)
            return !1;
          sr.reading = !1, sr.decoder && !Vt ? (kt = sr.decoder.write(kt), sr.objectMode || kt.length !== 0 ? wt(Ct, sr, kt, !1) : bt(Ct, sr)) : wt(Ct, sr, kt, !1);
        }
      else nr || (sr.reading = !1, bt(Ct, sr));
    }
    return !sr.ended && (sr.length < sr.highWaterMark || sr.length === 0);
  }
  function wt(Ct, kt, Vt, nr) {
    kt.flowing && kt.length === 0 && !kt.sync ? (kt.awaitDrain = 0, Ct.emit("data", Vt)) : (kt.length += kt.objectMode ? 1 : Vt.length, nr ? kt.buffer.unshift(Vt) : kt.buffer.push(Vt), kt.needReadable && ft(Ct)), bt(Ct, kt);
  }
  function Oe(Ct, kt) {
    var Vt;
    return !J(kt) && typeof kt != "string" && kt !== void 0 && !Ct.objectMode && (Vt = new it("chunk", ["string", "Buffer", "Uint8Array"], kt)), Vt;
  }
  vt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, vt.prototype.setEncoding = function(Ct) {
    ot || (ot = requireString_decoder().StringDecoder);
    var kt = new ot(Ct);
    this._readableState.decoder = kt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Vt = this._readableState.buffer.head, nr = ""; Vt !== null; )
      nr += kt.write(Vt.data), Vt = Vt.next;
    return this._readableState.buffer.clear(), nr !== "" && this._readableState.buffer.push(nr), this._readableState.length = nr.length, this;
  };
  var rt = 1073741824;
  function pe(Ct) {
    return Ct >= rt ? Ct = rt : (Ct--, Ct |= Ct >>> 1, Ct |= Ct >>> 2, Ct |= Ct >>> 4, Ct |= Ct >>> 8, Ct |= Ct >>> 16, Ct++), Ct;
  }
  function nt(Ct, kt) {
    return Ct <= 0 || kt.length === 0 && kt.ended ? 0 : kt.objectMode ? 1 : Ct !== Ct ? kt.flowing && kt.length ? kt.buffer.head.data.length : kt.length : (Ct > kt.highWaterMark && (kt.highWaterMark = pe(Ct)), Ct <= kt.length ? Ct : kt.ended ? kt.length : (kt.needReadable = !0, 0));
  }
  vt.prototype.read = function(Ct) {
    ie("read", Ct), Ct = parseInt(Ct, 10);
    var kt = this._readableState, Vt = Ct;
    if (Ct !== 0 && (kt.emittedReadable = !1), Ct === 0 && kt.needReadable && ((kt.highWaterMark !== 0 ? kt.length >= kt.highWaterMark : kt.length > 0) || kt.ended))
      return ie("read: emitReadable", kt.length, kt.ended), kt.length === 0 && kt.ended ? Mt(this) : ft(this), null;
    if (Ct = nt(Ct, kt), Ct === 0 && kt.ended)
      return kt.length === 0 && Mt(this), null;
    var nr = kt.needReadable;
    ie("need readable", nr), (kt.length === 0 || kt.length - Ct < kt.highWaterMark) && (nr = !0, ie("length less than watermark", nr)), kt.ended || kt.reading ? (nr = !1, ie("reading or ended", nr)) : nr && (ie("do read"), kt.reading = !0, kt.sync = !0, kt.length === 0 && (kt.needReadable = !0), this._read(kt.highWaterMark), kt.sync = !1, kt.reading || (Ct = nt(Vt, kt)));
    var ar;
    return Ct > 0 ? ar = Rt(Ct, kt) : ar = null, ar === null ? (kt.needReadable = kt.length <= kt.highWaterMark, Ct = 0) : (kt.length -= Ct, kt.awaitDrain = 0), kt.length === 0 && (kt.ended || (kt.needReadable = !0), Vt !== Ct && kt.ended && Mt(this)), ar !== null && this.emit("data", ar), ar;
  };
  function st(Ct, kt) {
    if (ie("onEofChunk"), !kt.ended) {
      if (kt.decoder) {
        var Vt = kt.decoder.end();
        Vt && Vt.length && (kt.buffer.push(Vt), kt.length += kt.objectMode ? 1 : Vt.length);
      }
      kt.ended = !0, kt.sync ? ft(Ct) : (kt.needReadable = !1, kt.emittedReadable || (kt.emittedReadable = !0, ht(Ct)));
    }
  }
  function ft(Ct) {
    var kt = Ct._readableState;
    ie("emitReadable", kt.needReadable, kt.emittedReadable), kt.needReadable = !1, kt.emittedReadable || (ie("emitReadable", kt.flowing), kt.emittedReadable = !0, process$1.nextTick(ht, Ct));
  }
  function ht(Ct) {
    var kt = Ct._readableState;
    ie("emitReadable_", kt.destroyed, kt.length, kt.ended), !kt.destroyed && (kt.length || kt.ended) && (Ct.emit("readable"), kt.emittedReadable = !1), kt.needReadable = !kt.flowing && !kt.ended && kt.length <= kt.highWaterMark, Lt(Ct);
  }
  function bt(Ct, kt) {
    kt.readingMore || (kt.readingMore = !0, process$1.nextTick(ut, Ct, kt));
  }
  function ut(Ct, kt) {
    for (; !kt.reading && !kt.ended && (kt.length < kt.highWaterMark || kt.flowing && kt.length === 0); ) {
      var Vt = kt.length;
      if (ie("maybeReadMore read 0"), Ct.read(0), Vt === kt.length)
        break;
    }
    kt.readingMore = !1;
  }
  vt.prototype._read = function(Ct) {
    Tt(this, new ct("_read()"));
  }, vt.prototype.pipe = function(Ct, kt) {
    var Vt = this, nr = this._readableState;
    switch (nr.pipesCount) {
      case 0:
        nr.pipes = Ct;
        break;
      case 1:
        nr.pipes = [nr.pipes, Ct];
        break;
      default:
        nr.pipes.push(Ct);
        break;
    }
    nr.pipesCount += 1, ie("pipe count=%d opts=%j", nr.pipesCount, kt);
    var ar = (!kt || kt.end !== !1) && Ct !== process$1.stdout && Ct !== process$1.stderr, sr = ar ? dr : Mr;
    nr.endEmitted ? process$1.nextTick(sr) : Vt.once("end", sr), Ct.on("unpipe", lr);
    function lr(_r, Rr) {
      ie("onunpipe"), _r === Vt && Rr && Rr.hasUnpiped === !1 && (Rr.hasUnpiped = !0, ur());
    }
    function dr() {
      ie("onend"), Ct.end();
    }
    var rr = gt(Vt);
    Ct.on("drain", rr);
    var Pr = !1;
    function ur() {
      ie("cleanup"), Ct.removeListener("close", hr), Ct.removeListener("finish", xr), Ct.removeListener("drain", rr), Ct.removeListener("error", br), Ct.removeListener("unpipe", lr), Vt.removeListener("end", dr), Vt.removeListener("end", Mr), Vt.removeListener("data", pr), Pr = !0, nr.awaitDrain && (!Ct._writableState || Ct._writableState.needDrain) && rr();
    }
    Vt.on("data", pr);
    function pr(_r) {
      ie("ondata");
      var Rr = Ct.write(_r);
      ie("dest.write", Rr), Rr === !1 && ((nr.pipesCount === 1 && nr.pipes === Ct || nr.pipesCount > 1 && zt(nr.pipes, Ct) !== -1) && !Pr && (ie("false write response, pause", nr.awaitDrain), nr.awaitDrain++), Vt.pause());
    }
    function br(_r) {
      ie("onerror", _r), Mr(), Ct.removeListener("error", br), B(Ct, "error") === 0 && Tt(Ct, _r);
    }
    Nt(Ct, "error", br);
    function hr() {
      Ct.removeListener("finish", xr), Mr();
    }
    Ct.once("close", hr);
    function xr() {
      ie("onfinish"), Ct.removeListener("close", hr), Mr();
    }
    Ct.once("finish", xr);
    function Mr() {
      ie("unpipe"), Vt.unpipe(Ct);
    }
    return Ct.emit("pipe", Vt), nr.flowing || (ie("pipe resume"), Vt.resume()), Ct;
  };
  function gt(Ct) {
    return function() {
      var Vt = Ct._readableState;
      ie("pipeOnDrain", Vt.awaitDrain), Vt.awaitDrain && Vt.awaitDrain--, Vt.awaitDrain === 0 && B(Ct, "data") && (Vt.flowing = !0, Lt(Ct));
    };
  }
  vt.prototype.unpipe = function(Ct) {
    var kt = this._readableState, Vt = {
      hasUnpiped: !1
    };
    if (kt.pipesCount === 0) return this;
    if (kt.pipesCount === 1)
      return Ct && Ct !== kt.pipes ? this : (Ct || (Ct = kt.pipes), kt.pipes = null, kt.pipesCount = 0, kt.flowing = !1, Ct && Ct.emit("unpipe", this, Vt), this);
    if (!Ct) {
      var nr = kt.pipes, ar = kt.pipesCount;
      kt.pipes = null, kt.pipesCount = 0, kt.flowing = !1;
      for (var sr = 0; sr < ar; sr++) nr[sr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var lr = zt(kt.pipes, Ct);
    return lr === -1 ? this : (kt.pipes.splice(lr, 1), kt.pipesCount -= 1, kt.pipesCount === 1 && (kt.pipes = kt.pipes[0]), Ct.emit("unpipe", this, Vt), this);
  }, vt.prototype.on = function(Ct, kt) {
    var Vt = L.prototype.on.call(this, Ct, kt), nr = this._readableState;
    return Ct === "data" ? (nr.readableListening = this.listenerCount("readable") > 0, nr.flowing !== !1 && this.resume()) : Ct === "readable" && !nr.endEmitted && !nr.readableListening && (nr.readableListening = nr.needReadable = !0, nr.flowing = !1, nr.emittedReadable = !1, ie("on readable", nr.length, nr.reading), nr.length ? ft(this) : nr.reading || process$1.nextTick($t, this)), Vt;
  }, vt.prototype.addListener = vt.prototype.on, vt.prototype.removeListener = function(Ct, kt) {
    var Vt = L.prototype.removeListener.call(this, Ct, kt);
    return Ct === "readable" && process$1.nextTick(lt, this), Vt;
  }, vt.prototype.removeAllListeners = function(Ct) {
    var kt = L.prototype.removeAllListeners.apply(this, arguments);
    return (Ct === "readable" || Ct === void 0) && process$1.nextTick(lt, this), kt;
  };
  function lt(Ct) {
    var kt = Ct._readableState;
    kt.readableListening = Ct.listenerCount("readable") > 0, kt.resumeScheduled && !kt.paused ? kt.flowing = !0 : Ct.listenerCount("data") > 0 && Ct.resume();
  }
  function $t(Ct) {
    ie("readable nexttick read 0"), Ct.read(0);
  }
  vt.prototype.resume = function() {
    var Ct = this._readableState;
    return Ct.flowing || (ie("resume"), Ct.flowing = !Ct.readableListening, jt(this, Ct)), Ct.paused = !1, this;
  };
  function jt(Ct, kt) {
    kt.resumeScheduled || (kt.resumeScheduled = !0, process$1.nextTick(Jt, Ct, kt));
  }
  function Jt(Ct, kt) {
    ie("resume", kt.reading), kt.reading || Ct.read(0), kt.resumeScheduled = !1, Ct.emit("resume"), Lt(Ct), kt.flowing && !kt.reading && Ct.read(0);
  }
  vt.prototype.pause = function() {
    return ie("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ie("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Lt(Ct) {
    var kt = Ct._readableState;
    for (ie("flow", kt.flowing); kt.flowing && Ct.read() !== null; ) ;
  }
  vt.prototype.wrap = function(Ct) {
    var kt = this, Vt = this._readableState, nr = !1;
    Ct.on("end", function() {
      if (ie("wrapped end"), Vt.decoder && !Vt.ended) {
        var lr = Vt.decoder.end();
        lr && lr.length && kt.push(lr);
      }
      kt.push(null);
    }), Ct.on("data", function(lr) {
      if (ie("wrapped data"), Vt.decoder && (lr = Vt.decoder.write(lr)), !(Vt.objectMode && lr == null) && !(!Vt.objectMode && (!lr || !lr.length))) {
        var dr = kt.push(lr);
        dr || (nr = !0, Ct.pause());
      }
    });
    for (var ar in Ct)
      this[ar] === void 0 && typeof Ct[ar] == "function" && (this[ar] = /* @__PURE__ */ function(dr) {
        return function() {
          return Ct[dr].apply(Ct, arguments);
        };
      }(ar));
    for (var sr = 0; sr < Pt.length; sr++)
      Ct.on(Pt[sr], this.emit.bind(this, Pt[sr]));
    return this._read = function(lr) {
      ie("wrapped _read", lr), nr && (nr = !1, Ct.resume());
    }, this;
  }, typeof Symbol == "function" && (vt.prototype[Symbol.asyncIterator] = function() {
    return yt === void 0 && (yt = requireAsync_iterator()), yt(this);
  }), Object.defineProperty(vt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(vt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(vt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(kt) {
      this._readableState && (this._readableState.flowing = kt);
    }
  }), vt._fromList = Rt, Object.defineProperty(vt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Rt(Ct, kt) {
    if (kt.length === 0) return null;
    var Vt;
    return kt.objectMode ? Vt = kt.buffer.shift() : !Ct || Ct >= kt.length ? (kt.decoder ? Vt = kt.buffer.join("") : kt.buffer.length === 1 ? Vt = kt.buffer.first() : Vt = kt.buffer.concat(kt.length), kt.buffer.clear()) : Vt = kt.buffer.consume(Ct, kt.decoder), Vt;
  }
  function Mt(Ct) {
    var kt = Ct._readableState;
    ie("endReadable", kt.endEmitted), kt.endEmitted || (kt.ended = !0, process$1.nextTick(Kt, kt, Ct));
  }
  function Kt(Ct, kt) {
    if (ie("endReadableNT", Ct.endEmitted, Ct.length), !Ct.endEmitted && Ct.length === 0 && (Ct.endEmitted = !0, kt.readable = !1, kt.emit("end"), Ct.autoDestroy)) {
      var Vt = kt._writableState;
      (!Vt || Vt.autoDestroy && Vt.finished) && kt.destroy();
    }
  }
  typeof Symbol == "function" && (vt.from = function(Ct, kt) {
    return mt === void 0 && (mt = requireFromBrowser()), mt(vt, Ct, kt);
  });
  function zt(Ct, kt) {
    for (var Vt = 0, nr = Ct.length; Vt < nr; Vt++)
      if (Ct[Vt] === kt) return Vt;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ne;
  var A = requireErrorsBrowser().codes, B = A.ERR_METHOD_NOT_IMPLEMENTED, L = A.ERR_MULTIPLE_CALLBACK, K = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, V = A.ERR_TRANSFORM_WITH_LENGTH_0, W = require_stream_duplex$1();
  requireInherits_browser()(ne, W);
  function J(re, oe) {
    var ke = this._transformState;
    ke.transforming = !1;
    var Ce = ke.writecb;
    if (Ce === null)
      return this.emit("error", new L());
    ke.writechunk = null, ke.writecb = null, oe != null && this.push(oe), Ce(re);
    var it = this._readableState;
    it.reading = !1, (it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
  }
  function ne(re) {
    if (!(this instanceof ne)) return new ne(re);
    W.call(this, re), this._transformState = {
      afterTransform: J.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, re && (typeof re.transform == "function" && (this._transform = re.transform), typeof re.flush == "function" && (this._flush = re.flush)), this.on("prefinish", ie);
  }
  function ie() {
    var re = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(oe, ke) {
      ce(re, oe, ke);
    }) : ce(this, null, null);
  }
  ne.prototype.push = function(re, oe) {
    return this._transformState.needTransform = !1, W.prototype.push.call(this, re, oe);
  }, ne.prototype._transform = function(re, oe, ke) {
    ke(new B("_transform()"));
  }, ne.prototype._write = function(re, oe, ke) {
    var Ce = this._transformState;
    if (Ce.writecb = ke, Ce.writechunk = re, Ce.writeencoding = oe, !Ce.transforming) {
      var it = this._readableState;
      (Ce.needTransform || it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
    }
  }, ne.prototype._read = function(re) {
    var oe = this._transformState;
    oe.writechunk !== null && !oe.transforming ? (oe.transforming = !0, this._transform(oe.writechunk, oe.writeencoding, oe.afterTransform)) : oe.needTransform = !0;
  }, ne.prototype._destroy = function(re, oe) {
    W.prototype._destroy.call(this, re, function(ke) {
      oe(ke);
    });
  };
  function ce(re, oe, ke) {
    if (oe) return re.emit("error", oe);
    if (ke != null && re.push(ke), re._writableState.length) throw new V();
    if (re._transformState.transforming) throw new K();
    return re.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = B;
  var A = require_stream_transform$1();
  requireInherits_browser()(B, A);
  function B(L) {
    if (!(this instanceof B)) return new B(L);
    A.call(this, L);
  }
  return B.prototype._transform = function(L, K, V) {
    V(null, L);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var A;
  function B(ke) {
    var Ce = !1;
    return function() {
      Ce || (Ce = !0, ke.apply(void 0, arguments));
    };
  }
  var L = requireErrorsBrowser().codes, K = L.ERR_MISSING_ARGS, V = L.ERR_STREAM_DESTROYED;
  function W(ke) {
    if (ke) throw ke;
  }
  function J(ke) {
    return ke.setHeader && typeof ke.abort == "function";
  }
  function ne(ke, Ce, it, at) {
    at = B(at);
    var ct = !1;
    ke.on("close", function() {
      ct = !0;
    }), A === void 0 && (A = requireEndOfStream()), A(ke, {
      readable: Ce,
      writable: it
    }, function(ot) {
      if (ot) return at(ot);
      ct = !0, at();
    });
    var dt = !1;
    return function(ot) {
      if (!ct && !dt) {
        if (dt = !0, J(ke)) return ke.abort();
        if (typeof ke.destroy == "function") return ke.destroy();
        at(ot || new V("pipe"));
      }
    };
  }
  function ie(ke) {
    ke();
  }
  function ce(ke, Ce) {
    return ke.pipe(Ce);
  }
  function re(ke) {
    return !ke.length || typeof ke[ke.length - 1] != "function" ? W : ke.pop();
  }
  function oe() {
    for (var ke = arguments.length, Ce = new Array(ke), it = 0; it < ke; it++)
      Ce[it] = arguments[it];
    var at = re(Ce);
    if (Array.isArray(Ce[0]) && (Ce = Ce[0]), Ce.length < 2)
      throw new K("streams");
    var ct, dt = Ce.map(function(ot, yt) {
      var mt = yt < Ce.length - 1, Tt = yt > 0;
      return ne(ot, mt, Tt, function(Pt) {
        ct || (ct = Pt), Pt && dt.forEach(ie), !mt && (dt.forEach(ie), at(ct));
      });
    });
    return Ce.reduce(ce);
  }
  return pipeline_1 = oe, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(A, B) {
    B = A.exports = require_stream_readable$1(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable$1(), B.Duplex = require_stream_duplex$1(), B.Transform = require_stream_transform$1(), B.PassThrough = require_stream_passthrough$1(), B.finished = requireEndOfStream(), B.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var A = safeBufferExports.Buffer, B = requireReadableBrowser$1().Transform, L = requireInherits_browser();
  function K(W, J) {
    if (!A.isBuffer(W) && typeof W != "string")
      throw new TypeError(J + " must be a string or a buffer");
  }
  function V(W) {
    B.call(this), this._block = A.allocUnsafe(W), this._blockSize = W, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return L(V, B), V.prototype._transform = function(W, J, ne) {
    var ie = null;
    try {
      this.update(W, J);
    } catch (ce) {
      ie = ce;
    }
    ne(ie);
  }, V.prototype._flush = function(W) {
    var J = null;
    try {
      this.push(this.digest());
    } catch (ne) {
      J = ne;
    }
    W(J);
  }, V.prototype.update = function(W, J) {
    if (K(W, "Data"), this._finalized) throw new Error("Digest already called");
    A.isBuffer(W) || (W = A.from(W, J));
    for (var ne = this._block, ie = 0; this._blockOffset + W.length - ie >= this._blockSize; ) {
      for (var ce = this._blockOffset; ce < this._blockSize; ) ne[ce++] = W[ie++];
      this._update(), this._blockOffset = 0;
    }
    for (; ie < W.length; ) ne[this._blockOffset++] = W[ie++];
    for (var re = 0, oe = W.length * 8; oe > 0; ++re)
      this._length[re] += oe, oe = this._length[re] / 4294967296 | 0, oe > 0 && (this._length[re] -= 4294967296 * oe);
    return this;
  }, V.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, V.prototype.digest = function(W) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var J = this._digest();
    W !== void 0 && (J = J.toString(W)), this._block.fill(0), this._blockOffset = 0;
    for (var ne = 0; ne < 4; ++ne) this._length[ne] = 0;
    return J;
  }, V.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = V, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var A = requireInherits_browser(), B = requireHashBase(), L = safeBufferExports.Buffer, K = new Array(16);
  function V() {
    B.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  A(V, B), V.prototype._update = function() {
    for (var re = K, oe = 0; oe < 16; ++oe) re[oe] = this._block.readInt32LE(oe * 4);
    var ke = this._a, Ce = this._b, it = this._c, at = this._d;
    ke = J(ke, Ce, it, at, re[0], 3614090360, 7), at = J(at, ke, Ce, it, re[1], 3905402710, 12), it = J(it, at, ke, Ce, re[2], 606105819, 17), Ce = J(Ce, it, at, ke, re[3], 3250441966, 22), ke = J(ke, Ce, it, at, re[4], 4118548399, 7), at = J(at, ke, Ce, it, re[5], 1200080426, 12), it = J(it, at, ke, Ce, re[6], 2821735955, 17), Ce = J(Ce, it, at, ke, re[7], 4249261313, 22), ke = J(ke, Ce, it, at, re[8], 1770035416, 7), at = J(at, ke, Ce, it, re[9], 2336552879, 12), it = J(it, at, ke, Ce, re[10], 4294925233, 17), Ce = J(Ce, it, at, ke, re[11], 2304563134, 22), ke = J(ke, Ce, it, at, re[12], 1804603682, 7), at = J(at, ke, Ce, it, re[13], 4254626195, 12), it = J(it, at, ke, Ce, re[14], 2792965006, 17), Ce = J(Ce, it, at, ke, re[15], 1236535329, 22), ke = ne(ke, Ce, it, at, re[1], 4129170786, 5), at = ne(at, ke, Ce, it, re[6], 3225465664, 9), it = ne(it, at, ke, Ce, re[11], 643717713, 14), Ce = ne(Ce, it, at, ke, re[0], 3921069994, 20), ke = ne(ke, Ce, it, at, re[5], 3593408605, 5), at = ne(at, ke, Ce, it, re[10], 38016083, 9), it = ne(it, at, ke, Ce, re[15], 3634488961, 14), Ce = ne(Ce, it, at, ke, re[4], 3889429448, 20), ke = ne(ke, Ce, it, at, re[9], 568446438, 5), at = ne(at, ke, Ce, it, re[14], 3275163606, 9), it = ne(it, at, ke, Ce, re[3], 4107603335, 14), Ce = ne(Ce, it, at, ke, re[8], 1163531501, 20), ke = ne(ke, Ce, it, at, re[13], 2850285829, 5), at = ne(at, ke, Ce, it, re[2], 4243563512, 9), it = ne(it, at, ke, Ce, re[7], 1735328473, 14), Ce = ne(Ce, it, at, ke, re[12], 2368359562, 20), ke = ie(ke, Ce, it, at, re[5], 4294588738, 4), at = ie(at, ke, Ce, it, re[8], 2272392833, 11), it = ie(it, at, ke, Ce, re[11], 1839030562, 16), Ce = ie(Ce, it, at, ke, re[14], 4259657740, 23), ke = ie(ke, Ce, it, at, re[1], 2763975236, 4), at = ie(at, ke, Ce, it, re[4], 1272893353, 11), it = ie(it, at, ke, Ce, re[7], 4139469664, 16), Ce = ie(Ce, it, at, ke, re[10], 3200236656, 23), ke = ie(ke, Ce, it, at, re[13], 681279174, 4), at = ie(at, ke, Ce, it, re[0], 3936430074, 11), it = ie(it, at, ke, Ce, re[3], 3572445317, 16), Ce = ie(Ce, it, at, ke, re[6], 76029189, 23), ke = ie(ke, Ce, it, at, re[9], 3654602809, 4), at = ie(at, ke, Ce, it, re[12], 3873151461, 11), it = ie(it, at, ke, Ce, re[15], 530742520, 16), Ce = ie(Ce, it, at, ke, re[2], 3299628645, 23), ke = ce(ke, Ce, it, at, re[0], 4096336452, 6), at = ce(at, ke, Ce, it, re[7], 1126891415, 10), it = ce(it, at, ke, Ce, re[14], 2878612391, 15), Ce = ce(Ce, it, at, ke, re[5], 4237533241, 21), ke = ce(ke, Ce, it, at, re[12], 1700485571, 6), at = ce(at, ke, Ce, it, re[3], 2399980690, 10), it = ce(it, at, ke, Ce, re[10], 4293915773, 15), Ce = ce(Ce, it, at, ke, re[1], 2240044497, 21), ke = ce(ke, Ce, it, at, re[8], 1873313359, 6), at = ce(at, ke, Ce, it, re[15], 4264355552, 10), it = ce(it, at, ke, Ce, re[6], 2734768916, 15), Ce = ce(Ce, it, at, ke, re[13], 1309151649, 21), ke = ce(ke, Ce, it, at, re[4], 4149444226, 6), at = ce(at, ke, Ce, it, re[11], 3174756917, 10), it = ce(it, at, ke, Ce, re[2], 718787259, 15), Ce = ce(Ce, it, at, ke, re[9], 3951481745, 21), this._a = this._a + ke | 0, this._b = this._b + Ce | 0, this._c = this._c + it | 0, this._d = this._d + at | 0;
  }, V.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var re = L.allocUnsafe(16);
    return re.writeInt32LE(this._a, 0), re.writeInt32LE(this._b, 4), re.writeInt32LE(this._c, 8), re.writeInt32LE(this._d, 12), re;
  };
  function W(re, oe) {
    return re << oe | re >>> 32 - oe;
  }
  function J(re, oe, ke, Ce, it, at, ct) {
    return W(re + (oe & ke | ~oe & Ce) + it + at | 0, ct) + oe | 0;
  }
  function ne(re, oe, ke, Ce, it, at, ct) {
    return W(re + (oe & Ce | ke & ~Ce) + it + at | 0, ct) + oe | 0;
  }
  function ie(re, oe, ke, Ce, it, at, ct) {
    return W(re + (oe ^ ke ^ Ce) + it + at | 0, ct) + oe | 0;
  }
  function ce(re, oe, ke, Ce, it, at, ct) {
    return W(re + (ke ^ (oe | ~Ce)) + it + at | 0, ct) + oe | 0;
  }
  return md5_js = V, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var A = dist$1.Buffer, B = requireInherits_browser(), L = requireHashBase(), K = new Array(16), V = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], W = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], J = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ne = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ie = [0, 1518500249, 1859775393, 2400959708, 2840853838], ce = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function re() {
    L.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  B(re, L), re.prototype._update = function() {
    for (var dt = K, ot = 0; ot < 16; ++ot) dt[ot] = this._block.readInt32LE(ot * 4);
    for (var yt = this._a | 0, mt = this._b | 0, Tt = this._c | 0, Pt = this._d | 0, Nt = this._e | 0, St = this._a | 0, vt = this._b | 0, It = this._c | 0, wt = this._d | 0, Oe = this._e | 0, rt = 0; rt < 80; rt += 1) {
      var pe, nt;
      rt < 16 ? (pe = ke(yt, mt, Tt, Pt, Nt, dt[V[rt]], ie[0], J[rt]), nt = ct(St, vt, It, wt, Oe, dt[W[rt]], ce[0], ne[rt])) : rt < 32 ? (pe = Ce(yt, mt, Tt, Pt, Nt, dt[V[rt]], ie[1], J[rt]), nt = at(St, vt, It, wt, Oe, dt[W[rt]], ce[1], ne[rt])) : rt < 48 ? (pe = it(yt, mt, Tt, Pt, Nt, dt[V[rt]], ie[2], J[rt]), nt = it(St, vt, It, wt, Oe, dt[W[rt]], ce[2], ne[rt])) : rt < 64 ? (pe = at(yt, mt, Tt, Pt, Nt, dt[V[rt]], ie[3], J[rt]), nt = Ce(St, vt, It, wt, Oe, dt[W[rt]], ce[3], ne[rt])) : (pe = ct(yt, mt, Tt, Pt, Nt, dt[V[rt]], ie[4], J[rt]), nt = ke(St, vt, It, wt, Oe, dt[W[rt]], ce[4], ne[rt])), yt = Nt, Nt = Pt, Pt = oe(Tt, 10), Tt = mt, mt = pe, St = Oe, Oe = wt, wt = oe(It, 10), It = vt, vt = nt;
    }
    var st = this._b + Tt + wt | 0;
    this._b = this._c + Pt + Oe | 0, this._c = this._d + Nt + St | 0, this._d = this._e + yt + vt | 0, this._e = this._a + mt + It | 0, this._a = st;
  }, re.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var dt = A.alloc ? A.alloc(20) : new A(20);
    return dt.writeInt32LE(this._a, 0), dt.writeInt32LE(this._b, 4), dt.writeInt32LE(this._c, 8), dt.writeInt32LE(this._d, 12), dt.writeInt32LE(this._e, 16), dt;
  };
  function oe(dt, ot) {
    return dt << ot | dt >>> 32 - ot;
  }
  function ke(dt, ot, yt, mt, Tt, Pt, Nt, St) {
    return oe(dt + (ot ^ yt ^ mt) + Pt + Nt | 0, St) + Tt | 0;
  }
  function Ce(dt, ot, yt, mt, Tt, Pt, Nt, St) {
    return oe(dt + (ot & yt | ~ot & mt) + Pt + Nt | 0, St) + Tt | 0;
  }
  function it(dt, ot, yt, mt, Tt, Pt, Nt, St) {
    return oe(dt + ((ot | ~yt) ^ mt) + Pt + Nt | 0, St) + Tt | 0;
  }
  function at(dt, ot, yt, mt, Tt, Pt, Nt, St) {
    return oe(dt + (ot & mt | yt & ~mt) + Pt + Nt | 0, St) + Tt | 0;
  }
  function ct(dt, ot, yt, mt, Tt, Pt, Nt, St) {
    return oe(dt + (ot ^ (yt | ~mt)) + Pt + Nt | 0, St) + Tt | 0;
  }
  return ripemd160$1 = re, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K) {
    this._block = A.alloc(L), this._finalSize = K, this._blockSize = L, this._len = 0;
  }
  return B.prototype.update = function(L, K) {
    typeof L == "string" && (K = K || "utf8", L = A.from(L, K));
    for (var V = this._block, W = this._blockSize, J = L.length, ne = this._len, ie = 0; ie < J; ) {
      for (var ce = ne % W, re = Math.min(J - ie, W - ce), oe = 0; oe < re; oe++)
        V[ce + oe] = L[ie + oe];
      ne += re, ie += re, ne % W === 0 && this._update(V);
    }
    return this._len += J, this;
  }, B.prototype.digest = function(L) {
    var K = this._len % this._blockSize;
    this._block[K] = 128, this._block.fill(0, K + 1), K >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var V = this._len * 8;
    if (V <= 4294967295)
      this._block.writeUInt32BE(V, this._blockSize - 4);
    else {
      var W = (V & 4294967295) >>> 0, J = (V - W) / 4294967296;
      this._block.writeUInt32BE(J, this._blockSize - 8), this._block.writeUInt32BE(W, this._blockSize - 4);
    }
    this._update(this._block);
    var ne = this._hash();
    return L ? ne.toString(L) : ne;
  }, B.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = B, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], V = new Array(80);
  function W() {
    this.init(), this._w = V, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function J(ce) {
    return ce << 5 | ce >>> 27;
  }
  function ne(ce) {
    return ce << 30 | ce >>> 2;
  }
  function ie(ce, re, oe, ke) {
    return ce === 0 ? re & oe | ~re & ke : ce === 2 ? re & oe | re & ke | oe & ke : re ^ oe ^ ke;
  }
  return W.prototype._update = function(ce) {
    for (var re = this._w, oe = this._a | 0, ke = this._b | 0, Ce = this._c | 0, it = this._d | 0, at = this._e | 0, ct = 0; ct < 16; ++ct) re[ct] = ce.readInt32BE(ct * 4);
    for (; ct < 80; ++ct) re[ct] = re[ct - 3] ^ re[ct - 8] ^ re[ct - 14] ^ re[ct - 16];
    for (var dt = 0; dt < 80; ++dt) {
      var ot = ~~(dt / 20), yt = J(oe) + ie(ot, ke, Ce, it) + at + re[dt] + K[ot] | 0;
      at = it, it = Ce, Ce = ne(ke), ke = oe, oe = yt;
    }
    this._a = oe + this._a | 0, this._b = ke + this._b | 0, this._c = Ce + this._c | 0, this._d = it + this._d | 0, this._e = at + this._e | 0;
  }, W.prototype._hash = function() {
    var ce = L.allocUnsafe(20);
    return ce.writeInt32BE(this._a | 0, 0), ce.writeInt32BE(this._b | 0, 4), ce.writeInt32BE(this._c | 0, 8), ce.writeInt32BE(this._d | 0, 12), ce.writeInt32BE(this._e | 0, 16), ce;
  }, sha$1 = W, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], V = new Array(80);
  function W() {
    this.init(), this._w = V, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function J(re) {
    return re << 1 | re >>> 31;
  }
  function ne(re) {
    return re << 5 | re >>> 27;
  }
  function ie(re) {
    return re << 30 | re >>> 2;
  }
  function ce(re, oe, ke, Ce) {
    return re === 0 ? oe & ke | ~oe & Ce : re === 2 ? oe & ke | oe & Ce | ke & Ce : oe ^ ke ^ Ce;
  }
  return W.prototype._update = function(re) {
    for (var oe = this._w, ke = this._a | 0, Ce = this._b | 0, it = this._c | 0, at = this._d | 0, ct = this._e | 0, dt = 0; dt < 16; ++dt) oe[dt] = re.readInt32BE(dt * 4);
    for (; dt < 80; ++dt) oe[dt] = J(oe[dt - 3] ^ oe[dt - 8] ^ oe[dt - 14] ^ oe[dt - 16]);
    for (var ot = 0; ot < 80; ++ot) {
      var yt = ~~(ot / 20), mt = ne(ke) + ce(yt, Ce, it, at) + ct + oe[ot] + K[yt] | 0;
      ct = at, at = it, it = ie(Ce), Ce = ke, ke = mt;
    }
    this._a = ke + this._a | 0, this._b = Ce + this._b | 0, this._c = it + this._c | 0, this._d = at + this._d | 0, this._e = ct + this._e | 0;
  }, W.prototype._hash = function() {
    var re = L.allocUnsafe(20);
    return re.writeInt32BE(this._a | 0, 0), re.writeInt32BE(this._b | 0, 4), re.writeInt32BE(this._c | 0, 8), re.writeInt32BE(this._d | 0, 12), re.writeInt32BE(this._e | 0, 16), re;
  }, sha1$1 = W, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], V = new Array(64);
  function W() {
    this.init(), this._w = V, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function J(ke, Ce, it) {
    return it ^ ke & (Ce ^ it);
  }
  function ne(ke, Ce, it) {
    return ke & Ce | it & (ke | Ce);
  }
  function ie(ke) {
    return (ke >>> 2 | ke << 30) ^ (ke >>> 13 | ke << 19) ^ (ke >>> 22 | ke << 10);
  }
  function ce(ke) {
    return (ke >>> 6 | ke << 26) ^ (ke >>> 11 | ke << 21) ^ (ke >>> 25 | ke << 7);
  }
  function re(ke) {
    return (ke >>> 7 | ke << 25) ^ (ke >>> 18 | ke << 14) ^ ke >>> 3;
  }
  function oe(ke) {
    return (ke >>> 17 | ke << 15) ^ (ke >>> 19 | ke << 13) ^ ke >>> 10;
  }
  return W.prototype._update = function(ke) {
    for (var Ce = this._w, it = this._a | 0, at = this._b | 0, ct = this._c | 0, dt = this._d | 0, ot = this._e | 0, yt = this._f | 0, mt = this._g | 0, Tt = this._h | 0, Pt = 0; Pt < 16; ++Pt) Ce[Pt] = ke.readInt32BE(Pt * 4);
    for (; Pt < 64; ++Pt) Ce[Pt] = oe(Ce[Pt - 2]) + Ce[Pt - 7] + re(Ce[Pt - 15]) + Ce[Pt - 16] | 0;
    for (var Nt = 0; Nt < 64; ++Nt) {
      var St = Tt + ce(ot) + J(ot, yt, mt) + K[Nt] + Ce[Nt] | 0, vt = ie(it) + ne(it, at, ct) | 0;
      Tt = mt, mt = yt, yt = ot, ot = dt + St | 0, dt = ct, ct = at, at = it, it = St + vt | 0;
    }
    this._a = it + this._a | 0, this._b = at + this._b | 0, this._c = ct + this._c | 0, this._d = dt + this._d | 0, this._e = ot + this._e | 0, this._f = yt + this._f | 0, this._g = mt + this._g | 0, this._h = Tt + this._h | 0;
  }, W.prototype._hash = function() {
    var ke = L.allocUnsafe(32);
    return ke.writeInt32BE(this._a, 0), ke.writeInt32BE(this._b, 4), ke.writeInt32BE(this._c, 8), ke.writeInt32BE(this._d, 12), ke.writeInt32BE(this._e, 16), ke.writeInt32BE(this._f, 20), ke.writeInt32BE(this._g, 24), ke.writeInt32BE(this._h, 28), ke;
  }, sha256$3 = W, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var A = requireInherits_browser(), B = requireSha256(), L = requireHash$1(), K = safeBufferExports.Buffer, V = new Array(64);
  function W() {
    this.init(), this._w = V, L.call(this, 64, 56);
  }
  return A(W, B), W.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, W.prototype._hash = function() {
    var J = K.allocUnsafe(28);
    return J.writeInt32BE(this._a, 0), J.writeInt32BE(this._b, 4), J.writeInt32BE(this._c, 8), J.writeInt32BE(this._d, 12), J.writeInt32BE(this._e, 16), J.writeInt32BE(this._f, 20), J.writeInt32BE(this._g, 24), J;
  }, sha224$1 = W, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], V = new Array(160);
  function W() {
    this.init(), this._w = V, B.call(this, 128, 112);
  }
  A(W, B), W.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function J(at, ct, dt) {
    return dt ^ at & (ct ^ dt);
  }
  function ne(at, ct, dt) {
    return at & ct | dt & (at | ct);
  }
  function ie(at, ct) {
    return (at >>> 28 | ct << 4) ^ (ct >>> 2 | at << 30) ^ (ct >>> 7 | at << 25);
  }
  function ce(at, ct) {
    return (at >>> 14 | ct << 18) ^ (at >>> 18 | ct << 14) ^ (ct >>> 9 | at << 23);
  }
  function re(at, ct) {
    return (at >>> 1 | ct << 31) ^ (at >>> 8 | ct << 24) ^ at >>> 7;
  }
  function oe(at, ct) {
    return (at >>> 1 | ct << 31) ^ (at >>> 8 | ct << 24) ^ (at >>> 7 | ct << 25);
  }
  function ke(at, ct) {
    return (at >>> 19 | ct << 13) ^ (ct >>> 29 | at << 3) ^ at >>> 6;
  }
  function Ce(at, ct) {
    return (at >>> 19 | ct << 13) ^ (ct >>> 29 | at << 3) ^ (at >>> 6 | ct << 26);
  }
  function it(at, ct) {
    return at >>> 0 < ct >>> 0 ? 1 : 0;
  }
  return W.prototype._update = function(at) {
    for (var ct = this._w, dt = this._ah | 0, ot = this._bh | 0, yt = this._ch | 0, mt = this._dh | 0, Tt = this._eh | 0, Pt = this._fh | 0, Nt = this._gh | 0, St = this._hh | 0, vt = this._al | 0, It = this._bl | 0, wt = this._cl | 0, Oe = this._dl | 0, rt = this._el | 0, pe = this._fl | 0, nt = this._gl | 0, st = this._hl | 0, ft = 0; ft < 32; ft += 2)
      ct[ft] = at.readInt32BE(ft * 4), ct[ft + 1] = at.readInt32BE(ft * 4 + 4);
    for (; ft < 160; ft += 2) {
      var ht = ct[ft - 30], bt = ct[ft - 15 * 2 + 1], ut = re(ht, bt), gt = oe(bt, ht);
      ht = ct[ft - 2 * 2], bt = ct[ft - 2 * 2 + 1];
      var lt = ke(ht, bt), $t = Ce(bt, ht), jt = ct[ft - 7 * 2], Jt = ct[ft - 7 * 2 + 1], Lt = ct[ft - 16 * 2], Rt = ct[ft - 16 * 2 + 1], Mt = gt + Jt | 0, Kt = ut + jt + it(Mt, gt) | 0;
      Mt = Mt + $t | 0, Kt = Kt + lt + it(Mt, $t) | 0, Mt = Mt + Rt | 0, Kt = Kt + Lt + it(Mt, Rt) | 0, ct[ft] = Kt, ct[ft + 1] = Mt;
    }
    for (var zt = 0; zt < 160; zt += 2) {
      Kt = ct[zt], Mt = ct[zt + 1];
      var Ct = ne(dt, ot, yt), kt = ne(vt, It, wt), Vt = ie(dt, vt), nr = ie(vt, dt), ar = ce(Tt, rt), sr = ce(rt, Tt), lr = K[zt], dr = K[zt + 1], rr = J(Tt, Pt, Nt), Pr = J(rt, pe, nt), ur = st + sr | 0, pr = St + ar + it(ur, st) | 0;
      ur = ur + Pr | 0, pr = pr + rr + it(ur, Pr) | 0, ur = ur + dr | 0, pr = pr + lr + it(ur, dr) | 0, ur = ur + Mt | 0, pr = pr + Kt + it(ur, Mt) | 0;
      var br = nr + kt | 0, hr = Vt + Ct + it(br, nr) | 0;
      St = Nt, st = nt, Nt = Pt, nt = pe, Pt = Tt, pe = rt, rt = Oe + ur | 0, Tt = mt + pr + it(rt, Oe) | 0, mt = yt, Oe = wt, yt = ot, wt = It, ot = dt, It = vt, vt = ur + br | 0, dt = pr + hr + it(vt, ur) | 0;
    }
    this._al = this._al + vt | 0, this._bl = this._bl + It | 0, this._cl = this._cl + wt | 0, this._dl = this._dl + Oe | 0, this._el = this._el + rt | 0, this._fl = this._fl + pe | 0, this._gl = this._gl + nt | 0, this._hl = this._hl + st | 0, this._ah = this._ah + dt + it(this._al, vt) | 0, this._bh = this._bh + ot + it(this._bl, It) | 0, this._ch = this._ch + yt + it(this._cl, wt) | 0, this._dh = this._dh + mt + it(this._dl, Oe) | 0, this._eh = this._eh + Tt + it(this._el, rt) | 0, this._fh = this._fh + Pt + it(this._fl, pe) | 0, this._gh = this._gh + Nt + it(this._gl, nt) | 0, this._hh = this._hh + St + it(this._hl, st) | 0;
  }, W.prototype._hash = function() {
    var at = L.allocUnsafe(64);
    function ct(dt, ot, yt) {
      at.writeInt32BE(dt, yt), at.writeInt32BE(ot, yt + 4);
    }
    return ct(this._ah, this._al, 0), ct(this._bh, this._bl, 8), ct(this._ch, this._cl, 16), ct(this._dh, this._dl, 24), ct(this._eh, this._el, 32), ct(this._fh, this._fl, 40), ct(this._gh, this._gl, 48), ct(this._hh, this._hl, 56), at;
  }, sha512$1 = W, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var A = requireInherits_browser(), B = requireSha512(), L = requireHash$1(), K = safeBufferExports.Buffer, V = new Array(160);
  function W() {
    this.init(), this._w = V, L.call(this, 128, 112);
  }
  return A(W, B), W.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, W.prototype._hash = function() {
    var J = K.allocUnsafe(48);
    function ne(ie, ce, re) {
      J.writeInt32BE(ie, re), J.writeInt32BE(ce, re + 4);
    }
    return ne(this._ah, this._al, 0), ne(this._bh, this._bl, 8), ne(this._ch, this._cl, 16), ne(this._dh, this._dl, 24), ne(this._eh, this._el, 32), ne(this._fh, this._fl, 40), J;
  }, sha384$1 = W, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var A = sha_js.exports = function(L) {
    L = L.toLowerCase();
    var K = A[L];
    if (!K) throw new Error(L + " is not supported (we accept pull requests)");
    return new K();
  };
  return A.sha = requireSha$1(), A.sha1 = requireSha1(), A.sha224 = requireSha224(), A.sha256 = requireSha256(), A.sha384 = requireSha384(), A.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = L;
  var A = requireEvents().EventEmitter, B = requireInherits_browser();
  B(L, A), L.Readable = require_stream_readable$1(), L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline(), L.Stream = L;
  function L() {
    A.call(this);
  }
  return L.prototype.pipe = function(K, V) {
    var W = this;
    function J(Ce) {
      K.writable && K.write(Ce) === !1 && W.pause && W.pause();
    }
    W.on("data", J);
    function ne() {
      W.readable && W.resume && W.resume();
    }
    K.on("drain", ne), !K._isStdio && (!V || V.end !== !1) && (W.on("end", ce), W.on("close", re));
    var ie = !1;
    function ce() {
      ie || (ie = !0, K.end());
    }
    function re() {
      ie || (ie = !0, typeof K.destroy == "function" && K.destroy());
    }
    function oe(Ce) {
      if (ke(), A.listenerCount(this, "error") === 0)
        throw Ce;
    }
    W.on("error", oe), K.on("error", oe);
    function ke() {
      W.removeListener("data", J), K.removeListener("drain", ne), W.removeListener("end", ce), W.removeListener("close", re), W.removeListener("error", oe), K.removeListener("error", oe), W.removeListener("end", ke), W.removeListener("close", ke), K.removeListener("close", ke);
    }
    return W.on("end", ke), W.on("close", ke), K.on("close", ke), K.emit("pipe", W), K;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var A = safeBufferExports.Buffer, B = requireStreamBrowserify().Transform, L = requireString_decoder().StringDecoder, K = requireInherits_browser();
  function V(ie) {
    B.call(this), this.hashMode = typeof ie == "string", this.hashMode ? this[ie] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  K(V, B);
  var W = typeof Uint8Array < "u", J = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (A.prototype instanceof Uint8Array || A.TYPED_ARRAY_SUPPORT);
  function ne(ie, ce) {
    if (ie instanceof A)
      return ie;
    if (typeof ie == "string")
      return A.from(ie, ce);
    if (J && ArrayBuffer.isView(ie)) {
      if (ie.byteLength === 0)
        return A.alloc(0);
      var re = A.from(ie.buffer, ie.byteOffset, ie.byteLength);
      if (re.byteLength === ie.byteLength)
        return re;
    }
    if (W && ie instanceof Uint8Array || A.isBuffer(ie) && ie.constructor && typeof ie.constructor.isBuffer == "function" && ie.constructor.isBuffer(ie))
      return A.from(ie);
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  return V.prototype.update = function(ie, ce, re) {
    var oe = ne(ie, ce), ke = this._update(oe);
    return this.hashMode ? this : (re && (ke = this._toString(ke, re)), ke);
  }, V.prototype.setAutoPadding = function() {
  }, V.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, V.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, V.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, V.prototype._transform = function(ie, ce, re) {
    var oe;
    try {
      this.hashMode ? this._update(ie) : this.push(this._update(ie));
    } catch (ke) {
      oe = ke;
    } finally {
      re(oe);
    }
  }, V.prototype._flush = function(ie) {
    var ce;
    try {
      this.push(this.__final());
    } catch (re) {
      ce = re;
    }
    ie(ce);
  }, V.prototype._finalOrDigest = function(ie) {
    var ce = this.__final() || A.alloc(0);
    return ie && (ce = this._toString(ce, ie, !0)), ce;
  }, V.prototype._toString = function(ie, ce, re) {
    if (this._decoder || (this._decoder = new L(ce), this._encoding = ce), this._encoding !== ce)
      throw new Error("can’t switch encodings");
    var oe = this._decoder.write(ie);
    return re && (oe += this._decoder.end()), oe;
  }, cipherBase = V, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var A = requireInherits_browser(), B = requireMd5_js(), L = requireRipemd160(), K = requireSha_js(), V = requireCipherBase();
  function W(J) {
    V.call(this, "digest"), this._hash = J;
  }
  return A(W, V), W.prototype._update = function(J) {
    this._hash.update(J);
  }, W.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(ne) {
    return ne = ne.toLowerCase(), ne === "md5" ? new B() : ne === "rmd160" || ne === "ripemd160" ? new L() : new W(K(ne));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var A = requireInherits_browser(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = B.alloc(128), V = 64;
  function W(J, ne) {
    L.call(this, "digest"), typeof ne == "string" && (ne = B.from(ne)), this._alg = J, this._key = ne, ne.length > V ? ne = J(ne) : ne.length < V && (ne = B.concat([ne, K], V));
    for (var ie = this._ipad = B.allocUnsafe(V), ce = this._opad = B.allocUnsafe(V), re = 0; re < V; re++)
      ie[re] = ne[re] ^ 54, ce[re] = ne[re] ^ 92;
    this._hash = [ie];
  }
  return A(W, L), W.prototype._update = function(J) {
    this._hash.push(J);
  }, W.prototype._final = function() {
    var J = this._alg(B.concat(this._hash));
    return this._alg(B.concat([this._opad, J]));
  }, legacy = W, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var A = requireMd5_js();
  return md5 = function(B) {
    return new A().update(B).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var A = requireInherits_browser(), B = requireLegacy(), L = requireCipherBase(), K = safeBufferExports.Buffer, V = requireMd5(), W = requireRipemd160(), J = requireSha_js(), ne = K.alloc(128);
  function ie(ce, re) {
    L.call(this, "digest"), typeof re == "string" && (re = K.from(re));
    var oe = ce === "sha512" || ce === "sha384" ? 128 : 64;
    if (this._alg = ce, this._key = re, re.length > oe) {
      var ke = ce === "rmd160" ? new W() : J(ce);
      re = ke.update(re).digest();
    } else re.length < oe && (re = K.concat([re, ne], oe));
    for (var Ce = this._ipad = K.allocUnsafe(oe), it = this._opad = K.allocUnsafe(oe), at = 0; at < oe; at++)
      Ce[at] = re[at] ^ 54, it[at] = re[at] ^ 92;
    this._hash = ce === "rmd160" ? new W() : J(ce), this._hash.update(Ce);
  }
  return A(ie, L), ie.prototype._update = function(ce) {
    this._hash.update(ce);
  }, ie.prototype._final = function() {
    var ce = this._hash.digest(), re = this._alg === "rmd160" ? new W() : J(this._alg);
    return re.update(this._opad).update(ce).digest();
  }, browser$8 = function(re, oe) {
    return re = re.toLowerCase(), re === "rmd160" || re === "ripemd160" ? new ie("rmd160", oe) : re === "md5" ? new B(V, oe) : new ie(re, oe);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var A = Math.pow(2, 30) - 1;
  return precondition = function(B, L) {
    if (typeof B != "number")
      throw new TypeError("Iterations not a number");
    if (B < 0)
      throw new TypeError("Bad iterations");
    if (typeof L != "number")
      throw new TypeError("Key length not a number");
    if (L < 0 || L > A || L !== L)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var A;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    A = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var B = parseInt(process$1.version.split(".")[0].slice(1), 10);
    A = B >= 6 ? "utf-8" : "binary";
  } else
    A = "utf-8";
  return defaultEncoding_1 = A, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var A = safeBufferExports.Buffer;
  return toBuffer$1 = function(B, L, K) {
    if (A.isBuffer(B))
      return B;
    if (typeof B == "string")
      return A.from(B, L);
    if (ArrayBuffer.isView(B))
      return A.from(B.buffer);
    throw new TypeError(K + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var A = requireMd5(), B = requireRipemd160(), L = requireSha_js(), K = safeBufferExports.Buffer, V = requirePrecondition(), W = requireDefaultEncoding(), J = requireToBuffer(), ne = K.alloc(128), ie = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function ce(ke, Ce, it) {
    var at = re(ke), ct = ke === "sha512" || ke === "sha384" ? 128 : 64;
    Ce.length > ct ? Ce = at(Ce) : Ce.length < ct && (Ce = K.concat([Ce, ne], ct));
    for (var dt = K.allocUnsafe(ct + ie[ke]), ot = K.allocUnsafe(ct + ie[ke]), yt = 0; yt < ct; yt++)
      dt[yt] = Ce[yt] ^ 54, ot[yt] = Ce[yt] ^ 92;
    var mt = K.allocUnsafe(ct + it + 4);
    dt.copy(mt, 0, 0, ct), this.ipad1 = mt, this.ipad2 = dt, this.opad = ot, this.alg = ke, this.blocksize = ct, this.hash = at, this.size = ie[ke];
  }
  ce.prototype.run = function(ke, Ce) {
    ke.copy(Ce, this.blocksize);
    var it = this.hash(Ce);
    return it.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function re(ke) {
    function Ce(at) {
      return L(ke).update(at).digest();
    }
    function it(at) {
      return new B().update(at).digest();
    }
    return ke === "rmd160" || ke === "ripemd160" ? it : ke === "md5" ? A : Ce;
  }
  function oe(ke, Ce, it, at, ct) {
    V(it, at), ke = J(ke, W, "Password"), Ce = J(Ce, W, "Salt"), ct = ct || "sha1";
    var dt = new ce(ct, ke, Ce.length), ot = K.allocUnsafe(at), yt = K.allocUnsafe(Ce.length + 4);
    Ce.copy(yt, 0, 0, Ce.length);
    for (var mt = 0, Tt = ie[ct], Pt = Math.ceil(at / Tt), Nt = 1; Nt <= Pt; Nt++) {
      yt.writeUInt32BE(Nt, Ce.length);
      for (var St = dt.run(yt, dt.ipad1), vt = St, It = 1; It < it; It++) {
        vt = dt.run(vt, dt.ipad2);
        for (var wt = 0; wt < Tt; wt++) St[wt] ^= vt[wt];
      }
      St.copy(ot, mt), mt += Tt;
    }
    return ot;
  }
  return syncBrowser = oe, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var A = safeBufferExports.Buffer, B = requirePrecondition(), L = requireDefaultEncoding(), K = requireSyncBrowser(), V = requireToBuffer(), W, J = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ne = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ie = [];
  function ce(it) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !J || !J.importKey || !J.deriveBits)
      return Promise.resolve(!1);
    if (ie[it] !== void 0)
      return ie[it];
    W = W || A.alloc(8);
    var at = ke(W, W, 10, 128, it).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ie[it] = at, at;
  }
  var re;
  function oe() {
    return re || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? re = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? re = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? re = commonjsGlobal.setImmediate : re = commonjsGlobal.setTimeout, re);
  }
  function ke(it, at, ct, dt, ot) {
    return J.importKey(
      "raw",
      it,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(yt) {
      return J.deriveBits({
        name: "PBKDF2",
        salt: at,
        iterations: ct,
        hash: {
          name: ot
        }
      }, yt, dt << 3);
    }).then(function(yt) {
      return A.from(yt);
    });
  }
  function Ce(it, at) {
    it.then(function(ct) {
      oe()(function() {
        at(null, ct);
      });
    }, function(ct) {
      oe()(function() {
        at(ct);
      });
    });
  }
  return async = function(it, at, ct, dt, ot, yt) {
    typeof ot == "function" && (yt = ot, ot = void 0), ot = ot || "sha1";
    var mt = ne[ot.toLowerCase()];
    if (!mt || typeof commonjsGlobal.Promise != "function") {
      oe()(function() {
        var Tt;
        try {
          Tt = K(it, at, ct, dt, ot);
        } catch (Pt) {
          return yt(Pt);
        }
        yt(null, Tt);
      });
      return;
    }
    if (B(ct, dt), it = V(it, L, "Password"), at = V(at, L, "Salt"), typeof yt != "function") throw new Error("No callback provided to pbkdf2");
    Ce(ce(mt).then(function(Tt) {
      return Tt ? ke(it, at, ct, dt, mt) : K(it, at, ct, dt, ot);
    }), yt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(V, W) {
    var J = V[0 + W] << 24 | V[1 + W] << 16 | V[2 + W] << 8 | V[3 + W];
    return J >>> 0;
  }, utils$4.writeUInt32BE = function(V, W, J) {
    V[0 + J] = W >>> 24, V[1 + J] = W >>> 16 & 255, V[2 + J] = W >>> 8 & 255, V[3 + J] = W & 255;
  }, utils$4.ip = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = 6; re >= 0; re -= 2) {
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= W >>> oe + re & 1;
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= V >>> oe + re & 1;
    }
    for (var re = 6; re >= 0; re -= 2) {
      for (var oe = 1; oe <= 25; oe += 8)
        ce <<= 1, ce |= W >>> oe + re & 1;
      for (var oe = 1; oe <= 25; oe += 8)
        ce <<= 1, ce |= V >>> oe + re & 1;
    }
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.rip = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = 0; re < 4; re++)
      for (var oe = 24; oe >= 0; oe -= 8)
        ie <<= 1, ie |= W >>> oe + re & 1, ie <<= 1, ie |= V >>> oe + re & 1;
    for (var re = 4; re < 8; re++)
      for (var oe = 24; oe >= 0; oe -= 8)
        ce <<= 1, ce |= W >>> oe + re & 1, ce <<= 1, ce |= V >>> oe + re & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.pc1 = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = 7; re >= 5; re--) {
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= W >> oe + re & 1;
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= V >> oe + re & 1;
    }
    for (var oe = 0; oe <= 24; oe += 8)
      ie <<= 1, ie |= W >> oe + re & 1;
    for (var re = 1; re <= 3; re++) {
      for (var oe = 0; oe <= 24; oe += 8)
        ce <<= 1, ce |= W >> oe + re & 1;
      for (var oe = 0; oe <= 24; oe += 8)
        ce <<= 1, ce |= V >> oe + re & 1;
    }
    for (var oe = 0; oe <= 24; oe += 8)
      ce <<= 1, ce |= V >> oe + re & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.r28shl = function(V, W) {
    return V << W & 268435455 | V >>> 28 - W;
  };
  var A = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = A.length >>> 1, oe = 0; oe < re; oe++)
      ie <<= 1, ie |= V >>> A[oe] & 1;
    for (var oe = re; oe < A.length; oe++)
      ce <<= 1, ce |= W >>> A[oe] & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.expand = function(V, W, J) {
    var ne = 0, ie = 0;
    ne = (V & 1) << 5 | V >>> 27;
    for (var ce = 23; ce >= 15; ce -= 4)
      ne <<= 6, ne |= V >>> ce & 63;
    for (var ce = 11; ce >= 3; ce -= 4)
      ie |= V >>> ce & 63, ie <<= 6;
    ie |= (V & 31) << 1 | V >>> 31, W[J + 0] = ne >>> 0, W[J + 1] = ie >>> 0;
  };
  var B = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(V, W) {
    for (var J = 0, ne = 0; ne < 4; ne++) {
      var ie = V >>> 18 - ne * 6 & 63, ce = B[ne * 64 + ie];
      J <<= 4, J |= ce;
    }
    for (var ne = 0; ne < 4; ne++) {
      var ie = W >>> 18 - ne * 6 & 63, ce = B[4 * 64 + ne * 64 + ie];
      J <<= 4, J |= ce;
    }
    return J >>> 0;
  };
  var L = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(V) {
    for (var W = 0, J = 0; J < L.length; J++)
      W <<= 1, W |= V >>> L[J] & 1;
    return W >>> 0;
  }, utils$4.padSplit = function(V, W, J) {
    for (var ne = V.toString(2); ne.length < W; )
      ne = "0" + ne;
    for (var ie = [], ce = 0; ce < W; ce += J)
      ie.push(ne.slice(ce, ce + J));
    return ie.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = A;
  function A(B, L) {
    if (!B)
      throw new Error(L || "Assertion failed");
  }
  return A.equal = function(L, K, V) {
    if (L != K)
      throw new Error(V || "Assertion failed: " + L + " != " + K);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var A = requireMinimalisticAssert();
  function B(L) {
    this.options = L, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = L.padding !== !1;
  }
  return cipher = B, B.prototype._init = function() {
  }, B.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, B.prototype._buffer = function(K, V) {
    for (var W = Math.min(this.buffer.length - this.bufferOff, K.length - V), J = 0; J < W; J++)
      this.buffer[this.bufferOff + J] = K[V + J];
    return this.bufferOff += W, W;
  }, B.prototype._flushBuffer = function(K, V) {
    return this._update(this.buffer, 0, K, V), this.bufferOff = 0, this.blockSize;
  }, B.prototype._updateEncrypt = function(K) {
    var V = 0, W = 0, J = (this.bufferOff + K.length) / this.blockSize | 0, ne = new Array(J * this.blockSize);
    this.bufferOff !== 0 && (V += this._buffer(K, V), this.bufferOff === this.buffer.length && (W += this._flushBuffer(ne, W)));
    for (var ie = K.length - (K.length - V) % this.blockSize; V < ie; V += this.blockSize)
      this._update(K, V, ne, W), W += this.blockSize;
    for (; V < K.length; V++, this.bufferOff++)
      this.buffer[this.bufferOff] = K[V];
    return ne;
  }, B.prototype._updateDecrypt = function(K) {
    for (var V = 0, W = 0, J = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, ne = new Array(J * this.blockSize); J > 0; J--)
      V += this._buffer(K, V), W += this._flushBuffer(ne, W);
    return V += this._buffer(K, V), ne;
  }, B.prototype.final = function(K) {
    var V;
    K && (V = this.update(K));
    var W;
    return this.type === "encrypt" ? W = this._finalEncrypt() : W = this._finalDecrypt(), V ? V.concat(W) : W;
  }, B.prototype._pad = function(K, V) {
    if (V === 0)
      return !1;
    for (; V < K.length; )
      K[V++] = 0;
    return !0;
  }, B.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, B.prototype._unpad = function(K) {
    return K;
  }, B.prototype._finalDecrypt = function() {
    A.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireUtils$3(), K = requireCipher();
  function V() {
    this.tmp = new Array(2), this.keys = null;
  }
  function W(ne) {
    K.call(this, ne);
    var ie = new V();
    this._desState = ie, this.deriveKeys(ie, ne.key);
  }
  B(W, K), des = W, W.create = function(ie) {
    return new W(ie);
  };
  var J = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return W.prototype.deriveKeys = function(ie, ce) {
    ie.keys = new Array(16 * 2), A.equal(ce.length, this.blockSize, "Invalid key length");
    var re = L.readUInt32BE(ce, 0), oe = L.readUInt32BE(ce, 4);
    L.pc1(re, oe, ie.tmp, 0), re = ie.tmp[0], oe = ie.tmp[1];
    for (var ke = 0; ke < ie.keys.length; ke += 2) {
      var Ce = J[ke >>> 1];
      re = L.r28shl(re, Ce), oe = L.r28shl(oe, Ce), L.pc2(re, oe, ie.keys, ke);
    }
  }, W.prototype._update = function(ie, ce, re, oe) {
    var ke = this._desState, Ce = L.readUInt32BE(ie, ce), it = L.readUInt32BE(ie, ce + 4);
    L.ip(Ce, it, ke.tmp, 0), Ce = ke.tmp[0], it = ke.tmp[1], this.type === "encrypt" ? this._encrypt(ke, Ce, it, ke.tmp, 0) : this._decrypt(ke, Ce, it, ke.tmp, 0), Ce = ke.tmp[0], it = ke.tmp[1], L.writeUInt32BE(re, Ce, oe), L.writeUInt32BE(re, it, oe + 4);
  }, W.prototype._pad = function(ie, ce) {
    if (this.padding === !1)
      return !1;
    for (var re = ie.length - ce, oe = ce; oe < ie.length; oe++)
      ie[oe] = re;
    return !0;
  }, W.prototype._unpad = function(ie) {
    if (this.padding === !1)
      return ie;
    for (var ce = ie[ie.length - 1], re = ie.length - ce; re < ie.length; re++)
      A.equal(ie[re], ce);
    return ie.slice(0, ie.length - ce);
  }, W.prototype._encrypt = function(ie, ce, re, oe, ke) {
    for (var Ce = ce, it = re, at = 0; at < ie.keys.length; at += 2) {
      var ct = ie.keys[at], dt = ie.keys[at + 1];
      L.expand(it, ie.tmp, 0), ct ^= ie.tmp[0], dt ^= ie.tmp[1];
      var ot = L.substitute(ct, dt), yt = L.permute(ot), mt = it;
      it = (Ce ^ yt) >>> 0, Ce = mt;
    }
    L.rip(it, Ce, oe, ke);
  }, W.prototype._decrypt = function(ie, ce, re, oe, ke) {
    for (var Ce = re, it = ce, at = ie.keys.length - 2; at >= 0; at -= 2) {
      var ct = ie.keys[at], dt = ie.keys[at + 1];
      L.expand(Ce, ie.tmp, 0), ct ^= ie.tmp[0], dt ^= ie.tmp[1];
      var ot = L.substitute(ct, dt), yt = L.permute(ot), mt = Ce;
      Ce = (it ^ yt) >>> 0, it = mt;
    }
    L.rip(Ce, it, oe, ke);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = {};
  function K(W) {
    A.equal(W.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var J = 0; J < this.iv.length; J++)
      this.iv[J] = W[J];
  }
  function V(W) {
    function J(re) {
      W.call(this, re), this._cbcInit();
    }
    B(J, W);
    for (var ne = Object.keys(L), ie = 0; ie < ne.length; ie++) {
      var ce = ne[ie];
      J.prototype[ce] = L[ce];
    }
    return J.create = function(oe) {
      return new J(oe);
    }, J;
  }
  return cbc$1.instantiate = V, L._cbcInit = function() {
    var J = new K(this.options.iv);
    this._cbcState = J;
  }, L._update = function(J, ne, ie, ce) {
    var re = this._cbcState, oe = this.constructor.super_.prototype, ke = re.iv;
    if (this.type === "encrypt") {
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] ^= J[ne + Ce];
      oe._update.call(this, ke, 0, ie, ce);
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] = ie[ce + Ce];
    } else {
      oe._update.call(this, J, ne, ie, ce);
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ie[ce + Ce] ^= ke[Ce];
      for (var Ce = 0; Ce < this.blockSize; Ce++)
        ke[Ce] = J[ne + Ce];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireCipher(), K = requireDes$1();
  function V(J, ne) {
    A.equal(ne.length, 24, "Invalid key length");
    var ie = ne.slice(0, 8), ce = ne.slice(8, 16), re = ne.slice(16, 24);
    J === "encrypt" ? this.ciphers = [
      K.create({ type: "encrypt", key: ie }),
      K.create({ type: "decrypt", key: ce }),
      K.create({ type: "encrypt", key: re })
    ] : this.ciphers = [
      K.create({ type: "decrypt", key: re }),
      K.create({ type: "encrypt", key: ce }),
      K.create({ type: "decrypt", key: ie })
    ];
  }
  function W(J) {
    L.call(this, J);
    var ne = new V(this.type, this.options.key);
    this._edeState = ne;
  }
  return B(W, L), ede = W, W.create = function(ne) {
    return new W(ne);
  }, W.prototype._update = function(ne, ie, ce, re) {
    var oe = this._edeState;
    oe.ciphers[0]._update(ne, ie, ce, re), oe.ciphers[1]._update(ce, re, ce, re), oe.ciphers[2]._update(ce, re, ce, re);
  }, W.prototype._pad = K.prototype._pad, W.prototype._unpad = K.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var A = requireCipherBase(), B = requireDes(), L = requireInherits_browser(), K = safeBufferExports.Buffer, V = {
    "des-ede3-cbc": B.CBC.instantiate(B.EDE),
    "des-ede3": B.EDE,
    "des-ede-cbc": B.CBC.instantiate(B.EDE),
    "des-ede": B.EDE,
    "des-cbc": B.CBC.instantiate(B.DES),
    "des-ecb": B.DES
  };
  V.des = V["des-cbc"], V.des3 = V["des-ede3-cbc"], browserifyDes = W, L(W, A);
  function W(J) {
    A.call(this);
    var ne = J.mode.toLowerCase(), ie = V[ne], ce;
    J.decrypt ? ce = "decrypt" : ce = "encrypt";
    var re = J.key;
    K.isBuffer(re) || (re = K.from(re)), (ne === "des-ede" || ne === "des-ede-cbc") && (re = K.concat([re, re.slice(0, 8)]));
    var oe = J.iv;
    K.isBuffer(oe) || (oe = K.from(oe)), this._des = ie.create({
      key: re,
      iv: oe,
      type: ce
    });
  }
  return W.prototype._update = function(J) {
    return K.from(this._des.update(J));
  }, W.prototype._final = function() {
    return K.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(A, B) {
    return A._cipher.encryptBlock(B);
  }, ecb.decrypt = function(A, B) {
    return A._cipher.decryptBlock(B);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(B, L) {
    for (var K = Math.min(B.length, L.length), V = new Buffer$1(K), W = 0; W < K; ++W)
      V[W] = B[W] ^ L[W];
    return V;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var A = requireBufferXor();
  return cbc.encrypt = function(B, L) {
    var K = A(L, B._prev);
    return B._prev = B._cipher.encryptBlock(K), B._prev;
  }, cbc.decrypt = function(B, L) {
    var K = B._prev;
    B._prev = L;
    var V = B._cipher.decryptBlock(L);
    return A(V, K);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var A = safeBufferExports.Buffer, B = requireBufferXor();
  function L(K, V, W) {
    var J = V.length, ne = B(V, K._cache);
    return K._cache = K._cache.slice(J), K._prev = A.concat([K._prev, W ? V : ne]), ne;
  }
  return cfb.encrypt = function(K, V, W) {
    for (var J = A.allocUnsafe(0), ne; V.length; )
      if (K._cache.length === 0 && (K._cache = K._cipher.encryptBlock(K._prev), K._prev = A.allocUnsafe(0)), K._cache.length <= V.length)
        ne = K._cache.length, J = A.concat([J, L(K, V.slice(0, ne), W)]), V = V.slice(ne);
      else {
        J = A.concat([J, L(K, V, W)]);
        break;
      }
    return J;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K, V) {
    var W = L._cipher.encryptBlock(L._prev), J = W[0] ^ K;
    return L._prev = A.concat([
      L._prev.slice(1),
      A.from([V ? K : J])
    ]), J;
  }
  return cfb8.encrypt = function(L, K, V) {
    for (var W = K.length, J = A.allocUnsafe(W), ne = -1; ++ne < W; )
      J[ne] = B(L, K[ne], V);
    return J;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var A = safeBufferExports.Buffer;
  function B(K, V, W) {
    for (var J, ne = -1, ie = 8, ce = 0, re, oe; ++ne < ie; )
      J = K._cipher.encryptBlock(K._prev), re = V & 1 << 7 - ne ? 128 : 0, oe = J[0] ^ re, ce += (oe & 128) >> ne % 8, K._prev = L(K._prev, W ? re : oe);
    return ce;
  }
  function L(K, V) {
    var W = K.length, J = -1, ne = A.allocUnsafe(K.length);
    for (K = A.concat([K, A.from([V])]); ++J < W; )
      ne[J] = K[J] << 1 | K[J + 1] >> 7;
    return ne;
  }
  return cfb1.encrypt = function(K, V, W) {
    for (var J = V.length, ne = A.allocUnsafe(J), ie = -1; ++ie < J; )
      ne[ie] = B(K, V[ie], W);
    return ne;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var A = requireBufferXor();
  function B(L) {
    return L._prev = L._cipher.encryptBlock(L._prev), L._prev;
  }
  return ofb.encrypt = function(L, K) {
    for (; L._cache.length < K.length; )
      L._cache = Buffer$1.concat([L._cache, B(L)]);
    var V = L._cache.slice(0, K.length);
    return L._cache = L._cache.slice(K.length), A(K, V);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function A(B) {
    for (var L = B.length, K; L--; )
      if (K = B.readUInt8(L), K === 255)
        B.writeUInt8(0, L);
      else {
        K++, B.writeUInt8(K, L);
        break;
      }
  }
  return incr32_1 = A, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var A = requireBufferXor(), B = safeBufferExports.Buffer, L = requireIncr32();
  function K(W) {
    var J = W._cipher.encryptBlockRaw(W._prev);
    return L(W._prev), J;
  }
  var V = 16;
  return ctr.encrypt = function(W, J) {
    var ne = Math.ceil(J.length / V), ie = W._cache.length;
    W._cache = B.concat([
      W._cache,
      B.allocUnsafe(ne * V)
    ]);
    for (var ce = 0; ce < ne; ce++) {
      var re = K(W), oe = ie + ce * V;
      W._cache.writeUInt32BE(re[0], oe + 0), W._cache.writeUInt32BE(re[1], oe + 4), W._cache.writeUInt32BE(re[2], oe + 8), W._cache.writeUInt32BE(re[3], oe + 12);
    }
    var ke = W._cache.slice(0, J.length);
    return W._cache = W._cache.slice(J.length), A(J, ke);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var A = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, B = require$$2;
  for (var L in B)
    B[L].module = A[B[L].mode];
  return modes_1 = B, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var A = safeBufferExports.Buffer;
  function B(ne) {
    A.isBuffer(ne) || (ne = A.from(ne));
    for (var ie = ne.length / 4 | 0, ce = new Array(ie), re = 0; re < ie; re++)
      ce[re] = ne.readUInt32BE(re * 4);
    return ce;
  }
  function L(ne) {
    for (var ie = 0; ie < ne.length; ne++)
      ne[ie] = 0;
  }
  function K(ne, ie, ce, re, oe) {
    for (var ke = ce[0], Ce = ce[1], it = ce[2], at = ce[3], ct = ne[0] ^ ie[0], dt = ne[1] ^ ie[1], ot = ne[2] ^ ie[2], yt = ne[3] ^ ie[3], mt, Tt, Pt, Nt, St = 4, vt = 1; vt < oe; vt++)
      mt = ke[ct >>> 24] ^ Ce[dt >>> 16 & 255] ^ it[ot >>> 8 & 255] ^ at[yt & 255] ^ ie[St++], Tt = ke[dt >>> 24] ^ Ce[ot >>> 16 & 255] ^ it[yt >>> 8 & 255] ^ at[ct & 255] ^ ie[St++], Pt = ke[ot >>> 24] ^ Ce[yt >>> 16 & 255] ^ it[ct >>> 8 & 255] ^ at[dt & 255] ^ ie[St++], Nt = ke[yt >>> 24] ^ Ce[ct >>> 16 & 255] ^ it[dt >>> 8 & 255] ^ at[ot & 255] ^ ie[St++], ct = mt, dt = Tt, ot = Pt, yt = Nt;
    return mt = (re[ct >>> 24] << 24 | re[dt >>> 16 & 255] << 16 | re[ot >>> 8 & 255] << 8 | re[yt & 255]) ^ ie[St++], Tt = (re[dt >>> 24] << 24 | re[ot >>> 16 & 255] << 16 | re[yt >>> 8 & 255] << 8 | re[ct & 255]) ^ ie[St++], Pt = (re[ot >>> 24] << 24 | re[yt >>> 16 & 255] << 16 | re[ct >>> 8 & 255] << 8 | re[dt & 255]) ^ ie[St++], Nt = (re[yt >>> 24] << 24 | re[ct >>> 16 & 255] << 16 | re[dt >>> 8 & 255] << 8 | re[ot & 255]) ^ ie[St++], mt = mt >>> 0, Tt = Tt >>> 0, Pt = Pt >>> 0, Nt = Nt >>> 0, [mt, Tt, Pt, Nt];
  }
  var V = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], W = function() {
    for (var ne = new Array(256), ie = 0; ie < 256; ie++)
      ie < 128 ? ne[ie] = ie << 1 : ne[ie] = ie << 1 ^ 283;
    for (var ce = [], re = [], oe = [[], [], [], []], ke = [[], [], [], []], Ce = 0, it = 0, at = 0; at < 256; ++at) {
      var ct = it ^ it << 1 ^ it << 2 ^ it << 3 ^ it << 4;
      ct = ct >>> 8 ^ ct & 255 ^ 99, ce[Ce] = ct, re[ct] = Ce;
      var dt = ne[Ce], ot = ne[dt], yt = ne[ot], mt = ne[ct] * 257 ^ ct * 16843008;
      oe[0][Ce] = mt << 24 | mt >>> 8, oe[1][Ce] = mt << 16 | mt >>> 16, oe[2][Ce] = mt << 8 | mt >>> 24, oe[3][Ce] = mt, mt = yt * 16843009 ^ ot * 65537 ^ dt * 257 ^ Ce * 16843008, ke[0][ct] = mt << 24 | mt >>> 8, ke[1][ct] = mt << 16 | mt >>> 16, ke[2][ct] = mt << 8 | mt >>> 24, ke[3][ct] = mt, Ce === 0 ? Ce = it = 1 : (Ce = dt ^ ne[ne[ne[yt ^ dt]]], it ^= ne[ne[it]]);
    }
    return {
      SBOX: ce,
      INV_SBOX: re,
      SUB_MIX: oe,
      INV_SUB_MIX: ke
    };
  }();
  function J(ne) {
    this._key = B(ne), this._reset();
  }
  return J.blockSize = 4 * 4, J.keySize = 256 / 8, J.prototype.blockSize = J.blockSize, J.prototype.keySize = J.keySize, J.prototype._reset = function() {
    for (var ne = this._key, ie = ne.length, ce = ie + 6, re = (ce + 1) * 4, oe = [], ke = 0; ke < ie; ke++)
      oe[ke] = ne[ke];
    for (ke = ie; ke < re; ke++) {
      var Ce = oe[ke - 1];
      ke % ie === 0 ? (Ce = Ce << 8 | Ce >>> 24, Ce = W.SBOX[Ce >>> 24] << 24 | W.SBOX[Ce >>> 16 & 255] << 16 | W.SBOX[Ce >>> 8 & 255] << 8 | W.SBOX[Ce & 255], Ce ^= V[ke / ie | 0] << 24) : ie > 6 && ke % ie === 4 && (Ce = W.SBOX[Ce >>> 24] << 24 | W.SBOX[Ce >>> 16 & 255] << 16 | W.SBOX[Ce >>> 8 & 255] << 8 | W.SBOX[Ce & 255]), oe[ke] = oe[ke - ie] ^ Ce;
    }
    for (var it = [], at = 0; at < re; at++) {
      var ct = re - at, dt = oe[ct - (at % 4 ? 0 : 4)];
      at < 4 || ct <= 4 ? it[at] = dt : it[at] = W.INV_SUB_MIX[0][W.SBOX[dt >>> 24]] ^ W.INV_SUB_MIX[1][W.SBOX[dt >>> 16 & 255]] ^ W.INV_SUB_MIX[2][W.SBOX[dt >>> 8 & 255]] ^ W.INV_SUB_MIX[3][W.SBOX[dt & 255]];
    }
    this._nRounds = ce, this._keySchedule = oe, this._invKeySchedule = it;
  }, J.prototype.encryptBlockRaw = function(ne) {
    return ne = B(ne), K(ne, this._keySchedule, W.SUB_MIX, W.SBOX, this._nRounds);
  }, J.prototype.encryptBlock = function(ne) {
    var ie = this.encryptBlockRaw(ne), ce = A.allocUnsafe(16);
    return ce.writeUInt32BE(ie[0], 0), ce.writeUInt32BE(ie[1], 4), ce.writeUInt32BE(ie[2], 8), ce.writeUInt32BE(ie[3], 12), ce;
  }, J.prototype.decryptBlock = function(ne) {
    ne = B(ne);
    var ie = ne[1];
    ne[1] = ne[3], ne[3] = ie;
    var ce = K(ne, this._invKeySchedule, W.INV_SUB_MIX, W.INV_SBOX, this._nRounds), re = A.allocUnsafe(16);
    return re.writeUInt32BE(ce[0], 0), re.writeUInt32BE(ce[3], 4), re.writeUInt32BE(ce[2], 8), re.writeUInt32BE(ce[1], 12), re;
  }, J.prototype.scrub = function() {
    L(this._keySchedule), L(this._invKeySchedule), L(this._key);
  }, aes.AES = J, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var A = safeBufferExports.Buffer, B = A.alloc(16, 0);
  function L(W) {
    return [
      W.readUInt32BE(0),
      W.readUInt32BE(4),
      W.readUInt32BE(8),
      W.readUInt32BE(12)
    ];
  }
  function K(W) {
    var J = A.allocUnsafe(16);
    return J.writeUInt32BE(W[0] >>> 0, 0), J.writeUInt32BE(W[1] >>> 0, 4), J.writeUInt32BE(W[2] >>> 0, 8), J.writeUInt32BE(W[3] >>> 0, 12), J;
  }
  function V(W) {
    this.h = W, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
  }
  return V.prototype.ghash = function(W) {
    for (var J = -1; ++J < W.length; )
      this.state[J] ^= W[J];
    this._multiply();
  }, V.prototype._multiply = function() {
    for (var W = L(this.h), J = [0, 0, 0, 0], ne, ie, ce, re = -1; ++re < 128; ) {
      for (ie = (this.state[~~(re / 8)] & 1 << 7 - re % 8) !== 0, ie && (J[0] ^= W[0], J[1] ^= W[1], J[2] ^= W[2], J[3] ^= W[3]), ce = (W[3] & 1) !== 0, ne = 3; ne > 0; ne--)
        W[ne] = W[ne] >>> 1 | (W[ne - 1] & 1) << 31;
      W[0] = W[0] >>> 1, ce && (W[0] = W[0] ^ 225 << 24);
    }
    this.state = K(J);
  }, V.prototype.update = function(W) {
    this.cache = A.concat([this.cache, W]);
    for (var J; this.cache.length >= 16; )
      J = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(J);
  }, V.prototype.final = function(W, J) {
    return this.cache.length && this.ghash(A.concat([this.cache, B], 16)), this.ghash(K([0, W, 0, J])), this.state;
  }, ghash = V, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser(), V = requireGhash(), W = requireBufferXor(), J = requireIncr32();
  function ne(re, oe) {
    var ke = 0;
    re.length !== oe.length && ke++;
    for (var Ce = Math.min(re.length, oe.length), it = 0; it < Ce; ++it)
      ke += re[it] ^ oe[it];
    return ke;
  }
  function ie(re, oe, ke) {
    if (oe.length === 12)
      return re._finID = B.concat([oe, B.from([0, 0, 0, 1])]), B.concat([oe, B.from([0, 0, 0, 2])]);
    var Ce = new V(ke), it = oe.length, at = it % 16;
    Ce.update(oe), at && (at = 16 - at, Ce.update(B.alloc(at, 0))), Ce.update(B.alloc(8, 0));
    var ct = it * 8, dt = B.alloc(8);
    dt.writeUIntBE(ct, 0, 8), Ce.update(dt), re._finID = Ce.state;
    var ot = B.from(re._finID);
    return J(ot), ot;
  }
  function ce(re, oe, ke, Ce) {
    L.call(this);
    var it = B.alloc(4, 0);
    this._cipher = new A.AES(oe);
    var at = this._cipher.encryptBlock(it);
    this._ghash = new V(at), ke = ie(this, ke, at), this._prev = B.from(ke), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = Ce, this._alen = 0, this._len = 0, this._mode = re, this._authTag = null, this._called = !1;
  }
  return K(ce, L), ce.prototype._update = function(re) {
    if (!this._called && this._alen) {
      var oe = 16 - this._alen % 16;
      oe < 16 && (oe = B.alloc(oe, 0), this._ghash.update(oe));
    }
    this._called = !0;
    var ke = this._mode.encrypt(this, re);
    return this._decrypt ? this._ghash.update(re) : this._ghash.update(ke), this._len += re.length, ke;
  }, ce.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var re = W(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ne(re, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = re, this._cipher.scrub();
  }, ce.prototype.getAuthTag = function() {
    if (this._decrypt || !B.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ce.prototype.setAuthTag = function(oe) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = oe;
  }, ce.prototype.setAAD = function(oe) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(oe), this._alen += oe.length;
  }, authCipher = ce, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser();
  function V(W, J, ne, ie) {
    L.call(this), this._cipher = new A.AES(J), this._prev = B.from(ne), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = ie, this._mode = W;
  }
  return K(V, L), V.prototype._update = function(W) {
    return this._mode.encrypt(this, W, this._decrypt);
  }, V.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = V, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var A = safeBufferExports.Buffer, B = requireMd5_js();
  function L(K, V, W, J) {
    if (A.isBuffer(K) || (K = A.from(K, "binary")), V && (A.isBuffer(V) || (V = A.from(V, "binary")), V.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var ne = W / 8, ie = A.alloc(ne), ce = A.alloc(J || 0), re = A.alloc(0); ne > 0 || J > 0; ) {
      var oe = new B();
      oe.update(re), oe.update(K), V && oe.update(V), re = oe.digest();
      var ke = 0;
      if (ne > 0) {
        var Ce = ie.length - ne;
        ke = Math.min(ne, re.length), re.copy(ie, Ce, 0, ke), ne -= ke;
      }
      if (ke < re.length && J > 0) {
        var it = ce.length - J, at = Math.min(J, re.length - ke);
        re.copy(ce, it, ke, ke + at), J -= at;
      }
    }
    return re.fill(0), { key: ie, iv: ce };
  }
  return evp_bytestokey = L, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var A = requireModes$1(), B = requireAuthCipher(), L = safeBufferExports.Buffer, K = requireStreamCipher(), V = requireCipherBase(), W = requireAes(), J = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Ce, it, at) {
    V.call(this), this._cache = new re(), this._cipher = new W.AES(it), this._prev = L.from(at), this._mode = Ce, this._autopadding = !0;
  }
  ne(ie, V), ie.prototype._update = function(Ce) {
    this._cache.add(Ce);
    for (var it, at, ct = []; it = this._cache.get(); )
      at = this._mode.encrypt(this, it), ct.push(at);
    return L.concat(ct);
  };
  var ce = L.alloc(16, 16);
  ie.prototype._final = function() {
    var Ce = this._cache.flush();
    if (this._autopadding)
      return Ce = this._mode.encrypt(this, Ce), this._cipher.scrub(), Ce;
    if (!Ce.equals(ce))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Ce) {
    return this._autopadding = !!Ce, this;
  };
  function re() {
    this.cache = L.allocUnsafe(0);
  }
  re.prototype.add = function(Ce) {
    this.cache = L.concat([this.cache, Ce]);
  }, re.prototype.get = function() {
    if (this.cache.length > 15) {
      var Ce = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Ce;
    }
    return null;
  }, re.prototype.flush = function() {
    for (var Ce = 16 - this.cache.length, it = L.allocUnsafe(Ce), at = -1; ++at < Ce; )
      it.writeUInt8(Ce, at);
    return L.concat([this.cache, it]);
  };
  function oe(Ce, it, at) {
    var ct = A[Ce.toLowerCase()];
    if (!ct) throw new TypeError("invalid suite type");
    if (typeof it == "string" && (it = L.from(it)), it.length !== ct.key / 8) throw new TypeError("invalid key length " + it.length);
    if (typeof at == "string" && (at = L.from(at)), ct.mode !== "GCM" && at.length !== ct.iv) throw new TypeError("invalid iv length " + at.length);
    return ct.type === "stream" ? new K(ct.module, it, at) : ct.type === "auth" ? new B(ct.module, it, at) : new ie(ct.module, it, at);
  }
  function ke(Ce, it) {
    var at = A[Ce.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var ct = J(it, !1, at.key, at.iv);
    return oe(Ce, ct.key, ct.iv);
  }
  return encrypter.createCipheriv = oe, encrypter.createCipher = ke, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var A = requireAuthCipher(), B = safeBufferExports.Buffer, L = requireModes$1(), K = requireStreamCipher(), V = requireCipherBase(), W = requireAes(), J = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Ce, it, at) {
    V.call(this), this._cache = new ce(), this._last = void 0, this._cipher = new W.AES(it), this._prev = B.from(at), this._mode = Ce, this._autopadding = !0;
  }
  ne(ie, V), ie.prototype._update = function(Ce) {
    this._cache.add(Ce);
    for (var it, at, ct = []; it = this._cache.get(this._autopadding); )
      at = this._mode.decrypt(this, it), ct.push(at);
    return B.concat(ct);
  }, ie.prototype._final = function() {
    var Ce = this._cache.flush();
    if (this._autopadding)
      return re(this._mode.decrypt(this, Ce));
    if (Ce)
      throw new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Ce) {
    return this._autopadding = !!Ce, this;
  };
  function ce() {
    this.cache = B.allocUnsafe(0);
  }
  ce.prototype.add = function(Ce) {
    this.cache = B.concat([this.cache, Ce]);
  }, ce.prototype.get = function(Ce) {
    var it;
    if (Ce) {
      if (this.cache.length > 16)
        return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    } else if (this.cache.length >= 16)
      return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    return null;
  }, ce.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function re(Ce) {
    var it = Ce[15];
    if (it < 1 || it > 16)
      throw new Error("unable to decrypt data");
    for (var at = -1; ++at < it; )
      if (Ce[at + (16 - it)] !== it)
        throw new Error("unable to decrypt data");
    if (it !== 16)
      return Ce.slice(0, 16 - it);
  }
  function oe(Ce, it, at) {
    var ct = L[Ce.toLowerCase()];
    if (!ct) throw new TypeError("invalid suite type");
    if (typeof at == "string" && (at = B.from(at)), ct.mode !== "GCM" && at.length !== ct.iv) throw new TypeError("invalid iv length " + at.length);
    if (typeof it == "string" && (it = B.from(it)), it.length !== ct.key / 8) throw new TypeError("invalid key length " + it.length);
    return ct.type === "stream" ? new K(ct.module, it, at, !0) : ct.type === "auth" ? new A(ct.module, it, at, !0) : new ie(ct.module, it, at);
  }
  function ke(Ce, it) {
    var at = L[Ce.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var ct = J(it, !1, at.key, at.iv);
    return oe(Ce, ct.key, ct.iv);
  }
  return decrypter.createDecipher = ke, decrypter.createDecipheriv = oe, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var A = requireEncrypter(), B = requireDecrypter(), L = require$$2;
  function K() {
    return Object.keys(L);
  }
  return browser$5.createCipher = browser$5.Cipher = A.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = A.createCipheriv, browser$5.createDecipher = browser$5.Decipher = B.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = B.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = K, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(A) {
    A["des-ecb"] = {
      key: 8,
      iv: 0
    }, A["des-cbc"] = A.des = {
      key: 8,
      iv: 8
    }, A["des-ede3-cbc"] = A.des3 = {
      key: 24,
      iv: 8
    }, A["des-ede3"] = {
      key: 24,
      iv: 0
    }, A["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, A["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var A = requireBrowserifyDes(), B = requireBrowser$6(), L = requireModes$1(), K = requireModes(), V = requireEvp_bytestokey();
  function W(re, oe) {
    re = re.toLowerCase();
    var ke, Ce;
    if (L[re])
      ke = L[re].key, Ce = L[re].iv;
    else if (K[re])
      ke = K[re].key * 8, Ce = K[re].iv;
    else
      throw new TypeError("invalid suite type");
    var it = V(oe, !1, ke, Ce);
    return ne(re, it.key, it.iv);
  }
  function J(re, oe) {
    re = re.toLowerCase();
    var ke, Ce;
    if (L[re])
      ke = L[re].key, Ce = L[re].iv;
    else if (K[re])
      ke = K[re].key * 8, Ce = K[re].iv;
    else
      throw new TypeError("invalid suite type");
    var it = V(oe, !1, ke, Ce);
    return ie(re, it.key, it.iv);
  }
  function ne(re, oe, ke) {
    if (re = re.toLowerCase(), L[re]) return B.createCipheriv(re, oe, ke);
    if (K[re]) return new A({ key: oe, iv: ke, mode: re });
    throw new TypeError("invalid suite type");
  }
  function ie(re, oe, ke) {
    if (re = re.toLowerCase(), L[re]) return B.createDecipheriv(re, oe, ke);
    if (K[re]) return new A({ key: oe, iv: ke, mode: re, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function ce() {
    return Object.keys(K).concat(B.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = W, browser$6.createCipheriv = browser$6.Cipheriv = ne, browser$6.createDecipher = browser$6.Decipher = J, browser$6.createDecipheriv = browser$6.Decipheriv = ie, browser$6.listCiphers = browser$6.getCiphers = ce, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(A) {
    (function(B, L) {
      function K(wt, Oe) {
        if (!wt) throw new Error(Oe || "Assertion failed");
      }
      function V(wt, Oe) {
        wt.super_ = Oe;
        var rt = function() {
        };
        rt.prototype = Oe.prototype, wt.prototype = new rt(), wt.prototype.constructor = wt;
      }
      function W(wt, Oe, rt) {
        if (W.isBN(wt))
          return wt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, wt !== null && ((Oe === "le" || Oe === "be") && (rt = Oe, Oe = 10), this._init(wt || 0, Oe || 10, rt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var J;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? J = window.Buffer : J = dist$1.Buffer;
      } catch {
      }
      W.isBN = function(Oe) {
        return Oe instanceof W ? !0 : Oe !== null && typeof Oe == "object" && Oe.constructor.wordSize === W.wordSize && Array.isArray(Oe.words);
      }, W.max = function(Oe, rt) {
        return Oe.cmp(rt) > 0 ? Oe : rt;
      }, W.min = function(Oe, rt) {
        return Oe.cmp(rt) < 0 ? Oe : rt;
      }, W.prototype._init = function(Oe, rt, pe) {
        if (typeof Oe == "number")
          return this._initNumber(Oe, rt, pe);
        if (typeof Oe == "object")
          return this._initArray(Oe, rt, pe);
        rt === "hex" && (rt = 16), K(rt === (rt | 0) && rt >= 2 && rt <= 36), Oe = Oe.toString().replace(/\s+/g, "");
        var nt = 0;
        Oe[0] === "-" && (nt++, this.negative = 1), nt < Oe.length && (rt === 16 ? this._parseHex(Oe, nt, pe) : (this._parseBase(Oe, rt, nt), pe === "le" && this._initArray(this.toArray(), rt, pe)));
      }, W.prototype._initNumber = function(Oe, rt, pe) {
        Oe < 0 && (this.negative = 1, Oe = -Oe), Oe < 67108864 ? (this.words = [Oe & 67108863], this.length = 1) : Oe < 4503599627370496 ? (this.words = [
          Oe & 67108863,
          Oe / 67108864 & 67108863
        ], this.length = 2) : (K(Oe < 9007199254740992), this.words = [
          Oe & 67108863,
          Oe / 67108864 & 67108863,
          1
        ], this.length = 3), pe === "le" && this._initArray(this.toArray(), rt, pe);
      }, W.prototype._initArray = function(Oe, rt, pe) {
        if (K(typeof Oe.length == "number"), Oe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Oe.length / 3), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var st, ft, ht = 0;
        if (pe === "be")
          for (nt = Oe.length - 1, st = 0; nt >= 0; nt -= 3)
            ft = Oe[nt] | Oe[nt - 1] << 8 | Oe[nt - 2] << 16, this.words[st] |= ft << ht & 67108863, this.words[st + 1] = ft >>> 26 - ht & 67108863, ht += 24, ht >= 26 && (ht -= 26, st++);
        else if (pe === "le")
          for (nt = 0, st = 0; nt < Oe.length; nt += 3)
            ft = Oe[nt] | Oe[nt + 1] << 8 | Oe[nt + 2] << 16, this.words[st] |= ft << ht & 67108863, this.words[st + 1] = ft >>> 26 - ht & 67108863, ht += 24, ht >= 26 && (ht -= 26, st++);
        return this.strip();
      };
      function ne(wt, Oe) {
        var rt = wt.charCodeAt(Oe);
        return rt >= 65 && rt <= 70 ? rt - 55 : rt >= 97 && rt <= 102 ? rt - 87 : rt - 48 & 15;
      }
      function ie(wt, Oe, rt) {
        var pe = ne(wt, rt);
        return rt - 1 >= Oe && (pe |= ne(wt, rt - 1) << 4), pe;
      }
      W.prototype._parseHex = function(Oe, rt, pe) {
        this.length = Math.ceil((Oe.length - rt) / 6), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var st = 0, ft = 0, ht;
        if (pe === "be")
          for (nt = Oe.length - 1; nt >= rt; nt -= 2)
            ht = ie(Oe, rt, nt) << st, this.words[ft] |= ht & 67108863, st >= 18 ? (st -= 18, ft += 1, this.words[ft] |= ht >>> 26) : st += 8;
        else {
          var bt = Oe.length - rt;
          for (nt = bt % 2 === 0 ? rt + 1 : rt; nt < Oe.length; nt += 2)
            ht = ie(Oe, rt, nt) << st, this.words[ft] |= ht & 67108863, st >= 18 ? (st -= 18, ft += 1, this.words[ft] |= ht >>> 26) : st += 8;
        }
        this.strip();
      };
      function ce(wt, Oe, rt, pe) {
        for (var nt = 0, st = Math.min(wt.length, rt), ft = Oe; ft < st; ft++) {
          var ht = wt.charCodeAt(ft) - 48;
          nt *= pe, ht >= 49 ? nt += ht - 49 + 10 : ht >= 17 ? nt += ht - 17 + 10 : nt += ht;
        }
        return nt;
      }
      W.prototype._parseBase = function(Oe, rt, pe) {
        this.words = [0], this.length = 1;
        for (var nt = 0, st = 1; st <= 67108863; st *= rt)
          nt++;
        nt--, st = st / rt | 0;
        for (var ft = Oe.length - pe, ht = ft % nt, bt = Math.min(ft, ft - ht) + pe, ut = 0, gt = pe; gt < bt; gt += nt)
          ut = ce(Oe, gt, gt + nt, rt), this.imuln(st), this.words[0] + ut < 67108864 ? this.words[0] += ut : this._iaddn(ut);
        if (ht !== 0) {
          var lt = 1;
          for (ut = ce(Oe, gt, Oe.length, rt), gt = 0; gt < ht; gt++)
            lt *= rt;
          this.imuln(lt), this.words[0] + ut < 67108864 ? this.words[0] += ut : this._iaddn(ut);
        }
        this.strip();
      }, W.prototype.copy = function(Oe) {
        Oe.words = new Array(this.length);
        for (var rt = 0; rt < this.length; rt++)
          Oe.words[rt] = this.words[rt];
        Oe.length = this.length, Oe.negative = this.negative, Oe.red = this.red;
      }, W.prototype.clone = function() {
        var Oe = new W(null);
        return this.copy(Oe), Oe;
      }, W.prototype._expand = function(Oe) {
        for (; this.length < Oe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, W.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var re = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], oe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ke = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(Oe, rt) {
        Oe = Oe || 10, rt = rt | 0 || 1;
        var pe;
        if (Oe === 16 || Oe === "hex") {
          pe = "";
          for (var nt = 0, st = 0, ft = 0; ft < this.length; ft++) {
            var ht = this.words[ft], bt = ((ht << nt | st) & 16777215).toString(16);
            st = ht >>> 24 - nt & 16777215, nt += 2, nt >= 26 && (nt -= 26, ft--), st !== 0 || ft !== this.length - 1 ? pe = re[6 - bt.length] + bt + pe : pe = bt + pe;
          }
          for (st !== 0 && (pe = st.toString(16) + pe); pe.length % rt !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        if (Oe === (Oe | 0) && Oe >= 2 && Oe <= 36) {
          var ut = oe[Oe], gt = ke[Oe];
          pe = "";
          var lt = this.clone();
          for (lt.negative = 0; !lt.isZero(); ) {
            var $t = lt.modn(gt).toString(Oe);
            lt = lt.idivn(gt), lt.isZero() ? pe = $t + pe : pe = re[ut - $t.length] + $t + pe;
          }
          for (this.isZero() && (pe = "0" + pe); pe.length % rt !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var Oe = this.words[0];
        return this.length === 2 ? Oe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Oe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Oe : Oe;
      }, W.prototype.toJSON = function() {
        return this.toString(16);
      }, W.prototype.toBuffer = function(Oe, rt) {
        return K(typeof J < "u"), this.toArrayLike(J, Oe, rt);
      }, W.prototype.toArray = function(Oe, rt) {
        return this.toArrayLike(Array, Oe, rt);
      }, W.prototype.toArrayLike = function(Oe, rt, pe) {
        var nt = this.byteLength(), st = pe || Math.max(1, nt);
        K(nt <= st, "byte array longer than desired length"), K(st > 0, "Requested array length <= 0"), this.strip();
        var ft = rt === "le", ht = new Oe(st), bt, ut, gt = this.clone();
        if (ft) {
          for (ut = 0; !gt.isZero(); ut++)
            bt = gt.andln(255), gt.iushrn(8), ht[ut] = bt;
          for (; ut < st; ut++)
            ht[ut] = 0;
        } else {
          for (ut = 0; ut < st - nt; ut++)
            ht[ut] = 0;
          for (ut = 0; !gt.isZero(); ut++)
            bt = gt.andln(255), gt.iushrn(8), ht[st - ut - 1] = bt;
        }
        return ht;
      }, Math.clz32 ? W.prototype._countBits = function(Oe) {
        return 32 - Math.clz32(Oe);
      } : W.prototype._countBits = function(Oe) {
        var rt = Oe, pe = 0;
        return rt >= 4096 && (pe += 13, rt >>>= 13), rt >= 64 && (pe += 7, rt >>>= 7), rt >= 8 && (pe += 4, rt >>>= 4), rt >= 2 && (pe += 2, rt >>>= 2), pe + rt;
      }, W.prototype._zeroBits = function(Oe) {
        if (Oe === 0) return 26;
        var rt = Oe, pe = 0;
        return rt & 8191 || (pe += 13, rt >>>= 13), rt & 127 || (pe += 7, rt >>>= 7), rt & 15 || (pe += 4, rt >>>= 4), rt & 3 || (pe += 2, rt >>>= 2), rt & 1 || pe++, pe;
      }, W.prototype.bitLength = function() {
        var Oe = this.words[this.length - 1], rt = this._countBits(Oe);
        return (this.length - 1) * 26 + rt;
      };
      function Ce(wt) {
        for (var Oe = new Array(wt.bitLength()), rt = 0; rt < Oe.length; rt++) {
          var pe = rt / 26 | 0, nt = rt % 26;
          Oe[rt] = (wt.words[pe] & 1 << nt) >>> nt;
        }
        return Oe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Oe = 0, rt = 0; rt < this.length; rt++) {
          var pe = this._zeroBits(this.words[rt]);
          if (Oe += pe, pe !== 26) break;
        }
        return Oe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(Oe) {
        return this.negative !== 0 ? this.abs().inotn(Oe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(Oe) {
        return this.testn(Oe - 1) ? this.notn(Oe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(Oe) {
        for (; this.length < Oe.length; )
          this.words[this.length++] = 0;
        for (var rt = 0; rt < Oe.length; rt++)
          this.words[rt] = this.words[rt] | Oe.words[rt];
        return this.strip();
      }, W.prototype.ior = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuor(Oe);
      }, W.prototype.or = function(Oe) {
        return this.length > Oe.length ? this.clone().ior(Oe) : Oe.clone().ior(this);
      }, W.prototype.uor = function(Oe) {
        return this.length > Oe.length ? this.clone().iuor(Oe) : Oe.clone().iuor(this);
      }, W.prototype.iuand = function(Oe) {
        var rt;
        this.length > Oe.length ? rt = Oe : rt = this;
        for (var pe = 0; pe < rt.length; pe++)
          this.words[pe] = this.words[pe] & Oe.words[pe];
        return this.length = rt.length, this.strip();
      }, W.prototype.iand = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuand(Oe);
      }, W.prototype.and = function(Oe) {
        return this.length > Oe.length ? this.clone().iand(Oe) : Oe.clone().iand(this);
      }, W.prototype.uand = function(Oe) {
        return this.length > Oe.length ? this.clone().iuand(Oe) : Oe.clone().iuand(this);
      }, W.prototype.iuxor = function(Oe) {
        var rt, pe;
        this.length > Oe.length ? (rt = this, pe = Oe) : (rt = Oe, pe = this);
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = rt.words[nt] ^ pe.words[nt];
        if (this !== rt)
          for (; nt < rt.length; nt++)
            this.words[nt] = rt.words[nt];
        return this.length = rt.length, this.strip();
      }, W.prototype.ixor = function(Oe) {
        return K((this.negative | Oe.negative) === 0), this.iuxor(Oe);
      }, W.prototype.xor = function(Oe) {
        return this.length > Oe.length ? this.clone().ixor(Oe) : Oe.clone().ixor(this);
      }, W.prototype.uxor = function(Oe) {
        return this.length > Oe.length ? this.clone().iuxor(Oe) : Oe.clone().iuxor(this);
      }, W.prototype.inotn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Math.ceil(Oe / 26) | 0, pe = Oe % 26;
        this._expand(rt), pe > 0 && rt--;
        for (var nt = 0; nt < rt; nt++)
          this.words[nt] = ~this.words[nt] & 67108863;
        return pe > 0 && (this.words[nt] = ~this.words[nt] & 67108863 >> 26 - pe), this.strip();
      }, W.prototype.notn = function(Oe) {
        return this.clone().inotn(Oe);
      }, W.prototype.setn = function(Oe, rt) {
        K(typeof Oe == "number" && Oe >= 0);
        var pe = Oe / 26 | 0, nt = Oe % 26;
        return this._expand(pe + 1), rt ? this.words[pe] = this.words[pe] | 1 << nt : this.words[pe] = this.words[pe] & ~(1 << nt), this.strip();
      }, W.prototype.iadd = function(Oe) {
        var rt;
        if (this.negative !== 0 && Oe.negative === 0)
          return this.negative = 0, rt = this.isub(Oe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Oe.negative !== 0)
          return Oe.negative = 0, rt = this.isub(Oe), Oe.negative = 1, rt._normSign();
        var pe, nt;
        this.length > Oe.length ? (pe = this, nt = Oe) : (pe = Oe, nt = this);
        for (var st = 0, ft = 0; ft < nt.length; ft++)
          rt = (pe.words[ft] | 0) + (nt.words[ft] | 0) + st, this.words[ft] = rt & 67108863, st = rt >>> 26;
        for (; st !== 0 && ft < pe.length; ft++)
          rt = (pe.words[ft] | 0) + st, this.words[ft] = rt & 67108863, st = rt >>> 26;
        if (this.length = pe.length, st !== 0)
          this.words[this.length] = st, this.length++;
        else if (pe !== this)
          for (; ft < pe.length; ft++)
            this.words[ft] = pe.words[ft];
        return this;
      }, W.prototype.add = function(Oe) {
        var rt;
        return Oe.negative !== 0 && this.negative === 0 ? (Oe.negative = 0, rt = this.sub(Oe), Oe.negative ^= 1, rt) : Oe.negative === 0 && this.negative !== 0 ? (this.negative = 0, rt = Oe.sub(this), this.negative = 1, rt) : this.length > Oe.length ? this.clone().iadd(Oe) : Oe.clone().iadd(this);
      }, W.prototype.isub = function(Oe) {
        if (Oe.negative !== 0) {
          Oe.negative = 0;
          var rt = this.iadd(Oe);
          return Oe.negative = 1, rt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Oe), this.negative = 1, this._normSign();
        var pe = this.cmp(Oe);
        if (pe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var nt, st;
        pe > 0 ? (nt = this, st = Oe) : (nt = Oe, st = this);
        for (var ft = 0, ht = 0; ht < st.length; ht++)
          rt = (nt.words[ht] | 0) - (st.words[ht] | 0) + ft, ft = rt >> 26, this.words[ht] = rt & 67108863;
        for (; ft !== 0 && ht < nt.length; ht++)
          rt = (nt.words[ht] | 0) + ft, ft = rt >> 26, this.words[ht] = rt & 67108863;
        if (ft === 0 && ht < nt.length && nt !== this)
          for (; ht < nt.length; ht++)
            this.words[ht] = nt.words[ht];
        return this.length = Math.max(this.length, ht), nt !== this && (this.negative = 1), this.strip();
      }, W.prototype.sub = function(Oe) {
        return this.clone().isub(Oe);
      };
      function it(wt, Oe, rt) {
        rt.negative = Oe.negative ^ wt.negative;
        var pe = wt.length + Oe.length | 0;
        rt.length = pe, pe = pe - 1 | 0;
        var nt = wt.words[0] | 0, st = Oe.words[0] | 0, ft = nt * st, ht = ft & 67108863, bt = ft / 67108864 | 0;
        rt.words[0] = ht;
        for (var ut = 1; ut < pe; ut++) {
          for (var gt = bt >>> 26, lt = bt & 67108863, $t = Math.min(ut, Oe.length - 1), jt = Math.max(0, ut - wt.length + 1); jt <= $t; jt++) {
            var Jt = ut - jt | 0;
            nt = wt.words[Jt] | 0, st = Oe.words[jt] | 0, ft = nt * st + lt, gt += ft / 67108864 | 0, lt = ft & 67108863;
          }
          rt.words[ut] = lt | 0, bt = gt | 0;
        }
        return bt !== 0 ? rt.words[ut] = bt | 0 : rt.length--, rt.strip();
      }
      var at = function(Oe, rt, pe) {
        var nt = Oe.words, st = rt.words, ft = pe.words, ht = 0, bt, ut, gt, lt = nt[0] | 0, $t = lt & 8191, jt = lt >>> 13, Jt = nt[1] | 0, Lt = Jt & 8191, Rt = Jt >>> 13, Mt = nt[2] | 0, Kt = Mt & 8191, zt = Mt >>> 13, Ct = nt[3] | 0, kt = Ct & 8191, Vt = Ct >>> 13, nr = nt[4] | 0, ar = nr & 8191, sr = nr >>> 13, lr = nt[5] | 0, dr = lr & 8191, rr = lr >>> 13, Pr = nt[6] | 0, ur = Pr & 8191, pr = Pr >>> 13, br = nt[7] | 0, hr = br & 8191, xr = br >>> 13, Mr = nt[8] | 0, _r = Mr & 8191, Rr = Mr >>> 13, kr = nt[9] | 0, Ot = kr & 8191, At = kr >>> 13, Bt = st[0] | 0, Ut = Bt & 8191, Xt = Bt >>> 13, Zt = st[1] | 0, tr = Zt & 8191, vr = Zt >>> 13, Br = st[2] | 0, yr = Br & 8191, $r = Br >>> 13, Er = st[3] | 0, wr = Er & 8191, Ir = Er >>> 13, Or = st[4] | 0, Wt = Or & 8191, Ft = Or >>> 13, Gt = st[5] | 0, xt = Gt & 8191, pt = Gt >>> 13, Et = st[6] | 0, qt = Et & 8191, Ht = Et >>> 13, Yt = st[7] | 0, Qt = Yt & 8191, or = Yt >>> 13, cr = st[8] | 0, Dt = cr & 8191, er = cr >>> 13, ir = st[9] | 0, fr = ir & 8191, Ar = ir >>> 13;
        pe.negative = Oe.negative ^ rt.negative, pe.length = 19, bt = Math.imul($t, Ut), ut = Math.imul($t, Xt), ut = ut + Math.imul(jt, Ut) | 0, gt = Math.imul(jt, Xt);
        var Sr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Sr >>> 26) | 0, Sr &= 67108863, bt = Math.imul(Lt, Ut), ut = Math.imul(Lt, Xt), ut = ut + Math.imul(Rt, Ut) | 0, gt = Math.imul(Rt, Xt), bt = bt + Math.imul($t, tr) | 0, ut = ut + Math.imul($t, vr) | 0, ut = ut + Math.imul(jt, tr) | 0, gt = gt + Math.imul(jt, vr) | 0;
        var gr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (gr >>> 26) | 0, gr &= 67108863, bt = Math.imul(Kt, Ut), ut = Math.imul(Kt, Xt), ut = ut + Math.imul(zt, Ut) | 0, gt = Math.imul(zt, Xt), bt = bt + Math.imul(Lt, tr) | 0, ut = ut + Math.imul(Lt, vr) | 0, ut = ut + Math.imul(Rt, tr) | 0, gt = gt + Math.imul(Rt, vr) | 0, bt = bt + Math.imul($t, yr) | 0, ut = ut + Math.imul($t, $r) | 0, ut = ut + Math.imul(jt, yr) | 0, gt = gt + Math.imul(jt, $r) | 0;
        var Tr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, bt = Math.imul(kt, Ut), ut = Math.imul(kt, Xt), ut = ut + Math.imul(Vt, Ut) | 0, gt = Math.imul(Vt, Xt), bt = bt + Math.imul(Kt, tr) | 0, ut = ut + Math.imul(Kt, vr) | 0, ut = ut + Math.imul(zt, tr) | 0, gt = gt + Math.imul(zt, vr) | 0, bt = bt + Math.imul(Lt, yr) | 0, ut = ut + Math.imul(Lt, $r) | 0, ut = ut + Math.imul(Rt, yr) | 0, gt = gt + Math.imul(Rt, $r) | 0, bt = bt + Math.imul($t, wr) | 0, ut = ut + Math.imul($t, Ir) | 0, ut = ut + Math.imul(jt, wr) | 0, gt = gt + Math.imul(jt, Ir) | 0;
        var Nr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, bt = Math.imul(ar, Ut), ut = Math.imul(ar, Xt), ut = ut + Math.imul(sr, Ut) | 0, gt = Math.imul(sr, Xt), bt = bt + Math.imul(kt, tr) | 0, ut = ut + Math.imul(kt, vr) | 0, ut = ut + Math.imul(Vt, tr) | 0, gt = gt + Math.imul(Vt, vr) | 0, bt = bt + Math.imul(Kt, yr) | 0, ut = ut + Math.imul(Kt, $r) | 0, ut = ut + Math.imul(zt, yr) | 0, gt = gt + Math.imul(zt, $r) | 0, bt = bt + Math.imul(Lt, wr) | 0, ut = ut + Math.imul(Lt, Ir) | 0, ut = ut + Math.imul(Rt, wr) | 0, gt = gt + Math.imul(Rt, Ir) | 0, bt = bt + Math.imul($t, Wt) | 0, ut = ut + Math.imul($t, Ft) | 0, ut = ut + Math.imul(jt, Wt) | 0, gt = gt + Math.imul(jt, Ft) | 0;
        var Cr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, bt = Math.imul(dr, Ut), ut = Math.imul(dr, Xt), ut = ut + Math.imul(rr, Ut) | 0, gt = Math.imul(rr, Xt), bt = bt + Math.imul(ar, tr) | 0, ut = ut + Math.imul(ar, vr) | 0, ut = ut + Math.imul(sr, tr) | 0, gt = gt + Math.imul(sr, vr) | 0, bt = bt + Math.imul(kt, yr) | 0, ut = ut + Math.imul(kt, $r) | 0, ut = ut + Math.imul(Vt, yr) | 0, gt = gt + Math.imul(Vt, $r) | 0, bt = bt + Math.imul(Kt, wr) | 0, ut = ut + Math.imul(Kt, Ir) | 0, ut = ut + Math.imul(zt, wr) | 0, gt = gt + Math.imul(zt, Ir) | 0, bt = bt + Math.imul(Lt, Wt) | 0, ut = ut + Math.imul(Lt, Ft) | 0, ut = ut + Math.imul(Rt, Wt) | 0, gt = gt + Math.imul(Rt, Ft) | 0, bt = bt + Math.imul($t, xt) | 0, ut = ut + Math.imul($t, pt) | 0, ut = ut + Math.imul(jt, xt) | 0, gt = gt + Math.imul(jt, pt) | 0;
        var qr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, bt = Math.imul(ur, Ut), ut = Math.imul(ur, Xt), ut = ut + Math.imul(pr, Ut) | 0, gt = Math.imul(pr, Xt), bt = bt + Math.imul(dr, tr) | 0, ut = ut + Math.imul(dr, vr) | 0, ut = ut + Math.imul(rr, tr) | 0, gt = gt + Math.imul(rr, vr) | 0, bt = bt + Math.imul(ar, yr) | 0, ut = ut + Math.imul(ar, $r) | 0, ut = ut + Math.imul(sr, yr) | 0, gt = gt + Math.imul(sr, $r) | 0, bt = bt + Math.imul(kt, wr) | 0, ut = ut + Math.imul(kt, Ir) | 0, ut = ut + Math.imul(Vt, wr) | 0, gt = gt + Math.imul(Vt, Ir) | 0, bt = bt + Math.imul(Kt, Wt) | 0, ut = ut + Math.imul(Kt, Ft) | 0, ut = ut + Math.imul(zt, Wt) | 0, gt = gt + Math.imul(zt, Ft) | 0, bt = bt + Math.imul(Lt, xt) | 0, ut = ut + Math.imul(Lt, pt) | 0, ut = ut + Math.imul(Rt, xt) | 0, gt = gt + Math.imul(Rt, pt) | 0, bt = bt + Math.imul($t, qt) | 0, ut = ut + Math.imul($t, Ht) | 0, ut = ut + Math.imul(jt, qt) | 0, gt = gt + Math.imul(jt, Ht) | 0;
        var Ur = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, bt = Math.imul(hr, Ut), ut = Math.imul(hr, Xt), ut = ut + Math.imul(xr, Ut) | 0, gt = Math.imul(xr, Xt), bt = bt + Math.imul(ur, tr) | 0, ut = ut + Math.imul(ur, vr) | 0, ut = ut + Math.imul(pr, tr) | 0, gt = gt + Math.imul(pr, vr) | 0, bt = bt + Math.imul(dr, yr) | 0, ut = ut + Math.imul(dr, $r) | 0, ut = ut + Math.imul(rr, yr) | 0, gt = gt + Math.imul(rr, $r) | 0, bt = bt + Math.imul(ar, wr) | 0, ut = ut + Math.imul(ar, Ir) | 0, ut = ut + Math.imul(sr, wr) | 0, gt = gt + Math.imul(sr, Ir) | 0, bt = bt + Math.imul(kt, Wt) | 0, ut = ut + Math.imul(kt, Ft) | 0, ut = ut + Math.imul(Vt, Wt) | 0, gt = gt + Math.imul(Vt, Ft) | 0, bt = bt + Math.imul(Kt, xt) | 0, ut = ut + Math.imul(Kt, pt) | 0, ut = ut + Math.imul(zt, xt) | 0, gt = gt + Math.imul(zt, pt) | 0, bt = bt + Math.imul(Lt, qt) | 0, ut = ut + Math.imul(Lt, Ht) | 0, ut = ut + Math.imul(Rt, qt) | 0, gt = gt + Math.imul(Rt, Ht) | 0, bt = bt + Math.imul($t, Qt) | 0, ut = ut + Math.imul($t, or) | 0, ut = ut + Math.imul(jt, Qt) | 0, gt = gt + Math.imul(jt, or) | 0;
        var Dr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, bt = Math.imul(_r, Ut), ut = Math.imul(_r, Xt), ut = ut + Math.imul(Rr, Ut) | 0, gt = Math.imul(Rr, Xt), bt = bt + Math.imul(hr, tr) | 0, ut = ut + Math.imul(hr, vr) | 0, ut = ut + Math.imul(xr, tr) | 0, gt = gt + Math.imul(xr, vr) | 0, bt = bt + Math.imul(ur, yr) | 0, ut = ut + Math.imul(ur, $r) | 0, ut = ut + Math.imul(pr, yr) | 0, gt = gt + Math.imul(pr, $r) | 0, bt = bt + Math.imul(dr, wr) | 0, ut = ut + Math.imul(dr, Ir) | 0, ut = ut + Math.imul(rr, wr) | 0, gt = gt + Math.imul(rr, Ir) | 0, bt = bt + Math.imul(ar, Wt) | 0, ut = ut + Math.imul(ar, Ft) | 0, ut = ut + Math.imul(sr, Wt) | 0, gt = gt + Math.imul(sr, Ft) | 0, bt = bt + Math.imul(kt, xt) | 0, ut = ut + Math.imul(kt, pt) | 0, ut = ut + Math.imul(Vt, xt) | 0, gt = gt + Math.imul(Vt, pt) | 0, bt = bt + Math.imul(Kt, qt) | 0, ut = ut + Math.imul(Kt, Ht) | 0, ut = ut + Math.imul(zt, qt) | 0, gt = gt + Math.imul(zt, Ht) | 0, bt = bt + Math.imul(Lt, Qt) | 0, ut = ut + Math.imul(Lt, or) | 0, ut = ut + Math.imul(Rt, Qt) | 0, gt = gt + Math.imul(Rt, or) | 0, bt = bt + Math.imul($t, Dt) | 0, ut = ut + Math.imul($t, er) | 0, ut = ut + Math.imul(jt, Dt) | 0, gt = gt + Math.imul(jt, er) | 0;
        var Lr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, bt = Math.imul(Ot, Ut), ut = Math.imul(Ot, Xt), ut = ut + Math.imul(At, Ut) | 0, gt = Math.imul(At, Xt), bt = bt + Math.imul(_r, tr) | 0, ut = ut + Math.imul(_r, vr) | 0, ut = ut + Math.imul(Rr, tr) | 0, gt = gt + Math.imul(Rr, vr) | 0, bt = bt + Math.imul(hr, yr) | 0, ut = ut + Math.imul(hr, $r) | 0, ut = ut + Math.imul(xr, yr) | 0, gt = gt + Math.imul(xr, $r) | 0, bt = bt + Math.imul(ur, wr) | 0, ut = ut + Math.imul(ur, Ir) | 0, ut = ut + Math.imul(pr, wr) | 0, gt = gt + Math.imul(pr, Ir) | 0, bt = bt + Math.imul(dr, Wt) | 0, ut = ut + Math.imul(dr, Ft) | 0, ut = ut + Math.imul(rr, Wt) | 0, gt = gt + Math.imul(rr, Ft) | 0, bt = bt + Math.imul(ar, xt) | 0, ut = ut + Math.imul(ar, pt) | 0, ut = ut + Math.imul(sr, xt) | 0, gt = gt + Math.imul(sr, pt) | 0, bt = bt + Math.imul(kt, qt) | 0, ut = ut + Math.imul(kt, Ht) | 0, ut = ut + Math.imul(Vt, qt) | 0, gt = gt + Math.imul(Vt, Ht) | 0, bt = bt + Math.imul(Kt, Qt) | 0, ut = ut + Math.imul(Kt, or) | 0, ut = ut + Math.imul(zt, Qt) | 0, gt = gt + Math.imul(zt, or) | 0, bt = bt + Math.imul(Lt, Dt) | 0, ut = ut + Math.imul(Lt, er) | 0, ut = ut + Math.imul(Rt, Dt) | 0, gt = gt + Math.imul(Rt, er) | 0, bt = bt + Math.imul($t, fr) | 0, ut = ut + Math.imul($t, Ar) | 0, ut = ut + Math.imul(jt, fr) | 0, gt = gt + Math.imul(jt, Ar) | 0;
        var Fr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, bt = Math.imul(Ot, tr), ut = Math.imul(Ot, vr), ut = ut + Math.imul(At, tr) | 0, gt = Math.imul(At, vr), bt = bt + Math.imul(_r, yr) | 0, ut = ut + Math.imul(_r, $r) | 0, ut = ut + Math.imul(Rr, yr) | 0, gt = gt + Math.imul(Rr, $r) | 0, bt = bt + Math.imul(hr, wr) | 0, ut = ut + Math.imul(hr, Ir) | 0, ut = ut + Math.imul(xr, wr) | 0, gt = gt + Math.imul(xr, Ir) | 0, bt = bt + Math.imul(ur, Wt) | 0, ut = ut + Math.imul(ur, Ft) | 0, ut = ut + Math.imul(pr, Wt) | 0, gt = gt + Math.imul(pr, Ft) | 0, bt = bt + Math.imul(dr, xt) | 0, ut = ut + Math.imul(dr, pt) | 0, ut = ut + Math.imul(rr, xt) | 0, gt = gt + Math.imul(rr, pt) | 0, bt = bt + Math.imul(ar, qt) | 0, ut = ut + Math.imul(ar, Ht) | 0, ut = ut + Math.imul(sr, qt) | 0, gt = gt + Math.imul(sr, Ht) | 0, bt = bt + Math.imul(kt, Qt) | 0, ut = ut + Math.imul(kt, or) | 0, ut = ut + Math.imul(Vt, Qt) | 0, gt = gt + Math.imul(Vt, or) | 0, bt = bt + Math.imul(Kt, Dt) | 0, ut = ut + Math.imul(Kt, er) | 0, ut = ut + Math.imul(zt, Dt) | 0, gt = gt + Math.imul(zt, er) | 0, bt = bt + Math.imul(Lt, fr) | 0, ut = ut + Math.imul(Lt, Ar) | 0, ut = ut + Math.imul(Rt, fr) | 0, gt = gt + Math.imul(Rt, Ar) | 0;
        var jr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, bt = Math.imul(Ot, yr), ut = Math.imul(Ot, $r), ut = ut + Math.imul(At, yr) | 0, gt = Math.imul(At, $r), bt = bt + Math.imul(_r, wr) | 0, ut = ut + Math.imul(_r, Ir) | 0, ut = ut + Math.imul(Rr, wr) | 0, gt = gt + Math.imul(Rr, Ir) | 0, bt = bt + Math.imul(hr, Wt) | 0, ut = ut + Math.imul(hr, Ft) | 0, ut = ut + Math.imul(xr, Wt) | 0, gt = gt + Math.imul(xr, Ft) | 0, bt = bt + Math.imul(ur, xt) | 0, ut = ut + Math.imul(ur, pt) | 0, ut = ut + Math.imul(pr, xt) | 0, gt = gt + Math.imul(pr, pt) | 0, bt = bt + Math.imul(dr, qt) | 0, ut = ut + Math.imul(dr, Ht) | 0, ut = ut + Math.imul(rr, qt) | 0, gt = gt + Math.imul(rr, Ht) | 0, bt = bt + Math.imul(ar, Qt) | 0, ut = ut + Math.imul(ar, or) | 0, ut = ut + Math.imul(sr, Qt) | 0, gt = gt + Math.imul(sr, or) | 0, bt = bt + Math.imul(kt, Dt) | 0, ut = ut + Math.imul(kt, er) | 0, ut = ut + Math.imul(Vt, Dt) | 0, gt = gt + Math.imul(Vt, er) | 0, bt = bt + Math.imul(Kt, fr) | 0, ut = ut + Math.imul(Kt, Ar) | 0, ut = ut + Math.imul(zt, fr) | 0, gt = gt + Math.imul(zt, Ar) | 0;
        var Hr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, bt = Math.imul(Ot, wr), ut = Math.imul(Ot, Ir), ut = ut + Math.imul(At, wr) | 0, gt = Math.imul(At, Ir), bt = bt + Math.imul(_r, Wt) | 0, ut = ut + Math.imul(_r, Ft) | 0, ut = ut + Math.imul(Rr, Wt) | 0, gt = gt + Math.imul(Rr, Ft) | 0, bt = bt + Math.imul(hr, xt) | 0, ut = ut + Math.imul(hr, pt) | 0, ut = ut + Math.imul(xr, xt) | 0, gt = gt + Math.imul(xr, pt) | 0, bt = bt + Math.imul(ur, qt) | 0, ut = ut + Math.imul(ur, Ht) | 0, ut = ut + Math.imul(pr, qt) | 0, gt = gt + Math.imul(pr, Ht) | 0, bt = bt + Math.imul(dr, Qt) | 0, ut = ut + Math.imul(dr, or) | 0, ut = ut + Math.imul(rr, Qt) | 0, gt = gt + Math.imul(rr, or) | 0, bt = bt + Math.imul(ar, Dt) | 0, ut = ut + Math.imul(ar, er) | 0, ut = ut + Math.imul(sr, Dt) | 0, gt = gt + Math.imul(sr, er) | 0, bt = bt + Math.imul(kt, fr) | 0, ut = ut + Math.imul(kt, Ar) | 0, ut = ut + Math.imul(Vt, fr) | 0, gt = gt + Math.imul(Vt, Ar) | 0;
        var Wr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, bt = Math.imul(Ot, Wt), ut = Math.imul(Ot, Ft), ut = ut + Math.imul(At, Wt) | 0, gt = Math.imul(At, Ft), bt = bt + Math.imul(_r, xt) | 0, ut = ut + Math.imul(_r, pt) | 0, ut = ut + Math.imul(Rr, xt) | 0, gt = gt + Math.imul(Rr, pt) | 0, bt = bt + Math.imul(hr, qt) | 0, ut = ut + Math.imul(hr, Ht) | 0, ut = ut + Math.imul(xr, qt) | 0, gt = gt + Math.imul(xr, Ht) | 0, bt = bt + Math.imul(ur, Qt) | 0, ut = ut + Math.imul(ur, or) | 0, ut = ut + Math.imul(pr, Qt) | 0, gt = gt + Math.imul(pr, or) | 0, bt = bt + Math.imul(dr, Dt) | 0, ut = ut + Math.imul(dr, er) | 0, ut = ut + Math.imul(rr, Dt) | 0, gt = gt + Math.imul(rr, er) | 0, bt = bt + Math.imul(ar, fr) | 0, ut = ut + Math.imul(ar, Ar) | 0, ut = ut + Math.imul(sr, fr) | 0, gt = gt + Math.imul(sr, Ar) | 0;
        var Gr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, bt = Math.imul(Ot, xt), ut = Math.imul(Ot, pt), ut = ut + Math.imul(At, xt) | 0, gt = Math.imul(At, pt), bt = bt + Math.imul(_r, qt) | 0, ut = ut + Math.imul(_r, Ht) | 0, ut = ut + Math.imul(Rr, qt) | 0, gt = gt + Math.imul(Rr, Ht) | 0, bt = bt + Math.imul(hr, Qt) | 0, ut = ut + Math.imul(hr, or) | 0, ut = ut + Math.imul(xr, Qt) | 0, gt = gt + Math.imul(xr, or) | 0, bt = bt + Math.imul(ur, Dt) | 0, ut = ut + Math.imul(ur, er) | 0, ut = ut + Math.imul(pr, Dt) | 0, gt = gt + Math.imul(pr, er) | 0, bt = bt + Math.imul(dr, fr) | 0, ut = ut + Math.imul(dr, Ar) | 0, ut = ut + Math.imul(rr, fr) | 0, gt = gt + Math.imul(rr, Ar) | 0;
        var Vr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, bt = Math.imul(Ot, qt), ut = Math.imul(Ot, Ht), ut = ut + Math.imul(At, qt) | 0, gt = Math.imul(At, Ht), bt = bt + Math.imul(_r, Qt) | 0, ut = ut + Math.imul(_r, or) | 0, ut = ut + Math.imul(Rr, Qt) | 0, gt = gt + Math.imul(Rr, or) | 0, bt = bt + Math.imul(hr, Dt) | 0, ut = ut + Math.imul(hr, er) | 0, ut = ut + Math.imul(xr, Dt) | 0, gt = gt + Math.imul(xr, er) | 0, bt = bt + Math.imul(ur, fr) | 0, ut = ut + Math.imul(ur, Ar) | 0, ut = ut + Math.imul(pr, fr) | 0, gt = gt + Math.imul(pr, Ar) | 0;
        var zr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, bt = Math.imul(Ot, Qt), ut = Math.imul(Ot, or), ut = ut + Math.imul(At, Qt) | 0, gt = Math.imul(At, or), bt = bt + Math.imul(_r, Dt) | 0, ut = ut + Math.imul(_r, er) | 0, ut = ut + Math.imul(Rr, Dt) | 0, gt = gt + Math.imul(Rr, er) | 0, bt = bt + Math.imul(hr, fr) | 0, ut = ut + Math.imul(hr, Ar) | 0, ut = ut + Math.imul(xr, fr) | 0, gt = gt + Math.imul(xr, Ar) | 0;
        var Xr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, bt = Math.imul(Ot, Dt), ut = Math.imul(Ot, er), ut = ut + Math.imul(At, Dt) | 0, gt = Math.imul(At, er), bt = bt + Math.imul(_r, fr) | 0, ut = ut + Math.imul(_r, Ar) | 0, ut = ut + Math.imul(Rr, fr) | 0, gt = gt + Math.imul(Rr, Ar) | 0;
        var Yr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        ht = (gt + (ut >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, bt = Math.imul(Ot, fr), ut = Math.imul(Ot, Ar), ut = ut + Math.imul(At, fr) | 0, gt = Math.imul(At, Ar);
        var Jr = (ht + bt | 0) + ((ut & 8191) << 13) | 0;
        return ht = (gt + (ut >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, ft[0] = Sr, ft[1] = gr, ft[2] = Tr, ft[3] = Nr, ft[4] = Cr, ft[5] = qr, ft[6] = Ur, ft[7] = Dr, ft[8] = Lr, ft[9] = Fr, ft[10] = jr, ft[11] = Hr, ft[12] = Wr, ft[13] = Gr, ft[14] = Vr, ft[15] = zr, ft[16] = Xr, ft[17] = Yr, ft[18] = Jr, ht !== 0 && (ft[19] = ht, pe.length++), pe;
      };
      Math.imul || (at = it);
      function ct(wt, Oe, rt) {
        rt.negative = Oe.negative ^ wt.negative, rt.length = wt.length + Oe.length;
        for (var pe = 0, nt = 0, st = 0; st < rt.length - 1; st++) {
          var ft = nt;
          nt = 0;
          for (var ht = pe & 67108863, bt = Math.min(st, Oe.length - 1), ut = Math.max(0, st - wt.length + 1); ut <= bt; ut++) {
            var gt = st - ut, lt = wt.words[gt] | 0, $t = Oe.words[ut] | 0, jt = lt * $t, Jt = jt & 67108863;
            ft = ft + (jt / 67108864 | 0) | 0, Jt = Jt + ht | 0, ht = Jt & 67108863, ft = ft + (Jt >>> 26) | 0, nt += ft >>> 26, ft &= 67108863;
          }
          rt.words[st] = ht, pe = ft, ft = nt;
        }
        return pe !== 0 ? rt.words[st] = pe : rt.length--, rt.strip();
      }
      function dt(wt, Oe, rt) {
        var pe = new ot();
        return pe.mulp(wt, Oe, rt);
      }
      W.prototype.mulTo = function(Oe, rt) {
        var pe, nt = this.length + Oe.length;
        return this.length === 10 && Oe.length === 10 ? pe = at(this, Oe, rt) : nt < 63 ? pe = it(this, Oe, rt) : nt < 1024 ? pe = ct(this, Oe, rt) : pe = dt(this, Oe, rt), pe;
      };
      function ot(wt, Oe) {
        this.x = wt, this.y = Oe;
      }
      ot.prototype.makeRBT = function(Oe) {
        for (var rt = new Array(Oe), pe = W.prototype._countBits(Oe) - 1, nt = 0; nt < Oe; nt++)
          rt[nt] = this.revBin(nt, pe, Oe);
        return rt;
      }, ot.prototype.revBin = function(Oe, rt, pe) {
        if (Oe === 0 || Oe === pe - 1) return Oe;
        for (var nt = 0, st = 0; st < rt; st++)
          nt |= (Oe & 1) << rt - st - 1, Oe >>= 1;
        return nt;
      }, ot.prototype.permute = function(Oe, rt, pe, nt, st, ft) {
        for (var ht = 0; ht < ft; ht++)
          nt[ht] = rt[Oe[ht]], st[ht] = pe[Oe[ht]];
      }, ot.prototype.transform = function(Oe, rt, pe, nt, st, ft) {
        this.permute(ft, Oe, rt, pe, nt, st);
        for (var ht = 1; ht < st; ht <<= 1)
          for (var bt = ht << 1, ut = Math.cos(2 * Math.PI / bt), gt = Math.sin(2 * Math.PI / bt), lt = 0; lt < st; lt += bt)
            for (var $t = ut, jt = gt, Jt = 0; Jt < ht; Jt++) {
              var Lt = pe[lt + Jt], Rt = nt[lt + Jt], Mt = pe[lt + Jt + ht], Kt = nt[lt + Jt + ht], zt = $t * Mt - jt * Kt;
              Kt = $t * Kt + jt * Mt, Mt = zt, pe[lt + Jt] = Lt + Mt, nt[lt + Jt] = Rt + Kt, pe[lt + Jt + ht] = Lt - Mt, nt[lt + Jt + ht] = Rt - Kt, Jt !== bt && (zt = ut * $t - gt * jt, jt = ut * jt + gt * $t, $t = zt);
            }
      }, ot.prototype.guessLen13b = function(Oe, rt) {
        var pe = Math.max(rt, Oe) | 1, nt = pe & 1, st = 0;
        for (pe = pe / 2 | 0; pe; pe = pe >>> 1)
          st++;
        return 1 << st + 1 + nt;
      }, ot.prototype.conjugate = function(Oe, rt, pe) {
        if (!(pe <= 1))
          for (var nt = 0; nt < pe / 2; nt++) {
            var st = Oe[nt];
            Oe[nt] = Oe[pe - nt - 1], Oe[pe - nt - 1] = st, st = rt[nt], rt[nt] = -rt[pe - nt - 1], rt[pe - nt - 1] = -st;
          }
      }, ot.prototype.normalize13b = function(Oe, rt) {
        for (var pe = 0, nt = 0; nt < rt / 2; nt++) {
          var st = Math.round(Oe[2 * nt + 1] / rt) * 8192 + Math.round(Oe[2 * nt] / rt) + pe;
          Oe[nt] = st & 67108863, st < 67108864 ? pe = 0 : pe = st / 67108864 | 0;
        }
        return Oe;
      }, ot.prototype.convert13b = function(Oe, rt, pe, nt) {
        for (var st = 0, ft = 0; ft < rt; ft++)
          st = st + (Oe[ft] | 0), pe[2 * ft] = st & 8191, st = st >>> 13, pe[2 * ft + 1] = st & 8191, st = st >>> 13;
        for (ft = 2 * rt; ft < nt; ++ft)
          pe[ft] = 0;
        K(st === 0), K((st & -8192) === 0);
      }, ot.prototype.stub = function(Oe) {
        for (var rt = new Array(Oe), pe = 0; pe < Oe; pe++)
          rt[pe] = 0;
        return rt;
      }, ot.prototype.mulp = function(Oe, rt, pe) {
        var nt = 2 * this.guessLen13b(Oe.length, rt.length), st = this.makeRBT(nt), ft = this.stub(nt), ht = new Array(nt), bt = new Array(nt), ut = new Array(nt), gt = new Array(nt), lt = new Array(nt), $t = new Array(nt), jt = pe.words;
        jt.length = nt, this.convert13b(Oe.words, Oe.length, ht, nt), this.convert13b(rt.words, rt.length, gt, nt), this.transform(ht, ft, bt, ut, nt, st), this.transform(gt, ft, lt, $t, nt, st);
        for (var Jt = 0; Jt < nt; Jt++) {
          var Lt = bt[Jt] * lt[Jt] - ut[Jt] * $t[Jt];
          ut[Jt] = bt[Jt] * $t[Jt] + ut[Jt] * lt[Jt], bt[Jt] = Lt;
        }
        return this.conjugate(bt, ut, nt), this.transform(bt, ut, jt, ft, nt, st), this.conjugate(jt, ft, nt), this.normalize13b(jt, nt), pe.negative = Oe.negative ^ rt.negative, pe.length = Oe.length + rt.length, pe.strip();
      }, W.prototype.mul = function(Oe) {
        var rt = new W(null);
        return rt.words = new Array(this.length + Oe.length), this.mulTo(Oe, rt);
      }, W.prototype.mulf = function(Oe) {
        var rt = new W(null);
        return rt.words = new Array(this.length + Oe.length), dt(this, Oe, rt);
      }, W.prototype.imul = function(Oe) {
        return this.clone().mulTo(Oe, this);
      }, W.prototype.imuln = function(Oe) {
        K(typeof Oe == "number"), K(Oe < 67108864);
        for (var rt = 0, pe = 0; pe < this.length; pe++) {
          var nt = (this.words[pe] | 0) * Oe, st = (nt & 67108863) + (rt & 67108863);
          rt >>= 26, rt += nt / 67108864 | 0, rt += st >>> 26, this.words[pe] = st & 67108863;
        }
        return rt !== 0 && (this.words[pe] = rt, this.length++), this;
      }, W.prototype.muln = function(Oe) {
        return this.clone().imuln(Oe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(Oe) {
        var rt = Ce(Oe);
        if (rt.length === 0) return new W(1);
        for (var pe = this, nt = 0; nt < rt.length && rt[nt] === 0; nt++, pe = pe.sqr())
          ;
        if (++nt < rt.length)
          for (var st = pe.sqr(); nt < rt.length; nt++, st = st.sqr())
            rt[nt] !== 0 && (pe = pe.mul(st));
        return pe;
      }, W.prototype.iushln = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 67108863 >>> 26 - rt << 26 - rt, st;
        if (rt !== 0) {
          var ft = 0;
          for (st = 0; st < this.length; st++) {
            var ht = this.words[st] & nt, bt = (this.words[st] | 0) - ht << rt;
            this.words[st] = bt | ft, ft = ht >>> 26 - rt;
          }
          ft && (this.words[st] = ft, this.length++);
        }
        if (pe !== 0) {
          for (st = this.length - 1; st >= 0; st--)
            this.words[st + pe] = this.words[st];
          for (st = 0; st < pe; st++)
            this.words[st] = 0;
          this.length += pe;
        }
        return this.strip();
      }, W.prototype.ishln = function(Oe) {
        return K(this.negative === 0), this.iushln(Oe);
      }, W.prototype.iushrn = function(Oe, rt, pe) {
        K(typeof Oe == "number" && Oe >= 0);
        var nt;
        rt ? nt = (rt - rt % 26) / 26 : nt = 0;
        var st = Oe % 26, ft = Math.min((Oe - st) / 26, this.length), ht = 67108863 ^ 67108863 >>> st << st, bt = pe;
        if (nt -= ft, nt = Math.max(0, nt), bt) {
          for (var ut = 0; ut < ft; ut++)
            bt.words[ut] = this.words[ut];
          bt.length = ft;
        }
        if (ft !== 0) if (this.length > ft)
          for (this.length -= ft, ut = 0; ut < this.length; ut++)
            this.words[ut] = this.words[ut + ft];
        else
          this.words[0] = 0, this.length = 1;
        var gt = 0;
        for (ut = this.length - 1; ut >= 0 && (gt !== 0 || ut >= nt); ut--) {
          var lt = this.words[ut] | 0;
          this.words[ut] = gt << 26 - st | lt >>> st, gt = lt & ht;
        }
        return bt && gt !== 0 && (bt.words[bt.length++] = gt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, W.prototype.ishrn = function(Oe, rt, pe) {
        return K(this.negative === 0), this.iushrn(Oe, rt, pe);
      }, W.prototype.shln = function(Oe) {
        return this.clone().ishln(Oe);
      }, W.prototype.ushln = function(Oe) {
        return this.clone().iushln(Oe);
      }, W.prototype.shrn = function(Oe) {
        return this.clone().ishrn(Oe);
      }, W.prototype.ushrn = function(Oe) {
        return this.clone().iushrn(Oe);
      }, W.prototype.testn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 1 << rt;
        if (this.length <= pe) return !1;
        var st = this.words[pe];
        return !!(st & nt);
      }, W.prototype.imaskn = function(Oe) {
        K(typeof Oe == "number" && Oe >= 0);
        var rt = Oe % 26, pe = (Oe - rt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= pe)
          return this;
        if (rt !== 0 && pe++, this.length = Math.min(pe, this.length), rt !== 0) {
          var nt = 67108863 ^ 67108863 >>> rt << rt;
          this.words[this.length - 1] &= nt;
        }
        return this.strip();
      }, W.prototype.maskn = function(Oe) {
        return this.clone().imaskn(Oe);
      }, W.prototype.iaddn = function(Oe) {
        return K(typeof Oe == "number"), K(Oe < 67108864), Oe < 0 ? this.isubn(-Oe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Oe ? (this.words[0] = Oe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Oe), this.negative = 1, this) : this._iaddn(Oe);
      }, W.prototype._iaddn = function(Oe) {
        this.words[0] += Oe;
        for (var rt = 0; rt < this.length && this.words[rt] >= 67108864; rt++)
          this.words[rt] -= 67108864, rt === this.length - 1 ? this.words[rt + 1] = 1 : this.words[rt + 1]++;
        return this.length = Math.max(this.length, rt + 1), this;
      }, W.prototype.isubn = function(Oe) {
        if (K(typeof Oe == "number"), K(Oe < 67108864), Oe < 0) return this.iaddn(-Oe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Oe), this.negative = 1, this;
        if (this.words[0] -= Oe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var rt = 0; rt < this.length && this.words[rt] < 0; rt++)
            this.words[rt] += 67108864, this.words[rt + 1] -= 1;
        return this.strip();
      }, W.prototype.addn = function(Oe) {
        return this.clone().iaddn(Oe);
      }, W.prototype.subn = function(Oe) {
        return this.clone().isubn(Oe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(Oe, rt, pe) {
        var nt = Oe.length + pe, st;
        this._expand(nt);
        var ft, ht = 0;
        for (st = 0; st < Oe.length; st++) {
          ft = (this.words[st + pe] | 0) + ht;
          var bt = (Oe.words[st] | 0) * rt;
          ft -= bt & 67108863, ht = (ft >> 26) - (bt / 67108864 | 0), this.words[st + pe] = ft & 67108863;
        }
        for (; st < this.length - pe; st++)
          ft = (this.words[st + pe] | 0) + ht, ht = ft >> 26, this.words[st + pe] = ft & 67108863;
        if (ht === 0) return this.strip();
        for (K(ht === -1), ht = 0, st = 0; st < this.length; st++)
          ft = -(this.words[st] | 0) + ht, ht = ft >> 26, this.words[st] = ft & 67108863;
        return this.negative = 1, this.strip();
      }, W.prototype._wordDiv = function(Oe, rt) {
        var pe = this.length - Oe.length, nt = this.clone(), st = Oe, ft = st.words[st.length - 1] | 0, ht = this._countBits(ft);
        pe = 26 - ht, pe !== 0 && (st = st.ushln(pe), nt.iushln(pe), ft = st.words[st.length - 1] | 0);
        var bt = nt.length - st.length, ut;
        if (rt !== "mod") {
          ut = new W(null), ut.length = bt + 1, ut.words = new Array(ut.length);
          for (var gt = 0; gt < ut.length; gt++)
            ut.words[gt] = 0;
        }
        var lt = nt.clone()._ishlnsubmul(st, 1, bt);
        lt.negative === 0 && (nt = lt, ut && (ut.words[bt] = 1));
        for (var $t = bt - 1; $t >= 0; $t--) {
          var jt = (nt.words[st.length + $t] | 0) * 67108864 + (nt.words[st.length + $t - 1] | 0);
          for (jt = Math.min(jt / ft | 0, 67108863), nt._ishlnsubmul(st, jt, $t); nt.negative !== 0; )
            jt--, nt.negative = 0, nt._ishlnsubmul(st, 1, $t), nt.isZero() || (nt.negative ^= 1);
          ut && (ut.words[$t] = jt);
        }
        return ut && ut.strip(), nt.strip(), rt !== "div" && pe !== 0 && nt.iushrn(pe), {
          div: ut || null,
          mod: nt
        };
      }, W.prototype.divmod = function(Oe, rt, pe) {
        if (K(!Oe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var nt, st, ft;
        return this.negative !== 0 && Oe.negative === 0 ? (ft = this.neg().divmod(Oe, rt), rt !== "mod" && (nt = ft.div.neg()), rt !== "div" && (st = ft.mod.neg(), pe && st.negative !== 0 && st.iadd(Oe)), {
          div: nt,
          mod: st
        }) : this.negative === 0 && Oe.negative !== 0 ? (ft = this.divmod(Oe.neg(), rt), rt !== "mod" && (nt = ft.div.neg()), {
          div: nt,
          mod: ft.mod
        }) : this.negative & Oe.negative ? (ft = this.neg().divmod(Oe.neg(), rt), rt !== "div" && (st = ft.mod.neg(), pe && st.negative !== 0 && st.isub(Oe)), {
          div: ft.div,
          mod: st
        }) : Oe.length > this.length || this.cmp(Oe) < 0 ? {
          div: new W(0),
          mod: this
        } : Oe.length === 1 ? rt === "div" ? {
          div: this.divn(Oe.words[0]),
          mod: null
        } : rt === "mod" ? {
          div: null,
          mod: new W(this.modn(Oe.words[0]))
        } : {
          div: this.divn(Oe.words[0]),
          mod: new W(this.modn(Oe.words[0]))
        } : this._wordDiv(Oe, rt);
      }, W.prototype.div = function(Oe) {
        return this.divmod(Oe, "div", !1).div;
      }, W.prototype.mod = function(Oe) {
        return this.divmod(Oe, "mod", !1).mod;
      }, W.prototype.umod = function(Oe) {
        return this.divmod(Oe, "mod", !0).mod;
      }, W.prototype.divRound = function(Oe) {
        var rt = this.divmod(Oe);
        if (rt.mod.isZero()) return rt.div;
        var pe = rt.div.negative !== 0 ? rt.mod.isub(Oe) : rt.mod, nt = Oe.ushrn(1), st = Oe.andln(1), ft = pe.cmp(nt);
        return ft < 0 || st === 1 && ft === 0 ? rt.div : rt.div.negative !== 0 ? rt.div.isubn(1) : rt.div.iaddn(1);
      }, W.prototype.modn = function(Oe) {
        K(Oe <= 67108863);
        for (var rt = (1 << 26) % Oe, pe = 0, nt = this.length - 1; nt >= 0; nt--)
          pe = (rt * pe + (this.words[nt] | 0)) % Oe;
        return pe;
      }, W.prototype.idivn = function(Oe) {
        K(Oe <= 67108863);
        for (var rt = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = (this.words[pe] | 0) + rt * 67108864;
          this.words[pe] = nt / Oe | 0, rt = nt % Oe;
        }
        return this.strip();
      }, W.prototype.divn = function(Oe) {
        return this.clone().idivn(Oe);
      }, W.prototype.egcd = function(Oe) {
        K(Oe.negative === 0), K(!Oe.isZero());
        var rt = this, pe = Oe.clone();
        rt.negative !== 0 ? rt = rt.umod(Oe) : rt = rt.clone();
        for (var nt = new W(1), st = new W(0), ft = new W(0), ht = new W(1), bt = 0; rt.isEven() && pe.isEven(); )
          rt.iushrn(1), pe.iushrn(1), ++bt;
        for (var ut = pe.clone(), gt = rt.clone(); !rt.isZero(); ) {
          for (var lt = 0, $t = 1; !(rt.words[0] & $t) && lt < 26; ++lt, $t <<= 1) ;
          if (lt > 0)
            for (rt.iushrn(lt); lt-- > 0; )
              (nt.isOdd() || st.isOdd()) && (nt.iadd(ut), st.isub(gt)), nt.iushrn(1), st.iushrn(1);
          for (var jt = 0, Jt = 1; !(pe.words[0] & Jt) && jt < 26; ++jt, Jt <<= 1) ;
          if (jt > 0)
            for (pe.iushrn(jt); jt-- > 0; )
              (ft.isOdd() || ht.isOdd()) && (ft.iadd(ut), ht.isub(gt)), ft.iushrn(1), ht.iushrn(1);
          rt.cmp(pe) >= 0 ? (rt.isub(pe), nt.isub(ft), st.isub(ht)) : (pe.isub(rt), ft.isub(nt), ht.isub(st));
        }
        return {
          a: ft,
          b: ht,
          gcd: pe.iushln(bt)
        };
      }, W.prototype._invmp = function(Oe) {
        K(Oe.negative === 0), K(!Oe.isZero());
        var rt = this, pe = Oe.clone();
        rt.negative !== 0 ? rt = rt.umod(Oe) : rt = rt.clone();
        for (var nt = new W(1), st = new W(0), ft = pe.clone(); rt.cmpn(1) > 0 && pe.cmpn(1) > 0; ) {
          for (var ht = 0, bt = 1; !(rt.words[0] & bt) && ht < 26; ++ht, bt <<= 1) ;
          if (ht > 0)
            for (rt.iushrn(ht); ht-- > 0; )
              nt.isOdd() && nt.iadd(ft), nt.iushrn(1);
          for (var ut = 0, gt = 1; !(pe.words[0] & gt) && ut < 26; ++ut, gt <<= 1) ;
          if (ut > 0)
            for (pe.iushrn(ut); ut-- > 0; )
              st.isOdd() && st.iadd(ft), st.iushrn(1);
          rt.cmp(pe) >= 0 ? (rt.isub(pe), nt.isub(st)) : (pe.isub(rt), st.isub(nt));
        }
        var lt;
        return rt.cmpn(1) === 0 ? lt = nt : lt = st, lt.cmpn(0) < 0 && lt.iadd(Oe), lt;
      }, W.prototype.gcd = function(Oe) {
        if (this.isZero()) return Oe.abs();
        if (Oe.isZero()) return this.abs();
        var rt = this.clone(), pe = Oe.clone();
        rt.negative = 0, pe.negative = 0;
        for (var nt = 0; rt.isEven() && pe.isEven(); nt++)
          rt.iushrn(1), pe.iushrn(1);
        do {
          for (; rt.isEven(); )
            rt.iushrn(1);
          for (; pe.isEven(); )
            pe.iushrn(1);
          var st = rt.cmp(pe);
          if (st < 0) {
            var ft = rt;
            rt = pe, pe = ft;
          } else if (st === 0 || pe.cmpn(1) === 0)
            break;
          rt.isub(pe);
        } while (!0);
        return pe.iushln(nt);
      }, W.prototype.invm = function(Oe) {
        return this.egcd(Oe).a.umod(Oe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(Oe) {
        return this.words[0] & Oe;
      }, W.prototype.bincn = function(Oe) {
        K(typeof Oe == "number");
        var rt = Oe % 26, pe = (Oe - rt) / 26, nt = 1 << rt;
        if (this.length <= pe)
          return this._expand(pe + 1), this.words[pe] |= nt, this;
        for (var st = nt, ft = pe; st !== 0 && ft < this.length; ft++) {
          var ht = this.words[ft] | 0;
          ht += st, st = ht >>> 26, ht &= 67108863, this.words[ft] = ht;
        }
        return st !== 0 && (this.words[ft] = st, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(Oe) {
        var rt = Oe < 0;
        if (this.negative !== 0 && !rt) return -1;
        if (this.negative === 0 && rt) return 1;
        this.strip();
        var pe;
        if (this.length > 1)
          pe = 1;
        else {
          rt && (Oe = -Oe), K(Oe <= 67108863, "Number is too big");
          var nt = this.words[0] | 0;
          pe = nt === Oe ? 0 : nt < Oe ? -1 : 1;
        }
        return this.negative !== 0 ? -pe | 0 : pe;
      }, W.prototype.cmp = function(Oe) {
        if (this.negative !== 0 && Oe.negative === 0) return -1;
        if (this.negative === 0 && Oe.negative !== 0) return 1;
        var rt = this.ucmp(Oe);
        return this.negative !== 0 ? -rt | 0 : rt;
      }, W.prototype.ucmp = function(Oe) {
        if (this.length > Oe.length) return 1;
        if (this.length < Oe.length) return -1;
        for (var rt = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = this.words[pe] | 0, st = Oe.words[pe] | 0;
          if (nt !== st) {
            nt < st ? rt = -1 : nt > st && (rt = 1);
            break;
          }
        }
        return rt;
      }, W.prototype.gtn = function(Oe) {
        return this.cmpn(Oe) === 1;
      }, W.prototype.gt = function(Oe) {
        return this.cmp(Oe) === 1;
      }, W.prototype.gten = function(Oe) {
        return this.cmpn(Oe) >= 0;
      }, W.prototype.gte = function(Oe) {
        return this.cmp(Oe) >= 0;
      }, W.prototype.ltn = function(Oe) {
        return this.cmpn(Oe) === -1;
      }, W.prototype.lt = function(Oe) {
        return this.cmp(Oe) === -1;
      }, W.prototype.lten = function(Oe) {
        return this.cmpn(Oe) <= 0;
      }, W.prototype.lte = function(Oe) {
        return this.cmp(Oe) <= 0;
      }, W.prototype.eqn = function(Oe) {
        return this.cmpn(Oe) === 0;
      }, W.prototype.eq = function(Oe) {
        return this.cmp(Oe) === 0;
      }, W.red = function(Oe) {
        return new vt(Oe);
      }, W.prototype.toRed = function(Oe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), Oe.convertTo(this)._forceRed(Oe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(Oe) {
        return this.red = Oe, this;
      }, W.prototype.forceRed = function(Oe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(Oe);
      }, W.prototype.redAdd = function(Oe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, Oe);
      }, W.prototype.redIAdd = function(Oe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Oe);
      }, W.prototype.redSub = function(Oe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, Oe);
      }, W.prototype.redISub = function(Oe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, Oe);
      }, W.prototype.redShl = function(Oe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, Oe);
      }, W.prototype.redMul = function(Oe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Oe), this.red.mul(this, Oe);
      }, W.prototype.redIMul = function(Oe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, Oe), this.red.imul(this, Oe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(Oe) {
        return K(this.red && !Oe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Oe);
      };
      var yt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function mt(wt, Oe) {
        this.name = wt, this.p = new W(Oe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      mt.prototype._tmp = function() {
        var Oe = new W(null);
        return Oe.words = new Array(Math.ceil(this.n / 13)), Oe;
      }, mt.prototype.ireduce = function(Oe) {
        var rt = Oe, pe;
        do
          this.split(rt, this.tmp), rt = this.imulK(rt), rt = rt.iadd(this.tmp), pe = rt.bitLength();
        while (pe > this.n);
        var nt = pe < this.n ? -1 : rt.ucmp(this.p);
        return nt === 0 ? (rt.words[0] = 0, rt.length = 1) : nt > 0 ? rt.isub(this.p) : rt.strip !== void 0 ? rt.strip() : rt._strip(), rt;
      }, mt.prototype.split = function(Oe, rt) {
        Oe.iushrn(this.n, 0, rt);
      }, mt.prototype.imulK = function(Oe) {
        return Oe.imul(this.k);
      };
      function Tt() {
        mt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      V(Tt, mt), Tt.prototype.split = function(Oe, rt) {
        for (var pe = 4194303, nt = Math.min(Oe.length, 9), st = 0; st < nt; st++)
          rt.words[st] = Oe.words[st];
        if (rt.length = nt, Oe.length <= 9) {
          Oe.words[0] = 0, Oe.length = 1;
          return;
        }
        var ft = Oe.words[9];
        for (rt.words[rt.length++] = ft & pe, st = 10; st < Oe.length; st++) {
          var ht = Oe.words[st] | 0;
          Oe.words[st - 10] = (ht & pe) << 4 | ft >>> 22, ft = ht;
        }
        ft >>>= 22, Oe.words[st - 10] = ft, ft === 0 && Oe.length > 10 ? Oe.length -= 10 : Oe.length -= 9;
      }, Tt.prototype.imulK = function(Oe) {
        Oe.words[Oe.length] = 0, Oe.words[Oe.length + 1] = 0, Oe.length += 2;
        for (var rt = 0, pe = 0; pe < Oe.length; pe++) {
          var nt = Oe.words[pe] | 0;
          rt += nt * 977, Oe.words[pe] = rt & 67108863, rt = nt * 64 + (rt / 67108864 | 0);
        }
        return Oe.words[Oe.length - 1] === 0 && (Oe.length--, Oe.words[Oe.length - 1] === 0 && Oe.length--), Oe;
      };
      function Pt() {
        mt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      V(Pt, mt);
      function Nt() {
        mt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      V(Nt, mt);
      function St() {
        mt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      V(St, mt), St.prototype.imulK = function(Oe) {
        for (var rt = 0, pe = 0; pe < Oe.length; pe++) {
          var nt = (Oe.words[pe] | 0) * 19 + rt, st = nt & 67108863;
          nt >>>= 26, Oe.words[pe] = st, rt = nt;
        }
        return rt !== 0 && (Oe.words[Oe.length++] = rt), Oe;
      }, W._prime = function(Oe) {
        if (yt[Oe]) return yt[Oe];
        var rt;
        if (Oe === "k256")
          rt = new Tt();
        else if (Oe === "p224")
          rt = new Pt();
        else if (Oe === "p192")
          rt = new Nt();
        else if (Oe === "p25519")
          rt = new St();
        else
          throw new Error("Unknown prime " + Oe);
        return yt[Oe] = rt, rt;
      };
      function vt(wt) {
        if (typeof wt == "string") {
          var Oe = W._prime(wt);
          this.m = Oe.p, this.prime = Oe;
        } else
          K(wt.gtn(1), "modulus must be greater than 1"), this.m = wt, this.prime = null;
      }
      vt.prototype._verify1 = function(Oe) {
        K(Oe.negative === 0, "red works only with positives"), K(Oe.red, "red works only with red numbers");
      }, vt.prototype._verify2 = function(Oe, rt) {
        K((Oe.negative | rt.negative) === 0, "red works only with positives"), K(
          Oe.red && Oe.red === rt.red,
          "red works only with red numbers"
        );
      }, vt.prototype.imod = function(Oe) {
        return this.prime ? this.prime.ireduce(Oe)._forceRed(this) : Oe.umod(this.m)._forceRed(this);
      }, vt.prototype.neg = function(Oe) {
        return Oe.isZero() ? Oe.clone() : this.m.sub(Oe)._forceRed(this);
      }, vt.prototype.add = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.add(rt);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe._forceRed(this);
      }, vt.prototype.iadd = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.iadd(rt);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe;
      }, vt.prototype.sub = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.sub(rt);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe._forceRed(this);
      }, vt.prototype.isub = function(Oe, rt) {
        this._verify2(Oe, rt);
        var pe = Oe.isub(rt);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe;
      }, vt.prototype.shl = function(Oe, rt) {
        return this._verify1(Oe), this.imod(Oe.ushln(rt));
      }, vt.prototype.imul = function(Oe, rt) {
        return this._verify2(Oe, rt), this.imod(Oe.imul(rt));
      }, vt.prototype.mul = function(Oe, rt) {
        return this._verify2(Oe, rt), this.imod(Oe.mul(rt));
      }, vt.prototype.isqr = function(Oe) {
        return this.imul(Oe, Oe.clone());
      }, vt.prototype.sqr = function(Oe) {
        return this.mul(Oe, Oe);
      }, vt.prototype.sqrt = function(Oe) {
        if (Oe.isZero()) return Oe.clone();
        var rt = this.m.andln(3);
        if (K(rt % 2 === 1), rt === 3) {
          var pe = this.m.add(new W(1)).iushrn(2);
          return this.pow(Oe, pe);
        }
        for (var nt = this.m.subn(1), st = 0; !nt.isZero() && nt.andln(1) === 0; )
          st++, nt.iushrn(1);
        K(!nt.isZero());
        var ft = new W(1).toRed(this), ht = ft.redNeg(), bt = this.m.subn(1).iushrn(1), ut = this.m.bitLength();
        for (ut = new W(2 * ut * ut).toRed(this); this.pow(ut, bt).cmp(ht) !== 0; )
          ut.redIAdd(ht);
        for (var gt = this.pow(ut, nt), lt = this.pow(Oe, nt.addn(1).iushrn(1)), $t = this.pow(Oe, nt), jt = st; $t.cmp(ft) !== 0; ) {
          for (var Jt = $t, Lt = 0; Jt.cmp(ft) !== 0; Lt++)
            Jt = Jt.redSqr();
          K(Lt < jt);
          var Rt = this.pow(gt, new W(1).iushln(jt - Lt - 1));
          lt = lt.redMul(Rt), gt = Rt.redSqr(), $t = $t.redMul(gt), jt = Lt;
        }
        return lt;
      }, vt.prototype.invm = function(Oe) {
        var rt = Oe._invmp(this.m);
        return rt.negative !== 0 ? (rt.negative = 0, this.imod(rt).redNeg()) : this.imod(rt);
      }, vt.prototype.pow = function(Oe, rt) {
        if (rt.isZero()) return new W(1).toRed(this);
        if (rt.cmpn(1) === 0) return Oe.clone();
        var pe = 4, nt = new Array(1 << pe);
        nt[0] = new W(1).toRed(this), nt[1] = Oe;
        for (var st = 2; st < nt.length; st++)
          nt[st] = this.mul(nt[st - 1], Oe);
        var ft = nt[0], ht = 0, bt = 0, ut = rt.bitLength() % 26;
        for (ut === 0 && (ut = 26), st = rt.length - 1; st >= 0; st--) {
          for (var gt = rt.words[st], lt = ut - 1; lt >= 0; lt--) {
            var $t = gt >> lt & 1;
            if (ft !== nt[0] && (ft = this.sqr(ft)), $t === 0 && ht === 0) {
              bt = 0;
              continue;
            }
            ht <<= 1, ht |= $t, bt++, !(bt !== pe && (st !== 0 || lt !== 0)) && (ft = this.mul(ft, nt[ht]), bt = 0, ht = 0);
          }
          ut = 26;
        }
        return ft;
      }, vt.prototype.convertTo = function(Oe) {
        var rt = Oe.umod(this.m);
        return rt === Oe ? rt.clone() : rt;
      }, vt.prototype.convertFrom = function(Oe) {
        var rt = Oe.clone();
        return rt.red = null, rt;
      }, W.mont = function(Oe) {
        return new It(Oe);
      };
      function It(wt) {
        vt.call(this, wt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      V(It, vt), It.prototype.convertTo = function(Oe) {
        return this.imod(Oe.ushln(this.shift));
      }, It.prototype.convertFrom = function(Oe) {
        var rt = this.imod(Oe.mul(this.rinv));
        return rt.red = null, rt;
      }, It.prototype.imul = function(Oe, rt) {
        if (Oe.isZero() || rt.isZero())
          return Oe.words[0] = 0, Oe.length = 1, Oe;
        var pe = Oe.imul(rt), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), st = pe.isub(nt).iushrn(this.shift), ft = st;
        return st.cmp(this.m) >= 0 ? ft = st.isub(this.m) : st.cmpn(0) < 0 && (ft = st.iadd(this.m)), ft._forceRed(this);
      }, It.prototype.mul = function(Oe, rt) {
        if (Oe.isZero() || rt.isZero()) return new W(0)._forceRed(this);
        var pe = Oe.mul(rt), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), st = pe.isub(nt).iushrn(this.shift), ft = st;
        return st.cmp(this.m) >= 0 ? ft = st.isub(this.m) : st.cmpn(0) < 0 && (ft = st.iadd(this.m)), ft._forceRed(this);
      }, It.prototype.invm = function(Oe) {
        var rt = this.imod(Oe._invmp(this.m).mul(this.r2));
        return rt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var A;
  brorand.exports = function(V) {
    return A || (A = new B(null)), A.generate(V);
  };
  function B(K) {
    this.rand = K;
  }
  if (brorand.exports.Rand = B, B.prototype.generate = function(V) {
    return this._rand(V);
  }, B.prototype._rand = function(V) {
    if (this.rand.getBytes)
      return this.rand.getBytes(V);
    for (var W = new Uint8Array(V), J = 0; J < W.length; J++)
      W[J] = this.rand.getByte();
    return W;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? B.prototype._rand = function(V) {
      var W = new Uint8Array(V);
      return self.crypto.getRandomValues(W), W;
    } : self.msCrypto && self.msCrypto.getRandomValues ? B.prototype._rand = function(V) {
      var W = new Uint8Array(V);
      return self.msCrypto.getRandomValues(W), W;
    } : typeof window == "object" && (B.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var L = requireCryptoBrowserify();
      if (typeof L.randomBytes != "function")
        throw new Error("Not supported");
      B.prototype._rand = function(V) {
        return L.randomBytes(V);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var A = requireBn$1(), B = requireBrorand();
  function L(K) {
    this.rand = K || new B.Rand();
  }
  return mr = L, L.create = function(V) {
    return new L(V);
  }, L.prototype._randbelow = function(V) {
    var W = V.bitLength(), J = Math.ceil(W / 8);
    do
      var ne = new A(this.rand.generate(J));
    while (ne.cmp(V) >= 0);
    return ne;
  }, L.prototype._randrange = function(V, W) {
    var J = W.sub(V);
    return V.add(this._randbelow(J));
  }, L.prototype.test = function(V, W, J) {
    var ne = V.bitLength(), ie = A.mont(V), ce = new A(1).toRed(ie);
    W || (W = Math.max(1, ne / 48 | 0));
    for (var re = V.subn(1), oe = 0; !re.testn(oe); oe++)
      ;
    for (var ke = V.shrn(oe), Ce = re.toRed(ie), it = !0; W > 0; W--) {
      var at = this._randrange(new A(2), re);
      J && J(at);
      var ct = at.toRed(ie).redPow(ke);
      if (!(ct.cmp(ce) === 0 || ct.cmp(Ce) === 0)) {
        for (var dt = 1; dt < oe; dt++) {
          if (ct = ct.redSqr(), ct.cmp(ce) === 0)
            return !1;
          if (ct.cmp(Ce) === 0)
            break;
        }
        if (dt === oe)
          return !1;
      }
    }
    return it;
  }, L.prototype.getDivisor = function(V, W) {
    var J = V.bitLength(), ne = A.mont(V), ie = new A(1).toRed(ne);
    W || (W = Math.max(1, J / 48 | 0));
    for (var ce = V.subn(1), re = 0; !ce.testn(re); re++)
      ;
    for (var oe = V.shrn(re), ke = ce.toRed(ne); W > 0; W--) {
      var Ce = this._randrange(new A(2), ce), it = V.gcd(Ce);
      if (it.cmpn(1) !== 0)
        return it;
      var at = Ce.toRed(ne).redPow(oe);
      if (!(at.cmp(ie) === 0 || at.cmp(ke) === 0)) {
        for (var ct = 1; ct < re; ct++) {
          if (at = at.redSqr(), at.cmp(ie) === 0)
            return at.fromRed().subn(1).gcd(V);
          if (at.cmp(ke) === 0)
            break;
        }
        if (ct === re)
          return at = at.redSqr(), at.fromRed().subn(1).gcd(V);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var A = requireBrowser$b();
  generatePrime = ct, ct.simpleSieve = it, ct.fermatTest = at;
  var B = requireBn$1(), L = new B(24), K = requireMr(), V = new K(), W = new B(1), J = new B(2), ne = new B(5);
  new B(16), new B(8);
  var ie = new B(10), ce = new B(3);
  new B(7);
  var re = new B(11), oe = new B(4);
  new B(12);
  var ke = null;
  function Ce() {
    if (ke !== null)
      return ke;
    var dt = 1048576, ot = [];
    ot[0] = 2;
    for (var yt = 1, mt = 3; mt < dt; mt += 2) {
      for (var Tt = Math.ceil(Math.sqrt(mt)), Pt = 0; Pt < yt && ot[Pt] <= Tt && mt % ot[Pt] !== 0; Pt++)
        ;
      yt !== Pt && ot[Pt] <= Tt || (ot[yt++] = mt);
    }
    return ke = ot, ot;
  }
  function it(dt) {
    for (var ot = Ce(), yt = 0; yt < ot.length; yt++)
      if (dt.modn(ot[yt]) === 0)
        return dt.cmpn(ot[yt]) === 0;
    return !0;
  }
  function at(dt) {
    var ot = B.mont(dt);
    return J.toRed(ot).redPow(dt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ct(dt, ot) {
    if (dt < 16)
      return ot === 2 || ot === 5 ? new B([140, 123]) : new B([140, 39]);
    ot = new B(ot);
    for (var yt, mt; ; ) {
      for (yt = new B(A(Math.ceil(dt / 8))); yt.bitLength() > dt; )
        yt.ishrn(1);
      if (yt.isEven() && yt.iadd(W), yt.testn(1) || yt.iadd(J), ot.cmp(J)) {
        if (!ot.cmp(ne))
          for (; yt.mod(ie).cmp(ce); )
            yt.iadd(oe);
      } else for (; yt.mod(L).cmp(re); )
        yt.iadd(oe);
      if (mt = yt.shrn(1), it(mt) && it(yt) && at(mt) && at(yt) && V.test(mt) && V.test(yt))
        return yt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var A = requireBn$1(), B = requireMr(), L = new B(), K = new A(24), V = new A(11), W = new A(10), J = new A(3), ne = new A(7), ie = requireGeneratePrime(), ce = requireBrowser$b();
  dh = it;
  function re(ct, dt) {
    return dt = dt || "utf8", Buffer$1.isBuffer(ct) || (ct = new Buffer$1(ct, dt)), this._pub = new A(ct), this;
  }
  function oe(ct, dt) {
    return dt = dt || "utf8", Buffer$1.isBuffer(ct) || (ct = new Buffer$1(ct, dt)), this._priv = new A(ct), this;
  }
  var ke = {};
  function Ce(ct, dt) {
    var ot = dt.toString("hex"), yt = [ot, ct.toString(16)].join("_");
    if (yt in ke)
      return ke[yt];
    var mt = 0;
    if (ct.isEven() || !ie.simpleSieve || !ie.fermatTest(ct) || !L.test(ct))
      return mt += 1, ot === "02" || ot === "05" ? mt += 8 : mt += 4, ke[yt] = mt, mt;
    L.test(ct.shrn(1)) || (mt += 2);
    var Tt;
    switch (ot) {
      case "02":
        ct.mod(K).cmp(V) && (mt += 8);
        break;
      case "05":
        Tt = ct.mod(W), Tt.cmp(J) && Tt.cmp(ne) && (mt += 8);
        break;
      default:
        mt += 4;
    }
    return ke[yt] = mt, mt;
  }
  function it(ct, dt, ot) {
    this.setGenerator(dt), this.__prime = new A(ct), this._prime = A.mont(this.__prime), this._primeLen = ct.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ot ? (this.setPublicKey = re, this.setPrivateKey = oe) : this._primeCode = 8;
  }
  Object.defineProperty(it.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ce(this.__prime, this.__gen)), this._primeCode;
    }
  }), it.prototype.generateKeys = function() {
    return this._priv || (this._priv = new A(ce(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, it.prototype.computeSecret = function(ct) {
    ct = new A(ct), ct = ct.toRed(this._prime);
    var dt = ct.redPow(this._priv).fromRed(), ot = new Buffer$1(dt.toArray()), yt = this.getPrime();
    if (ot.length < yt.length) {
      var mt = new Buffer$1(yt.length - ot.length);
      mt.fill(0), ot = Buffer$1.concat([mt, ot]);
    }
    return ot;
  }, it.prototype.getPublicKey = function(dt) {
    return at(this._pub, dt);
  }, it.prototype.getPrivateKey = function(dt) {
    return at(this._priv, dt);
  }, it.prototype.getPrime = function(ct) {
    return at(this.__prime, ct);
  }, it.prototype.getGenerator = function(ct) {
    return at(this._gen, ct);
  }, it.prototype.setGenerator = function(ct, dt) {
    return dt = dt || "utf8", Buffer$1.isBuffer(ct) || (ct = new Buffer$1(ct, dt)), this.__gen = ct, this._gen = new A(ct), this;
  };
  function at(ct, dt) {
    var ot = new Buffer$1(ct.toArray());
    return dt ? ot.toString(dt) : ot;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var A = requireGeneratePrime(), B = require$$1$1, L = requireDh();
  function K(J) {
    var ne = new Buffer$1(B[J].prime, "hex"), ie = new Buffer$1(B[J].gen, "hex");
    return new L(ne, ie);
  }
  var V = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function W(J, ne, ie, ce) {
    return Buffer$1.isBuffer(ne) || V[ne] === void 0 ? W(J, "binary", ne, ie) : (ne = ne || "binary", ce = ce || "binary", ie = ie || new Buffer$1([2]), Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, ce)), typeof J == "number" ? new L(A(J, ie), ie, !0) : (Buffer$1.isBuffer(J) || (J = new Buffer$1(J, ne)), new L(J, ie, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = K, browser$4.createDiffieHellman = browser$4.DiffieHellman = W, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: A } : processNextickArgs.exports = process$1;
  function A(B, L, K, V) {
    if (typeof B != "function")
      throw new TypeError('"callback" argument must be a function');
    var W = arguments.length, J, ne;
    switch (W) {
      case 0:
      case 1:
        return process$1.nextTick(B);
      case 2:
        return process$1.nextTick(function() {
          B.call(null, L);
        });
      case 3:
        return process$1.nextTick(function() {
          B.call(null, L, K);
        });
      case 4:
        return process$1.nextTick(function() {
          B.call(null, L, K, V);
        });
      default:
        for (J = new Array(W - 1), ne = 0; ne < J.length; )
          J[ne++] = arguments[ne];
        return process$1.nextTick(function() {
          B.apply(null, J);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var A = {}.toString;
  return isarray = Array.isArray || function(B) {
    return A.call(B) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(A, B) {
    var L = dist$1, K = L.Buffer;
    function V(J, ne) {
      for (var ie in J)
        ne[ie] = J[ie];
    }
    K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (V(L, B), B.Buffer = W);
    function W(J, ne, ie) {
      return K(J, ne, ie);
    }
    V(K, W), W.from = function(J, ne, ie) {
      if (typeof J == "number")
        throw new TypeError("Argument must not be a number");
      return K(J, ne, ie);
    }, W.alloc = function(J, ne, ie) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      var ce = K(J);
      return ne !== void 0 ? typeof ie == "string" ? ce.fill(ne, ie) : ce.fill(ne) : ce.fill(0), ce;
    }, W.allocUnsafe = function(J) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      return K(J);
    }, W.allocUnsafeSlow = function(J) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      return L.SlowBuffer(J);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function A(at) {
    return Array.isArray ? Array.isArray(at) : it(at) === "[object Array]";
  }
  util.isArray = A;
  function B(at) {
    return typeof at == "boolean";
  }
  util.isBoolean = B;
  function L(at) {
    return at === null;
  }
  util.isNull = L;
  function K(at) {
    return at == null;
  }
  util.isNullOrUndefined = K;
  function V(at) {
    return typeof at == "number";
  }
  util.isNumber = V;
  function W(at) {
    return typeof at == "string";
  }
  util.isString = W;
  function J(at) {
    return typeof at == "symbol";
  }
  util.isSymbol = J;
  function ne(at) {
    return at === void 0;
  }
  util.isUndefined = ne;
  function ie(at) {
    return it(at) === "[object RegExp]";
  }
  util.isRegExp = ie;
  function ce(at) {
    return typeof at == "object" && at !== null;
  }
  util.isObject = ce;
  function re(at) {
    return it(at) === "[object Date]";
  }
  util.isDate = re;
  function oe(at) {
    return it(at) === "[object Error]" || at instanceof Error;
  }
  util.isError = oe;
  function ke(at) {
    return typeof at == "function";
  }
  util.isFunction = ke;
  function Ce(at) {
    return at === null || typeof at == "boolean" || typeof at == "number" || typeof at == "string" || typeof at == "symbol" || // ES6 symbol
    typeof at > "u";
  }
  util.isPrimitive = Ce, util.isBuffer = dist$1.Buffer.isBuffer;
  function it(at) {
    return Object.prototype.toString.call(at);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(A) {
    function B(W, J) {
      if (!(W instanceof J))
        throw new TypeError("Cannot call a class as a function");
    }
    var L = requireSafeBuffer().Buffer, K = requireUtil$1();
    function V(W, J, ne) {
      W.copy(J, ne);
    }
    A.exports = function() {
      function W() {
        B(this, W), this.head = null, this.tail = null, this.length = 0;
      }
      return W.prototype.push = function(ne) {
        var ie = { data: ne, next: null };
        this.length > 0 ? this.tail.next = ie : this.head = ie, this.tail = ie, ++this.length;
      }, W.prototype.unshift = function(ne) {
        var ie = { data: ne, next: this.head };
        this.length === 0 && (this.tail = ie), this.head = ie, ++this.length;
      }, W.prototype.shift = function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }, W.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, W.prototype.join = function(ne) {
        if (this.length === 0) return "";
        for (var ie = this.head, ce = "" + ie.data; ie = ie.next; )
          ce += ne + ie.data;
        return ce;
      }, W.prototype.concat = function(ne) {
        if (this.length === 0) return L.alloc(0);
        for (var ie = L.allocUnsafe(ne >>> 0), ce = this.head, re = 0; ce; )
          V(ce.data, ie, re), re += ce.data.length, ce = ce.next;
        return ie;
      }, W;
    }(), K && K.inspect && K.inspect.custom && (A.exports.prototype[K.inspect.custom] = function() {
      var W = K.inspect({ length: this.length });
      return this.constructor.name + " " + W;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var A = requireProcessNextickArgs();
  function B(V, W) {
    var J = this, ne = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
    return ne || ie ? (W ? W(V) : V && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, A.nextTick(K, this, V)) : A.nextTick(K, this, V)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(V || null, function(ce) {
      !W && ce ? J._writableState ? J._writableState.errorEmitted || (J._writableState.errorEmitted = !0, A.nextTick(K, J, ce)) : A.nextTick(K, J, ce) : W && W(ce);
    }), this);
  }
  function L() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function K(V, W) {
    V.emit("error", W);
  }
  return destroy_1 = {
    destroy: B,
    undestroy: L
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var A = requireProcessNextickArgs();
  _stream_writable = at;
  function B(ft) {
    var ht = this;
    this.next = null, this.entry = null, this.finish = function() {
      st(ht, ft);
    };
  }
  var L = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : A.nextTick, K;
  at.WritableState = Ce;
  var V = Object.create(requireUtil());
  V.inherits = requireInherits_browser();
  var W = {
    deprecate: requireBrowser$a()
  }, J = requireStreamBrowser(), ne = requireSafeBuffer().Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ce(ft) {
    return ne.from(ft);
  }
  function re(ft) {
    return ne.isBuffer(ft) || ft instanceof ie;
  }
  var oe = requireDestroy();
  V.inherits(at, J);
  function ke() {
  }
  function Ce(ft, ht) {
    K = K || require_stream_duplex(), ft = ft || {};
    var bt = ht instanceof K;
    this.objectMode = !!ft.objectMode, bt && (this.objectMode = this.objectMode || !!ft.writableObjectMode);
    var ut = ft.highWaterMark, gt = ft.writableHighWaterMark, lt = this.objectMode ? 16 : 16 * 1024;
    ut || ut === 0 ? this.highWaterMark = ut : bt && (gt || gt === 0) ? this.highWaterMark = gt : this.highWaterMark = lt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var $t = ft.decodeStrings === !1;
    this.decodeStrings = !$t, this.defaultEncoding = ft.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(jt) {
      Nt(ht, jt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Ce.prototype.getBuffer = function() {
    for (var ht = this.bufferedRequest, bt = []; ht; )
      bt.push(ht), ht = ht.next;
    return bt;
  }, function() {
    try {
      Object.defineProperty(Ce.prototype, "buffer", {
        get: W.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var it;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (it = Function.prototype[Symbol.hasInstance], Object.defineProperty(at, Symbol.hasInstance, {
    value: function(ft) {
      return it.call(this, ft) ? !0 : this !== at ? !1 : ft && ft._writableState instanceof Ce;
    }
  })) : it = function(ft) {
    return ft instanceof this;
  };
  function at(ft) {
    if (K = K || require_stream_duplex(), !it.call(at, this) && !(this instanceof K))
      return new at(ft);
    this._writableState = new Ce(ft, this), this.writable = !0, ft && (typeof ft.write == "function" && (this._write = ft.write), typeof ft.writev == "function" && (this._writev = ft.writev), typeof ft.destroy == "function" && (this._destroy = ft.destroy), typeof ft.final == "function" && (this._final = ft.final)), J.call(this);
  }
  at.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function ct(ft, ht) {
    var bt = new Error("write after end");
    ft.emit("error", bt), A.nextTick(ht, bt);
  }
  function dt(ft, ht, bt, ut) {
    var gt = !0, lt = !1;
    return bt === null ? lt = new TypeError("May not write null values to stream") : typeof bt != "string" && bt !== void 0 && !ht.objectMode && (lt = new TypeError("Invalid non-string/buffer chunk")), lt && (ft.emit("error", lt), A.nextTick(ut, lt), gt = !1), gt;
  }
  at.prototype.write = function(ft, ht, bt) {
    var ut = this._writableState, gt = !1, lt = !ut.objectMode && re(ft);
    return lt && !ne.isBuffer(ft) && (ft = ce(ft)), typeof ht == "function" && (bt = ht, ht = null), lt ? ht = "buffer" : ht || (ht = ut.defaultEncoding), typeof bt != "function" && (bt = ke), ut.ended ? ct(this, bt) : (lt || dt(this, ut, ft, bt)) && (ut.pendingcb++, gt = yt(this, ut, lt, ft, ht, bt)), gt;
  }, at.prototype.cork = function() {
    var ft = this._writableState;
    ft.corked++;
  }, at.prototype.uncork = function() {
    var ft = this._writableState;
    ft.corked && (ft.corked--, !ft.writing && !ft.corked && !ft.bufferProcessing && ft.bufferedRequest && It(this, ft));
  }, at.prototype.setDefaultEncoding = function(ht) {
    if (typeof ht == "string" && (ht = ht.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ht + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ht);
    return this._writableState.defaultEncoding = ht, this;
  };
  function ot(ft, ht, bt) {
    return !ft.objectMode && ft.decodeStrings !== !1 && typeof ht == "string" && (ht = ne.from(ht, bt)), ht;
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function yt(ft, ht, bt, ut, gt, lt) {
    if (!bt) {
      var $t = ot(ht, ut, gt);
      ut !== $t && (bt = !0, gt = "buffer", ut = $t);
    }
    var jt = ht.objectMode ? 1 : ut.length;
    ht.length += jt;
    var Jt = ht.length < ht.highWaterMark;
    if (Jt || (ht.needDrain = !0), ht.writing || ht.corked) {
      var Lt = ht.lastBufferedRequest;
      ht.lastBufferedRequest = {
        chunk: ut,
        encoding: gt,
        isBuf: bt,
        callback: lt,
        next: null
      }, Lt ? Lt.next = ht.lastBufferedRequest : ht.bufferedRequest = ht.lastBufferedRequest, ht.bufferedRequestCount += 1;
    } else
      mt(ft, ht, !1, jt, ut, gt, lt);
    return Jt;
  }
  function mt(ft, ht, bt, ut, gt, lt, $t) {
    ht.writelen = ut, ht.writecb = $t, ht.writing = !0, ht.sync = !0, bt ? ft._writev(gt, ht.onwrite) : ft._write(gt, lt, ht.onwrite), ht.sync = !1;
  }
  function Tt(ft, ht, bt, ut, gt) {
    --ht.pendingcb, bt ? (A.nextTick(gt, ut), A.nextTick(pe, ft, ht), ft._writableState.errorEmitted = !0, ft.emit("error", ut)) : (gt(ut), ft._writableState.errorEmitted = !0, ft.emit("error", ut), pe(ft, ht));
  }
  function Pt(ft) {
    ft.writing = !1, ft.writecb = null, ft.length -= ft.writelen, ft.writelen = 0;
  }
  function Nt(ft, ht) {
    var bt = ft._writableState, ut = bt.sync, gt = bt.writecb;
    if (Pt(bt), ht) Tt(ft, bt, ut, ht, gt);
    else {
      var lt = wt(bt);
      !lt && !bt.corked && !bt.bufferProcessing && bt.bufferedRequest && It(ft, bt), ut ? L(St, ft, bt, lt, gt) : St(ft, bt, lt, gt);
    }
  }
  function St(ft, ht, bt, ut) {
    bt || vt(ft, ht), ht.pendingcb--, ut(), pe(ft, ht);
  }
  function vt(ft, ht) {
    ht.length === 0 && ht.needDrain && (ht.needDrain = !1, ft.emit("drain"));
  }
  function It(ft, ht) {
    ht.bufferProcessing = !0;
    var bt = ht.bufferedRequest;
    if (ft._writev && bt && bt.next) {
      var ut = ht.bufferedRequestCount, gt = new Array(ut), lt = ht.corkedRequestsFree;
      lt.entry = bt;
      for (var $t = 0, jt = !0; bt; )
        gt[$t] = bt, bt.isBuf || (jt = !1), bt = bt.next, $t += 1;
      gt.allBuffers = jt, mt(ft, ht, !0, ht.length, gt, "", lt.finish), ht.pendingcb++, ht.lastBufferedRequest = null, lt.next ? (ht.corkedRequestsFree = lt.next, lt.next = null) : ht.corkedRequestsFree = new B(ht), ht.bufferedRequestCount = 0;
    } else {
      for (; bt; ) {
        var Jt = bt.chunk, Lt = bt.encoding, Rt = bt.callback, Mt = ht.objectMode ? 1 : Jt.length;
        if (mt(ft, ht, !1, Mt, Jt, Lt, Rt), bt = bt.next, ht.bufferedRequestCount--, ht.writing)
          break;
      }
      bt === null && (ht.lastBufferedRequest = null);
    }
    ht.bufferedRequest = bt, ht.bufferProcessing = !1;
  }
  at.prototype._write = function(ft, ht, bt) {
    bt(new Error("_write() is not implemented"));
  }, at.prototype._writev = null, at.prototype.end = function(ft, ht, bt) {
    var ut = this._writableState;
    typeof ft == "function" ? (bt = ft, ft = null, ht = null) : typeof ht == "function" && (bt = ht, ht = null), ft != null && this.write(ft, ht), ut.corked && (ut.corked = 1, this.uncork()), ut.ending || nt(this, ut, bt);
  };
  function wt(ft) {
    return ft.ending && ft.length === 0 && ft.bufferedRequest === null && !ft.finished && !ft.writing;
  }
  function Oe(ft, ht) {
    ft._final(function(bt) {
      ht.pendingcb--, bt && ft.emit("error", bt), ht.prefinished = !0, ft.emit("prefinish"), pe(ft, ht);
    });
  }
  function rt(ft, ht) {
    !ht.prefinished && !ht.finalCalled && (typeof ft._final == "function" ? (ht.pendingcb++, ht.finalCalled = !0, A.nextTick(Oe, ft, ht)) : (ht.prefinished = !0, ft.emit("prefinish")));
  }
  function pe(ft, ht) {
    var bt = wt(ht);
    return bt && (rt(ft, ht), ht.pendingcb === 0 && (ht.finished = !0, ft.emit("finish"))), bt;
  }
  function nt(ft, ht, bt) {
    ht.ending = !0, pe(ft, ht), bt && (ht.finished ? A.nextTick(bt) : ft.once("finish", bt)), ht.ended = !0, ft.writable = !1;
  }
  function st(ft, ht, bt) {
    var ut = ft.entry;
    for (ft.entry = null; ut; ) {
      var gt = ut.callback;
      ht.pendingcb--, gt(bt), ut = ut.next;
    }
    ht.corkedRequestsFree.next = ft;
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ft) {
      this._writableState && (this._writableState.destroyed = ft);
    }
  }), at.prototype.destroy = oe.destroy, at.prototype._undestroy = oe.undestroy, at.prototype._destroy = function(ft, ht) {
    this.end(), ht(ft);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var A = requireProcessNextickArgs(), B = Object.keys || function(oe) {
    var ke = [];
    for (var Ce in oe)
      ke.push(Ce);
    return ke;
  };
  _stream_duplex = ie;
  var L = Object.create(requireUtil());
  L.inherits = requireInherits_browser();
  var K = require_stream_readable(), V = require_stream_writable();
  L.inherits(ie, K);
  for (var W = B(V.prototype), J = 0; J < W.length; J++) {
    var ne = W[J];
    ie.prototype[ne] || (ie.prototype[ne] = V.prototype[ne]);
  }
  function ie(oe) {
    if (!(this instanceof ie)) return new ie(oe);
    K.call(this, oe), V.call(this, oe), oe && oe.readable === !1 && (this.readable = !1), oe && oe.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, oe && oe.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ce);
  }
  Object.defineProperty(ie.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ce() {
    this.allowHalfOpen || this._writableState.ended || A.nextTick(re, this);
  }
  function re(oe) {
    oe.end();
  }
  return Object.defineProperty(ie.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(oe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = oe, this._writableState.destroyed = oe);
    }
  }), ie.prototype._destroy = function(oe, ke) {
    this.push(null), this.end(), A.nextTick(ke, oe);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var A = requireProcessNextickArgs();
  _stream_readable = ot;
  var B = requireIsarray(), L;
  ot.ReadableState = dt, requireEvents().EventEmitter;
  var K = function(Rt, Mt) {
    return Rt.listeners(Mt).length;
  }, V = requireStreamBrowser(), W = requireSafeBuffer().Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ne(Rt) {
    return W.from(Rt);
  }
  function ie(Rt) {
    return W.isBuffer(Rt) || Rt instanceof J;
  }
  var ce = Object.create(requireUtil());
  ce.inherits = requireInherits_browser();
  var re = requireUtil$1(), oe = void 0;
  re && re.debuglog ? oe = re.debuglog("stream") : oe = function() {
  };
  var ke = requireBufferList(), Ce = requireDestroy(), it;
  ce.inherits(ot, V);
  var at = ["error", "close", "destroy", "pause", "resume"];
  function ct(Rt, Mt, Kt) {
    if (typeof Rt.prependListener == "function") return Rt.prependListener(Mt, Kt);
    !Rt._events || !Rt._events[Mt] ? Rt.on(Mt, Kt) : B(Rt._events[Mt]) ? Rt._events[Mt].unshift(Kt) : Rt._events[Mt] = [Kt, Rt._events[Mt]];
  }
  function dt(Rt, Mt) {
    L = L || require_stream_duplex(), Rt = Rt || {};
    var Kt = Mt instanceof L;
    this.objectMode = !!Rt.objectMode, Kt && (this.objectMode = this.objectMode || !!Rt.readableObjectMode);
    var zt = Rt.highWaterMark, Ct = Rt.readableHighWaterMark, kt = this.objectMode ? 16 : 16 * 1024;
    zt || zt === 0 ? this.highWaterMark = zt : Kt && (Ct || Ct === 0) ? this.highWaterMark = Ct : this.highWaterMark = kt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new ke(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Rt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Rt.encoding && (it || (it = requireString_decoder().StringDecoder), this.decoder = new it(Rt.encoding), this.encoding = Rt.encoding);
  }
  function ot(Rt) {
    if (L = L || require_stream_duplex(), !(this instanceof ot)) return new ot(Rt);
    this._readableState = new dt(Rt, this), this.readable = !0, Rt && (typeof Rt.read == "function" && (this._read = Rt.read), typeof Rt.destroy == "function" && (this._destroy = Rt.destroy)), V.call(this);
  }
  Object.defineProperty(ot.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Rt) {
      this._readableState && (this._readableState.destroyed = Rt);
    }
  }), ot.prototype.destroy = Ce.destroy, ot.prototype._undestroy = Ce.undestroy, ot.prototype._destroy = function(Rt, Mt) {
    this.push(null), Mt(Rt);
  }, ot.prototype.push = function(Rt, Mt) {
    var Kt = this._readableState, zt;
    return Kt.objectMode ? zt = !0 : typeof Rt == "string" && (Mt = Mt || Kt.defaultEncoding, Mt !== Kt.encoding && (Rt = W.from(Rt, Mt), Mt = ""), zt = !0), yt(this, Rt, Mt, !1, zt);
  }, ot.prototype.unshift = function(Rt) {
    return yt(this, Rt, null, !0, !1);
  };
  function yt(Rt, Mt, Kt, zt, Ct) {
    var kt = Rt._readableState;
    if (Mt === null)
      kt.reading = !1, It(Rt, kt);
    else {
      var Vt;
      Ct || (Vt = Tt(kt, Mt)), Vt ? Rt.emit("error", Vt) : kt.objectMode || Mt && Mt.length > 0 ? (typeof Mt != "string" && !kt.objectMode && Object.getPrototypeOf(Mt) !== W.prototype && (Mt = ne(Mt)), zt ? kt.endEmitted ? Rt.emit("error", new Error("stream.unshift() after end event")) : mt(Rt, kt, Mt, !0) : kt.ended ? Rt.emit("error", new Error("stream.push() after EOF")) : (kt.reading = !1, kt.decoder && !Kt ? (Mt = kt.decoder.write(Mt), kt.objectMode || Mt.length !== 0 ? mt(Rt, kt, Mt, !1) : rt(Rt, kt)) : mt(Rt, kt, Mt, !1))) : zt || (kt.reading = !1);
    }
    return Pt(kt);
  }
  function mt(Rt, Mt, Kt, zt) {
    Mt.flowing && Mt.length === 0 && !Mt.sync ? (Rt.emit("data", Kt), Rt.read(0)) : (Mt.length += Mt.objectMode ? 1 : Kt.length, zt ? Mt.buffer.unshift(Kt) : Mt.buffer.push(Kt), Mt.needReadable && wt(Rt)), rt(Rt, Mt);
  }
  function Tt(Rt, Mt) {
    var Kt;
    return !ie(Mt) && typeof Mt != "string" && Mt !== void 0 && !Rt.objectMode && (Kt = new TypeError("Invalid non-string/buffer chunk")), Kt;
  }
  function Pt(Rt) {
    return !Rt.ended && (Rt.needReadable || Rt.length < Rt.highWaterMark || Rt.length === 0);
  }
  ot.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ot.prototype.setEncoding = function(Rt) {
    return it || (it = requireString_decoder().StringDecoder), this._readableState.decoder = new it(Rt), this._readableState.encoding = Rt, this;
  };
  var Nt = 8388608;
  function St(Rt) {
    return Rt >= Nt ? Rt = Nt : (Rt--, Rt |= Rt >>> 1, Rt |= Rt >>> 2, Rt |= Rt >>> 4, Rt |= Rt >>> 8, Rt |= Rt >>> 16, Rt++), Rt;
  }
  function vt(Rt, Mt) {
    return Rt <= 0 || Mt.length === 0 && Mt.ended ? 0 : Mt.objectMode ? 1 : Rt !== Rt ? Mt.flowing && Mt.length ? Mt.buffer.head.data.length : Mt.length : (Rt > Mt.highWaterMark && (Mt.highWaterMark = St(Rt)), Rt <= Mt.length ? Rt : Mt.ended ? Mt.length : (Mt.needReadable = !0, 0));
  }
  ot.prototype.read = function(Rt) {
    oe("read", Rt), Rt = parseInt(Rt, 10);
    var Mt = this._readableState, Kt = Rt;
    if (Rt !== 0 && (Mt.emittedReadable = !1), Rt === 0 && Mt.needReadable && (Mt.length >= Mt.highWaterMark || Mt.ended))
      return oe("read: emitReadable", Mt.length, Mt.ended), Mt.length === 0 && Mt.ended ? jt(this) : wt(this), null;
    if (Rt = vt(Rt, Mt), Rt === 0 && Mt.ended)
      return Mt.length === 0 && jt(this), null;
    var zt = Mt.needReadable;
    oe("need readable", zt), (Mt.length === 0 || Mt.length - Rt < Mt.highWaterMark) && (zt = !0, oe("length less than watermark", zt)), Mt.ended || Mt.reading ? (zt = !1, oe("reading or ended", zt)) : zt && (oe("do read"), Mt.reading = !0, Mt.sync = !0, Mt.length === 0 && (Mt.needReadable = !0), this._read(Mt.highWaterMark), Mt.sync = !1, Mt.reading || (Rt = vt(Kt, Mt)));
    var Ct;
    return Rt > 0 ? Ct = ut(Rt, Mt) : Ct = null, Ct === null ? (Mt.needReadable = !0, Rt = 0) : Mt.length -= Rt, Mt.length === 0 && (Mt.ended || (Mt.needReadable = !0), Kt !== Rt && Mt.ended && jt(this)), Ct !== null && this.emit("data", Ct), Ct;
  };
  function It(Rt, Mt) {
    if (!Mt.ended) {
      if (Mt.decoder) {
        var Kt = Mt.decoder.end();
        Kt && Kt.length && (Mt.buffer.push(Kt), Mt.length += Mt.objectMode ? 1 : Kt.length);
      }
      Mt.ended = !0, wt(Rt);
    }
  }
  function wt(Rt) {
    var Mt = Rt._readableState;
    Mt.needReadable = !1, Mt.emittedReadable || (oe("emitReadable", Mt.flowing), Mt.emittedReadable = !0, Mt.sync ? A.nextTick(Oe, Rt) : Oe(Rt));
  }
  function Oe(Rt) {
    oe("emit readable"), Rt.emit("readable"), bt(Rt);
  }
  function rt(Rt, Mt) {
    Mt.readingMore || (Mt.readingMore = !0, A.nextTick(pe, Rt, Mt));
  }
  function pe(Rt, Mt) {
    for (var Kt = Mt.length; !Mt.reading && !Mt.flowing && !Mt.ended && Mt.length < Mt.highWaterMark && (oe("maybeReadMore read 0"), Rt.read(0), Kt !== Mt.length); )
      Kt = Mt.length;
    Mt.readingMore = !1;
  }
  ot.prototype._read = function(Rt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ot.prototype.pipe = function(Rt, Mt) {
    var Kt = this, zt = this._readableState;
    switch (zt.pipesCount) {
      case 0:
        zt.pipes = Rt;
        break;
      case 1:
        zt.pipes = [zt.pipes, Rt];
        break;
      default:
        zt.pipes.push(Rt);
        break;
    }
    zt.pipesCount += 1, oe("pipe count=%d opts=%j", zt.pipesCount, Mt);
    var Ct = (!Mt || Mt.end !== !1) && Rt !== process$1.stdout && Rt !== process$1.stderr, kt = Ct ? nr : br;
    zt.endEmitted ? A.nextTick(kt) : Kt.once("end", kt), Rt.on("unpipe", Vt);
    function Vt(hr, xr) {
      oe("onunpipe"), hr === Kt && xr && xr.hasUnpiped === !1 && (xr.hasUnpiped = !0, lr());
    }
    function nr() {
      oe("onend"), Rt.end();
    }
    var ar = nt(Kt);
    Rt.on("drain", ar);
    var sr = !1;
    function lr() {
      oe("cleanup"), Rt.removeListener("close", ur), Rt.removeListener("finish", pr), Rt.removeListener("drain", ar), Rt.removeListener("error", Pr), Rt.removeListener("unpipe", Vt), Kt.removeListener("end", nr), Kt.removeListener("end", br), Kt.removeListener("data", rr), sr = !0, zt.awaitDrain && (!Rt._writableState || Rt._writableState.needDrain) && ar();
    }
    var dr = !1;
    Kt.on("data", rr);
    function rr(hr) {
      oe("ondata"), dr = !1;
      var xr = Rt.write(hr);
      xr === !1 && !dr && ((zt.pipesCount === 1 && zt.pipes === Rt || zt.pipesCount > 1 && Lt(zt.pipes, Rt) !== -1) && !sr && (oe("false write response, pause", zt.awaitDrain), zt.awaitDrain++, dr = !0), Kt.pause());
    }
    function Pr(hr) {
      oe("onerror", hr), br(), Rt.removeListener("error", Pr), K(Rt, "error") === 0 && Rt.emit("error", hr);
    }
    ct(Rt, "error", Pr);
    function ur() {
      Rt.removeListener("finish", pr), br();
    }
    Rt.once("close", ur);
    function pr() {
      oe("onfinish"), Rt.removeListener("close", ur), br();
    }
    Rt.once("finish", pr);
    function br() {
      oe("unpipe"), Kt.unpipe(Rt);
    }
    return Rt.emit("pipe", Kt), zt.flowing || (oe("pipe resume"), Kt.resume()), Rt;
  };
  function nt(Rt) {
    return function() {
      var Mt = Rt._readableState;
      oe("pipeOnDrain", Mt.awaitDrain), Mt.awaitDrain && Mt.awaitDrain--, Mt.awaitDrain === 0 && K(Rt, "data") && (Mt.flowing = !0, bt(Rt));
    };
  }
  ot.prototype.unpipe = function(Rt) {
    var Mt = this._readableState, Kt = { hasUnpiped: !1 };
    if (Mt.pipesCount === 0) return this;
    if (Mt.pipesCount === 1)
      return Rt && Rt !== Mt.pipes ? this : (Rt || (Rt = Mt.pipes), Mt.pipes = null, Mt.pipesCount = 0, Mt.flowing = !1, Rt && Rt.emit("unpipe", this, Kt), this);
    if (!Rt) {
      var zt = Mt.pipes, Ct = Mt.pipesCount;
      Mt.pipes = null, Mt.pipesCount = 0, Mt.flowing = !1;
      for (var kt = 0; kt < Ct; kt++)
        zt[kt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Vt = Lt(Mt.pipes, Rt);
    return Vt === -1 ? this : (Mt.pipes.splice(Vt, 1), Mt.pipesCount -= 1, Mt.pipesCount === 1 && (Mt.pipes = Mt.pipes[0]), Rt.emit("unpipe", this, Kt), this);
  }, ot.prototype.on = function(Rt, Mt) {
    var Kt = V.prototype.on.call(this, Rt, Mt);
    if (Rt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Rt === "readable") {
      var zt = this._readableState;
      !zt.endEmitted && !zt.readableListening && (zt.readableListening = zt.needReadable = !0, zt.emittedReadable = !1, zt.reading ? zt.length && wt(this) : A.nextTick(st, this));
    }
    return Kt;
  }, ot.prototype.addListener = ot.prototype.on;
  function st(Rt) {
    oe("readable nexttick read 0"), Rt.read(0);
  }
  ot.prototype.resume = function() {
    var Rt = this._readableState;
    return Rt.flowing || (oe("resume"), Rt.flowing = !0, ft(this, Rt)), this;
  };
  function ft(Rt, Mt) {
    Mt.resumeScheduled || (Mt.resumeScheduled = !0, A.nextTick(ht, Rt, Mt));
  }
  function ht(Rt, Mt) {
    Mt.reading || (oe("resume read 0"), Rt.read(0)), Mt.resumeScheduled = !1, Mt.awaitDrain = 0, Rt.emit("resume"), bt(Rt), Mt.flowing && !Mt.reading && Rt.read(0);
  }
  ot.prototype.pause = function() {
    return oe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (oe("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function bt(Rt) {
    var Mt = Rt._readableState;
    for (oe("flow", Mt.flowing); Mt.flowing && Rt.read() !== null; )
      ;
  }
  ot.prototype.wrap = function(Rt) {
    var Mt = this, Kt = this._readableState, zt = !1;
    Rt.on("end", function() {
      if (oe("wrapped end"), Kt.decoder && !Kt.ended) {
        var Vt = Kt.decoder.end();
        Vt && Vt.length && Mt.push(Vt);
      }
      Mt.push(null);
    }), Rt.on("data", function(Vt) {
      if (oe("wrapped data"), Kt.decoder && (Vt = Kt.decoder.write(Vt)), !(Kt.objectMode && Vt == null) && !(!Kt.objectMode && (!Vt || !Vt.length))) {
        var nr = Mt.push(Vt);
        nr || (zt = !0, Rt.pause());
      }
    });
    for (var Ct in Rt)
      this[Ct] === void 0 && typeof Rt[Ct] == "function" && (this[Ct] = /* @__PURE__ */ function(Vt) {
        return function() {
          return Rt[Vt].apply(Rt, arguments);
        };
      }(Ct));
    for (var kt = 0; kt < at.length; kt++)
      Rt.on(at[kt], this.emit.bind(this, at[kt]));
    return this._read = function(Vt) {
      oe("wrapped _read", Vt), zt && (zt = !1, Rt.resume());
    }, this;
  }, Object.defineProperty(ot.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ot._fromList = ut;
  function ut(Rt, Mt) {
    if (Mt.length === 0) return null;
    var Kt;
    return Mt.objectMode ? Kt = Mt.buffer.shift() : !Rt || Rt >= Mt.length ? (Mt.decoder ? Kt = Mt.buffer.join("") : Mt.buffer.length === 1 ? Kt = Mt.buffer.head.data : Kt = Mt.buffer.concat(Mt.length), Mt.buffer.clear()) : Kt = gt(Rt, Mt.buffer, Mt.decoder), Kt;
  }
  function gt(Rt, Mt, Kt) {
    var zt;
    return Rt < Mt.head.data.length ? (zt = Mt.head.data.slice(0, Rt), Mt.head.data = Mt.head.data.slice(Rt)) : Rt === Mt.head.data.length ? zt = Mt.shift() : zt = Kt ? lt(Rt, Mt) : $t(Rt, Mt), zt;
  }
  function lt(Rt, Mt) {
    var Kt = Mt.head, zt = 1, Ct = Kt.data;
    for (Rt -= Ct.length; Kt = Kt.next; ) {
      var kt = Kt.data, Vt = Rt > kt.length ? kt.length : Rt;
      if (Vt === kt.length ? Ct += kt : Ct += kt.slice(0, Rt), Rt -= Vt, Rt === 0) {
        Vt === kt.length ? (++zt, Kt.next ? Mt.head = Kt.next : Mt.head = Mt.tail = null) : (Mt.head = Kt, Kt.data = kt.slice(Vt));
        break;
      }
      ++zt;
    }
    return Mt.length -= zt, Ct;
  }
  function $t(Rt, Mt) {
    var Kt = W.allocUnsafe(Rt), zt = Mt.head, Ct = 1;
    for (zt.data.copy(Kt), Rt -= zt.data.length; zt = zt.next; ) {
      var kt = zt.data, Vt = Rt > kt.length ? kt.length : Rt;
      if (kt.copy(Kt, Kt.length - Rt, 0, Vt), Rt -= Vt, Rt === 0) {
        Vt === kt.length ? (++Ct, zt.next ? Mt.head = zt.next : Mt.head = Mt.tail = null) : (Mt.head = zt, zt.data = kt.slice(Vt));
        break;
      }
      ++Ct;
    }
    return Mt.length -= Ct, Kt;
  }
  function jt(Rt) {
    var Mt = Rt._readableState;
    if (Mt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Mt.endEmitted || (Mt.ended = !0, A.nextTick(Jt, Mt, Rt));
  }
  function Jt(Rt, Mt) {
    !Rt.endEmitted && Rt.length === 0 && (Rt.endEmitted = !0, Mt.readable = !1, Mt.emit("end"));
  }
  function Lt(Rt, Mt) {
    for (var Kt = 0, zt = Rt.length; Kt < zt; Kt++)
      if (Rt[Kt] === Mt) return Kt;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = K;
  var A = require_stream_duplex(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(K, A);
  function L(J, ne) {
    var ie = this._transformState;
    ie.transforming = !1;
    var ce = ie.writecb;
    if (!ce)
      return this.emit("error", new Error("write callback called multiple times"));
    ie.writechunk = null, ie.writecb = null, ne != null && this.push(ne), ce(J);
    var re = this._readableState;
    re.reading = !1, (re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark);
  }
  function K(J) {
    if (!(this instanceof K)) return new K(J);
    A.call(this, J), this._transformState = {
      afterTransform: L.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, J && (typeof J.transform == "function" && (this._transform = J.transform), typeof J.flush == "function" && (this._flush = J.flush)), this.on("prefinish", V);
  }
  function V() {
    var J = this;
    typeof this._flush == "function" ? this._flush(function(ne, ie) {
      W(J, ne, ie);
    }) : W(this, null, null);
  }
  K.prototype.push = function(J, ne) {
    return this._transformState.needTransform = !1, A.prototype.push.call(this, J, ne);
  }, K.prototype._transform = function(J, ne, ie) {
    throw new Error("_transform() is not implemented");
  }, K.prototype._write = function(J, ne, ie) {
    var ce = this._transformState;
    if (ce.writecb = ie, ce.writechunk = J, ce.writeencoding = ne, !ce.transforming) {
      var re = this._readableState;
      (ce.needTransform || re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark);
    }
  }, K.prototype._read = function(J) {
    var ne = this._transformState;
    ne.writechunk !== null && ne.writecb && !ne.transforming ? (ne.transforming = !0, this._transform(ne.writechunk, ne.writeencoding, ne.afterTransform)) : ne.needTransform = !0;
  }, K.prototype._destroy = function(J, ne) {
    var ie = this;
    A.prototype._destroy.call(this, J, function(ce) {
      ne(ce), ie.emit("close");
    });
  };
  function W(J, ne, ie) {
    if (ne) return J.emit("error", ne);
    if (ie != null && J.push(ie), J._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (J._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return J.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = L;
  var A = require_stream_transform(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(L, A);
  function L(K) {
    if (!(this instanceof L)) return new L(K);
    A.call(this, K);
  }
  return L.prototype._transform = function(K, V, W) {
    W(null, K);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(A, B) {
    B = A.exports = require_stream_readable(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable(), B.Duplex = require_stream_duplex(), B.Transform = require_stream_transform(), B.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(A) {
    (function(B, L) {
      function K(rt, pe) {
        if (!rt) throw new Error(pe || "Assertion failed");
      }
      function V(rt, pe) {
        rt.super_ = pe;
        var nt = function() {
        };
        nt.prototype = pe.prototype, rt.prototype = new nt(), rt.prototype.constructor = rt;
      }
      function W(rt, pe, nt) {
        if (W.isBN(rt))
          return rt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, rt !== null && ((pe === "le" || pe === "be") && (nt = pe, pe = 10), this._init(rt || 0, pe || 10, nt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var J;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? J = window.Buffer : J = dist$1.Buffer;
      } catch {
      }
      W.isBN = function(pe) {
        return pe instanceof W ? !0 : pe !== null && typeof pe == "object" && pe.constructor.wordSize === W.wordSize && Array.isArray(pe.words);
      }, W.max = function(pe, nt) {
        return pe.cmp(nt) > 0 ? pe : nt;
      }, W.min = function(pe, nt) {
        return pe.cmp(nt) < 0 ? pe : nt;
      }, W.prototype._init = function(pe, nt, st) {
        if (typeof pe == "number")
          return this._initNumber(pe, nt, st);
        if (typeof pe == "object")
          return this._initArray(pe, nt, st);
        nt === "hex" && (nt = 16), K(nt === (nt | 0) && nt >= 2 && nt <= 36), pe = pe.toString().replace(/\s+/g, "");
        var ft = 0;
        pe[0] === "-" && (ft++, this.negative = 1), ft < pe.length && (nt === 16 ? this._parseHex(pe, ft, st) : (this._parseBase(pe, nt, ft), st === "le" && this._initArray(this.toArray(), nt, st)));
      }, W.prototype._initNumber = function(pe, nt, st) {
        pe < 0 && (this.negative = 1, pe = -pe), pe < 67108864 ? (this.words = [pe & 67108863], this.length = 1) : pe < 4503599627370496 ? (this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863
        ], this.length = 2) : (K(pe < 9007199254740992), this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863,
          1
        ], this.length = 3), st === "le" && this._initArray(this.toArray(), nt, st);
      }, W.prototype._initArray = function(pe, nt, st) {
        if (K(typeof pe.length == "number"), pe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(pe.length / 3), this.words = new Array(this.length);
        for (var ft = 0; ft < this.length; ft++)
          this.words[ft] = 0;
        var ht, bt, ut = 0;
        if (st === "be")
          for (ft = pe.length - 1, ht = 0; ft >= 0; ft -= 3)
            bt = pe[ft] | pe[ft - 1] << 8 | pe[ft - 2] << 16, this.words[ht] |= bt << ut & 67108863, this.words[ht + 1] = bt >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ht++);
        else if (st === "le")
          for (ft = 0, ht = 0; ft < pe.length; ft += 3)
            bt = pe[ft] | pe[ft + 1] << 8 | pe[ft + 2] << 16, this.words[ht] |= bt << ut & 67108863, this.words[ht + 1] = bt >>> 26 - ut & 67108863, ut += 24, ut >= 26 && (ut -= 26, ht++);
        return this._strip();
      };
      function ne(rt, pe) {
        var nt = rt.charCodeAt(pe);
        if (nt >= 48 && nt <= 57)
          return nt - 48;
        if (nt >= 65 && nt <= 70)
          return nt - 55;
        if (nt >= 97 && nt <= 102)
          return nt - 87;
        K(!1, "Invalid character in " + rt);
      }
      function ie(rt, pe, nt) {
        var st = ne(rt, nt);
        return nt - 1 >= pe && (st |= ne(rt, nt - 1) << 4), st;
      }
      W.prototype._parseHex = function(pe, nt, st) {
        this.length = Math.ceil((pe.length - nt) / 6), this.words = new Array(this.length);
        for (var ft = 0; ft < this.length; ft++)
          this.words[ft] = 0;
        var ht = 0, bt = 0, ut;
        if (st === "be")
          for (ft = pe.length - 1; ft >= nt; ft -= 2)
            ut = ie(pe, nt, ft) << ht, this.words[bt] |= ut & 67108863, ht >= 18 ? (ht -= 18, bt += 1, this.words[bt] |= ut >>> 26) : ht += 8;
        else {
          var gt = pe.length - nt;
          for (ft = gt % 2 === 0 ? nt + 1 : nt; ft < pe.length; ft += 2)
            ut = ie(pe, nt, ft) << ht, this.words[bt] |= ut & 67108863, ht >= 18 ? (ht -= 18, bt += 1, this.words[bt] |= ut >>> 26) : ht += 8;
        }
        this._strip();
      };
      function ce(rt, pe, nt, st) {
        for (var ft = 0, ht = 0, bt = Math.min(rt.length, nt), ut = pe; ut < bt; ut++) {
          var gt = rt.charCodeAt(ut) - 48;
          ft *= st, gt >= 49 ? ht = gt - 49 + 10 : gt >= 17 ? ht = gt - 17 + 10 : ht = gt, K(gt >= 0 && ht < st, "Invalid character"), ft += ht;
        }
        return ft;
      }
      W.prototype._parseBase = function(pe, nt, st) {
        this.words = [0], this.length = 1;
        for (var ft = 0, ht = 1; ht <= 67108863; ht *= nt)
          ft++;
        ft--, ht = ht / nt | 0;
        for (var bt = pe.length - st, ut = bt % ft, gt = Math.min(bt, bt - ut) + st, lt = 0, $t = st; $t < gt; $t += ft)
          lt = ce(pe, $t, $t + ft, nt), this.imuln(ht), this.words[0] + lt < 67108864 ? this.words[0] += lt : this._iaddn(lt);
        if (ut !== 0) {
          var jt = 1;
          for (lt = ce(pe, $t, pe.length, nt), $t = 0; $t < ut; $t++)
            jt *= nt;
          this.imuln(jt), this.words[0] + lt < 67108864 ? this.words[0] += lt : this._iaddn(lt);
        }
        this._strip();
      }, W.prototype.copy = function(pe) {
        pe.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          pe.words[nt] = this.words[nt];
        pe.length = this.length, pe.negative = this.negative, pe.red = this.red;
      };
      function re(rt, pe) {
        rt.words = pe.words, rt.length = pe.length, rt.negative = pe.negative, rt.red = pe.red;
      }
      if (W.prototype._move = function(pe) {
        re(pe, this);
      }, W.prototype.clone = function() {
        var pe = new W(null);
        return this.copy(pe), pe;
      }, W.prototype._expand = function(pe) {
        for (; this.length < pe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          W.prototype[Symbol.for("nodejs.util.inspect.custom")] = oe;
        } catch {
          W.prototype.inspect = oe;
        }
      else
        W.prototype.inspect = oe;
      function oe() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var ke = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ce = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], it = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(pe, nt) {
        pe = pe || 10, nt = nt | 0 || 1;
        var st;
        if (pe === 16 || pe === "hex") {
          st = "";
          for (var ft = 0, ht = 0, bt = 0; bt < this.length; bt++) {
            var ut = this.words[bt], gt = ((ut << ft | ht) & 16777215).toString(16);
            ht = ut >>> 24 - ft & 16777215, ft += 2, ft >= 26 && (ft -= 26, bt--), ht !== 0 || bt !== this.length - 1 ? st = ke[6 - gt.length] + gt + st : st = gt + st;
          }
          for (ht !== 0 && (st = ht.toString(16) + st); st.length % nt !== 0; )
            st = "0" + st;
          return this.negative !== 0 && (st = "-" + st), st;
        }
        if (pe === (pe | 0) && pe >= 2 && pe <= 36) {
          var lt = Ce[pe], $t = it[pe];
          st = "";
          var jt = this.clone();
          for (jt.negative = 0; !jt.isZero(); ) {
            var Jt = jt.modrn($t).toString(pe);
            jt = jt.idivn($t), jt.isZero() ? st = Jt + st : st = ke[lt - Jt.length] + Jt + st;
          }
          for (this.isZero() && (st = "0" + st); st.length % nt !== 0; )
            st = "0" + st;
          return this.negative !== 0 && (st = "-" + st), st;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var pe = this.words[0];
        return this.length === 2 ? pe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? pe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -pe : pe;
      }, W.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, J && (W.prototype.toBuffer = function(pe, nt) {
        return this.toArrayLike(J, pe, nt);
      }), W.prototype.toArray = function(pe, nt) {
        return this.toArrayLike(Array, pe, nt);
      };
      var at = function(pe, nt) {
        return pe.allocUnsafe ? pe.allocUnsafe(nt) : new pe(nt);
      };
      W.prototype.toArrayLike = function(pe, nt, st) {
        this._strip();
        var ft = this.byteLength(), ht = st || Math.max(1, ft);
        K(ft <= ht, "byte array longer than desired length"), K(ht > 0, "Requested array length <= 0");
        var bt = at(pe, ht), ut = nt === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ut](bt, ft), bt;
      }, W.prototype._toArrayLikeLE = function(pe, nt) {
        for (var st = 0, ft = 0, ht = 0, bt = 0; ht < this.length; ht++) {
          var ut = this.words[ht] << bt | ft;
          pe[st++] = ut & 255, st < pe.length && (pe[st++] = ut >> 8 & 255), st < pe.length && (pe[st++] = ut >> 16 & 255), bt === 6 ? (st < pe.length && (pe[st++] = ut >> 24 & 255), ft = 0, bt = 0) : (ft = ut >>> 24, bt += 2);
        }
        if (st < pe.length)
          for (pe[st++] = ft; st < pe.length; )
            pe[st++] = 0;
      }, W.prototype._toArrayLikeBE = function(pe, nt) {
        for (var st = pe.length - 1, ft = 0, ht = 0, bt = 0; ht < this.length; ht++) {
          var ut = this.words[ht] << bt | ft;
          pe[st--] = ut & 255, st >= 0 && (pe[st--] = ut >> 8 & 255), st >= 0 && (pe[st--] = ut >> 16 & 255), bt === 6 ? (st >= 0 && (pe[st--] = ut >> 24 & 255), ft = 0, bt = 0) : (ft = ut >>> 24, bt += 2);
        }
        if (st >= 0)
          for (pe[st--] = ft; st >= 0; )
            pe[st--] = 0;
      }, Math.clz32 ? W.prototype._countBits = function(pe) {
        return 32 - Math.clz32(pe);
      } : W.prototype._countBits = function(pe) {
        var nt = pe, st = 0;
        return nt >= 4096 && (st += 13, nt >>>= 13), nt >= 64 && (st += 7, nt >>>= 7), nt >= 8 && (st += 4, nt >>>= 4), nt >= 2 && (st += 2, nt >>>= 2), st + nt;
      }, W.prototype._zeroBits = function(pe) {
        if (pe === 0) return 26;
        var nt = pe, st = 0;
        return nt & 8191 || (st += 13, nt >>>= 13), nt & 127 || (st += 7, nt >>>= 7), nt & 15 || (st += 4, nt >>>= 4), nt & 3 || (st += 2, nt >>>= 2), nt & 1 || st++, st;
      }, W.prototype.bitLength = function() {
        var pe = this.words[this.length - 1], nt = this._countBits(pe);
        return (this.length - 1) * 26 + nt;
      };
      function ct(rt) {
        for (var pe = new Array(rt.bitLength()), nt = 0; nt < pe.length; nt++) {
          var st = nt / 26 | 0, ft = nt % 26;
          pe[nt] = rt.words[st] >>> ft & 1;
        }
        return pe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var pe = 0, nt = 0; nt < this.length; nt++) {
          var st = this._zeroBits(this.words[nt]);
          if (pe += st, st !== 26) break;
        }
        return pe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(pe) {
        return this.negative !== 0 ? this.abs().inotn(pe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(pe) {
        return this.testn(pe - 1) ? this.notn(pe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(pe) {
        for (; this.length < pe.length; )
          this.words[this.length++] = 0;
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = this.words[nt] | pe.words[nt];
        return this._strip();
      }, W.prototype.ior = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuor(pe);
      }, W.prototype.or = function(pe) {
        return this.length > pe.length ? this.clone().ior(pe) : pe.clone().ior(this);
      }, W.prototype.uor = function(pe) {
        return this.length > pe.length ? this.clone().iuor(pe) : pe.clone().iuor(this);
      }, W.prototype.iuand = function(pe) {
        var nt;
        this.length > pe.length ? nt = pe : nt = this;
        for (var st = 0; st < nt.length; st++)
          this.words[st] = this.words[st] & pe.words[st];
        return this.length = nt.length, this._strip();
      }, W.prototype.iand = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuand(pe);
      }, W.prototype.and = function(pe) {
        return this.length > pe.length ? this.clone().iand(pe) : pe.clone().iand(this);
      }, W.prototype.uand = function(pe) {
        return this.length > pe.length ? this.clone().iuand(pe) : pe.clone().iuand(this);
      }, W.prototype.iuxor = function(pe) {
        var nt, st;
        this.length > pe.length ? (nt = this, st = pe) : (nt = pe, st = this);
        for (var ft = 0; ft < st.length; ft++)
          this.words[ft] = nt.words[ft] ^ st.words[ft];
        if (this !== nt)
          for (; ft < nt.length; ft++)
            this.words[ft] = nt.words[ft];
        return this.length = nt.length, this._strip();
      }, W.prototype.ixor = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuxor(pe);
      }, W.prototype.xor = function(pe) {
        return this.length > pe.length ? this.clone().ixor(pe) : pe.clone().ixor(this);
      }, W.prototype.uxor = function(pe) {
        return this.length > pe.length ? this.clone().iuxor(pe) : pe.clone().iuxor(this);
      }, W.prototype.inotn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = Math.ceil(pe / 26) | 0, st = pe % 26;
        this._expand(nt), st > 0 && nt--;
        for (var ft = 0; ft < nt; ft++)
          this.words[ft] = ~this.words[ft] & 67108863;
        return st > 0 && (this.words[ft] = ~this.words[ft] & 67108863 >> 26 - st), this._strip();
      }, W.prototype.notn = function(pe) {
        return this.clone().inotn(pe);
      }, W.prototype.setn = function(pe, nt) {
        K(typeof pe == "number" && pe >= 0);
        var st = pe / 26 | 0, ft = pe % 26;
        return this._expand(st + 1), nt ? this.words[st] = this.words[st] | 1 << ft : this.words[st] = this.words[st] & ~(1 << ft), this._strip();
      }, W.prototype.iadd = function(pe) {
        var nt;
        if (this.negative !== 0 && pe.negative === 0)
          return this.negative = 0, nt = this.isub(pe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && pe.negative !== 0)
          return pe.negative = 0, nt = this.isub(pe), pe.negative = 1, nt._normSign();
        var st, ft;
        this.length > pe.length ? (st = this, ft = pe) : (st = pe, ft = this);
        for (var ht = 0, bt = 0; bt < ft.length; bt++)
          nt = (st.words[bt] | 0) + (ft.words[bt] | 0) + ht, this.words[bt] = nt & 67108863, ht = nt >>> 26;
        for (; ht !== 0 && bt < st.length; bt++)
          nt = (st.words[bt] | 0) + ht, this.words[bt] = nt & 67108863, ht = nt >>> 26;
        if (this.length = st.length, ht !== 0)
          this.words[this.length] = ht, this.length++;
        else if (st !== this)
          for (; bt < st.length; bt++)
            this.words[bt] = st.words[bt];
        return this;
      }, W.prototype.add = function(pe) {
        var nt;
        return pe.negative !== 0 && this.negative === 0 ? (pe.negative = 0, nt = this.sub(pe), pe.negative ^= 1, nt) : pe.negative === 0 && this.negative !== 0 ? (this.negative = 0, nt = pe.sub(this), this.negative = 1, nt) : this.length > pe.length ? this.clone().iadd(pe) : pe.clone().iadd(this);
      }, W.prototype.isub = function(pe) {
        if (pe.negative !== 0) {
          pe.negative = 0;
          var nt = this.iadd(pe);
          return pe.negative = 1, nt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(pe), this.negative = 1, this._normSign();
        var st = this.cmp(pe);
        if (st === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var ft, ht;
        st > 0 ? (ft = this, ht = pe) : (ft = pe, ht = this);
        for (var bt = 0, ut = 0; ut < ht.length; ut++)
          nt = (ft.words[ut] | 0) - (ht.words[ut] | 0) + bt, bt = nt >> 26, this.words[ut] = nt & 67108863;
        for (; bt !== 0 && ut < ft.length; ut++)
          nt = (ft.words[ut] | 0) + bt, bt = nt >> 26, this.words[ut] = nt & 67108863;
        if (bt === 0 && ut < ft.length && ft !== this)
          for (; ut < ft.length; ut++)
            this.words[ut] = ft.words[ut];
        return this.length = Math.max(this.length, ut), ft !== this && (this.negative = 1), this._strip();
      }, W.prototype.sub = function(pe) {
        return this.clone().isub(pe);
      };
      function dt(rt, pe, nt) {
        nt.negative = pe.negative ^ rt.negative;
        var st = rt.length + pe.length | 0;
        nt.length = st, st = st - 1 | 0;
        var ft = rt.words[0] | 0, ht = pe.words[0] | 0, bt = ft * ht, ut = bt & 67108863, gt = bt / 67108864 | 0;
        nt.words[0] = ut;
        for (var lt = 1; lt < st; lt++) {
          for (var $t = gt >>> 26, jt = gt & 67108863, Jt = Math.min(lt, pe.length - 1), Lt = Math.max(0, lt - rt.length + 1); Lt <= Jt; Lt++) {
            var Rt = lt - Lt | 0;
            ft = rt.words[Rt] | 0, ht = pe.words[Lt] | 0, bt = ft * ht + jt, $t += bt / 67108864 | 0, jt = bt & 67108863;
          }
          nt.words[lt] = jt | 0, gt = $t | 0;
        }
        return gt !== 0 ? nt.words[lt] = gt | 0 : nt.length--, nt._strip();
      }
      var ot = function(pe, nt, st) {
        var ft = pe.words, ht = nt.words, bt = st.words, ut = 0, gt, lt, $t, jt = ft[0] | 0, Jt = jt & 8191, Lt = jt >>> 13, Rt = ft[1] | 0, Mt = Rt & 8191, Kt = Rt >>> 13, zt = ft[2] | 0, Ct = zt & 8191, kt = zt >>> 13, Vt = ft[3] | 0, nr = Vt & 8191, ar = Vt >>> 13, sr = ft[4] | 0, lr = sr & 8191, dr = sr >>> 13, rr = ft[5] | 0, Pr = rr & 8191, ur = rr >>> 13, pr = ft[6] | 0, br = pr & 8191, hr = pr >>> 13, xr = ft[7] | 0, Mr = xr & 8191, _r = xr >>> 13, Rr = ft[8] | 0, kr = Rr & 8191, Ot = Rr >>> 13, At = ft[9] | 0, Bt = At & 8191, Ut = At >>> 13, Xt = ht[0] | 0, Zt = Xt & 8191, tr = Xt >>> 13, vr = ht[1] | 0, Br = vr & 8191, yr = vr >>> 13, $r = ht[2] | 0, Er = $r & 8191, wr = $r >>> 13, Ir = ht[3] | 0, Or = Ir & 8191, Wt = Ir >>> 13, Ft = ht[4] | 0, Gt = Ft & 8191, xt = Ft >>> 13, pt = ht[5] | 0, Et = pt & 8191, qt = pt >>> 13, Ht = ht[6] | 0, Yt = Ht & 8191, Qt = Ht >>> 13, or = ht[7] | 0, cr = or & 8191, Dt = or >>> 13, er = ht[8] | 0, ir = er & 8191, fr = er >>> 13, Ar = ht[9] | 0, Sr = Ar & 8191, gr = Ar >>> 13;
        st.negative = pe.negative ^ nt.negative, st.length = 19, gt = Math.imul(Jt, Zt), lt = Math.imul(Jt, tr), lt = lt + Math.imul(Lt, Zt) | 0, $t = Math.imul(Lt, tr);
        var Tr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, gt = Math.imul(Mt, Zt), lt = Math.imul(Mt, tr), lt = lt + Math.imul(Kt, Zt) | 0, $t = Math.imul(Kt, tr), gt = gt + Math.imul(Jt, Br) | 0, lt = lt + Math.imul(Jt, yr) | 0, lt = lt + Math.imul(Lt, Br) | 0, $t = $t + Math.imul(Lt, yr) | 0;
        var Nr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, gt = Math.imul(Ct, Zt), lt = Math.imul(Ct, tr), lt = lt + Math.imul(kt, Zt) | 0, $t = Math.imul(kt, tr), gt = gt + Math.imul(Mt, Br) | 0, lt = lt + Math.imul(Mt, yr) | 0, lt = lt + Math.imul(Kt, Br) | 0, $t = $t + Math.imul(Kt, yr) | 0, gt = gt + Math.imul(Jt, Er) | 0, lt = lt + Math.imul(Jt, wr) | 0, lt = lt + Math.imul(Lt, Er) | 0, $t = $t + Math.imul(Lt, wr) | 0;
        var Cr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, gt = Math.imul(nr, Zt), lt = Math.imul(nr, tr), lt = lt + Math.imul(ar, Zt) | 0, $t = Math.imul(ar, tr), gt = gt + Math.imul(Ct, Br) | 0, lt = lt + Math.imul(Ct, yr) | 0, lt = lt + Math.imul(kt, Br) | 0, $t = $t + Math.imul(kt, yr) | 0, gt = gt + Math.imul(Mt, Er) | 0, lt = lt + Math.imul(Mt, wr) | 0, lt = lt + Math.imul(Kt, Er) | 0, $t = $t + Math.imul(Kt, wr) | 0, gt = gt + Math.imul(Jt, Or) | 0, lt = lt + Math.imul(Jt, Wt) | 0, lt = lt + Math.imul(Lt, Or) | 0, $t = $t + Math.imul(Lt, Wt) | 0;
        var qr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, gt = Math.imul(lr, Zt), lt = Math.imul(lr, tr), lt = lt + Math.imul(dr, Zt) | 0, $t = Math.imul(dr, tr), gt = gt + Math.imul(nr, Br) | 0, lt = lt + Math.imul(nr, yr) | 0, lt = lt + Math.imul(ar, Br) | 0, $t = $t + Math.imul(ar, yr) | 0, gt = gt + Math.imul(Ct, Er) | 0, lt = lt + Math.imul(Ct, wr) | 0, lt = lt + Math.imul(kt, Er) | 0, $t = $t + Math.imul(kt, wr) | 0, gt = gt + Math.imul(Mt, Or) | 0, lt = lt + Math.imul(Mt, Wt) | 0, lt = lt + Math.imul(Kt, Or) | 0, $t = $t + Math.imul(Kt, Wt) | 0, gt = gt + Math.imul(Jt, Gt) | 0, lt = lt + Math.imul(Jt, xt) | 0, lt = lt + Math.imul(Lt, Gt) | 0, $t = $t + Math.imul(Lt, xt) | 0;
        var Ur = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, gt = Math.imul(Pr, Zt), lt = Math.imul(Pr, tr), lt = lt + Math.imul(ur, Zt) | 0, $t = Math.imul(ur, tr), gt = gt + Math.imul(lr, Br) | 0, lt = lt + Math.imul(lr, yr) | 0, lt = lt + Math.imul(dr, Br) | 0, $t = $t + Math.imul(dr, yr) | 0, gt = gt + Math.imul(nr, Er) | 0, lt = lt + Math.imul(nr, wr) | 0, lt = lt + Math.imul(ar, Er) | 0, $t = $t + Math.imul(ar, wr) | 0, gt = gt + Math.imul(Ct, Or) | 0, lt = lt + Math.imul(Ct, Wt) | 0, lt = lt + Math.imul(kt, Or) | 0, $t = $t + Math.imul(kt, Wt) | 0, gt = gt + Math.imul(Mt, Gt) | 0, lt = lt + Math.imul(Mt, xt) | 0, lt = lt + Math.imul(Kt, Gt) | 0, $t = $t + Math.imul(Kt, xt) | 0, gt = gt + Math.imul(Jt, Et) | 0, lt = lt + Math.imul(Jt, qt) | 0, lt = lt + Math.imul(Lt, Et) | 0, $t = $t + Math.imul(Lt, qt) | 0;
        var Dr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, gt = Math.imul(br, Zt), lt = Math.imul(br, tr), lt = lt + Math.imul(hr, Zt) | 0, $t = Math.imul(hr, tr), gt = gt + Math.imul(Pr, Br) | 0, lt = lt + Math.imul(Pr, yr) | 0, lt = lt + Math.imul(ur, Br) | 0, $t = $t + Math.imul(ur, yr) | 0, gt = gt + Math.imul(lr, Er) | 0, lt = lt + Math.imul(lr, wr) | 0, lt = lt + Math.imul(dr, Er) | 0, $t = $t + Math.imul(dr, wr) | 0, gt = gt + Math.imul(nr, Or) | 0, lt = lt + Math.imul(nr, Wt) | 0, lt = lt + Math.imul(ar, Or) | 0, $t = $t + Math.imul(ar, Wt) | 0, gt = gt + Math.imul(Ct, Gt) | 0, lt = lt + Math.imul(Ct, xt) | 0, lt = lt + Math.imul(kt, Gt) | 0, $t = $t + Math.imul(kt, xt) | 0, gt = gt + Math.imul(Mt, Et) | 0, lt = lt + Math.imul(Mt, qt) | 0, lt = lt + Math.imul(Kt, Et) | 0, $t = $t + Math.imul(Kt, qt) | 0, gt = gt + Math.imul(Jt, Yt) | 0, lt = lt + Math.imul(Jt, Qt) | 0, lt = lt + Math.imul(Lt, Yt) | 0, $t = $t + Math.imul(Lt, Qt) | 0;
        var Lr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, gt = Math.imul(Mr, Zt), lt = Math.imul(Mr, tr), lt = lt + Math.imul(_r, Zt) | 0, $t = Math.imul(_r, tr), gt = gt + Math.imul(br, Br) | 0, lt = lt + Math.imul(br, yr) | 0, lt = lt + Math.imul(hr, Br) | 0, $t = $t + Math.imul(hr, yr) | 0, gt = gt + Math.imul(Pr, Er) | 0, lt = lt + Math.imul(Pr, wr) | 0, lt = lt + Math.imul(ur, Er) | 0, $t = $t + Math.imul(ur, wr) | 0, gt = gt + Math.imul(lr, Or) | 0, lt = lt + Math.imul(lr, Wt) | 0, lt = lt + Math.imul(dr, Or) | 0, $t = $t + Math.imul(dr, Wt) | 0, gt = gt + Math.imul(nr, Gt) | 0, lt = lt + Math.imul(nr, xt) | 0, lt = lt + Math.imul(ar, Gt) | 0, $t = $t + Math.imul(ar, xt) | 0, gt = gt + Math.imul(Ct, Et) | 0, lt = lt + Math.imul(Ct, qt) | 0, lt = lt + Math.imul(kt, Et) | 0, $t = $t + Math.imul(kt, qt) | 0, gt = gt + Math.imul(Mt, Yt) | 0, lt = lt + Math.imul(Mt, Qt) | 0, lt = lt + Math.imul(Kt, Yt) | 0, $t = $t + Math.imul(Kt, Qt) | 0, gt = gt + Math.imul(Jt, cr) | 0, lt = lt + Math.imul(Jt, Dt) | 0, lt = lt + Math.imul(Lt, cr) | 0, $t = $t + Math.imul(Lt, Dt) | 0;
        var Fr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, gt = Math.imul(kr, Zt), lt = Math.imul(kr, tr), lt = lt + Math.imul(Ot, Zt) | 0, $t = Math.imul(Ot, tr), gt = gt + Math.imul(Mr, Br) | 0, lt = lt + Math.imul(Mr, yr) | 0, lt = lt + Math.imul(_r, Br) | 0, $t = $t + Math.imul(_r, yr) | 0, gt = gt + Math.imul(br, Er) | 0, lt = lt + Math.imul(br, wr) | 0, lt = lt + Math.imul(hr, Er) | 0, $t = $t + Math.imul(hr, wr) | 0, gt = gt + Math.imul(Pr, Or) | 0, lt = lt + Math.imul(Pr, Wt) | 0, lt = lt + Math.imul(ur, Or) | 0, $t = $t + Math.imul(ur, Wt) | 0, gt = gt + Math.imul(lr, Gt) | 0, lt = lt + Math.imul(lr, xt) | 0, lt = lt + Math.imul(dr, Gt) | 0, $t = $t + Math.imul(dr, xt) | 0, gt = gt + Math.imul(nr, Et) | 0, lt = lt + Math.imul(nr, qt) | 0, lt = lt + Math.imul(ar, Et) | 0, $t = $t + Math.imul(ar, qt) | 0, gt = gt + Math.imul(Ct, Yt) | 0, lt = lt + Math.imul(Ct, Qt) | 0, lt = lt + Math.imul(kt, Yt) | 0, $t = $t + Math.imul(kt, Qt) | 0, gt = gt + Math.imul(Mt, cr) | 0, lt = lt + Math.imul(Mt, Dt) | 0, lt = lt + Math.imul(Kt, cr) | 0, $t = $t + Math.imul(Kt, Dt) | 0, gt = gt + Math.imul(Jt, ir) | 0, lt = lt + Math.imul(Jt, fr) | 0, lt = lt + Math.imul(Lt, ir) | 0, $t = $t + Math.imul(Lt, fr) | 0;
        var jr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, gt = Math.imul(Bt, Zt), lt = Math.imul(Bt, tr), lt = lt + Math.imul(Ut, Zt) | 0, $t = Math.imul(Ut, tr), gt = gt + Math.imul(kr, Br) | 0, lt = lt + Math.imul(kr, yr) | 0, lt = lt + Math.imul(Ot, Br) | 0, $t = $t + Math.imul(Ot, yr) | 0, gt = gt + Math.imul(Mr, Er) | 0, lt = lt + Math.imul(Mr, wr) | 0, lt = lt + Math.imul(_r, Er) | 0, $t = $t + Math.imul(_r, wr) | 0, gt = gt + Math.imul(br, Or) | 0, lt = lt + Math.imul(br, Wt) | 0, lt = lt + Math.imul(hr, Or) | 0, $t = $t + Math.imul(hr, Wt) | 0, gt = gt + Math.imul(Pr, Gt) | 0, lt = lt + Math.imul(Pr, xt) | 0, lt = lt + Math.imul(ur, Gt) | 0, $t = $t + Math.imul(ur, xt) | 0, gt = gt + Math.imul(lr, Et) | 0, lt = lt + Math.imul(lr, qt) | 0, lt = lt + Math.imul(dr, Et) | 0, $t = $t + Math.imul(dr, qt) | 0, gt = gt + Math.imul(nr, Yt) | 0, lt = lt + Math.imul(nr, Qt) | 0, lt = lt + Math.imul(ar, Yt) | 0, $t = $t + Math.imul(ar, Qt) | 0, gt = gt + Math.imul(Ct, cr) | 0, lt = lt + Math.imul(Ct, Dt) | 0, lt = lt + Math.imul(kt, cr) | 0, $t = $t + Math.imul(kt, Dt) | 0, gt = gt + Math.imul(Mt, ir) | 0, lt = lt + Math.imul(Mt, fr) | 0, lt = lt + Math.imul(Kt, ir) | 0, $t = $t + Math.imul(Kt, fr) | 0, gt = gt + Math.imul(Jt, Sr) | 0, lt = lt + Math.imul(Jt, gr) | 0, lt = lt + Math.imul(Lt, Sr) | 0, $t = $t + Math.imul(Lt, gr) | 0;
        var Hr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, gt = Math.imul(Bt, Br), lt = Math.imul(Bt, yr), lt = lt + Math.imul(Ut, Br) | 0, $t = Math.imul(Ut, yr), gt = gt + Math.imul(kr, Er) | 0, lt = lt + Math.imul(kr, wr) | 0, lt = lt + Math.imul(Ot, Er) | 0, $t = $t + Math.imul(Ot, wr) | 0, gt = gt + Math.imul(Mr, Or) | 0, lt = lt + Math.imul(Mr, Wt) | 0, lt = lt + Math.imul(_r, Or) | 0, $t = $t + Math.imul(_r, Wt) | 0, gt = gt + Math.imul(br, Gt) | 0, lt = lt + Math.imul(br, xt) | 0, lt = lt + Math.imul(hr, Gt) | 0, $t = $t + Math.imul(hr, xt) | 0, gt = gt + Math.imul(Pr, Et) | 0, lt = lt + Math.imul(Pr, qt) | 0, lt = lt + Math.imul(ur, Et) | 0, $t = $t + Math.imul(ur, qt) | 0, gt = gt + Math.imul(lr, Yt) | 0, lt = lt + Math.imul(lr, Qt) | 0, lt = lt + Math.imul(dr, Yt) | 0, $t = $t + Math.imul(dr, Qt) | 0, gt = gt + Math.imul(nr, cr) | 0, lt = lt + Math.imul(nr, Dt) | 0, lt = lt + Math.imul(ar, cr) | 0, $t = $t + Math.imul(ar, Dt) | 0, gt = gt + Math.imul(Ct, ir) | 0, lt = lt + Math.imul(Ct, fr) | 0, lt = lt + Math.imul(kt, ir) | 0, $t = $t + Math.imul(kt, fr) | 0, gt = gt + Math.imul(Mt, Sr) | 0, lt = lt + Math.imul(Mt, gr) | 0, lt = lt + Math.imul(Kt, Sr) | 0, $t = $t + Math.imul(Kt, gr) | 0;
        var Wr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, gt = Math.imul(Bt, Er), lt = Math.imul(Bt, wr), lt = lt + Math.imul(Ut, Er) | 0, $t = Math.imul(Ut, wr), gt = gt + Math.imul(kr, Or) | 0, lt = lt + Math.imul(kr, Wt) | 0, lt = lt + Math.imul(Ot, Or) | 0, $t = $t + Math.imul(Ot, Wt) | 0, gt = gt + Math.imul(Mr, Gt) | 0, lt = lt + Math.imul(Mr, xt) | 0, lt = lt + Math.imul(_r, Gt) | 0, $t = $t + Math.imul(_r, xt) | 0, gt = gt + Math.imul(br, Et) | 0, lt = lt + Math.imul(br, qt) | 0, lt = lt + Math.imul(hr, Et) | 0, $t = $t + Math.imul(hr, qt) | 0, gt = gt + Math.imul(Pr, Yt) | 0, lt = lt + Math.imul(Pr, Qt) | 0, lt = lt + Math.imul(ur, Yt) | 0, $t = $t + Math.imul(ur, Qt) | 0, gt = gt + Math.imul(lr, cr) | 0, lt = lt + Math.imul(lr, Dt) | 0, lt = lt + Math.imul(dr, cr) | 0, $t = $t + Math.imul(dr, Dt) | 0, gt = gt + Math.imul(nr, ir) | 0, lt = lt + Math.imul(nr, fr) | 0, lt = lt + Math.imul(ar, ir) | 0, $t = $t + Math.imul(ar, fr) | 0, gt = gt + Math.imul(Ct, Sr) | 0, lt = lt + Math.imul(Ct, gr) | 0, lt = lt + Math.imul(kt, Sr) | 0, $t = $t + Math.imul(kt, gr) | 0;
        var Gr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, gt = Math.imul(Bt, Or), lt = Math.imul(Bt, Wt), lt = lt + Math.imul(Ut, Or) | 0, $t = Math.imul(Ut, Wt), gt = gt + Math.imul(kr, Gt) | 0, lt = lt + Math.imul(kr, xt) | 0, lt = lt + Math.imul(Ot, Gt) | 0, $t = $t + Math.imul(Ot, xt) | 0, gt = gt + Math.imul(Mr, Et) | 0, lt = lt + Math.imul(Mr, qt) | 0, lt = lt + Math.imul(_r, Et) | 0, $t = $t + Math.imul(_r, qt) | 0, gt = gt + Math.imul(br, Yt) | 0, lt = lt + Math.imul(br, Qt) | 0, lt = lt + Math.imul(hr, Yt) | 0, $t = $t + Math.imul(hr, Qt) | 0, gt = gt + Math.imul(Pr, cr) | 0, lt = lt + Math.imul(Pr, Dt) | 0, lt = lt + Math.imul(ur, cr) | 0, $t = $t + Math.imul(ur, Dt) | 0, gt = gt + Math.imul(lr, ir) | 0, lt = lt + Math.imul(lr, fr) | 0, lt = lt + Math.imul(dr, ir) | 0, $t = $t + Math.imul(dr, fr) | 0, gt = gt + Math.imul(nr, Sr) | 0, lt = lt + Math.imul(nr, gr) | 0, lt = lt + Math.imul(ar, Sr) | 0, $t = $t + Math.imul(ar, gr) | 0;
        var Vr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, gt = Math.imul(Bt, Gt), lt = Math.imul(Bt, xt), lt = lt + Math.imul(Ut, Gt) | 0, $t = Math.imul(Ut, xt), gt = gt + Math.imul(kr, Et) | 0, lt = lt + Math.imul(kr, qt) | 0, lt = lt + Math.imul(Ot, Et) | 0, $t = $t + Math.imul(Ot, qt) | 0, gt = gt + Math.imul(Mr, Yt) | 0, lt = lt + Math.imul(Mr, Qt) | 0, lt = lt + Math.imul(_r, Yt) | 0, $t = $t + Math.imul(_r, Qt) | 0, gt = gt + Math.imul(br, cr) | 0, lt = lt + Math.imul(br, Dt) | 0, lt = lt + Math.imul(hr, cr) | 0, $t = $t + Math.imul(hr, Dt) | 0, gt = gt + Math.imul(Pr, ir) | 0, lt = lt + Math.imul(Pr, fr) | 0, lt = lt + Math.imul(ur, ir) | 0, $t = $t + Math.imul(ur, fr) | 0, gt = gt + Math.imul(lr, Sr) | 0, lt = lt + Math.imul(lr, gr) | 0, lt = lt + Math.imul(dr, Sr) | 0, $t = $t + Math.imul(dr, gr) | 0;
        var zr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, gt = Math.imul(Bt, Et), lt = Math.imul(Bt, qt), lt = lt + Math.imul(Ut, Et) | 0, $t = Math.imul(Ut, qt), gt = gt + Math.imul(kr, Yt) | 0, lt = lt + Math.imul(kr, Qt) | 0, lt = lt + Math.imul(Ot, Yt) | 0, $t = $t + Math.imul(Ot, Qt) | 0, gt = gt + Math.imul(Mr, cr) | 0, lt = lt + Math.imul(Mr, Dt) | 0, lt = lt + Math.imul(_r, cr) | 0, $t = $t + Math.imul(_r, Dt) | 0, gt = gt + Math.imul(br, ir) | 0, lt = lt + Math.imul(br, fr) | 0, lt = lt + Math.imul(hr, ir) | 0, $t = $t + Math.imul(hr, fr) | 0, gt = gt + Math.imul(Pr, Sr) | 0, lt = lt + Math.imul(Pr, gr) | 0, lt = lt + Math.imul(ur, Sr) | 0, $t = $t + Math.imul(ur, gr) | 0;
        var Xr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, gt = Math.imul(Bt, Yt), lt = Math.imul(Bt, Qt), lt = lt + Math.imul(Ut, Yt) | 0, $t = Math.imul(Ut, Qt), gt = gt + Math.imul(kr, cr) | 0, lt = lt + Math.imul(kr, Dt) | 0, lt = lt + Math.imul(Ot, cr) | 0, $t = $t + Math.imul(Ot, Dt) | 0, gt = gt + Math.imul(Mr, ir) | 0, lt = lt + Math.imul(Mr, fr) | 0, lt = lt + Math.imul(_r, ir) | 0, $t = $t + Math.imul(_r, fr) | 0, gt = gt + Math.imul(br, Sr) | 0, lt = lt + Math.imul(br, gr) | 0, lt = lt + Math.imul(hr, Sr) | 0, $t = $t + Math.imul(hr, gr) | 0;
        var Yr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, gt = Math.imul(Bt, cr), lt = Math.imul(Bt, Dt), lt = lt + Math.imul(Ut, cr) | 0, $t = Math.imul(Ut, Dt), gt = gt + Math.imul(kr, ir) | 0, lt = lt + Math.imul(kr, fr) | 0, lt = lt + Math.imul(Ot, ir) | 0, $t = $t + Math.imul(Ot, fr) | 0, gt = gt + Math.imul(Mr, Sr) | 0, lt = lt + Math.imul(Mr, gr) | 0, lt = lt + Math.imul(_r, Sr) | 0, $t = $t + Math.imul(_r, gr) | 0;
        var Jr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, gt = Math.imul(Bt, ir), lt = Math.imul(Bt, fr), lt = lt + Math.imul(Ut, ir) | 0, $t = Math.imul(Ut, fr), gt = gt + Math.imul(kr, Sr) | 0, lt = lt + Math.imul(kr, gr) | 0, lt = lt + Math.imul(Ot, Sr) | 0, $t = $t + Math.imul(Ot, gr) | 0;
        var Qr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        ut = ($t + (lt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, gt = Math.imul(Bt, Sr), lt = Math.imul(Bt, gr), lt = lt + Math.imul(Ut, Sr) | 0, $t = Math.imul(Ut, gr);
        var Zr = (ut + gt | 0) + ((lt & 8191) << 13) | 0;
        return ut = ($t + (lt >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, bt[0] = Tr, bt[1] = Nr, bt[2] = Cr, bt[3] = qr, bt[4] = Ur, bt[5] = Dr, bt[6] = Lr, bt[7] = Fr, bt[8] = jr, bt[9] = Hr, bt[10] = Wr, bt[11] = Gr, bt[12] = Vr, bt[13] = zr, bt[14] = Xr, bt[15] = Yr, bt[16] = Jr, bt[17] = Qr, bt[18] = Zr, ut !== 0 && (bt[19] = ut, st.length++), st;
      };
      Math.imul || (ot = dt);
      function yt(rt, pe, nt) {
        nt.negative = pe.negative ^ rt.negative, nt.length = rt.length + pe.length;
        for (var st = 0, ft = 0, ht = 0; ht < nt.length - 1; ht++) {
          var bt = ft;
          ft = 0;
          for (var ut = st & 67108863, gt = Math.min(ht, pe.length - 1), lt = Math.max(0, ht - rt.length + 1); lt <= gt; lt++) {
            var $t = ht - lt, jt = rt.words[$t] | 0, Jt = pe.words[lt] | 0, Lt = jt * Jt, Rt = Lt & 67108863;
            bt = bt + (Lt / 67108864 | 0) | 0, Rt = Rt + ut | 0, ut = Rt & 67108863, bt = bt + (Rt >>> 26) | 0, ft += bt >>> 26, bt &= 67108863;
          }
          nt.words[ht] = ut, st = bt, bt = ft;
        }
        return st !== 0 ? nt.words[ht] = st : nt.length--, nt._strip();
      }
      function mt(rt, pe, nt) {
        return yt(rt, pe, nt);
      }
      W.prototype.mulTo = function(pe, nt) {
        var st, ft = this.length + pe.length;
        return this.length === 10 && pe.length === 10 ? st = ot(this, pe, nt) : ft < 63 ? st = dt(this, pe, nt) : ft < 1024 ? st = yt(this, pe, nt) : st = mt(this, pe, nt), st;
      }, W.prototype.mul = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), this.mulTo(pe, nt);
      }, W.prototype.mulf = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), mt(this, pe, nt);
      }, W.prototype.imul = function(pe) {
        return this.clone().mulTo(pe, this);
      }, W.prototype.imuln = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(typeof pe == "number"), K(pe < 67108864);
        for (var st = 0, ft = 0; ft < this.length; ft++) {
          var ht = (this.words[ft] | 0) * pe, bt = (ht & 67108863) + (st & 67108863);
          st >>= 26, st += ht / 67108864 | 0, st += bt >>> 26, this.words[ft] = bt & 67108863;
        }
        return st !== 0 && (this.words[ft] = st, this.length++), nt ? this.ineg() : this;
      }, W.prototype.muln = function(pe) {
        return this.clone().imuln(pe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(pe) {
        var nt = ct(pe);
        if (nt.length === 0) return new W(1);
        for (var st = this, ft = 0; ft < nt.length && nt[ft] === 0; ft++, st = st.sqr())
          ;
        if (++ft < nt.length)
          for (var ht = st.sqr(); ft < nt.length; ft++, ht = ht.sqr())
            nt[ft] !== 0 && (st = st.mul(ht));
        return st;
      }, W.prototype.iushln = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, st = (pe - nt) / 26, ft = 67108863 >>> 26 - nt << 26 - nt, ht;
        if (nt !== 0) {
          var bt = 0;
          for (ht = 0; ht < this.length; ht++) {
            var ut = this.words[ht] & ft, gt = (this.words[ht] | 0) - ut << nt;
            this.words[ht] = gt | bt, bt = ut >>> 26 - nt;
          }
          bt && (this.words[ht] = bt, this.length++);
        }
        if (st !== 0) {
          for (ht = this.length - 1; ht >= 0; ht--)
            this.words[ht + st] = this.words[ht];
          for (ht = 0; ht < st; ht++)
            this.words[ht] = 0;
          this.length += st;
        }
        return this._strip();
      }, W.prototype.ishln = function(pe) {
        return K(this.negative === 0), this.iushln(pe);
      }, W.prototype.iushrn = function(pe, nt, st) {
        K(typeof pe == "number" && pe >= 0);
        var ft;
        nt ? ft = (nt - nt % 26) / 26 : ft = 0;
        var ht = pe % 26, bt = Math.min((pe - ht) / 26, this.length), ut = 67108863 ^ 67108863 >>> ht << ht, gt = st;
        if (ft -= bt, ft = Math.max(0, ft), gt) {
          for (var lt = 0; lt < bt; lt++)
            gt.words[lt] = this.words[lt];
          gt.length = bt;
        }
        if (bt !== 0) if (this.length > bt)
          for (this.length -= bt, lt = 0; lt < this.length; lt++)
            this.words[lt] = this.words[lt + bt];
        else
          this.words[0] = 0, this.length = 1;
        var $t = 0;
        for (lt = this.length - 1; lt >= 0 && ($t !== 0 || lt >= ft); lt--) {
          var jt = this.words[lt] | 0;
          this.words[lt] = $t << 26 - ht | jt >>> ht, $t = jt & ut;
        }
        return gt && $t !== 0 && (gt.words[gt.length++] = $t), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, W.prototype.ishrn = function(pe, nt, st) {
        return K(this.negative === 0), this.iushrn(pe, nt, st);
      }, W.prototype.shln = function(pe) {
        return this.clone().ishln(pe);
      }, W.prototype.ushln = function(pe) {
        return this.clone().iushln(pe);
      }, W.prototype.shrn = function(pe) {
        return this.clone().ishrn(pe);
      }, W.prototype.ushrn = function(pe) {
        return this.clone().iushrn(pe);
      }, W.prototype.testn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, st = (pe - nt) / 26, ft = 1 << nt;
        if (this.length <= st) return !1;
        var ht = this.words[st];
        return !!(ht & ft);
      }, W.prototype.imaskn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, st = (pe - nt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= st)
          return this;
        if (nt !== 0 && st++, this.length = Math.min(st, this.length), nt !== 0) {
          var ft = 67108863 ^ 67108863 >>> nt << nt;
          this.words[this.length - 1] &= ft;
        }
        return this._strip();
      }, W.prototype.maskn = function(pe) {
        return this.clone().imaskn(pe);
      }, W.prototype.iaddn = function(pe) {
        return K(typeof pe == "number"), K(pe < 67108864), pe < 0 ? this.isubn(-pe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= pe ? (this.words[0] = pe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(pe), this.negative = 1, this) : this._iaddn(pe);
      }, W.prototype._iaddn = function(pe) {
        this.words[0] += pe;
        for (var nt = 0; nt < this.length && this.words[nt] >= 67108864; nt++)
          this.words[nt] -= 67108864, nt === this.length - 1 ? this.words[nt + 1] = 1 : this.words[nt + 1]++;
        return this.length = Math.max(this.length, nt + 1), this;
      }, W.prototype.isubn = function(pe) {
        if (K(typeof pe == "number"), K(pe < 67108864), pe < 0) return this.iaddn(-pe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(pe), this.negative = 1, this;
        if (this.words[0] -= pe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var nt = 0; nt < this.length && this.words[nt] < 0; nt++)
            this.words[nt] += 67108864, this.words[nt + 1] -= 1;
        return this._strip();
      }, W.prototype.addn = function(pe) {
        return this.clone().iaddn(pe);
      }, W.prototype.subn = function(pe) {
        return this.clone().isubn(pe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(pe, nt, st) {
        var ft = pe.length + st, ht;
        this._expand(ft);
        var bt, ut = 0;
        for (ht = 0; ht < pe.length; ht++) {
          bt = (this.words[ht + st] | 0) + ut;
          var gt = (pe.words[ht] | 0) * nt;
          bt -= gt & 67108863, ut = (bt >> 26) - (gt / 67108864 | 0), this.words[ht + st] = bt & 67108863;
        }
        for (; ht < this.length - st; ht++)
          bt = (this.words[ht + st] | 0) + ut, ut = bt >> 26, this.words[ht + st] = bt & 67108863;
        if (ut === 0) return this._strip();
        for (K(ut === -1), ut = 0, ht = 0; ht < this.length; ht++)
          bt = -(this.words[ht] | 0) + ut, ut = bt >> 26, this.words[ht] = bt & 67108863;
        return this.negative = 1, this._strip();
      }, W.prototype._wordDiv = function(pe, nt) {
        var st = this.length - pe.length, ft = this.clone(), ht = pe, bt = ht.words[ht.length - 1] | 0, ut = this._countBits(bt);
        st = 26 - ut, st !== 0 && (ht = ht.ushln(st), ft.iushln(st), bt = ht.words[ht.length - 1] | 0);
        var gt = ft.length - ht.length, lt;
        if (nt !== "mod") {
          lt = new W(null), lt.length = gt + 1, lt.words = new Array(lt.length);
          for (var $t = 0; $t < lt.length; $t++)
            lt.words[$t] = 0;
        }
        var jt = ft.clone()._ishlnsubmul(ht, 1, gt);
        jt.negative === 0 && (ft = jt, lt && (lt.words[gt] = 1));
        for (var Jt = gt - 1; Jt >= 0; Jt--) {
          var Lt = (ft.words[ht.length + Jt] | 0) * 67108864 + (ft.words[ht.length + Jt - 1] | 0);
          for (Lt = Math.min(Lt / bt | 0, 67108863), ft._ishlnsubmul(ht, Lt, Jt); ft.negative !== 0; )
            Lt--, ft.negative = 0, ft._ishlnsubmul(ht, 1, Jt), ft.isZero() || (ft.negative ^= 1);
          lt && (lt.words[Jt] = Lt);
        }
        return lt && lt._strip(), ft._strip(), nt !== "div" && st !== 0 && ft.iushrn(st), {
          div: lt || null,
          mod: ft
        };
      }, W.prototype.divmod = function(pe, nt, st) {
        if (K(!pe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var ft, ht, bt;
        return this.negative !== 0 && pe.negative === 0 ? (bt = this.neg().divmod(pe, nt), nt !== "mod" && (ft = bt.div.neg()), nt !== "div" && (ht = bt.mod.neg(), st && ht.negative !== 0 && ht.iadd(pe)), {
          div: ft,
          mod: ht
        }) : this.negative === 0 && pe.negative !== 0 ? (bt = this.divmod(pe.neg(), nt), nt !== "mod" && (ft = bt.div.neg()), {
          div: ft,
          mod: bt.mod
        }) : this.negative & pe.negative ? (bt = this.neg().divmod(pe.neg(), nt), nt !== "div" && (ht = bt.mod.neg(), st && ht.negative !== 0 && ht.isub(pe)), {
          div: bt.div,
          mod: ht
        }) : pe.length > this.length || this.cmp(pe) < 0 ? {
          div: new W(0),
          mod: this
        } : pe.length === 1 ? nt === "div" ? {
          div: this.divn(pe.words[0]),
          mod: null
        } : nt === "mod" ? {
          div: null,
          mod: new W(this.modrn(pe.words[0]))
        } : {
          div: this.divn(pe.words[0]),
          mod: new W(this.modrn(pe.words[0]))
        } : this._wordDiv(pe, nt);
      }, W.prototype.div = function(pe) {
        return this.divmod(pe, "div", !1).div;
      }, W.prototype.mod = function(pe) {
        return this.divmod(pe, "mod", !1).mod;
      }, W.prototype.umod = function(pe) {
        return this.divmod(pe, "mod", !0).mod;
      }, W.prototype.divRound = function(pe) {
        var nt = this.divmod(pe);
        if (nt.mod.isZero()) return nt.div;
        var st = nt.div.negative !== 0 ? nt.mod.isub(pe) : nt.mod, ft = pe.ushrn(1), ht = pe.andln(1), bt = st.cmp(ft);
        return bt < 0 || ht === 1 && bt === 0 ? nt.div : nt.div.negative !== 0 ? nt.div.isubn(1) : nt.div.iaddn(1);
      }, W.prototype.modrn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var st = (1 << 26) % pe, ft = 0, ht = this.length - 1; ht >= 0; ht--)
          ft = (st * ft + (this.words[ht] | 0)) % pe;
        return nt ? -ft : ft;
      }, W.prototype.modn = function(pe) {
        return this.modrn(pe);
      }, W.prototype.idivn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var st = 0, ft = this.length - 1; ft >= 0; ft--) {
          var ht = (this.words[ft] | 0) + st * 67108864;
          this.words[ft] = ht / pe | 0, st = ht % pe;
        }
        return this._strip(), nt ? this.ineg() : this;
      }, W.prototype.divn = function(pe) {
        return this.clone().idivn(pe);
      }, W.prototype.egcd = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, st = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var ft = new W(1), ht = new W(0), bt = new W(0), ut = new W(1), gt = 0; nt.isEven() && st.isEven(); )
          nt.iushrn(1), st.iushrn(1), ++gt;
        for (var lt = st.clone(), $t = nt.clone(); !nt.isZero(); ) {
          for (var jt = 0, Jt = 1; !(nt.words[0] & Jt) && jt < 26; ++jt, Jt <<= 1) ;
          if (jt > 0)
            for (nt.iushrn(jt); jt-- > 0; )
              (ft.isOdd() || ht.isOdd()) && (ft.iadd(lt), ht.isub($t)), ft.iushrn(1), ht.iushrn(1);
          for (var Lt = 0, Rt = 1; !(st.words[0] & Rt) && Lt < 26; ++Lt, Rt <<= 1) ;
          if (Lt > 0)
            for (st.iushrn(Lt); Lt-- > 0; )
              (bt.isOdd() || ut.isOdd()) && (bt.iadd(lt), ut.isub($t)), bt.iushrn(1), ut.iushrn(1);
          nt.cmp(st) >= 0 ? (nt.isub(st), ft.isub(bt), ht.isub(ut)) : (st.isub(nt), bt.isub(ft), ut.isub(ht));
        }
        return {
          a: bt,
          b: ut,
          gcd: st.iushln(gt)
        };
      }, W.prototype._invmp = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, st = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var ft = new W(1), ht = new W(0), bt = st.clone(); nt.cmpn(1) > 0 && st.cmpn(1) > 0; ) {
          for (var ut = 0, gt = 1; !(nt.words[0] & gt) && ut < 26; ++ut, gt <<= 1) ;
          if (ut > 0)
            for (nt.iushrn(ut); ut-- > 0; )
              ft.isOdd() && ft.iadd(bt), ft.iushrn(1);
          for (var lt = 0, $t = 1; !(st.words[0] & $t) && lt < 26; ++lt, $t <<= 1) ;
          if (lt > 0)
            for (st.iushrn(lt); lt-- > 0; )
              ht.isOdd() && ht.iadd(bt), ht.iushrn(1);
          nt.cmp(st) >= 0 ? (nt.isub(st), ft.isub(ht)) : (st.isub(nt), ht.isub(ft));
        }
        var jt;
        return nt.cmpn(1) === 0 ? jt = ft : jt = ht, jt.cmpn(0) < 0 && jt.iadd(pe), jt;
      }, W.prototype.gcd = function(pe) {
        if (this.isZero()) return pe.abs();
        if (pe.isZero()) return this.abs();
        var nt = this.clone(), st = pe.clone();
        nt.negative = 0, st.negative = 0;
        for (var ft = 0; nt.isEven() && st.isEven(); ft++)
          nt.iushrn(1), st.iushrn(1);
        do {
          for (; nt.isEven(); )
            nt.iushrn(1);
          for (; st.isEven(); )
            st.iushrn(1);
          var ht = nt.cmp(st);
          if (ht < 0) {
            var bt = nt;
            nt = st, st = bt;
          } else if (ht === 0 || st.cmpn(1) === 0)
            break;
          nt.isub(st);
        } while (!0);
        return st.iushln(ft);
      }, W.prototype.invm = function(pe) {
        return this.egcd(pe).a.umod(pe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(pe) {
        return this.words[0] & pe;
      }, W.prototype.bincn = function(pe) {
        K(typeof pe == "number");
        var nt = pe % 26, st = (pe - nt) / 26, ft = 1 << nt;
        if (this.length <= st)
          return this._expand(st + 1), this.words[st] |= ft, this;
        for (var ht = ft, bt = st; ht !== 0 && bt < this.length; bt++) {
          var ut = this.words[bt] | 0;
          ut += ht, ht = ut >>> 26, ut &= 67108863, this.words[bt] = ut;
        }
        return ht !== 0 && (this.words[bt] = ht, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(pe) {
        var nt = pe < 0;
        if (this.negative !== 0 && !nt) return -1;
        if (this.negative === 0 && nt) return 1;
        this._strip();
        var st;
        if (this.length > 1)
          st = 1;
        else {
          nt && (pe = -pe), K(pe <= 67108863, "Number is too big");
          var ft = this.words[0] | 0;
          st = ft === pe ? 0 : ft < pe ? -1 : 1;
        }
        return this.negative !== 0 ? -st | 0 : st;
      }, W.prototype.cmp = function(pe) {
        if (this.negative !== 0 && pe.negative === 0) return -1;
        if (this.negative === 0 && pe.negative !== 0) return 1;
        var nt = this.ucmp(pe);
        return this.negative !== 0 ? -nt | 0 : nt;
      }, W.prototype.ucmp = function(pe) {
        if (this.length > pe.length) return 1;
        if (this.length < pe.length) return -1;
        for (var nt = 0, st = this.length - 1; st >= 0; st--) {
          var ft = this.words[st] | 0, ht = pe.words[st] | 0;
          if (ft !== ht) {
            ft < ht ? nt = -1 : ft > ht && (nt = 1);
            break;
          }
        }
        return nt;
      }, W.prototype.gtn = function(pe) {
        return this.cmpn(pe) === 1;
      }, W.prototype.gt = function(pe) {
        return this.cmp(pe) === 1;
      }, W.prototype.gten = function(pe) {
        return this.cmpn(pe) >= 0;
      }, W.prototype.gte = function(pe) {
        return this.cmp(pe) >= 0;
      }, W.prototype.ltn = function(pe) {
        return this.cmpn(pe) === -1;
      }, W.prototype.lt = function(pe) {
        return this.cmp(pe) === -1;
      }, W.prototype.lten = function(pe) {
        return this.cmpn(pe) <= 0;
      }, W.prototype.lte = function(pe) {
        return this.cmp(pe) <= 0;
      }, W.prototype.eqn = function(pe) {
        return this.cmpn(pe) === 0;
      }, W.prototype.eq = function(pe) {
        return this.cmp(pe) === 0;
      }, W.red = function(pe) {
        return new wt(pe);
      }, W.prototype.toRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), pe.convertTo(this)._forceRed(pe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(pe) {
        return this.red = pe, this;
      }, W.prototype.forceRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(pe);
      }, W.prototype.redAdd = function(pe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, pe);
      }, W.prototype.redIAdd = function(pe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, pe);
      }, W.prototype.redSub = function(pe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, pe);
      }, W.prototype.redISub = function(pe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, pe);
      }, W.prototype.redShl = function(pe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, pe);
      }, W.prototype.redMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.mul(this, pe);
      }, W.prototype.redIMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.imul(this, pe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(pe) {
        return K(this.red && !pe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, pe);
      };
      var Tt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Pt(rt, pe) {
        this.name = rt, this.p = new W(pe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Pt.prototype._tmp = function() {
        var pe = new W(null);
        return pe.words = new Array(Math.ceil(this.n / 13)), pe;
      }, Pt.prototype.ireduce = function(pe) {
        var nt = pe, st;
        do
          this.split(nt, this.tmp), nt = this.imulK(nt), nt = nt.iadd(this.tmp), st = nt.bitLength();
        while (st > this.n);
        var ft = st < this.n ? -1 : nt.ucmp(this.p);
        return ft === 0 ? (nt.words[0] = 0, nt.length = 1) : ft > 0 ? nt.isub(this.p) : nt.strip !== void 0 ? nt.strip() : nt._strip(), nt;
      }, Pt.prototype.split = function(pe, nt) {
        pe.iushrn(this.n, 0, nt);
      }, Pt.prototype.imulK = function(pe) {
        return pe.imul(this.k);
      };
      function Nt() {
        Pt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      V(Nt, Pt), Nt.prototype.split = function(pe, nt) {
        for (var st = 4194303, ft = Math.min(pe.length, 9), ht = 0; ht < ft; ht++)
          nt.words[ht] = pe.words[ht];
        if (nt.length = ft, pe.length <= 9) {
          pe.words[0] = 0, pe.length = 1;
          return;
        }
        var bt = pe.words[9];
        for (nt.words[nt.length++] = bt & st, ht = 10; ht < pe.length; ht++) {
          var ut = pe.words[ht] | 0;
          pe.words[ht - 10] = (ut & st) << 4 | bt >>> 22, bt = ut;
        }
        bt >>>= 22, pe.words[ht - 10] = bt, bt === 0 && pe.length > 10 ? pe.length -= 10 : pe.length -= 9;
      }, Nt.prototype.imulK = function(pe) {
        pe.words[pe.length] = 0, pe.words[pe.length + 1] = 0, pe.length += 2;
        for (var nt = 0, st = 0; st < pe.length; st++) {
          var ft = pe.words[st] | 0;
          nt += ft * 977, pe.words[st] = nt & 67108863, nt = ft * 64 + (nt / 67108864 | 0);
        }
        return pe.words[pe.length - 1] === 0 && (pe.length--, pe.words[pe.length - 1] === 0 && pe.length--), pe;
      };
      function St() {
        Pt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      V(St, Pt);
      function vt() {
        Pt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      V(vt, Pt);
      function It() {
        Pt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      V(It, Pt), It.prototype.imulK = function(pe) {
        for (var nt = 0, st = 0; st < pe.length; st++) {
          var ft = (pe.words[st] | 0) * 19 + nt, ht = ft & 67108863;
          ft >>>= 26, pe.words[st] = ht, nt = ft;
        }
        return nt !== 0 && (pe.words[pe.length++] = nt), pe;
      }, W._prime = function(pe) {
        if (Tt[pe]) return Tt[pe];
        var nt;
        if (pe === "k256")
          nt = new Nt();
        else if (pe === "p224")
          nt = new St();
        else if (pe === "p192")
          nt = new vt();
        else if (pe === "p25519")
          nt = new It();
        else
          throw new Error("Unknown prime " + pe);
        return Tt[pe] = nt, nt;
      };
      function wt(rt) {
        if (typeof rt == "string") {
          var pe = W._prime(rt);
          this.m = pe.p, this.prime = pe;
        } else
          K(rt.gtn(1), "modulus must be greater than 1"), this.m = rt, this.prime = null;
      }
      wt.prototype._verify1 = function(pe) {
        K(pe.negative === 0, "red works only with positives"), K(pe.red, "red works only with red numbers");
      }, wt.prototype._verify2 = function(pe, nt) {
        K((pe.negative | nt.negative) === 0, "red works only with positives"), K(
          pe.red && pe.red === nt.red,
          "red works only with red numbers"
        );
      }, wt.prototype.imod = function(pe) {
        return this.prime ? this.prime.ireduce(pe)._forceRed(this) : (re(pe, pe.umod(this.m)._forceRed(this)), pe);
      }, wt.prototype.neg = function(pe) {
        return pe.isZero() ? pe.clone() : this.m.sub(pe)._forceRed(this);
      }, wt.prototype.add = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.add(nt);
        return st.cmp(this.m) >= 0 && st.isub(this.m), st._forceRed(this);
      }, wt.prototype.iadd = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.iadd(nt);
        return st.cmp(this.m) >= 0 && st.isub(this.m), st;
      }, wt.prototype.sub = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.sub(nt);
        return st.cmpn(0) < 0 && st.iadd(this.m), st._forceRed(this);
      }, wt.prototype.isub = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.isub(nt);
        return st.cmpn(0) < 0 && st.iadd(this.m), st;
      }, wt.prototype.shl = function(pe, nt) {
        return this._verify1(pe), this.imod(pe.ushln(nt));
      }, wt.prototype.imul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.imul(nt));
      }, wt.prototype.mul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.mul(nt));
      }, wt.prototype.isqr = function(pe) {
        return this.imul(pe, pe.clone());
      }, wt.prototype.sqr = function(pe) {
        return this.mul(pe, pe);
      }, wt.prototype.sqrt = function(pe) {
        if (pe.isZero()) return pe.clone();
        var nt = this.m.andln(3);
        if (K(nt % 2 === 1), nt === 3) {
          var st = this.m.add(new W(1)).iushrn(2);
          return this.pow(pe, st);
        }
        for (var ft = this.m.subn(1), ht = 0; !ft.isZero() && ft.andln(1) === 0; )
          ht++, ft.iushrn(1);
        K(!ft.isZero());
        var bt = new W(1).toRed(this), ut = bt.redNeg(), gt = this.m.subn(1).iushrn(1), lt = this.m.bitLength();
        for (lt = new W(2 * lt * lt).toRed(this); this.pow(lt, gt).cmp(ut) !== 0; )
          lt.redIAdd(ut);
        for (var $t = this.pow(lt, ft), jt = this.pow(pe, ft.addn(1).iushrn(1)), Jt = this.pow(pe, ft), Lt = ht; Jt.cmp(bt) !== 0; ) {
          for (var Rt = Jt, Mt = 0; Rt.cmp(bt) !== 0; Mt++)
            Rt = Rt.redSqr();
          K(Mt < Lt);
          var Kt = this.pow($t, new W(1).iushln(Lt - Mt - 1));
          jt = jt.redMul(Kt), $t = Kt.redSqr(), Jt = Jt.redMul($t), Lt = Mt;
        }
        return jt;
      }, wt.prototype.invm = function(pe) {
        var nt = pe._invmp(this.m);
        return nt.negative !== 0 ? (nt.negative = 0, this.imod(nt).redNeg()) : this.imod(nt);
      }, wt.prototype.pow = function(pe, nt) {
        if (nt.isZero()) return new W(1).toRed(this);
        if (nt.cmpn(1) === 0) return pe.clone();
        var st = 4, ft = new Array(1 << st);
        ft[0] = new W(1).toRed(this), ft[1] = pe;
        for (var ht = 2; ht < ft.length; ht++)
          ft[ht] = this.mul(ft[ht - 1], pe);
        var bt = ft[0], ut = 0, gt = 0, lt = nt.bitLength() % 26;
        for (lt === 0 && (lt = 26), ht = nt.length - 1; ht >= 0; ht--) {
          for (var $t = nt.words[ht], jt = lt - 1; jt >= 0; jt--) {
            var Jt = $t >> jt & 1;
            if (bt !== ft[0] && (bt = this.sqr(bt)), Jt === 0 && ut === 0) {
              gt = 0;
              continue;
            }
            ut <<= 1, ut |= Jt, gt++, !(gt !== st && (ht !== 0 || jt !== 0)) && (bt = this.mul(bt, ft[ut]), gt = 0, ut = 0);
          }
          lt = 26;
        }
        return bt;
      }, wt.prototype.convertTo = function(pe) {
        var nt = pe.umod(this.m);
        return nt === pe ? nt.clone() : nt;
      }, wt.prototype.convertFrom = function(pe) {
        var nt = pe.clone();
        return nt.red = null, nt;
      }, W.mont = function(pe) {
        return new Oe(pe);
      };
      function Oe(rt) {
        wt.call(this, rt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      V(Oe, wt), Oe.prototype.convertTo = function(pe) {
        return this.imod(pe.ushln(this.shift));
      }, Oe.prototype.convertFrom = function(pe) {
        var nt = this.imod(pe.mul(this.rinv));
        return nt.red = null, nt;
      }, Oe.prototype.imul = function(pe, nt) {
        if (pe.isZero() || nt.isZero())
          return pe.words[0] = 0, pe.length = 1, pe;
        var st = pe.imul(nt), ft = st.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = st.isub(ft).iushrn(this.shift), bt = ht;
        return ht.cmp(this.m) >= 0 ? bt = ht.isub(this.m) : ht.cmpn(0) < 0 && (bt = ht.iadd(this.m)), bt._forceRed(this);
      }, Oe.prototype.mul = function(pe, nt) {
        if (pe.isZero() || nt.isZero()) return new W(0)._forceRed(this);
        var st = pe.mul(nt), ft = st.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = st.isub(ft).iushrn(this.shift), bt = ht;
        return ht.cmp(this.m) >= 0 ? bt = ht.isub(this.m) : ht.cmpn(0) < 0 && (bt = ht.iadd(this.m)), bt._forceRed(this);
      }, Oe.prototype.invm = function(pe) {
        var nt = this.imod(pe._invmp(this.m).mul(this.r2));
        return nt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var A = requireBn(), B = requireBrowser$b(), L = safeBufferExports.Buffer;
  function K(J) {
    var ne = J.modulus.byteLength(), ie;
    do
      ie = new A(B(ne));
    while (ie.cmp(J.modulus) >= 0 || !ie.umod(J.prime1) || !ie.umod(J.prime2));
    return ie;
  }
  function V(J) {
    var ne = K(J), ie = ne.toRed(A.mont(J.modulus)).redPow(new A(J.publicExponent)).fromRed();
    return { blinder: ie, unblinder: ne.invm(J.modulus) };
  }
  function W(J, ne) {
    var ie = V(ne), ce = ne.modulus.byteLength(), re = new A(J).mul(ie.blinder).umod(ne.modulus), oe = re.toRed(A.mont(ne.prime1)), ke = re.toRed(A.mont(ne.prime2)), Ce = ne.coefficient, it = ne.prime1, at = ne.prime2, ct = oe.redPow(ne.exponent1).fromRed(), dt = ke.redPow(ne.exponent2).fromRed(), ot = ct.isub(dt).imul(Ce).umod(it).imul(at);
    return dt.iadd(ot).imul(ie.unblinder).umod(ne.modulus).toArrayLike(L, "be", ce);
  }
  return W.getr = K, browserifyRsa = W, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(A) {
    var B = A;
    function L(W, J) {
      if (Array.isArray(W))
        return W.slice();
      if (!W)
        return [];
      var ne = [];
      if (typeof W != "string") {
        for (var ie = 0; ie < W.length; ie++)
          ne[ie] = W[ie] | 0;
        return ne;
      }
      if (J === "hex") {
        W = W.replace(/[^a-z0-9]+/ig, ""), W.length % 2 !== 0 && (W = "0" + W);
        for (var ie = 0; ie < W.length; ie += 2)
          ne.push(parseInt(W[ie] + W[ie + 1], 16));
      } else
        for (var ie = 0; ie < W.length; ie++) {
          var ce = W.charCodeAt(ie), re = ce >> 8, oe = ce & 255;
          re ? ne.push(re, oe) : ne.push(oe);
        }
      return ne;
    }
    B.toArray = L;
    function K(W) {
      return W.length === 1 ? "0" + W : W;
    }
    B.zero2 = K;
    function V(W) {
      for (var J = "", ne = 0; ne < W.length; ne++)
        J += K(W[ne].toString(16));
      return J;
    }
    B.toHex = V, B.encode = function(J, ne) {
      return ne === "hex" ? V(J) : J;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(A) {
    var B = A, L = requireBn$1(), K = requireMinimalisticAssert(), V = requireUtils$2();
    B.assert = K, B.toArray = V.toArray, B.zero2 = V.zero2, B.toHex = V.toHex, B.encode = V.encode;
    function W(re, oe, ke) {
      var Ce = new Array(Math.max(re.bitLength(), ke) + 1), it;
      for (it = 0; it < Ce.length; it += 1)
        Ce[it] = 0;
      var at = 1 << oe + 1, ct = re.clone();
      for (it = 0; it < Ce.length; it++) {
        var dt, ot = ct.andln(at - 1);
        ct.isOdd() ? (ot > (at >> 1) - 1 ? dt = (at >> 1) - ot : dt = ot, ct.isubn(dt)) : dt = 0, Ce[it] = dt, ct.iushrn(1);
      }
      return Ce;
    }
    B.getNAF = W;
    function J(re, oe) {
      var ke = [
        [],
        []
      ];
      re = re.clone(), oe = oe.clone();
      for (var Ce = 0, it = 0, at; re.cmpn(-Ce) > 0 || oe.cmpn(-it) > 0; ) {
        var ct = re.andln(3) + Ce & 3, dt = oe.andln(3) + it & 3;
        ct === 3 && (ct = -1), dt === 3 && (dt = -1);
        var ot;
        ct & 1 ? (at = re.andln(7) + Ce & 7, (at === 3 || at === 5) && dt === 2 ? ot = -ct : ot = ct) : ot = 0, ke[0].push(ot);
        var yt;
        dt & 1 ? (at = oe.andln(7) + it & 7, (at === 3 || at === 5) && ct === 2 ? yt = -dt : yt = dt) : yt = 0, ke[1].push(yt), 2 * Ce === ot + 1 && (Ce = 1 - Ce), 2 * it === yt + 1 && (it = 1 - it), re.iushrn(1), oe.iushrn(1);
      }
      return ke;
    }
    B.getJSF = J;
    function ne(re, oe, ke) {
      var Ce = "_" + oe;
      re.prototype[oe] = function() {
        return this[Ce] !== void 0 ? this[Ce] : this[Ce] = ke.call(this);
      };
    }
    B.cachedProperty = ne;
    function ie(re) {
      return typeof re == "string" ? B.toArray(re, "hex") : re;
    }
    B.parseBytes = ie;
    function ce(re) {
      return new L(re, "hex", "le");
    }
    B.intFromLE = ce;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.getNAF, K = B.getJSF, V = B.assert;
  function W(ne, ie) {
    this.type = ne, this.p = new A(ie.p, 16), this.red = ie.prime ? A.red(ie.prime) : A.mont(this.p), this.zero = new A(0).toRed(this.red), this.one = new A(1).toRed(this.red), this.two = new A(2).toRed(this.red), this.n = ie.n && new A(ie.n, 16), this.g = ie.g && this.pointFromJSON(ie.g, ie.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var ce = this.n && this.p.div(this.n);
    !ce || ce.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = W, W.prototype.point = function() {
    throw new Error("Not implemented");
  }, W.prototype.validate = function() {
    throw new Error("Not implemented");
  }, W.prototype._fixedNafMul = function(ie, ce) {
    V(ie.precomputed);
    var re = ie._getDoubles(), oe = L(ce, 1, this._bitLength), ke = (1 << re.step + 1) - (re.step % 2 === 0 ? 2 : 1);
    ke /= 3;
    var Ce = [], it, at;
    for (it = 0; it < oe.length; it += re.step) {
      at = 0;
      for (var ct = it + re.step - 1; ct >= it; ct--)
        at = (at << 1) + oe[ct];
      Ce.push(at);
    }
    for (var dt = this.jpoint(null, null, null), ot = this.jpoint(null, null, null), yt = ke; yt > 0; yt--) {
      for (it = 0; it < Ce.length; it++)
        at = Ce[it], at === yt ? ot = ot.mixedAdd(re.points[it]) : at === -yt && (ot = ot.mixedAdd(re.points[it].neg()));
      dt = dt.add(ot);
    }
    return dt.toP();
  }, W.prototype._wnafMul = function(ie, ce) {
    var re = 4, oe = ie._getNAFPoints(re);
    re = oe.wnd;
    for (var ke = oe.points, Ce = L(ce, re, this._bitLength), it = this.jpoint(null, null, null), at = Ce.length - 1; at >= 0; at--) {
      for (var ct = 0; at >= 0 && Ce[at] === 0; at--)
        ct++;
      if (at >= 0 && ct++, it = it.dblp(ct), at < 0)
        break;
      var dt = Ce[at];
      V(dt !== 0), ie.type === "affine" ? dt > 0 ? it = it.mixedAdd(ke[dt - 1 >> 1]) : it = it.mixedAdd(ke[-dt - 1 >> 1].neg()) : dt > 0 ? it = it.add(ke[dt - 1 >> 1]) : it = it.add(ke[-dt - 1 >> 1].neg());
    }
    return ie.type === "affine" ? it.toP() : it;
  }, W.prototype._wnafMulAdd = function(ie, ce, re, oe, ke) {
    var Ce = this._wnafT1, it = this._wnafT2, at = this._wnafT3, ct = 0, dt, ot, yt;
    for (dt = 0; dt < oe; dt++) {
      yt = ce[dt];
      var mt = yt._getNAFPoints(ie);
      Ce[dt] = mt.wnd, it[dt] = mt.points;
    }
    for (dt = oe - 1; dt >= 1; dt -= 2) {
      var Tt = dt - 1, Pt = dt;
      if (Ce[Tt] !== 1 || Ce[Pt] !== 1) {
        at[Tt] = L(re[Tt], Ce[Tt], this._bitLength), at[Pt] = L(re[Pt], Ce[Pt], this._bitLength), ct = Math.max(at[Tt].length, ct), ct = Math.max(at[Pt].length, ct);
        continue;
      }
      var Nt = [
        ce[Tt],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        ce[Pt]
        /* 7 */
      ];
      ce[Tt].y.cmp(ce[Pt].y) === 0 ? (Nt[1] = ce[Tt].add(ce[Pt]), Nt[2] = ce[Tt].toJ().mixedAdd(ce[Pt].neg())) : ce[Tt].y.cmp(ce[Pt].y.redNeg()) === 0 ? (Nt[1] = ce[Tt].toJ().mixedAdd(ce[Pt]), Nt[2] = ce[Tt].add(ce[Pt].neg())) : (Nt[1] = ce[Tt].toJ().mixedAdd(ce[Pt]), Nt[2] = ce[Tt].toJ().mixedAdd(ce[Pt].neg()));
      var St = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], vt = K(re[Tt], re[Pt]);
      for (ct = Math.max(vt[0].length, ct), at[Tt] = new Array(ct), at[Pt] = new Array(ct), ot = 0; ot < ct; ot++) {
        var It = vt[0][ot] | 0, wt = vt[1][ot] | 0;
        at[Tt][ot] = St[(It + 1) * 3 + (wt + 1)], at[Pt][ot] = 0, it[Tt] = Nt;
      }
    }
    var Oe = this.jpoint(null, null, null), rt = this._wnafT4;
    for (dt = ct; dt >= 0; dt--) {
      for (var pe = 0; dt >= 0; ) {
        var nt = !0;
        for (ot = 0; ot < oe; ot++)
          rt[ot] = at[ot][dt] | 0, rt[ot] !== 0 && (nt = !1);
        if (!nt)
          break;
        pe++, dt--;
      }
      if (dt >= 0 && pe++, Oe = Oe.dblp(pe), dt < 0)
        break;
      for (ot = 0; ot < oe; ot++) {
        var st = rt[ot];
        st !== 0 && (st > 0 ? yt = it[ot][st - 1 >> 1] : st < 0 && (yt = it[ot][-st - 1 >> 1].neg()), yt.type === "affine" ? Oe = Oe.mixedAdd(yt) : Oe = Oe.add(yt));
      }
    }
    for (dt = 0; dt < oe; dt++)
      it[dt] = null;
    return ke ? Oe : Oe.toP();
  };
  function J(ne, ie) {
    this.curve = ne, this.type = ie, this.precomputed = null;
  }
  return W.BasePoint = J, J.prototype.eq = function() {
    throw new Error("Not implemented");
  }, J.prototype.validate = function() {
    return this.curve.validate(this);
  }, W.prototype.decodePoint = function(ie, ce) {
    ie = B.toArray(ie, ce);
    var re = this.p.byteLength();
    if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 === 2 * re) {
      ie[0] === 6 ? V(ie[ie.length - 1] % 2 === 0) : ie[0] === 7 && V(ie[ie.length - 1] % 2 === 1);
      var oe = this.point(
        ie.slice(1, 1 + re),
        ie.slice(1 + re, 1 + 2 * re)
      );
      return oe;
    } else if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === re)
      return this.pointFromX(ie.slice(1, 1 + re), ie[0] === 3);
    throw new Error("Unknown point format");
  }, J.prototype.encodeCompressed = function(ie) {
    return this.encode(ie, !0);
  }, J.prototype._encode = function(ie) {
    var ce = this.curve.p.byteLength(), re = this.getX().toArray("be", ce);
    return ie ? [this.getY().isEven() ? 2 : 3].concat(re) : [4].concat(re, this.getY().toArray("be", ce));
  }, J.prototype.encode = function(ie, ce) {
    return B.encode(this._encode(ce), ie);
  }, J.prototype.precompute = function(ie) {
    if (this.precomputed)
      return this;
    var ce = {
      doubles: null,
      naf: null,
      beta: null
    };
    return ce.naf = this._getNAFPoints(8), ce.doubles = this._getDoubles(4, ie), ce.beta = this._getBeta(), this.precomputed = ce, this;
  }, J.prototype._hasDoubles = function(ie) {
    if (!this.precomputed)
      return !1;
    var ce = this.precomputed.doubles;
    return ce ? ce.points.length >= Math.ceil((ie.bitLength() + 1) / ce.step) : !1;
  }, J.prototype._getDoubles = function(ie, ce) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var re = [this], oe = this, ke = 0; ke < ce; ke += ie) {
      for (var Ce = 0; Ce < ie; Ce++)
        oe = oe.dbl();
      re.push(oe);
    }
    return {
      step: ie,
      points: re
    };
  }, J.prototype._getNAFPoints = function(ie) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var ce = [this], re = (1 << ie) - 1, oe = re === 1 ? null : this.dbl(), ke = 1; ke < re; ke++)
      ce[ke] = ce[ke - 1].add(oe);
    return {
      wnd: ie,
      points: ce
    };
  }, J.prototype._getBeta = function() {
    return null;
  }, J.prototype.dblp = function(ie) {
    for (var ce = this, re = 0; re < ie; re++)
      ce = ce.dbl();
    return ce;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), V = A.assert;
  function W(ie) {
    K.call(this, "short", ie), this.a = new B(ie.a, 16).toRed(this.red), this.b = new B(ie.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ie), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  L(W, K), short = W, W.prototype._getEndomorphism = function(ce) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var re, oe;
      if (ce.beta)
        re = new B(ce.beta, 16).toRed(this.red);
      else {
        var ke = this._getEndoRoots(this.p);
        re = ke[0].cmp(ke[1]) < 0 ? ke[0] : ke[1], re = re.toRed(this.red);
      }
      if (ce.lambda)
        oe = new B(ce.lambda, 16);
      else {
        var Ce = this._getEndoRoots(this.n);
        this.g.mul(Ce[0]).x.cmp(this.g.x.redMul(re)) === 0 ? oe = Ce[0] : (oe = Ce[1], V(this.g.mul(oe).x.cmp(this.g.x.redMul(re)) === 0));
      }
      var it;
      return ce.basis ? it = ce.basis.map(function(at) {
        return {
          a: new B(at.a, 16),
          b: new B(at.b, 16)
        };
      }) : it = this._getEndoBasis(oe), {
        beta: re,
        lambda: oe,
        basis: it
      };
    }
  }, W.prototype._getEndoRoots = function(ce) {
    var re = ce === this.p ? this.red : B.mont(ce), oe = new B(2).toRed(re).redInvm(), ke = oe.redNeg(), Ce = new B(3).toRed(re).redNeg().redSqrt().redMul(oe), it = ke.redAdd(Ce).fromRed(), at = ke.redSub(Ce).fromRed();
    return [it, at];
  }, W.prototype._getEndoBasis = function(ce) {
    for (var re = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), oe = ce, ke = this.n.clone(), Ce = new B(1), it = new B(0), at = new B(0), ct = new B(1), dt, ot, yt, mt, Tt, Pt, Nt, St = 0, vt, It; oe.cmpn(0) !== 0; ) {
      var wt = ke.div(oe);
      vt = ke.sub(wt.mul(oe)), It = at.sub(wt.mul(Ce));
      var Oe = ct.sub(wt.mul(it));
      if (!yt && vt.cmp(re) < 0)
        dt = Nt.neg(), ot = Ce, yt = vt.neg(), mt = It;
      else if (yt && ++St === 2)
        break;
      Nt = vt, ke = oe, oe = vt, at = Ce, Ce = It, ct = it, it = Oe;
    }
    Tt = vt.neg(), Pt = It;
    var rt = yt.sqr().add(mt.sqr()), pe = Tt.sqr().add(Pt.sqr());
    return pe.cmp(rt) >= 0 && (Tt = dt, Pt = ot), yt.negative && (yt = yt.neg(), mt = mt.neg()), Tt.negative && (Tt = Tt.neg(), Pt = Pt.neg()), [
      { a: yt, b: mt },
      { a: Tt, b: Pt }
    ];
  }, W.prototype._endoSplit = function(ce) {
    var re = this.endo.basis, oe = re[0], ke = re[1], Ce = ke.b.mul(ce).divRound(this.n), it = oe.b.neg().mul(ce).divRound(this.n), at = Ce.mul(oe.a), ct = it.mul(ke.a), dt = Ce.mul(oe.b), ot = it.mul(ke.b), yt = ce.sub(at).sub(ct), mt = dt.add(ot).neg();
    return { k1: yt, k2: mt };
  }, W.prototype.pointFromX = function(ce, re) {
    ce = new B(ce, 16), ce.red || (ce = ce.toRed(this.red));
    var oe = ce.redSqr().redMul(ce).redIAdd(ce.redMul(this.a)).redIAdd(this.b), ke = oe.redSqrt();
    if (ke.redSqr().redSub(oe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Ce = ke.fromRed().isOdd();
    return (re && !Ce || !re && Ce) && (ke = ke.redNeg()), this.point(ce, ke);
  }, W.prototype.validate = function(ce) {
    if (ce.inf)
      return !0;
    var re = ce.x, oe = ce.y, ke = this.a.redMul(re), Ce = re.redSqr().redMul(re).redIAdd(ke).redIAdd(this.b);
    return oe.redSqr().redISub(Ce).cmpn(0) === 0;
  }, W.prototype._endoWnafMulAdd = function(ce, re, oe) {
    for (var ke = this._endoWnafT1, Ce = this._endoWnafT2, it = 0; it < ce.length; it++) {
      var at = this._endoSplit(re[it]), ct = ce[it], dt = ct._getBeta();
      at.k1.negative && (at.k1.ineg(), ct = ct.neg(!0)), at.k2.negative && (at.k2.ineg(), dt = dt.neg(!0)), ke[it * 2] = ct, ke[it * 2 + 1] = dt, Ce[it * 2] = at.k1, Ce[it * 2 + 1] = at.k2;
    }
    for (var ot = this._wnafMulAdd(1, ke, Ce, it * 2, oe), yt = 0; yt < it * 2; yt++)
      ke[yt] = null, Ce[yt] = null;
    return ot;
  };
  function J(ie, ce, re, oe) {
    K.BasePoint.call(this, ie, "affine"), ce === null && re === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new B(ce, 16), this.y = new B(re, 16), oe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  L(J, K.BasePoint), W.prototype.point = function(ce, re, oe) {
    return new J(this, ce, re, oe);
  }, W.prototype.pointFromJSON = function(ce, re) {
    return J.fromJSON(this, ce, re);
  }, J.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ce = this.precomputed;
      if (ce && ce.beta)
        return ce.beta;
      var re = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ce) {
        var oe = this.curve, ke = function(Ce) {
          return oe.point(Ce.x.redMul(oe.endo.beta), Ce.y);
        };
        ce.beta = re, re.precomputed = {
          beta: null,
          naf: ce.naf && {
            wnd: ce.naf.wnd,
            points: ce.naf.points.map(ke)
          },
          doubles: ce.doubles && {
            step: ce.doubles.step,
            points: ce.doubles.points.map(ke)
          }
        };
      }
      return re;
    }
  }, J.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, J.fromJSON = function(ce, re, oe) {
    typeof re == "string" && (re = JSON.parse(re));
    var ke = ce.point(re[0], re[1], oe);
    if (!re[2])
      return ke;
    function Ce(at) {
      return ce.point(at[0], at[1], oe);
    }
    var it = re[2];
    return ke.precomputed = {
      beta: null,
      doubles: it.doubles && {
        step: it.doubles.step,
        points: [ke].concat(it.doubles.points.map(Ce))
      },
      naf: it.naf && {
        wnd: it.naf.wnd,
        points: [ke].concat(it.naf.points.map(Ce))
      }
    }, ke;
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.inf;
  }, J.prototype.add = function(ce) {
    if (this.inf)
      return ce;
    if (ce.inf)
      return this;
    if (this.eq(ce))
      return this.dbl();
    if (this.neg().eq(ce))
      return this.curve.point(null, null);
    if (this.x.cmp(ce.x) === 0)
      return this.curve.point(null, null);
    var re = this.y.redSub(ce.y);
    re.cmpn(0) !== 0 && (re = re.redMul(this.x.redSub(ce.x).redInvm()));
    var oe = re.redSqr().redISub(this.x).redISub(ce.x), ke = re.redMul(this.x.redSub(oe)).redISub(this.y);
    return this.curve.point(oe, ke);
  }, J.prototype.dbl = function() {
    if (this.inf)
      return this;
    var ce = this.y.redAdd(this.y);
    if (ce.cmpn(0) === 0)
      return this.curve.point(null, null);
    var re = this.curve.a, oe = this.x.redSqr(), ke = ce.redInvm(), Ce = oe.redAdd(oe).redIAdd(oe).redIAdd(re).redMul(ke), it = Ce.redSqr().redISub(this.x.redAdd(this.x)), at = Ce.redMul(this.x.redSub(it)).redISub(this.y);
    return this.curve.point(it, at);
  }, J.prototype.getX = function() {
    return this.x.fromRed();
  }, J.prototype.getY = function() {
    return this.y.fromRed();
  }, J.prototype.mul = function(ce) {
    return ce = new B(ce, 16), this.isInfinity() ? this : this._hasDoubles(ce) ? this.curve._fixedNafMul(this, ce) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ce]) : this.curve._wnafMul(this, ce);
  }, J.prototype.mulAdd = function(ce, re, oe) {
    var ke = [this, re], Ce = [ce, oe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Ce) : this.curve._wnafMulAdd(1, ke, Ce, 2);
  }, J.prototype.jmulAdd = function(ce, re, oe) {
    var ke = [this, re], Ce = [ce, oe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Ce, !0) : this.curve._wnafMulAdd(1, ke, Ce, 2, !0);
  }, J.prototype.eq = function(ce) {
    return this === ce || this.inf === ce.inf && (this.inf || this.x.cmp(ce.x) === 0 && this.y.cmp(ce.y) === 0);
  }, J.prototype.neg = function(ce) {
    if (this.inf)
      return this;
    var re = this.curve.point(this.x, this.y.redNeg());
    if (ce && this.precomputed) {
      var oe = this.precomputed, ke = function(Ce) {
        return Ce.neg();
      };
      re.precomputed = {
        naf: oe.naf && {
          wnd: oe.naf.wnd,
          points: oe.naf.points.map(ke)
        },
        doubles: oe.doubles && {
          step: oe.doubles.step,
          points: oe.doubles.points.map(ke)
        }
      };
    }
    return re;
  }, J.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var ce = this.curve.jpoint(this.x, this.y, this.curve.one);
    return ce;
  };
  function ne(ie, ce, re, oe) {
    K.BasePoint.call(this, ie, "jacobian"), ce === null && re === null && oe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new B(0)) : (this.x = new B(ce, 16), this.y = new B(re, 16), this.z = new B(oe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return L(ne, K.BasePoint), W.prototype.jpoint = function(ce, re, oe) {
    return new ne(this, ce, re, oe);
  }, ne.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var ce = this.z.redInvm(), re = ce.redSqr(), oe = this.x.redMul(re), ke = this.y.redMul(re).redMul(ce);
    return this.curve.point(oe, ke);
  }, ne.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ne.prototype.add = function(ce) {
    if (this.isInfinity())
      return ce;
    if (ce.isInfinity())
      return this;
    var re = ce.z.redSqr(), oe = this.z.redSqr(), ke = this.x.redMul(re), Ce = ce.x.redMul(oe), it = this.y.redMul(re.redMul(ce.z)), at = ce.y.redMul(oe.redMul(this.z)), ct = ke.redSub(Ce), dt = it.redSub(at);
    if (ct.cmpn(0) === 0)
      return dt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var ot = ct.redSqr(), yt = ot.redMul(ct), mt = ke.redMul(ot), Tt = dt.redSqr().redIAdd(yt).redISub(mt).redISub(mt), Pt = dt.redMul(mt.redISub(Tt)).redISub(it.redMul(yt)), Nt = this.z.redMul(ce.z).redMul(ct);
    return this.curve.jpoint(Tt, Pt, Nt);
  }, ne.prototype.mixedAdd = function(ce) {
    if (this.isInfinity())
      return ce.toJ();
    if (ce.isInfinity())
      return this;
    var re = this.z.redSqr(), oe = this.x, ke = ce.x.redMul(re), Ce = this.y, it = ce.y.redMul(re).redMul(this.z), at = oe.redSub(ke), ct = Ce.redSub(it);
    if (at.cmpn(0) === 0)
      return ct.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var dt = at.redSqr(), ot = dt.redMul(at), yt = oe.redMul(dt), mt = ct.redSqr().redIAdd(ot).redISub(yt).redISub(yt), Tt = ct.redMul(yt.redISub(mt)).redISub(Ce.redMul(ot)), Pt = this.z.redMul(at);
    return this.curve.jpoint(mt, Tt, Pt);
  }, ne.prototype.dblp = function(ce) {
    if (ce === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!ce)
      return this.dbl();
    var re;
    if (this.curve.zeroA || this.curve.threeA) {
      var oe = this;
      for (re = 0; re < ce; re++)
        oe = oe.dbl();
      return oe;
    }
    var ke = this.curve.a, Ce = this.curve.tinv, it = this.x, at = this.y, ct = this.z, dt = ct.redSqr().redSqr(), ot = at.redAdd(at);
    for (re = 0; re < ce; re++) {
      var yt = it.redSqr(), mt = ot.redSqr(), Tt = mt.redSqr(), Pt = yt.redAdd(yt).redIAdd(yt).redIAdd(ke.redMul(dt)), Nt = it.redMul(mt), St = Pt.redSqr().redISub(Nt.redAdd(Nt)), vt = Nt.redISub(St), It = Pt.redMul(vt);
      It = It.redIAdd(It).redISub(Tt);
      var wt = ot.redMul(ct);
      re + 1 < ce && (dt = dt.redMul(Tt)), it = St, ct = wt, ot = It;
    }
    return this.curve.jpoint(it, ot.redMul(Ce), ct);
  }, ne.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ne.prototype._zeroDbl = function() {
    var ce, re, oe;
    if (this.zOne) {
      var ke = this.x.redSqr(), Ce = this.y.redSqr(), it = Ce.redSqr(), at = this.x.redAdd(Ce).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var ct = ke.redAdd(ke).redIAdd(ke), dt = ct.redSqr().redISub(at).redISub(at), ot = it.redIAdd(it);
      ot = ot.redIAdd(ot), ot = ot.redIAdd(ot), ce = dt, re = ct.redMul(at.redISub(dt)).redISub(ot), oe = this.y.redAdd(this.y);
    } else {
      var yt = this.x.redSqr(), mt = this.y.redSqr(), Tt = mt.redSqr(), Pt = this.x.redAdd(mt).redSqr().redISub(yt).redISub(Tt);
      Pt = Pt.redIAdd(Pt);
      var Nt = yt.redAdd(yt).redIAdd(yt), St = Nt.redSqr(), vt = Tt.redIAdd(Tt);
      vt = vt.redIAdd(vt), vt = vt.redIAdd(vt), ce = St.redISub(Pt).redISub(Pt), re = Nt.redMul(Pt.redISub(ce)).redISub(vt), oe = this.y.redMul(this.z), oe = oe.redIAdd(oe);
    }
    return this.curve.jpoint(ce, re, oe);
  }, ne.prototype._threeDbl = function() {
    var ce, re, oe;
    if (this.zOne) {
      var ke = this.x.redSqr(), Ce = this.y.redSqr(), it = Ce.redSqr(), at = this.x.redAdd(Ce).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var ct = ke.redAdd(ke).redIAdd(ke).redIAdd(this.curve.a), dt = ct.redSqr().redISub(at).redISub(at);
      ce = dt;
      var ot = it.redIAdd(it);
      ot = ot.redIAdd(ot), ot = ot.redIAdd(ot), re = ct.redMul(at.redISub(dt)).redISub(ot), oe = this.y.redAdd(this.y);
    } else {
      var yt = this.z.redSqr(), mt = this.y.redSqr(), Tt = this.x.redMul(mt), Pt = this.x.redSub(yt).redMul(this.x.redAdd(yt));
      Pt = Pt.redAdd(Pt).redIAdd(Pt);
      var Nt = Tt.redIAdd(Tt);
      Nt = Nt.redIAdd(Nt);
      var St = Nt.redAdd(Nt);
      ce = Pt.redSqr().redISub(St), oe = this.y.redAdd(this.z).redSqr().redISub(mt).redISub(yt);
      var vt = mt.redSqr();
      vt = vt.redIAdd(vt), vt = vt.redIAdd(vt), vt = vt.redIAdd(vt), re = Pt.redMul(Nt.redISub(ce)).redISub(vt);
    }
    return this.curve.jpoint(ce, re, oe);
  }, ne.prototype._dbl = function() {
    var ce = this.curve.a, re = this.x, oe = this.y, ke = this.z, Ce = ke.redSqr().redSqr(), it = re.redSqr(), at = oe.redSqr(), ct = it.redAdd(it).redIAdd(it).redIAdd(ce.redMul(Ce)), dt = re.redAdd(re);
    dt = dt.redIAdd(dt);
    var ot = dt.redMul(at), yt = ct.redSqr().redISub(ot.redAdd(ot)), mt = ot.redISub(yt), Tt = at.redSqr();
    Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt);
    var Pt = ct.redMul(mt).redISub(Tt), Nt = oe.redAdd(oe).redMul(ke);
    return this.curve.jpoint(yt, Pt, Nt);
  }, ne.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var ce = this.x.redSqr(), re = this.y.redSqr(), oe = this.z.redSqr(), ke = re.redSqr(), Ce = ce.redAdd(ce).redIAdd(ce), it = Ce.redSqr(), at = this.x.redAdd(re).redSqr().redISub(ce).redISub(ke);
    at = at.redIAdd(at), at = at.redAdd(at).redIAdd(at), at = at.redISub(it);
    var ct = at.redSqr(), dt = ke.redIAdd(ke);
    dt = dt.redIAdd(dt), dt = dt.redIAdd(dt), dt = dt.redIAdd(dt);
    var ot = Ce.redIAdd(at).redSqr().redISub(it).redISub(ct).redISub(dt), yt = re.redMul(ot);
    yt = yt.redIAdd(yt), yt = yt.redIAdd(yt);
    var mt = this.x.redMul(ct).redISub(yt);
    mt = mt.redIAdd(mt), mt = mt.redIAdd(mt);
    var Tt = this.y.redMul(ot.redMul(dt.redISub(ot)).redISub(at.redMul(ct)));
    Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt), Tt = Tt.redIAdd(Tt);
    var Pt = this.z.redAdd(at).redSqr().redISub(oe).redISub(ct);
    return this.curve.jpoint(mt, Tt, Pt);
  }, ne.prototype.mul = function(ce, re) {
    return ce = new B(ce, re), this.curve._wnafMul(this, ce);
  }, ne.prototype.eq = function(ce) {
    if (ce.type === "affine")
      return this.eq(ce.toJ());
    if (this === ce)
      return !0;
    var re = this.z.redSqr(), oe = ce.z.redSqr();
    if (this.x.redMul(oe).redISub(ce.x.redMul(re)).cmpn(0) !== 0)
      return !1;
    var ke = re.redMul(this.z), Ce = oe.redMul(ce.z);
    return this.y.redMul(Ce).redISub(ce.y.redMul(ke)).cmpn(0) === 0;
  }, ne.prototype.eqXToP = function(ce) {
    var re = this.z.redSqr(), oe = ce.toRed(this.curve.red).redMul(re);
    if (this.x.cmp(oe) === 0)
      return !0;
    for (var ke = ce.clone(), Ce = this.curve.redN.redMul(re); ; ) {
      if (ke.iadd(this.curve.n), ke.cmp(this.curve.p) >= 0)
        return !1;
      if (oe.redIAdd(Ce), this.x.cmp(oe) === 0)
        return !0;
    }
  }, ne.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ne.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var A = requireBn$1(), B = requireInherits_browser(), L = requireBase$1(), K = requireUtils$1();
  function V(J) {
    L.call(this, "mont", J), this.a = new A(J.a, 16).toRed(this.red), this.b = new A(J.b, 16).toRed(this.red), this.i4 = new A(4).toRed(this.red).redInvm(), this.two = new A(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  B(V, L), mont = V, V.prototype.validate = function(ne) {
    var ie = ne.normalize().x, ce = ie.redSqr(), re = ce.redMul(ie).redAdd(ce.redMul(this.a)).redAdd(ie), oe = re.redSqrt();
    return oe.redSqr().cmp(re) === 0;
  };
  function W(J, ne, ie) {
    L.BasePoint.call(this, J, "projective"), ne === null && ie === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new A(ne, 16), this.z = new A(ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return B(W, L.BasePoint), V.prototype.decodePoint = function(ne, ie) {
    return this.point(K.toArray(ne, ie), 1);
  }, V.prototype.point = function(ne, ie) {
    return new W(this, ne, ie);
  }, V.prototype.pointFromJSON = function(ne) {
    return W.fromJSON(this, ne);
  }, W.prototype.precompute = function() {
  }, W.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, W.fromJSON = function(ne, ie) {
    return new W(ne, ie[0], ie[1] || ne.one);
  }, W.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, W.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, W.prototype.dbl = function() {
    var ne = this.x.redAdd(this.z), ie = ne.redSqr(), ce = this.x.redSub(this.z), re = ce.redSqr(), oe = ie.redSub(re), ke = ie.redMul(re), Ce = oe.redMul(re.redAdd(this.curve.a24.redMul(oe)));
    return this.curve.point(ke, Ce);
  }, W.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.diffAdd = function(ne, ie) {
    var ce = this.x.redAdd(this.z), re = this.x.redSub(this.z), oe = ne.x.redAdd(ne.z), ke = ne.x.redSub(ne.z), Ce = ke.redMul(ce), it = oe.redMul(re), at = ie.z.redMul(Ce.redAdd(it).redSqr()), ct = ie.x.redMul(Ce.redISub(it).redSqr());
    return this.curve.point(at, ct);
  }, W.prototype.mul = function(ne) {
    for (var ie = ne.clone(), ce = this, re = this.curve.point(null, null), oe = this, ke = []; ie.cmpn(0) !== 0; ie.iushrn(1))
      ke.push(ie.andln(1));
    for (var Ce = ke.length - 1; Ce >= 0; Ce--)
      ke[Ce] === 0 ? (ce = ce.diffAdd(re, oe), re = re.dbl()) : (re = ce.diffAdd(re, oe), ce = ce.dbl());
    return re;
  }, W.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.eq = function(ne) {
    return this.getX().cmp(ne.getX()) === 0;
  }, W.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, W.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), V = A.assert;
  function W(ne) {
    this.twisted = (ne.a | 0) !== 1, this.mOneA = this.twisted && (ne.a | 0) === -1, this.extended = this.mOneA, K.call(this, "edwards", ne), this.a = new B(ne.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new B(ne.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new B(ne.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), V(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ne.c | 0) === 1;
  }
  L(W, K), edwards = W, W.prototype._mulA = function(ie) {
    return this.mOneA ? ie.redNeg() : this.a.redMul(ie);
  }, W.prototype._mulC = function(ie) {
    return this.oneC ? ie : this.c.redMul(ie);
  }, W.prototype.jpoint = function(ie, ce, re, oe) {
    return this.point(ie, ce, re, oe);
  }, W.prototype.pointFromX = function(ie, ce) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var re = ie.redSqr(), oe = this.c2.redSub(this.a.redMul(re)), ke = this.one.redSub(this.c2.redMul(this.d).redMul(re)), Ce = oe.redMul(ke.redInvm()), it = Ce.redSqrt();
    if (it.redSqr().redSub(Ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var at = it.fromRed().isOdd();
    return (ce && !at || !ce && at) && (it = it.redNeg()), this.point(ie, it);
  }, W.prototype.pointFromY = function(ie, ce) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var re = ie.redSqr(), oe = re.redSub(this.c2), ke = re.redMul(this.d).redMul(this.c2).redSub(this.a), Ce = oe.redMul(ke.redInvm());
    if (Ce.cmp(this.zero) === 0) {
      if (ce)
        throw new Error("invalid point");
      return this.point(this.zero, ie);
    }
    var it = Ce.redSqrt();
    if (it.redSqr().redSub(Ce).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return it.fromRed().isOdd() !== ce && (it = it.redNeg()), this.point(it, ie);
  }, W.prototype.validate = function(ie) {
    if (ie.isInfinity())
      return !0;
    ie.normalize();
    var ce = ie.x.redSqr(), re = ie.y.redSqr(), oe = ce.redMul(this.a).redAdd(re), ke = this.c2.redMul(this.one.redAdd(this.d.redMul(ce).redMul(re)));
    return oe.cmp(ke) === 0;
  };
  function J(ne, ie, ce, re, oe) {
    K.BasePoint.call(this, ne, "projective"), ie === null && ce === null && re === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new B(ie, 16), this.y = new B(ce, 16), this.z = re ? new B(re, 16) : this.curve.one, this.t = oe && new B(oe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return L(J, K.BasePoint), W.prototype.pointFromJSON = function(ie) {
    return J.fromJSON(this, ie);
  }, W.prototype.point = function(ie, ce, re, oe) {
    return new J(this, ie, ce, re, oe);
  }, J.fromJSON = function(ie, ce) {
    return new J(ie, ce[0], ce[1], ce[2]);
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, J.prototype._extDbl = function() {
    var ie = this.x.redSqr(), ce = this.y.redSqr(), re = this.z.redSqr();
    re = re.redIAdd(re);
    var oe = this.curve._mulA(ie), ke = this.x.redAdd(this.y).redSqr().redISub(ie).redISub(ce), Ce = oe.redAdd(ce), it = Ce.redSub(re), at = oe.redSub(ce), ct = ke.redMul(it), dt = Ce.redMul(at), ot = ke.redMul(at), yt = it.redMul(Ce);
    return this.curve.point(ct, dt, yt, ot);
  }, J.prototype._projDbl = function() {
    var ie = this.x.redAdd(this.y).redSqr(), ce = this.x.redSqr(), re = this.y.redSqr(), oe, ke, Ce, it, at, ct;
    if (this.curve.twisted) {
      it = this.curve._mulA(ce);
      var dt = it.redAdd(re);
      this.zOne ? (oe = ie.redSub(ce).redSub(re).redMul(dt.redSub(this.curve.two)), ke = dt.redMul(it.redSub(re)), Ce = dt.redSqr().redSub(dt).redSub(dt)) : (at = this.z.redSqr(), ct = dt.redSub(at).redISub(at), oe = ie.redSub(ce).redISub(re).redMul(ct), ke = dt.redMul(it.redSub(re)), Ce = dt.redMul(ct));
    } else
      it = ce.redAdd(re), at = this.curve._mulC(this.z).redSqr(), ct = it.redSub(at).redSub(at), oe = this.curve._mulC(ie.redISub(it)).redMul(ct), ke = this.curve._mulC(it).redMul(ce.redISub(re)), Ce = it.redMul(ct);
    return this.curve.point(oe, ke, Ce);
  }, J.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, J.prototype._extAdd = function(ie) {
    var ce = this.y.redSub(this.x).redMul(ie.y.redSub(ie.x)), re = this.y.redAdd(this.x).redMul(ie.y.redAdd(ie.x)), oe = this.t.redMul(this.curve.dd).redMul(ie.t), ke = this.z.redMul(ie.z.redAdd(ie.z)), Ce = re.redSub(ce), it = ke.redSub(oe), at = ke.redAdd(oe), ct = re.redAdd(ce), dt = Ce.redMul(it), ot = at.redMul(ct), yt = Ce.redMul(ct), mt = it.redMul(at);
    return this.curve.point(dt, ot, mt, yt);
  }, J.prototype._projAdd = function(ie) {
    var ce = this.z.redMul(ie.z), re = ce.redSqr(), oe = this.x.redMul(ie.x), ke = this.y.redMul(ie.y), Ce = this.curve.d.redMul(oe).redMul(ke), it = re.redSub(Ce), at = re.redAdd(Ce), ct = this.x.redAdd(this.y).redMul(ie.x.redAdd(ie.y)).redISub(oe).redISub(ke), dt = ce.redMul(it).redMul(ct), ot, yt;
    return this.curve.twisted ? (ot = ce.redMul(at).redMul(ke.redSub(this.curve._mulA(oe))), yt = it.redMul(at)) : (ot = ce.redMul(at).redMul(ke.redSub(oe)), yt = this.curve._mulC(it).redMul(at)), this.curve.point(dt, ot, yt);
  }, J.prototype.add = function(ie) {
    return this.isInfinity() ? ie : ie.isInfinity() ? this : this.curve.extended ? this._extAdd(ie) : this._projAdd(ie);
  }, J.prototype.mul = function(ie) {
    return this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve._wnafMul(this, ie);
  }, J.prototype.mulAdd = function(ie, ce, re) {
    return this.curve._wnafMulAdd(1, [this, ce], [ie, re], 2, !1);
  }, J.prototype.jmulAdd = function(ie, ce, re) {
    return this.curve._wnafMulAdd(1, [this, ce], [ie, re], 2, !0);
  }, J.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ie = this.z.redInvm();
    return this.x = this.x.redMul(ie), this.y = this.y.redMul(ie), this.t && (this.t = this.t.redMul(ie)), this.z = this.curve.one, this.zOne = !0, this;
  }, J.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, J.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, J.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, J.prototype.eq = function(ie) {
    return this === ie || this.getX().cmp(ie.getX()) === 0 && this.getY().cmp(ie.getY()) === 0;
  }, J.prototype.eqXToP = function(ie) {
    var ce = ie.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ce) === 0)
      return !0;
    for (var re = ie.clone(), oe = this.curve.redN.redMul(this.z); ; ) {
      if (re.iadd(this.curve.n), re.cmp(this.curve.p) >= 0)
        return !1;
      if (ce.redIAdd(oe), this.x.cmp(ce) === 0)
        return !0;
    }
  }, J.prototype.toP = J.prototype.normalize, J.prototype.mixedAdd = J.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(A) {
    var B = A;
    B.base = requireBase$1(), B.short = requireShort(), B.mont = requireMont(), B.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser();
  utils$1.inherits = B;
  function L(Oe, rt) {
    return (Oe.charCodeAt(rt) & 64512) !== 55296 || rt < 0 || rt + 1 >= Oe.length ? !1 : (Oe.charCodeAt(rt + 1) & 64512) === 56320;
  }
  function K(Oe, rt) {
    if (Array.isArray(Oe))
      return Oe.slice();
    if (!Oe)
      return [];
    var pe = [];
    if (typeof Oe == "string")
      if (rt) {
        if (rt === "hex")
          for (Oe = Oe.replace(/[^a-z0-9]+/ig, ""), Oe.length % 2 !== 0 && (Oe = "0" + Oe), st = 0; st < Oe.length; st += 2)
            pe.push(parseInt(Oe[st] + Oe[st + 1], 16));
      } else for (var nt = 0, st = 0; st < Oe.length; st++) {
        var ft = Oe.charCodeAt(st);
        ft < 128 ? pe[nt++] = ft : ft < 2048 ? (pe[nt++] = ft >> 6 | 192, pe[nt++] = ft & 63 | 128) : L(Oe, st) ? (ft = 65536 + ((ft & 1023) << 10) + (Oe.charCodeAt(++st) & 1023), pe[nt++] = ft >> 18 | 240, pe[nt++] = ft >> 12 & 63 | 128, pe[nt++] = ft >> 6 & 63 | 128, pe[nt++] = ft & 63 | 128) : (pe[nt++] = ft >> 12 | 224, pe[nt++] = ft >> 6 & 63 | 128, pe[nt++] = ft & 63 | 128);
      }
    else
      for (st = 0; st < Oe.length; st++)
        pe[st] = Oe[st] | 0;
    return pe;
  }
  utils$1.toArray = K;
  function V(Oe) {
    for (var rt = "", pe = 0; pe < Oe.length; pe++)
      rt += ne(Oe[pe].toString(16));
    return rt;
  }
  utils$1.toHex = V;
  function W(Oe) {
    var rt = Oe >>> 24 | Oe >>> 8 & 65280 | Oe << 8 & 16711680 | (Oe & 255) << 24;
    return rt >>> 0;
  }
  utils$1.htonl = W;
  function J(Oe, rt) {
    for (var pe = "", nt = 0; nt < Oe.length; nt++) {
      var st = Oe[nt];
      rt === "little" && (st = W(st)), pe += ie(st.toString(16));
    }
    return pe;
  }
  utils$1.toHex32 = J;
  function ne(Oe) {
    return Oe.length === 1 ? "0" + Oe : Oe;
  }
  utils$1.zero2 = ne;
  function ie(Oe) {
    return Oe.length === 7 ? "0" + Oe : Oe.length === 6 ? "00" + Oe : Oe.length === 5 ? "000" + Oe : Oe.length === 4 ? "0000" + Oe : Oe.length === 3 ? "00000" + Oe : Oe.length === 2 ? "000000" + Oe : Oe.length === 1 ? "0000000" + Oe : Oe;
  }
  utils$1.zero8 = ie;
  function ce(Oe, rt, pe, nt) {
    var st = pe - rt;
    A(st % 4 === 0);
    for (var ft = new Array(st / 4), ht = 0, bt = rt; ht < ft.length; ht++, bt += 4) {
      var ut;
      nt === "big" ? ut = Oe[bt] << 24 | Oe[bt + 1] << 16 | Oe[bt + 2] << 8 | Oe[bt + 3] : ut = Oe[bt + 3] << 24 | Oe[bt + 2] << 16 | Oe[bt + 1] << 8 | Oe[bt], ft[ht] = ut >>> 0;
    }
    return ft;
  }
  utils$1.join32 = ce;
  function re(Oe, rt) {
    for (var pe = new Array(Oe.length * 4), nt = 0, st = 0; nt < Oe.length; nt++, st += 4) {
      var ft = Oe[nt];
      rt === "big" ? (pe[st] = ft >>> 24, pe[st + 1] = ft >>> 16 & 255, pe[st + 2] = ft >>> 8 & 255, pe[st + 3] = ft & 255) : (pe[st + 3] = ft >>> 24, pe[st + 2] = ft >>> 16 & 255, pe[st + 1] = ft >>> 8 & 255, pe[st] = ft & 255);
    }
    return pe;
  }
  utils$1.split32 = re;
  function oe(Oe, rt) {
    return Oe >>> rt | Oe << 32 - rt;
  }
  utils$1.rotr32 = oe;
  function ke(Oe, rt) {
    return Oe << rt | Oe >>> 32 - rt;
  }
  utils$1.rotl32 = ke;
  function Ce(Oe, rt) {
    return Oe + rt >>> 0;
  }
  utils$1.sum32 = Ce;
  function it(Oe, rt, pe) {
    return Oe + rt + pe >>> 0;
  }
  utils$1.sum32_3 = it;
  function at(Oe, rt, pe, nt) {
    return Oe + rt + pe + nt >>> 0;
  }
  utils$1.sum32_4 = at;
  function ct(Oe, rt, pe, nt, st) {
    return Oe + rt + pe + nt + st >>> 0;
  }
  utils$1.sum32_5 = ct;
  function dt(Oe, rt, pe, nt) {
    var st = Oe[rt], ft = Oe[rt + 1], ht = nt + ft >>> 0, bt = (ht < nt ? 1 : 0) + pe + st;
    Oe[rt] = bt >>> 0, Oe[rt + 1] = ht;
  }
  utils$1.sum64 = dt;
  function ot(Oe, rt, pe, nt) {
    var st = rt + nt >>> 0, ft = (st < rt ? 1 : 0) + Oe + pe;
    return ft >>> 0;
  }
  utils$1.sum64_hi = ot;
  function yt(Oe, rt, pe, nt) {
    var st = rt + nt;
    return st >>> 0;
  }
  utils$1.sum64_lo = yt;
  function mt(Oe, rt, pe, nt, st, ft, ht, bt) {
    var ut = 0, gt = rt;
    gt = gt + nt >>> 0, ut += gt < rt ? 1 : 0, gt = gt + ft >>> 0, ut += gt < ft ? 1 : 0, gt = gt + bt >>> 0, ut += gt < bt ? 1 : 0;
    var lt = Oe + pe + st + ht + ut;
    return lt >>> 0;
  }
  utils$1.sum64_4_hi = mt;
  function Tt(Oe, rt, pe, nt, st, ft, ht, bt) {
    var ut = rt + nt + ft + bt;
    return ut >>> 0;
  }
  utils$1.sum64_4_lo = Tt;
  function Pt(Oe, rt, pe, nt, st, ft, ht, bt, ut, gt) {
    var lt = 0, $t = rt;
    $t = $t + nt >>> 0, lt += $t < rt ? 1 : 0, $t = $t + ft >>> 0, lt += $t < ft ? 1 : 0, $t = $t + bt >>> 0, lt += $t < bt ? 1 : 0, $t = $t + gt >>> 0, lt += $t < gt ? 1 : 0;
    var jt = Oe + pe + st + ht + ut + lt;
    return jt >>> 0;
  }
  utils$1.sum64_5_hi = Pt;
  function Nt(Oe, rt, pe, nt, st, ft, ht, bt, ut, gt) {
    var lt = rt + nt + ft + bt + gt;
    return lt >>> 0;
  }
  utils$1.sum64_5_lo = Nt;
  function St(Oe, rt, pe) {
    var nt = rt << 32 - pe | Oe >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_hi = St;
  function vt(Oe, rt, pe) {
    var nt = Oe << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_lo = vt;
  function It(Oe, rt, pe) {
    return Oe >>> pe;
  }
  utils$1.shr64_hi = It;
  function wt(Oe, rt, pe) {
    var nt = Oe << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  return utils$1.shr64_lo = wt, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = L, L.prototype.update = function(V, W) {
    if (V = A.toArray(V, W), this.pending ? this.pending = this.pending.concat(V) : this.pending = V, this.pendingTotal += V.length, this.pending.length >= this._delta8) {
      V = this.pending;
      var J = V.length % this._delta8;
      this.pending = V.slice(V.length - J, V.length), this.pending.length === 0 && (this.pending = null), V = A.join32(V, 0, V.length - J, this.endian);
      for (var ne = 0; ne < V.length; ne += this._delta32)
        this._update(V, ne, ne + this._delta32);
    }
    return this;
  }, L.prototype.digest = function(V) {
    return this.update(this._pad()), B(this.pending === null), this._digest(V);
  }, L.prototype._pad = function() {
    var V = this.pendingTotal, W = this._delta8, J = W - (V + this.padLength) % W, ne = new Array(J + this.padLength);
    ne[0] = 128;
    for (var ie = 1; ie < J; ie++)
      ne[ie] = 0;
    if (V <<= 3, this.endian === "big") {
      for (var ce = 8; ce < this.padLength; ce++)
        ne[ie++] = 0;
      ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = V >>> 24 & 255, ne[ie++] = V >>> 16 & 255, ne[ie++] = V >>> 8 & 255, ne[ie++] = V & 255;
    } else
      for (ne[ie++] = V & 255, ne[ie++] = V >>> 8 & 255, ne[ie++] = V >>> 16 & 255, ne[ie++] = V >>> 24 & 255, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ce = 8; ce < this.padLength; ce++)
        ne[ie++] = 0;
    return ne;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var A = requireUtils(), B = A.rotr32;
  function L(re, oe, ke, Ce) {
    if (re === 0)
      return K(oe, ke, Ce);
    if (re === 1 || re === 3)
      return W(oe, ke, Ce);
    if (re === 2)
      return V(oe, ke, Ce);
  }
  common.ft_1 = L;
  function K(re, oe, ke) {
    return re & oe ^ ~re & ke;
  }
  common.ch32 = K;
  function V(re, oe, ke) {
    return re & oe ^ re & ke ^ oe & ke;
  }
  common.maj32 = V;
  function W(re, oe, ke) {
    return re ^ oe ^ ke;
  }
  common.p32 = W;
  function J(re) {
    return B(re, 2) ^ B(re, 13) ^ B(re, 22);
  }
  common.s0_256 = J;
  function ne(re) {
    return B(re, 6) ^ B(re, 11) ^ B(re, 25);
  }
  common.s1_256 = ne;
  function ie(re) {
    return B(re, 7) ^ B(re, 18) ^ re >>> 3;
  }
  common.g0_256 = ie;
  function ce(re) {
    return B(re, 17) ^ B(re, 19) ^ re >>> 10;
  }
  return common.g1_256 = ce, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = A.rotl32, V = A.sum32, W = A.sum32_5, J = L.ft_1, ne = B.BlockHash, ie = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ce() {
    if (!(this instanceof ce))
      return new ce();
    ne.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return A.inherits(ce, ne), _1 = ce, ce.blockSize = 512, ce.outSize = 160, ce.hmacStrength = 80, ce.padLength = 64, ce.prototype._update = function(oe, ke) {
    for (var Ce = this.W, it = 0; it < 16; it++)
      Ce[it] = oe[ke + it];
    for (; it < Ce.length; it++)
      Ce[it] = K(Ce[it - 3] ^ Ce[it - 8] ^ Ce[it - 14] ^ Ce[it - 16], 1);
    var at = this.h[0], ct = this.h[1], dt = this.h[2], ot = this.h[3], yt = this.h[4];
    for (it = 0; it < Ce.length; it++) {
      var mt = ~~(it / 20), Tt = W(K(at, 5), J(mt, ct, dt, ot), yt, Ce[it], ie[mt]);
      yt = ot, ot = dt, dt = K(ct, 30), ct = at, at = Tt;
    }
    this.h[0] = V(this.h[0], at), this.h[1] = V(this.h[1], ct), this.h[2] = V(this.h[2], dt), this.h[3] = V(this.h[3], ot), this.h[4] = V(this.h[4], yt);
  }, ce.prototype._digest = function(oe) {
    return oe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = requireMinimalisticAssert(), V = A.sum32, W = A.sum32_4, J = A.sum32_5, ne = L.ch32, ie = L.maj32, ce = L.s0_256, re = L.s1_256, oe = L.g0_256, ke = L.g1_256, Ce = B.BlockHash, it = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function at() {
    if (!(this instanceof at))
      return new at();
    Ce.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = it, this.W = new Array(64);
  }
  return A.inherits(at, Ce), _256 = at, at.blockSize = 512, at.outSize = 256, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(dt, ot) {
    for (var yt = this.W, mt = 0; mt < 16; mt++)
      yt[mt] = dt[ot + mt];
    for (; mt < yt.length; mt++)
      yt[mt] = W(ke(yt[mt - 2]), yt[mt - 7], oe(yt[mt - 15]), yt[mt - 16]);
    var Tt = this.h[0], Pt = this.h[1], Nt = this.h[2], St = this.h[3], vt = this.h[4], It = this.h[5], wt = this.h[6], Oe = this.h[7];
    for (K(this.k.length === yt.length), mt = 0; mt < yt.length; mt++) {
      var rt = J(Oe, re(vt), ne(vt, It, wt), this.k[mt], yt[mt]), pe = V(ce(Tt), ie(Tt, Pt, Nt));
      Oe = wt, wt = It, It = vt, vt = V(St, rt), St = Nt, Nt = Pt, Pt = Tt, Tt = V(rt, pe);
    }
    this.h[0] = V(this.h[0], Tt), this.h[1] = V(this.h[1], Pt), this.h[2] = V(this.h[2], Nt), this.h[3] = V(this.h[3], St), this.h[4] = V(this.h[4], vt), this.h[5] = V(this.h[5], It), this.h[6] = V(this.h[6], wt), this.h[7] = V(this.h[7], Oe);
  }, at.prototype._digest = function(dt) {
    return dt === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var A = requireUtils(), B = require_256();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return A.inherits(L, B), _224 = L, L.blockSize = 512, L.outSize = 224, L.hmacStrength = 192, L.padLength = 64, L.prototype._digest = function(V) {
    return V === "hex" ? A.toHex32(this.h.slice(0, 7), "big") : A.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireMinimalisticAssert(), K = A.rotr64_hi, V = A.rotr64_lo, W = A.shr64_hi, J = A.shr64_lo, ne = A.sum64, ie = A.sum64_hi, ce = A.sum64_lo, re = A.sum64_4_hi, oe = A.sum64_4_lo, ke = A.sum64_5_hi, Ce = A.sum64_5_lo, it = B.BlockHash, at = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function ct() {
    if (!(this instanceof ct))
      return new ct();
    it.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = at, this.W = new Array(160);
  }
  A.inherits(ct, it), _512 = ct, ct.blockSize = 1024, ct.outSize = 512, ct.hmacStrength = 192, ct.padLength = 128, ct.prototype._prepareBlock = function(pe, nt) {
    for (var st = this.W, ft = 0; ft < 32; ft++)
      st[ft] = pe[nt + ft];
    for (; ft < st.length; ft += 2) {
      var ht = wt(st[ft - 4], st[ft - 3]), bt = Oe(st[ft - 4], st[ft - 3]), ut = st[ft - 14], gt = st[ft - 13], lt = vt(st[ft - 30], st[ft - 29]), $t = It(st[ft - 30], st[ft - 29]), jt = st[ft - 32], Jt = st[ft - 31];
      st[ft] = re(
        ht,
        bt,
        ut,
        gt,
        lt,
        $t,
        jt,
        Jt
      ), st[ft + 1] = oe(
        ht,
        bt,
        ut,
        gt,
        lt,
        $t,
        jt,
        Jt
      );
    }
  }, ct.prototype._update = function(pe, nt) {
    this._prepareBlock(pe, nt);
    var st = this.W, ft = this.h[0], ht = this.h[1], bt = this.h[2], ut = this.h[3], gt = this.h[4], lt = this.h[5], $t = this.h[6], jt = this.h[7], Jt = this.h[8], Lt = this.h[9], Rt = this.h[10], Mt = this.h[11], Kt = this.h[12], zt = this.h[13], Ct = this.h[14], kt = this.h[15];
    L(this.k.length === st.length);
    for (var Vt = 0; Vt < st.length; Vt += 2) {
      var nr = Ct, ar = kt, sr = Nt(Jt, Lt), lr = St(Jt, Lt), dr = dt(Jt, Lt, Rt, Mt, Kt), rr = ot(Jt, Lt, Rt, Mt, Kt, zt), Pr = this.k[Vt], ur = this.k[Vt + 1], pr = st[Vt], br = st[Vt + 1], hr = ke(
        nr,
        ar,
        sr,
        lr,
        dr,
        rr,
        Pr,
        ur,
        pr,
        br
      ), xr = Ce(
        nr,
        ar,
        sr,
        lr,
        dr,
        rr,
        Pr,
        ur,
        pr,
        br
      );
      nr = Tt(ft, ht), ar = Pt(ft, ht), sr = yt(ft, ht, bt, ut, gt), lr = mt(ft, ht, bt, ut, gt, lt);
      var Mr = ie(nr, ar, sr, lr), _r = ce(nr, ar, sr, lr);
      Ct = Kt, kt = zt, Kt = Rt, zt = Mt, Rt = Jt, Mt = Lt, Jt = ie($t, jt, hr, xr), Lt = ce(jt, jt, hr, xr), $t = gt, jt = lt, gt = bt, lt = ut, bt = ft, ut = ht, ft = ie(hr, xr, Mr, _r), ht = ce(hr, xr, Mr, _r);
    }
    ne(this.h, 0, ft, ht), ne(this.h, 2, bt, ut), ne(this.h, 4, gt, lt), ne(this.h, 6, $t, jt), ne(this.h, 8, Jt, Lt), ne(this.h, 10, Rt, Mt), ne(this.h, 12, Kt, zt), ne(this.h, 14, Ct, kt);
  }, ct.prototype._digest = function(pe) {
    return pe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  };
  function dt(rt, pe, nt, st, ft) {
    var ht = rt & nt ^ ~rt & ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function ot(rt, pe, nt, st, ft, ht) {
    var bt = pe & st ^ ~pe & ht;
    return bt < 0 && (bt += 4294967296), bt;
  }
  function yt(rt, pe, nt, st, ft) {
    var ht = rt & nt ^ rt & ft ^ nt & ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function mt(rt, pe, nt, st, ft, ht) {
    var bt = pe & st ^ pe & ht ^ st & ht;
    return bt < 0 && (bt += 4294967296), bt;
  }
  function Tt(rt, pe) {
    var nt = K(rt, pe, 28), st = K(pe, rt, 2), ft = K(pe, rt, 7), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function Pt(rt, pe) {
    var nt = V(rt, pe, 28), st = V(pe, rt, 2), ft = V(pe, rt, 7), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function Nt(rt, pe) {
    var nt = K(rt, pe, 14), st = K(rt, pe, 18), ft = K(pe, rt, 9), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function St(rt, pe) {
    var nt = V(rt, pe, 14), st = V(rt, pe, 18), ft = V(pe, rt, 9), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function vt(rt, pe) {
    var nt = K(rt, pe, 1), st = K(rt, pe, 8), ft = W(rt, pe, 7), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function It(rt, pe) {
    var nt = V(rt, pe, 1), st = V(rt, pe, 8), ft = J(rt, pe, 7), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function wt(rt, pe) {
    var nt = K(rt, pe, 19), st = K(pe, rt, 29), ft = W(rt, pe, 6), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function Oe(rt, pe) {
    var nt = V(rt, pe, 19), st = V(pe, rt, 29), ft = J(rt, pe, 6), ht = nt ^ st ^ ft;
    return ht < 0 && (ht += 4294967296), ht;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var A = requireUtils(), B = require_512();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return A.inherits(L, B), _384 = L, L.blockSize = 1024, L.outSize = 384, L.hmacStrength = 192, L.padLength = 128, L.prototype._digest = function(V) {
    return V === "hex" ? A.toHex32(this.h.slice(0, 12), "big") : A.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var A = requireUtils(), B = requireCommon$1(), L = A.rotl32, K = A.sum32, V = A.sum32_3, W = A.sum32_4, J = B.BlockHash;
  function ne() {
    if (!(this instanceof ne))
      return new ne();
    J.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  A.inherits(ne, J), ripemd.ripemd160 = ne, ne.blockSize = 512, ne.outSize = 160, ne.hmacStrength = 192, ne.padLength = 64, ne.prototype._update = function(ct, dt) {
    for (var ot = this.h[0], yt = this.h[1], mt = this.h[2], Tt = this.h[3], Pt = this.h[4], Nt = ot, St = yt, vt = mt, It = Tt, wt = Pt, Oe = 0; Oe < 80; Oe++) {
      var rt = K(
        L(
          W(ot, ie(Oe, yt, mt, Tt), ct[oe[Oe] + dt], ce(Oe)),
          Ce[Oe]
        ),
        Pt
      );
      ot = Pt, Pt = Tt, Tt = L(mt, 10), mt = yt, yt = rt, rt = K(
        L(
          W(Nt, ie(79 - Oe, St, vt, It), ct[ke[Oe] + dt], re(Oe)),
          it[Oe]
        ),
        wt
      ), Nt = wt, wt = It, It = L(vt, 10), vt = St, St = rt;
    }
    rt = V(this.h[1], mt, It), this.h[1] = V(this.h[2], Tt, wt), this.h[2] = V(this.h[3], Pt, Nt), this.h[3] = V(this.h[4], ot, St), this.h[4] = V(this.h[0], yt, vt), this.h[0] = rt;
  }, ne.prototype._digest = function(ct) {
    return ct === "hex" ? A.toHex32(this.h, "little") : A.split32(this.h, "little");
  };
  function ie(at, ct, dt, ot) {
    return at <= 15 ? ct ^ dt ^ ot : at <= 31 ? ct & dt | ~ct & ot : at <= 47 ? (ct | ~dt) ^ ot : at <= 63 ? ct & ot | dt & ~ot : ct ^ (dt | ~ot);
  }
  function ce(at) {
    return at <= 15 ? 0 : at <= 31 ? 1518500249 : at <= 47 ? 1859775393 : at <= 63 ? 2400959708 : 2840853838;
  }
  function re(at) {
    return at <= 15 ? 1352829926 : at <= 31 ? 1548603684 : at <= 47 ? 1836072691 : at <= 63 ? 2053994217 : 0;
  }
  var oe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ke = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Ce = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], it = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L(K, V, W) {
    if (!(this instanceof L))
      return new L(K, V, W);
    this.Hash = K, this.blockSize = K.blockSize / 8, this.outSize = K.outSize / 8, this.inner = null, this.outer = null, this._init(A.toArray(V, W));
  }
  return hmac = L, L.prototype._init = function(V) {
    V.length > this.blockSize && (V = new this.Hash().update(V).digest()), B(V.length <= this.blockSize);
    for (var W = V.length; W < this.blockSize; W++)
      V.push(0);
    for (W = 0; W < V.length; W++)
      V[W] ^= 54;
    for (this.inner = new this.Hash().update(V), W = 0; W < V.length; W++)
      V[W] ^= 106;
    this.outer = new this.Hash().update(V);
  }, L.prototype.update = function(V, W) {
    return this.inner.update(V, W), this;
  }, L.prototype.digest = function(V) {
    return this.outer.update(this.inner.digest()), this.outer.digest(V);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(A) {
    var B = A;
    B.utils = requireUtils(), B.common = requireCommon$1(), B.sha = requireSha(), B.ripemd = requireRipemd(), B.hmac = requireHmac(), B.sha1 = B.sha.sha1, B.sha256 = B.sha.sha256, B.sha224 = B.sha.sha224, B.sha384 = B.sha.sha384, B.sha512 = B.sha.sha512, B.ripemd160 = B.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(A) {
    var B = A, L = requireHash(), K = requireCurve(), V = requireUtils$1(), W = V.assert;
    function J(ce) {
      ce.type === "short" ? this.curve = new K.short(ce) : ce.type === "edwards" ? this.curve = new K.edwards(ce) : this.curve = new K.mont(ce), this.g = this.curve.g, this.n = this.curve.n, this.hash = ce.hash, W(this.g.validate(), "Invalid curve"), W(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    B.PresetCurve = J;
    function ne(ce, re) {
      Object.defineProperty(B, ce, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var oe = new J(re);
          return Object.defineProperty(B, ce, {
            configurable: !0,
            enumerable: !0,
            value: oe
          }), oe;
        }
      });
    }
    ne("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: L.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), ne("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: L.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), ne("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: L.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), ne("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: L.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), ne("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: L.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), ne("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), ne("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ie;
    try {
      ie = requireSecp256k1();
    } catch {
      ie = void 0;
    }
    ne("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: L.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ie
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var A = requireHash(), B = requireUtils$2(), L = requireMinimalisticAssert();
  function K(V) {
    if (!(this instanceof K))
      return new K(V);
    this.hash = V.hash, this.predResist = !!V.predResist, this.outLen = this.hash.outSize, this.minEntropy = V.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var W = B.toArray(V.entropy, V.entropyEnc || "hex"), J = B.toArray(V.nonce, V.nonceEnc || "hex"), ne = B.toArray(V.pers, V.persEnc || "hex");
    L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(W, J, ne);
  }
  return hmacDrbg = K, K.prototype._init = function(W, J, ne) {
    var ie = W.concat(J).concat(ne);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ce = 0; ce < this.V.length; ce++)
      this.K[ce] = 0, this.V[ce] = 1;
    this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, K.prototype._hmac = function() {
    return new A.hmac(this.hash, this.K);
  }, K.prototype._update = function(W) {
    var J = this._hmac().update(this.V).update([0]);
    W && (J = J.update(W)), this.K = J.digest(), this.V = this._hmac().update(this.V).digest(), W && (this.K = this._hmac().update(this.V).update([1]).update(W).digest(), this.V = this._hmac().update(this.V).digest());
  }, K.prototype.reseed = function(W, J, ne, ie) {
    typeof J != "string" && (ie = ne, ne = J, J = null), W = B.toArray(W, J), ne = B.toArray(ne, ie), L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(W.concat(ne || [])), this._reseed = 1;
  }, K.prototype.generate = function(W, J, ne, ie) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof J != "string" && (ie = ne, ne = J, J = null), ne && (ne = B.toArray(ne, ie || "hex"), this._update(ne));
    for (var ce = []; ce.length < W; )
      this.V = this._hmac().update(this.V).digest(), ce = ce.concat(this.V);
    var re = ce.slice(0, W);
    return this._update(ne), this._reseed++, B.encode(re, J);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(V, W) {
    this.ec = V, this.priv = null, this.pub = null, W.priv && this._importPrivate(W.priv, W.privEnc), W.pub && this._importPublic(W.pub, W.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(W, J, ne) {
    return J instanceof K ? J : new K(W, {
      pub: J,
      pubEnc: ne
    });
  }, K.fromPrivate = function(W, J, ne) {
    return J instanceof K ? J : new K(W, {
      priv: J,
      privEnc: ne
    });
  }, K.prototype.validate = function() {
    var W = this.getPublic();
    return W.isInfinity() ? { result: !1, reason: "Invalid public key" } : W.validate() ? W.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(W, J) {
    return typeof W == "string" && (J = W, W = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), J ? this.pub.encode(J, W) : this.pub;
  }, K.prototype.getPrivate = function(W) {
    return W === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(W, J) {
    this.priv = new A(W, J || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(W, J) {
    if (W.x || W.y) {
      this.ec.curve.type === "mont" ? L(W.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && L(W.x && W.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(W.x, W.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(W, J);
  }, K.prototype.derive = function(W) {
    return W.validate() || L(W.validate(), "public point not validated"), W.mul(this.priv).getX();
  }, K.prototype.sign = function(W, J, ne) {
    return this.ec.sign(W, this, J, ne);
  }, K.prototype.verify = function(W, J, ne) {
    return this.ec.verify(W, J, this, void 0, ne);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(ie, ce) {
    if (ie instanceof K)
      return ie;
    this._importDER(ie, ce) || (L(ie.r && ie.s, "Signature without r or s"), this.r = new A(ie.r, 16), this.s = new A(ie.s, 16), ie.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ie.recoveryParam);
  }
  signature$1 = K;
  function V() {
    this.place = 0;
  }
  function W(ie, ce) {
    var re = ie[ce.place++];
    if (!(re & 128))
      return re;
    var oe = re & 15;
    if (oe === 0 || oe > 4 || ie[ce.place] === 0)
      return !1;
    for (var ke = 0, Ce = 0, it = ce.place; Ce < oe; Ce++, it++)
      ke <<= 8, ke |= ie[it], ke >>>= 0;
    return ke <= 127 ? !1 : (ce.place = it, ke);
  }
  function J(ie) {
    for (var ce = 0, re = ie.length - 1; !ie[ce] && !(ie[ce + 1] & 128) && ce < re; )
      ce++;
    return ce === 0 ? ie : ie.slice(ce);
  }
  K.prototype._importDER = function(ce, re) {
    ce = B.toArray(ce, re);
    var oe = new V();
    if (ce[oe.place++] !== 48)
      return !1;
    var ke = W(ce, oe);
    if (ke === !1 || ke + oe.place !== ce.length || ce[oe.place++] !== 2)
      return !1;
    var Ce = W(ce, oe);
    if (Ce === !1 || ce[oe.place] & 128)
      return !1;
    var it = ce.slice(oe.place, Ce + oe.place);
    if (oe.place += Ce, ce[oe.place++] !== 2)
      return !1;
    var at = W(ce, oe);
    if (at === !1 || ce.length !== at + oe.place || ce[oe.place] & 128)
      return !1;
    var ct = ce.slice(oe.place, at + oe.place);
    if (it[0] === 0)
      if (it[1] & 128)
        it = it.slice(1);
      else
        return !1;
    if (ct[0] === 0)
      if (ct[1] & 128)
        ct = ct.slice(1);
      else
        return !1;
    return this.r = new A(it), this.s = new A(ct), this.recoveryParam = null, !0;
  };
  function ne(ie, ce) {
    if (ce < 128) {
      ie.push(ce);
      return;
    }
    var re = 1 + (Math.log(ce) / Math.LN2 >>> 3);
    for (ie.push(re | 128); --re; )
      ie.push(ce >>> (re << 3) & 255);
    ie.push(ce);
  }
  return K.prototype.toDER = function(ce) {
    var re = this.r.toArray(), oe = this.s.toArray();
    for (re[0] & 128 && (re = [0].concat(re)), oe[0] & 128 && (oe = [0].concat(oe)), re = J(re), oe = J(oe); !oe[0] && !(oe[1] & 128); )
      oe = oe.slice(1);
    var ke = [2];
    ne(ke, re.length), ke = ke.concat(re), ke.push(2), ne(ke, oe.length);
    var Ce = ke.concat(oe), it = [48];
    return ne(it, Ce.length), it = it.concat(Ce), B.encode(it, ce);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var A = requireBn$1(), B = requireHmacDrbg(), L = requireUtils$1(), K = requireCurves(), V = requireBrorand(), W = L.assert, J = requireKey$1(), ne = requireSignature$1();
  function ie(ce) {
    if (!(this instanceof ie))
      return new ie(ce);
    typeof ce == "string" && (W(
      Object.prototype.hasOwnProperty.call(K, ce),
      "Unknown curve " + ce
    ), ce = K[ce]), ce instanceof K.PresetCurve && (ce = { curve: ce }), this.curve = ce.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ce.curve.g, this.g.precompute(ce.curve.n.bitLength() + 1), this.hash = ce.hash || ce.curve.hash;
  }
  return ec = ie, ie.prototype.keyPair = function(re) {
    return new J(this, re);
  }, ie.prototype.keyFromPrivate = function(re, oe) {
    return J.fromPrivate(this, re, oe);
  }, ie.prototype.keyFromPublic = function(re, oe) {
    return J.fromPublic(this, re, oe);
  }, ie.prototype.genKeyPair = function(re) {
    re || (re = {});
    for (var oe = new B({
      hash: this.hash,
      pers: re.pers,
      persEnc: re.persEnc || "utf8",
      entropy: re.entropy || V(this.hash.hmacStrength),
      entropyEnc: re.entropy && re.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), ke = this.n.byteLength(), Ce = this.n.sub(new A(2)); ; ) {
      var it = new A(oe.generate(ke));
      if (!(it.cmp(Ce) > 0))
        return it.iaddn(1), this.keyFromPrivate(it);
    }
  }, ie.prototype._truncateToN = function(re, oe, ke) {
    var Ce;
    if (A.isBN(re) || typeof re == "number")
      re = new A(re, 16), Ce = re.byteLength();
    else if (typeof re == "object")
      Ce = re.length, re = new A(re, 16);
    else {
      var it = re.toString();
      Ce = it.length + 1 >>> 1, re = new A(it, 16);
    }
    typeof ke != "number" && (ke = Ce * 8);
    var at = ke - this.n.bitLength();
    return at > 0 && (re = re.ushrn(at)), !oe && re.cmp(this.n) >= 0 ? re.sub(this.n) : re;
  }, ie.prototype.sign = function(re, oe, ke, Ce) {
    if (typeof ke == "object" && (Ce = ke, ke = null), Ce || (Ce = {}), typeof re != "string" && typeof re != "number" && !A.isBN(re)) {
      W(
        typeof re == "object" && re && typeof re.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), W(re.length >>> 0 === re.length);
      for (var it = 0; it < re.length; it++) W((re[it] & 255) === re[it]);
    }
    oe = this.keyFromPrivate(oe, ke), re = this._truncateToN(re, !1, Ce.msgBitLength), W(!re.isNeg(), "Can not sign a negative message");
    var at = this.n.byteLength(), ct = oe.getPrivate().toArray("be", at), dt = re.toArray("be", at);
    W(new A(dt).eq(re), "Can not sign message");
    for (var ot = new B({
      hash: this.hash,
      entropy: ct,
      nonce: dt,
      pers: Ce.pers,
      persEnc: Ce.persEnc || "utf8"
    }), yt = this.n.sub(new A(1)), mt = 0; ; mt++) {
      var Tt = Ce.k ? Ce.k(mt) : new A(ot.generate(this.n.byteLength()));
      if (Tt = this._truncateToN(Tt, !0), !(Tt.cmpn(1) <= 0 || Tt.cmp(yt) >= 0)) {
        var Pt = this.g.mul(Tt);
        if (!Pt.isInfinity()) {
          var Nt = Pt.getX(), St = Nt.umod(this.n);
          if (St.cmpn(0) !== 0) {
            var vt = Tt.invm(this.n).mul(St.mul(oe.getPrivate()).iadd(re));
            if (vt = vt.umod(this.n), vt.cmpn(0) !== 0) {
              var It = (Pt.getY().isOdd() ? 1 : 0) | (Nt.cmp(St) !== 0 ? 2 : 0);
              return Ce.canonical && vt.cmp(this.nh) > 0 && (vt = this.n.sub(vt), It ^= 1), new ne({ r: St, s: vt, recoveryParam: It });
            }
          }
        }
      }
    }
  }, ie.prototype.verify = function(re, oe, ke, Ce, it) {
    it || (it = {}), re = this._truncateToN(re, !1, it.msgBitLength), ke = this.keyFromPublic(ke, Ce), oe = new ne(oe, "hex");
    var at = oe.r, ct = oe.s;
    if (at.cmpn(1) < 0 || at.cmp(this.n) >= 0 || ct.cmpn(1) < 0 || ct.cmp(this.n) >= 0)
      return !1;
    var dt = ct.invm(this.n), ot = dt.mul(re).umod(this.n), yt = dt.mul(at).umod(this.n), mt;
    return this.curve._maxwellTrick ? (mt = this.g.jmulAdd(ot, ke.getPublic(), yt), mt.isInfinity() ? !1 : mt.eqXToP(at)) : (mt = this.g.mulAdd(ot, ke.getPublic(), yt), mt.isInfinity() ? !1 : mt.getX().umod(this.n).cmp(at) === 0);
  }, ie.prototype.recoverPubKey = function(ce, re, oe, ke) {
    W((3 & oe) === oe, "The recovery param is more than two bits"), re = new ne(re, ke);
    var Ce = this.n, it = new A(ce), at = re.r, ct = re.s, dt = oe & 1, ot = oe >> 1;
    if (at.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ot)
      throw new Error("Unable to find sencond key candinate");
    ot ? at = this.curve.pointFromX(at.add(this.curve.n), dt) : at = this.curve.pointFromX(at, dt);
    var yt = re.r.invm(Ce), mt = Ce.sub(it).mul(yt).umod(Ce), Tt = ct.mul(yt).umod(Ce);
    return this.g.mulAdd(mt, at, Tt);
  }, ie.prototype.getKeyRecoveryParam = function(ce, re, oe, ke) {
    if (re = new ne(re, ke), re.recoveryParam !== null)
      return re.recoveryParam;
    for (var Ce = 0; Ce < 4; Ce++) {
      var it;
      try {
        it = this.recoverPubKey(ce, re, Ce);
      } catch {
        continue;
      }
      if (it.eq(oe))
        return Ce;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var A = requireUtils$1(), B = A.assert, L = A.parseBytes, K = A.cachedProperty;
  function V(W, J) {
    this.eddsa = W, this._secret = L(J.secret), W.isPoint(J.pub) ? this._pub = J.pub : this._pubBytes = L(J.pub);
  }
  return V.fromPublic = function(J, ne) {
    return ne instanceof V ? ne : new V(J, { pub: ne });
  }, V.fromSecret = function(J, ne) {
    return ne instanceof V ? ne : new V(J, { secret: ne });
  }, V.prototype.secret = function() {
    return this._secret;
  }, K(V, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), K(V, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), K(V, "privBytes", function() {
    var J = this.eddsa, ne = this.hash(), ie = J.encodingLength - 1, ce = ne.slice(0, J.encodingLength);
    return ce[0] &= 248, ce[ie] &= 127, ce[ie] |= 64, ce;
  }), K(V, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), K(V, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), K(V, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), V.prototype.sign = function(J) {
    return B(this._secret, "KeyPair can only verify"), this.eddsa.sign(J, this);
  }, V.prototype.verify = function(J, ne) {
    return this.eddsa.verify(J, ne, this);
  }, V.prototype.getSecret = function(J) {
    return B(this._secret, "KeyPair is public only"), A.encode(this.secret(), J);
  }, V.prototype.getPublic = function(J) {
    return A.encode(this.pubBytes(), J);
  }, key = V, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert, K = B.cachedProperty, V = B.parseBytes;
  function W(J, ne) {
    this.eddsa = J, typeof ne != "object" && (ne = V(ne)), Array.isArray(ne) && (L(ne.length === J.encodingLength * 2, "Signature has invalid size"), ne = {
      R: ne.slice(0, J.encodingLength),
      S: ne.slice(J.encodingLength)
    }), L(ne.R && ne.S, "Signature without R or S"), J.isPoint(ne.R) && (this._R = ne.R), ne.S instanceof A && (this._S = ne.S), this._Rencoded = Array.isArray(ne.R) ? ne.R : ne.Rencoded, this._Sencoded = Array.isArray(ne.S) ? ne.S : ne.Sencoded;
  }
  return K(W, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), K(W, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), K(W, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), K(W, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), W.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, W.prototype.toHex = function() {
    return B.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = W, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var A = requireHash(), B = requireCurves(), L = requireUtils$1(), K = L.assert, V = L.parseBytes, W = requireKey(), J = requireSignature();
  function ne(ie) {
    if (K(ie === "ed25519", "only tested with ed25519 so far"), !(this instanceof ne))
      return new ne(ie);
    ie = B[ie].curve, this.curve = ie, this.g = ie.g, this.g.precompute(ie.n.bitLength() + 1), this.pointClass = ie.point().constructor, this.encodingLength = Math.ceil(ie.n.bitLength() / 8), this.hash = A.sha512;
  }
  return eddsa = ne, ne.prototype.sign = function(ce, re) {
    ce = V(ce);
    var oe = this.keyFromSecret(re), ke = this.hashInt(oe.messagePrefix(), ce), Ce = this.g.mul(ke), it = this.encodePoint(Ce), at = this.hashInt(it, oe.pubBytes(), ce).mul(oe.priv()), ct = ke.add(at).umod(this.curve.n);
    return this.makeSignature({ R: Ce, S: ct, Rencoded: it });
  }, ne.prototype.verify = function(ce, re, oe) {
    if (ce = V(ce), re = this.makeSignature(re), re.S().gte(re.eddsa.curve.n) || re.S().isNeg())
      return !1;
    var ke = this.keyFromPublic(oe), Ce = this.hashInt(re.Rencoded(), ke.pubBytes(), ce), it = this.g.mul(re.S()), at = re.R().add(ke.pub().mul(Ce));
    return at.eq(it);
  }, ne.prototype.hashInt = function() {
    for (var ce = this.hash(), re = 0; re < arguments.length; re++)
      ce.update(arguments[re]);
    return L.intFromLE(ce.digest()).umod(this.curve.n);
  }, ne.prototype.keyFromPublic = function(ce) {
    return W.fromPublic(this, ce);
  }, ne.prototype.keyFromSecret = function(ce) {
    return W.fromSecret(this, ce);
  }, ne.prototype.makeSignature = function(ce) {
    return ce instanceof J ? ce : new J(this, ce);
  }, ne.prototype.encodePoint = function(ce) {
    var re = ce.getY().toArray("le", this.encodingLength);
    return re[this.encodingLength - 1] |= ce.getX().isOdd() ? 128 : 0, re;
  }, ne.prototype.decodePoint = function(ce) {
    ce = L.parseBytes(ce);
    var re = ce.length - 1, oe = ce.slice(0, re).concat(ce[re] & -129), ke = (ce[re] & 128) !== 0, Ce = L.intFromLE(oe);
    return this.curve.pointFromY(Ce, ke);
  }, ne.prototype.encodeInt = function(ce) {
    return ce.toArray("le", this.encodingLength);
  }, ne.prototype.decodeInt = function(ce) {
    return L.intFromLE(ce);
  }, ne.prototype.isPoint = function(ce) {
    return ce instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(A) {
    var B = A;
    B.version = require$$0.version, B.utils = requireUtils$1(), B.rand = requireBrorand(), B.curve = requireCurve(), B.curves = requireCurves(), B.ec = requireEc(), B.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(A, B) {
      if (A.indexOf) return A.indexOf(B);
      for (var L = 0; L < A.length; L++)
        if (A[L] === B) return L;
      return -1;
    }, Object_keys = function(A) {
      if (Object.keys) return Object.keys(A);
      var B = [];
      for (var L in A) B.push(L);
      return B;
    }, forEach = function(A, B) {
      if (A.forEach) return A.forEach(B);
      for (var L = 0; L < A.length; L++)
        B(A[L], L, A);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(A, B, L) {
          Object.defineProperty(A, B, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: L
          });
        };
      } catch {
        return function(B, L, K) {
          B[L] = K;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(A) {
      if (!(A instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var B = document.createElement("iframe");
      B.style || (B.style = {}), B.style.display = "none", document.body.appendChild(B);
      var L = B.contentWindow, K = L.eval, V = L.execScript;
      !K && V && (V.call(L, "null"), K = L.eval), forEach(Object_keys(A), function(ne) {
        L[ne] = A[ne];
      }), forEach(globals, function(ne) {
        A[ne] && (L[ne] = A[ne]);
      });
      var W = Object_keys(L), J = K.call(L, this.code);
      return forEach(Object_keys(L), function(ne) {
        (ne in A || indexOf(W, ne) === -1) && (A[ne] = L[ne]);
      }), forEach(globals, function(ne) {
        ne in A || defineProp(A, ne, L[ne]);
      }), document.body.removeChild(B), J;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(A) {
      var B = Script.createContext(A), L = this.runInContext(B);
      return A && forEach(Object_keys(B), function(K) {
        A[K] = B[K];
      }), L;
    }, forEach(Object_keys(Script.prototype), function(A) {
      exports[A] = Script[A] = function(B) {
        var L = Script(B);
        return L[A].apply(L, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(A) {
      return A instanceof Context;
    }, exports.createScript = function(A) {
      return exports.Script(A);
    }, exports.createContext = Script.createContext = function(A) {
      var B = new Context();
      return typeof A == "object" && forEach(Object_keys(A), function(L) {
        B[L] = A[L];
      }), B;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(A) {
    var B = requireAsn1$1(), L = requireInherits_browser(), K = A;
    K.define = function(J, ne) {
      return new V(J, ne);
    };
    function V(W, J) {
      this.name = W, this.body = J, this.decoders = {}, this.encoders = {};
    }
    V.prototype._createNamed = function(J) {
      var ne;
      try {
        ne = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ne = function(ce) {
          this._initNamed(ce);
        };
      }
      return L(ne, J), ne.prototype._initNamed = function(ce) {
        J.call(this, ce);
      }, new ne(this);
    }, V.prototype._getDecoder = function(J) {
      return J = J || "der", this.decoders.hasOwnProperty(J) || (this.decoders[J] = this._createNamed(B.decoders[J])), this.decoders[J];
    }, V.prototype.decode = function(J, ne, ie) {
      return this._getDecoder(ne).decode(J, ie);
    }, V.prototype._getEncoder = function(J) {
      return J = J || "der", this.encoders.hasOwnProperty(J) || (this.encoders[J] = this._createNamed(B.encoders[J])), this.encoders[J];
    }, V.prototype.encode = function(J, ne, ie) {
      return this._getEncoder(ne).encode(J, ie);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var A = requireInherits_browser();
  function B(K) {
    this._reporterState = {
      obj: null,
      path: [],
      options: K || {},
      errors: []
    };
  }
  reporter.Reporter = B, B.prototype.isError = function(V) {
    return V instanceof L;
  }, B.prototype.save = function() {
    var V = this._reporterState;
    return { obj: V.obj, pathLen: V.path.length };
  }, B.prototype.restore = function(V) {
    var W = this._reporterState;
    W.obj = V.obj, W.path = W.path.slice(0, V.pathLen);
  }, B.prototype.enterKey = function(V) {
    return this._reporterState.path.push(V);
  }, B.prototype.exitKey = function(V) {
    var W = this._reporterState;
    W.path = W.path.slice(0, V - 1);
  }, B.prototype.leaveKey = function(V, W, J) {
    var ne = this._reporterState;
    this.exitKey(V), ne.obj !== null && (ne.obj[W] = J);
  }, B.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, B.prototype.enterObject = function() {
    var V = this._reporterState, W = V.obj;
    return V.obj = {}, W;
  }, B.prototype.leaveObject = function(V) {
    var W = this._reporterState, J = W.obj;
    return W.obj = V, J;
  }, B.prototype.error = function(V) {
    var W, J = this._reporterState, ne = V instanceof L;
    if (ne ? W = V : W = new L(J.path.map(function(ie) {
      return "[" + JSON.stringify(ie) + "]";
    }).join(""), V.message || V, V.stack), !J.options.partial)
      throw W;
    return ne || J.errors.push(W), W;
  }, B.prototype.wrapResult = function(V) {
    var W = this._reporterState;
    return W.options.partial ? {
      result: this.isError(V) ? null : V,
      errors: W.errors
    } : V;
  };
  function L(K, V) {
    this.path = K, this.rethrow(V);
  }
  return A(L, Error), L.prototype.rethrow = function(V) {
    if (this.message = V + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, L), !this.stack)
      try {
        throw new Error(this.message);
      } catch (W) {
        this.stack = W.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var A = requireInherits_browser(), B = requireBase().Reporter, L = dist$1.Buffer;
  function K(W, J) {
    if (B.call(this, J), !L.isBuffer(W)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = W, this.offset = 0, this.length = W.length;
  }
  A(K, B), buffer.DecoderBuffer = K, K.prototype.save = function() {
    return { offset: this.offset, reporter: B.prototype.save.call(this) };
  }, K.prototype.restore = function(J) {
    var ne = new K(this.base);
    return ne.offset = J.offset, ne.length = this.offset, this.offset = J.offset, B.prototype.restore.call(this, J.reporter), ne;
  }, K.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, K.prototype.readUInt8 = function(J) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(J || "DecoderBuffer overrun");
  }, K.prototype.skip = function(J, ne) {
    if (!(this.offset + J <= this.length))
      return this.error(ne || "DecoderBuffer overrun");
    var ie = new K(this.base);
    return ie._reporterState = this._reporterState, ie.offset = this.offset, ie.length = this.offset + J, this.offset += J, ie;
  }, K.prototype.raw = function(J) {
    return this.base.slice(J ? J.offset : this.offset, this.length);
  };
  function V(W, J) {
    if (Array.isArray(W))
      this.length = 0, this.value = W.map(function(ne) {
        return ne instanceof V || (ne = new V(ne, J)), this.length += ne.length, ne;
      }, this);
    else if (typeof W == "number") {
      if (!(0 <= W && W <= 255))
        return J.error("non-byte EncoderBuffer value");
      this.value = W, this.length = 1;
    } else if (typeof W == "string")
      this.value = W, this.length = L.byteLength(W);
    else if (L.isBuffer(W))
      this.value = W, this.length = W.length;
    else
      return J.error("Unsupported type: " + typeof W);
  }
  return buffer.EncoderBuffer = V, V.prototype.join = function(J, ne) {
    return J || (J = new L(this.length)), ne || (ne = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ie) {
      ie.join(J, ne), ne += ie.length;
    }) : (typeof this.value == "number" ? J[ne] = this.value : typeof this.value == "string" ? J.write(this.value, ne) : L.isBuffer(this.value) && this.value.copy(J, ne), ne += this.length)), J;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var A = requireBase().Reporter, B = requireBase().EncoderBuffer, L = requireBase().DecoderBuffer, K = requireMinimalisticAssert(), V = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], W = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(V), J = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ne(ce, re) {
    var oe = {};
    this._baseState = oe, oe.enc = ce, oe.parent = re || null, oe.children = null, oe.tag = null, oe.args = null, oe.reverseArgs = null, oe.choice = null, oe.optional = !1, oe.any = !1, oe.obj = !1, oe.use = null, oe.useDecoder = null, oe.key = null, oe.default = null, oe.explicit = null, oe.implicit = null, oe.contains = null, oe.parent || (oe.children = [], this._wrap());
  }
  node = ne;
  var ie = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ne.prototype.clone = function() {
    var re = this._baseState, oe = {};
    ie.forEach(function(Ce) {
      oe[Ce] = re[Ce];
    });
    var ke = new this.constructor(oe.parent);
    return ke._baseState = oe, ke;
  }, ne.prototype._wrap = function() {
    var re = this._baseState;
    W.forEach(function(oe) {
      this[oe] = function() {
        var Ce = new this.constructor(this);
        return re.children.push(Ce), Ce[oe].apply(Ce, arguments);
      };
    }, this);
  }, ne.prototype._init = function(re) {
    var oe = this._baseState;
    K(oe.parent === null), re.call(this), oe.children = oe.children.filter(function(ke) {
      return ke._baseState.parent === this;
    }, this), K.equal(oe.children.length, 1, "Root node can have only one child");
  }, ne.prototype._useArgs = function(re) {
    var oe = this._baseState, ke = re.filter(function(Ce) {
      return Ce instanceof this.constructor;
    }, this);
    re = re.filter(function(Ce) {
      return !(Ce instanceof this.constructor);
    }, this), ke.length !== 0 && (K(oe.children === null), oe.children = ke, ke.forEach(function(Ce) {
      Ce._baseState.parent = this;
    }, this)), re.length !== 0 && (K(oe.args === null), oe.args = re, oe.reverseArgs = re.map(function(Ce) {
      if (typeof Ce != "object" || Ce.constructor !== Object)
        return Ce;
      var it = {};
      return Object.keys(Ce).forEach(function(at) {
        at == (at | 0) && (at |= 0);
        var ct = Ce[at];
        it[ct] = at;
      }), it;
    }));
  }, J.forEach(function(ce) {
    ne.prototype[ce] = function() {
      var oe = this._baseState;
      throw new Error(ce + " not implemented for encoding: " + oe.enc);
    };
  }), V.forEach(function(ce) {
    ne.prototype[ce] = function() {
      var oe = this._baseState, ke = Array.prototype.slice.call(arguments);
      return K(oe.tag === null), oe.tag = ce, this._useArgs(ke), this;
    };
  }), ne.prototype.use = function(re) {
    K(re);
    var oe = this._baseState;
    return K(oe.use === null), oe.use = re, this;
  }, ne.prototype.optional = function() {
    var re = this._baseState;
    return re.optional = !0, this;
  }, ne.prototype.def = function(re) {
    var oe = this._baseState;
    return K(oe.default === null), oe.default = re, oe.optional = !0, this;
  }, ne.prototype.explicit = function(re) {
    var oe = this._baseState;
    return K(oe.explicit === null && oe.implicit === null), oe.explicit = re, this;
  }, ne.prototype.implicit = function(re) {
    var oe = this._baseState;
    return K(oe.explicit === null && oe.implicit === null), oe.implicit = re, this;
  }, ne.prototype.obj = function() {
    var re = this._baseState, oe = Array.prototype.slice.call(arguments);
    return re.obj = !0, oe.length !== 0 && this._useArgs(oe), this;
  }, ne.prototype.key = function(re) {
    var oe = this._baseState;
    return K(oe.key === null), oe.key = re, this;
  }, ne.prototype.any = function() {
    var re = this._baseState;
    return re.any = !0, this;
  }, ne.prototype.choice = function(re) {
    var oe = this._baseState;
    return K(oe.choice === null), oe.choice = re, this._useArgs(Object.keys(re).map(function(ke) {
      return re[ke];
    })), this;
  }, ne.prototype.contains = function(re) {
    var oe = this._baseState;
    return K(oe.use === null), oe.contains = re, this;
  }, ne.prototype._decode = function(re, oe) {
    var ke = this._baseState;
    if (ke.parent === null)
      return re.wrapResult(ke.children[0]._decode(re, oe));
    var Ce = ke.default, it = !0, at = null;
    if (ke.key !== null && (at = re.enterKey(ke.key)), ke.optional) {
      var ct = null;
      if (ke.explicit !== null ? ct = ke.explicit : ke.implicit !== null ? ct = ke.implicit : ke.tag !== null && (ct = ke.tag), ct === null && !ke.any) {
        var dt = re.save();
        try {
          ke.choice === null ? this._decodeGeneric(ke.tag, re, oe) : this._decodeChoice(re, oe), it = !0;
        } catch {
          it = !1;
        }
        re.restore(dt);
      } else if (it = this._peekTag(re, ct, ke.any), re.isError(it))
        return it;
    }
    var ot;
    if (ke.obj && it && (ot = re.enterObject()), it) {
      if (ke.explicit !== null) {
        var yt = this._decodeTag(re, ke.explicit);
        if (re.isError(yt))
          return yt;
        re = yt;
      }
      var mt = re.offset;
      if (ke.use === null && ke.choice === null) {
        if (ke.any)
          var dt = re.save();
        var Tt = this._decodeTag(
          re,
          ke.implicit !== null ? ke.implicit : ke.tag,
          ke.any
        );
        if (re.isError(Tt))
          return Tt;
        ke.any ? Ce = re.raw(dt) : re = Tt;
      }
      if (oe && oe.track && ke.tag !== null && oe.track(re.path(), mt, re.length, "tagged"), oe && oe.track && ke.tag !== null && oe.track(re.path(), re.offset, re.length, "content"), ke.any ? Ce = Ce : ke.choice === null ? Ce = this._decodeGeneric(ke.tag, re, oe) : Ce = this._decodeChoice(re, oe), re.isError(Ce))
        return Ce;
      if (!ke.any && ke.choice === null && ke.children !== null && ke.children.forEach(function(St) {
        St._decode(re, oe);
      }), ke.contains && (ke.tag === "octstr" || ke.tag === "bitstr")) {
        var Pt = new L(Ce);
        Ce = this._getUse(ke.contains, re._reporterState.obj)._decode(Pt, oe);
      }
    }
    return ke.obj && it && (Ce = re.leaveObject(ot)), ke.key !== null && (Ce !== null || it === !0) ? re.leaveKey(at, ke.key, Ce) : at !== null && re.exitKey(at), Ce;
  }, ne.prototype._decodeGeneric = function(re, oe, ke) {
    var Ce = this._baseState;
    return re === "seq" || re === "set" ? null : re === "seqof" || re === "setof" ? this._decodeList(oe, re, Ce.args[0], ke) : /str$/.test(re) ? this._decodeStr(oe, re, ke) : re === "objid" && Ce.args ? this._decodeObjid(oe, Ce.args[0], Ce.args[1], ke) : re === "objid" ? this._decodeObjid(oe, null, null, ke) : re === "gentime" || re === "utctime" ? this._decodeTime(oe, re, ke) : re === "null_" ? this._decodeNull(oe, ke) : re === "bool" ? this._decodeBool(oe, ke) : re === "objDesc" ? this._decodeStr(oe, re, ke) : re === "int" || re === "enum" ? this._decodeInt(oe, Ce.args && Ce.args[0], ke) : Ce.use !== null ? this._getUse(Ce.use, oe._reporterState.obj)._decode(oe, ke) : oe.error("unknown tag: " + re);
  }, ne.prototype._getUse = function(re, oe) {
    var ke = this._baseState;
    return ke.useDecoder = this._use(re, oe), K(ke.useDecoder._baseState.parent === null), ke.useDecoder = ke.useDecoder._baseState.children[0], ke.implicit !== ke.useDecoder._baseState.implicit && (ke.useDecoder = ke.useDecoder.clone(), ke.useDecoder._baseState.implicit = ke.implicit), ke.useDecoder;
  }, ne.prototype._decodeChoice = function(re, oe) {
    var ke = this._baseState, Ce = null, it = !1;
    return Object.keys(ke.choice).some(function(at) {
      var ct = re.save(), dt = ke.choice[at];
      try {
        var ot = dt._decode(re, oe);
        if (re.isError(ot))
          return !1;
        Ce = { type: at, value: ot }, it = !0;
      } catch {
        return re.restore(ct), !1;
      }
      return !0;
    }, this), it ? Ce : re.error("Choice not matched");
  }, ne.prototype._createEncoderBuffer = function(re) {
    return new B(re, this.reporter);
  }, ne.prototype._encode = function(re, oe, ke) {
    var Ce = this._baseState;
    if (!(Ce.default !== null && Ce.default === re)) {
      var it = this._encodeValue(re, oe, ke);
      if (it !== void 0 && !this._skipDefault(it, oe, ke))
        return it;
    }
  }, ne.prototype._encodeValue = function(re, oe, ke) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return Ce.children[0]._encode(re, oe || new A());
    var dt = null;
    if (this.reporter = oe, Ce.optional && re === void 0)
      if (Ce.default !== null)
        re = Ce.default;
      else
        return;
    var it = null, at = !1;
    if (Ce.any)
      dt = this._createEncoderBuffer(re);
    else if (Ce.choice)
      dt = this._encodeChoice(re, oe);
    else if (Ce.contains)
      it = this._getUse(Ce.contains, ke)._encode(re, oe), at = !0;
    else if (Ce.children)
      it = Ce.children.map(function(mt) {
        if (mt._baseState.tag === "null_")
          return mt._encode(null, oe, re);
        if (mt._baseState.key === null)
          return oe.error("Child should have a key");
        var Tt = oe.enterKey(mt._baseState.key);
        if (typeof re != "object")
          return oe.error("Child expected, but input is not object");
        var Pt = mt._encode(re[mt._baseState.key], oe, re);
        return oe.leaveKey(Tt), Pt;
      }, this).filter(function(mt) {
        return mt;
      }), it = this._createEncoderBuffer(it);
    else if (Ce.tag === "seqof" || Ce.tag === "setof") {
      if (!(Ce.args && Ce.args.length === 1))
        return oe.error("Too many args for : " + Ce.tag);
      if (!Array.isArray(re))
        return oe.error("seqof/setof, but data is not Array");
      var ct = this.clone();
      ct._baseState.implicit = null, it = this._createEncoderBuffer(re.map(function(mt) {
        var Tt = this._baseState;
        return this._getUse(Tt.args[0], re)._encode(mt, oe);
      }, ct));
    } else Ce.use !== null ? dt = this._getUse(Ce.use, ke)._encode(re, oe) : (it = this._encodePrimitive(Ce.tag, re), at = !0);
    var dt;
    if (!Ce.any && Ce.choice === null) {
      var ot = Ce.implicit !== null ? Ce.implicit : Ce.tag, yt = Ce.implicit === null ? "universal" : "context";
      ot === null ? Ce.use === null && oe.error("Tag could be omitted only for .use()") : Ce.use === null && (dt = this._encodeComposite(ot, at, yt, it));
    }
    return Ce.explicit !== null && (dt = this._encodeComposite(Ce.explicit, !1, "context", dt)), dt;
  }, ne.prototype._encodeChoice = function(re, oe) {
    var ke = this._baseState, Ce = ke.choice[re.type];
    return Ce || K(
      !1,
      re.type + " not found in " + JSON.stringify(Object.keys(ke.choice))
    ), Ce._encode(re.value, oe);
  }, ne.prototype._encodePrimitive = function(re, oe) {
    var ke = this._baseState;
    if (/str$/.test(re))
      return this._encodeStr(oe, re);
    if (re === "objid" && ke.args)
      return this._encodeObjid(oe, ke.reverseArgs[0], ke.args[1]);
    if (re === "objid")
      return this._encodeObjid(oe, null, null);
    if (re === "gentime" || re === "utctime")
      return this._encodeTime(oe, re);
    if (re === "null_")
      return this._encodeNull();
    if (re === "int" || re === "enum")
      return this._encodeInt(oe, ke.args && ke.reverseArgs[0]);
    if (re === "bool")
      return this._encodeBool(oe);
    if (re === "objDesc")
      return this._encodeStr(oe, re);
    throw new Error("Unsupported tag: " + re);
  }, ne.prototype._isNumstr = function(re) {
    return /^[0-9 ]*$/.test(re);
  }, ne.prototype._isPrintstr = function(re) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(re);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(A) {
    var B = A;
    B.Reporter = requireReporter().Reporter, B.DecoderBuffer = requireBuffer().DecoderBuffer, B.EncoderBuffer = requireBuffer().EncoderBuffer, B.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(A) {
    var B = requireConstants();
    A.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, A.tagClassByName = B._reverse(A.tagClass), A.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, A.tagByName = B._reverse(A.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(A) {
    var B = A;
    B._reverse = function(K) {
      var V = {};
      return Object.keys(K).forEach(function(W) {
        (W | 0) == W && (W = W | 0);
        var J = K[W];
        V[J] = W;
      }), V;
    }, B.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var A = requireInherits_browser(), B = requireAsn1$1(), L = B.base, K = B.bignum, V = B.constants.der;
  function W(ce) {
    this.enc = "der", this.name = ce.name, this.entity = ce, this.tree = new J(), this.tree._init(ce.body);
  }
  der_1$1 = W, W.prototype.decode = function(re, oe) {
    return re instanceof L.DecoderBuffer || (re = new L.DecoderBuffer(re, oe)), this.tree._decode(re, oe);
  };
  function J(ce) {
    L.Node.call(this, "der", ce);
  }
  A(J, L.Node), J.prototype._peekTag = function(re, oe, ke) {
    if (re.isEmpty())
      return !1;
    var Ce = re.save(), it = ne(re, 'Failed to peek tag: "' + oe + '"');
    return re.isError(it) ? it : (re.restore(Ce), it.tag === oe || it.tagStr === oe || it.tagStr + "of" === oe || ke);
  }, J.prototype._decodeTag = function(re, oe, ke) {
    var Ce = ne(
      re,
      'Failed to decode tag of "' + oe + '"'
    );
    if (re.isError(Ce))
      return Ce;
    var it = ie(
      re,
      Ce.primitive,
      'Failed to get length of "' + oe + '"'
    );
    if (re.isError(it))
      return it;
    if (!ke && Ce.tag !== oe && Ce.tagStr !== oe && Ce.tagStr + "of" !== oe)
      return re.error('Failed to match tag: "' + oe + '"');
    if (Ce.primitive || it !== null)
      return re.skip(it, 'Failed to match body of: "' + oe + '"');
    var at = re.save(), ct = this._skipUntilEnd(
      re,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return re.isError(ct) ? ct : (it = re.offset - at.offset, re.restore(at), re.skip(it, 'Failed to match body of: "' + oe + '"'));
  }, J.prototype._skipUntilEnd = function(re, oe) {
    for (; ; ) {
      var ke = ne(re, oe);
      if (re.isError(ke))
        return ke;
      var Ce = ie(re, ke.primitive, oe);
      if (re.isError(Ce))
        return Ce;
      var it;
      if (ke.primitive || Ce !== null ? it = re.skip(Ce) : it = this._skipUntilEnd(re, oe), re.isError(it))
        return it;
      if (ke.tagStr === "end")
        break;
    }
  }, J.prototype._decodeList = function(re, oe, ke, Ce) {
    for (var it = []; !re.isEmpty(); ) {
      var at = this._peekTag(re, "end");
      if (re.isError(at))
        return at;
      var ct = ke.decode(re, "der", Ce);
      if (re.isError(ct) && at)
        break;
      it.push(ct);
    }
    return it;
  }, J.prototype._decodeStr = function(re, oe) {
    if (oe === "bitstr") {
      var ke = re.readUInt8();
      return re.isError(ke) ? ke : { unused: ke, data: re.raw() };
    } else if (oe === "bmpstr") {
      var Ce = re.raw();
      if (Ce.length % 2 === 1)
        return re.error("Decoding of string type: bmpstr length mismatch");
      for (var it = "", at = 0; at < Ce.length / 2; at++)
        it += String.fromCharCode(Ce.readUInt16BE(at * 2));
      return it;
    } else if (oe === "numstr") {
      var ct = re.raw().toString("ascii");
      return this._isNumstr(ct) ? ct : re.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (oe === "octstr")
        return re.raw();
      if (oe === "objDesc")
        return re.raw();
      if (oe === "printstr") {
        var dt = re.raw().toString("ascii");
        return this._isPrintstr(dt) ? dt : re.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(oe) ? re.raw().toString() : re.error("Decoding of string type: " + oe + " unsupported");
    }
  }, J.prototype._decodeObjid = function(re, oe, ke) {
    for (var Ce, it = [], at = 0; !re.isEmpty(); ) {
      var ct = re.readUInt8();
      at <<= 7, at |= ct & 127, ct & 128 || (it.push(at), at = 0);
    }
    ct & 128 && it.push(at);
    var dt = it[0] / 40 | 0, ot = it[0] % 40;
    if (ke ? Ce = it : Ce = [dt, ot].concat(it.slice(1)), oe) {
      var yt = oe[Ce.join(" ")];
      yt === void 0 && (yt = oe[Ce.join(".")]), yt !== void 0 && (Ce = yt);
    }
    return Ce;
  }, J.prototype._decodeTime = function(re, oe) {
    var ke = re.raw().toString();
    if (oe === "gentime")
      var Ce = ke.slice(0, 4) | 0, it = ke.slice(4, 6) | 0, at = ke.slice(6, 8) | 0, ct = ke.slice(8, 10) | 0, dt = ke.slice(10, 12) | 0, ot = ke.slice(12, 14) | 0;
    else if (oe === "utctime") {
      var Ce = ke.slice(0, 2) | 0, it = ke.slice(2, 4) | 0, at = ke.slice(4, 6) | 0, ct = ke.slice(6, 8) | 0, dt = ke.slice(8, 10) | 0, ot = ke.slice(10, 12) | 0;
      Ce < 70 ? Ce = 2e3 + Ce : Ce = 1900 + Ce;
    } else
      return re.error("Decoding " + oe + " time is not supported yet");
    return Date.UTC(Ce, it - 1, at, ct, dt, ot, 0);
  }, J.prototype._decodeNull = function(re) {
    return null;
  }, J.prototype._decodeBool = function(re) {
    var oe = re.readUInt8();
    return re.isError(oe) ? oe : oe !== 0;
  }, J.prototype._decodeInt = function(re, oe) {
    var ke = re.raw(), Ce = new K(ke);
    return oe && (Ce = oe[Ce.toString(10)] || Ce), Ce;
  }, J.prototype._use = function(re, oe) {
    return typeof re == "function" && (re = re(oe)), re._getDecoder("der").tree;
  };
  function ne(ce, re) {
    var oe = ce.readUInt8(re);
    if (ce.isError(oe))
      return oe;
    var ke = V.tagClass[oe >> 6], Ce = (oe & 32) === 0;
    if ((oe & 31) === 31) {
      var it = oe;
      for (oe = 0; (it & 128) === 128; ) {
        if (it = ce.readUInt8(re), ce.isError(it))
          return it;
        oe <<= 7, oe |= it & 127;
      }
    } else
      oe &= 31;
    var at = V.tag[oe];
    return {
      cls: ke,
      primitive: Ce,
      tag: oe,
      tagStr: at
    };
  }
  function ie(ce, re, oe) {
    var ke = ce.readUInt8(oe);
    if (ce.isError(ke))
      return ke;
    if (!re && ke === 128)
      return null;
    if (!(ke & 128))
      return ke;
    var Ce = ke & 127;
    if (Ce > 4)
      return ce.error("length octect is too long");
    ke = 0;
    for (var it = 0; it < Ce; it++) {
      ke <<= 8;
      var at = ce.readUInt8(oe);
      if (ce.isError(at))
        return at;
      ke |= at;
    }
    return ke;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var A = requireInherits_browser(), B = dist$1.Buffer, L = requireDer$1();
  function K(V) {
    L.call(this, V), this.enc = "pem";
  }
  return A(K, L), pem$1 = K, K.prototype.decode = function(W, J) {
    for (var ne = W.toString().split(/[\r\n]+/g), ie = J.label.toUpperCase(), ce = /^-----(BEGIN|END) ([^-]+)-----$/, re = -1, oe = -1, ke = 0; ke < ne.length; ke++) {
      var Ce = ne[ke].match(ce);
      if (Ce !== null && Ce[2] === ie)
        if (re === -1) {
          if (Ce[1] !== "BEGIN")
            break;
          re = ke;
        } else {
          if (Ce[1] !== "END")
            break;
          oe = ke;
          break;
        }
    }
    if (re === -1 || oe === -1)
      throw new Error("PEM section not found for: " + ie);
    var it = ne.slice(re + 1, oe).join("");
    it.replace(/[^a-z0-9\+\/=]+/gi, "");
    var at = new B(it, "base64");
    return L.prototype.decode.call(this, at, J);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(A) {
    var B = A;
    B.der = requireDer$1(), B.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var A = requireInherits_browser(), B = dist$1.Buffer, L = requireAsn1$1(), K = L.base, V = L.constants.der;
  function W(ce) {
    this.enc = "der", this.name = ce.name, this.entity = ce, this.tree = new J(), this.tree._init(ce.body);
  }
  der_1 = W, W.prototype.encode = function(re, oe) {
    return this.tree._encode(re, oe).join();
  };
  function J(ce) {
    K.Node.call(this, "der", ce);
  }
  A(J, K.Node), J.prototype._encodeComposite = function(re, oe, ke, Ce) {
    var it = ie(re, oe, ke, this.reporter);
    if (Ce.length < 128) {
      var dt = new B(2);
      return dt[0] = it, dt[1] = Ce.length, this._createEncoderBuffer([dt, Ce]);
    }
    for (var at = 1, ct = Ce.length; ct >= 256; ct >>= 8)
      at++;
    var dt = new B(2 + at);
    dt[0] = it, dt[1] = 128 | at;
    for (var ct = 1 + at, ot = Ce.length; ot > 0; ct--, ot >>= 8)
      dt[ct] = ot & 255;
    return this._createEncoderBuffer([dt, Ce]);
  }, J.prototype._encodeStr = function(re, oe) {
    if (oe === "bitstr")
      return this._createEncoderBuffer([re.unused | 0, re.data]);
    if (oe === "bmpstr") {
      for (var ke = new B(re.length * 2), Ce = 0; Ce < re.length; Ce++)
        ke.writeUInt16BE(re.charCodeAt(Ce), Ce * 2);
      return this._createEncoderBuffer(ke);
    } else return oe === "numstr" ? this._isNumstr(re) ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : oe === "printstr" ? this._isPrintstr(re) ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(oe) ? this._createEncoderBuffer(re) : oe === "objDesc" ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: " + oe + " unsupported");
  }, J.prototype._encodeObjid = function(re, oe, ke) {
    if (typeof re == "string") {
      if (!oe)
        return this.reporter.error("string objid given, but no values map found");
      if (!oe.hasOwnProperty(re))
        return this.reporter.error("objid not found in values map");
      re = oe[re].split(/[\s\.]+/g);
      for (var Ce = 0; Ce < re.length; Ce++)
        re[Ce] |= 0;
    } else if (Array.isArray(re)) {
      re = re.slice();
      for (var Ce = 0; Ce < re.length; Ce++)
        re[Ce] |= 0;
    }
    if (!Array.isArray(re))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(re));
    if (!ke) {
      if (re[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      re.splice(0, 2, re[0] * 40 + re[1]);
    }
    for (var it = 0, Ce = 0; Ce < re.length; Ce++) {
      var at = re[Ce];
      for (it++; at >= 128; at >>= 7)
        it++;
    }
    for (var ct = new B(it), dt = ct.length - 1, Ce = re.length - 1; Ce >= 0; Ce--) {
      var at = re[Ce];
      for (ct[dt--] = at & 127; (at >>= 7) > 0; )
        ct[dt--] = 128 | at & 127;
    }
    return this._createEncoderBuffer(ct);
  };
  function ne(ce) {
    return ce < 10 ? "0" + ce : ce;
  }
  J.prototype._encodeTime = function(re, oe) {
    var ke, Ce = new Date(re);
    return oe === "gentime" ? ke = [
      ne(Ce.getFullYear()),
      ne(Ce.getUTCMonth() + 1),
      ne(Ce.getUTCDate()),
      ne(Ce.getUTCHours()),
      ne(Ce.getUTCMinutes()),
      ne(Ce.getUTCSeconds()),
      "Z"
    ].join("") : oe === "utctime" ? ke = [
      ne(Ce.getFullYear() % 100),
      ne(Ce.getUTCMonth() + 1),
      ne(Ce.getUTCDate()),
      ne(Ce.getUTCHours()),
      ne(Ce.getUTCMinutes()),
      ne(Ce.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + oe + " time is not supported yet"), this._encodeStr(ke, "octstr");
  }, J.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, J.prototype._encodeInt = function(re, oe) {
    if (typeof re == "string") {
      if (!oe)
        return this.reporter.error("String int or enum given, but no values map");
      if (!oe.hasOwnProperty(re))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(re));
      re = oe[re];
    }
    if (typeof re != "number" && !B.isBuffer(re)) {
      var ke = re.toArray();
      !re.sign && ke[0] & 128 && ke.unshift(0), re = new B(ke);
    }
    if (B.isBuffer(re)) {
      var Ce = re.length;
      re.length === 0 && Ce++;
      var at = new B(Ce);
      return re.copy(at), re.length === 0 && (at[0] = 0), this._createEncoderBuffer(at);
    }
    if (re < 128)
      return this._createEncoderBuffer(re);
    if (re < 256)
      return this._createEncoderBuffer([0, re]);
    for (var Ce = 1, it = re; it >= 256; it >>= 8)
      Ce++;
    for (var at = new Array(Ce), it = at.length - 1; it >= 0; it--)
      at[it] = re & 255, re >>= 8;
    return at[0] & 128 && at.unshift(0), this._createEncoderBuffer(new B(at));
  }, J.prototype._encodeBool = function(re) {
    return this._createEncoderBuffer(re ? 255 : 0);
  }, J.prototype._use = function(re, oe) {
    return typeof re == "function" && (re = re(oe)), re._getEncoder("der").tree;
  }, J.prototype._skipDefault = function(re, oe, ke) {
    var Ce = this._baseState, it;
    if (Ce.default === null)
      return !1;
    var at = re.join();
    if (Ce.defaultBuffer === void 0 && (Ce.defaultBuffer = this._encodeValue(Ce.default, oe, ke).join()), at.length !== Ce.defaultBuffer.length)
      return !1;
    for (it = 0; it < at.length; it++)
      if (at[it] !== Ce.defaultBuffer[it])
        return !1;
    return !0;
  };
  function ie(ce, re, oe, ke) {
    var Ce;
    if (ce === "seqof" ? ce = "seq" : ce === "setof" && (ce = "set"), V.tagByName.hasOwnProperty(ce))
      Ce = V.tagByName[ce];
    else if (typeof ce == "number" && (ce | 0) === ce)
      Ce = ce;
    else
      return ke.error("Unknown tag: " + ce);
    return Ce >= 31 ? ke.error("Multi-octet tag encoding unsupported") : (re || (Ce |= 32), Ce |= V.tagClassByName[oe || "universal"] << 6, Ce);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var A = requireInherits_browser(), B = requireDer();
  function L(K) {
    B.call(this, K), this.enc = "pem";
  }
  return A(L, B), pem = L, L.prototype.encode = function(V, W) {
    for (var J = B.prototype.encode.call(this, V), ne = J.toString("base64"), ie = ["-----BEGIN " + W.label + "-----"], ce = 0; ce < ne.length; ce += 64)
      ie.push(ne.slice(ce, ce + 64));
    return ie.push("-----END " + W.label + "-----"), ie.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(A) {
    var B = A;
    B.der = requireDer(), B.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(A) {
    var B = A;
    B.bignum = requireBn$1(), B.define = requireApi().define, B.base = requireBase(), B.constants = requireConstants(), B.decoders = requireDecoders(), B.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var A = requireAsn1$1(), B = A.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), L = A.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), V = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  }), W = A.define("RelativeDistinguishedName", function() {
    this.setof(L);
  }), J = A.define("RDNSequence", function() {
    this.seqof(W);
  }), ne = A.define("Name", function() {
    this.choice({
      rdnSequence: this.use(J)
    });
  }), ie = A.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(B),
      this.key("notAfter").use(B)
    );
  }), ce = A.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), re = A.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(K),
      this.key("issuer").use(ne),
      this.key("validity").use(ie),
      this.key("subject").use(ne),
      this.key("subjectPublicKeyInfo").use(V),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(ce).optional()
    );
  }), oe = A.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(re),
      this.key("signatureAlgorithm").use(K),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = oe, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var A = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var B = A.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = B;
  var L = A.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = L;
  var K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), V = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = V;
  var W = A.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(K),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = W;
  var J = A.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = J;
  var ne = A.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = ne, asn1$1.DSAparam = A.define("DSAparam", function() {
    this.int();
  });
  var ie = A.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), ce = A.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ie),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = ce, asn1$1.signature = A.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var A = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, B = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, L = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K = requireEvp_bytestokey(), V = requireBrowser$6(), W = safeBufferExports.Buffer;
  return fixProc = function(J, ne) {
    var ie = J.toString(), ce = ie.match(A), re;
    if (ce) {
      var ke = "aes" + ce[1], Ce = W.from(ce[2], "hex"), it = W.from(ce[3].replace(/[\r\n]/g, ""), "base64"), at = K(ne, Ce.slice(0, 8), parseInt(ce[1], 10)).key, ct = [], dt = V.createDecipheriv(ke, at, Ce);
      ct.push(dt.update(it)), ct.push(dt.final()), re = W.concat(ct);
    } else {
      var oe = ie.match(L);
      re = W.from(oe[2].replace(/[\r\n]/g, ""), "base64");
    }
    var ot = ie.match(B)[1];
    return {
      tag: ot,
      data: re
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var A = requireAsn1(), B = require$$1, L = requireFixProc(), K = requireBrowser$6(), V = requireBrowser$7(), W = safeBufferExports.Buffer;
  function J(ie, ce) {
    var re = ie.algorithm.decrypt.kde.kdeparams.salt, oe = parseInt(ie.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ke = B[ie.algorithm.decrypt.cipher.algo.join(".")], Ce = ie.algorithm.decrypt.cipher.iv, it = ie.subjectPrivateKey, at = parseInt(ke.split("-")[1], 10) / 8, ct = V.pbkdf2Sync(ce, re, oe, at, "sha1"), dt = K.createDecipheriv(ke, ct, Ce), ot = [];
    return ot.push(dt.update(it)), ot.push(dt.final()), W.concat(ot);
  }
  function ne(ie) {
    var ce;
    typeof ie == "object" && !W.isBuffer(ie) && (ce = ie.passphrase, ie = ie.key), typeof ie == "string" && (ie = W.from(ie));
    var re = L(ie, ce), oe = re.tag, ke = re.data, Ce, it;
    switch (oe) {
      case "CERTIFICATE":
        it = A.certificate.decode(ke, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (it || (it = A.PublicKey.decode(ke, "der")), Ce = it.algorithm.algorithm.join("."), Ce) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPublicKey.decode(it.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return it.subjectPrivateKey = it.subjectPublicKey, {
              type: "ec",
              data: it
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.pub_key = A.DSAparam.decode(it.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ce);
        }
      case "ENCRYPTED PRIVATE KEY":
        ke = A.EncryptedPrivateKey.decode(ke, "der"), ke = J(ke, ce);
      case "PRIVATE KEY":
        switch (it = A.PrivateKey.decode(ke, "der"), Ce = it.algorithm.algorithm.join("."), Ce) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPrivateKey.decode(it.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: it.algorithm.curve,
              privateKey: A.ECPrivateKey.decode(it.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.priv_key = A.DSAparam.decode(it.subjectPrivateKey, "der"), {
              type: "dsa",
              params: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ce);
        }
      case "RSA PUBLIC KEY":
        return A.RSAPublicKey.decode(ke, "der");
      case "RSA PRIVATE KEY":
        return A.RSAPrivateKey.decode(ke, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: A.DSAPrivateKey.decode(ke, "der")
        };
      case "EC PRIVATE KEY":
        return ke = A.ECPrivateKey.decode(ke, "der"), {
          curve: ke.parameters.value,
          privateKey: ke.privateKey
        };
      default:
        throw new Error("unknown key type " + oe);
    }
  }
  return ne.signature = A.signature, parseAsn1 = ne, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$8(), L = requireBrowserifyRsa(), K = requireElliptic().ec, V = requireBn(), W = requireParseAsn1(), J = require$$4, ne = 1;
  function ie(dt, ot, yt, mt, Tt) {
    var Pt = W(ot);
    if (Pt.curve) {
      if (mt !== "ecdsa" && mt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ce(dt, Pt);
    } else if (Pt.type === "dsa") {
      if (mt !== "dsa")
        throw new Error("wrong private key type");
      return re(dt, Pt, yt);
    }
    if (mt !== "rsa" && mt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ot.padding !== void 0 && ot.padding !== ne)
      throw new Error("illegal or unsupported padding mode");
    dt = A.concat([Tt, dt]);
    for (var Nt = Pt.modulus.byteLength(), St = [0, 1]; dt.length + St.length + 1 < Nt; )
      St.push(255);
    St.push(0);
    for (var vt = -1; ++vt < dt.length; )
      St.push(dt[vt]);
    var It = L(St, Pt);
    return It;
  }
  function ce(dt, ot) {
    var yt = J[ot.curve.join(".")];
    if (!yt)
      throw new Error("unknown curve " + ot.curve.join("."));
    var mt = new K(yt), Tt = mt.keyFromPrivate(ot.privateKey), Pt = Tt.sign(dt);
    return A.from(Pt.toDER());
  }
  function re(dt, ot, yt) {
    for (var mt = ot.params.priv_key, Tt = ot.params.p, Pt = ot.params.q, Nt = ot.params.g, St = new V(0), vt, It = Ce(dt, Pt).mod(Pt), wt = !1, Oe = ke(mt, Pt, dt, yt); wt === !1; )
      vt = at(Pt, Oe, yt), St = ct(Nt, vt, Tt, Pt), wt = vt.invm(Pt).imul(It.add(mt.mul(St))).mod(Pt), wt.cmpn(0) === 0 && (wt = !1, St = new V(0));
    return oe(St, wt);
  }
  function oe(dt, ot) {
    dt = dt.toArray(), ot = ot.toArray(), dt[0] & 128 && (dt = [0].concat(dt)), ot[0] & 128 && (ot = [0].concat(ot));
    var yt = dt.length + ot.length + 4, mt = [
      48,
      yt,
      2,
      dt.length
    ];
    return mt = mt.concat(dt, [2, ot.length], ot), A.from(mt);
  }
  function ke(dt, ot, yt, mt) {
    if (dt = A.from(dt.toArray()), dt.length < ot.byteLength()) {
      var Tt = A.alloc(ot.byteLength() - dt.length);
      dt = A.concat([Tt, dt]);
    }
    var Pt = yt.length, Nt = it(yt, ot), St = A.alloc(Pt);
    St.fill(1);
    var vt = A.alloc(Pt);
    return vt = B(mt, vt).update(St).update(A.from([0])).update(dt).update(Nt).digest(), St = B(mt, vt).update(St).digest(), vt = B(mt, vt).update(St).update(A.from([1])).update(dt).update(Nt).digest(), St = B(mt, vt).update(St).digest(), { k: vt, v: St };
  }
  function Ce(dt, ot) {
    var yt = new V(dt), mt = (dt.length << 3) - ot.bitLength();
    return mt > 0 && yt.ishrn(mt), yt;
  }
  function it(dt, ot) {
    dt = Ce(dt, ot), dt = dt.mod(ot);
    var yt = A.from(dt.toArray());
    if (yt.length < ot.byteLength()) {
      var mt = A.alloc(ot.byteLength() - yt.length);
      yt = A.concat([mt, yt]);
    }
    return yt;
  }
  function at(dt, ot, yt) {
    var mt, Tt;
    do {
      for (mt = A.alloc(0); mt.length * 8 < dt.bitLength(); )
        ot.v = B(yt, ot.k).update(ot.v).digest(), mt = A.concat([mt, ot.v]);
      Tt = Ce(mt, dt), ot.k = B(yt, ot.k).update(ot.v).update(A.from([0])).digest(), ot.v = B(yt, ot.k).update(ot.v).digest();
    } while (Tt.cmp(dt) !== -1);
    return Tt;
  }
  function ct(dt, ot, yt, mt) {
    return dt.toRed(V.mont(yt)).redPow(ot).fromRed().mod(mt);
  }
  return sign.exports = ie, sign.exports.getKey = ke, sign.exports.makeKey = at, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var A = safeBufferExports.Buffer, B = requireBn(), L = requireElliptic().ec, K = requireParseAsn1(), V = require$$4;
  function W(ce, re, oe, ke, Ce) {
    var it = K(oe);
    if (it.type === "ec") {
      if (ke !== "ecdsa" && ke !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return J(ce, re, it);
    } else if (it.type === "dsa") {
      if (ke !== "dsa")
        throw new Error("wrong public key type");
      return ne(ce, re, it);
    }
    if (ke !== "rsa" && ke !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    re = A.concat([Ce, re]);
    for (var at = it.modulus.byteLength(), ct = [1], dt = 0; re.length + ct.length + 2 < at; )
      ct.push(255), dt += 1;
    ct.push(0);
    for (var ot = -1; ++ot < re.length; )
      ct.push(re[ot]);
    ct = A.from(ct);
    var yt = B.mont(it.modulus);
    ce = new B(ce).toRed(yt), ce = ce.redPow(new B(it.publicExponent)), ce = A.from(ce.fromRed().toArray());
    var mt = dt < 8 ? 1 : 0;
    for (at = Math.min(ce.length, ct.length), ce.length !== ct.length && (mt = 1), ot = -1; ++ot < at; )
      mt |= ce[ot] ^ ct[ot];
    return mt === 0;
  }
  function J(ce, re, oe) {
    var ke = V[oe.data.algorithm.curve.join(".")];
    if (!ke)
      throw new Error("unknown curve " + oe.data.algorithm.curve.join("."));
    var Ce = new L(ke), it = oe.data.subjectPrivateKey.data;
    return Ce.verify(re, ce, it);
  }
  function ne(ce, re, oe) {
    var ke = oe.data.p, Ce = oe.data.q, it = oe.data.g, at = oe.data.pub_key, ct = K.signature.decode(ce, "der"), dt = ct.s, ot = ct.r;
    ie(dt, Ce), ie(ot, Ce);
    var yt = B.mont(ke), mt = dt.invm(Ce), Tt = it.toRed(yt).redPow(new B(re).mul(mt).mod(Ce)).fromRed().mul(at.toRed(yt).redPow(ot.mul(mt).mod(Ce)).fromRed()).mod(ke).mod(Ce);
    return Tt.cmp(ot) === 0;
  }
  function ie(ce, re) {
    if (ce.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ce.cmp(re) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = W, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$9(), L = requireReadableBrowser(), K = requireInherits_browser(), V = requireSign(), W = requireVerify(), J = require$$6;
  Object.keys(J).forEach(function(oe) {
    J[oe].id = A.from(J[oe].id, "hex"), J[oe.toLowerCase()] = J[oe];
  });
  function ne(oe) {
    L.Writable.call(this);
    var ke = J[oe];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hashType = ke.hash, this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ne, L.Writable), ne.prototype._write = function(ke, Ce, it) {
    this._hash.update(ke), it();
  }, ne.prototype.update = function(ke, Ce) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Ce) : ke), this;
  }, ne.prototype.sign = function(ke, Ce) {
    this.end();
    var it = this._hash.digest(), at = V(it, ke, this._hashType, this._signType, this._tag);
    return Ce ? at.toString(Ce) : at;
  };
  function ie(oe) {
    L.Writable.call(this);
    var ke = J[oe];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ie, L.Writable), ie.prototype._write = function(ke, Ce, it) {
    this._hash.update(ke), it();
  }, ie.prototype.update = function(ke, Ce) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Ce) : ke), this;
  }, ie.prototype.verify = function(ke, Ce, it) {
    var at = typeof Ce == "string" ? A.from(Ce, it) : Ce;
    this.end();
    var ct = this._hash.digest();
    return W(at, ct, ke, this._signType, this._tag);
  };
  function ce(oe) {
    return new ne(oe);
  }
  function re(oe) {
    return new ie(oe);
  }
  return browser$3 = {
    Sign: ce,
    Verify: re,
    createSign: ce,
    createVerify: re
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var A = requireElliptic(), B = requireBn$1();
  browser$2 = function(J) {
    return new K(J);
  };
  var L = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  L.p224 = L.secp224r1, L.p256 = L.secp256r1 = L.prime256v1, L.p192 = L.secp192r1 = L.prime192v1, L.p384 = L.secp384r1, L.p521 = L.secp521r1;
  function K(W) {
    this.curveType = L[W], this.curveType || (this.curveType = {
      name: W
    }), this.curve = new A.ec(this.curveType.name), this.keys = void 0;
  }
  K.prototype.generateKeys = function(W, J) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(W, J);
  }, K.prototype.computeSecret = function(W, J, ne) {
    J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J));
    var ie = this.curve.keyFromPublic(W).getPublic(), ce = ie.mul(this.keys.getPrivate()).getX();
    return V(ce, ne, this.curveType.byteLength);
  }, K.prototype.getPublicKey = function(W, J) {
    var ne = this.keys.getPublic(J === "compressed", !0);
    return J === "hybrid" && (ne[ne.length - 1] % 2 ? ne[0] = 7 : ne[0] = 6), V(ne, W);
  }, K.prototype.getPrivateKey = function(W) {
    return V(this.keys.getPrivate(), W);
  }, K.prototype.setPublicKey = function(W, J) {
    return J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J)), this.keys._importPublic(W), this;
  }, K.prototype.setPrivateKey = function(W, J) {
    J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J));
    var ne = new B(W);
    return ne = ne.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ne), this;
  };
  function V(W, J, ne) {
    Array.isArray(W) || (W = W.toArray());
    var ie = new Buffer$1(W);
    if (ne && ie.length < ne) {
      var ce = new Buffer$1(ne - ie.length);
      ce.fill(0), ie = Buffer$1.concat([ce, ie]);
    }
    return J ? ie.toString(J) : ie;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var A = requireBrowser$9(), B = safeBufferExports.Buffer;
  mgf = function(K, V) {
    for (var W = B.alloc(0), J = 0, ne; W.length < V; )
      ne = L(J++), W = B.concat([W, A("sha1").update(K).update(ne).digest()]);
    return W.slice(0, V);
  };
  function L(K) {
    var V = B.allocUnsafe(4);
    return V.writeUInt32BE(K, 0), V;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(B, L) {
    for (var K = B.length, V = -1; ++V < K; )
      B[V] ^= L[V];
    return B;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var A = requireBn$1(), B = safeBufferExports.Buffer;
  function L(K, V) {
    return B.from(K.toRed(A.mont(V.modulus)).redPow(new A(V.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = L, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var A = requireParseAsn1(), B = requireBrowser$b(), L = requireBrowser$9(), K = requireMgf(), V = requireXor(), W = requireBn$1(), J = requireWithPublic(), ne = requireBrowserifyRsa(), ie = safeBufferExports.Buffer;
  publicEncrypt = function(Ce, it, at) {
    var ct;
    Ce.padding ? ct = Ce.padding : at ? ct = 1 : ct = 4;
    var dt = A(Ce), ot;
    if (ct === 4)
      ot = ce(dt, it);
    else if (ct === 1)
      ot = re(dt, it, at);
    else if (ct === 3) {
      if (ot = new W(it), ot.cmp(dt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return at ? ne(ot, dt) : J(ot, dt);
  };
  function ce(ke, Ce) {
    var it = ke.modulus.byteLength(), at = Ce.length, ct = L("sha1").update(ie.alloc(0)).digest(), dt = ct.length, ot = 2 * dt;
    if (at > it - ot - 2)
      throw new Error("message too long");
    var yt = ie.alloc(it - at - ot - 2), mt = it - dt - 1, Tt = B(dt), Pt = V(ie.concat([ct, yt, ie.alloc(1, 1), Ce], mt), K(Tt, mt)), Nt = V(Tt, K(Pt, dt));
    return new W(ie.concat([ie.alloc(1), Nt, Pt], it));
  }
  function re(ke, Ce, it) {
    var at = Ce.length, ct = ke.modulus.byteLength();
    if (at > ct - 11)
      throw new Error("message too long");
    var dt;
    return it ? dt = ie.alloc(ct - at - 3, 255) : dt = oe(ct - at - 3), new W(ie.concat([ie.from([0, it ? 1 : 2]), dt, ie.alloc(1), Ce], ct));
  }
  function oe(ke) {
    for (var Ce = ie.allocUnsafe(ke), it = 0, at = B(ke * 2), ct = 0, dt; it < ke; )
      ct === at.length && (at = B(ke * 2), ct = 0), dt = at[ct++], dt && (Ce[it++] = dt);
    return Ce;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var A = requireParseAsn1(), B = requireMgf(), L = requireXor(), K = requireBn$1(), V = requireBrowserifyRsa(), W = requireBrowser$9(), J = requireWithPublic(), ne = safeBufferExports.Buffer;
  privateDecrypt = function(ke, Ce, it) {
    var at;
    ke.padding ? at = ke.padding : it ? at = 1 : at = 4;
    var ct = A(ke), dt = ct.modulus.byteLength();
    if (Ce.length > dt || new K(Ce).cmp(ct.modulus) >= 0)
      throw new Error("decryption error");
    var ot;
    it ? ot = J(new K(Ce), ct) : ot = V(Ce, ct);
    var yt = ne.alloc(dt - ot.length);
    if (ot = ne.concat([yt, ot], dt), at === 4)
      return ie(ct, ot);
    if (at === 1)
      return ce(ct, ot, it);
    if (at === 3)
      return ot;
    throw new Error("unknown padding");
  };
  function ie(oe, ke) {
    var Ce = oe.modulus.byteLength(), it = W("sha1").update(ne.alloc(0)).digest(), at = it.length;
    if (ke[0] !== 0)
      throw new Error("decryption error");
    var ct = ke.slice(1, at + 1), dt = ke.slice(at + 1), ot = L(ct, B(dt, at)), yt = L(dt, B(ot, Ce - at - 1));
    if (re(it, yt.slice(0, at)))
      throw new Error("decryption error");
    for (var mt = at; yt[mt] === 0; )
      mt++;
    if (yt[mt++] !== 1)
      throw new Error("decryption error");
    return yt.slice(mt);
  }
  function ce(oe, ke, Ce) {
    for (var it = ke.slice(0, 2), at = 2, ct = 0; ke[at++] !== 0; )
      if (at >= ke.length) {
        ct++;
        break;
      }
    var dt = ke.slice(2, at - 1);
    if ((it.toString("hex") !== "0002" && !Ce || it.toString("hex") !== "0001" && Ce) && ct++, dt.length < 8 && ct++, ct)
      throw new Error("decryption error");
    return ke.slice(at);
  }
  function re(oe, ke) {
    oe = ne.from(oe), ke = ne.from(ke);
    var Ce = 0, it = oe.length;
    oe.length !== ke.length && (Ce++, it = Math.min(oe.length, ke.length));
    for (var at = -1; ++at < it; )
      Ce += oe[at] ^ ke[at];
    return Ce;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(A) {
    A.publicEncrypt = requirePublicEncrypt(), A.privateDecrypt = requirePrivateDecrypt(), A.privateEncrypt = function(L, K) {
      return A.publicEncrypt(L, K, !0);
    }, A.publicDecrypt = function(L, K) {
      return A.privateDecrypt(L, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function A() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var B = safeBufferExports, L = requireBrowser$b(), K = B.Buffer, V = B.kMaxLength, W = commonjsGlobal.crypto || commonjsGlobal.msCrypto, J = Math.pow(2, 32) - 1;
  function ne(ke, Ce) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("offset must be a number");
    if (ke > J || ke < 0)
      throw new TypeError("offset must be a uint32");
    if (ke > V || ke > Ce)
      throw new RangeError("offset out of range");
  }
  function ie(ke, Ce, it) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("size must be a number");
    if (ke > J || ke < 0)
      throw new TypeError("size must be a uint32");
    if (ke + Ce > it || ke > V)
      throw new RangeError("buffer too small");
  }
  W && W.getRandomValues || !process$1.browser ? (browser.randomFill = ce, browser.randomFillSync = oe) : (browser.randomFill = A, browser.randomFillSync = A);
  function ce(ke, Ce, it, at) {
    if (!K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Ce == "function")
      at = Ce, Ce = 0, it = ke.length;
    else if (typeof it == "function")
      at = it, it = ke.length - Ce;
    else if (typeof at != "function")
      throw new TypeError('"cb" argument must be a function');
    return ne(Ce, ke.length), ie(it, Ce, ke.length), re(ke, Ce, it, at);
  }
  function re(ke, Ce, it, at) {
    if (process$1.browser) {
      var ct = ke.buffer, dt = new Uint8Array(ct, Ce, it);
      if (W.getRandomValues(dt), at) {
        process$1.nextTick(function() {
          at(null, ke);
        });
        return;
      }
      return ke;
    }
    if (at) {
      L(it, function(yt, mt) {
        if (yt)
          return at(yt);
        mt.copy(ke, Ce), at(null, ke);
      });
      return;
    }
    var ot = L(it);
    return ot.copy(ke, Ce), ke;
  }
  function oe(ke, Ce, it) {
    if (typeof Ce > "u" && (Ce = 0), !K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ne(Ce, ke.length), it === void 0 && (it = ke.length - Ce), ie(it, Ce, ke.length), re(ke, Ce, it);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var A = requireAlgos(), B = Object.keys(A), L = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(B);
  cryptoBrowserify.getHashes = function() {
    return L;
  };
  var K = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = K.pbkdf2, cryptoBrowserify.pbkdf2Sync = K.pbkdf2Sync;
  var V = requireBrowser$5();
  cryptoBrowserify.Cipher = V.Cipher, cryptoBrowserify.createCipher = V.createCipher, cryptoBrowserify.Cipheriv = V.Cipheriv, cryptoBrowserify.createCipheriv = V.createCipheriv, cryptoBrowserify.Decipher = V.Decipher, cryptoBrowserify.createDecipher = V.createDecipher, cryptoBrowserify.Decipheriv = V.Decipheriv, cryptoBrowserify.createDecipheriv = V.createDecipheriv, cryptoBrowserify.getCiphers = V.getCiphers, cryptoBrowserify.listCiphers = V.listCiphers;
  var W = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = W.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = W.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = W.getDiffieHellman, cryptoBrowserify.createDiffieHellman = W.createDiffieHellman, cryptoBrowserify.DiffieHellman = W.DiffieHellman;
  var J = requireBrowser$3();
  cryptoBrowserify.createSign = J.createSign, cryptoBrowserify.Sign = J.Sign, cryptoBrowserify.createVerify = J.createVerify, cryptoBrowserify.Verify = J.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ne = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ne.publicEncrypt, cryptoBrowserify.privateEncrypt = ne.privateEncrypt, cryptoBrowserify.publicDecrypt = ne.publicDecrypt, cryptoBrowserify.privateDecrypt = ne.privateDecrypt;
  var ie = requireBrowser();
  return cryptoBrowserify.randomFill = ie.randomFill, cryptoBrowserify.randomFillSync = ie.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(A) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.utils = A.schnorr = A.verify = A.signSync = A.sign = A.getSharedSecret = A.recoverPublicKey = A.getPublicKey = A.Signature = A.Point = A.CURVE = void 0;
  const B = requireCryptoBrowserify(), L = BigInt(0), K = BigInt(1), V = BigInt(2), W = BigInt(3), J = BigInt(8), ne = Object.freeze({
    a: L,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: K,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  A.CURVE = ne;
  const ie = (Wt, Ft) => (Wt + Ft / V) / Ft, ce = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Wt) {
      const { n: Ft } = ne, Gt = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), xt = -K * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), pt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Et = Gt, qt = BigInt("0x100000000000000000000000000000000"), Ht = ie(Et * Wt, Ft), Yt = ie(-xt * Wt, Ft);
      let Qt = $t(Wt - Ht * Gt - Yt * pt, Ft), or = $t(-Ht * xt - Yt * Et, Ft);
      const cr = Qt > qt, Dt = or > qt;
      if (cr && (Qt = Ft - Qt), Dt && (or = Ft - or), Qt > qt || or > qt)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Wt);
      return { k1neg: cr, k1: Qt, k2neg: Dt, k2: or };
    }
  }, re = 32, oe = 32, ke = 32, Ce = re + 1, it = 2 * re + 1;
  function at(Wt) {
    const { a: Ft, b: Gt } = ne, xt = $t(Wt * Wt), pt = $t(xt * Wt);
    return $t(pt + Ft * Wt + Gt);
  }
  const ct = ne.a === L;
  class dt extends Error {
    constructor(Ft) {
      super(Ft);
    }
  }
  function ot(Wt) {
    if (!(Wt instanceof yt))
      throw new TypeError("JacobianPoint expected");
  }
  class yt {
    constructor(Ft, Gt, xt) {
      this.x = Ft, this.y = Gt, this.z = xt;
    }
    static fromAffine(Ft) {
      if (!(Ft instanceof Pt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Ft.equals(Pt.ZERO) ? yt.ZERO : new yt(Ft.x, Ft.y, K);
    }
    static toAffineBatch(Ft) {
      const Gt = Rt(Ft.map((xt) => xt.z));
      return Ft.map((xt, pt) => xt.toAffine(Gt[pt]));
    }
    static normalizeZ(Ft) {
      return yt.toAffineBatch(Ft).map(yt.fromAffine);
    }
    equals(Ft) {
      ot(Ft);
      const { x: Gt, y: xt, z: pt } = this, { x: Et, y: qt, z: Ht } = Ft, Yt = $t(pt * pt), Qt = $t(Ht * Ht), or = $t(Gt * Qt), cr = $t(Et * Yt), Dt = $t($t(xt * Ht) * Qt), er = $t($t(qt * pt) * Yt);
      return or === cr && Dt === er;
    }
    negate() {
      return new yt(this.x, $t(-this.y), this.z);
    }
    double() {
      const { x: Ft, y: Gt, z: xt } = this, pt = $t(Ft * Ft), Et = $t(Gt * Gt), qt = $t(Et * Et), Ht = Ft + Et, Yt = $t(V * ($t(Ht * Ht) - pt - qt)), Qt = $t(W * pt), or = $t(Qt * Qt), cr = $t(or - V * Yt), Dt = $t(Qt * (Yt - cr) - J * qt), er = $t(V * Gt * xt);
      return new yt(cr, Dt, er);
    }
    add(Ft) {
      ot(Ft);
      const { x: Gt, y: xt, z: pt } = this, { x: Et, y: qt, z: Ht } = Ft;
      if (Et === L || qt === L)
        return this;
      if (Gt === L || xt === L)
        return Ft;
      const Yt = $t(pt * pt), Qt = $t(Ht * Ht), or = $t(Gt * Qt), cr = $t(Et * Yt), Dt = $t($t(xt * Ht) * Qt), er = $t($t(qt * pt) * Yt), ir = $t(cr - or), fr = $t(er - Dt);
      if (ir === L)
        return fr === L ? this.double() : yt.ZERO;
      const Ar = $t(ir * ir), Sr = $t(ir * Ar), gr = $t(or * Ar), Tr = $t(fr * fr - Sr - V * gr), Nr = $t(fr * (gr - Tr) - Dt * Sr), Cr = $t(pt * Ht * ir);
      return new yt(Tr, Nr, Cr);
    }
    subtract(Ft) {
      return this.add(Ft.negate());
    }
    multiplyUnsafe(Ft) {
      const Gt = yt.ZERO;
      if (typeof Ft == "bigint" && Ft === L)
        return Gt;
      let xt = lt(Ft);
      if (xt === K)
        return this;
      if (!ct) {
        let cr = Gt, Dt = this;
        for (; xt > L; )
          xt & K && (cr = cr.add(Dt)), Dt = Dt.double(), xt >>= K;
        return cr;
      }
      let { k1neg: pt, k1: Et, k2neg: qt, k2: Ht } = ce.splitScalar(xt), Yt = Gt, Qt = Gt, or = this;
      for (; Et > L || Ht > L; )
        Et & K && (Yt = Yt.add(or)), Ht & K && (Qt = Qt.add(or)), or = or.double(), Et >>= K, Ht >>= K;
      return pt && (Yt = Yt.negate()), qt && (Qt = Qt.negate()), Qt = new yt($t(Qt.x * ce.beta), Qt.y, Qt.z), Yt.add(Qt);
    }
    precomputeWindow(Ft) {
      const Gt = ct ? 128 / Ft + 1 : 256 / Ft + 1, xt = [];
      let pt = this, Et = pt;
      for (let qt = 0; qt < Gt; qt++) {
        Et = pt, xt.push(Et);
        for (let Ht = 1; Ht < 2 ** (Ft - 1); Ht++)
          Et = Et.add(pt), xt.push(Et);
        pt = Et.double();
      }
      return xt;
    }
    wNAF(Ft, Gt) {
      !Gt && this.equals(yt.BASE) && (Gt = Pt.BASE);
      const xt = Gt && Gt._WINDOW_SIZE || 1;
      if (256 % xt)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let pt = Gt && Tt.get(Gt);
      pt || (pt = this.precomputeWindow(xt), Gt && xt !== 1 && (pt = yt.normalizeZ(pt), Tt.set(Gt, pt)));
      let Et = yt.ZERO, qt = yt.BASE;
      const Ht = 1 + (ct ? 128 / xt : 256 / xt), Yt = 2 ** (xt - 1), Qt = BigInt(2 ** xt - 1), or = 2 ** xt, cr = BigInt(xt);
      for (let Dt = 0; Dt < Ht; Dt++) {
        const er = Dt * Yt;
        let ir = Number(Ft & Qt);
        Ft >>= cr, ir > Yt && (ir -= or, Ft += K);
        const fr = er, Ar = er + Math.abs(ir) - 1, Sr = Dt % 2 !== 0, gr = ir < 0;
        ir === 0 ? qt = qt.add(mt(Sr, pt[fr])) : Et = Et.add(mt(gr, pt[Ar]));
      }
      return { p: Et, f: qt };
    }
    multiply(Ft, Gt) {
      let xt = lt(Ft), pt, Et;
      if (ct) {
        const { k1neg: qt, k1: Ht, k2neg: Yt, k2: Qt } = ce.splitScalar(xt);
        let { p: or, f: cr } = this.wNAF(Ht, Gt), { p: Dt, f: er } = this.wNAF(Qt, Gt);
        or = mt(qt, or), Dt = mt(Yt, Dt), Dt = new yt($t(Dt.x * ce.beta), Dt.y, Dt.z), pt = or.add(Dt), Et = cr.add(er);
      } else {
        const { p: qt, f: Ht } = this.wNAF(xt, Gt);
        pt = qt, Et = Ht;
      }
      return yt.normalizeZ([pt, Et])[0];
    }
    toAffine(Ft) {
      const { x: Gt, y: xt, z: pt } = this, Et = this.equals(yt.ZERO);
      Ft == null && (Ft = Et ? J : Lt(pt));
      const qt = Ft, Ht = $t(qt * qt), Yt = $t(Ht * qt), Qt = $t(Gt * Ht), or = $t(xt * Yt), cr = $t(pt * qt);
      if (Et)
        return Pt.ZERO;
      if (cr !== K)
        throw new Error("invZ was invalid");
      return new Pt(Qt, or);
    }
  }
  yt.BASE = new yt(ne.Gx, ne.Gy, K), yt.ZERO = new yt(L, K, L);
  function mt(Wt, Ft) {
    const Gt = Ft.negate();
    return Wt ? Gt : Ft;
  }
  const Tt = /* @__PURE__ */ new WeakMap();
  class Pt {
    constructor(Ft, Gt) {
      this.x = Ft, this.y = Gt;
    }
    _setWindowSize(Ft) {
      this._WINDOW_SIZE = Ft, Tt.delete(this);
    }
    hasEvenY() {
      return this.y % V === L;
    }
    static fromCompressedHex(Ft) {
      const Gt = Ft.length === 32, xt = ut(Gt ? Ft : Ft.subarray(1));
      if (!nr(xt))
        throw new Error("Point is not on curve");
      const pt = at(xt);
      let Et = Jt(pt);
      const qt = (Et & K) === K;
      Gt ? qt && (Et = $t(-Et)) : (Ft[0] & 1) === 1 !== qt && (Et = $t(-Et));
      const Ht = new Pt(xt, Et);
      return Ht.assertValidity(), Ht;
    }
    static fromUncompressedHex(Ft) {
      const Gt = ut(Ft.subarray(1, re + 1)), xt = ut(Ft.subarray(re + 1, re * 2 + 1)), pt = new Pt(Gt, xt);
      return pt.assertValidity(), pt;
    }
    static fromHex(Ft) {
      const Gt = gt(Ft), xt = Gt.length, pt = Gt[0];
      if (xt === re)
        return this.fromCompressedHex(Gt);
      if (xt === Ce && (pt === 2 || pt === 3))
        return this.fromCompressedHex(Gt);
      if (xt === it && pt === 4)
        return this.fromUncompressedHex(Gt);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ce} compressed bytes or ${it} uncompressed bytes, not ${xt}`);
    }
    static fromPrivateKey(Ft) {
      return Pt.BASE.multiply(sr(Ft));
    }
    static fromSignature(Ft, Gt, xt) {
      const { r: pt, s: Et } = dr(Gt);
      if (![0, 1, 2, 3].includes(xt))
        throw new Error("Cannot recover: invalid recovery bit");
      const qt = Kt(gt(Ft)), { n: Ht } = ne, Yt = xt === 2 || xt === 3 ? pt + Ht : pt, Qt = Lt(Yt, Ht), or = $t(-qt * Qt, Ht), cr = $t(Et * Qt, Ht), Dt = xt & 1 ? "03" : "02", er = Pt.fromHex(Dt + nt(Yt)), ir = Pt.BASE.multiplyAndAddUnsafe(er, or, cr);
      if (!ir)
        throw new Error("Cannot recover signature: point at infinify");
      return ir.assertValidity(), ir;
    }
    toRawBytes(Ft = !1) {
      return bt(this.toHex(Ft));
    }
    toHex(Ft = !1) {
      const Gt = nt(this.x);
      return Ft ? `${this.hasEvenY() ? "02" : "03"}${Gt}` : `04${Gt}${nt(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Ft = "Point is not on elliptic curve", { x: Gt, y: xt } = this;
      if (!nr(Gt) || !nr(xt))
        throw new Error(Ft);
      const pt = $t(xt * xt), Et = at(Gt);
      if ($t(pt - Et) !== L)
        throw new Error(Ft);
    }
    equals(Ft) {
      return this.x === Ft.x && this.y === Ft.y;
    }
    negate() {
      return new Pt(this.x, $t(-this.y));
    }
    double() {
      return yt.fromAffine(this).double().toAffine();
    }
    add(Ft) {
      return yt.fromAffine(this).add(yt.fromAffine(Ft)).toAffine();
    }
    subtract(Ft) {
      return this.add(Ft.negate());
    }
    multiply(Ft) {
      return yt.fromAffine(this).multiply(Ft, this).toAffine();
    }
    multiplyAndAddUnsafe(Ft, Gt, xt) {
      const pt = yt.fromAffine(this), Et = Gt === L || Gt === K || this !== Pt.BASE ? pt.multiplyUnsafe(Gt) : pt.multiply(Gt), qt = yt.fromAffine(Ft).multiplyUnsafe(xt), Ht = Et.add(qt);
      return Ht.equals(yt.ZERO) ? void 0 : Ht.toAffine();
    }
  }
  A.Point = Pt, Pt.BASE = new Pt(ne.Gx, ne.Gy), Pt.ZERO = new Pt(L, L);
  function Nt(Wt) {
    return Number.parseInt(Wt[0], 16) >= 8 ? "00" + Wt : Wt;
  }
  function St(Wt) {
    if (Wt.length < 2 || Wt[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${rt(Wt)}`);
    const Ft = Wt[1], Gt = Wt.subarray(2, Ft + 2);
    if (!Ft || Gt.length !== Ft)
      throw new Error("Invalid signature integer: wrong length");
    if (Gt[0] === 0 && Gt[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ut(Gt), left: Wt.subarray(Ft + 2) };
  }
  function vt(Wt) {
    if (Wt.length < 2 || Wt[0] != 48)
      throw new Error(`Invalid signature tag: ${rt(Wt)}`);
    if (Wt[1] !== Wt.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Ft, left: Gt } = St(Wt.subarray(2)), { data: xt, left: pt } = St(Gt);
    if (pt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${rt(pt)}`);
    return { r: Ft, s: xt };
  }
  class It {
    constructor(Ft, Gt) {
      this.r = Ft, this.s = Gt, this.assertValidity();
    }
    static fromCompact(Ft) {
      const Gt = Ft instanceof Uint8Array, xt = "Signature.fromCompact";
      if (typeof Ft != "string" && !Gt)
        throw new TypeError(`${xt}: Expected string or Uint8Array`);
      const pt = Gt ? rt(Ft) : Ft;
      if (pt.length !== 128)
        throw new Error(`${xt}: Expected 64-byte hex`);
      return new It(ht(pt.slice(0, 64)), ht(pt.slice(64, 128)));
    }
    static fromDER(Ft) {
      const Gt = Ft instanceof Uint8Array;
      if (typeof Ft != "string" && !Gt)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: xt, s: pt } = vt(Gt ? Ft : bt(Ft));
      return new It(xt, pt);
    }
    static fromHex(Ft) {
      return this.fromDER(Ft);
    }
    assertValidity() {
      const { r: Ft, s: Gt } = this;
      if (!Vt(Ft))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!Vt(Gt))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Ft = ne.n >> K;
      return this.s > Ft;
    }
    normalizeS() {
      return this.hasHighS() ? new It(this.r, $t(-this.s, ne.n)) : this;
    }
    toDERRawBytes() {
      return bt(this.toDERHex());
    }
    toDERHex() {
      const Ft = Nt(ft(this.s)), Gt = Nt(ft(this.r)), xt = Ft.length / 2, pt = Gt.length / 2, Et = ft(xt), qt = ft(pt);
      return `30${ft(pt + xt + 4)}02${qt}${Gt}02${Et}${Ft}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return bt(this.toCompactHex());
    }
    toCompactHex() {
      return nt(this.r) + nt(this.s);
    }
  }
  A.Signature = It;
  function wt(...Wt) {
    if (!Wt.every((xt) => xt instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Wt.length === 1)
      return Wt[0];
    const Ft = Wt.reduce((xt, pt) => xt + pt.length, 0), Gt = new Uint8Array(Ft);
    for (let xt = 0, pt = 0; xt < Wt.length; xt++) {
      const Et = Wt[xt];
      Gt.set(Et, pt), pt += Et.length;
    }
    return Gt;
  }
  const Oe = Array.from({ length: 256 }, (Wt, Ft) => Ft.toString(16).padStart(2, "0"));
  function rt(Wt) {
    if (!(Wt instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Ft = "";
    for (let Gt = 0; Gt < Wt.length; Gt++)
      Ft += Oe[Wt[Gt]];
    return Ft;
  }
  const pe = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function nt(Wt) {
    if (typeof Wt != "bigint")
      throw new Error("Expected bigint");
    if (!(L <= Wt && Wt < pe))
      throw new Error("Expected number 0 <= n < 2^256");
    return Wt.toString(16).padStart(64, "0");
  }
  function st(Wt) {
    const Ft = bt(nt(Wt));
    if (Ft.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Ft;
  }
  function ft(Wt) {
    const Ft = Wt.toString(16);
    return Ft.length & 1 ? `0${Ft}` : Ft;
  }
  function ht(Wt) {
    if (typeof Wt != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Wt);
    return BigInt(`0x${Wt}`);
  }
  function bt(Wt) {
    if (typeof Wt != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Wt);
    if (Wt.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Wt.length);
    const Ft = new Uint8Array(Wt.length / 2);
    for (let Gt = 0; Gt < Ft.length; Gt++) {
      const xt = Gt * 2, pt = Wt.slice(xt, xt + 2), Et = Number.parseInt(pt, 16);
      if (Number.isNaN(Et) || Et < 0)
        throw new Error("Invalid byte sequence");
      Ft[Gt] = Et;
    }
    return Ft;
  }
  function ut(Wt) {
    return ht(rt(Wt));
  }
  function gt(Wt) {
    return Wt instanceof Uint8Array ? Uint8Array.from(Wt) : bt(Wt);
  }
  function lt(Wt) {
    if (typeof Wt == "number" && Number.isSafeInteger(Wt) && Wt > 0)
      return BigInt(Wt);
    if (typeof Wt == "bigint" && Vt(Wt))
      return Wt;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function $t(Wt, Ft = ne.P) {
    const Gt = Wt % Ft;
    return Gt >= L ? Gt : Ft + Gt;
  }
  function jt(Wt, Ft) {
    const { P: Gt } = ne;
    let xt = Wt;
    for (; Ft-- > L; )
      xt *= xt, xt %= Gt;
    return xt;
  }
  function Jt(Wt) {
    const { P: Ft } = ne, Gt = BigInt(6), xt = BigInt(11), pt = BigInt(22), Et = BigInt(23), qt = BigInt(44), Ht = BigInt(88), Yt = Wt * Wt * Wt % Ft, Qt = Yt * Yt * Wt % Ft, or = jt(Qt, W) * Qt % Ft, cr = jt(or, W) * Qt % Ft, Dt = jt(cr, V) * Yt % Ft, er = jt(Dt, xt) * Dt % Ft, ir = jt(er, pt) * er % Ft, fr = jt(ir, qt) * ir % Ft, Ar = jt(fr, Ht) * fr % Ft, Sr = jt(Ar, qt) * ir % Ft, gr = jt(Sr, W) * Qt % Ft, Tr = jt(gr, Et) * er % Ft, Nr = jt(Tr, Gt) * Yt % Ft, Cr = jt(Nr, V);
    if (Cr * Cr % Ft !== Wt)
      throw new Error("Cannot find square root");
    return Cr;
  }
  function Lt(Wt, Ft = ne.P) {
    if (Wt === L || Ft <= L)
      throw new Error(`invert: expected positive integers, got n=${Wt} mod=${Ft}`);
    let Gt = $t(Wt, Ft), xt = Ft, pt = L, Et = K;
    for (; Gt !== L; ) {
      const Ht = xt / Gt, Yt = xt % Gt, Qt = pt - Et * Ht;
      xt = Gt, Gt = Yt, pt = Et, Et = Qt;
    }
    if (xt !== K)
      throw new Error("invert: does not exist");
    return $t(pt, Ft);
  }
  function Rt(Wt, Ft = ne.P) {
    const Gt = new Array(Wt.length), xt = Wt.reduce((Et, qt, Ht) => qt === L ? Et : (Gt[Ht] = Et, $t(Et * qt, Ft)), K), pt = Lt(xt, Ft);
    return Wt.reduceRight((Et, qt, Ht) => qt === L ? Et : (Gt[Ht] = $t(Et * Gt[Ht], Ft), $t(Et * qt, Ft)), pt), Gt;
  }
  function Mt(Wt) {
    const Ft = Wt.length * 8 - oe * 8, Gt = ut(Wt);
    return Ft > 0 ? Gt >> BigInt(Ft) : Gt;
  }
  function Kt(Wt, Ft = !1) {
    const Gt = Mt(Wt);
    if (Ft)
      return Gt;
    const { n: xt } = ne;
    return Gt >= xt ? Gt - xt : Gt;
  }
  let zt, Ct;
  class kt {
    constructor(Ft, Gt) {
      if (this.hashLen = Ft, this.qByteLen = Gt, typeof Ft != "number" || Ft < 2)
        throw new Error("hashLen must be a number");
      if (typeof Gt != "number" || Gt < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Ft).fill(1), this.k = new Uint8Array(Ft).fill(0), this.counter = 0;
    }
    hmac(...Ft) {
      return A.utils.hmacSha256(this.k, ...Ft);
    }
    hmacSync(...Ft) {
      return Ct(this.k, ...Ft);
    }
    checkSync() {
      if (typeof Ct != "function")
        throw new dt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Ft = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Ft), this.v = await this.hmac(this.v), Ft.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Ft), this.v = await this.hmac(this.v));
    }
    reseedSync(Ft = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Ft), this.v = this.hmacSync(this.v), Ft.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Ft), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Ft = 0;
      const Gt = [];
      for (; Ft < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const xt = this.v.slice();
        Gt.push(xt), Ft += this.v.length;
      }
      return wt(...Gt);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Ft = 0;
      const Gt = [];
      for (; Ft < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const xt = this.v.slice();
        Gt.push(xt), Ft += this.v.length;
      }
      return wt(...Gt);
    }
  }
  function Vt(Wt) {
    return L < Wt && Wt < ne.n;
  }
  function nr(Wt) {
    return L < Wt && Wt < ne.P;
  }
  function ar(Wt, Ft, Gt, xt = !0) {
    const { n: pt } = ne, Et = Kt(Wt, !0);
    if (!Vt(Et))
      return;
    const qt = Lt(Et, pt), Ht = Pt.BASE.multiply(Et), Yt = $t(Ht.x, pt);
    if (Yt === L)
      return;
    const Qt = $t(qt * $t(Ft + Gt * Yt, pt), pt);
    if (Qt === L)
      return;
    let or = new It(Yt, Qt), cr = (Ht.x === or.r ? 0 : 2) | Number(Ht.y & K);
    return xt && or.hasHighS() && (or = or.normalizeS(), cr ^= 1), { sig: or, recovery: cr };
  }
  function sr(Wt) {
    let Ft;
    if (typeof Wt == "bigint")
      Ft = Wt;
    else if (typeof Wt == "number" && Number.isSafeInteger(Wt) && Wt > 0)
      Ft = BigInt(Wt);
    else if (typeof Wt == "string") {
      if (Wt.length !== 2 * oe)
        throw new Error("Expected 32 bytes of private key");
      Ft = ht(Wt);
    } else if (Wt instanceof Uint8Array) {
      if (Wt.length !== oe)
        throw new Error("Expected 32 bytes of private key");
      Ft = ut(Wt);
    } else
      throw new TypeError("Expected valid private key");
    if (!Vt(Ft))
      throw new Error("Expected private key: 0 < key < n");
    return Ft;
  }
  function lr(Wt) {
    return Wt instanceof Pt ? (Wt.assertValidity(), Wt) : Pt.fromHex(Wt);
  }
  function dr(Wt) {
    if (Wt instanceof It)
      return Wt.assertValidity(), Wt;
    try {
      return It.fromDER(Wt);
    } catch {
      return It.fromCompact(Wt);
    }
  }
  function rr(Wt, Ft = !1) {
    return Pt.fromPrivateKey(Wt).toRawBytes(Ft);
  }
  A.getPublicKey = rr;
  function Pr(Wt, Ft, Gt, xt = !1) {
    return Pt.fromSignature(Wt, Ft, Gt).toRawBytes(xt);
  }
  A.recoverPublicKey = Pr;
  function ur(Wt) {
    const Ft = Wt instanceof Uint8Array, Gt = typeof Wt == "string", xt = (Ft || Gt) && Wt.length;
    return Ft ? xt === Ce || xt === it : Gt ? xt === Ce * 2 || xt === it * 2 : Wt instanceof Pt;
  }
  function pr(Wt, Ft, Gt = !1) {
    if (ur(Wt))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!ur(Ft))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const xt = lr(Ft);
    return xt.assertValidity(), xt.multiply(sr(Wt)).toRawBytes(Gt);
  }
  A.getSharedSecret = pr;
  function br(Wt) {
    const Ft = Wt.length > re ? Wt.slice(0, re) : Wt;
    return ut(Ft);
  }
  function hr(Wt) {
    const Ft = br(Wt), Gt = $t(Ft, ne.n);
    return xr(Gt < L ? Ft : Gt);
  }
  function xr(Wt) {
    return st(Wt);
  }
  function Mr(Wt, Ft, Gt) {
    if (Wt == null)
      throw new Error(`sign: expected valid message hash, not "${Wt}"`);
    const xt = gt(Wt), pt = sr(Ft), Et = [xr(pt), hr(xt)];
    if (Gt != null) {
      Gt === !0 && (Gt = A.utils.randomBytes(re));
      const Yt = gt(Gt);
      if (Yt.length !== re)
        throw new Error(`sign: Expected ${re} bytes of extra data`);
      Et.push(Yt);
    }
    const qt = wt(...Et), Ht = br(xt);
    return { seed: qt, m: Ht, d: pt };
  }
  function _r(Wt, Ft) {
    const { sig: Gt, recovery: xt } = Wt, { der: pt, recovered: Et } = Object.assign({ canonical: !0, der: !0 }, Ft), qt = pt ? Gt.toDERRawBytes() : Gt.toCompactRawBytes();
    return Et ? [qt, xt] : qt;
  }
  async function Rr(Wt, Ft, Gt = {}) {
    const { seed: xt, m: pt, d: Et } = Mr(Wt, Ft, Gt.extraEntropy), qt = new kt(ke, oe);
    await qt.reseed(xt);
    let Ht;
    for (; !(Ht = ar(await qt.generate(), pt, Et, Gt.canonical)); )
      await qt.reseed();
    return _r(Ht, Gt);
  }
  A.sign = Rr;
  function kr(Wt, Ft, Gt = {}) {
    const { seed: xt, m: pt, d: Et } = Mr(Wt, Ft, Gt.extraEntropy), qt = new kt(ke, oe);
    qt.reseedSync(xt);
    let Ht;
    for (; !(Ht = ar(qt.generateSync(), pt, Et, Gt.canonical)); )
      qt.reseedSync();
    return _r(Ht, Gt);
  }
  A.signSync = kr;
  const Ot = { strict: !0 };
  function At(Wt, Ft, Gt, xt = Ot) {
    let pt;
    try {
      pt = dr(Wt), Ft = gt(Ft);
    } catch {
      return !1;
    }
    const { r: Et, s: qt } = pt;
    if (xt.strict && pt.hasHighS())
      return !1;
    const Ht = Kt(Ft);
    let Yt;
    try {
      Yt = lr(Gt);
    } catch {
      return !1;
    }
    const { n: Qt } = ne, or = Lt(qt, Qt), cr = $t(Ht * or, Qt), Dt = $t(Et * or, Qt), er = Pt.BASE.multiplyAndAddUnsafe(Yt, cr, Dt);
    return er ? $t(er.x, Qt) === Et : !1;
  }
  A.verify = At;
  function Bt(Wt) {
    return $t(ut(Wt), ne.n);
  }
  class Ut {
    constructor(Ft, Gt) {
      this.r = Ft, this.s = Gt, this.assertValidity();
    }
    static fromHex(Ft) {
      const Gt = gt(Ft);
      if (Gt.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Gt.length}`);
      const xt = ut(Gt.subarray(0, 32)), pt = ut(Gt.subarray(32, 64));
      return new Ut(xt, pt);
    }
    assertValidity() {
      const { r: Ft, s: Gt } = this;
      if (!nr(Ft) || !Vt(Gt))
        throw new Error("Invalid signature");
    }
    toHex() {
      return nt(this.r) + nt(this.s);
    }
    toRawBytes() {
      return bt(this.toHex());
    }
  }
  function Xt(Wt) {
    return Pt.fromPrivateKey(Wt).toRawX();
  }
  class Zt {
    constructor(Ft, Gt, xt = A.utils.randomBytes()) {
      if (Ft == null)
        throw new TypeError(`sign: Expected valid message, not "${Ft}"`);
      this.m = gt(Ft);
      const { x: pt, scalar: Et } = this.getScalar(sr(Gt));
      if (this.px = pt, this.d = Et, this.rand = gt(xt), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Ft) {
      const Gt = Pt.fromPrivateKey(Ft), xt = Gt.hasEvenY() ? Ft : ne.n - Ft;
      return { point: Gt, scalar: xt, x: Gt.toRawX() };
    }
    initNonce(Ft, Gt) {
      return st(Ft ^ ut(Gt));
    }
    finalizeNonce(Ft) {
      const Gt = $t(ut(Ft), ne.n);
      if (Gt === L)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: xt, x: pt, scalar: Et } = this.getScalar(Gt);
      return { R: xt, rx: pt, k: Et };
    }
    finalizeSig(Ft, Gt, xt, pt) {
      return new Ut(Ft.x, $t(Gt + xt * pt, ne.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Ft, d: Gt, px: xt, rand: pt } = this, Et = A.utils.taggedHash, qt = this.initNonce(Gt, await Et(Ir.aux, pt)), { R: Ht, rx: Yt, k: Qt } = this.finalizeNonce(await Et(Ir.nonce, qt, xt, Ft)), or = Bt(await Et(Ir.challenge, Yt, xt, Ft)), cr = this.finalizeSig(Ht, Qt, or, Gt);
      return await $r(cr, Ft, xt) || this.error(), cr;
    }
    calcSync() {
      const { m: Ft, d: Gt, px: xt, rand: pt } = this, Et = A.utils.taggedHashSync, qt = this.initNonce(Gt, Et(Ir.aux, pt)), { R: Ht, rx: Yt, k: Qt } = this.finalizeNonce(Et(Ir.nonce, qt, xt, Ft)), or = Bt(Et(Ir.challenge, Yt, xt, Ft)), cr = this.finalizeSig(Ht, Qt, or, Gt);
      return Er(cr, Ft, xt) || this.error(), cr;
    }
  }
  async function tr(Wt, Ft, Gt) {
    return new Zt(Wt, Ft, Gt).calc();
  }
  function vr(Wt, Ft, Gt) {
    return new Zt(Wt, Ft, Gt).calcSync();
  }
  function Br(Wt, Ft, Gt) {
    const xt = Wt instanceof Ut, pt = xt ? Wt : Ut.fromHex(Wt);
    return xt && pt.assertValidity(), {
      ...pt,
      m: gt(Ft),
      P: lr(Gt)
    };
  }
  function yr(Wt, Ft, Gt, xt) {
    const pt = Pt.BASE.multiplyAndAddUnsafe(Ft, sr(Gt), $t(-xt, ne.n));
    return !(!pt || !pt.hasEvenY() || pt.x !== Wt);
  }
  async function $r(Wt, Ft, Gt) {
    try {
      const { r: xt, s: pt, m: Et, P: qt } = Br(Wt, Ft, Gt), Ht = Bt(await A.utils.taggedHash(Ir.challenge, st(xt), qt.toRawX(), Et));
      return yr(xt, qt, pt, Ht);
    } catch {
      return !1;
    }
  }
  function Er(Wt, Ft, Gt) {
    try {
      const { r: xt, s: pt, m: Et, P: qt } = Br(Wt, Ft, Gt), Ht = Bt(A.utils.taggedHashSync(Ir.challenge, st(xt), qt.toRawX(), Et));
      return yr(xt, qt, pt, Ht);
    } catch (xt) {
      if (xt instanceof dt)
        throw xt;
      return !1;
    }
  }
  A.schnorr = {
    Signature: Ut,
    getPublicKey: Xt,
    sign: tr,
    verify: $r,
    signSync: vr,
    verifySync: Er
  }, Pt.BASE._setWindowSize(8);
  const wr = {
    node: B,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Ir = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Or = {};
  A.utils = {
    bytesToHex: rt,
    hexToBytes: bt,
    concatBytes: wt,
    mod: $t,
    invert: Lt,
    isValidPrivateKey(Wt) {
      try {
        return sr(Wt), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: st,
    _normalizePrivateKey: sr,
    hashToPrivateKey: (Wt) => {
      Wt = gt(Wt);
      const Ft = oe + 8;
      if (Wt.length < Ft || Wt.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Gt = $t(ut(Wt), ne.n - K) + K;
      return st(Gt);
    },
    randomBytes: (Wt = 32) => {
      if (wr.web)
        return wr.web.getRandomValues(new Uint8Array(Wt));
      if (wr.node) {
        const { randomBytes: Ft } = wr.node;
        return Uint8Array.from(Ft(Wt));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => A.utils.hashToPrivateKey(A.utils.randomBytes(oe + 8)),
    precompute(Wt = 8, Ft = Pt.BASE) {
      const Gt = Ft === Pt.BASE ? Ft : new Pt(Ft.x, Ft.y);
      return Gt._setWindowSize(Wt), Gt.multiply(W), Gt;
    },
    sha256: async (...Wt) => {
      if (wr.web) {
        const Ft = await wr.web.subtle.digest("SHA-256", wt(...Wt));
        return new Uint8Array(Ft);
      } else if (wr.node) {
        const { createHash: Ft } = wr.node, Gt = Ft("sha256");
        return Wt.forEach((xt) => Gt.update(xt)), Uint8Array.from(Gt.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Wt, ...Ft) => {
      if (wr.web) {
        const Gt = await wr.web.subtle.importKey("raw", Wt, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), xt = wt(...Ft), pt = await wr.web.subtle.sign("HMAC", Gt, xt);
        return new Uint8Array(pt);
      } else if (wr.node) {
        const { createHmac: Gt } = wr.node, xt = Gt("sha256", Wt);
        return Ft.forEach((pt) => xt.update(pt)), Uint8Array.from(xt.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Wt, ...Ft) => {
      let Gt = Or[Wt];
      if (Gt === void 0) {
        const xt = await A.utils.sha256(Uint8Array.from(Wt, (pt) => pt.charCodeAt(0)));
        Gt = wt(xt, xt), Or[Wt] = Gt;
      }
      return A.utils.sha256(Gt, ...Ft);
    },
    taggedHashSync: (Wt, ...Ft) => {
      if (typeof zt != "function")
        throw new dt("sha256Sync is undefined, you need to set it");
      let Gt = Or[Wt];
      if (Gt === void 0) {
        const xt = zt(Uint8Array.from(Wt, (pt) => pt.charCodeAt(0)));
        Gt = wt(xt, xt), Or[Wt] = Gt;
      }
      return zt(Gt, ...Ft);
    },
    _JacobianPoint: yt
  }, Object.defineProperties(A.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return zt;
      },
      set(Wt) {
        zt || (zt = Wt);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Ct;
      },
      set(Wt) {
        Ct || (Ct = Wt);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(A) {
  return (A / 8 | 0) + (A % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(A) {
  const B = paramBytesForAlg[A];
  if (B)
    return B;
  throw new Error(`Unknown algorithm "${A}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(A) {
  if (A instanceof Uint8Array)
    return A;
  if (typeof A == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(A));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(A, B) {
  const L = signatureAsBytes(A), K = getParamBytesForAlg(B), V = K + 1, W = L.length;
  let J = 0;
  if (L[J++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ne = L[J++];
  if (ne === (MAX_OCTET | 1) && (ne = L[J++]), W - J < ne)
    throw new Error(`"seq" specified length of "${ne}", only "${W - J}" remaining`);
  if (L[J++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ie = L[J++];
  if (W - J - 2 < ie)
    throw new Error(`"r" specified length of "${ie}", only "${W - J - 2}" available`);
  if (V < ie)
    throw new Error(`"r" specified length of "${ie}", max of "${V}" is acceptable`);
  const ce = J;
  if (J += ie, L[J++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const re = L[J++];
  if (W - J !== re)
    throw new Error(`"s" specified length of "${re}", expected "${W - J}"`);
  if (V < re)
    throw new Error(`"s" specified length of "${re}", max of "${V}" is acceptable`);
  const oe = J;
  if (J += re, J !== W)
    throw new Error(`Expected to consume entire array, but "${W - J}" bytes remain`);
  const ke = K - ie, Ce = K - re, it = new Uint8Array(ke + ie + Ce + re);
  for (J = 0; J < ke; ++J)
    it[J] = 0;
  it.set(L.subarray(ce + Math.max(-ke, 0), ce + ie), J), J = K;
  for (const at = J; J < at + Ce; ++J)
    it[J] = 0;
  return it.set(L.subarray(oe + Math.max(-Ce, 0), oe + re), J), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(it));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(A, B, L) {
  let K = 0;
  for (; B + K < L && A[B + K] === 0; )
    ++K;
  return A[B + K] >= MAX_OCTET && --K, K;
}
function joseToDer(A, B) {
  A = signatureAsBytes(A);
  const L = getParamBytesForAlg(B), K = A.length;
  if (K !== L * 2)
    throw new TypeError(`"${B}" signatures must be "${L * 2}" bytes, saw "${K}"`);
  const V = countPadding(A, 0, L), W = countPadding(A, L, A.length), J = L - V, ne = L - W, ie = 2 + J + 1 + 1 + ne, ce = ie < MAX_OCTET, re = new Uint8Array((ce ? 2 : 3) + ie);
  let oe = 0;
  return re[oe++] = ENCODED_TAG_SEQ, ce ? re[oe++] = ie : (re[oe++] = MAX_OCTET | 1, re[oe++] = ie & 255), re[oe++] = ENCODED_TAG_INT, re[oe++] = J, V < 0 ? (re[oe++] = 0, re.set(A.subarray(0, L), oe), oe += L) : (re.set(A.subarray(V, L), oe), oe += L - V), re[oe++] = ENCODED_TAG_INT, re[oe++] = ne, W < 0 ? (re[oe++] = 0, re.set(A.subarray(L), oe)) : re.set(A.subarray(L + W), oe), re;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(B) {
    super(), this.name = "MissingParametersError", this.message = B || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(B) {
    super(), this.name = "InvalidTokenError", this.message = B || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (A, ...B) => {
  const L = hmac_1.hmac.create(sha256_1$3.sha256, A);
  return B.forEach((K) => L.update(K)), L.digest();
};
class SECP256K1Client {
  static derivePublicKey(B, L = !0) {
    return B.length === 66 && (B = B.slice(0, 64)), B.length < 64 && (B = B.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(B, L));
  }
  static signHash(B, L, K = "jose") {
    if (!B || !L)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const V = secp.signSync(B, L.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (K === "der")
      return (0, utils_1$2.bytesToHex)(V);
    if (K === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(V, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(B) {
    return (0, ecdsaSigFormatter_1.joseToDer)(B, "ES256");
  }
  static verifyHash(B, L, K) {
    if (!B || !L || !K)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(L, B, K, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.cryptoClients = A.SECP256K1Client = void 0;
  const B = secp256k1$1;
  Object.defineProperty(A, "SECP256K1Client", { enumerable: !0, get: function() {
    return B.SECP256K1Client;
  } });
  const L = {
    ES256K: B.SECP256K1Client
  };
  A.cryptoClients = L;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function V(W) {
    return W instanceof L ? W : new L(function(J) {
      J(W);
    });
  }
  return new (L || (L = Promise))(function(W, J) {
    function ne(re) {
      try {
        ce(K.next(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ie(re) {
      try {
        ce(K.throw(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ce(re) {
      re.done ? W(re.value) : V(re.value).then(ne, ie);
    }
    ce((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(A) {
  return (0, sha256_1$2.sha256)(A);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(A) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const L = typeof A == "string" ? new TextEncoder().encode(A) : A, K = yield crypto.subtle.digest("SHA-256", L);
        return new Uint8Array(K);
      } else {
        const L = requireCryptoBrowserify();
        if (!L.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(L.createHash("sha256").update(A).digest());
      }
    } catch (B) {
      return console.log(B), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(A));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function V(W) {
    return W instanceof L ? W : new L(function(J) {
      J(W);
    });
  }
  return new (L || (L = Promise))(function(W, J) {
    function ne(re) {
      try {
        ce(K.next(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ie(re) {
      try {
        ce(K.throw(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ce(re) {
      re.done ? W(re.value) : V(re.value).then(ne, ie);
    }
    ce((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(A, B) {
  const L = [], K = base64url$2.encode(JSON.stringify(B));
  L.push(K);
  const V = base64url$2.encode(JSON.stringify(A));
  return L.push(V), L.join(".");
}
function createUnsecuredToken(A) {
  return createSigningInput(A, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof B != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (B = B.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(B))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[B], this.rawPrivateKey = L;
  }
  header(B = {}) {
    const L = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, L, B);
  }
  sign(B, L = !1, K = {}) {
    const V = this.header(K), W = createSigningInput(B, V), J = (0, sha256_1$1.hashSha256)(W);
    return this.createWithSignedHash(B, L, V, W, J);
  }
  signAsync(B, L = !1, K = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const V = this.header(K), W = createSigningInput(B, V), J = yield (0, sha256_1$1.hashSha256Async)(W);
      return this.createWithSignedHash(B, L, V, W, J);
    });
  }
  createWithSignedHash(B, L, K, V, W) {
    const J = this.cryptoClient.signHash(W, this.rawPrivateKey);
    return L ? {
      header: [base64url$2.encode(JSON.stringify(K))],
      payload: JSON.stringify(B),
      signature: [J]
    } : [V, J].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof B != "string")
      throw "signing algorithm parameter must be a string";
    if (B = B.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(B))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[B], this.rawPublicKey = L;
  }
  verify(B) {
    return typeof B == "string" ? this.verifyCompact(B, !1) : typeof B == "object" ? this.verifyExpanded(B, !1) : !1;
  }
  verifyAsync(B) {
    return typeof B == "string" ? this.verifyCompact(B, !0) : typeof B == "object" ? this.verifyExpanded(B, !0) : Promise.resolve(!1);
  }
  verifyCompact(B, L) {
    const K = B.split("."), V = K[0] + "." + K[1], W = (J) => {
      const ne = this.cryptoClient.loadSignature(K[2]);
      return this.cryptoClient.verifyHash(J, ne, this.rawPublicKey);
    };
    if (L)
      return (0, sha256_1.hashSha256Async)(V).then((J) => W(J));
    {
      const J = (0, sha256_1.hashSha256)(V);
      return W(J);
    }
  }
  verifyExpanded(B, L) {
    const K = [B.header.join("."), base64url$1.encode(B.payload)].join(".");
    let V = !0;
    const W = (J) => (B.signature.map((ne) => {
      const ie = this.cryptoClient.loadSignature(ne);
      this.cryptoClient.verifyHash(J, ie, this.rawPublicKey) || (V = !1);
    }), V);
    if (L)
      return (0, sha256_1.hashSha256Async)(K).then((J) => W(J));
    {
      const J = (0, sha256_1.hashSha256)(K);
      return W(J);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(A) {
  if (typeof A == "string") {
    const B = A.split("."), L = JSON.parse(base64url.decode(B[0])), K = JSON.parse(base64url.decode(B[1])), V = B[2];
    return {
      header: L,
      payload: K,
      signature: V
    };
  } else if (typeof A == "object") {
    if (typeof A.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let B = A.payload;
    A.payload[0] !== "{" && (B = base64url.decode(B));
    const L = [];
    return A.header.map((K) => {
      const V = JSON.parse(base64url.decode(K));
      L.push(V);
    }), {
      header: L,
      payload: JSON.parse(B),
      signature: A.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(A) {
  var B = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(K, V, W, J) {
    J === void 0 && (J = W);
    var ne = Object.getOwnPropertyDescriptor(V, W);
    (!ne || ("get" in ne ? !V.__esModule : ne.writable || ne.configurable)) && (ne = { enumerable: !0, get: function() {
      return V[W];
    } }), Object.defineProperty(K, J, ne);
  } : function(K, V, W, J) {
    J === void 0 && (J = W), K[J] = V[W];
  }), L = commonjsGlobal && commonjsGlobal.__exportStar || function(K, V) {
    for (var W in K) W !== "default" && !Object.prototype.hasOwnProperty.call(V, W) && B(V, K, W);
  };
  Object.defineProperty(A, "__esModule", { value: !0 }), L(signer, A), L(verifier, A), L(decode$i, A), L(errors$1, A), L(cryptoClients, A);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const A = Array(256).fill(-1);
  for (let B = 0; B < r.length; ++B) A[r.charCodeAt(B)] = B;
})();
var s, i, o, h$1 = (s = function(A, B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bech32m = B.bech32 = void 0;
  const L = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", K = {};
  for (let oe = 0; oe < 32; oe++) {
    const ke = L.charAt(oe);
    K[ke] = oe;
  }
  function V(oe) {
    const ke = oe >> 25;
    return (33554431 & oe) << 5 ^ 996825010 & -(ke >> 0 & 1) ^ 642813549 & -(ke >> 1 & 1) ^ 513874426 & -(ke >> 2 & 1) ^ 1027748829 & -(ke >> 3 & 1) ^ 705979059 & -(ke >> 4 & 1);
  }
  function W(oe) {
    let ke = 1;
    for (let Ce = 0; Ce < oe.length; ++Ce) {
      const it = oe.charCodeAt(Ce);
      if (it < 33 || it > 126) return "Invalid prefix (" + oe + ")";
      ke = V(ke) ^ it >> 5;
    }
    ke = V(ke);
    for (let Ce = 0; Ce < oe.length; ++Ce) {
      const it = oe.charCodeAt(Ce);
      ke = V(ke) ^ 31 & it;
    }
    return ke;
  }
  function J(oe, ke, Ce, it) {
    let at = 0, ct = 0;
    const dt = (1 << Ce) - 1, ot = [];
    for (let yt = 0; yt < oe.length; ++yt) for (at = at << ke | oe[yt], ct += ke; ct >= Ce; ) ct -= Ce, ot.push(at >> ct & dt);
    if (it) ct > 0 && ot.push(at << Ce - ct & dt);
    else {
      if (ct >= ke) return "Excess padding";
      if (at << Ce - ct & dt) return "Non-zero padding";
    }
    return ot;
  }
  function ne(oe) {
    return J(oe, 8, 5, !0);
  }
  function ie(oe) {
    const ke = J(oe, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
  }
  function ce(oe) {
    const ke = J(oe, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
    throw new Error(ke);
  }
  function re(oe) {
    let ke;
    function Ce(it, at) {
      if (at = at || 90, it.length < 8) return it + " too short";
      if (it.length > at) return "Exceeds length limit";
      const ct = it.toLowerCase(), dt = it.toUpperCase();
      if (it !== ct && it !== dt) return "Mixed-case string " + it;
      const ot = (it = ct).lastIndexOf("1");
      if (ot === -1) return "No separator character for " + it;
      if (ot === 0) return "Missing prefix for " + it;
      const yt = it.slice(0, ot), mt = it.slice(ot + 1);
      if (mt.length < 6) return "Data too short";
      let Tt = W(yt);
      if (typeof Tt == "string") return Tt;
      const Pt = [];
      for (let Nt = 0; Nt < mt.length; ++Nt) {
        const St = mt.charAt(Nt), vt = K[St];
        if (vt === void 0) return "Unknown character " + St;
        Tt = V(Tt) ^ vt, Nt + 6 >= mt.length || Pt.push(vt);
      }
      return Tt !== ke ? "Invalid checksum for " + it : { prefix: yt, words: Pt };
    }
    return ke = oe === "bech32" ? 1 : 734539939, { decodeUnsafe: function(it, at) {
      const ct = Ce(it, at);
      if (typeof ct == "object") return ct;
    }, decode: function(it, at) {
      const ct = Ce(it, at);
      if (typeof ct == "object") return ct;
      throw new Error(ct);
    }, encode: function(it, at, ct) {
      if (ct = ct || 90, it.length + 7 + at.length > ct) throw new TypeError("Exceeds length limit");
      let dt = W(it = it.toLowerCase());
      if (typeof dt == "string") throw new Error(dt);
      let ot = it + "1";
      for (let yt = 0; yt < at.length; ++yt) {
        const mt = at[yt];
        if (mt >> 5) throw new Error("Non 5-bit word");
        dt = V(dt) ^ mt, ot += L.charAt(mt);
      }
      for (let yt = 0; yt < 6; ++yt) dt = V(dt);
      dt ^= ke;
      for (let yt = 0; yt < 6; ++yt) ot += L.charAt(dt >> 5 * (5 - yt) & 31);
      return ot;
    }, toWords: ne, fromWordsUnsafe: ie, fromWords: ce };
  }
  B.bech32 = re("bech32"), B.bech32m = re("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(A) {
  A.mainnet = "mainnet", A.testnet = "testnet", A.regtest = "regtest";
})(x || (x = {})), function(A) {
  A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
async function getProviderOrThrow(A) {
  var L;
  const B = await (A == null ? void 0 : A()) || ((L = window.XverseProviders) == null ? void 0 : L.BitcoinProvider) || window.BitcoinProvider;
  if (!B)
    throw new Error("No Bitcoin wallet installed");
  return B;
}
var BitcoinNetworkType = /* @__PURE__ */ ((A) => (A.Mainnet = "Mainnet", A.Testnet = "Testnet", A.Testnet4 = "Testnet4", A.Signet = "Signet", A.Regtest = "Regtest", A))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((A) => (A.Ordinals = "ordinals", A.Payment = "payment", A.Stacks = "stacks", A))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((A) => (A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr", A.stacks = "stacks", A))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), getAddress = async (A) => {
  var K, V;
  const B = await getProviderOrThrow(A.getProvider), { purposes: L } = A.payload;
  if (!L)
    throw new Error("Address purposes are required");
  try {
    const W = lib$1.createUnsecuredToken(A.payload), J = await B.connect(W);
    (K = A.onFinish) == null || K.call(A, J);
  } catch (W) {
    console.error("[Connect] Error during address request", W), (V = A.onCancel) == null || V.call(A);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((A) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((A) => (A.ECDSA = "ECDSA", A.BIP322 = "BIP322", A))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
async function waitForUnisatExtensionReady() {
  let A = 0;
  const B = 20;
  for (; A < B; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const L = await window.unisat.getAccounts();
        if (L && L.length > 0)
          return !0;
      } catch {
        break;
      }
    A += 1, await new Promise((L) => {
      setTimeout(L, 100);
    });
  }
  return !1;
}
const NETWORK_TO_BITCOIN_NETWORK_TYPE = {
  mainnet: BitcoinNetworkType.Mainnet,
  testnet: BitcoinNetworkType.Testnet,
  signet: BitcoinNetworkType.Signet
}, getXverseAddresses = async (A) => {
  var W;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((W = window.XverseProviders) == null ? void 0 : W.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const L = async () => window.XverseProviders.BitcoinProvider, K = [], V = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: A === Network.TESTNET ? BitcoinNetworkType.Testnet4 : NETWORK_TO_BITCOIN_NETWORK_TYPE[A]
      }
    },
    getProvider: L,
    onFinish: (J) => {
      if (!J || !J.addresses || J.addresses.length !== 2)
        throw new BrowserWalletSigningError(
          "Failed to retrieve addresses using selected wallet"
        );
      J.addresses.forEach((ne) => {
        const ie = getAddressFormat(ne.address, A);
        let ce = ne.publicKey;
        ie === "taproot" && (ce = Buffer$2.from(ne.publicKey, "hex").length === 33 ? ce : `02${ce}`), K.push({
          publicKey: ce,
          address: ne.address,
          format: ie
        });
      });
    },
    onCancel: () => {
      throw new BrowserWalletRequestCancelledByUserError();
    }
  };
  return await getAddress(V), K;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: A,
  wallet: B,
  chain: L = Chain.BITCOIN
}, { readOnly: K = !1 } = {}) => {
  switch (console.log("==>wallet", B), B) {
    case Wallet.UNISAT: {
      console.log("unisat1", A, B);
      const V = await getAddresses$3(A, L, { readOnly: K });
      if (!V || V.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const W = V[0];
      return {
        address: {
          ordinals: W.address,
          payments: W.address
        },
        publicKey: {
          ordinals: W.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: W.format,
          payments: W.format
        }
      };
    }
    case Wallet.XVERSE: {
      console.log("xverse1", A, B);
      const V = await getXverseAddresses(A);
      if (console.log("xverse1", V), !V || V.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const W = V.find(
        (ne) => ne.format === "p2sh-p2wpkh" || ne.format === "segwit"
      );
      if (!W)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const J = V.find(
        (ne) => ne.format === "taproot"
      );
      if (!J)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return console.log("xverse2", J, W), {
        address: {
          ordinals: J.address,
          payments: W.address
        },
        publicKey: {
          ordinals: J.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: J.format,
          payments: W.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const V = await getAddresses$2(A);
      if (!V || V.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const W = V.find(
        (ne) => ne.format === "segwit" || ne.format === "p2sh-p2wpkh"
      );
      if (!W)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const J = V.find(
        (ne) => ne.format === "taproot"
      );
      if (!J)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: J.address,
          payments: W.address
        },
        publicKey: {
          ordinals: J.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: J.format,
          payments: W.format
        }
      };
    }
    case Wallet.LEATHER: {
      const V = await getAddresses$1(A);
      if (!V || V.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const W = V.find(
        (ne) => ne.format === "segwit"
      );
      if (!W)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const J = V.find(
        (ne) => ne.format === "taproot"
      );
      if (!J)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: J.address,
          payments: W.address
        },
        publicKey: {
          ordinals: J.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: J.format,
          payments: W.format
        }
      };
    }
    case Wallet.OKX: {
      const V = await getAddresses(A);
      if (!V || V.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const W = V[0];
      return {
        address: {
          ordinals: W.address,
          payments: W.address
        },
        publicKey: {
          ordinals: W.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: W.format,
          payments: W.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: A,
  onError: B
}) {
  const {
    updateAddress: L,
    network: K,
    updateWallet: V,
    updatePublicKey: W,
    updateFormat: J,
    disconnectWallet: ne,
    address: ie,
    publicKey: ce,
    format: re,
    wallet: oe,
    chain: ke
  } = useOrdConnect(), Ce = (at, ct) => {
    B(ct.message ?? ct.toString()), console.error(`Error while connecting to ${at} wallet`, ct), ne(), ct instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[at],
      "_blank",
      "noopener,noreferrer"
    );
  }, it = async (at, { readOnly: ct = !1 } = {}) => {
    try {
      const { address: dt, publicKey: ot, format: yt } = await connectWallet(
        { network: K, wallet: at, chain: ke },
        { readOnly: ct }
      );
      return L({
        ordinals: dt.ordinals,
        payments: dt.payments
      }), W({
        ordinals: ot.ordinals,
        payments: ot.payments
      }), V(at), J({
        ordinals: yt.ordinals,
        payments: yt.payments
      }), A(), !0;
    } catch (dt) {
      return Ce(at, dt), !1;
    }
  };
  return useEffect(() => {
    if (console.log("connectedWallet", oe), oe !== Wallet.UNISAT) {
      console.log("connectedWallet", oe);
      return;
    }
    let at = !0, ct = !1;
    const dt = () => it(Wallet.UNISAT);
    return ie && ce && re && (async () => {
      const yt = await waitForUnisatExtensionReady();
      if (at) {
        if (!yt) {
          ne();
          return;
        }
        ct = await it(Wallet.UNISAT, {
          readOnly: !0
        }), at && ct && window.unisat.addListener("accountsChanged", dt);
      }
    })(), () => {
      at = !1, ct && window.unisat.removeListener("accountsChanged", dt);
    };
  }, [oe]), { connectWallet: it };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: A,
  onConnect: B,
  icon: L,
  renderAvatar: K,
  isPreferred: V
}) {
  const W = isMobileUserAgent(), {
    network: J,
    wallet: ne,
    address: ie,
    updateNetwork: ce
  } = useOrdConnect(), [re, oe] = useState(!1), ke = WALLET_TO_NAME[A], Ce = async () => {
    oe(!0);
    try {
      J === BitcoinNetworkType.Testnet4.toLowerCase() && ce(Network.TESTNET), await B();
    } catch {
    }
    oe(!1);
  }, it = ne === A && ie.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Ce,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: L, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: ke }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: W ? "Available on app" : "" })
        ] }),
        ne === A && ie.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          K ? K(ie.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: W ? 12 : 16,
              variant: "beam",
              name: ie.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(ie.ordinals) })
        ] }) : null,
        !it && V ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        re ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: W ? 20 : 24,
            height: W ? 20 : 24,
            alt: `${ke} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: W ? 20 : 24,
            height: W ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: A,
  closeModal: B,
  renderAvatar: L,
  preferredWallet: K,
  walletsOrder: V,
  visibleWallets: W
}) {
  const [J, ne] = useState(""), { connectWallet: ie } = useConnect({
    onClose: B,
    onError: (Ce) => ne(Ce)
  }), { network: ce, chain: re } = useOrdConnect(), oe = isMobileUserAgent(), ke = useMemo(() => {
    const it = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ie(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: oe && ce !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ie(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: oe,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ie(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ie(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ie(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: oe,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((ct) => (W || []).includes(ct.wallet)).filter(
      (ct) => ct.chains.includes(re) && !ct.hidden
    );
    return V ? it.map((ct) => {
      const dt = V.findIndex(
        (ot) => ot === ct.wallet
      );
      return dt >= 0 ? { ...ct, order: dt } : ct;
    }).sort((ct, dt) => ct.order - dt.order) : it;
  }, [oe, ce, V, ie, re]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: A, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: B,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[re],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: B,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: ke.map((Ce, it) => {
                  const at = it === ke.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Ce.wallet,
                        onConnect: async () => {
                          ne("");
                          const ct = Ce.onConnect().then((ot) => (ot && ne(""), ot)), dt = await Promise.race([
                            ct,
                            new Promise((ot) => {
                              setTimeout(() => ot("timeout"), 5e3);
                            })
                          ]);
                          return typeof dt == "string" ? (ne(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), ct) : dt;
                        },
                        icon: Ce.icon,
                        renderAvatar: L,
                        isPreferred: K === Ce.wallet
                      }
                    ),
                    !at && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Ce.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: J })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: A,
  onViewProfile: B,
  onChangeWalletClick: L,
  onDisconnectWalletClick: K,
  renderAvatar: V,
  preferredWallet: W,
  walletsOrder: J
}) {
  const {
    address: ne,
    disconnectWallet: ie,
    network: ce,
    isModalOpen: re,
    openModal: oe,
    closeModal: ke,
    visibleWallets: Ce
  } = useOrdConnect(), it = useHasMounted(), at = () => A ? null : ne != null && ne.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ne.ordinals,
      network: ce,
      onViewProfile: B,
      onChangeWallet: () => {
        oe(), L == null || L();
      },
      onDisconnectWallet: () => {
        ie(), K == null || K();
      },
      renderAvatar: V
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !it, openModal: oe });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    at(),
    it ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: re,
        closeModal: ke,
        renderAvatar: V,
        preferredWallet: W,
        walletsOrder: J,
        visibleWallets: Ce
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(A) {
  var B, L, K, V = ot.prototype = { constructor: ot, toString: null, valueOf: null }, W = new ot(1), J = 20, ne = 4, ie = -7, ce = 21, re = -1e7, oe = 1e7, ke = !1, Ce = 1, it = 0, at = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ct = "0123456789abcdefghijklmnopqrstuvwxyz", dt = !0;
  function ot(St, vt) {
    var It, wt, Oe, rt, pe, nt, st, ft, ht = this;
    if (!(ht instanceof ot)) return new ot(St, vt);
    if (vt == null) {
      if (St && St._isBigNumber === !0) {
        ht.s = St.s, !St.c || St.e > oe ? ht.c = ht.e = null : St.e < re ? ht.c = [ht.e = 0] : (ht.e = St.e, ht.c = St.c.slice());
        return;
      }
      if ((nt = typeof St == "number") && St * 0 == 0) {
        if (ht.s = 1 / St < 0 ? (St = -St, -1) : 1, St === ~~St) {
          for (rt = 0, pe = St; pe >= 10; pe /= 10, rt++) ;
          rt > oe ? ht.c = ht.e = null : (ht.e = rt, ht.c = [St]);
          return;
        }
        ft = String(St);
      } else {
        if (!isNumeric.test(ft = String(St))) return K(ht, ft, nt);
        ht.s = ft.charCodeAt(0) == 45 ? (ft = ft.slice(1), -1) : 1;
      }
      (rt = ft.indexOf(".")) > -1 && (ft = ft.replace(".", "")), (pe = ft.search(/e/i)) > 0 ? (rt < 0 && (rt = pe), rt += +ft.slice(pe + 1), ft = ft.substring(0, pe)) : rt < 0 && (rt = ft.length);
    } else {
      if (intCheck(vt, 2, ct.length, "Base"), vt == 10 && dt)
        return ht = new ot(St), Pt(ht, J + ht.e + 1, ne);
      if (ft = String(St), nt = typeof St == "number") {
        if (St * 0 != 0) return K(ht, ft, nt, vt);
        if (ht.s = 1 / St < 0 ? (ft = ft.slice(1), -1) : 1, ot.DEBUG && ft.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + St);
      } else
        ht.s = ft.charCodeAt(0) === 45 ? (ft = ft.slice(1), -1) : 1;
      for (It = ct.slice(0, vt), rt = pe = 0, st = ft.length; pe < st; pe++)
        if (It.indexOf(wt = ft.charAt(pe)) < 0) {
          if (wt == ".") {
            if (pe > rt) {
              rt = st;
              continue;
            }
          } else if (!Oe && (ft == ft.toUpperCase() && (ft = ft.toLowerCase()) || ft == ft.toLowerCase() && (ft = ft.toUpperCase()))) {
            Oe = !0, pe = -1, rt = 0;
            continue;
          }
          return K(ht, String(St), nt, vt);
        }
      nt = !1, ft = L(ft, vt, 10, ht.s), (rt = ft.indexOf(".")) > -1 ? ft = ft.replace(".", "") : rt = ft.length;
    }
    for (pe = 0; ft.charCodeAt(pe) === 48; pe++) ;
    for (st = ft.length; ft.charCodeAt(--st) === 48; ) ;
    if (ft = ft.slice(pe, ++st)) {
      if (st -= pe, nt && ot.DEBUG && st > 15 && (St > MAX_SAFE_INTEGER$2 || St !== mathfloor(St)))
        throw Error(tooManyDigits + ht.s * St);
      if ((rt = rt - pe - 1) > oe)
        ht.c = ht.e = null;
      else if (rt < re)
        ht.c = [ht.e = 0];
      else {
        if (ht.e = rt, ht.c = [], pe = (rt + 1) % LOG_BASE, rt < 0 && (pe += LOG_BASE), pe < st) {
          for (pe && ht.c.push(+ft.slice(0, pe)), st -= LOG_BASE; pe < st; )
            ht.c.push(+ft.slice(pe, pe += LOG_BASE));
          pe = LOG_BASE - (ft = ft.slice(pe)).length;
        } else
          pe -= st;
        for (; pe--; ft += "0") ;
        ht.c.push(+ft);
      }
    } else
      ht.c = [ht.e = 0];
  }
  ot.clone = clone, ot.ROUND_UP = 0, ot.ROUND_DOWN = 1, ot.ROUND_CEIL = 2, ot.ROUND_FLOOR = 3, ot.ROUND_HALF_UP = 4, ot.ROUND_HALF_DOWN = 5, ot.ROUND_HALF_EVEN = 6, ot.ROUND_HALF_CEIL = 7, ot.ROUND_HALF_FLOOR = 8, ot.EUCLID = 9, ot.config = ot.set = function(St) {
    var vt, It;
    if (St != null)
      if (typeof St == "object") {
        if (St.hasOwnProperty(vt = "DECIMAL_PLACES") && (It = St[vt], intCheck(It, 0, MAX, vt), J = It), St.hasOwnProperty(vt = "ROUNDING_MODE") && (It = St[vt], intCheck(It, 0, 8, vt), ne = It), St.hasOwnProperty(vt = "EXPONENTIAL_AT") && (It = St[vt], It && It.pop ? (intCheck(It[0], -1e9, 0, vt), intCheck(It[1], 0, MAX, vt), ie = It[0], ce = It[1]) : (intCheck(It, -1e9, MAX, vt), ie = -(ce = It < 0 ? -It : It))), St.hasOwnProperty(vt = "RANGE"))
          if (It = St[vt], It && It.pop)
            intCheck(It[0], -1e9, -1, vt), intCheck(It[1], 1, MAX, vt), re = It[0], oe = It[1];
          else if (intCheck(It, -1e9, MAX, vt), It)
            re = -(oe = It < 0 ? -It : It);
          else
            throw Error(bignumberError + vt + " cannot be zero: " + It);
        if (St.hasOwnProperty(vt = "CRYPTO"))
          if (It = St[vt], It === !!It)
            if (It)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                ke = It;
              else
                throw ke = !It, Error(bignumberError + "crypto unavailable");
            else
              ke = It;
          else
            throw Error(bignumberError + vt + " not true or false: " + It);
        if (St.hasOwnProperty(vt = "MODULO_MODE") && (It = St[vt], intCheck(It, 0, 9, vt), Ce = It), St.hasOwnProperty(vt = "POW_PRECISION") && (It = St[vt], intCheck(It, 0, MAX, vt), it = It), St.hasOwnProperty(vt = "FORMAT"))
          if (It = St[vt], typeof It == "object") at = It;
          else throw Error(bignumberError + vt + " not an object: " + It);
        if (St.hasOwnProperty(vt = "ALPHABET"))
          if (It = St[vt], typeof It == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(It))
            dt = It.slice(0, 10) == "0123456789", ct = It;
          else
            throw Error(bignumberError + vt + " invalid: " + It);
      } else
        throw Error(bignumberError + "Object expected: " + St);
    return {
      DECIMAL_PLACES: J,
      ROUNDING_MODE: ne,
      EXPONENTIAL_AT: [ie, ce],
      RANGE: [re, oe],
      CRYPTO: ke,
      MODULO_MODE: Ce,
      POW_PRECISION: it,
      FORMAT: at,
      ALPHABET: ct
    };
  }, ot.isBigNumber = function(St) {
    if (!St || St._isBigNumber !== !0) return !1;
    if (!ot.DEBUG) return !0;
    var vt, It, wt = St.c, Oe = St.e, rt = St.s;
    e: if ({}.toString.call(wt) == "[object Array]") {
      if ((rt === 1 || rt === -1) && Oe >= -1e9 && Oe <= MAX && Oe === mathfloor(Oe)) {
        if (wt[0] === 0) {
          if (Oe === 0 && wt.length === 1) return !0;
          break e;
        }
        if (vt = (Oe + 1) % LOG_BASE, vt < 1 && (vt += LOG_BASE), String(wt[0]).length == vt) {
          for (vt = 0; vt < wt.length; vt++)
            if (It = wt[vt], It < 0 || It >= BASE || It !== mathfloor(It)) break e;
          if (It !== 0) return !0;
        }
      }
    } else if (wt === null && Oe === null && (rt === null || rt === 1 || rt === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + St);
  }, ot.maximum = ot.max = function() {
    return mt(arguments, -1);
  }, ot.minimum = ot.min = function() {
    return mt(arguments, 1);
  }, ot.random = function() {
    var St = 9007199254740992, vt = Math.random() * St & 2097151 ? function() {
      return mathfloor(Math.random() * St);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(It) {
      var wt, Oe, rt, pe, nt, st = 0, ft = [], ht = new ot(W);
      if (It == null ? It = J : intCheck(It, 0, MAX), pe = mathceil(It / LOG_BASE), ke)
        if (crypto.getRandomValues) {
          for (wt = crypto.getRandomValues(new Uint32Array(pe *= 2)); st < pe; )
            nt = wt[st] * 131072 + (wt[st + 1] >>> 11), nt >= 9e15 ? (Oe = crypto.getRandomValues(new Uint32Array(2)), wt[st] = Oe[0], wt[st + 1] = Oe[1]) : (ft.push(nt % 1e14), st += 2);
          st = pe / 2;
        } else if (crypto.randomBytes) {
          for (wt = crypto.randomBytes(pe *= 7); st < pe; )
            nt = (wt[st] & 31) * 281474976710656 + wt[st + 1] * 1099511627776 + wt[st + 2] * 4294967296 + wt[st + 3] * 16777216 + (wt[st + 4] << 16) + (wt[st + 5] << 8) + wt[st + 6], nt >= 9e15 ? crypto.randomBytes(7).copy(wt, st) : (ft.push(nt % 1e14), st += 7);
          st = pe / 7;
        } else
          throw ke = !1, Error(bignumberError + "crypto unavailable");
      if (!ke)
        for (; st < pe; )
          nt = vt(), nt < 9e15 && (ft[st++] = nt % 1e14);
      for (pe = ft[--st], It %= LOG_BASE, pe && It && (nt = POWS_TEN[LOG_BASE - It], ft[st] = mathfloor(pe / nt) * nt); ft[st] === 0; ft.pop(), st--) ;
      if (st < 0)
        ft = [rt = 0];
      else {
        for (rt = -1; ft[0] === 0; ft.splice(0, 1), rt -= LOG_BASE) ;
        for (st = 1, nt = ft[0]; nt >= 10; nt /= 10, st++) ;
        st < LOG_BASE && (rt -= LOG_BASE - st);
      }
      return ht.e = rt, ht.c = ft, ht;
    };
  }(), ot.sum = function() {
    for (var St = 1, vt = arguments, It = new ot(vt[0]); St < vt.length; ) It = It.plus(vt[St++]);
    return It;
  }, L = /* @__PURE__ */ function() {
    var St = "0123456789";
    function vt(It, wt, Oe, rt) {
      for (var pe, nt = [0], st, ft = 0, ht = It.length; ft < ht; ) {
        for (st = nt.length; st--; nt[st] *= wt) ;
        for (nt[0] += rt.indexOf(It.charAt(ft++)), pe = 0; pe < nt.length; pe++)
          nt[pe] > Oe - 1 && (nt[pe + 1] == null && (nt[pe + 1] = 0), nt[pe + 1] += nt[pe] / Oe | 0, nt[pe] %= Oe);
      }
      return nt.reverse();
    }
    return function(It, wt, Oe, rt, pe) {
      var nt, st, ft, ht, bt, ut, gt, lt, $t = It.indexOf("."), jt = J, Jt = ne;
      for ($t >= 0 && (ht = it, it = 0, It = It.replace(".", ""), lt = new ot(wt), ut = lt.pow(It.length - $t), it = ht, lt.c = vt(
        toFixedPoint(coeffToString(ut.c), ut.e, "0"),
        10,
        Oe,
        St
      ), lt.e = lt.c.length), gt = vt(It, wt, Oe, pe ? (nt = ct, St) : (nt = St, ct)), ft = ht = gt.length; gt[--ht] == 0; gt.pop()) ;
      if (!gt[0]) return nt.charAt(0);
      if ($t < 0 ? --ft : (ut.c = gt, ut.e = ft, ut.s = rt, ut = B(ut, lt, jt, Jt, Oe), gt = ut.c, bt = ut.r, ft = ut.e), st = ft + jt + 1, $t = gt[st], ht = Oe / 2, bt = bt || st < 0 || gt[st + 1] != null, bt = Jt < 4 ? ($t != null || bt) && (Jt == 0 || Jt == (ut.s < 0 ? 3 : 2)) : $t > ht || $t == ht && (Jt == 4 || bt || Jt == 6 && gt[st - 1] & 1 || Jt == (ut.s < 0 ? 8 : 7)), st < 1 || !gt[0])
        It = bt ? toFixedPoint(nt.charAt(1), -jt, nt.charAt(0)) : nt.charAt(0);
      else {
        if (gt.length = st, bt)
          for (--Oe; ++gt[--st] > Oe; )
            gt[st] = 0, st || (++ft, gt = [1].concat(gt));
        for (ht = gt.length; !gt[--ht]; ) ;
        for ($t = 0, It = ""; $t <= ht; It += nt.charAt(gt[$t++])) ;
        It = toFixedPoint(It, ft, nt.charAt(0));
      }
      return It;
    };
  }(), B = /* @__PURE__ */ function() {
    function St(wt, Oe, rt) {
      var pe, nt, st, ft, ht = 0, bt = wt.length, ut = Oe % SQRT_BASE, gt = Oe / SQRT_BASE | 0;
      for (wt = wt.slice(); bt--; )
        st = wt[bt] % SQRT_BASE, ft = wt[bt] / SQRT_BASE | 0, pe = gt * st + ft * ut, nt = ut * st + pe % SQRT_BASE * SQRT_BASE + ht, ht = (nt / rt | 0) + (pe / SQRT_BASE | 0) + gt * ft, wt[bt] = nt % rt;
      return ht && (wt = [ht].concat(wt)), wt;
    }
    function vt(wt, Oe, rt, pe) {
      var nt, st;
      if (rt != pe)
        st = rt > pe ? 1 : -1;
      else
        for (nt = st = 0; nt < rt; nt++)
          if (wt[nt] != Oe[nt]) {
            st = wt[nt] > Oe[nt] ? 1 : -1;
            break;
          }
      return st;
    }
    function It(wt, Oe, rt, pe) {
      for (var nt = 0; rt--; )
        wt[rt] -= nt, nt = wt[rt] < Oe[rt] ? 1 : 0, wt[rt] = nt * pe + wt[rt] - Oe[rt];
      for (; !wt[0] && wt.length > 1; wt.splice(0, 1)) ;
    }
    return function(wt, Oe, rt, pe, nt) {
      var st, ft, ht, bt, ut, gt, lt, $t, jt, Jt, Lt, Rt, Mt, Kt, zt, Ct, kt, Vt = wt.s == Oe.s ? 1 : -1, nr = wt.c, ar = Oe.c;
      if (!nr || !nr[0] || !ar || !ar[0])
        return new ot(
          // Return NaN if either NaN, or both Infinity or 0.
          !wt.s || !Oe.s || (nr ? ar && nr[0] == ar[0] : !ar) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            nr && nr[0] == 0 || !ar ? Vt * 0 : Vt / 0
          )
        );
      for ($t = new ot(Vt), jt = $t.c = [], ft = wt.e - Oe.e, Vt = rt + ft + 1, nt || (nt = BASE, ft = bitFloor(wt.e / LOG_BASE) - bitFloor(Oe.e / LOG_BASE), Vt = Vt / LOG_BASE | 0), ht = 0; ar[ht] == (nr[ht] || 0); ht++) ;
      if (ar[ht] > (nr[ht] || 0) && ft--, Vt < 0)
        jt.push(1), bt = !0;
      else {
        for (Kt = nr.length, Ct = ar.length, ht = 0, Vt += 2, ut = mathfloor(nt / (ar[0] + 1)), ut > 1 && (ar = St(ar, ut, nt), nr = St(nr, ut, nt), Ct = ar.length, Kt = nr.length), Mt = Ct, Jt = nr.slice(0, Ct), Lt = Jt.length; Lt < Ct; Jt[Lt++] = 0) ;
        kt = ar.slice(), kt = [0].concat(kt), zt = ar[0], ar[1] >= nt / 2 && zt++;
        do {
          if (ut = 0, st = vt(ar, Jt, Ct, Lt), st < 0) {
            if (Rt = Jt[0], Ct != Lt && (Rt = Rt * nt + (Jt[1] || 0)), ut = mathfloor(Rt / zt), ut > 1)
              for (ut >= nt && (ut = nt - 1), gt = St(ar, ut, nt), lt = gt.length, Lt = Jt.length; vt(gt, Jt, lt, Lt) == 1; )
                ut--, It(gt, Ct < lt ? kt : ar, lt, nt), lt = gt.length, st = 1;
            else
              ut == 0 && (st = ut = 1), gt = ar.slice(), lt = gt.length;
            if (lt < Lt && (gt = [0].concat(gt)), It(Jt, gt, Lt, nt), Lt = Jt.length, st == -1)
              for (; vt(ar, Jt, Ct, Lt) < 1; )
                ut++, It(Jt, Ct < Lt ? kt : ar, Lt, nt), Lt = Jt.length;
          } else st === 0 && (ut++, Jt = [0]);
          jt[ht++] = ut, Jt[0] ? Jt[Lt++] = nr[Mt] || 0 : (Jt = [nr[Mt]], Lt = 1);
        } while ((Mt++ < Kt || Jt[0] != null) && Vt--);
        bt = Jt[0] != null, jt[0] || jt.splice(0, 1);
      }
      if (nt == BASE) {
        for (ht = 1, Vt = jt[0]; Vt >= 10; Vt /= 10, ht++) ;
        Pt($t, rt + ($t.e = ht + ft * LOG_BASE - 1) + 1, pe, bt);
      } else
        $t.e = ft, $t.r = +bt;
      return $t;
    };
  }();
  function yt(St, vt, It, wt) {
    var Oe, rt, pe, nt, st;
    if (It == null ? It = ne : intCheck(It, 0, 8), !St.c) return St.toString();
    if (Oe = St.c[0], pe = St.e, vt == null)
      st = coeffToString(St.c), st = wt == 1 || wt == 2 && (pe <= ie || pe >= ce) ? toExponential(st, pe) : toFixedPoint(st, pe, "0");
    else if (St = Pt(new ot(St), vt, It), rt = St.e, st = coeffToString(St.c), nt = st.length, wt == 1 || wt == 2 && (vt <= rt || rt <= ie)) {
      for (; nt < vt; st += "0", nt++) ;
      st = toExponential(st, rt);
    } else if (vt -= pe, st = toFixedPoint(st, rt, "0"), rt + 1 > nt) {
      if (--vt > 0) for (st += "."; vt--; st += "0") ;
    } else if (vt += rt - nt, vt > 0)
      for (rt + 1 == nt && (st += "."); vt--; st += "0") ;
    return St.s < 0 && Oe ? "-" + st : st;
  }
  function mt(St, vt) {
    for (var It, wt, Oe = 1, rt = new ot(St[0]); Oe < St.length; Oe++)
      wt = new ot(St[Oe]), (!wt.s || (It = compare(rt, wt)) === vt || It === 0 && rt.s === vt) && (rt = wt);
    return rt;
  }
  function Tt(St, vt, It) {
    for (var wt = 1, Oe = vt.length; !vt[--Oe]; vt.pop()) ;
    for (Oe = vt[0]; Oe >= 10; Oe /= 10, wt++) ;
    return (It = wt + It * LOG_BASE - 1) > oe ? St.c = St.e = null : It < re ? St.c = [St.e = 0] : (St.e = It, St.c = vt), St;
  }
  K = /* @__PURE__ */ function() {
    var St = /^(-?)0([xbo])(?=\w[\w.]*$)/i, vt = /^([^.]+)\.$/, It = /^\.([^.]+)$/, wt = /^-?(Infinity|NaN)$/, Oe = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(rt, pe, nt, st) {
      var ft, ht = nt ? pe : pe.replace(Oe, "");
      if (wt.test(ht))
        rt.s = isNaN(ht) ? null : ht < 0 ? -1 : 1;
      else {
        if (!nt && (ht = ht.replace(St, function(bt, ut, gt) {
          return ft = (gt = gt.toLowerCase()) == "x" ? 16 : gt == "b" ? 2 : 8, !st || st == ft ? ut : bt;
        }), st && (ft = st, ht = ht.replace(vt, "$1").replace(It, "0.$1")), pe != ht))
          return new ot(ht, ft);
        if (ot.DEBUG)
          throw Error(bignumberError + "Not a" + (st ? " base " + st : "") + " number: " + pe);
        rt.s = null;
      }
      rt.c = rt.e = null;
    };
  }();
  function Pt(St, vt, It, wt) {
    var Oe, rt, pe, nt, st, ft, ht, bt = St.c, ut = POWS_TEN;
    if (bt) {
      e: {
        for (Oe = 1, nt = bt[0]; nt >= 10; nt /= 10, Oe++) ;
        if (rt = vt - Oe, rt < 0)
          rt += LOG_BASE, pe = vt, st = bt[ft = 0], ht = mathfloor(st / ut[Oe - pe - 1] % 10);
        else if (ft = mathceil((rt + 1) / LOG_BASE), ft >= bt.length)
          if (wt) {
            for (; bt.length <= ft; bt.push(0)) ;
            st = ht = 0, Oe = 1, rt %= LOG_BASE, pe = rt - LOG_BASE + 1;
          } else
            break e;
        else {
          for (st = nt = bt[ft], Oe = 1; nt >= 10; nt /= 10, Oe++) ;
          rt %= LOG_BASE, pe = rt - LOG_BASE + Oe, ht = pe < 0 ? 0 : mathfloor(st / ut[Oe - pe - 1] % 10);
        }
        if (wt = wt || vt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        bt[ft + 1] != null || (pe < 0 ? st : st % ut[Oe - pe - 1]), wt = It < 4 ? (ht || wt) && (It == 0 || It == (St.s < 0 ? 3 : 2)) : ht > 5 || ht == 5 && (It == 4 || wt || It == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (rt > 0 ? pe > 0 ? st / ut[Oe - pe] : 0 : bt[ft - 1]) % 10 & 1 || It == (St.s < 0 ? 8 : 7)), vt < 1 || !bt[0])
          return bt.length = 0, wt ? (vt -= St.e + 1, bt[0] = ut[(LOG_BASE - vt % LOG_BASE) % LOG_BASE], St.e = -vt || 0) : bt[0] = St.e = 0, St;
        if (rt == 0 ? (bt.length = ft, nt = 1, ft--) : (bt.length = ft + 1, nt = ut[LOG_BASE - rt], bt[ft] = pe > 0 ? mathfloor(st / ut[Oe - pe] % ut[pe]) * nt : 0), wt)
          for (; ; )
            if (ft == 0) {
              for (rt = 1, pe = bt[0]; pe >= 10; pe /= 10, rt++) ;
              for (pe = bt[0] += nt, nt = 1; pe >= 10; pe /= 10, nt++) ;
              rt != nt && (St.e++, bt[0] == BASE && (bt[0] = 1));
              break;
            } else {
              if (bt[ft] += nt, bt[ft] != BASE) break;
              bt[ft--] = 0, nt = 1;
            }
        for (rt = bt.length; bt[--rt] === 0; bt.pop()) ;
      }
      St.e > oe ? St.c = St.e = null : St.e < re && (St.c = [St.e = 0]);
    }
    return St;
  }
  function Nt(St) {
    var vt, It = St.e;
    return It === null ? St.toString() : (vt = coeffToString(St.c), vt = It <= ie || It >= ce ? toExponential(vt, It) : toFixedPoint(vt, It, "0"), St.s < 0 ? "-" + vt : vt);
  }
  return V.absoluteValue = V.abs = function() {
    var St = new ot(this);
    return St.s < 0 && (St.s = 1), St;
  }, V.comparedTo = function(St, vt) {
    return compare(this, new ot(St, vt));
  }, V.decimalPlaces = V.dp = function(St, vt) {
    var It, wt, Oe, rt = this;
    if (St != null)
      return intCheck(St, 0, MAX), vt == null ? vt = ne : intCheck(vt, 0, 8), Pt(new ot(rt), St + rt.e + 1, vt);
    if (!(It = rt.c)) return null;
    if (wt = ((Oe = It.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Oe = It[Oe]) for (; Oe % 10 == 0; Oe /= 10, wt--) ;
    return wt < 0 && (wt = 0), wt;
  }, V.dividedBy = V.div = function(St, vt) {
    return B(this, new ot(St, vt), J, ne);
  }, V.dividedToIntegerBy = V.idiv = function(St, vt) {
    return B(this, new ot(St, vt), 0, 1);
  }, V.exponentiatedBy = V.pow = function(St, vt) {
    var It, wt, Oe, rt, pe, nt, st, ft, ht, bt = this;
    if (St = new ot(St), St.c && !St.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Nt(St));
    if (vt != null && (vt = new ot(vt)), nt = St.e > 14, !bt.c || !bt.c[0] || bt.c[0] == 1 && !bt.e && bt.c.length == 1 || !St.c || !St.c[0])
      return ht = new ot(Math.pow(+Nt(bt), nt ? St.s * (2 - isOdd(St)) : +Nt(St))), vt ? ht.mod(vt) : ht;
    if (st = St.s < 0, vt) {
      if (vt.c ? !vt.c[0] : !vt.s) return new ot(NaN);
      wt = !st && bt.isInteger() && vt.isInteger(), wt && (bt = bt.mod(vt));
    } else {
      if (St.e > 9 && (bt.e > 0 || bt.e < -1 || (bt.e == 0 ? bt.c[0] > 1 || nt && bt.c[1] >= 24e7 : bt.c[0] < 8e13 || nt && bt.c[0] <= 9999975e7)))
        return rt = bt.s < 0 && isOdd(St) ? -0 : 0, bt.e > -1 && (rt = 1 / rt), new ot(st ? 1 / rt : rt);
      it && (rt = mathceil(it / LOG_BASE + 2));
    }
    for (nt ? (It = new ot(0.5), st && (St.s = 1), ft = isOdd(St)) : (Oe = Math.abs(+Nt(St)), ft = Oe % 2), ht = new ot(W); ; ) {
      if (ft) {
        if (ht = ht.times(bt), !ht.c) break;
        rt ? ht.c.length > rt && (ht.c.length = rt) : wt && (ht = ht.mod(vt));
      }
      if (Oe) {
        if (Oe = mathfloor(Oe / 2), Oe === 0) break;
        ft = Oe % 2;
      } else if (St = St.times(It), Pt(St, St.e + 1, 1), St.e > 14)
        ft = isOdd(St);
      else {
        if (Oe = +Nt(St), Oe === 0) break;
        ft = Oe % 2;
      }
      bt = bt.times(bt), rt ? bt.c && bt.c.length > rt && (bt.c.length = rt) : wt && (bt = bt.mod(vt));
    }
    return wt ? ht : (st && (ht = W.div(ht)), vt ? ht.mod(vt) : rt ? Pt(ht, it, ne, pe) : ht);
  }, V.integerValue = function(St) {
    var vt = new ot(this);
    return St == null ? St = ne : intCheck(St, 0, 8), Pt(vt, vt.e + 1, St);
  }, V.isEqualTo = V.eq = function(St, vt) {
    return compare(this, new ot(St, vt)) === 0;
  }, V.isFinite = function() {
    return !!this.c;
  }, V.isGreaterThan = V.gt = function(St, vt) {
    return compare(this, new ot(St, vt)) > 0;
  }, V.isGreaterThanOrEqualTo = V.gte = function(St, vt) {
    return (vt = compare(this, new ot(St, vt))) === 1 || vt === 0;
  }, V.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, V.isLessThan = V.lt = function(St, vt) {
    return compare(this, new ot(St, vt)) < 0;
  }, V.isLessThanOrEqualTo = V.lte = function(St, vt) {
    return (vt = compare(this, new ot(St, vt))) === -1 || vt === 0;
  }, V.isNaN = function() {
    return !this.s;
  }, V.isNegative = function() {
    return this.s < 0;
  }, V.isPositive = function() {
    return this.s > 0;
  }, V.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, V.minus = function(St, vt) {
    var It, wt, Oe, rt, pe = this, nt = pe.s;
    if (St = new ot(St, vt), vt = St.s, !nt || !vt) return new ot(NaN);
    if (nt != vt)
      return St.s = -vt, pe.plus(St);
    var st = pe.e / LOG_BASE, ft = St.e / LOG_BASE, ht = pe.c, bt = St.c;
    if (!st || !ft) {
      if (!ht || !bt) return ht ? (St.s = -vt, St) : new ot(bt ? pe : NaN);
      if (!ht[0] || !bt[0])
        return bt[0] ? (St.s = -vt, St) : new ot(ht[0] ? pe : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ne == 3 ? -0 : 0
        ));
    }
    if (st = bitFloor(st), ft = bitFloor(ft), ht = ht.slice(), nt = st - ft) {
      for ((rt = nt < 0) ? (nt = -nt, Oe = ht) : (ft = st, Oe = bt), Oe.reverse(), vt = nt; vt--; Oe.push(0)) ;
      Oe.reverse();
    } else
      for (wt = (rt = (nt = ht.length) < (vt = bt.length)) ? nt : vt, nt = vt = 0; vt < wt; vt++)
        if (ht[vt] != bt[vt]) {
          rt = ht[vt] < bt[vt];
          break;
        }
    if (rt && (Oe = ht, ht = bt, bt = Oe, St.s = -St.s), vt = (wt = bt.length) - (It = ht.length), vt > 0) for (; vt--; ht[It++] = 0) ;
    for (vt = BASE - 1; wt > nt; ) {
      if (ht[--wt] < bt[wt]) {
        for (It = wt; It && !ht[--It]; ht[It] = vt) ;
        --ht[It], ht[wt] += BASE;
      }
      ht[wt] -= bt[wt];
    }
    for (; ht[0] == 0; ht.splice(0, 1), --ft) ;
    return ht[0] ? Tt(St, ht, ft) : (St.s = ne == 3 ? -1 : 1, St.c = [St.e = 0], St);
  }, V.modulo = V.mod = function(St, vt) {
    var It, wt, Oe = this;
    return St = new ot(St, vt), !Oe.c || !St.s || St.c && !St.c[0] ? new ot(NaN) : !St.c || Oe.c && !Oe.c[0] ? new ot(Oe) : (Ce == 9 ? (wt = St.s, St.s = 1, It = B(Oe, St, 0, 3), St.s = wt, It.s *= wt) : It = B(Oe, St, 0, Ce), St = Oe.minus(It.times(St)), !St.c[0] && Ce == 1 && (St.s = Oe.s), St);
  }, V.multipliedBy = V.times = function(St, vt) {
    var It, wt, Oe, rt, pe, nt, st, ft, ht, bt, ut, gt, lt, $t, jt, Jt = this, Lt = Jt.c, Rt = (St = new ot(St, vt)).c;
    if (!Lt || !Rt || !Lt[0] || !Rt[0])
      return !Jt.s || !St.s || Lt && !Lt[0] && !Rt || Rt && !Rt[0] && !Lt ? St.c = St.e = St.s = null : (St.s *= Jt.s, !Lt || !Rt ? St.c = St.e = null : (St.c = [0], St.e = 0)), St;
    for (wt = bitFloor(Jt.e / LOG_BASE) + bitFloor(St.e / LOG_BASE), St.s *= Jt.s, st = Lt.length, bt = Rt.length, st < bt && (lt = Lt, Lt = Rt, Rt = lt, Oe = st, st = bt, bt = Oe), Oe = st + bt, lt = []; Oe--; lt.push(0)) ;
    for ($t = BASE, jt = SQRT_BASE, Oe = bt; --Oe >= 0; ) {
      for (It = 0, ut = Rt[Oe] % jt, gt = Rt[Oe] / jt | 0, pe = st, rt = Oe + pe; rt > Oe; )
        ft = Lt[--pe] % jt, ht = Lt[pe] / jt | 0, nt = gt * ft + ht * ut, ft = ut * ft + nt % jt * jt + lt[rt] + It, It = (ft / $t | 0) + (nt / jt | 0) + gt * ht, lt[rt--] = ft % $t;
      lt[rt] = It;
    }
    return It ? ++wt : lt.splice(0, 1), Tt(St, lt, wt);
  }, V.negated = function() {
    var St = new ot(this);
    return St.s = -St.s || null, St;
  }, V.plus = function(St, vt) {
    var It, wt = this, Oe = wt.s;
    if (St = new ot(St, vt), vt = St.s, !Oe || !vt) return new ot(NaN);
    if (Oe != vt)
      return St.s = -vt, wt.minus(St);
    var rt = wt.e / LOG_BASE, pe = St.e / LOG_BASE, nt = wt.c, st = St.c;
    if (!rt || !pe) {
      if (!nt || !st) return new ot(Oe / 0);
      if (!nt[0] || !st[0]) return st[0] ? St : new ot(nt[0] ? wt : Oe * 0);
    }
    if (rt = bitFloor(rt), pe = bitFloor(pe), nt = nt.slice(), Oe = rt - pe) {
      for (Oe > 0 ? (pe = rt, It = st) : (Oe = -Oe, It = nt), It.reverse(); Oe--; It.push(0)) ;
      It.reverse();
    }
    for (Oe = nt.length, vt = st.length, Oe - vt < 0 && (It = st, st = nt, nt = It, vt = Oe), Oe = 0; vt; )
      Oe = (nt[--vt] = nt[vt] + st[vt] + Oe) / BASE | 0, nt[vt] = BASE === nt[vt] ? 0 : nt[vt] % BASE;
    return Oe && (nt = [Oe].concat(nt), ++pe), Tt(St, nt, pe);
  }, V.precision = V.sd = function(St, vt) {
    var It, wt, Oe, rt = this;
    if (St != null && St !== !!St)
      return intCheck(St, 1, MAX), vt == null ? vt = ne : intCheck(vt, 0, 8), Pt(new ot(rt), St, vt);
    if (!(It = rt.c)) return null;
    if (Oe = It.length - 1, wt = Oe * LOG_BASE + 1, Oe = It[Oe]) {
      for (; Oe % 10 == 0; Oe /= 10, wt--) ;
      for (Oe = It[0]; Oe >= 10; Oe /= 10, wt++) ;
    }
    return St && rt.e + 1 > wt && (wt = rt.e + 1), wt;
  }, V.shiftedBy = function(St) {
    return intCheck(St, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + St);
  }, V.squareRoot = V.sqrt = function() {
    var St, vt, It, wt, Oe, rt = this, pe = rt.c, nt = rt.s, st = rt.e, ft = J + 4, ht = new ot("0.5");
    if (nt !== 1 || !pe || !pe[0])
      return new ot(!nt || nt < 0 && (!pe || pe[0]) ? NaN : pe ? rt : 1 / 0);
    if (nt = Math.sqrt(+Nt(rt)), nt == 0 || nt == 1 / 0 ? (vt = coeffToString(pe), (vt.length + st) % 2 == 0 && (vt += "0"), nt = Math.sqrt(+vt), st = bitFloor((st + 1) / 2) - (st < 0 || st % 2), nt == 1 / 0 ? vt = "5e" + st : (vt = nt.toExponential(), vt = vt.slice(0, vt.indexOf("e") + 1) + st), It = new ot(vt)) : It = new ot(nt + ""), It.c[0]) {
      for (st = It.e, nt = st + ft, nt < 3 && (nt = 0); ; )
        if (Oe = It, It = ht.times(Oe.plus(B(rt, Oe, ft, 1))), coeffToString(Oe.c).slice(0, nt) === (vt = coeffToString(It.c)).slice(0, nt))
          if (It.e < st && --nt, vt = vt.slice(nt - 3, nt + 1), vt == "9999" || !wt && vt == "4999") {
            if (!wt && (Pt(Oe, Oe.e + J + 2, 0), Oe.times(Oe).eq(rt))) {
              It = Oe;
              break;
            }
            ft += 4, nt += 4, wt = 1;
          } else {
            (!+vt || !+vt.slice(1) && vt.charAt(0) == "5") && (Pt(It, It.e + J + 2, 1), St = !It.times(It).eq(rt));
            break;
          }
    }
    return Pt(It, It.e + J + 1, ne, St);
  }, V.toExponential = function(St, vt) {
    return St != null && (intCheck(St, 0, MAX), St++), yt(this, St, vt, 1);
  }, V.toFixed = function(St, vt) {
    return St != null && (intCheck(St, 0, MAX), St = St + this.e + 1), yt(this, St, vt);
  }, V.toFormat = function(St, vt, It) {
    var wt, Oe = this;
    if (It == null)
      St != null && vt && typeof vt == "object" ? (It = vt, vt = null) : St && typeof St == "object" ? (It = St, St = vt = null) : It = at;
    else if (typeof It != "object")
      throw Error(bignumberError + "Argument not an object: " + It);
    if (wt = Oe.toFixed(St, vt), Oe.c) {
      var rt, pe = wt.split("."), nt = +It.groupSize, st = +It.secondaryGroupSize, ft = It.groupSeparator || "", ht = pe[0], bt = pe[1], ut = Oe.s < 0, gt = ut ? ht.slice(1) : ht, lt = gt.length;
      if (st && (rt = nt, nt = st, st = rt, lt -= rt), nt > 0 && lt > 0) {
        for (rt = lt % nt || nt, ht = gt.substr(0, rt); rt < lt; rt += nt) ht += ft + gt.substr(rt, nt);
        st > 0 && (ht += ft + gt.slice(rt)), ut && (ht = "-" + ht);
      }
      wt = bt ? ht + (It.decimalSeparator || "") + ((st = +It.fractionGroupSize) ? bt.replace(
        new RegExp("\\d{" + st + "}\\B", "g"),
        "$&" + (It.fractionGroupSeparator || "")
      ) : bt) : ht;
    }
    return (It.prefix || "") + wt + (It.suffix || "");
  }, V.toFraction = function(St) {
    var vt, It, wt, Oe, rt, pe, nt, st, ft, ht, bt, ut, gt = this, lt = gt.c;
    if (St != null && (nt = new ot(St), !nt.isInteger() && (nt.c || nt.s !== 1) || nt.lt(W)))
      throw Error(bignumberError + "Argument " + (nt.isInteger() ? "out of range: " : "not an integer: ") + Nt(nt));
    if (!lt) return new ot(gt);
    for (vt = new ot(W), ft = It = new ot(W), wt = st = new ot(W), ut = coeffToString(lt), rt = vt.e = ut.length - gt.e - 1, vt.c[0] = POWS_TEN[(pe = rt % LOG_BASE) < 0 ? LOG_BASE + pe : pe], St = !St || nt.comparedTo(vt) > 0 ? rt > 0 ? vt : ft : nt, pe = oe, oe = 1 / 0, nt = new ot(ut), st.c[0] = 0; ht = B(nt, vt, 0, 1), Oe = It.plus(ht.times(wt)), Oe.comparedTo(St) != 1; )
      It = wt, wt = Oe, ft = st.plus(ht.times(Oe = ft)), st = Oe, vt = nt.minus(ht.times(Oe = vt)), nt = Oe;
    return Oe = B(St.minus(It), wt, 0, 1), st = st.plus(Oe.times(ft)), It = It.plus(Oe.times(wt)), st.s = ft.s = gt.s, rt = rt * 2, bt = B(ft, wt, rt, ne).minus(gt).abs().comparedTo(
      B(st, It, rt, ne).minus(gt).abs()
    ) < 1 ? [ft, wt] : [st, It], oe = pe, bt;
  }, V.toNumber = function() {
    return +Nt(this);
  }, V.toPrecision = function(St, vt) {
    return St != null && intCheck(St, 1, MAX), yt(this, St, vt, 2);
  }, V.toString = function(St) {
    var vt, It = this, wt = It.s, Oe = It.e;
    return Oe === null ? wt ? (vt = "Infinity", wt < 0 && (vt = "-" + vt)) : vt = "NaN" : (St == null ? vt = Oe <= ie || Oe >= ce ? toExponential(coeffToString(It.c), Oe) : toFixedPoint(coeffToString(It.c), Oe, "0") : St === 10 && dt ? (It = Pt(new ot(It), J + Oe + 1, ne), vt = toFixedPoint(coeffToString(It.c), It.e, "0")) : (intCheck(St, 2, ct.length, "Base"), vt = L(toFixedPoint(coeffToString(It.c), Oe, "0"), 10, St, wt, !0)), wt < 0 && It.c[0] && (vt = "-" + vt)), vt;
  }, V.valueOf = V.toJSON = function() {
    return Nt(this);
  }, V._isBigNumber = !0, V[Symbol.toStringTag] = "BigNumber", V[Symbol.for("nodejs.util.inspect.custom")] = V.valueOf, A != null && ot.set(A), ot;
}
function bitFloor(A) {
  var B = A | 0;
  return A > 0 || A === B ? B : B - 1;
}
function coeffToString(A) {
  for (var B, L, K = 1, V = A.length, W = A[0] + ""; K < V; ) {
    for (B = A[K++] + "", L = LOG_BASE - B.length; L--; B = "0" + B) ;
    W += B;
  }
  for (V = W.length; W.charCodeAt(--V) === 48; ) ;
  return W.slice(0, V + 1 || 1);
}
function compare(A, B) {
  var L, K, V = A.c, W = B.c, J = A.s, ne = B.s, ie = A.e, ce = B.e;
  if (!J || !ne) return null;
  if (L = V && !V[0], K = W && !W[0], L || K) return L ? K ? 0 : -ne : J;
  if (J != ne) return J;
  if (L = J < 0, K = ie == ce, !V || !W) return K ? 0 : !V ^ L ? 1 : -1;
  if (!K) return ie > ce ^ L ? 1 : -1;
  for (ne = (ie = V.length) < (ce = W.length) ? ie : ce, J = 0; J < ne; J++) if (V[J] != W[J]) return V[J] > W[J] ^ L ? 1 : -1;
  return ie == ce ? 0 : ie > ce ^ L ? 1 : -1;
}
function intCheck(A, B, L, K) {
  if (A < B || A > L || A !== mathfloor(A))
    throw Error(bignumberError + (K || "Argument") + (typeof A == "number" ? A < B || A > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(A));
}
function isOdd(A) {
  var B = A.c.length - 1;
  return bitFloor(A.e / LOG_BASE) == B && A.c[B] % 2 != 0;
}
function toExponential(A, B) {
  return (A.length > 1 ? A.charAt(0) + "." + A.slice(1) : A) + (B < 0 ? "e" : "e+") + B;
}
function toFixedPoint(A, B, L) {
  var K, V;
  if (B < 0) {
    for (V = L + "."; ++B; V += L) ;
    A = V + A;
  } else if (K = A.length, ++B > K) {
    for (V = L, B -= K; --B; V += L) ;
    A += V;
  } else B < K && (A = A.slice(0, B) + "." + A.slice(B));
  return A;
}
var BigNumber = clone();
function useBalance() {
  const { network: A, publicKey: B, format: L } = useOrdConnect(), [K, V] = useState(null), [W, J] = useState(!1);
  return { getBalance: useCallback(async () => {
    J(!0);
    try {
      if (V(null), !L || !L.payments || !B || !B.payments)
        throw new Error("No wallet is connected");
      const { address: ie } = getAddressesFromPublicKey(
        B.payments,
        A,
        ADDRESS_FORMAT_TO_TYPE[L.payments]
      )[0], re = await new JsonRpcDatasource({ network: A }).getBalance({ address: ie }), oe = Number(
        new BigNumber(re).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return J(!1), oe;
    } catch (ie) {
      throw V(ie.message), J(!1), ie;
    }
  }, [L, A, B]), error: K, loading: W };
}
async function signPsbt({
  address: A,
  wallet: B,
  network: L,
  psbt: K,
  options: V
}) {
  var ie, ce;
  if ((ie = V == null ? void 0 : V.signingIndexes) != null && ie.length && ((ce = V == null ? void 0 : V.inputsToSign) != null && ce.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const W = (V == null ? void 0 : V.finalize) ?? !0, J = (V == null ? void 0 : V.extractTx) ?? !0, ne = () => K.data.inputs.map((re, oe) => oe);
  if (B === Wallet.MAGICEDEN)
    return await signPsbt$1(K, {
      network: L,
      inputsToSign: (V == null ? void 0 : V.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne(),
          sigHash: V == null ? void 0 : V.sigHash
        }
      ],
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.UNISAT)
    return await signPsbt$2(K, {
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.XVERSE)
    return await signPsbt$3(K, {
      network: L,
      inputsToSign: (V == null ? void 0 : V.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: V == null ? void 0 : V.sigHash
        }
      ],
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.LEATHER)
    return await signPsbt$4(K, {
      network: L,
      finalize: W,
      extractTx: J,
      allowedSighash: V != null && V.sigHash ? [V == null ? void 0 : V.sigHash] : [],
      signAtIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne()
      // If signingIndexes is not provided, just sign everything
    });
  if (B === Wallet.OKX)
    return await signPsbt$5(K, {
      finalize: W,
      extractTx: J,
      network: L,
      inputsToSign: (V == null ? void 0 : V.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: V == null ? void 0 : V.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: A, network: B, address: L, publicKey: K } = useOrdConnect(), [V, W] = useState(null), [J, ne] = useState(!1);
  return { send: useCallback(
    async (ce, re, oe, ke = !0) => {
      ne(!0);
      try {
        if (W(null), !L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const Ce = new PSBTBuilder({
          address: L.payments,
          feeRate: oe,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ce,
              value: re
            }
          ]
        });
        await Ce.prepare();
        const it = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: Ce.toPSBT()
        });
        if (ke) {
          const ct = await new JsonRpcDatasource({ network: B }).relay({ hex: it.hex });
          return ne(!1), ct;
        }
        return ne(!1), it.hex;
      } catch (Ce) {
        return W(Ce.message), ne(!1), null;
      }
    },
    [L, B, K, A]
  ), error: V, loading: J };
}
function useSendV2() {
  const { wallet: A, network: B, address: L, publicKey: K } = useOrdConnect(), [V, W] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ne,
      satoshis: ie,
      feeRate: ce,
      relay: re = !0,
      rbf: oe = !1
    }) => {
      W(!0);
      try {
        if (!L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const ke = new PSBTBuilder({
          address: L.payments,
          feeRate: ce,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ne,
              value: ie
            }
          ]
        });
        ke.setRBF(oe), await ke.prepare();
        const Ce = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: ke.toPSBT()
        });
        if (re) {
          const at = await new JsonRpcDatasource({ network: B }).relay({ hex: Ce.hex });
          return W(!1), {
            txId: at
          };
        }
        return W(!1), {
          signedPsbtHex: Ce.hex
        };
      } catch (ke) {
        return W(!1), {
          error: ke.message
        };
      }
    },
    [L, B, K, A]
  ), isLoading: V };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(A) {
  if (A.length < 8 || A.length > 72 || A[0] !== 48 || A[1] !== A.length - 2 || A[2] !== 2) return !1;
  const B = A[3];
  if (B === 0 || 5 + B >= A.length || A[4 + B] !== 2) return !1;
  const L = A[5 + B];
  return !(L === 0 || 6 + B + L !== A.length || A[4] & 128 || B > 1 && A[4] === 0 && !(A[5] & 128) || A[B + 6] & 128 || L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128));
}
bip66.check = check$d;
function decode$h(A) {
  if (A.length < 8) throw new Error("DER sequence length is too short");
  if (A.length > 72) throw new Error("DER sequence length is too long");
  if (A[0] !== 48) throw new Error("Expected DER sequence");
  if (A[1] !== A.length - 2)
    throw new Error("DER sequence length is invalid");
  if (A[2] !== 2) throw new Error("Expected DER integer");
  const B = A[3];
  if (B === 0) throw new Error("R length is zero");
  if (5 + B >= A.length) throw new Error("R length is too long");
  if (A[4 + B] !== 2) throw new Error("Expected DER integer (2)");
  const L = A[5 + B];
  if (L === 0) throw new Error("S length is zero");
  if (6 + B + L !== A.length) throw new Error("S length is invalid");
  if (A[4] & 128) throw new Error("R value is negative");
  if (B > 1 && A[4] === 0 && !(A[5] & 128))
    throw new Error("R value excessively padded");
  if (A[B + 6] & 128) throw new Error("S value is negative");
  if (L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: A.slice(4, 4 + B),
    s: A.slice(6 + B)
  };
}
bip66.decode = decode$h;
function encode$i(A, B) {
  const L = A.length, K = B.length;
  if (L === 0) throw new Error("R length is zero");
  if (K === 0) throw new Error("S length is zero");
  if (L > 33) throw new Error("R length is too long");
  if (K > 33) throw new Error("S length is too long");
  if (A[0] & 128) throw new Error("R value is negative");
  if (B[0] & 128) throw new Error("S value is negative");
  if (L > 1 && A[0] === 0 && !(A[1] & 128))
    throw new Error("R value excessively padded");
  if (K > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("S value excessively padded");
  const V = Buffer$1.allocUnsafe(6 + L + K);
  return V[0] = 48, V[1] = V.length - 2, V[2] = 2, V[3] = A.length, A.copy(V, 4), V[4 + L] = 2, V[5 + L] = B.length, B.copy(V, 6 + L), V;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const A of Object.keys(OPS$7)) {
  const B = OPS$7[A];
  REVERSE_OPS[B] = A;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(A) {
  return A < ops_1.OPS.OP_PUSHDATA1 ? 1 : A <= 255 ? 2 : A <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(A, B, L) {
  const K = encodingLength$2(B);
  return K === 1 ? A.writeUInt8(B, L) : K === 2 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA1, L), A.writeUInt8(B, L + 1)) : K === 3 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA2, L), A.writeUInt16LE(B, L + 1)) : (A.writeUInt8(ops_1.OPS.OP_PUSHDATA4, L), A.writeUInt32LE(B, L + 1)), K;
}
push_data.encode = encode$h;
function decode$g(A, B) {
  const L = A.readUInt8(B);
  let K, V;
  if (L < ops_1.OPS.OP_PUSHDATA1)
    K = L, V = 1;
  else if (L === ops_1.OPS.OP_PUSHDATA1) {
    if (B + 2 > A.length) return null;
    K = A.readUInt8(B + 1), V = 2;
  } else if (L === ops_1.OPS.OP_PUSHDATA2) {
    if (B + 3 > A.length) return null;
    K = A.readUInt16LE(B + 1), V = 3;
  } else {
    if (B + 5 > A.length) return null;
    if (L !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    K = A.readUInt32LE(B + 1), V = 5;
  }
  return {
    opcode: L,
    number: K,
    size: V
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(A, B, L) {
  B = B || 4, L = L === void 0 ? !0 : L;
  const K = A.length;
  if (K === 0) return 0;
  if (K > B) throw new TypeError("Script number overflow");
  if (L && !(A[K - 1] & 127) && (K <= 1 || !(A[K - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (K === 5) {
    const W = A.readUInt32LE(0), J = A.readUInt8(4);
    return J & 128 ? -((J & -129) * 4294967296 + W) : J * 4294967296 + W;
  }
  let V = 0;
  for (let W = 0; W < K; ++W)
    V |= A[W] << 8 * W;
  return A[K - 1] & 128 ? -(V & ~(128 << 8 * (K - 1))) : V;
}
script_number.decode = decode$f;
function scriptNumSize(A) {
  return A > 2147483647 ? 5 : A > 8388607 ? 4 : A > 32767 ? 3 : A > 127 ? 2 : A > 0 ? 1 : 0;
}
function encode$g(A) {
  let B = Math.abs(A);
  const L = scriptNumSize(B), K = Buffer$1.allocUnsafe(L), V = A < 0;
  for (let W = 0; W < L; ++W)
    K.writeUInt8(B & 255, W), B >>= 8;
  return K[L - 1] & 128 ? K.writeUInt8(V ? 128 : 0, L - 1) : V && (K[L - 1] |= 128), K;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(A) {
    return A != null && A.constructor === Array;
  },
  Boolean: function(A) {
    return typeof A == "boolean";
  },
  Function: function(A) {
    return typeof A == "function";
  },
  Nil: function(A) {
    return A == null;
  },
  Number: function(A) {
    return typeof A == "number";
  },
  Object: function(A) {
    return typeof A == "object";
  },
  String: function(A) {
    return typeof A == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(A) {
    return A;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(A) {
  return A.name || A.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(A) {
  return native.Nil(A) ? "" : getTypeName(A.constructor);
}
function getValue(A) {
  return native.Function(A) ? "" : native.String(A) ? JSON.stringify(A) : A && native.Object(A) ? "" : A;
}
function captureStackTrace(A, B) {
  Error.captureStackTrace && Error.captureStackTrace(A, B);
}
function tfJSON$1(A) {
  return native.Function(A) ? A.toJSON ? A.toJSON() : getTypeName(A) : native.Array(A) ? "Array" : A && native.Object(A) ? "Object" : A !== void 0 ? A : "";
}
function tfErrorString(A, B, L) {
  var K = getValue(B);
  return "Expected " + tfJSON$1(A) + ", got" + (L !== "" ? " " + L : "") + (K !== "" ? " " + K : "");
}
function TfTypeError$1(A, B, L) {
  L = L || getValueTypeName$1(B), this.message = tfErrorString(A, B, L), captureStackTrace(this, TfTypeError$1), this.__type = A, this.__value = B, this.__valueTypeName = L;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(A, B, L, K, V) {
  var W = '" of type ';
  return B === "key" && (W = '" with key type '), tfErrorString('property "' + tfJSON$1(L) + W + tfJSON$1(A), K, V);
}
function TfPropertyTypeError$1(A, B, L, K, V) {
  A ? (V = V || getValueTypeName$1(K), this.message = tfPropertyErrorString(A, L, B, K, V)) : this.message = 'Unexpected property "' + B + '"', captureStackTrace(this, TfTypeError$1), this.__label = L, this.__property = B, this.__type = A, this.__value = K, this.__valueTypeName = V;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(A, B) {
  return new TfTypeError$1(A, {}, B);
}
function tfSubError$1(A, B, L) {
  return A instanceof TfPropertyTypeError$1 ? (B = B + "." + A.__property, A = new TfPropertyTypeError$1(
    A.__type,
    B,
    A.__label,
    A.__value,
    A.__valueTypeName
  )) : A instanceof TfTypeError$1 && (A = new TfPropertyTypeError$1(
    A.__type,
    B,
    L,
    A.__value,
    A.__valueTypeName
  )), captureStackTrace(A), A;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var A = native$1, B = errors;
  function L(Pt) {
    return Buffer$1.isBuffer(Pt);
  }
  function K(Pt) {
    return typeof Pt == "string" && /^([0-9a-f]{2})+$/i.test(Pt);
  }
  function V(Pt, Nt) {
    var St = Pt.toJSON();
    function vt(It) {
      if (!Pt(It)) return !1;
      if (It.length === Nt) return !0;
      throw B.tfCustomError(St + "(Length: " + Nt + ")", St + "(Length: " + It.length + ")");
    }
    return vt.toJSON = function() {
      return St;
    }, vt;
  }
  var W = V.bind(null, A.Array), J = V.bind(null, L), ne = V.bind(null, K), ie = V.bind(null, A.String);
  function ce(Pt, Nt, St) {
    St = St || A.Number;
    function vt(It, wt) {
      return St(It, wt) && It > Pt && It < Nt;
    }
    return vt.toJSON = function() {
      return `${St.toJSON()} between [${Pt}, ${Nt}]`;
    }, vt;
  }
  var re = Math.pow(2, 53) - 1;
  function oe(Pt) {
    return typeof Pt == "number" && isFinite(Pt);
  }
  function ke(Pt) {
    return Pt << 24 >> 24 === Pt;
  }
  function Ce(Pt) {
    return Pt << 16 >> 16 === Pt;
  }
  function it(Pt) {
    return (Pt | 0) === Pt;
  }
  function at(Pt) {
    return typeof Pt == "number" && Pt >= -re && Pt <= re && Math.floor(Pt) === Pt;
  }
  function ct(Pt) {
    return (Pt & 255) === Pt;
  }
  function dt(Pt) {
    return (Pt & 65535) === Pt;
  }
  function ot(Pt) {
    return Pt >>> 0 === Pt;
  }
  function yt(Pt) {
    return typeof Pt == "number" && Pt >= 0 && Pt <= re && Math.floor(Pt) === Pt;
  }
  var mt = {
    ArrayN: W,
    Buffer: L,
    BufferN: J,
    Finite: oe,
    Hex: K,
    HexN: ne,
    Int8: ke,
    Int16: Ce,
    Int32: it,
    Int53: at,
    Range: ce,
    StringN: ie,
    UInt8: ct,
    UInt16: dt,
    UInt32: ot,
    UInt53: yt
  };
  for (var Tt in mt)
    mt[Tt].toJSON = (function(Pt) {
      return Pt;
    }).bind(null, Tt);
  return extra = mt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function A(B, L) {
    B = compile(B), L = L || {};
    function K(V, W) {
      return !NATIVE.Array(V) || NATIVE.Nil(V) || L.minLength !== void 0 && V.length < L.minLength || L.maxLength !== void 0 && V.length > L.maxLength || L.length !== void 0 && V.length !== L.length ? !1 : V.every(function(J, ne) {
        try {
          return typeforce$3(B, J, W);
        } catch (ie) {
          throw tfSubError(ie, ne);
        }
      });
    }
    return K.toJSON = function() {
      var V = "[" + tfJSON(B) + "]";
      return L.length !== void 0 ? V += "{" + L.length + "}" : (L.minLength !== void 0 || L.maxLength !== void 0) && (V += "{" + (L.minLength === void 0 ? 0 : L.minLength) + "," + (L.maxLength === void 0 ? 1 / 0 : L.maxLength) + "}"), V;
    }, K;
  },
  maybe: function A(B) {
    B = compile(B);
    function L(K, V) {
      return NATIVE.Nil(K) || B(K, V, A);
    }
    return L.toJSON = function() {
      return "?" + tfJSON(B);
    }, L;
  },
  map: function A(B, L) {
    B = compile(B), L && (L = compile(L));
    function K(V, W) {
      if (!NATIVE.Object(V) || NATIVE.Nil(V)) return !1;
      for (var J in V) {
        try {
          L && typeforce$3(L, J, W);
        } catch (ie) {
          throw tfSubError(ie, J, "key");
        }
        try {
          var ne = V[J];
          typeforce$3(B, ne, W);
        } catch (ie) {
          throw tfSubError(ie, J);
        }
      }
      return !0;
    }
    return L ? K.toJSON = function() {
      return "{" + tfJSON(L) + ": " + tfJSON(B) + "}";
    } : K.toJSON = function() {
      return "{" + tfJSON(B) + "}";
    }, K;
  },
  object: function A(B) {
    var L = {};
    for (var K in B)
      L[K] = compile(B[K]);
    function V(W, J) {
      if (!NATIVE.Object(W) || NATIVE.Nil(W)) return !1;
      var ne;
      try {
        for (ne in L) {
          var ie = L[ne], ce = W[ne];
          typeforce$3(ie, ce, J);
        }
      } catch (re) {
        throw tfSubError(re, ne);
      }
      if (J) {
        for (ne in W)
          if (!L[ne])
            throw new TfPropertyTypeError(void 0, ne);
      }
      return !0;
    }
    return V.toJSON = function() {
      return tfJSON(L);
    }, V;
  },
  anyOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, V) {
      return B.some(function(W) {
        try {
          return typeforce$3(W, K, V);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join("|");
    }, L;
  },
  allOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, V) {
      return B.every(function(W) {
        try {
          return typeforce$3(W, K, V);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join(" & ");
    }, L;
  },
  quacksLike: function A(B) {
    function L(K) {
      return B === getValueTypeName(K);
    }
    return L.toJSON = function() {
      return B;
    }, L;
  },
  tuple: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, V) {
      return NATIVE.Nil(K) || NATIVE.Nil(K.length) || V && K.length !== B.length ? !1 : B.every(function(W, J) {
        try {
          return typeforce$3(W, K[J], V);
        } catch (ne) {
          throw tfSubError(ne, J);
        }
      });
    }
    return L.toJSON = function() {
      return "(" + B.map(tfJSON).join(", ") + ")";
    }, L;
  },
  value: function A(B) {
    function L(K) {
      return K === B;
    }
    return L.toJSON = function() {
      return B;
    }, L;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(A) {
  if (NATIVE.String(A))
    return A[0] === "?" ? TYPES.maybe(A.slice(1)) : NATIVE[A] || TYPES.quacksLike(A);
  if (A && NATIVE.Object(A)) {
    if (NATIVE.Array(A)) {
      if (A.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(A[0]);
    }
    return TYPES.object(A);
  } else if (NATIVE.Function(A))
    return A;
  return TYPES.value(A);
}
function typeforce$3(A, B, L, K) {
  if (NATIVE.Function(A)) {
    if (A(B, L)) return !0;
    throw new TfTypeError(K || A, B);
  }
  return typeforce$3(compile(A), B, L);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.oneOf = A.Null = A.BufferN = A.Function = A.UInt32 = A.UInt8 = A.tuple = A.maybe = A.Hex = A.Buffer = A.String = A.Boolean = A.Array = A.Number = A.Hash256bit = A.Hash160bit = A.Buffer256bit = A.isTaptree = A.isTapleaf = A.TAPLEAF_VERSION_MASK = A.Satoshi = A.isPoint = A.stacksEqual = A.typeforce = void 0;
  const B = dist$1;
  A.typeforce = typeforce_1;
  const L = B.Buffer.alloc(32, 0), K = B.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function V(re, oe) {
    return re.length !== oe.length ? !1 : re.every((ke, Ce) => ke.equals(oe[Ce]));
  }
  A.stacksEqual = V;
  function W(re) {
    if (!B.Buffer.isBuffer(re) || re.length < 33) return !1;
    const oe = re[0], ke = re.slice(1, 33);
    if (ke.compare(L) === 0 || ke.compare(K) >= 0) return !1;
    if ((oe === 2 || oe === 3) && re.length === 33)
      return !0;
    const Ce = re.slice(33);
    return Ce.compare(L) === 0 || Ce.compare(K) >= 0 ? !1 : oe === 4 && re.length === 65;
  }
  A.isPoint = W;
  const J = 21 * 1e14;
  function ne(re) {
    return A.typeforce.UInt53(re) && re <= J;
  }
  A.Satoshi = ne, A.TAPLEAF_VERSION_MASK = 254;
  function ie(re) {
    return !re || !("output" in re) || !B.Buffer.isBuffer(re.output) ? !1 : re.version !== void 0 ? (re.version & A.TAPLEAF_VERSION_MASK) === re.version : !0;
  }
  A.isTapleaf = ie;
  function ce(re) {
    return (0, A.Array)(re) ? re.length !== 2 ? !1 : re.every((oe) => ce(oe)) : ie(re);
  }
  A.isTaptree = ce, A.Buffer256bit = A.typeforce.BufferN(32), A.Hash160bit = A.typeforce.BufferN(20), A.Hash256bit = A.typeforce.BufferN(32), A.Number = A.typeforce.Number, A.Array = A.typeforce.Array, A.Boolean = A.typeforce.Boolean, A.String = A.typeforce.String, A.Buffer = A.typeforce.Buffer, A.Hex = A.typeforce.Hex, A.maybe = A.typeforce.maybe, A.tuple = A.typeforce.tuple, A.UInt8 = A.typeforce.UInt8, A.UInt32 = A.typeforce.UInt32, A.Function = A.typeforce.Function, A.BufferN = A.typeforce.BufferN, A.Null = A.typeforce.Null, A.oneOf = A.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const A = bip66, B = requireScript(), L = types$4, { typeforce: K } = L, V = Buffer$1.alloc(1, 0);
  function W(ce) {
    let re = 0;
    for (; ce[re] === 0; ) ++re;
    return re === ce.length ? V : (ce = ce.slice(re), ce[0] & 128 ? Buffer$1.concat([V, ce], 1 + ce.length) : ce);
  }
  function J(ce) {
    ce[0] === 0 && (ce = ce.slice(1));
    const re = Buffer$1.alloc(32, 0), oe = Math.max(0, 32 - ce.length);
    return ce.copy(re, oe), re;
  }
  function ne(ce) {
    const re = ce.readUInt8(ce.length - 1);
    if (!(0, B.isDefinedHashType)(re))
      throw new Error("Invalid hashType " + re);
    const oe = A.decode(ce.slice(0, -1)), ke = J(oe.r), Ce = J(oe.s);
    return { signature: Buffer$1.concat([ke, Ce], 64), hashType: re };
  }
  script_signature.decode = ne;
  function ie(ce, re) {
    if (K(
      {
        signature: L.BufferN(64),
        hashType: L.UInt8
      },
      { signature: ce, hashType: re }
    ), !(0, B.isDefinedHashType)(re))
      throw new Error("Invalid hashType " + re);
    const oe = Buffer$1.allocUnsafe(1);
    oe.writeUInt8(re, 0);
    const ke = W(ce.slice(0, 32)), Ce = W(ce.slice(32, 64));
    return Buffer$1.concat([A.encode(ke, Ce), oe]);
  }
  return script_signature.encode = ie, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.signature = A.number = A.isCanonicalScriptSignature = A.isDefinedHashType = A.isCanonicalPubKey = A.toStack = A.fromASM = A.toASM = A.decompile = A.compile = A.countNonPushOnlyOPs = A.isPushOnly = A.OPS = void 0;
    const B = bip66, L = ops;
    Object.defineProperty(A, "OPS", {
      enumerable: !0,
      get: function() {
        return L.OPS;
      }
    });
    const K = push_data, V = script_number, W = requireScript_signature(), J = types$4, { typeforce: ne } = J, ie = L.OPS.OP_RESERVED;
    function ce(vt) {
      return J.Number(vt) && (vt === L.OPS.OP_0 || vt >= L.OPS.OP_1 && vt <= L.OPS.OP_16 || vt === L.OPS.OP_1NEGATE);
    }
    function re(vt) {
      return J.Buffer(vt) || ce(vt);
    }
    function oe(vt) {
      return J.Array(vt) && vt.every(re);
    }
    A.isPushOnly = oe;
    function ke(vt) {
      return vt.length - vt.filter(re).length;
    }
    A.countNonPushOnlyOPs = ke;
    function Ce(vt) {
      if (vt.length === 0) return L.OPS.OP_0;
      if (vt.length === 1) {
        if (vt[0] >= 1 && vt[0] <= 16) return ie + vt[0];
        if (vt[0] === 129) return L.OPS.OP_1NEGATE;
      }
    }
    function it(vt) {
      return Buffer$1.isBuffer(vt);
    }
    function at(vt) {
      return J.Array(vt);
    }
    function ct(vt) {
      return Buffer$1.isBuffer(vt);
    }
    function dt(vt) {
      if (it(vt)) return vt;
      ne(J.Array, vt);
      const It = vt.reduce((rt, pe) => ct(pe) ? pe.length === 1 && Ce(pe) !== void 0 ? rt + 1 : rt + K.encodingLength(pe.length) + pe.length : rt + 1, 0), wt = Buffer$1.allocUnsafe(It);
      let Oe = 0;
      if (vt.forEach((rt) => {
        if (ct(rt)) {
          const pe = Ce(rt);
          if (pe !== void 0) {
            wt.writeUInt8(pe, Oe), Oe += 1;
            return;
          }
          Oe += K.encode(wt, rt.length, Oe), rt.copy(wt, Oe), Oe += rt.length;
        } else
          wt.writeUInt8(rt, Oe), Oe += 1;
      }), Oe !== wt.length) throw new Error("Could not decode chunks");
      return wt;
    }
    A.compile = dt;
    function ot(vt) {
      if (at(vt)) return vt;
      ne(J.Buffer, vt);
      const It = [];
      let wt = 0;
      for (; wt < vt.length; ) {
        const Oe = vt[wt];
        if (Oe > L.OPS.OP_0 && Oe <= L.OPS.OP_PUSHDATA4) {
          const rt = K.decode(vt, wt);
          if (rt === null || (wt += rt.size, wt + rt.number > vt.length)) return null;
          const pe = vt.slice(wt, wt + rt.number);
          wt += rt.number;
          const nt = Ce(pe);
          nt !== void 0 ? It.push(nt) : It.push(pe);
        } else
          It.push(Oe), wt += 1;
      }
      return It;
    }
    A.decompile = ot;
    function yt(vt) {
      if (it(vt) && (vt = ot(vt)), !vt)
        throw new Error("Could not convert invalid chunks to ASM");
      return vt.map((It) => {
        if (ct(It)) {
          const wt = Ce(It);
          if (wt === void 0) return It.toString("hex");
          It = wt;
        }
        return L.REVERSE_OPS[It];
      }).join(" ");
    }
    A.toASM = yt;
    function mt(vt) {
      return ne(J.String, vt), dt(
        vt.split(" ").map((It) => L.OPS[It] !== void 0 ? L.OPS[It] : (ne(J.Hex, It), Buffer$1.from(It, "hex")))
      );
    }
    A.fromASM = mt;
    function Tt(vt) {
      return vt = ot(vt), ne(oe, vt), vt.map((It) => ct(It) ? It : It === L.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : V.encode(It - ie));
    }
    A.toStack = Tt;
    function Pt(vt) {
      return J.isPoint(vt);
    }
    A.isCanonicalPubKey = Pt;
    function Nt(vt) {
      const It = vt & -129;
      return It > 0 && It < 4;
    }
    A.isDefinedHashType = Nt;
    function St(vt) {
      return !Buffer$1.isBuffer(vt) || !Nt(vt[vt.length - 1]) ? !1 : B.check(vt.slice(0, -1));
    }
    A.isCanonicalScriptSignature = St, A.number = V, A.signature = W;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(A, B, L) {
  Object.defineProperty(A, B, {
    configurable: !0,
    enumerable: !0,
    get() {
      const K = L.call(this);
      return this[B] = K, K;
    },
    set(K) {
      Object.defineProperty(this, B, {
        configurable: !0,
        enumerable: !0,
        value: K,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(A) {
  let B;
  return () => (B !== void 0 || (B = A()), B);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(A, B) {
  if (!A.data && !A.output) throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    A
  );
  const K = { name: "embed", network: A.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (A.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(A.data));
  }), lazy$6.prop(K, "data", () => {
    if (A.output)
      return bscript$9.decompile(A.output).slice(1);
  }), B.validate && A.output) {
    const V = bscript$9.decompile(A.output);
    if (V[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!V.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (A.data && !(0, types_1$7.stacksEqual)(A.data, K.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(K, A);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(A, B) {
  if (!A.input && !A.output && !(A.pubkeys && A.m !== void 0) && !A.signatures)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {});
  function L(ie) {
    return bscript$8.isCanonicalScriptSignature(ie) || (B.allowIncomplete && ie === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(L)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    A
  );
  const V = { network: A.network || networks_1$6.bitcoin };
  let W = [], J = !1;
  function ne(ie) {
    J || (J = !0, W = bscript$8.decompile(ie), V.m = W[0] - OP_INT_BASE, V.n = W[W.length - 2] - OP_INT_BASE, V.pubkeys = W.slice(1, -2));
  }
  if (lazy$5.prop(V, "output", () => {
    if (A.m && V.n && A.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + A.m,
          A.pubkeys,
          OP_INT_BASE + V.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(V, "m", () => {
    if (V.output)
      return ne(V.output), V.m;
  }), lazy$5.prop(V, "n", () => {
    if (V.pubkeys)
      return V.pubkeys.length;
  }), lazy$5.prop(V, "pubkeys", () => {
    if (A.output)
      return ne(A.output), V.pubkeys;
  }), lazy$5.prop(V, "signatures", () => {
    if (A.input)
      return bscript$8.decompile(A.input).slice(1);
  }), lazy$5.prop(V, "input", () => {
    if (A.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(A.signatures));
  }), lazy$5.prop(V, "witness", () => {
    if (V.input)
      return [];
  }), lazy$5.prop(V, "name", () => {
    if (!(!V.m || !V.n))
      return `p2ms(${V.m} of ${V.n})`;
  }), B.validate) {
    if (A.output) {
      if (ne(A.output), !types_1$6.typeforce.Number(W[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(W[W.length - 2]))
        throw new TypeError("Output is invalid");
      if (W[W.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (V.m <= 0 || V.n > 16 || V.m > V.n || V.n !== W.length - 3)
        throw new TypeError("Output is invalid");
      if (!V.pubkeys.every((ie) => (0, types_1$6.isPoint)(ie)))
        throw new TypeError("Output is invalid");
      if (A.m !== void 0 && A.m !== V.m) throw new TypeError("m mismatch");
      if (A.n !== void 0 && A.n !== V.n) throw new TypeError("n mismatch");
      if (A.pubkeys && !(0, types_1$6.stacksEqual)(A.pubkeys, V.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (A.pubkeys) {
      if (A.n !== void 0 && A.n !== A.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (V.n = A.pubkeys.length, V.n < V.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (A.signatures) {
      if (A.signatures.length < V.m)
        throw new TypeError("Not enough signatures provided");
      if (A.signatures.length > V.m)
        throw new TypeError("Too many signatures provided");
    }
    if (A.input) {
      if (A.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (V.signatures.length === 0 || !V.signatures.every(L))
        throw new TypeError("Input has invalid signature(s)");
      if (A.signatures && !(0, types_1$6.stacksEqual)(A.signatures, V.signatures))
        throw new TypeError("Signature mismatch");
      if (A.m !== void 0 && A.m !== A.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(V, A);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(A, B) {
  if (!A.input && !A.output && !A.pubkey && !A.input && !A.signature)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    A
  );
  const L = lazy$4.value(() => bscript$7.decompile(A.input)), V = { name: "p2pk", network: A.network || networks_1$5.bitcoin };
  if (lazy$4.prop(V, "output", () => {
    if (A.pubkey)
      return bscript$7.compile([A.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(V, "pubkey", () => {
    if (A.output)
      return A.output.slice(1, -1);
  }), lazy$4.prop(V, "signature", () => {
    if (A.input)
      return L()[0];
  }), lazy$4.prop(V, "input", () => {
    if (A.signature)
      return bscript$7.compile([A.signature]);
  }), lazy$4.prop(V, "witness", () => {
    if (V.input)
      return [];
  }), B.validate) {
    if (A.output) {
      if (A.output[A.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(V.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (A.pubkey && !A.pubkey.equals(V.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (A.signature && A.input && !A.input.equals(V.input))
      throw new TypeError("Signature mismatch");
    if (A.input) {
      if (L().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(V.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(V, A);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((A, B) => B)), Pi = /* @__PURE__ */ Id.map((A) => (9 * A + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let A = 0; A < 4; A++)
  for (let B of [idxL, idxR])
    B.push(B[A].map((L) => Rho[L]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((A) => new Uint8Array(A)), shiftsL = /* @__PURE__ */ idxL.map((A, B) => A.map((L) => shifts[B][L])), shiftsR = /* @__PURE__ */ idxR.map((A, B) => A.map((L) => shifts[B][L])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(A, B, L, K) {
  return A === 0 ? B ^ L ^ K : A === 1 ? B & L | ~B & K : A === 2 ? (B | ~L) ^ K : A === 3 ? B & K | L & ~K : B ^ (L | ~K);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: B, h1: L, h2: K, h3: V, h4: W } = this;
    return [B, L, K, V, W];
  }
  set(B, L, K, V, W) {
    this.h0 = B | 0, this.h1 = L | 0, this.h2 = K | 0, this.h3 = V | 0, this.h4 = W | 0;
  }
  process(B, L) {
    for (let Ce = 0; Ce < 16; Ce++, L += 4)
      R_BUF[Ce] = B.getUint32(L, !0);
    let K = this.h0 | 0, V = K, W = this.h1 | 0, J = W, ne = this.h2 | 0, ie = ne, ce = this.h3 | 0, re = ce, oe = this.h4 | 0, ke = oe;
    for (let Ce = 0; Ce < 5; Ce++) {
      const it = 4 - Ce, at = Kl[Ce], ct = Kr[Ce], dt = idxL[Ce], ot = idxR[Ce], yt = shiftsL[Ce], mt = shiftsR[Ce];
      for (let Tt = 0; Tt < 16; Tt++) {
        const Pt = (0, utils_js_1$1.rotl)(K + f(Ce, W, ne, ce) + R_BUF[dt[Tt]] + at, yt[Tt]) + oe | 0;
        K = oe, oe = ce, ce = (0, utils_js_1$1.rotl)(ne, 10) | 0, ne = W, W = Pt;
      }
      for (let Tt = 0; Tt < 16; Tt++) {
        const Pt = (0, utils_js_1$1.rotl)(V + f(it, J, ie, re) + R_BUF[ot[Tt]] + ct, mt[Tt]) + ke | 0;
        V = ke, ke = re, re = (0, utils_js_1$1.rotl)(ie, 10) | 0, ie = J, J = Pt;
      }
    }
    this.set(this.h1 + ne + re | 0, this.h2 + ce + ke | 0, this.h3 + oe + V | 0, this.h4 + K + J | 0, this.h0 + W + ie | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: V, E: W } = this;
    return [B, L, K, V, W];
  }
  set(B, L, K, V, W) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = V | 0, this.E = W | 0;
  }
  process(B, L) {
    for (let ie = 0; ie < 16; ie++, L += 4)
      SHA1_W[ie] = B.getUint32(L, !1);
    for (let ie = 16; ie < 80; ie++)
      SHA1_W[ie] = (0, utils_js_1.rotl)(SHA1_W[ie - 3] ^ SHA1_W[ie - 8] ^ SHA1_W[ie - 14] ^ SHA1_W[ie - 16], 1);
    let { A: K, B: V, C: W, D: J, E: ne } = this;
    for (let ie = 0; ie < 80; ie++) {
      let ce, re;
      ie < 20 ? (ce = (0, _md_js_1.Chi)(V, W, J), re = 1518500249) : ie < 40 ? (ce = V ^ W ^ J, re = 1859775393) : ie < 60 ? (ce = (0, _md_js_1.Maj)(V, W, J), re = 2400959708) : (ce = V ^ W ^ J, re = 3395469782);
      const oe = (0, utils_js_1.rotl)(K, 5) + ce + ne + re + SHA1_W[ie] | 0;
      ne = J, J = W, W = (0, utils_js_1.rotl)(V, 30), V = K, K = oe;
    }
    K = K + this.A | 0, V = V + this.B | 0, W = W + this.C | 0, J = J + this.D | 0, ne = ne + this.E | 0, this.set(K, V, W, J, ne);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.taggedHash = A.TAGGED_HASH_PREFIXES = A.TAGS = A.hash256 = A.hash160 = A.sha256 = A.sha1 = A.ripemd160 = void 0;
  const B = ripemd160, L = sha1, K = sha256$4;
  function V(re) {
    return Buffer$1.from((0, B.ripemd160)(Uint8Array.from(re)));
  }
  A.ripemd160 = V;
  function W(re) {
    return Buffer$1.from((0, L.sha1)(Uint8Array.from(re)));
  }
  A.sha1 = W;
  function J(re) {
    return Buffer$1.from((0, K.sha256)(Uint8Array.from(re)));
  }
  A.sha256 = J;
  function ne(re) {
    return Buffer$1.from(
      (0, B.ripemd160)((0, K.sha256)(Uint8Array.from(re)))
    );
  }
  A.hash160 = ne;
  function ie(re) {
    return Buffer$1.from(
      (0, K.sha256)((0, K.sha256)(Uint8Array.from(re)))
    );
  }
  A.hash256 = ie, A.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], A.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function ce(re, oe) {
    return J(Buffer$1.concat([A.TAGGED_HASH_PREFIXES[re], oe]));
  }
  A.taggedHash = ce;
})(crypto$1);
function base$1(A) {
  if (A.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var B = new Uint8Array(256), L = 0; L < B.length; L++)
    B[L] = 255;
  for (var K = 0; K < A.length; K++) {
    var V = A.charAt(K), W = V.charCodeAt(0);
    if (B[W] !== 255)
      throw new TypeError(V + " is ambiguous");
    B[W] = K;
  }
  var J = A.length, ne = A.charAt(0), ie = Math.log(J) / Math.log(256), ce = Math.log(256) / Math.log(J);
  function re(Ce) {
    if (Ce instanceof Uint8Array || (ArrayBuffer.isView(Ce) ? Ce = new Uint8Array(Ce.buffer, Ce.byteOffset, Ce.byteLength) : Array.isArray(Ce) && (Ce = Uint8Array.from(Ce))), !(Ce instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ce.length === 0)
      return "";
    for (var it = 0, at = 0, ct = 0, dt = Ce.length; ct !== dt && Ce[ct] === 0; )
      ct++, it++;
    for (var ot = (dt - ct) * ce + 1 >>> 0, yt = new Uint8Array(ot); ct !== dt; ) {
      for (var mt = Ce[ct], Tt = 0, Pt = ot - 1; (mt !== 0 || Tt < at) && Pt !== -1; Pt--, Tt++)
        mt += 256 * yt[Pt] >>> 0, yt[Pt] = mt % J >>> 0, mt = mt / J >>> 0;
      if (mt !== 0)
        throw new Error("Non-zero carry");
      at = Tt, ct++;
    }
    for (var Nt = ot - at; Nt !== ot && yt[Nt] === 0; )
      Nt++;
    for (var St = ne.repeat(it); Nt < ot; ++Nt)
      St += A.charAt(yt[Nt]);
    return St;
  }
  function oe(Ce) {
    if (typeof Ce != "string")
      throw new TypeError("Expected String");
    if (Ce.length === 0)
      return new Uint8Array();
    for (var it = 0, at = 0, ct = 0; Ce[it] === ne; )
      at++, it++;
    for (var dt = (Ce.length - it) * ie + 1 >>> 0, ot = new Uint8Array(dt); Ce[it]; ) {
      var yt = B[Ce.charCodeAt(it)];
      if (yt === 255)
        return;
      for (var mt = 0, Tt = dt - 1; (yt !== 0 || mt < ct) && Tt !== -1; Tt--, mt++)
        yt += J * ot[Tt] >>> 0, ot[Tt] = yt % 256 >>> 0, yt = yt / 256 >>> 0;
      if (yt !== 0)
        throw new Error("Non-zero carry");
      ct = mt, it++;
    }
    for (var Pt = dt - ct; Pt !== dt && ot[Pt] === 0; )
      Pt++;
    for (var Nt = new Uint8Array(at + (dt - Pt)), St = at; Pt !== dt; )
      Nt[St++] = ot[Pt++];
    return Nt;
  }
  function ke(Ce) {
    var it = oe(Ce);
    if (it)
      return it;
    throw new Error("Non-base" + J + " character");
  }
  return {
    encode: re,
    decodeUnsafe: oe,
    decode: ke
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(A) {
  function B(W) {
    var J = Uint8Array.from(W), ne = A(J), ie = J.length + 4, ce = new Uint8Array(ie);
    return ce.set(J, 0), ce.set(ne.subarray(0, 4), J.length), base58.encode(ce, ie);
  }
  function L(W) {
    var J = W.slice(0, -4), ne = W.slice(-4), ie = A(J);
    if (!(ne[0] ^ ie[0] | ne[1] ^ ie[1] | ne[2] ^ ie[2] | ne[3] ^ ie[3]))
      return J;
  }
  function K(W) {
    var J = base58.decodeUnsafe(W);
    if (J)
      return L(J);
  }
  function V(W) {
    var J = base58.decode(W), ne = L(J);
    if (!ne) throw new Error("Invalid checksum");
    return ne;
  }
  return {
    encode: B,
    decode: V,
    decodeUnsafe: K
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(A) {
  return sha256(sha256(A));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    A
  );
  const L = lazy$3.value(() => {
    const J = Buffer$1.from(bs58check$1.decode(A.address)), ne = J.readUInt8(0), ie = J.slice(1);
    return { version: ne, hash: ie };
  }), K = lazy$3.value(() => bscript$6.decompile(A.input)), V = A.network || networks_1$4.bitcoin, W = { name: "p2pkh", network: V };
  if (lazy$3.prop(W, "address", () => {
    if (!W.hash) return;
    const J = Buffer$1.allocUnsafe(21);
    return J.writeUInt8(V.pubKeyHash, 0), W.hash.copy(J, 1), bs58check$1.encode(J);
  }), lazy$3.prop(W, "hash", () => {
    if (A.output) return A.output.slice(3, 23);
    if (A.address) return L().hash;
    if (A.pubkey || W.pubkey) return bcrypto$5.hash160(A.pubkey || W.pubkey);
  }), lazy$3.prop(W, "output", () => {
    if (W.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        W.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(W, "pubkey", () => {
    if (A.input)
      return K()[1];
  }), lazy$3.prop(W, "signature", () => {
    if (A.input)
      return K()[0];
  }), lazy$3.prop(W, "input", () => {
    if (A.pubkey && A.signature)
      return bscript$6.compile([A.signature, A.pubkey]);
  }), lazy$3.prop(W, "witness", () => {
    if (W.input)
      return [];
  }), B.validate) {
    let J = Buffer$1.from([]);
    if (A.address) {
      if (L().version !== V.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (L().hash.length !== 20) throw new TypeError("Invalid address");
      J = L().hash;
    }
    if (A.hash) {
      if (J.length > 0 && !J.equals(A.hash))
        throw new TypeError("Hash mismatch");
      J = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 25 || A.output[0] !== OPS$3.OP_DUP || A.output[1] !== OPS$3.OP_HASH160 || A.output[2] !== 20 || A.output[23] !== OPS$3.OP_EQUALVERIFY || A.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(3, 23);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.pubkey) {
      const ne = bcrypto$5.hash160(A.pubkey);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.input) {
      const ne = K();
      if (ne.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ne[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ne[1]))
        throw new TypeError("Input has invalid pubkey");
      if (A.signature && !A.signature.equals(ne[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(ne[1]))
        throw new TypeError("Pubkey mismatch");
      const ie = bcrypto$5.hash160(ne[1]);
      if (J.length > 0 && !J.equals(ie))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(W, A);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    A
  );
  let L = A.network;
  L || (L = A.redeem && A.redeem.network || networks_1$3.bitcoin);
  const K = { network: L }, V = lazy$2.value(() => {
    const ne = Buffer$1.from(bs58check.decode(A.address)), ie = ne.readUInt8(0), ce = ne.slice(1);
    return { version: ie, hash: ce };
  }), W = lazy$2.value(() => bscript$5.decompile(A.input)), J = lazy$2.value(() => {
    const ne = W(), ie = ne[ne.length - 1];
    return {
      network: L,
      output: ie === OPS$2.OP_FALSE ? Buffer$1.from([]) : ie,
      input: bscript$5.compile(ne.slice(0, -1)),
      witness: A.witness || []
    };
  });
  if (lazy$2.prop(K, "address", () => {
    if (!K.hash) return;
    const ne = Buffer$1.allocUnsafe(21);
    return ne.writeUInt8(K.network.scriptHash, 0), K.hash.copy(ne, 1), bs58check.encode(ne);
  }), lazy$2.prop(K, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return V().hash;
    if (K.redeem && K.redeem.output) return bcrypto$4.hash160(K.redeem.output);
  }), lazy$2.prop(K, "output", () => {
    if (K.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, K.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(K, "redeem", () => {
    if (A.input)
      return J();
  }), lazy$2.prop(K, "input", () => {
    if (!(!A.redeem || !A.redeem.input || !A.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(A.redeem.input), A.redeem.output)
      );
  }), lazy$2.prop(K, "witness", () => {
    if (K.redeem && K.redeem.witness) return K.redeem.witness;
    if (K.input) return [];
  }), lazy$2.prop(K, "name", () => {
    const ne = ["p2sh"];
    return K.redeem !== void 0 && K.redeem.name !== void 0 && ne.push(K.redeem.name), ne.join("-");
  }), B.validate) {
    let ne = Buffer$1.from([]);
    if (A.address) {
      if (V().version !== L.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (V().hash.length !== 20) throw new TypeError("Invalid address");
      ne = V().hash;
    }
    if (A.hash) {
      if (ne.length > 0 && !ne.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ne = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 23 || A.output[0] !== OPS$2.OP_HASH160 || A.output[1] !== 20 || A.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const ce = A.output.slice(2, 22);
      if (ne.length > 0 && !ne.equals(ce))
        throw new TypeError("Hash mismatch");
      ne = ce;
    }
    const ie = (ce) => {
      if (ce.output) {
        const re = bscript$5.decompile(ce.output);
        if (!re || re.length < 1)
          throw new TypeError("Redeem.output too short");
        if (ce.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(re) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const oe = bcrypto$4.hash160(ce.output);
        if (ne.length > 0 && !ne.equals(oe))
          throw new TypeError("Hash mismatch");
        ne = oe;
      }
      if (ce.input) {
        const re = ce.input.length > 0, oe = ce.witness && ce.witness.length > 0;
        if (!re && !oe) throw new TypeError("Empty input");
        if (re && oe)
          throw new TypeError("Input and witness provided");
        if (re) {
          const ke = bscript$5.decompile(ce.input);
          if (!bscript$5.isPushOnly(ke))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (A.input) {
      const ce = W();
      if (!ce || ce.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(J().output))
        throw new TypeError("Input is invalid");
      ie(J());
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== L)
        throw new TypeError("Network mismatch");
      if (A.input) {
        const ce = J();
        if (A.redeem.output && !A.redeem.output.equals(ce.output))
          throw new TypeError("Redeem.output mismatch");
        if (A.redeem.input && !A.redeem.input.equals(ce.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ie(A.redeem);
    }
    if (A.witness && A.redeem && A.redeem.witness && !(0, types_1$3.stacksEqual)(A.redeem.witness, A.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(K, A);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let A = 0; A < ALPHABET.length; A++) {
  const B = ALPHABET.charAt(A);
  ALPHABET_MAP[B] = A;
}
function polymodStep(A) {
  const B = A >> 25;
  return (A & 33554431) << 5 ^ -(B >> 0 & 1) & 996825010 ^ -(B >> 1 & 1) & 642813549 ^ -(B >> 2 & 1) & 513874426 ^ -(B >> 3 & 1) & 1027748829 ^ -(B >> 4 & 1) & 705979059;
}
function prefixChk(A) {
  let B = 1;
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    if (K < 33 || K > 126)
      return "Invalid prefix (" + A + ")";
    B = polymodStep(B) ^ K >> 5;
  }
  B = polymodStep(B);
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    B = polymodStep(B) ^ K & 31;
  }
  return B;
}
function convert$2(A, B, L, K) {
  let V = 0, W = 0;
  const J = (1 << L) - 1, ne = [];
  for (let ie = 0; ie < A.length; ++ie)
    for (V = V << B | A[ie], W += B; W >= L; )
      W -= L, ne.push(V >> W & J);
  if (K)
    W > 0 && ne.push(V << L - W & J);
  else {
    if (W >= B)
      return "Excess padding";
    if (V << L - W & J)
      return "Non-zero padding";
  }
  return ne;
}
function toWords(A) {
  return convert$2(A, 8, 5, !0);
}
function fromWordsUnsafe(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
}
function fromWords(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
  throw new Error(B);
}
function getLibraryFromEncoding(A) {
  let B;
  A === "bech32" ? B = 1 : B = 734539939;
  function L(J, ne, ie) {
    if (ie = ie || 90, J.length + 7 + ne.length > ie)
      throw new TypeError("Exceeds length limit");
    J = J.toLowerCase();
    let ce = prefixChk(J);
    if (typeof ce == "string")
      throw new Error(ce);
    let re = J + "1";
    for (let oe = 0; oe < ne.length; ++oe) {
      const ke = ne[oe];
      if (ke >> 5)
        throw new Error("Non 5-bit word");
      ce = polymodStep(ce) ^ ke, re += ALPHABET.charAt(ke);
    }
    for (let oe = 0; oe < 6; ++oe)
      ce = polymodStep(ce);
    ce ^= B;
    for (let oe = 0; oe < 6; ++oe) {
      const ke = ce >> (5 - oe) * 5 & 31;
      re += ALPHABET.charAt(ke);
    }
    return re;
  }
  function K(J, ne) {
    if (ne = ne || 90, J.length < 8)
      return J + " too short";
    if (J.length > ne)
      return "Exceeds length limit";
    const ie = J.toLowerCase(), ce = J.toUpperCase();
    if (J !== ie && J !== ce)
      return "Mixed-case string " + J;
    J = ie;
    const re = J.lastIndexOf("1");
    if (re === -1)
      return "No separator character for " + J;
    if (re === 0)
      return "Missing prefix for " + J;
    const oe = J.slice(0, re), ke = J.slice(re + 1);
    if (ke.length < 6)
      return "Data too short";
    let Ce = prefixChk(oe);
    if (typeof Ce == "string")
      return Ce;
    const it = [];
    for (let at = 0; at < ke.length; ++at) {
      const ct = ke.charAt(at), dt = ALPHABET_MAP[ct];
      if (dt === void 0)
        return "Unknown character " + ct;
      Ce = polymodStep(Ce) ^ dt, !(at + 6 >= ke.length) && it.push(dt);
    }
    return Ce !== B ? "Invalid checksum for " + J : { prefix: oe, words: it };
  }
  function V(J, ne) {
    const ie = K(J, ne);
    if (typeof ie == "object")
      return ie;
  }
  function W(J, ne) {
    const ie = K(J, ne);
    if (typeof ie == "object")
      return ie;
    throw new Error(ie);
  }
  return {
    decodeUnsafe: V,
    decode: W,
    encode: L,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy$1.value(() => {
    const W = bech32_1$1.bech32.decode(A.address), J = W.words.shift(), ne = bech32_1$1.bech32.fromWords(W.words);
    return {
      version: J,
      prefix: W.prefix,
      data: Buffer$1.from(ne)
    };
  }), K = A.network || networks_1$2.bitcoin, V = { name: "p2wpkh", network: K };
  if (lazy$1.prop(V, "address", () => {
    if (!V.hash) return;
    const W = bech32_1$1.bech32.toWords(V.hash);
    return W.unshift(0), bech32_1$1.bech32.encode(K.bech32, W);
  }), lazy$1.prop(V, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return L().data;
    if (A.pubkey || V.pubkey) return bcrypto$3.hash160(A.pubkey || V.pubkey);
  }), lazy$1.prop(V, "output", () => {
    if (V.hash)
      return bscript$4.compile([OPS$1.OP_0, V.hash]);
  }), lazy$1.prop(V, "pubkey", () => {
    if (A.pubkey) return A.pubkey;
    if (A.witness)
      return A.witness[1];
  }), lazy$1.prop(V, "signature", () => {
    if (A.witness)
      return A.witness[0];
  }), lazy$1.prop(V, "input", () => {
    if (V.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(V, "witness", () => {
    if (A.pubkey && A.signature)
      return [A.signature, A.pubkey];
  }), B.validate) {
    let W = Buffer$1.from([]);
    if (A.address) {
      if (K && K.bech32 !== L().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 20)
        throw new TypeError("Invalid address data");
      W = L().data;
    }
    if (A.hash) {
      if (W.length > 0 && !W.equals(A.hash))
        throw new TypeError("Hash mismatch");
      W = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 22 || A.output[0] !== OPS$1.OP_0 || A.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (W.length > 0 && !W.equals(A.output.slice(2)))
        throw new TypeError("Hash mismatch");
      W = A.output.slice(2);
    }
    if (A.pubkey) {
      const J = bcrypto$3.hash160(A.pubkey);
      if (W.length > 0 && !W.equals(J))
        throw new TypeError("Hash mismatch");
      if (W = J, !(0, types_1$2.isPoint)(A.pubkey) || A.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (A.witness) {
      if (A.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(A.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(A.witness[1]) || A.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (A.signature && !A.signature.equals(A.witness[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(A.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const J = bcrypto$3.hash160(A.witness[1]);
      if (W.length > 0 && !W.equals(J))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(V, A);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(A) {
  return !!(Buffer$1.isBuffer(A) && A.length === 65 && A[0] === 4 && (0, types_1$1.isPoint)(A));
}
function p2wsh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy.value(() => {
    const J = bech32_1.bech32.decode(A.address), ne = J.words.shift(), ie = bech32_1.bech32.fromWords(J.words);
    return {
      version: ne,
      prefix: J.prefix,
      data: Buffer$1.from(ie)
    };
  }), K = lazy.value(() => bscript$3.decompile(A.redeem.input));
  let V = A.network;
  V || (V = A.redeem && A.redeem.network || networks_1$1.bitcoin);
  const W = { network: V };
  if (lazy.prop(W, "address", () => {
    if (!W.hash) return;
    const J = bech32_1.bech32.toWords(W.hash);
    return J.unshift(0), bech32_1.bech32.encode(V.bech32, J);
  }), lazy.prop(W, "hash", () => {
    if (A.output) return A.output.slice(2);
    if (A.address) return L().data;
    if (W.redeem && W.redeem.output) return bcrypto$2.sha256(W.redeem.output);
  }), lazy.prop(W, "output", () => {
    if (W.hash)
      return bscript$3.compile([OPS.OP_0, W.hash]);
  }), lazy.prop(W, "redeem", () => {
    if (A.witness)
      return {
        output: A.witness[A.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: A.witness.slice(0, -1)
      };
  }), lazy.prop(W, "input", () => {
    if (W.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(W, "witness", () => {
    if (A.redeem && A.redeem.input && A.redeem.input.length > 0 && A.redeem.output && A.redeem.output.length > 0) {
      const J = bscript$3.toStack(K());
      return W.redeem = Object.assign({ witness: J }, A.redeem), W.redeem.input = EMPTY_BUFFER$1, [].concat(J, A.redeem.output);
    }
    if (A.redeem && A.redeem.output && A.redeem.witness)
      return [].concat(A.redeem.witness, A.redeem.output);
  }), lazy.prop(W, "name", () => {
    const J = ["p2wsh"];
    return W.redeem !== void 0 && W.redeem.name !== void 0 && J.push(W.redeem.name), J.join("-");
  }), B.validate) {
    let J = Buffer$1.from([]);
    if (A.address) {
      if (L().prefix !== V.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 32)
        throw new TypeError("Invalid address data");
      J = L().data;
    }
    if (A.hash) {
      if (J.length > 0 && !J.equals(A.hash))
        throw new TypeError("Hash mismatch");
      J = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 34 || A.output[0] !== OPS.OP_0 || A.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(2);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== V)
        throw new TypeError("Network mismatch");
      if (A.redeem.input && A.redeem.input.length > 0 && A.redeem.witness && A.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (A.redeem.output) {
        const ne = bscript$3.decompile(A.redeem.output);
        if (!ne || ne.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (A.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ne) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ie = bcrypto$2.sha256(A.redeem.output);
        if (J.length > 0 && !J.equals(ie))
          throw new TypeError("Hash mismatch");
        J = ie;
      }
      if (A.redeem.input && !bscript$3.isPushOnly(K()))
        throw new TypeError("Non push-only scriptSig");
      if (A.witness && A.redeem.witness && !(0, types_1$1.stacksEqual)(A.witness, A.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (A.redeem.input && K().some(chunkHasUncompressedPubkey) || A.redeem.output && (bscript$3.decompile(A.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (A.witness && A.witness.length > 0) {
      const ne = A.witness[A.witness.length - 1];
      if (A.redeem && A.redeem.output && !A.redeem.output.equals(ne))
        throw new TypeError("Witness and redeem.output mismatch");
      if (A.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ne) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(W, A);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(A) {
  A ? A !== _ECCLIB_CACHE.eccLib && (verifyEcc(A), _ECCLIB_CACHE.eccLib = A) : _ECCLIB_CACHE.eccLib = A;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (A) => Buffer$1.from(A, "hex");
function verifyEcc(A) {
  assert(typeof A.isXOnlyPoint == "function"), assert(
    A.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    A.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof A.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((B) => {
    const L = A.xOnlyPointAddTweak(h(B.pubkey), h(B.tweak));
    B.result === null ? assert(L === null) : (assert(L !== null), assert(L.parity === B.parity), assert(Buffer$1.from(L.xOnlyPubkey).equals(h(B.result))));
  });
}
function assert(A) {
  if (!A) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER$1 || A % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(A, B, L) {
  if (checkUInt53$1(A), B || (B = Buffer.allocUnsafe(encodingLength$1(A))), !Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), encode$f.bytes = 1) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), encode$f.bytes = 3) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), encode$f.bytes = 5) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), encode$f.bytes = 9), B;
}
function decode$e(A, B) {
  if (!Buffer.isBuffer(A)) throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  var L = A.readUInt8(B);
  if (L < 253)
    return decode$e.bytes = 1, L;
  if (L === 253)
    return decode$e.bytes = 3, A.readUInt16LE(B + 1);
  if (L === 254)
    return decode$e.bytes = 5, A.readUInt32LE(B + 1);
  decode$e.bytes = 9;
  var K = A.readUInt32LE(B + 1), V = A.readUInt32LE(B + 5), W = V * 4294967296 + K;
  return checkUInt53$1(W), W;
}
function encodingLength$1(A) {
  return checkUInt53$1(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint$1(K + L, 9007199254740991), K + L;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(A, B, L) {
  return verifuint$1(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(A) {
  const B = Buffer$1.allocUnsafe(A.length);
  return A.copy(B), B;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(B) {
    return new BufferWriter(Buffer$1.alloc(B));
  }
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  writeUInt8(B) {
    this.offset = this.buffer.writeUInt8(B, this.offset);
  }
  writeInt32(B) {
    this.offset = this.buffer.writeInt32LE(B, this.offset);
  }
  writeUInt32(B) {
    this.offset = this.buffer.writeUInt32LE(B, this.offset);
  }
  writeUInt64(B) {
    this.offset = writeUInt64LE$1(this.buffer, B, this.offset);
  }
  writeVarInt(B) {
    varuint$7.encode(B, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(B) {
    if (this.buffer.length < this.offset + B.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += B.copy(this.buffer, this.offset);
  }
  writeVarSlice(B) {
    this.writeVarInt(B.length), this.writeSlice(B);
  }
  writeVector(B) {
    this.writeVarInt(B.length), B.forEach((L) => this.writeVarSlice(L));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  readUInt8() {
    const B = this.buffer.readUInt8(this.offset);
    return this.offset++, B;
  }
  readInt32() {
    const B = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt32() {
    const B = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt64() {
    const B = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, B;
  }
  readVarInt() {
    const B = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, B;
  }
  readSlice(B) {
    if (this.buffer.length < this.offset + B)
      throw new Error("Cannot read slice out of bounds");
    const L = this.buffer.slice(this.offset, this.offset + B);
    return this.offset += B, L;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const B = this.readVarInt(), L = [];
    for (let K = 0; K < B; K++) L.push(this.readVarSlice());
    return L;
  }
}
bufferutils.BufferReader = BufferReader;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.tweakKey = A.tapTweakHash = A.tapleafHash = A.findScriptPath = A.toHashTree = A.rootHashFromPath = A.MAX_TAPTREE_DEPTH = A.LEAF_VERSION_TAPSCRIPT = void 0;
  const B = dist$1, L = ecc_lib, K = crypto$1, V = bufferutils, W = types$4;
  A.LEAF_VERSION_TAPSCRIPT = 192, A.MAX_TAPTREE_DEPTH = 128;
  const J = (at) => "left" in at && "right" in at;
  function ne(at, ct) {
    if (at.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${at.length}, expected min 33.`
      );
    const dt = (at.length - 33) / 32;
    let ot = ct;
    for (let yt = 0; yt < dt; yt++) {
      const mt = at.slice(33 + 32 * yt, 65 + 32 * yt);
      ot.compare(mt) < 0 ? ot = Ce(ot, mt) : ot = Ce(mt, ot);
    }
    return ot;
  }
  A.rootHashFromPath = ne;
  function ie(at) {
    if ((0, W.isTapleaf)(at))
      return { hash: re(at) };
    const ct = [ie(at[0]), ie(at[1])];
    ct.sort((yt, mt) => yt.hash.compare(mt.hash));
    const [dt, ot] = ct;
    return {
      hash: Ce(dt.hash, ot.hash),
      left: dt,
      right: ot
    };
  }
  A.toHashTree = ie;
  function ce(at, ct) {
    if (J(at)) {
      const dt = ce(at.left, ct);
      if (dt !== void 0) return [...dt, at.right.hash];
      const ot = ce(at.right, ct);
      if (ot !== void 0) return [...ot, at.left.hash];
    } else if (at.hash.equals(ct))
      return [];
  }
  A.findScriptPath = ce;
  function re(at) {
    const ct = at.version || A.LEAF_VERSION_TAPSCRIPT;
    return K.taggedHash(
      "TapLeaf",
      B.Buffer.concat([
        B.Buffer.from([ct]),
        it(at.output)
      ])
    );
  }
  A.tapleafHash = re;
  function oe(at, ct) {
    return K.taggedHash(
      "TapTweak",
      B.Buffer.concat(ct ? [at, ct] : [at])
    );
  }
  A.tapTweakHash = oe;
  function ke(at, ct) {
    if (!B.Buffer.isBuffer(at) || at.length !== 32 || ct && ct.length !== 32) return null;
    const dt = oe(at, ct), ot = (0, L.getEccLib)().xOnlyPointAddTweak(at, dt);
    return !ot || ot.xOnlyPubkey === null ? null : {
      parity: ot.parity,
      x: B.Buffer.from(ot.xOnlyPubkey)
    };
  }
  A.tweakKey = ke;
  function Ce(at, ct) {
    return K.taggedHash("TapBranch", B.Buffer.concat([at, ct]));
  }
  function it(at) {
    const ct = V.varuint.encodingLength(at.length), dt = B.Buffer.allocUnsafe(ct);
    return V.varuint.encode(at.length, dt), B.Buffer.concat([dt, at]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const A = dist$1, B = networks, L = requireScript(), K = types$4, V = ecc_lib, W = bip341, J = lazy$7, ne = dist, ie = requireAddress(), ce = L.OPS, re = 1, oe = 80;
  function ke(Ce, it) {
    if (!Ce.address && !Ce.output && !Ce.pubkey && !Ce.internalPubkey && !(Ce.witness && Ce.witness.length > 1))
      throw new TypeError("Not enough data");
    it = Object.assign({ validate: !0 }, it || {}), (0, K.typeforce)(
      {
        address: K.typeforce.maybe(K.typeforce.String),
        input: K.typeforce.maybe(K.typeforce.BufferN(0)),
        network: K.typeforce.maybe(K.typeforce.Object),
        output: K.typeforce.maybe(K.typeforce.BufferN(34)),
        internalPubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        hash: K.typeforce.maybe(K.typeforce.BufferN(32)),
        pubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        signature: K.typeforce.maybe(
          K.typeforce.anyOf(
            K.typeforce.BufferN(64),
            K.typeforce.BufferN(65)
          )
        ),
        witness: K.typeforce.maybe(
          K.typeforce.arrayOf(K.typeforce.Buffer)
        ),
        scriptTree: K.typeforce.maybe(K.isTaptree),
        redeem: K.typeforce.maybe({
          output: K.typeforce.maybe(K.typeforce.Buffer),
          redeemVersion: K.typeforce.maybe(K.typeforce.Number),
          witness: K.typeforce.maybe(
            K.typeforce.arrayOf(K.typeforce.Buffer)
          )
        }),
        redeemVersion: K.typeforce.maybe(K.typeforce.Number)
      },
      Ce
    );
    const at = J.value(() => (0, ie.fromBech32)(Ce.address)), ct = J.value(() => {
      if (!(!Ce.witness || !Ce.witness.length))
        return Ce.witness.length >= 2 && Ce.witness[Ce.witness.length - 1][0] === oe ? Ce.witness.slice(0, -1) : Ce.witness.slice();
    }), dt = J.value(() => {
      if (Ce.scriptTree) return (0, W.toHashTree)(Ce.scriptTree);
      if (Ce.hash) return { hash: Ce.hash };
    }), ot = Ce.network || B.bitcoin, yt = { name: "p2tr", network: ot };
    if (J.prop(yt, "address", () => {
      if (!yt.pubkey) return;
      const mt = ne.bech32m.toWords(yt.pubkey);
      return mt.unshift(re), ne.bech32m.encode(ot.bech32, mt);
    }), J.prop(yt, "hash", () => {
      const mt = dt();
      if (mt) return mt.hash;
      const Tt = ct();
      if (Tt && Tt.length > 1) {
        const Pt = Tt[Tt.length - 1], Nt = Pt[0] & K.TAPLEAF_VERSION_MASK, St = Tt[Tt.length - 2], vt = (0, W.tapleafHash)({
          output: St,
          version: Nt
        });
        return (0, W.rootHashFromPath)(Pt, vt);
      }
      return null;
    }), J.prop(yt, "output", () => {
      if (yt.pubkey)
        return L.compile([ce.OP_1, yt.pubkey]);
    }), J.prop(yt, "redeemVersion", () => Ce.redeemVersion ? Ce.redeemVersion : Ce.redeem && Ce.redeem.redeemVersion !== void 0 && Ce.redeem.redeemVersion !== null ? Ce.redeem.redeemVersion : W.LEAF_VERSION_TAPSCRIPT), J.prop(yt, "redeem", () => {
      const mt = ct();
      if (!(!mt || mt.length < 2))
        return {
          output: mt[mt.length - 2],
          witness: mt.slice(0, -2),
          redeemVersion: mt[mt.length - 1][0] & K.TAPLEAF_VERSION_MASK
        };
    }), J.prop(yt, "pubkey", () => {
      if (Ce.pubkey) return Ce.pubkey;
      if (Ce.output) return Ce.output.slice(2);
      if (Ce.address) return at().data;
      if (yt.internalPubkey) {
        const mt = (0, W.tweakKey)(yt.internalPubkey, yt.hash);
        if (mt) return mt.x;
      }
    }), J.prop(yt, "internalPubkey", () => {
      if (Ce.internalPubkey) return Ce.internalPubkey;
      const mt = ct();
      if (mt && mt.length > 1)
        return mt[mt.length - 1].slice(1, 33);
    }), J.prop(yt, "signature", () => {
      if (Ce.signature) return Ce.signature;
      const mt = ct();
      if (!(!mt || mt.length !== 1))
        return mt[0];
    }), J.prop(yt, "witness", () => {
      if (Ce.witness) return Ce.witness;
      const mt = dt();
      if (mt && Ce.redeem && Ce.redeem.output && Ce.internalPubkey) {
        const Tt = (0, W.tapleafHash)({
          output: Ce.redeem.output,
          version: yt.redeemVersion
        }), Pt = (0, W.findScriptPath)(mt, Tt);
        if (!Pt) return;
        const Nt = (0, W.tweakKey)(Ce.internalPubkey, mt.hash);
        if (!Nt) return;
        const St = A.Buffer.concat(
          [
            A.Buffer.from([yt.redeemVersion | Nt.parity]),
            Ce.internalPubkey
          ].concat(Pt)
        );
        return [Ce.redeem.output, St];
      }
      if (Ce.signature) return [Ce.signature];
    }), it.validate) {
      let mt = A.Buffer.from([]);
      if (Ce.address) {
        if (ot && ot.bech32 !== at().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (at().version !== re)
          throw new TypeError("Invalid address version");
        if (at().data.length !== 32)
          throw new TypeError("Invalid address data");
        mt = at().data;
      }
      if (Ce.pubkey) {
        if (mt.length > 0 && !mt.equals(Ce.pubkey))
          throw new TypeError("Pubkey mismatch");
        mt = Ce.pubkey;
      }
      if (Ce.output) {
        if (Ce.output.length !== 34 || Ce.output[0] !== ce.OP_1 || Ce.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (mt.length > 0 && !mt.equals(Ce.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        mt = Ce.output.slice(2);
      }
      if (Ce.internalPubkey) {
        const Nt = (0, W.tweakKey)(Ce.internalPubkey, yt.hash);
        if (mt.length > 0 && !mt.equals(Nt.x))
          throw new TypeError("Pubkey mismatch");
        mt = Nt.x;
      }
      if (mt && mt.length && !(0, V.getEccLib)().isXOnlyPoint(mt))
        throw new TypeError("Invalid pubkey for p2tr");
      const Tt = dt();
      if (Ce.hash && Tt && !Ce.hash.equals(Tt.hash))
        throw new TypeError("Hash mismatch");
      if (Ce.redeem && Ce.redeem.output && Tt) {
        const Nt = (0, W.tapleafHash)({
          output: Ce.redeem.output,
          version: yt.redeemVersion
        });
        if (!(0, W.findScriptPath)(Tt, Nt))
          throw new TypeError("Redeem script not in tree");
      }
      const Pt = ct();
      if (Ce.redeem && yt.redeem) {
        if (Ce.redeem.redeemVersion && Ce.redeem.redeemVersion !== yt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Ce.redeem.output) {
          if (L.decompile(Ce.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (yt.redeem.output && !Ce.redeem.output.equals(yt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Ce.redeem.witness && yt.redeem.witness && !(0, K.stacksEqual)(Ce.redeem.witness, yt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Pt && Pt.length)
        if (Pt.length === 1) {
          if (Ce.signature && !Ce.signature.equals(Pt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Nt = Pt[Pt.length - 1];
          if (Nt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Nt.length}, expected min 33.`
            );
          if ((Nt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Nt.length} is incorrect!`
            );
          const St = (Nt.length - 33) / 32;
          if (St > 128)
            throw new TypeError(
              `The script path is too long. Got ${St}, expected max 128.`
            );
          const vt = Nt.slice(1, 33);
          if (Ce.internalPubkey && !Ce.internalPubkey.equals(vt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, V.getEccLib)().isXOnlyPoint(vt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const It = Nt[0] & K.TAPLEAF_VERSION_MASK, wt = Pt[Pt.length - 2], Oe = (0, W.tapleafHash)({
            output: wt,
            version: It
          }), rt = (0, W.rootHashFromPath)(Nt, Oe), pe = (0, W.tweakKey)(vt, rt);
          if (!pe)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (mt.length && !mt.equals(pe.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (pe.parity !== (Nt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(yt, Ce);
  }
  return p2tr.p2tr = ke, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.p2tr = A.p2wsh = A.p2wpkh = A.p2sh = A.p2pkh = A.p2pk = A.p2ms = A.embed = void 0;
    const B = embed;
    Object.defineProperty(A, "embed", {
      enumerable: !0,
      get: function() {
        return B.p2data;
      }
    });
    const L = p2ms$1;
    Object.defineProperty(A, "p2ms", {
      enumerable: !0,
      get: function() {
        return L.p2ms;
      }
    });
    const K = p2pk$1;
    Object.defineProperty(A, "p2pk", {
      enumerable: !0,
      get: function() {
        return K.p2pk;
      }
    });
    const V = p2pkh$1;
    Object.defineProperty(A, "p2pkh", {
      enumerable: !0,
      get: function() {
        return V.p2pkh;
      }
    });
    const W = p2sh$1;
    Object.defineProperty(A, "p2sh", {
      enumerable: !0,
      get: function() {
        return W.p2sh;
      }
    });
    const J = p2wpkh$1;
    Object.defineProperty(A, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return J.p2wpkh;
      }
    });
    const ne = p2wsh$1;
    Object.defineProperty(A, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ne.p2wsh;
      }
    });
    const ie = requireP2tr();
    Object.defineProperty(A, "p2tr", {
      enumerable: !0,
      get: function() {
        return ie.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const A = networks, B = requirePayments(), L = requireScript(), K = types$4, V = dist, W = bs58check$2, J = 40, ne = 2, ie = 16, ce = 2, re = 80, oe = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function ke(yt, mt) {
    const Tt = yt.slice(2);
    if (Tt.length < ne || Tt.length > J)
      throw new TypeError("Invalid program length for segwit address");
    const Pt = yt[0] - re;
    if (Pt < ce || Pt > ie)
      throw new TypeError("Invalid version for segwit address");
    if (yt[1] !== Tt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(oe), ct(Tt, Pt, mt.bech32);
  }
  function Ce(yt) {
    const mt = Buffer$1.from(W.decode(yt));
    if (mt.length < 21) throw new TypeError(yt + " is too short");
    if (mt.length > 21) throw new TypeError(yt + " is too long");
    const Tt = mt.readUInt8(0), Pt = mt.slice(1);
    return { version: Tt, hash: Pt };
  }
  address.fromBase58Check = Ce;
  function it(yt) {
    let mt, Tt;
    try {
      mt = V.bech32.decode(yt);
    } catch {
    }
    if (mt) {
      if (Tt = mt.words[0], Tt !== 0) throw new TypeError(yt + " uses wrong encoding");
    } else if (mt = V.bech32m.decode(yt), Tt = mt.words[0], Tt === 0) throw new TypeError(yt + " uses wrong encoding");
    const Pt = V.bech32.fromWords(mt.words.slice(1));
    return {
      version: Tt,
      prefix: mt.prefix,
      data: Buffer$1.from(Pt)
    };
  }
  address.fromBech32 = it;
  function at(yt, mt) {
    (0, K.typeforce)(
      (0, K.tuple)(K.Hash160bit, K.UInt8),
      arguments
    );
    const Tt = Buffer$1.allocUnsafe(21);
    return Tt.writeUInt8(mt, 0), yt.copy(Tt, 1), W.encode(Tt);
  }
  address.toBase58Check = at;
  function ct(yt, mt, Tt) {
    const Pt = V.bech32.toWords(yt);
    return Pt.unshift(mt), mt === 0 ? V.bech32.encode(Tt, Pt) : V.bech32m.encode(Tt, Pt);
  }
  address.toBech32 = ct;
  function dt(yt, mt) {
    mt = mt || A.bitcoin;
    try {
      return B.p2pkh({ output: yt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2sh({ output: yt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2wpkh({ output: yt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2wsh({ output: yt, network: mt }).address;
    } catch {
    }
    try {
      return B.p2tr({ output: yt, network: mt }).address;
    } catch {
    }
    try {
      return ke(yt, mt);
    } catch {
    }
    throw new Error(L.toASM(yt) + " has no matching Address");
  }
  address.fromOutputScript = dt;
  function ot(yt, mt) {
    mt = mt || A.bitcoin;
    let Tt, Pt;
    try {
      Tt = Ce(yt);
    } catch {
    }
    if (Tt) {
      if (Tt.version === mt.pubKeyHash)
        return B.p2pkh({ hash: Tt.hash }).output;
      if (Tt.version === mt.scriptHash)
        return B.p2sh({ hash: Tt.hash }).output;
    } else {
      try {
        Pt = it(yt);
      } catch {
      }
      if (Pt) {
        if (Pt.prefix !== mt.bech32)
          throw new Error(yt + " has an invalid prefix");
        if (Pt.version === 0) {
          if (Pt.data.length === 20)
            return B.p2wpkh({ hash: Pt.data }).output;
          if (Pt.data.length === 32)
            return B.p2wsh({ hash: Pt.data }).output;
        } else if (Pt.version === 1) {
          if (Pt.data.length === 32)
            return B.p2tr({ pubkey: Pt.data }).output;
        } else if (Pt.version >= ce && Pt.version <= ie && Pt.data.length >= ne && Pt.data.length <= J)
          return console.warn(oe), L.compile([
            Pt.version + re,
            Pt.data
          ]);
      }
    }
    throw new Error(yt + " has no matching Script");
  }
  return address.toOutputScript = ot, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(A, B) {
  if (!Array.isArray(A)) throw TypeError("Expected values Array");
  if (typeof B != "function")
    throw TypeError("Expected digest Function");
  let L = A.length;
  const K = A.concat();
  for (; L > 1; ) {
    let V = 0;
    for (let W = 0; W < L; W += 2, ++V) {
      const J = K[W], ne = W + 1 === L ? J : K[W + 1], ie = Buffer$1.concat([J, ne]);
      K[V] = B(ie);
    }
    L = V;
  }
  return K[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + B;
}
function vectorSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + A.reduce((L, K) => L + varSliceSize(K), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(A) {
  return A.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(B, L) {
    const K = new bufferutils_1$2.BufferReader(B), V = new Transaction();
    V.version = K.readInt32();
    const W = K.readUInt8(), J = K.readUInt8();
    let ne = !1;
    W === Transaction.ADVANCED_TRANSACTION_MARKER && J === Transaction.ADVANCED_TRANSACTION_FLAG ? ne = !0 : K.offset -= 2;
    const ie = K.readVarInt();
    for (let re = 0; re < ie; ++re)
      V.ins.push({
        hash: K.readSlice(32),
        index: K.readUInt32(),
        script: K.readVarSlice(),
        sequence: K.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const ce = K.readVarInt();
    for (let re = 0; re < ce; ++re)
      V.outs.push({
        value: K.readUInt64(),
        script: K.readVarSlice()
      });
    if (ne) {
      for (let re = 0; re < ie; ++re)
        V.ins[re].witness = K.readVector();
      if (!V.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (V.locktime = K.readUInt32(), L) return V;
    if (K.offset !== B.length)
      throw new Error("Transaction has unexpected data");
    return V;
  }
  static fromHex(B) {
    return Transaction.fromBuffer(Buffer$1.from(B, "hex"), !1);
  }
  static isCoinbaseHash(B) {
    typeforce$1(types$1.Hash256bit, B);
    for (let L = 0; L < 32; ++L)
      if (B[L] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(B, L, K, V) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(K) && (K = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: B,
      index: L,
      script: V || EMPTY_BUFFER,
      sequence: K,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(B, L) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: B,
      value: L
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((B) => B.witness.length !== 0);
  }
  weight() {
    const B = this.byteLength(!1), L = this.byteLength(!0);
    return B * 3 + L;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(B = !0) {
    const L = B && this.hasWitnesses();
    return (L ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((K, V) => K + 40 + varSliceSize(V.script), 0) + this.outs.reduce((K, V) => K + 8 + varSliceSize(V.script), 0) + (L ? this.ins.reduce((K, V) => K + vectorSize(V.witness), 0) : 0);
  }
  clone() {
    const B = new Transaction();
    return B.version = this.version, B.locktime = this.locktime, B.ins = this.ins.map((L) => ({
      hash: L.hash,
      index: L.index,
      script: L.script,
      sequence: L.sequence,
      witness: L.witness
    })), B.outs = this.outs.map((L) => ({
      script: L.script,
      value: L.value
    })), B;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(B, L, K) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), B >= this.ins.length) return ONE;
    const V = bscript$2.compile(
      bscript$2.decompile(L).filter((ne) => ne !== script_1.OPS.OP_CODESEPARATOR)
    ), W = this.clone();
    if ((K & 31) === Transaction.SIGHASH_NONE)
      W.outs = [], W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    else if ((K & 31) === Transaction.SIGHASH_SINGLE) {
      if (B >= this.outs.length) return ONE;
      W.outs.length = B + 1;
      for (let ne = 0; ne < B; ne++)
        W.outs[ne] = BLANK_OUTPUT;
      W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    }
    K & Transaction.SIGHASH_ANYONECANPAY ? (W.ins = [W.ins[B]], W.ins[0].script = V) : (W.ins.forEach((ne) => {
      ne.script = EMPTY_BUFFER;
    }), W.ins[B].script = V);
    const J = Buffer$1.allocUnsafe(W.byteLength(!1) + 4);
    return J.writeInt32LE(K, J.length - 4), W.__toBuffer(J, 0, !1), bcrypto$1.hash256(J);
  }
  hashForWitnessV1(B, L, K, V, W, J) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), K.length !== this.ins.length || L.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ne = V === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : V & Transaction.SIGHASH_OUTPUT_MASK, ce = (V & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, re = ne === Transaction.SIGHASH_NONE, oe = ne === Transaction.SIGHASH_SINGLE;
    let ke = EMPTY_BUFFER, Ce = EMPTY_BUFFER, it = EMPTY_BUFFER, at = EMPTY_BUFFER, ct = EMPTY_BUFFER;
    if (!ce) {
      let mt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Tt) => {
        mt.writeSlice(Tt.hash), mt.writeUInt32(Tt.index);
      }), ke = bcrypto$1.sha256(mt.end()), mt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), K.forEach((Tt) => mt.writeUInt64(Tt)), Ce = bcrypto$1.sha256(mt.end()), mt = bufferutils_1$2.BufferWriter.withCapacity(
        L.map(varSliceSize).reduce((Tt, Pt) => Tt + Pt)
      ), L.forEach(
        (Tt) => mt.writeVarSlice(Tt)
      ), it = bcrypto$1.sha256(mt.end()), mt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Tt) => mt.writeUInt32(Tt.sequence)), at = bcrypto$1.sha256(mt.end());
    }
    if (re || oe) {
      if (oe && B < this.outs.length) {
        const mt = this.outs[B], Tt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(mt.script)
        );
        Tt.writeUInt64(mt.value), Tt.writeVarSlice(mt.script), ct = bcrypto$1.sha256(Tt.end());
      }
    } else {
      const mt = this.outs.map((Pt) => 8 + varSliceSize(Pt.script)).reduce((Pt, Nt) => Pt + Nt), Tt = bufferutils_1$2.BufferWriter.withCapacity(mt);
      this.outs.forEach((Pt) => {
        Tt.writeUInt64(Pt.value), Tt.writeVarSlice(Pt.script);
      }), ct = bcrypto$1.sha256(Tt.end());
    }
    const dt = (W ? 2 : 0) + (J ? 1 : 0), ot = 174 - (ce ? 49 : 0) - (re ? 32 : 0) + (J ? 32 : 0) + (W ? 37 : 0), yt = bufferutils_1$2.BufferWriter.withCapacity(ot);
    if (yt.writeUInt8(V), yt.writeInt32(this.version), yt.writeUInt32(this.locktime), yt.writeSlice(ke), yt.writeSlice(Ce), yt.writeSlice(it), yt.writeSlice(at), re || oe || yt.writeSlice(ct), yt.writeUInt8(dt), ce) {
      const mt = this.ins[B];
      yt.writeSlice(mt.hash), yt.writeUInt32(mt.index), yt.writeUInt64(K[B]), yt.writeVarSlice(L[B]), yt.writeUInt32(mt.sequence);
    } else
      yt.writeUInt32(B);
    if (J) {
      const mt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(J)
      );
      mt.writeVarSlice(J), yt.writeSlice(bcrypto$1.sha256(mt.end()));
    }
    return oe && yt.writeSlice(ct), W && (yt.writeSlice(W), yt.writeUInt8(0), yt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), yt.end()])
    );
  }
  hashForWitnessV0(B, L, K, V) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let W = Buffer$1.from([]), J, ne = ZERO, ie = ZERO, ce = ZERO;
    if (V & Transaction.SIGHASH_ANYONECANPAY || (W = Buffer$1.allocUnsafe(36 * this.ins.length), J = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((oe) => {
      J.writeSlice(oe.hash), J.writeUInt32(oe.index);
    }), ie = bcrypto$1.hash256(W)), !(V & Transaction.SIGHASH_ANYONECANPAY) && (V & 31) !== Transaction.SIGHASH_SINGLE && (V & 31) !== Transaction.SIGHASH_NONE && (W = Buffer$1.allocUnsafe(4 * this.ins.length), J = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((oe) => {
      J.writeUInt32(oe.sequence);
    }), ce = bcrypto$1.hash256(W)), (V & 31) !== Transaction.SIGHASH_SINGLE && (V & 31) !== Transaction.SIGHASH_NONE) {
      const oe = this.outs.reduce((ke, Ce) => ke + 8 + varSliceSize(Ce.script), 0);
      W = Buffer$1.allocUnsafe(oe), J = new bufferutils_1$2.BufferWriter(W, 0), this.outs.forEach((ke) => {
        J.writeUInt64(ke.value), J.writeVarSlice(ke.script);
      }), ne = bcrypto$1.hash256(W);
    } else if ((V & 31) === Transaction.SIGHASH_SINGLE && B < this.outs.length) {
      const oe = this.outs[B];
      W = Buffer$1.allocUnsafe(8 + varSliceSize(oe.script)), J = new bufferutils_1$2.BufferWriter(W, 0), J.writeUInt64(oe.value), J.writeVarSlice(oe.script), ne = bcrypto$1.hash256(W);
    }
    W = Buffer$1.allocUnsafe(156 + varSliceSize(L)), J = new bufferutils_1$2.BufferWriter(W, 0);
    const re = this.ins[B];
    return J.writeInt32(this.version), J.writeSlice(ie), J.writeSlice(ce), J.writeSlice(re.hash), J.writeUInt32(re.index), J.writeVarSlice(L), J.writeUInt64(K), J.writeUInt32(re.sequence), J.writeSlice(ne), J.writeUInt32(this.locktime), J.writeUInt32(V), bcrypto$1.hash256(W);
  }
  getHash(B) {
    return B && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, B));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(B, L) {
    return this.__toBuffer(B, L, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[B].script = L;
  }
  setWitness(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[B].witness = L;
  }
  __toBuffer(B, L, K = !1) {
    B || (B = Buffer$1.allocUnsafe(this.byteLength(K)));
    const V = new bufferutils_1$2.BufferWriter(
      B,
      L || 0
    );
    V.writeInt32(this.version);
    const W = K && this.hasWitnesses();
    return W && (V.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), V.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), V.writeVarInt(this.ins.length), this.ins.forEach((J) => {
      V.writeSlice(J.hash), V.writeUInt32(J.index), V.writeVarSlice(J.script), V.writeUInt32(J.sequence);
    }), V.writeVarInt(this.outs.length), this.outs.forEach((J) => {
      isOutput(J) ? V.writeUInt64(J.value) : V.writeSlice(J.valueBuffer), V.writeVarSlice(J.script);
    }), W && this.ins.forEach((J) => {
      V.writeVector(J.witness);
    }), V.writeUInt32(this.locktime), L !== void 0 ? B.slice(L, V.offset) : B;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(B) {
    if (B.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const L = new bufferutils_1$1.BufferReader(B), K = new Block();
    if (K.version = L.readInt32(), K.prevHash = L.readSlice(32), K.merkleRoot = L.readSlice(32), K.timestamp = L.readUInt32(), K.bits = L.readUInt32(), K.nonce = L.readUInt32(), B.length === 80) return K;
    const V = () => {
      const ne = transaction_1$3.Transaction.fromBuffer(
        L.buffer.slice(L.offset),
        !0
      );
      return L.offset += ne.byteLength(), ne;
    }, W = L.readVarInt();
    K.transactions = [];
    for (let ne = 0; ne < W; ++ne) {
      const ie = V();
      K.transactions.push(ie);
    }
    const J = K.getWitnessCommit();
    return J && (K.witnessCommit = J), K;
  }
  static fromHex(B) {
    return Block.fromBuffer(Buffer$1.from(B, "hex"));
  }
  static calculateTarget(B) {
    const L = ((B & 4278190080) >> 24) - 3, K = B & 8388607, V = Buffer$1.alloc(32, 0);
    return V.writeUIntBE(K, 29 - L, 3), V;
  }
  static calculateMerkleRoot(B, L) {
    if (typeforce([{ getHash: types.Function }], B), B.length === 0) throw errorMerkleNoTxes;
    if (L && !txesHaveWitnessCommit(B))
      throw errorWitnessNotSegwit;
    const K = B.map(
      (W) => W.getHash(L)
    ), V = (0, merkle_1.fastMerkleRoot)(K, bcrypto.hash256);
    return L ? bcrypto.hash256(
      Buffer$1.concat([V, B[0].ins[0].witness[0]])
    ) : V;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const B = this.transactions[0].outs.filter(
      (K) => K.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((K) => K.script.slice(6, 38));
    if (B.length === 0) return null;
    const L = B[B.length - 1];
    return L instanceof Buffer$1 && L.length === 32 ? L : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const B = this.byteLength(!1, !1), L = this.byteLength(!1, !0);
    return B * 3 + L;
  }
  byteLength(B, L = !0) {
    return B || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((K, V) => K + V.byteLength(L), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const B = /* @__PURE__ */ new Date(0);
    return B.setUTCSeconds(this.timestamp), B;
  }
  // TODO: buffer, offset compatibility
  toBuffer(B) {
    const L = Buffer$1.allocUnsafe(this.byteLength(B)), K = new bufferutils_1$1.BufferWriter(L);
    return K.writeInt32(this.version), K.writeSlice(this.prevHash), K.writeSlice(this.merkleRoot), K.writeUInt32(this.timestamp), K.writeUInt32(this.bits), K.writeUInt32(this.nonce), B || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      L,
      K.offset
    ), K.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((V) => {
      const W = V.byteLength();
      V.toBuffer(L, K.offset), K.offset += W;
    })), L;
  }
  toHex(B) {
    return this.toBuffer(B).toString("hex");
  }
  checkTxRoots() {
    const B = this.hasWitnessCommit();
    return !B && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (B ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const B = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), L = Block.calculateTarget(this.bits);
    return B.compare(L) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const B = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(B) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const B = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(B) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(A) {
  return A instanceof Array && A[0] && A[0].ins && A[0].ins instanceof Array && A[0].ins[0] && A[0].ins[0].witness && A[0].ins[0].witness instanceof Array && A[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(A) {
  return A instanceof Array && A.some(
    (B) => typeof B == "object" && B.ins instanceof Array && B.ins.some(
      (L) => typeof L == "object" && L.witness instanceof Array && L.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), function(B) {
    B[B.UNSIGNED_TX = 0] = "UNSIGNED_TX", B[B.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(A.GlobalTypes || (A.GlobalTypes = {})), A.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(B) {
    B[B.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", B[B.WITNESS_UTXO = 1] = "WITNESS_UTXO", B[B.PARTIAL_SIG = 2] = "PARTIAL_SIG", B[B.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", B[B.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", B[B.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", B[B.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", B[B.POR_COMMITMENT = 9] = "POR_COMMITMENT", B[B.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", B[B.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", B[B.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", B[B.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", B[B.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(A.InputTypes || (A.InputTypes = {})), A.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(B) {
    B[B.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", B[B.TAP_TREE = 6] = "TAP_TREE", B[B.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(A.OutputTypes || (A.OutputTypes = {})), A.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (A) => [...Array(A).keys()];
function decode$d(A) {
  if (A.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 79 || ![2, 3].includes(A.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + A.key.toString("hex")
    );
  if (A.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const B = A.key.slice(1), L = {
    masterFingerprint: A.value.slice(0, 4),
    extendedPubkey: B,
    path: "m"
  };
  for (const K of range$2(A.value.length / 4 - 1)) {
    const V = A.value.readUInt32LE(K * 4 + 4), W = !!(V & 2147483648), J = V & 2147483647;
    L.path += "/" + J.toString(10) + (W ? "'" : "");
  }
  return L;
}
globalXpub$1.decode = decode$d;
function encode$e(A) {
  const B = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), L = Buffer$1.concat([B, A.extendedPubkey]), K = A.path.split("/"), V = Buffer$1.allocUnsafe(K.length * 4);
  A.masterFingerprint.copy(V, 0);
  let W = 4;
  return K.slice(1).forEach((J) => {
    const ne = J.slice(-1) === "'";
    let ie = 2147483647 & parseInt(ne ? J.slice(0, -1) : J, 10);
    ne && (ie += 2147483648), V.writeUInt32LE(ie, W), W += 4;
  }), {
    key: L,
    value: V
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(A) {
  const B = A.extendedPubkey, L = A.masterFingerprint, K = A.path;
  return Buffer$1.isBuffer(B) && B.length === 78 && [2, 3].indexOf(B[45]) > -1 && Buffer$1.isBuffer(L) && L.length === 4 && typeof K == "string" && !!K.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(A, B, L) {
  const K = B.extendedPubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((V) => V.extendedPubkey.equals(B.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(A) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: A.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(A) {
  if (A.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(A) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: A
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptSig$1.check = check$b;
function canAdd$8(A, B) {
  return !!A && !!B && A.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(A) {
  if (A.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(A) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: A
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(A, B) {
  return !!A && !!B && A.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(A) {
  if (A.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(A) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: A
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(A) {
  return Buffer$1.isBuffer(A);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(A, B) {
  return !!A && !!B && A.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(A) {
  if (A.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + A.key.toString("hex")
    );
  if (!(A.key.length === 34 || A.key.length === 66) || ![2, 3, 4].includes(A.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + A.key.toString("hex")
    );
  return {
    pubkey: A.key.slice(1),
    signature: A.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(A) {
  const B = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey]),
    value: A.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.signature) && [33, 65].includes(A.pubkey.length) && [2, 3, 4].includes(A.pubkey[0]) && isDerSigWithSighash(A.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(A) {
  if (!Buffer$1.isBuffer(A) || A.length < 9 || A[0] !== 48 || A.length !== A[1] + 3 || A[2] !== 2) return !1;
  const B = A[3];
  if (B > 33 || B < 1 || A[3 + B + 1] !== 2) return !1;
  const L = A[3 + B + 2];
  return !(L > 33 || L < 1 || A.length !== 3 + B + 2 + L + 2);
}
function canAddToArray$2(A, B, L) {
  const K = B.pubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((V) => V.pubkey.equals(B.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(A) {
  if (A.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + A.key.toString("hex")
    );
  return A.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(A) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(A, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(A) {
  return typeof A == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(A, B) {
  return !!A && !!B && A.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(A) {
  if (A.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + A.key.toString("hex")
    );
  return A.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(A) {
  const B = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), L = Buffer$1.allocUnsafe(4);
  return L.writeUInt32LE(A, 0), {
    key: B,
    value: L
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(A) {
  return typeof A == "number";
}
sighashType$1.check = check$6;
function canAdd$4(A, B) {
  return !!A && !!B && A.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(A) {
  if (A.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + A.key.toString("hex")
    );
  if (!check$5(A.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return A.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(A) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: A };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(A) {
  return Buffer$1.isBuffer(A) && (A.length === 64 || A.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(A, B) {
  return !!A && !!B && A.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(A) {
  if (A.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + A.key.toString("hex")
    );
  if ((A.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + A.key.toString("hex")
    );
  const B = A.value[A.value.length - 1];
  if ((A.key[1] & 254) !== B)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + A.key.toString("hex")
    );
  const L = A.value.slice(0, -1);
  return { controlBlock: A.key.slice(1), script: L, leafVersion: B };
}
tapLeafScript$1.decode = decode$5;
function encode$5(A) {
  const B = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), L = Buffer$1.from([A.leafVersion]);
  return {
    key: Buffer$1.concat([B, A.controlBlock]),
    value: Buffer$1.concat([A.script, L])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(A) {
  return Buffer$1.isBuffer(A.controlBlock) && (A.controlBlock.length - 1) % 32 === 0 && (A.controlBlock[0] & 254) === A.leafVersion && Buffer$1.isBuffer(A.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(A, B, L) {
  const K = B.controlBlock.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((V) => V.controlBlock.equals(B.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(A) {
  if (A.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + A.key.toString("hex")
    );
  if (!check$3(A.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return A.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(A) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: A };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(A) {
  return Buffer$1.isBuffer(A) && A.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(A, B) {
  return !!A && !!B && A.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(A) {
  if (A.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + A.key.toString("hex")
    );
  if (A.value.length !== 64 && A.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + A.key.toString("hex")
    );
  const B = A.key.slice(1, 33), L = A.key.slice(33);
  return {
    pubkey: B,
    leafHash: L,
    signature: A.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(A) {
  const B = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey, A.leafHash]),
    value: A.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.leafHash) && Buffer$1.isBuffer(A.signature) && A.pubkey.length === 32 && A.leafHash.length === 32 && (A.signature.length === 64 || A.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(A, B, L) {
  const K = B.pubkey.toString("hex") + B.leafHash.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter(
    (V) => V.pubkey.equals(B.pubkey) && V.leafHash.equals(B.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER || A % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(A, B, L) {
  if (checkUInt53(A), B || (B = Buffer$1.allocUnsafe(encodingLength(A))), !Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), Object.assign(encode$2, { bytes: 1 })) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), Object.assign(encode$2, { bytes: 3 })) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), Object.assign(encode$2, { bytes: 5 })) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), Object.assign(encode$2, { bytes: 9 })), B;
}
varint.encode = encode$2;
function decode$2(A, B) {
  if (!Buffer$1.isBuffer(A))
    throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  const L = A.readUInt8(B);
  if (L < 253)
    return Object.assign(decode$2, { bytes: 1 }), L;
  if (L === 253)
    return Object.assign(decode$2, { bytes: 3 }), A.readUInt16LE(B + 1);
  if (L === 254)
    return Object.assign(decode$2, { bytes: 5 }), A.readUInt32LE(B + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const K = A.readUInt32LE(B + 1), W = A.readUInt32LE(B + 5) * 4294967296 + K;
    return checkUInt53(W), W;
  }
}
varint.decode = decode$2;
function encodingLength(A) {
  return checkUInt53(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (A) => [...Array(A).keys()];
function reverseBuffer(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(A) {
  const B = A.map(keyValToBuffer);
  return B.push(Buffer$1.from([0])), Buffer$1.concat(B);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(A) {
  const B = A.key.length, L = A.value.length, K = varuint$6.encodingLength(B), V = varuint$6.encodingLength(L), W = Buffer$1.allocUnsafe(
    K + B + V + L
  );
  return varuint$6.encode(B, W, 0), A.key.copy(W, K), varuint$6.encode(L, W, K + B), A.value.copy(W, K + B + V), W;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint(K + L, 9007199254740991), K + L;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(A, B, L) {
  return verifuint(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(A) {
  if (A.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + A.key.toString("hex")
    );
  const B = tools_1$2.readUInt64LE(A.value, 0);
  let L = 8;
  const K = varuint$5.decode(A.value, L);
  L += varuint$5.encodingLength(K);
  const V = A.value.slice(L);
  if (V.length !== K)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: V,
    value: B
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(A) {
  const { script: B, value: L } = A, K = varuint$5.encodingLength(B.length), V = Buffer$1.allocUnsafe(8 + K + B.length);
  return tools_1$2.writeUInt64LE(V, L, 0), varuint$5.encode(B.length, V, 8), B.copy(V, 8 + K), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: V
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(A) {
  return Buffer$1.isBuffer(A.script) && typeof A.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(A, B) {
  return !!A && !!B && A.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(A) {
  if (A.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + A.key.toString("hex")
    );
  let B = 0;
  const L = [];
  for (; B < A.value.length; ) {
    const K = A.value[B++], V = A.value[B++], W = varuint$4.decode(A.value, B);
    B += varuint$4.encodingLength(W), L.push({
      depth: K,
      leafVersion: V,
      script: A.value.slice(B, B + W)
    }), B += W;
  }
  return { leaves: L };
}
tapTree$1.decode = decode;
function encode(A) {
  const B = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), L = [].concat(
    ...A.leaves.map((K) => [
      Buffer$1.of(K.depth, K.leafVersion),
      varuint$4.encode(K.script.length),
      K.script
    ])
  );
  return {
    key: B,
    value: Buffer$1.concat(L)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(A) {
  return Array.isArray(A.leaves) && A.leaves.every(
    (B) => B.depth >= 0 && B.depth <= 128 && (B.leafVersion & 254) === B.leafVersion && Buffer$1.isBuffer(B.script)
  );
}
tapTree$1.check = check;
function canAdd(A, B) {
  return !!A && !!B && A.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (A) => [...Array(A).keys()], isValidDERKey = (A) => A.length === 33 && [2, 3].includes(A[0]) || A.length === 65 && A[0] === 4;
function makeConverter$4(A, B = isValidDERKey) {
  function L(ne) {
    if (ne.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ne.key.toString("hex")
      );
    const ie = ne.key.slice(1);
    if (!B(ie))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ne.key.toString("hex")
      );
    if (ne.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const ce = {
      masterFingerprint: ne.value.slice(0, 4),
      pubkey: ie,
      path: "m"
    };
    for (const re of range$1(ne.value.length / 4 - 1)) {
      const oe = ne.value.readUInt32LE(re * 4 + 4), ke = !!(oe & 2147483648), Ce = oe & 2147483647;
      ce.path += "/" + Ce.toString(10) + (ke ? "'" : "");
    }
    return ce;
  }
  function K(ne) {
    const ie = Buffer$1.from([A]), ce = Buffer$1.concat([ie, ne.pubkey]), re = ne.path.split("/"), oe = Buffer$1.allocUnsafe(re.length * 4);
    ne.masterFingerprint.copy(oe, 0);
    let ke = 4;
    return re.slice(1).forEach((Ce) => {
      const it = Ce.slice(-1) === "'";
      let at = 2147483647 & parseInt(it ? Ce.slice(0, -1) : Ce, 10);
      it && (at += 2147483648), oe.writeUInt32LE(at, ke), ke += 4;
    }), {
      key: ce,
      value: oe
    };
  }
  const V = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function W(ne) {
    return Buffer$1.isBuffer(ne.pubkey) && Buffer$1.isBuffer(ne.masterFingerprint) && typeof ne.path == "string" && B(ne.pubkey) && ne.masterFingerprint.length === 4;
  }
  function J(ne, ie, ce) {
    const re = ie.pubkey.toString("hex");
    return ce.has(re) ? !1 : (ce.add(re), ne.filter((oe) => oe.pubkey.equals(ie.pubkey)).length === 0);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: V,
    canAddToArray: J
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(A) {
  return B;
  function B(L) {
    let K;
    if (A.includes(L.key[0]) && (K = L.key.slice(1), !(K.length === 33 || K.length === 65) || ![2, 3, 4].includes(K[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + L.key.toString("hex")
      );
    return K;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(A) {
  function B(J) {
    if (J.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + J.key.toString("hex")
      );
    return J.value;
  }
  function L(J) {
    return {
      key: Buffer$1.from([A]),
      value: J
    };
  }
  const K = "Buffer";
  function V(J) {
    return Buffer$1.isBuffer(J);
  }
  function W(J, ne) {
    return !!J && !!ne && J.redeemScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: V,
    expected: K,
    canAdd: W
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (A) => A.length === 32;
function makeConverter$2(A) {
  const B = bip32Derivation$1.makeConverter(A, isValidBIP340Key);
  function L(J) {
    const ne = varuint$3.decode(J.value), ie = varuint$3.encodingLength(ne), ce = B.decode({
      key: J.key,
      value: J.value.slice(ie + ne * 32)
    }), re = new Array(ne);
    for (let oe = 0, ke = ie; oe < ne; oe++, ke += 32)
      re[oe] = J.value.slice(ke, ke + 32);
    return Object.assign({}, ce, { leafHashes: re });
  }
  function K(J) {
    const ne = B.encode(J), ie = varuint$3.encodingLength(J.leafHashes.length), ce = Buffer$1.allocUnsafe(ie);
    varuint$3.encode(J.leafHashes.length, ce);
    const re = Buffer$1.concat([ce, ...J.leafHashes, ne.value]);
    return Object.assign({}, ne, { value: re });
  }
  const V = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function W(J) {
    return Array.isArray(J.leafHashes) && J.leafHashes.every(
      (ne) => Buffer$1.isBuffer(ne) && ne.length === 32
    ) && B.check(J);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: V,
    canAddToArray: B.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(A) {
  function B(J) {
    if (J.key[0] !== A || J.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + J.key.toString("hex")
      );
    if (J.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return J.value;
  }
  function L(J) {
    return { key: Buffer$1.from([A]), value: J };
  }
  const K = "Buffer";
  function V(J) {
    return Buffer$1.isBuffer(J) && J.length === 32;
  }
  function W(J, ne) {
    return !!J && !!ne && J.tapInternalKey === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: V,
    expected: K,
    canAdd: W
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(A) {
  function B(J) {
    if (J.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + J.key.toString("hex")
      );
    return J.value;
  }
  function L(J) {
    return {
      key: Buffer$1.from([A]),
      value: J
    };
  }
  const K = "Buffer";
  function V(J) {
    return Buffer$1.isBuffer(J);
  }
  function W(J, ne) {
    return !!J && !!ne && J.witnessScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: V,
    expected: K,
    canAdd: W
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(A, B) {
  let L = 0;
  function K() {
    const ct = varuint$2.decode(A, L);
    L += varuint$2.encodingLength(ct);
    const dt = A.slice(L, L + ct);
    return L += ct, dt;
  }
  function V() {
    const ct = A.readUInt32BE(L);
    return L += 4, ct;
  }
  function W() {
    const ct = A.readUInt8(L);
    return L += 1, ct;
  }
  function J() {
    const ct = K(), dt = K();
    return {
      key: ct,
      value: dt
    };
  }
  function ne() {
    if (L >= A.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const ct = A.readUInt8(L) === 0;
    return ct && L++, ct;
  }
  if (V() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (W() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ie = [], ce = {};
  for (; !ne(); ) {
    const ct = J(), dt = ct.key.toString("hex");
    if (ce[dt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + dt
      );
    ce[dt] = 1, ie.push(ct);
  }
  const re = ie.filter(
    (ct) => ct.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (re.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const oe = B(re[0].value), { inputCount: ke, outputCount: Ce } = oe.getInputOutputCounts(), it = [], at = [];
  for (const ct of tools_1$1.range(ke)) {
    const dt = {}, ot = [];
    for (; !ne(); ) {
      const yt = J(), mt = yt.key.toString("hex");
      if (dt[mt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + ct + " key " + mt
        );
      dt[mt] = 1, ot.push(yt);
    }
    it.push(ot);
  }
  for (const ct of tools_1$1.range(Ce)) {
    const dt = {}, ot = [];
    for (; !ne(); ) {
      const yt = J(), mt = yt.key.toString("hex");
      if (dt[mt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + ct + " key " + mt
        );
      dt[mt] = 1, ot.push(yt);
    }
    at.push(ot);
  }
  return psbtFromKeyVals(oe, {
    globalMapKeyVals: ie,
    inputKeyVals: it,
    outputKeyVals: at
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(A, B, L) {
  if (!B.equals(Buffer$1.from([L])))
    throw new Error(
      `Format Error: Invalid ${A} key: ${B.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(A, { globalMapKeyVals: B, inputKeyVals: L, outputKeyVals: K }) {
  const V = {
    unsignedTx: A
  };
  let W = 0;
  for (const re of B)
    switch (re.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          re.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), W > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        W++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        V.globalXpub === void 0 && (V.globalXpub = []), V.globalXpub.push(convert$1.globals.globalXpub.decode(re));
        break;
      default:
        V.unknownKeyVals || (V.unknownKeyVals = []), V.unknownKeyVals.push(re);
    }
  const J = L.length, ne = K.length, ie = [], ce = [];
  for (const re of tools_1$1.range(J)) {
    const oe = {};
    for (const ke of L[re])
      switch (convert$1.inputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), oe.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          oe.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), oe.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          oe.witnessUtxo = convert$1.inputs.witnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          oe.partialSig === void 0 && (oe.partialSig = []), oe.partialSig.push(convert$1.inputs.partialSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), oe.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          oe.sighashType = convert$1.inputs.sighashType.decode(ke);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), oe.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          oe.redeemScript = convert$1.inputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), oe.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          oe.witnessScript = convert$1.inputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          oe.bip32Derivation === void 0 && (oe.bip32Derivation = []), oe.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), oe.finalScriptSig = convert$1.inputs.finalScriptSig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), oe.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            ke
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), oe.porCommitment = convert$1.inputs.porCommitment.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), oe.tapKeySig = convert$1.inputs.tapKeySig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          oe.tapScriptSig === void 0 && (oe.tapScriptSig = []), oe.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          oe.tapLeafScript === void 0 && (oe.tapLeafScript = []), oe.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          oe.tapBip32Derivation === void 0 && (oe.tapBip32Derivation = []), oe.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), oe.tapInternalKey = convert$1.inputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), oe.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(ke);
          break;
        default:
          oe.unknownKeyVals || (oe.unknownKeyVals = []), oe.unknownKeyVals.push(ke);
      }
    ie.push(oe);
  }
  for (const re of tools_1$1.range(ne)) {
    const oe = {};
    for (const ke of K[re])
      switch (convert$1.outputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), oe.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          oe.redeemScript = convert$1.outputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), oe.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          oe.witnessScript = convert$1.outputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          oe.bip32Derivation === void 0 && (oe.bip32Derivation = []), oe.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), oe.tapInternalKey = convert$1.outputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), oe.tapTree = convert$1.outputs.tapTree.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          oe.tapBip32Derivation === void 0 && (oe.tapBip32Derivation = []), oe.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(ke)
          );
          break;
        default:
          oe.unknownKeyVals || (oe.unknownKeyVals = []), oe.unknownKeyVals.push(ke);
      }
    ce.push(oe);
  }
  return { globalMap: V, inputs: ie, outputs: ce };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: A, inputs: B, outputs: L }) {
  const { globalKeyVals: K, inputKeyVals: V, outputKeyVals: W } = psbtToKeyVals({
    globalMap: A,
    inputs: B,
    outputs: L
  }), J = tools_1.keyValsToBuffer(K), ne = (oe) => oe.length === 0 ? [Buffer$1.from([0])] : oe.map(tools_1.keyValsToBuffer), ie = ne(V), ce = ne(W), re = Buffer$1.allocUnsafe(5);
  return re.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [re, J].concat(ie, ce)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (A, B) => A.key.compare(B.key);
function keyValsFromMap(A, B) {
  const L = /* @__PURE__ */ new Set(), K = Object.entries(A).reduce((W, [J, ne]) => {
    if (J === "unknownKeyVals") return W;
    const ie = B[J];
    if (ie === void 0) return W;
    const ce = (Array.isArray(ne) ? ne : [ne]).map(
      ie.encode
    );
    return ce.map((oe) => oe.key.toString("hex")).forEach((oe) => {
      if (L.has(oe))
        throw new Error("Serialize Error: Duplicate key: " + oe);
      L.add(oe);
    }), W.concat(ce);
  }, []), V = A.unknownKeyVals ? A.unknownKeyVals.filter((W) => !L.has(W.key.toString("hex"))) : [];
  return K.concat(V).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: A, inputs: B, outputs: L }) {
  return {
    globalKeyVals: keyValsFromMap(A, convert.globals),
    inputKeyVals: B.map((K) => keyValsFromMap(K, convert.inputs)),
    outputKeyVals: L.map((K) => keyValsFromMap(K, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(A) {
  function B(L) {
    for (var K in L) A.hasOwnProperty(K) || (A[K] = L[K]);
  }
  Object.defineProperty(A, "__esModule", { value: !0 }), B(fromBuffer), B(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(A) {
  const B = A[0], L = parser_1$1.psbtToKeyVals(B), K = A.slice(1);
  if (K.length === 0) throw new Error("Combine: Nothing to combine");
  const V = getTx(B);
  if (V === void 0)
    throw new Error("Combine: Self missing transaction");
  const W = getKeySet(L.globalKeyVals), J = L.inputKeyVals.map(getKeySet), ne = L.outputKeyVals.map(getKeySet);
  for (const ie of K) {
    const ce = getTx(ie);
    if (ce === void 0 || !ce.toBuffer().equals(V.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const re = parser_1$1.psbtToKeyVals(ie);
    getKeySet(re.globalKeyVals).forEach(
      keyPusher(
        W,
        L.globalKeyVals,
        re.globalKeyVals
      )
    ), re.inputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          J[at],
          L.inputKeyVals[at],
          re.inputKeyVals[at]
        )
      )
    ), re.outputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          ne[at],
          L.outputKeyVals[at],
          re.outputKeyVals[at]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(V, {
    globalMapKeyVals: L.globalKeyVals,
    inputKeyVals: L.inputKeyVals,
    outputKeyVals: L.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(A, B, L) {
  return (K) => {
    if (A.has(K)) return;
    const V = L.filter((W) => W.key.toString("hex") === K)[0];
    B.push(V), A.add(K);
  };
}
function getTx(A) {
  return A.globalMap.unsignedTx;
}
function getKeySet(A) {
  const B = /* @__PURE__ */ new Set();
  return A.forEach((L) => {
    const K = L.key.toString("hex");
    if (B.has(K))
      throw new Error("Combine: KeyValue Map keys should be unique");
    B.add(K);
  }), B;
}
var utils = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 });
  const B = converter;
  function L(Ce, it) {
    const at = Ce[it];
    if (at === void 0) throw new Error(`No input #${it}`);
    return at;
  }
  A.checkForInput = L;
  function K(Ce, it) {
    const at = Ce[it];
    if (at === void 0) throw new Error(`No output #${it}`);
    return at;
  }
  A.checkForOutput = K;
  function V(Ce, it, at) {
    if (Ce.key[0] < at)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (it && it.filter((ct) => ct.key.equals(Ce.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Ce.key.toString("hex")}`);
  }
  A.checkHasKey = V;
  function W(Ce) {
    let it = 0;
    return Object.keys(Ce).forEach((at) => {
      Number(isNaN(Number(at))) && it++;
    }), it;
  }
  A.getEnumLength = W;
  function J(Ce, it) {
    let at = !1;
    if (it.nonWitnessUtxo || it.witnessUtxo) {
      const ct = !!it.redeemScript, dt = !!it.witnessScript, ot = !ct || !!it.finalScriptSig, yt = !dt || !!it.finalScriptWitness, mt = !!it.finalScriptSig || !!it.finalScriptWitness;
      at = ot && yt && mt;
    }
    if (at === !1)
      throw new Error(
        `Input #${Ce} has too much or too little data to clean`
      );
  }
  A.inputCheckUncleanFinalized = J;
  function ne(Ce, it, at, ct) {
    throw new Error(
      `Data for ${Ce} key ${it} is incorrect: Expected ${at} and got ${JSON.stringify(ct)}`
    );
  }
  function ie(Ce) {
    return (it, at) => {
      for (const ct of Object.keys(it)) {
        const dt = it[ct], { canAdd: ot, canAddToArray: yt, check: mt, expected: Tt } = (
          // @ts-ignore
          B[Ce + "s"][ct] || {}
        ), Pt = !!yt;
        if (mt)
          if (Pt) {
            if (!Array.isArray(dt) || // @ts-ignore
            at[ct] && !Array.isArray(at[ct]))
              throw new Error(`Key type ${ct} must be an array`);
            dt.every(mt) || ne(Ce, ct, Tt, dt);
            const Nt = at[ct] || [], St = /* @__PURE__ */ new Set();
            if (!dt.every((vt) => yt(Nt, vt, St)))
              throw new Error("Can not add duplicate data to array");
            at[ct] = Nt.concat(dt);
          } else {
            if (mt(dt) || ne(Ce, ct, Tt, dt), !ot(at, dt))
              throw new Error(`Can not add duplicate data to ${Ce}`);
            at[ct] = dt;
          }
      }
    };
  }
  A.updateGlobal = ie("global"), A.updateInput = ie("input"), A.updateOutput = ie("output");
  function ce(Ce, it) {
    const at = Ce.length - 1, ct = L(Ce, at);
    A.updateInput(it, ct);
  }
  A.addInputAttributes = ce;
  function re(Ce, it) {
    const at = Ce.length - 1, ct = K(Ce, at);
    A.updateOutput(it, ct);
  }
  A.addOutputAttributes = re;
  function oe(Ce, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return it.writeUInt32LE(Ce, 0), it;
  }
  A.defaultVersionSetter = oe;
  function ke(Ce, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return it.writeUInt32LE(Ce, it.length - 4), it;
  }
  A.defaultLocktimeSetter = ke;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: B
    };
  }
  static fromBase64(B, L) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L) {
    const K = parser_1.psbtFromBuffer(B, L), V = new this(K.globalMap.unsignedTx);
    return Object.assign(V, K), V;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$1.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.updateInput(L, K), this;
  }
  updateOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.updateOutput(L, K), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$1.checkHasKey(
      B,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (V) => this.addUnknownKeyValToInput(K, V)
    ), utils_1$1.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (V) => this.addUnknownKeyValToOutput(K, V)
    ), utils_1$1.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const L = utils_1$1.checkForInput(this.inputs, B);
    utils_1$1.inputCheckUncleanFinalized(B, L);
    for (const K of Object.keys(L))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(K) || delete L[K];
    return this;
  }
  combine(...B) {
    const L = combiner_1.combine([this].concat(B));
    return Object.assign(this, L), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(A) {
  return (B) => {
    try {
      return A({ output: B }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(A) {
  let B = Buffer$1.allocUnsafe(0);
  function L(J) {
    B = Buffer$1.concat([B, Buffer$1.from(J)]);
  }
  function K(J) {
    const ne = B.length, ie = varuint$1.encodingLength(J);
    B = Buffer$1.concat([B, Buffer$1.allocUnsafe(ie)]), varuint$1.encode(J, B, ne);
  }
  function V(J) {
    K(J.length), L(J);
  }
  function W(J) {
    K(J.length), J.forEach(V);
  }
  return W(A), B;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(A, B) {
  const L = (0, crypto_1.hash160)(A), K = A.slice(1, 33), V = bscript$1.decompile(B);
  if (V === null) throw new Error("Unknown script error");
  return V.findIndex((W) => typeof W == "number" ? !1 : W.equals(A) || W.equals(L) || W.equals(K));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(A, B) {
  return pubkeyPositionInScript(A, B) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(A, B) {
  return extractPartialSigs(A).some(
    (K) => signatureBlocksAction(K, bscript$1.signature.decode, B)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(A, B, L) {
  const { hashType: K } = B(A), V = [];
  switch (K & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && V.push("addInput"), K & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      V.push("addOutput"), V.push("setInputSequence");
      break;
  }
  return V.indexOf(L) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(A) {
  let B = [];
  if ((A.partialSig || []).length === 0) {
    if (!A.finalScriptSig && !A.finalScriptWitness) return [];
    B = getPsigsFromInputFinalScripts(A);
  } else
    B = A.partialSig;
  return B.map((L) => L.signature);
}
function getPsigsFromInputFinalScripts(A) {
  const B = A.finalScriptSig ? bscript$1.decompile(A.finalScriptSig) || [] : [], L = A.finalScriptWitness ? bscript$1.decompile(A.finalScriptWitness) || [] : [];
  return B.concat(L).filter((K) => Buffer$1.isBuffer(K) && bscript$1.isCanonicalScriptSignature(K)).map((K) => ({ signature: K }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (A) => A.length === 32 ? A : A.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(A, B, L) {
  const K = findTapLeafToFinalize(
    B,
    A,
    L
  );
  try {
    const W = sortSignatures(B, K).concat(K.script).concat(K.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(W)
    };
  } catch (V) {
    throw new Error(`Can not finalize taproot input #${A}: ${V}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(A, B) {
  const L = B ? Buffer$1.from([B]) : Buffer$1.from([]);
  return Buffer$1.concat([A, L]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(A) {
  return A && !!(A.tapInternalKey || A.tapMerkleRoot || A.tapLeafScript && A.tapLeafScript.length || A.tapBip32Derivation && A.tapBip32Derivation.length || A.witnessUtxo && (0, psbtutils_1$1.isP2TR)(A.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(A, B) {
  return A && !!(A.tapInternalKey || A.tapTree || A.tapBip32Derivation && A.tapBip32Derivation.length || B && (0, psbtutils_1$1.isP2TR)(B));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootInputFields(A, B, L), checkIfTapLeafInTree(A, B, L);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootOutputFields(A, B, L), checkTaprootScriptPubkey(A, B);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(A, B) {
  if (!B.tapTree && !B.tapInternalKey) return;
  const L = B.tapInternalKey || A.tapInternalKey, K = B.tapTree || A.tapTree;
  if (L) {
    const { script: V } = A, W = getTaprootScripPubkey(L, K);
    if (V && !V.equals(W))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(A, B) {
  const L = B && tapTreeFromList(B.leaves), { output: K } = (0, payments_1.p2tr)({
    internalPubkey: A,
    scriptTree: L
  });
  return K;
}
function tweakInternalPubKey(A, B) {
  const L = B.tapInternalKey, K = L && (0, bip341_1$1.tweakKey)(L, B.tapMerkleRoot);
  if (!K)
    throw new Error(
      `Cannot tweak tap internal key for input #${A}. Public key: ${L && L.toString("hex")}`
    );
  return K.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(A) {
  if (!(0, types_1.isTaptree)(A))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(A);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(A = []) {
  return A.length === 1 && A[0].depth === 0 ? {
    output: A[0].script,
    version: A[0].leafVersion
  } : instertLeavesInTree(A);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(A, B) {
  return extractTaprootSigs(A).some(
    (K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, B)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(A) {
  return {
    signature: A.slice(0, 64),
    hashType: A.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(A) {
  const B = [];
  if (A.tapKeySig && B.push(A.tapKeySig), A.tapScriptSig && B.push(...A.tapScriptSig.map((L) => L.signature)), !B.length) {
    const L = getTapKeySigFromWithness(A.finalScriptWitness);
    L && B.push(L);
  }
  return B;
}
function getTapKeySigFromWithness(A) {
  if (!A) return;
  const B = A.slice(2);
  if (B.length === 64 || B.length === 65) return B;
}
function _tapTreeToList(A, B = [], L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return A ? (0, types_1.isTapleaf)(A) ? (B.push({
    depth: L,
    leafVersion: A.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: A.output
  }), B) : (A[0] && _tapTreeToList(A[0], B, L + 1), A[1] && _tapTreeToList(A[1], B, L + 1), B) : [];
}
function instertLeavesInTree(A) {
  let B;
  for (const L of A)
    if (B = instertLeafInTree(L, B), !B) throw new Error("No room left to insert tapleaf in tree");
  return B;
}
function instertLeafInTree(A, B, L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (A.depth === L)
    return B ? void 0 : {
      output: A.script,
      version: A.leafVersion
    };
  if ((0, types_1.isTapleaf)(B)) return;
  const K = instertLeafInTree(A, B && B[0], L + 1);
  if (K) return [K, B && B[1]];
  const V = instertLeafInTree(A, B && B[1], L + 1);
  if (V) return [B && B[0], V];
}
function checkMixedTaprootAndNonTaprootInputFields(A, B, L) {
  const K = isTaprootInput(A) && hasNonTaprootFields(B), V = hasNonTaprootFields(A) && isTaprootInput(B), W = A === B && isTaprootInput(B) && hasNonTaprootFields(B);
  if (K || V || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(A, B, L) {
  const K = isTaprootOutput(A) && hasNonTaprootFields(B), V = hasNonTaprootFields(A) && isTaprootOutput(B), W = A === B && isTaprootOutput(B) && hasNonTaprootFields(B);
  if (K || V || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(A, B, L) {
  if (B.tapMerkleRoot) {
    const K = (B.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    ), V = (A.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    );
    if (!K || !V)
      throw new Error(
        `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
      );
  } else if (A.tapMerkleRoot && !(B.tapLeafScript || []).every(
    (V) => isTapLeafInTree(V, A.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(A, B) {
  if (!B) return !0;
  const L = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    A.controlBlock,
    L
  ).equals(B);
}
function sortSignatures(A, B) {
  const L = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (A.tapScriptSig || []).filter((K) => K.leafHash.equals(L)).map((K) => addPubkeyPositionInScript(B.script, K)).sort((K, V) => V.positionInScript - K.positionInScript).map((K) => K.signature);
}
function addPubkeyPositionInScript(A, B) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        B.pubkey,
        A
      )
    },
    B
  );
}
function findTapLeafToFinalize(A, B, L) {
  if (!A.tapScriptSig || !A.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${B}. No tapleaf script signature provided.`
    );
  const K = (A.tapLeafScript || []).sort((V, W) => V.controlBlock.length - W.controlBlock.length).find(
    (V) => canFinalizeLeaf(V, A.tapScriptSig, L)
  );
  if (!K)
    throw new Error(
      `Can not finalize taproot input #${B}. Signature for tapleaf script not found.`
    );
  return K;
}
function canFinalizeLeaf(A, B, L) {
  const K = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (!L || L.equals(K)) && B.find((W) => W.leafHash.equals(K)) !== void 0;
}
function hasNonTaprootFields(A) {
  return A && !!(A.redeemScript || A.witnessScript || A.bip32Derivation && A.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(B, L = {}) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L = {}) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L = {}) {
    const K = bip174_1.Psbt.fromBuffer(B, transactionFromBuffer), V = new Psbt(L, K);
    return checkTxForDupeIns(V.__CACHE.__TX, V.__CACHE), V;
  }
  constructor(B = {}, L = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = L, this.opts = Object.assign({}, DEFAULT_OPTS, B), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const K = (V, W, J, ne) => Object.defineProperty(V, W, {
      enumerable: J,
      writable: ne
    });
    K(this, "__CACHE", !1, !0), K(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(B) {
    this.setVersion(B);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(B) {
    this.setLocktime(B);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((B) => ({
      hash: (0, bufferutils_1.cloneBuffer)(B.hash),
      index: B.index,
      sequence: B.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((B) => {
      let L;
      try {
        L = (0, address_1.fromOutputScript)(
          B.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(B.script),
        value: B.value,
        address: L
      };
    });
  }
  combine(...B) {
    return this.data.combine(...B.map((L) => L.data)), this;
  }
  clone() {
    const B = Psbt.fromBuffer(this.data.toBuffer());
    return B.opts = JSON.parse(JSON.stringify(this.opts)), B;
  }
  setMaximumFeeRate(B) {
    check32Bit(B), this.opts.maximumFeeRate = B;
  }
  setVersion(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const L = this.__CACHE;
    return L.__TX.version = B, L.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const L = this.__CACHE;
    return L.__TX.locktime = B, L.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(B, L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const K = this.__CACHE;
    if (K.__TX.ins.length <= B)
      throw new Error("Input index too high");
    return K.__TX.ins[B].sequence = L, K.__EXTRACTED_TX = void 0, this;
  }
  addInputs(B) {
    return B.forEach((L) => this.addInput(L)), this;
  }
  addInput(B) {
    if (arguments.length > 1 || !B || B.hash === void 0 || B.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(B, B, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), B.witnessScript && checkInvalidP2WSH(B.witnessScript);
    const L = this.__CACHE;
    this.data.addInput(B);
    const K = L.__TX.ins[L.__TX.ins.length - 1];
    checkTxInputCache(L, K);
    const V = this.data.inputs.length - 1, W = this.data.inputs[V];
    return W.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, W, V), L.__FEE = void 0, L.__FEE_RATE = void 0, L.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(B) {
    return B.forEach((L) => this.addOutput(L)), this;
  }
  addOutput(B) {
    if (arguments.length > 1 || !B || B.value === void 0 || B.address === void 0 && B.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: L } = B;
    if (typeof L == "string") {
      const { network: V } = this.opts, W = (0, address_1.toOutputScript)(L, V);
      B = Object.assign({}, B, { script: W });
    }
    (0, bip371_1.checkTaprootOutputFields)(B, B, "addOutput");
    const K = this.__CACHE;
    return this.data.addOutput(B), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(B) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const L = this.__CACHE;
    if (B || checkFees(this, L, this.opts), L.__EXTRACTED_TX) return L.__EXTRACTED_TX;
    const K = L.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, K, L, !0), K;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((B) => this.finalizeInput(B)), this;
  }
  finalizeInput(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(K) ? this._finalizeTaprootInput(
      B,
      K,
      void 0,
      L
    ) : this._finalizeInput(B, K, L);
  }
  finalizeTaprootInput(B, L, K = bip371_1.tapScriptFinalizer) {
    const V = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(V))
      return this._finalizeTaprootInput(
        B,
        V,
        L,
        K
      );
    throw new Error(`Cannot finalize input #${B}. Not Taproot.`);
  }
  _finalizeInput(B, L, K = getFinalScripts) {
    const { script: V, isP2SH: W, isP2WSH: J, isSegwit: ne } = getScriptFromInput(
      B,
      L,
      this.__CACHE
    );
    if (!V) throw new Error(`No script found for input #${B}`);
    checkPartialSigSighashes(L);
    const { finalScriptSig: ie, finalScriptWitness: ce } = K(
      B,
      L,
      V,
      ne,
      W,
      J
    );
    if (ie && this.data.updateInput(B, { finalScriptSig: ie }), ce && this.data.updateInput(B, { finalScriptWitness: ce }), !ie && !ce)
      throw new Error(`Unknown error finalizing input #${B}`);
    return this.data.clearFinalizedInput(B), this;
  }
  _finalizeTaprootInput(B, L, K, V = bip371_1.tapScriptFinalizer) {
    if (!L.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${B}. Missing withness utxo.`
      );
    if (L.tapKeySig) {
      const W = payments.p2tr({
        output: L.witnessUtxo.script,
        signature: L.tapKeySig
      }), J = (0, psbtutils_1.witnessStackToScriptWitness)(
        W.witness
      );
      this.data.updateInput(B, { finalScriptWitness: J });
    } else {
      const { finalScriptWitness: W } = V(
        B,
        L,
        K
      );
      this.data.updateInput(B, { finalScriptWitness: W });
    }
    return this.data.clearFinalizedInput(B), this;
  }
  getInputType(B) {
    const L = (0, utils_1.checkForInput)(this.data.inputs, B), K = getScriptFromUtxo(B, L, this.__CACHE), V = getMeaningfulScript(
      K,
      B,
      "input",
      L.redeemScript || redeemFromFinalScriptSig(L.finalScriptSig),
      L.witnessScript || redeemFromFinalWitnessScript(L.finalScriptWitness)
    ), W = V.type === "raw" ? "" : V.type + "-", J = classifyScript(V.meaningfulScript);
    return W + J;
  }
  inputHasPubkey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return pubkeyInInput(L, K, B, this.__CACHE);
  }
  inputHasHDKey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B), V = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(V);
  }
  outputHasPubkey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B);
    return pubkeyInOutput(L, K, B, this.__CACHE);
  }
  outputHasHDKey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B), V = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(V);
  }
  validateSignaturesOfAllInputs(B) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (K) => this.validateSignaturesOfInput(K, B)
    ).reduce((K, V) => V === !0 && K, !0);
  }
  validateSignaturesOfInput(B, L, K) {
    const V = this.data.inputs[B];
    return (0, bip371_1.isTaprootInput)(V) ? this.validateSignaturesOfTaprootInput(
      B,
      L,
      K
    ) : this._validateSignaturesOfInput(B, L, K);
  }
  _validateSignaturesOfInput(B, L, K) {
    const V = this.data.inputs[B], W = (V || {}).partialSig;
    if (!V || !W || W.length < 1)
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    const J = K ? W.filter((oe) => oe.pubkey.equals(K)) : W;
    if (J.length < 1) throw new Error("No signatures for this pubkey");
    const ne = [];
    let ie, ce, re;
    for (const oe of J) {
      const ke = bscript.signature.decode(oe.signature), { hash: Ce, script: it } = re !== ke.hashType ? getHashForSig(
        B,
        Object.assign({}, V, { sighashType: ke.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ie, script: ce };
      re = ke.hashType, ie = Ce, ce = it, checkScriptForPubkey(oe.pubkey, it, "verify"), ne.push(L(oe.pubkey, Ce, ke.signature));
    }
    return ne.every((oe) => oe === !0);
  }
  validateSignaturesOfTaprootInput(B, L, K) {
    const V = this.data.inputs[B], W = (V || {}).tapKeySig, J = (V || {}).tapScriptSig;
    if (!V && !W && !(J && !J.length))
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    K = K && (0, bip371_1.toXOnly)(K);
    const ne = K ? getTaprootHashesForSig(
      B,
      V,
      this.data.inputs,
      K,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      B,
      V,
      this.data.inputs,
      this.__CACHE
    );
    if (!ne.length) throw new Error("No signatures for this pubkey");
    const ie = ne.find((re) => !re.leafHash);
    let ce = 0;
    if (W && ie) {
      if (!L(
        ie.pubkey,
        ie.hash,
        trimTaprootSig(W)
      )) return !1;
      ce++;
    }
    if (J)
      for (const re of J) {
        const oe = ne.find((ke) => re.pubkey.equals(ke.pubkey));
        if (oe) {
          if (!L(
            re.pubkey,
            oe.hash,
            trimTaprootSig(re.signature)
          )) return !1;
          ce++;
        }
      }
    return ce > 0;
  }
  signAllInputsHD(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!B || !B.publicKey || !B.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const K = [];
    for (const V of range(this.data.inputs.length))
      try {
        this.signInputHD(V, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((V) => V === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((K, V) => {
      if (!B || !B.publicKey || !B.fingerprint)
        return V(new Error("Need HDSigner to sign input"));
      const W = [], J = [];
      for (const ne of range(this.data.inputs.length))
        J.push(
          this.signInputHDAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(J).then(() => {
        if (W.every((ne) => ne === !1))
          return V(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInputHD(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(B, this.data.inputs, L).forEach((W) => this.signInput(B, W, K)), this;
  }
  signInputHDAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((V, W) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return W(new Error("Need HDSigner to sign input"));
      const ne = getSignersFromHD(B, this.data.inputs, L).map(
        (ie) => this.signInputAsync(B, ie, K)
      );
      return Promise.all(ne).then(() => {
        V();
      }).catch(W);
    });
  }
  signAllInputs(B, L) {
    if (!B || !B.publicKey)
      throw new Error("Need Signer to sign input");
    const K = [];
    for (const V of range(this.data.inputs.length))
      try {
        this.signInput(V, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((V) => V === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(B, L) {
    return new Promise((K, V) => {
      if (!B || !B.publicKey)
        return V(new Error("Need Signer to sign input"));
      const W = [], J = [];
      for (const [ne] of this.data.inputs.entries())
        J.push(
          this.signInputAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(J).then(() => {
        if (W.every((ne) => ne === !1))
          return V(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInput(B, L, K) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const V = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(V) ? this._signTaprootInput(
      B,
      V,
      L,
      void 0,
      K
    ) : this._signInput(B, L, K);
  }
  signTaprootInput(B, L, K, V) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const W = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(W))
      return this._signTaprootInput(
        B,
        W,
        L,
        K,
        V
      );
    throw new Error(`Input #${B} is not of type Taproot.`);
  }
  _signInput(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: V, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    ), J = [
      {
        pubkey: L.publicKey,
        signature: bscript.signature.encode(L.sign(V), W)
      }
    ];
    return this.data.updateInput(B, { partialSig: J }), this;
  }
  _signTaprootInput(B, L, K, V, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const J = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      V,
      W
    ), ne = J.filter((ce) => !ce.leafHash).map(
      (ce) => (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(ce.hash),
        L.sighashType
      )
    )[0], ie = J.filter((ce) => !!ce.leafHash).map((ce) => ({
      pubkey: (0, bip371_1.toXOnly)(K.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(ce.hash),
        L.sighashType
      ),
      leafHash: ce.leafHash
    }));
    return ne && this.data.updateInput(B, { tapKeySig: ne }), ie.length && this.data.updateInput(B, { tapScriptSig: ie }), this;
  }
  signInputAsync(B, L, K) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const V = (0, utils_1.checkForInput)(this.data.inputs, B);
      return (0, bip371_1.isTaprootInput)(V) ? this._signTaprootInputAsync(
        B,
        V,
        L,
        void 0,
        K
      ) : this._signInputAsync(B, L, K);
    });
  }
  signTaprootInputAsync(B, L, K, V) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const W = (0, utils_1.checkForInput)(this.data.inputs, B);
      if ((0, bip371_1.isTaprootInput)(W))
        return this._signTaprootInputAsync(
          B,
          W,
          L,
          K,
          V
        );
      throw new Error(`Input #${B} is not of type Taproot.`);
    });
  }
  _signInputAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: V, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    );
    return Promise.resolve(L.sign(V)).then((J) => {
      const ne = [
        {
          pubkey: L.publicKey,
          signature: bscript.signature.encode(J, W)
        }
      ];
      this.data.updateInput(B, { partialSig: ne });
    });
  }
  async _signTaprootInputAsync(B, L, K, V, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const J = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      V,
      W
    ), ne = [], ie = J.filter((re) => !re.leafHash)[0];
    if (ie) {
      const re = Promise.resolve(
        K.signSchnorr(ie.hash)
      ).then((oe) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          oe,
          L.sighashType
        )
      }));
      ne.push(re);
    }
    const ce = J.filter((re) => !!re.leafHash);
    if (ce.length) {
      const re = ce.map((oe) => Promise.resolve(K.signSchnorr(oe.hash)).then(
        (ke) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(K.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              ke,
              L.sighashType
            ),
            leafHash: oe.leafHash
          }
        ] })
      ));
      ne.push(...re);
    }
    return Promise.all(ne).then((re) => {
      re.forEach((oe) => this.data.updateInput(B, oe));
    });
  }
  checkTaprootHashesForSig(B, L, K, V, W) {
    if (typeof K.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${B}.`
      );
    const J = getTaprootHashesForSig(
      B,
      L,
      this.data.inputs,
      K.publicKey,
      this.__CACHE,
      V,
      W
    );
    if (!J || !J.length)
      throw new Error(
        `Can not sign for input #${B} with the key ${K.publicKey.toString(
          "hex"
        )}`
      );
    return J;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(B) {
    return this.data.updateGlobal(B), this;
  }
  updateInput(B, L) {
    return L.witnessScript && checkInvalidP2WSH(L.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[B],
      L,
      "updateInput"
    ), this.data.updateInput(B, L), L.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[B],
      B
    ), this;
  }
  updateOutput(B, L) {
    const K = this.data.outputs[B];
    return (0, bip371_1.checkTaprootOutputFields)(
      K,
      L,
      "updateOutput"
    ), this.data.updateOutput(B, L), this;
  }
  addUnknownKeyValToGlobal(B) {
    return this.data.addUnknownKeyValToGlobal(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    return this.data.addUnknownKeyValToInput(B, L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    return this.data.addUnknownKeyValToOutput(B, L), this;
  }
  clearFinalizedInput(B) {
    return this.data.clearFinalizedInput(B), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (A) => new PsbtTransaction(A);
class PsbtTransaction {
  constructor(B = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(B), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(B) {
    if (B.hash === void 0 || B.index === void 0 || !Buffer$1.isBuffer(B.hash) && typeof B.hash != "string" || typeof B.index != "number")
      throw new Error("Error adding input.");
    const L = typeof B.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash, "hex")) : B.hash;
    this.tx.addInput(L, B.index, B.sequence);
  }
  addOutput(B) {
    if (B.script === void 0 || B.value === void 0 || !Buffer$1.isBuffer(B.script) || typeof B.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(B.script, B.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(A, B, L) {
  switch (L) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, A.partialSig);
    case "multisig":
      const K = payments.p2ms({ output: B });
      return hasSigs(K.m, A.partialSig, K.pubkeys);
    default:
      return !1;
  }
}
function checkCache(A) {
  if (A.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(A, B, L) {
  if (!B) return !1;
  let K;
  if (L ? K = L.map((V) => {
    const W = compressPubkey(V);
    return B.find((J) => J.pubkey.equals(W));
  }).filter((V) => !!V) : K = B, K.length > A) throw new Error("Too many signatures");
  return K.length === A;
}
function isFinalized(A) {
  return !!A.finalScriptSig || !!A.finalScriptWitness;
}
function bip32DerivationIsMine(A) {
  return (B) => !(!B.masterFingerprint.equals(A.fingerprint) || !A.derivePath(B.path).publicKey.equals(B.pubkey));
}
function check32Bit(A) {
  if (typeof A != "number" || A !== Math.floor(A) || A > 4294967295 || A < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(A, B, L) {
  const K = B.__FEE_RATE || A.getFeeRate(), V = B.__EXTRACTED_TX.virtualSize(), W = K * V;
  if (K >= L.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(W / 1e8).toFixed(8)} in fees, which is ${K} satoshi per byte for a transaction with a VSize of ${V} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(A, B) {
  A.forEach((L) => {
    if ((0, bip371_1.isTaprootInput)(L) ? (0, bip371_1.checkTaprootInputForSigs)(L, B) : (0, psbtutils_1.checkInputForSig)(L, B))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(A) {
  if (!A.sighashType || !A.partialSig) return;
  const { partialSig: B, sighashType: L } = A;
  B.forEach((K) => {
    const { hashType: V } = bscript.signature.decode(K.signature);
    if (L !== V)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(A, B, L) {
  if (!(0, psbtutils_1.pubkeyInScript)(A, B))
    throw new Error(
      `Can not ${L} for this input with the key ${A.toString("hex")}`
    );
}
function checkTxEmpty(A) {
  if (!A.ins.every(
    (L) => L.script && L.script.length === 0 && L.witness && L.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(A, B) {
  A.ins.forEach((L) => {
    checkTxInputCache(B, L);
  });
}
function checkTxInputCache(A, B) {
  const L = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash)).toString("hex") + ":" + B.index;
  if (A.__TX_IN_CACHE[L]) throw new Error("Duplicate input detected.");
  A.__TX_IN_CACHE[L] = 1;
}
function scriptCheckerFactory(A, B) {
  return (L, K, V, W) => {
    const J = A({
      redeem: { output: V }
    }).output;
    if (!K.equals(J))
      throw new Error(
        `${B} for ${W} #${L} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(A, B, L, K) {
  if (!L.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${B}`);
  if (A === "__FEE_RATE" && K.__FEE_RATE) return K.__FEE_RATE;
  if (A === "__FEE" && K.__FEE) return K.__FEE;
  let V, W = !0;
  if (K.__EXTRACTED_TX ? (V = K.__EXTRACTED_TX, W = !1) : V = K.__TX.clone(), inputFinalizeGetAmts(L, V, K, W), A === "__FEE_RATE") return K.__FEE_RATE;
  if (A === "__FEE") return K.__FEE;
}
function getFinalScripts(A, B, L, K, V, W) {
  const J = classifyScript(L);
  if (!canFinalize(B, L, J))
    throw new Error(`Can not finalize input #${A}`);
  return prepareFinalScripts(
    L,
    J,
    B.partialSig,
    K,
    V,
    W
  );
}
function prepareFinalScripts(A, B, L, K, V, W) {
  let J, ne;
  const ie = getPayment(A, B, L), ce = W ? payments.p2wsh({ redeem: ie }) : null, re = V ? payments.p2sh({ redeem: ce || ie }) : null;
  return K ? (ce ? ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    ce.witness
  ) : ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    ie.witness
  ), re && (J = re.input)) : re ? J = re.input : J = ie.input, {
    finalScriptSig: J,
    finalScriptWitness: ne
  };
}
function getHashAndSighashType(A, B, L, K, V) {
  const W = (0, utils_1.checkForInput)(A, B), { hash: J, sighashType: ne, script: ie } = getHashForSig(
    B,
    W,
    K,
    !1,
    V
  );
  return checkScriptForPubkey(L, ie, "sign"), {
    hash: J,
    sighashType: ne
  };
}
function getHashForSig(A, B, L, K, V) {
  const W = L.__TX, J = B.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(J, V);
  let ne, ie;
  if (B.nonWitnessUtxo) {
    const oe = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), ke = W.ins[A].hash, Ce = oe.getHash();
    if (!ke.equals(Ce))
      throw new Error(
        `Non-witness UTXO hash for input #${A} doesn't match the hash specified in the prevout`
      );
    const it = W.ins[A].index;
    ie = oe.outs[it];
  } else if (B.witnessUtxo)
    ie = B.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: ce, type: re } = getMeaningfulScript(
    ie.script,
    A,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(re) >= 0)
    ne = W.hashForWitnessV0(
      A,
      ce,
      ie.value,
      J
    );
  else if ((0, psbtutils_1.isP2WPKH)(ce)) {
    const oe = payments.p2pkh({
      hash: ce.slice(2)
    }).output;
    ne = W.hashForWitnessV0(
      A,
      oe,
      ie.value,
      J
    );
  } else {
    if (B.nonWitnessUtxo === void 0 && L.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${A} has witnessUtxo but non-segwit script: ${ce.toString("hex")}`
      );
    !K && L.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ne = W.hashForSignature(
      A,
      ce,
      J
    );
  }
  return {
    script: ce,
    sighashType: J,
    hash: ne
  };
}
function getAllTaprootHashesForSig(A, B, L, K) {
  const V = [];
  if (B.tapInternalKey) {
    const J = getPrevoutTaprootKey(A, B, K);
    J && V.push(J);
  }
  if (B.tapScriptSig) {
    const J = B.tapScriptSig.map((ne) => ne.pubkey);
    V.push(...J);
  }
  return V.map(
    (J) => getTaprootHashesForSig(A, B, L, J, K)
  ).flat();
}
function getPrevoutTaprootKey(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return (0, psbtutils_1.isP2TR)(K) ? K.subarray(2, 34) : null;
}
function trimTaprootSig(A) {
  return A.length === 64 ? A : A.subarray(0, 64);
}
function getTaprootHashesForSig(A, B, L, K, V, W, J) {
  const ne = V.__TX, ie = B.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ie, J);
  const ce = L.map(
    (it, at) => getScriptAndAmountFromUtxo(at, it, V)
  ), re = ce.map((it) => it.script), oe = ce.map((it) => it.value), ke = [];
  if (B.tapInternalKey && !W) {
    const it = getPrevoutTaprootKey(A, B, V) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(K).equals(it)) {
      const at = ne.hashForWitnessV1(
        A,
        re,
        oe,
        ie
      );
      ke.push({ pubkey: K, hash: at });
    }
  }
  const Ce = (B.tapLeafScript || []).filter((it) => (0, psbtutils_1.pubkeyInScript)(K, it.script)).map((it) => {
    const at = (0, bip341_1.tapleafHash)({
      output: it.script,
      version: it.leafVersion
    });
    return Object.assign({ hash: at }, it);
  }).filter(
    (it) => !W || W.equals(it.hash)
  ).map((it) => {
    const at = ne.hashForWitnessV1(
      A,
      re,
      oe,
      ie,
      it.hash
    );
    return {
      pubkey: K,
      hash: at,
      leafHash: it.hash
    };
  });
  return ke.concat(Ce);
}
function checkSighashTypeAllowed(A, B) {
  if (B && B.indexOf(A) < 0) {
    const L = sighashTypeToString(A);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${L}`
    );
  }
}
function getPayment(A, B, L) {
  let K;
  switch (B) {
    case "multisig":
      const V = getSortedSigs(A, L);
      K = payments.p2ms({
        output: A,
        signatures: V
      });
      break;
    case "pubkey":
      K = payments.p2pk({
        output: A,
        signature: L[0].signature
      });
      break;
    case "pubkeyhash":
      K = payments.p2pkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
    case "witnesspubkeyhash":
      K = payments.p2wpkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
  }
  return K;
}
function getScriptFromInput(A, B, L) {
  const K = L.__TX, V = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (V.isP2SH = !!B.redeemScript, V.isP2WSH = !!B.witnessScript, B.witnessScript)
    V.script = B.witnessScript;
  else if (B.redeemScript)
    V.script = B.redeemScript;
  else if (B.nonWitnessUtxo) {
    const W = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), J = K.ins[A].index;
    V.script = W.outs[J].script;
  } else B.witnessUtxo && (V.script = B.witnessUtxo.script);
  return (B.witnessScript || (0, psbtutils_1.isP2WPKH)(V.script)) && (V.isSegwit = !0), V;
}
function getSignersFromHD(A, B, L) {
  const K = (0, utils_1.checkForInput)(B, A);
  if (!K.bip32Derivation || K.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const V = K.bip32Derivation.map((J) => {
    if (J.masterFingerprint.equals(L.fingerprint))
      return J;
  }).filter((J) => !!J);
  if (V.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return V.map((J) => {
    const ne = L.derivePath(J.path);
    if (!J.pubkey.equals(ne.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ne;
  });
}
function getSortedSigs(A, B) {
  return payments.p2ms({ output: A }).pubkeys.map((K) => (B.filter((V) => V.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(A) {
  let B = 0;
  function L(J) {
    return B += J, A.slice(B - J, B);
  }
  function K() {
    const J = varuint.decode(A, B);
    return B += varuint.decode.bytes, J;
  }
  function V() {
    return L(K());
  }
  function W() {
    const J = K(), ne = [];
    for (let ie = 0; ie < J; ie++) ne.push(V());
    return ne;
  }
  return W();
}
function sighashTypeToString(A) {
  let B = A & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (A & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      B += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      B += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      B += "SIGHASH_NONE";
      break;
  }
  return B;
}
function addNonWitnessTxCache(A, B, L) {
  A.__NON_WITNESS_UTXO_BUF_CACHE[L] = B.nonWitnessUtxo;
  const K = transaction_1.Transaction.fromBuffer(B.nonWitnessUtxo);
  A.__NON_WITNESS_UTXO_TX_CACHE[L] = K;
  const V = A, W = L;
  delete B.nonWitnessUtxo, Object.defineProperty(B, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const J = V.__NON_WITNESS_UTXO_BUF_CACHE[W], ne = V.__NON_WITNESS_UTXO_TX_CACHE[W];
      if (J !== void 0)
        return J;
      {
        const ie = ne.toBuffer();
        return V.__NON_WITNESS_UTXO_BUF_CACHE[W] = ie, ie;
      }
    },
    set(J) {
      V.__NON_WITNESS_UTXO_BUF_CACHE[W] = J;
    }
  });
}
function inputFinalizeGetAmts(A, B, L, K) {
  let V = 0;
  A.forEach((ie, ce) => {
    if (K && ie.finalScriptSig && (B.ins[ce].script = ie.finalScriptSig), K && ie.finalScriptWitness && (B.ins[ce].witness = scriptWitnessToWitnessStack(
      ie.finalScriptWitness
    )), ie.witnessUtxo)
      V += ie.witnessUtxo.value;
    else if (ie.nonWitnessUtxo) {
      const re = nonWitnessUtxoTxFromCache(L, ie, ce), oe = B.ins[ce].index, ke = re.outs[oe];
      V += ke.value;
    }
  });
  const W = B.outs.reduce((ie, ce) => ie + ce.value, 0), J = V - W;
  if (J < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ne = B.virtualSize();
  L.__FEE = J, L.__EXTRACTED_TX = B, L.__FEE_RATE = Math.floor(J / ne);
}
function nonWitnessUtxoTxFromCache(A, B, L) {
  const K = A.__NON_WITNESS_UTXO_TX_CACHE;
  return K[L] || addNonWitnessTxCache(A, B, L), K[L];
}
function getScriptFromUtxo(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return K;
}
function getScriptAndAmountFromUtxo(A, B, L) {
  if (B.witnessUtxo !== void 0)
    return {
      script: B.witnessUtxo.script,
      value: B.witnessUtxo.value
    };
  if (B.nonWitnessUtxo !== void 0) {
    const V = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ).outs[L.__TX.ins[A].index];
    return { script: V.script, value: V.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(A, B, L, K) {
  const V = getScriptFromUtxo(L, B, K), { meaningfulScript: W } = getMeaningfulScript(
    V,
    L,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function pubkeyInOutput(A, B, L, K) {
  const V = K.__TX.outs[L].script, { meaningfulScript: W } = getMeaningfulScript(
    V,
    L,
    "output",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function redeemFromFinalScriptSig(A) {
  if (!A) return;
  const B = bscript.decompile(A);
  if (!B) return;
  const L = B[B.length - 1];
  if (!(!Buffer$1.isBuffer(L) || isPubkeyLike(L) || isSigLike(L) || !bscript.decompile(L)))
    return L;
}
function redeemFromFinalWitnessScript(A) {
  if (!A) return;
  const B = scriptWitnessToWitnessStack(A), L = B[B.length - 1];
  if (!(isPubkeyLike(L) || !bscript.decompile(L)))
    return L;
}
function compressPubkey(A) {
  if (A.length === 65) {
    const B = A[64] & 1, L = A.slice(0, 33);
    return L[0] = 2 | B, L;
  }
  return A.slice();
}
function isPubkeyLike(A) {
  return A.length === 33 && bscript.isCanonicalPubKey(A);
}
function isSigLike(A) {
  return bscript.isCanonicalScriptSignature(A);
}
function getMeaningfulScript(A, B, L, K, V) {
  const W = (0, psbtutils_1.isP2SHScript)(A), J = W && K && (0, psbtutils_1.isP2WSHScript)(K), ne = (0, psbtutils_1.isP2WSHScript)(A);
  if (W && K === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ne || J) && V === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ie;
  return J ? (ie = V, checkRedeemScript(B, A, K, L), checkWitnessScript(B, K, V, L), checkInvalidP2WSH(ie)) : ne ? (ie = V, checkWitnessScript(B, A, V, L), checkInvalidP2WSH(ie)) : W ? (ie = K, checkRedeemScript(B, A, K, L)) : ie = A, {
    meaningfulScript: ie,
    type: J ? "p2sh-p2wsh" : W ? "p2sh" : ne ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(A) {
  if ((0, psbtutils_1.isP2WPKH)(A) || (0, psbtutils_1.isP2SHScript)(A))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(A) {
  return (0, psbtutils_1.isP2WPKH)(A) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(A) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(A) ? "multisig" : (0, psbtutils_1.isP2PK)(A) ? "pubkey" : "nonstandard";
}
function range(A) {
  return [...Array(A).keys()];
}
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.initEccLib = A.Transaction = A.opcodes = A.Psbt = A.Block = A.script = A.payments = A.networks = A.crypto = A.address = void 0;
  const B = requireAddress();
  A.address = B;
  const L = crypto$1;
  A.crypto = L;
  const K = networks;
  A.networks = K;
  const V = requirePayments();
  A.payments = V;
  const W = requireScript();
  A.script = W;
  var J = block;
  Object.defineProperty(A, "Block", {
    enumerable: !0,
    get: function() {
      return J.Block;
    }
  });
  var ne = psbt$1;
  Object.defineProperty(A, "Psbt", {
    enumerable: !0,
    get: function() {
      return ne.Psbt;
    }
  });
  var ie = ops;
  Object.defineProperty(A, "opcodes", {
    enumerable: !0,
    get: function() {
      return ie.OPS;
    }
  });
  var ce = transaction;
  Object.defineProperty(A, "Transaction", {
    enumerable: !0,
    get: function() {
      return ce.Transaction;
    }
  });
  var re = ecc_lib;
  Object.defineProperty(A, "initEccLib", {
    enumerable: !0,
    get: function() {
      return re.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: A, publicKey: B, format: L, wallet: K } = useOrdConnect(), [V, W] = useState(null), [J, ne] = useState(!1);
  return { sign: useCallback(
    async (ce, re, oe) => {
      ne(!0);
      try {
        if (W(null), !L || !B || !K)
          throw new Error("No wallet is connected");
        const ke = src$1.Psbt.fromBase64(re), Ce = await signPsbt({
          address: ce,
          wallet: K,
          network: A,
          psbt: ke,
          options: oe
        });
        return ne(!1), Ce;
      } catch (ke) {
        throw W(ke.message), ne(!1), ke;
      }
    },
    [L, A, B, K]
  ), error: V, loading: J };
}
function leatherPaymentTypeFromFormat(A) {
  if (A === "segwit")
    return LeatherAddressType.P2WPKH;
  if (A === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: A,
  wallet: B,
  address: L,
  network: K,
  format: V
}) {
  if (B === Wallet.MAGICEDEN) {
    const { base64: W } = await signMessage$1(A, L, K);
    return W;
  }
  if (B === Wallet.UNISAT) {
    const { base64: W } = await signMessage$2(A, "bip322-simple");
    return W;
  }
  if (B === Wallet.XVERSE) {
    const { base64: W } = await signMessage$3(A, L, K);
    return W;
  }
  if (B === Wallet.LEATHER) {
    const W = leatherPaymentTypeFromFormat(V), { base64: J } = await signMessage$4(A, {
      paymentType: W,
      network: K
    });
    return J;
  }
  if (B === Wallet.OKX) {
    const { base64: W } = await signMessage$5(A, "bip322-simple", K);
    return W;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: A,
    wallet: B,
    publicKey: L,
    format: K,
    address: V
  } = useOrdConnect(), [W, J] = useState(null), [ne, ie] = useState(!1);
  return { signMsg: useCallback(
    async (re, oe) => {
      ie(!0);
      try {
        if (J(null), !K || !L || !B)
          throw new Error("No wallet is connected");
        if (V.ordinals !== re && V.payments !== re)
          throw new Error("Address supplied is not connected address");
        const ke = await signMessage({
          address: re,
          wallet: B,
          message: oe,
          network: A,
          format: V.ordinals === re ? K.ordinals : K.payments
        });
        return ie(!1), ke;
      } catch (ke) {
        throw J(ke.message), ie(!1), ke;
      }
    },
    [K, A, L, B, V]
  ), error: W, isLoading: ne };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
