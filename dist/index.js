(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as React from "react";
import React__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useRef, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, useReducer, useSyncExternalStore, createRef } from "react";
import * as ReactDOM from "react-dom";
import { createPortal, flushSync } from "react-dom";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletRequestCancelledByUserError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var z = queue.length; z; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < z; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, z = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var z = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var Y = 1; Y < arguments.length; Y++)
      z[Y - 1] = arguments[Y];
  queue.push(new Item(B, z)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, z) {
  this.fun = B, this.array = z;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.fragment"), ne = Object.prototype.hasOwnProperty, ie = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, oe = { key: !0, ref: !0, __self: !0, __source: !0 };
  function se(ae, ge, Ce) {
    var le, Ee = {}, Je = null, Ve = null;
    Ce !== void 0 && (Je = "" + Ce), ge.key !== void 0 && (Je = "" + ge.key), ge.ref !== void 0 && (Ve = ge.ref);
    for (le in ge) ne.call(ge, le) && !oe.hasOwnProperty(le) && (Ee[le] = ge[le]);
    if (ae && ae.defaultProps) for (le in ge = ae.defaultProps, ge) Ee[le] === void 0 && (Ee[le] = ge[le]);
    return { $$typeof: z, type: ae, key: Je, ref: Ve, props: Ee, _owner: ie.current };
  }
  return reactJsxRuntime_production_min.Fragment = Y, reactJsxRuntime_production_min.jsx = se, reactJsxRuntime_production_min.jsxs = se, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), ie = Symbol.for("react.strict_mode"), oe = Symbol.for("react.profiler"), se = Symbol.for("react.provider"), ae = Symbol.for("react.context"), ge = Symbol.for("react.forward_ref"), Ce = Symbol.for("react.suspense"), le = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), Je = Symbol.for("react.lazy"), Ve = Symbol.for("react.offscreen"), $t = Symbol.iterator, Nt = "@@iterator";
    function Dt(nr) {
      if (nr === null || typeof nr != "object")
        return null;
      var wr = $t && nr[$t] || nr[Nt];
      return typeof wr == "function" ? wr : null;
    }
    var Wt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Pt(nr) {
      {
        for (var wr = arguments.length, Er = new Array(wr > 1 ? wr - 1 : 0), Pr = 1; Pr < wr; Pr++)
          Er[Pr - 1] = arguments[Pr];
        Lt("error", nr, Er);
      }
    }
    function Lt(nr, wr, Er) {
      {
        var Pr = Wt.ReactDebugCurrentFrame, Dr = Pr.getStackAddendum();
        Dr !== "" && (wr += "%s", Er = Er.concat([Dr]));
        var Ur = Er.map(function(kr) {
          return String(kr);
        });
        Ur.unshift("Warning: " + wr), Function.prototype.apply.call(console[nr], console, Ur);
      }
    }
    var qt = !1, Zt = !1, Yt = !1, or = !1, jt = !1, Ct;
    Ct = Symbol.for("react.module.reference");
    function Vt(nr) {
      return !!(typeof nr == "string" || typeof nr == "function" || nr === ne || nr === oe || jt || nr === ie || nr === Ce || nr === le || or || nr === Ve || qt || Zt || Yt || typeof nr == "object" && nr !== null && (nr.$$typeof === Je || nr.$$typeof === Ee || nr.$$typeof === se || nr.$$typeof === ae || nr.$$typeof === ge || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      nr.$$typeof === Ct || nr.getModuleId !== void 0));
    }
    function kt(nr, wr, Er) {
      var Pr = nr.displayName;
      if (Pr)
        return Pr;
      var Dr = wr.displayName || wr.name || "";
      return Dr !== "" ? Er + "(" + Dr + ")" : Er;
    }
    function Pe(nr) {
      return nr.displayName || "Context";
    }
    function Xe(nr) {
      if (nr == null)
        return null;
      if (typeof nr.tag == "number" && Pt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof nr == "function")
        return nr.displayName || nr.name || null;
      if (typeof nr == "string")
        return nr;
      switch (nr) {
        case ne:
          return "Fragment";
        case Y:
          return "Portal";
        case oe:
          return "Profiler";
        case ie:
          return "StrictMode";
        case Ce:
          return "Suspense";
        case le:
          return "SuspenseList";
      }
      if (typeof nr == "object")
        switch (nr.$$typeof) {
          case ae:
            var wr = nr;
            return Pe(wr) + ".Consumer";
          case se:
            var Er = nr;
            return Pe(Er._context) + ".Provider";
          case ge:
            return kt(nr, nr.render, "ForwardRef");
          case Ee:
            var Pr = nr.displayName || null;
            return Pr !== null ? Pr : Xe(nr.type) || "Memo";
          case Je: {
            var Dr = nr, Ur = Dr._payload, kr = Dr._init;
            try {
              return Xe(kr(Ur));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ve = Object.assign, Ke = 0, ht, wt, vt, xt, Qe, Rt, bt;
    function Ht() {
    }
    Ht.__reactDisabledLog = !0;
    function ar() {
      {
        if (Ke === 0) {
          ht = console.log, wt = console.info, vt = console.warn, xt = console.error, Qe = console.group, Rt = console.groupCollapsed, bt = console.groupEnd;
          var nr = {
            configurable: !0,
            enumerable: !0,
            value: Ht,
            writable: !0
          };
          Object.defineProperties(console, {
            info: nr,
            log: nr,
            warn: nr,
            error: nr,
            group: nr,
            groupCollapsed: nr,
            groupEnd: nr
          });
        }
        Ke++;
      }
    }
    function yr() {
      {
        if (Ke--, Ke === 0) {
          var nr = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ve({}, nr, {
              value: ht
            }),
            info: ve({}, nr, {
              value: wt
            }),
            warn: ve({}, nr, {
              value: vt
            }),
            error: ve({}, nr, {
              value: xt
            }),
            group: ve({}, nr, {
              value: Qe
            }),
            groupCollapsed: ve({}, nr, {
              value: Rt
            }),
            groupEnd: ve({}, nr, {
              value: bt
            })
          });
        }
        Ke < 0 && Pt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var rr = Wt.ReactCurrentDispatcher, Kt;
    function Gt(nr, wr, Er) {
      {
        if (Kt === void 0)
          try {
            throw Error();
          } catch (Dr) {
            var Pr = Dr.stack.trim().match(/\n( *(at )?)/);
            Kt = Pr && Pr[1] || "";
          }
        return `
` + Kt + nr;
      }
    }
    var ur = !1, gr;
    {
      var Qt = typeof WeakMap == "function" ? WeakMap : Map;
      gr = new Qt();
    }
    function Jt(nr, wr) {
      if (!nr || ur)
        return "";
      {
        var Er = gr.get(nr);
        if (Er !== void 0)
          return Er;
      }
      var Pr;
      ur = !0;
      var Dr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Ur;
      Ur = rr.current, rr.current = null, ar();
      try {
        if (wr) {
          var kr = function() {
            throw Error();
          };
          if (Object.defineProperty(kr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(kr, []);
            } catch (an) {
              Pr = an;
            }
            Reflect.construct(nr, [], kr);
          } else {
            try {
              kr.call();
            } catch (an) {
              Pr = an;
            }
            nr.call(kr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (an) {
            Pr = an;
          }
          nr();
        }
      } catch (an) {
        if (an && Pr && typeof an.stack == "string") {
          for (var Xr = an.stack.split(`
`), sn = Pr.stack.split(`
`), tn = Xr.length - 1, on = sn.length - 1; tn >= 1 && on >= 0 && Xr[tn] !== sn[on]; )
            on--;
          for (; tn >= 1 && on >= 0; tn--, on--)
            if (Xr[tn] !== sn[on]) {
              if (tn !== 1 || on !== 1)
                do
                  if (tn--, on--, on < 0 || Xr[tn] !== sn[on]) {
                    var cn = `
` + Xr[tn].replace(" at new ", " at ");
                    return nr.displayName && cn.includes("<anonymous>") && (cn = cn.replace("<anonymous>", nr.displayName)), typeof nr == "function" && gr.set(nr, cn), cn;
                  }
                while (tn >= 1 && on >= 0);
              break;
            }
        }
      } finally {
        ur = !1, rr.current = Ur, yr(), Error.prepareStackTrace = Dr;
      }
      var ln = nr ? nr.displayName || nr.name : "", un = ln ? Gt(ln) : "";
      return typeof nr == "function" && gr.set(nr, un), un;
    }
    function br(nr, wr, Er) {
      return Jt(nr, !1);
    }
    function Sr(nr) {
      var wr = nr.prototype;
      return !!(wr && wr.isReactComponent);
    }
    function Ar(nr, wr, Er) {
      if (nr == null)
        return "";
      if (typeof nr == "function")
        return Jt(nr, Sr(nr));
      if (typeof nr == "string")
        return Gt(nr);
      switch (nr) {
        case Ce:
          return Gt("Suspense");
        case le:
          return Gt("SuspenseList");
      }
      if (typeof nr == "object")
        switch (nr.$$typeof) {
          case ge:
            return br(nr.render);
          case Ee:
            return Ar(nr.type, wr, Er);
          case Je: {
            var Pr = nr, Dr = Pr._payload, Ur = Pr._init;
            try {
              return Ar(Ur(Dr), wr, Er);
            } catch {
            }
          }
        }
      return "";
    }
    var Br = Object.prototype.hasOwnProperty, Mr = {}, Cr = Wt.ReactDebugCurrentFrame;
    function $r(nr) {
      if (nr) {
        var wr = nr._owner, Er = Ar(nr.type, nr._source, wr ? wr.type : null);
        Cr.setExtraStackFrame(Er);
      } else
        Cr.setExtraStackFrame(null);
    }
    function Qr(nr, wr, Er, Pr, Dr) {
      {
        var Ur = Function.call.bind(Br);
        for (var kr in nr)
          if (Ur(nr, kr)) {
            var Xr = void 0;
            try {
              if (typeof nr[kr] != "function") {
                var sn = Error((Pr || "React class") + ": " + Er + " type `" + kr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof nr[kr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw sn.name = "Invariant Violation", sn;
              }
              Xr = nr[kr](wr, kr, Pr, Er, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (tn) {
              Xr = tn;
            }
            Xr && !(Xr instanceof Error) && ($r(Dr), Pt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Pr || "React class", Er, kr, typeof Xr), $r(null)), Xr instanceof Error && !(Xr.message in Mr) && (Mr[Xr.message] = !0, $r(Dr), Pt("Failed %s type: %s", Er, Xr.message), $r(null));
          }
      }
    }
    var jr = Array.isArray;
    function qr(nr) {
      return jr(nr);
    }
    function Gr(nr) {
      {
        var wr = typeof Symbol == "function" && Symbol.toStringTag, Er = wr && nr[Symbol.toStringTag] || nr.constructor.name || "Object";
        return Er;
      }
    }
    function Or(nr) {
      try {
        return Vr(nr), !1;
      } catch {
        return !0;
      }
    }
    function Vr(nr) {
      return "" + nr;
    }
    function Zr(nr) {
      if (Or(nr))
        return Pt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Gr(nr)), Vr(nr);
    }
    var Lr = Wt.ReactCurrentOwner, Yr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, en, zt;
    function Ot(nr) {
      if (Br.call(nr, "ref")) {
        var wr = Object.getOwnPropertyDescriptor(nr, "ref").get;
        if (wr && wr.isReactWarning)
          return !1;
      }
      return nr.ref !== void 0;
    }
    function Ut(nr) {
      if (Br.call(nr, "key")) {
        var wr = Object.getOwnPropertyDescriptor(nr, "key").get;
        if (wr && wr.isReactWarning)
          return !1;
      }
      return nr.key !== void 0;
    }
    function tr(nr, wr) {
      typeof nr.ref == "string" && Lr.current;
    }
    function lr(nr, wr) {
      {
        var Er = function() {
          en || (en = !0, Pt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", wr));
        };
        Er.isReactWarning = !0, Object.defineProperty(nr, "key", {
          get: Er,
          configurable: !0
        });
      }
    }
    function vr(nr, wr) {
      {
        var Er = function() {
          zt || (zt = !0, Pt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", wr));
        };
        Er.isReactWarning = !0, Object.defineProperty(nr, "ref", {
          get: Er,
          configurable: !0
        });
      }
    }
    var _r = function(nr, wr, Er, Pr, Dr, Ur, kr) {
      var Xr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: z,
        // Built-in properties that belong on the element
        type: nr,
        key: wr,
        ref: Er,
        props: kr,
        // Record the component responsible for creating this element.
        _owner: Ur
      };
      return Xr._store = {}, Object.defineProperty(Xr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Xr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Pr
      }), Object.defineProperty(Xr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Dr
      }), Object.freeze && (Object.freeze(Xr.props), Object.freeze(Xr)), Xr;
    };
    function Rr(nr, wr, Er, Pr, Dr) {
      {
        var Ur, kr = {}, Xr = null, sn = null;
        Er !== void 0 && (Zr(Er), Xr = "" + Er), Ut(wr) && (Zr(wr.key), Xr = "" + wr.key), Ot(wr) && (sn = wr.ref, tr(wr, Dr));
        for (Ur in wr)
          Br.call(wr, Ur) && !Yr.hasOwnProperty(Ur) && (kr[Ur] = wr[Ur]);
        if (nr && nr.defaultProps) {
          var tn = nr.defaultProps;
          for (Ur in tn)
            kr[Ur] === void 0 && (kr[Ur] = tn[Ur]);
        }
        if (Xr || sn) {
          var on = typeof nr == "function" ? nr.displayName || nr.name || "Unknown" : nr;
          Xr && lr(kr, on), sn && vr(kr, on);
        }
        return _r(nr, Xr, sn, Dr, Pr, Lr.current, kr);
      }
    }
    var Wr = Wt.ReactCurrentOwner, Ir = Wt.ReactDebugCurrentFrame;
    function Hr(nr) {
      if (nr) {
        var wr = nr._owner, Er = Ar(nr.type, nr._source, wr ? wr.type : null);
        Ir.setExtraStackFrame(Er);
      } else
        Ir.setExtraStackFrame(null);
    }
    var Fr;
    Fr = !1;
    function Nr(nr) {
      return typeof nr == "object" && nr !== null && nr.$$typeof === z;
    }
    function Jr() {
      {
        if (Wr.current) {
          var nr = Xe(Wr.current.type);
          if (nr)
            return `

Check the render method of \`` + nr + "`.";
        }
        return "";
      }
    }
    function nn(nr) {
      return "";
    }
    var fr = {};
    function er(nr) {
      {
        var wr = Jr();
        if (!wr) {
          var Er = typeof nr == "string" ? nr : nr.displayName || nr.name;
          Er && (wr = `

Check the top-level render call using <` + Er + ">.");
        }
        return wr;
      }
    }
    function cr(nr, wr) {
      {
        if (!nr._store || nr._store.validated || nr.key != null)
          return;
        nr._store.validated = !0;
        var Er = er(wr);
        if (fr[Er])
          return;
        fr[Er] = !0;
        var Pr = "";
        nr && nr._owner && nr._owner !== Wr.current && (Pr = " It was passed a child from " + Xe(nr._owner.type) + "."), Hr(nr), Pt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Er, Pr), Hr(null);
      }
    }
    function Ft(nr, wr) {
      {
        if (typeof nr != "object")
          return;
        if (qr(nr))
          for (var Er = 0; Er < nr.length; Er++) {
            var Pr = nr[Er];
            Nr(Pr) && cr(Pr, wr);
          }
        else if (Nr(nr))
          nr._store && (nr._store.validated = !0);
        else if (nr) {
          var Dr = Dt(nr);
          if (typeof Dr == "function" && Dr !== nr.entries)
            for (var Ur = Dr.call(nr), kr; !(kr = Ur.next()).done; )
              Nr(kr.value) && cr(kr.value, wr);
        }
      }
    }
    function _t(nr) {
      {
        var wr = nr.type;
        if (wr == null || typeof wr == "string")
          return;
        var Er;
        if (typeof wr == "function")
          Er = wr.propTypes;
        else if (typeof wr == "object" && (wr.$$typeof === ge || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        wr.$$typeof === Ee))
          Er = wr.propTypes;
        else
          return;
        if (Er) {
          var Pr = Xe(wr);
          Qr(Er, nr.props, "prop", Pr, nr);
        } else if (wr.PropTypes !== void 0 && !Fr) {
          Fr = !0;
          var Dr = Xe(wr);
          Pt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Dr || "Unknown");
        }
        typeof wr.getDefaultProps == "function" && !wr.getDefaultProps.isReactClassApproved && Pt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Bt(nr) {
      {
        for (var wr = Object.keys(nr.props), Er = 0; Er < wr.length; Er++) {
          var Pr = wr[Er];
          if (Pr !== "children" && Pr !== "key") {
            Hr(nr), Pt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Pr), Hr(null);
            break;
          }
        }
        nr.ref !== null && (Hr(nr), Pt("Invalid attribute `ref` supplied to `React.Fragment`."), Hr(null));
      }
    }
    var Xt = {};
    function ir(nr, wr, Er, Pr, Dr, Ur) {
      {
        var kr = Vt(nr);
        if (!kr) {
          var Xr = "";
          (nr === void 0 || typeof nr == "object" && nr !== null && Object.keys(nr).length === 0) && (Xr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var sn = nn();
          sn ? Xr += sn : Xr += Jr();
          var tn;
          nr === null ? tn = "null" : qr(nr) ? tn = "array" : nr !== void 0 && nr.$$typeof === z ? (tn = "<" + (Xe(nr.type) || "Unknown") + " />", Xr = " Did you accidentally export a JSX literal instead of a component?") : tn = typeof nr, Pt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", tn, Xr);
        }
        var on = Rr(nr, wr, Er, Dr, Ur);
        if (on == null)
          return on;
        if (kr) {
          var cn = wr.children;
          if (cn !== void 0)
            if (Pr)
              if (qr(cn)) {
                for (var ln = 0; ln < cn.length; ln++)
                  Ft(cn[ln], nr);
                Object.freeze && Object.freeze(cn);
              } else
                Pt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ft(cn, nr);
        }
        if (Br.call(wr, "key")) {
          var un = Xe(nr), an = Object.keys(wr).filter(function(pn) {
            return pn !== "key";
          }), dn = an.length > 0 ? "{key: someKey, " + an.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Xt[un + dn]) {
            var hn = an.length > 0 ? "{" + an.join(": ..., ") + ": ...}" : "{}";
            Pt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, dn, un, hn, un), Xt[un + dn] = !0;
          }
        }
        return nr === ne ? Bt(on) : _t(on), on;
      }
    }
    function dr(nr, wr, Er) {
      return ir(nr, wr, Er, !0);
    }
    function pr(nr, wr, Er) {
      return ir(nr, wr, Er, !1);
    }
    var xr = pr, Tr = dr;
    reactJsxRuntime_development.Fragment = ne, reactJsxRuntime_development.jsx = xr, reactJsxRuntime_development.jsxs = Tr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, z] = useState(!1);
  return useEffect(() => {
    z(!0);
  }, []), B;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(B) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const z = `${KEY_PREFIX}_${B}`;
  try {
    const Y = window.localStorage.getItem(z);
    return Y != null ? JSON.parse(Y) : null;
  } catch (Y) {
    return console.error(`Error retrieving ${z} from localStorage`, Y), null;
  }
}
function setItemToLocalStorage(B, z) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const Y = `${KEY_PREFIX}_${B}`;
  try {
    z ? window.localStorage.setItem(Y, JSON.stringify(z)) : window.localStorage.removeItem(Y);
  } catch (ne) {
    console.error(`Error saving ${Y} to localStorage`, ne);
  }
}
function useLocalStorage(B, z, Y = {}) {
  const { initializeWithValue: ne = !0 } = Y, ie = useCallback(() => {
    const ge = getItemFromLocalStorage(B);
    return ge || (setItemToLocalStorage(B, z), z);
  }, [z, B]), [oe, se] = useState(() => ne ? ie() : z), ae = useCallback(
    (ge) => {
      setItemToLocalStorage(B, ge), se(ge);
    },
    [B]
  );
  return useEffect(() => {
    se(ie());
  }, [B]), [oe, ae];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {}), Chain = /* @__PURE__ */ ((B) => (B.BITCOIN = "bitcoin", B.FRACTAL_BITCOIN = "fractal-bitcoin", B))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: B,
  network: z,
  visibleWallets: Y,
  chain: ne = "bitcoin",
  ssr: ie = !1
}) {
  if (!z)
    throw new Error("Network cannot be empty");
  if (!Y || Y.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [oe, se] = useState(z), [ae, ge] = useState(Y), [Ce, le] = useState(ne), [Ee, Je] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ie }
  ), [Ve, $t] = useLocalStorage(WALLET, null, {
    initializeWithValue: !ie
  }), [Nt, Dt] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ie }
  ), [Wt, Pt] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !ie }
  ), [Lt, qt] = useState(!1), Zt = useCallback(() => qt(!0), []), Yt = useCallback(() => qt(!1), []), or = useCallback(() => {
    Je(EMPTY_BIADDRESS_OBJECT), Dt(EMPTY_BIADDRESS_OBJECT), Pt(EMPTY_BIADDRESS_OBJECT), $t(null);
  }, [Je, Pt, Dt, $t]), jt = useMemo(
    () => ({
      address: Ee,
      updateAddress: Je,
      publicKey: Nt,
      updatePublicKey: Dt,
      network: oe,
      updateNetwork: se,
      wallet: Ve,
      updateWallet: $t,
      isModalOpen: Lt,
      openModal: Zt,
      closeModal: Yt,
      format: Wt,
      updateFormat: Pt,
      disconnectWallet: or,
      chain: Ce,
      updateChain: le,
      visibleWallets: ae,
      updateVisibleWallets: ge
    }),
    [
      Ee,
      Je,
      Nt,
      Dt,
      oe,
      Ve,
      Lt,
      Zt,
      Yt,
      Wt,
      Pt,
      or,
      Ce,
      ae,
      $t
    ]
  );
  return useEffect(() => {
    se(z);
  }, [z]), useEffect(() => {
    Ce !== ne && (or(), le(ne));
  }, [ne, Ce, or]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: jt, children: B });
}
function useOrdConnect() {
  const B = useContext(OrdConnectContext);
  if (!B)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return B;
}
var build = { exports: {} };
(function(B, z) {
  (function(Y, ne) {
    B.exports = ne(React__default);
  })(commonjsGlobal, function(Y) {
    return function(ne) {
      var ie = {};
      function oe(se) {
        if (ie[se]) return ie[se].exports;
        var ae = ie[se] = { i: se, l: !1, exports: {} };
        return ne[se].call(ae.exports, ae, ae.exports, oe), ae.l = !0, ae.exports;
      }
      return oe.m = ne, oe.c = ie, oe.d = function(se, ae, ge) {
        oe.o(se, ae) || Object.defineProperty(se, ae, { enumerable: !0, get: ge });
      }, oe.r = function(se) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(se, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(se, "__esModule", { value: !0 });
      }, oe.t = function(se, ae) {
        if (1 & ae && (se = oe(se)), 8 & ae || 4 & ae && typeof se == "object" && se && se.__esModule) return se;
        var ge = /* @__PURE__ */ Object.create(null);
        if (oe.r(ge), Object.defineProperty(ge, "default", { enumerable: !0, value: se }), 2 & ae && typeof se != "string") for (var Ce in se) oe.d(ge, Ce, (function(le) {
          return se[le];
        }).bind(null, Ce));
        return ge;
      }, oe.n = function(se) {
        var ae = se && se.__esModule ? function() {
          return se.default;
        } : function() {
          return se;
        };
        return oe.d(ae, "a", ae), ae;
      }, oe.o = function(se, ae) {
        return Object.prototype.hasOwnProperty.call(se, ae);
      }, oe.p = "/", oe(oe.s = 1);
    }([function(ne, ie) {
      ne.exports = Y;
    }, function(ne, ie, oe) {
      ne.exports = oe(2);
    }, function(ne, ie, oe) {
      function se(Pt, Lt) {
        if (Pt == null) return {};
        var qt, Zt, Yt = function(jt, Ct) {
          if (jt == null) return {};
          var Vt, kt, Pe = {}, Xe = Object.keys(jt);
          for (kt = 0; kt < Xe.length; kt++) Vt = Xe[kt], Ct.indexOf(Vt) >= 0 || (Pe[Vt] = jt[Vt]);
          return Pe;
        }(Pt, Lt);
        if (Object.getOwnPropertySymbols) {
          var or = Object.getOwnPropertySymbols(Pt);
          for (Zt = 0; Zt < or.length; Zt++) qt = or[Zt], Lt.indexOf(qt) >= 0 || Object.prototype.propertyIsEnumerable.call(Pt, qt) && (Yt[qt] = Pt[qt]);
        }
        return Yt;
      }
      oe.r(ie);
      var ae = oe(0), ge = oe.n(ae), Ce = function(Pt) {
        for (var Lt = 0, qt = 0; qt < Pt.length; qt++)
          Lt = (Lt << 5) - Lt + Pt.charCodeAt(qt), Lt &= Lt;
        return Math.abs(Lt);
      }, le = function(Pt, Lt) {
        return Math.floor(Pt / Math.pow(10, Lt) % 10);
      }, Ee = function(Pt, Lt) {
        return !(le(Pt, Lt) % 2);
      }, Je = function(Pt, Lt, qt) {
        var Zt = Pt % Lt;
        return qt && le(Pt, qt) % 2 === 0 ? -Zt : Zt;
      }, Ve = function(Pt, Lt, qt) {
        return Lt[Pt % qt];
      }, $t = function(Pt) {
        var Lt = Pt.name, qt = Pt.colors, Zt = Pt.title, Yt = Pt.square, or = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Ct = function(kt, Pe) {
          var Xe = Ce(kt), ve = Pe && Pe.length;
          return Array.from({ length: 3 }, function(Ke, ht) {
            return { color: Ve(Xe + ht, Pe, ve), translateX: Je(Xe * (ht + 1), 8, 1), translateY: Je(Xe * (ht + 1), 8, 2), scale: 1.2 + Je(Xe * (ht + 1), 4) / 10, rotate: Je(Xe * (ht + 1), 360, 1) };
          });
        }(Lt, qt), Vt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: or, height: or }, jt), Zt && ae.createElement("title", null, Lt), ae.createElement("mask", { id: Vt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Yt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Vt, ")") }, ae.createElement("rect", { width: 80, height: 80, fill: Ct[0].color }), ae.createElement("path", { filter: "url(#filter_".concat(Vt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: Ct[1].color, transform: "translate(" + Ct[1].translateX + " " + Ct[1].translateY + ") rotate(" + Ct[1].rotate + " 40 40) scale(" + Ct[2].scale + ")" }), ae.createElement("path", { filter: "url(#filter_".concat(Vt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: Ct[2].color, transform: "translate(" + Ct[2].translateX + " " + Ct[2].translateY + ") rotate(" + Ct[2].rotate + " 40 40) scale(" + Ct[2].scale + ")" })), ae.createElement("defs", null, ae.createElement("filter", { id: "filter_".concat(Vt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, ae.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), ae.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), ae.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, Nt = { pixel: function(Pt) {
        var Lt = Pt.name, qt = Pt.colors, Zt = Pt.title, Yt = Pt.square, or = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Ct = function(kt, Pe) {
          var Xe = Ce(kt), ve = Pe && Pe.length;
          return Array.from({ length: 64 }, function(Ke, ht) {
            return Ve(Xe % (ht + 1), Pe, ve);
          });
        }(Lt, qt), Vt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: or, height: or }, jt), Zt && ae.createElement("title", null, Lt), ae.createElement("mask", { id: Vt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Yt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Vt, ")") }, ae.createElement("rect", { width: 10, height: 10, fill: Ct[0] }), ae.createElement("rect", { x: 20, width: 10, height: 10, fill: Ct[1] }), ae.createElement("rect", { x: 40, width: 10, height: 10, fill: Ct[2] }), ae.createElement("rect", { x: 60, width: 10, height: 10, fill: Ct[3] }), ae.createElement("rect", { x: 10, width: 10, height: 10, fill: Ct[4] }), ae.createElement("rect", { x: 30, width: 10, height: 10, fill: Ct[5] }), ae.createElement("rect", { x: 50, width: 10, height: 10, fill: Ct[6] }), ae.createElement("rect", { x: 70, width: 10, height: 10, fill: Ct[7] }), ae.createElement("rect", { y: 10, width: 10, height: 10, fill: Ct[8] }), ae.createElement("rect", { y: 20, width: 10, height: 10, fill: Ct[9] }), ae.createElement("rect", { y: 30, width: 10, height: 10, fill: Ct[10] }), ae.createElement("rect", { y: 40, width: 10, height: 10, fill: Ct[11] }), ae.createElement("rect", { y: 50, width: 10, height: 10, fill: Ct[12] }), ae.createElement("rect", { y: 60, width: 10, height: 10, fill: Ct[13] }), ae.createElement("rect", { y: 70, width: 10, height: 10, fill: Ct[14] }), ae.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: Ct[15] }), ae.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: Ct[16] }), ae.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: Ct[17] }), ae.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: Ct[18] }), ae.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: Ct[19] }), ae.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: Ct[20] }), ae.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: Ct[21] }), ae.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: Ct[22] }), ae.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: Ct[23] }), ae.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: Ct[24] }), ae.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: Ct[25] }), ae.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: Ct[26] }), ae.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: Ct[27] }), ae.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: Ct[28] }), ae.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: Ct[29] }), ae.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: Ct[30] }), ae.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: Ct[31] }), ae.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: Ct[32] }), ae.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: Ct[33] }), ae.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: Ct[34] }), ae.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: Ct[35] }), ae.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: Ct[36] }), ae.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: Ct[37] }), ae.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: Ct[38] }), ae.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: Ct[39] }), ae.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: Ct[40] }), ae.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: Ct[41] }), ae.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: Ct[42] }), ae.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: Ct[43] }), ae.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: Ct[44] }), ae.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: Ct[45] }), ae.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: Ct[46] }), ae.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: Ct[47] }), ae.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: Ct[48] }), ae.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: Ct[49] }), ae.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: Ct[50] }), ae.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: Ct[51] }), ae.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: Ct[52] }), ae.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: Ct[53] }), ae.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: Ct[54] }), ae.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: Ct[55] }), ae.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: Ct[56] }), ae.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: Ct[57] }), ae.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: Ct[58] }), ae.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: Ct[59] }), ae.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: Ct[60] }), ae.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: Ct[61] }), ae.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: Ct[62] }), ae.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: Ct[63] })));
      }, bauhaus: function(Pt) {
        var Lt = Pt.name, qt = Pt.colors, Zt = Pt.title, Yt = Pt.square, or = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Ct = function(kt, Pe) {
          var Xe = Ce(kt), ve = Pe && Pe.length;
          return Array.from({ length: 4 }, function(Ke, ht) {
            return { color: Ve(Xe + ht, Pe, ve), translateX: Je(Xe * (ht + 1), 40 - (ht + 17), 1), translateY: Je(Xe * (ht + 1), 40 - (ht + 17), 2), rotate: Je(Xe * (ht + 1), 360), isSquare: Ee(Xe, 2) };
          });
        }(Lt, qt), Vt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: or, height: or }, jt), Zt && ae.createElement("title", null, Lt), ae.createElement("mask", { id: Vt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Yt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Vt, ")") }, ae.createElement("rect", { width: 80, height: 80, fill: Ct[0].color }), ae.createElement("rect", { x: 10, y: 30, width: 80, height: Ct[1].isSquare ? 80 : 10, fill: Ct[1].color, transform: "translate(" + Ct[1].translateX + " " + Ct[1].translateY + ") rotate(" + Ct[1].rotate + " 40 40)" }), ae.createElement("circle", { cx: 40, cy: 40, fill: Ct[2].color, r: 16, transform: "translate(" + Ct[2].translateX + " " + Ct[2].translateY + ")" }), ae.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: Ct[3].color, transform: "translate(" + Ct[3].translateX + " " + Ct[3].translateY + ") rotate(" + Ct[3].rotate + " 40 40)" })));
      }, ring: function(Pt) {
        var Lt = Pt.name, qt = Pt.colors, Zt = Pt.title, Yt = Pt.square, or = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Ct = function(kt, Pe) {
          var Xe = Ce(Pe), ve = kt && kt.length, Ke = Array.from({ length: 5 }, function(wt, vt) {
            return Ve(Xe + vt, kt, ve);
          }), ht = [];
          return ht[0] = Ke[0], ht[1] = Ke[1], ht[2] = Ke[1], ht[3] = Ke[2], ht[4] = Ke[2], ht[5] = Ke[3], ht[6] = Ke[3], ht[7] = Ke[0], ht[8] = Ke[4], ht;
        }(qt, Lt), Vt = ge.a.useId();
        return ge.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: or, height: or }, jt), Zt && ge.a.createElement("title", null, Lt), ge.a.createElement("mask", { id: Vt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ge.a.createElement("rect", { width: 90, height: 90, rx: Yt ? void 0 : 180, fill: "#FFFFFF" })), ge.a.createElement("g", { mask: "url(#".concat(Vt, ")") }, ge.a.createElement("path", { d: "M0 0h90v45H0z", fill: Ct[0] }), ge.a.createElement("path", { d: "M0 45h90v45H0z", fill: Ct[1] }), ge.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: Ct[2] }), ge.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: Ct[3] }), ge.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: Ct[4] }), ge.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: Ct[5] }), ge.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: Ct[6] }), ge.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: Ct[7] }), ge.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: Ct[8] })));
      }, beam: function(Pt) {
        var Lt = Pt.name, qt = Pt.colors, Zt = Pt.title, Yt = Pt.square, or = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Ct = function(kt, Pe) {
          var Xe, ve = Ce(kt), Ke = Pe && Pe.length, ht = Ve(ve, Pe, Ke), wt = Je(ve, 10, 1), vt = wt < 5 ? wt + 4 : wt, xt = Je(ve, 10, 2), Qe = xt < 5 ? xt + 4 : xt;
          return { wrapperColor: ht, faceColor: (Xe = ht, Xe.slice(0, 1) === "#" && (Xe = Xe.slice(1)), (299 * parseInt(Xe.substr(0, 2), 16) + 587 * parseInt(Xe.substr(2, 2), 16) + 114 * parseInt(Xe.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Ve(ve + 13, Pe, Ke), wrapperTranslateX: vt, wrapperTranslateY: Qe, wrapperRotate: Je(ve, 360), wrapperScale: 1 + Je(ve, 3) / 10, isMouthOpen: Ee(ve, 2), isCircle: Ee(ve, 1), eyeSpread: Je(ve, 5), mouthSpread: Je(ve, 3), faceRotate: Je(ve, 10, 3), faceTranslateX: vt > 6 ? vt / 2 : Je(ve, 8, 1), faceTranslateY: Qe > 6 ? Qe / 2 : Je(ve, 7, 2) };
        }(Lt, qt), Vt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: or, height: or }, jt), Zt && ae.createElement("title", null, Lt), ae.createElement("mask", { id: Vt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, ae.createElement("rect", { width: 36, height: 36, rx: Yt ? void 0 : 72, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(Vt, ")") }, ae.createElement("rect", { width: 36, height: 36, fill: Ct.backgroundColor }), ae.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + Ct.wrapperTranslateX + " " + Ct.wrapperTranslateY + ") rotate(" + Ct.wrapperRotate + " 18 18) scale(" + Ct.wrapperScale + ")", fill: Ct.wrapperColor, rx: Ct.isCircle ? 36 : 6 }), ae.createElement("g", { transform: "translate(" + Ct.faceTranslateX + " " + Ct.faceTranslateY + ") rotate(" + Ct.faceRotate + " 18 18)" }, Ct.isMouthOpen ? ae.createElement("path", { d: "M15 " + (19 + Ct.mouthSpread) + "c2 1 4 1 6 0", stroke: Ct.faceColor, fill: "none", strokeLinecap: "round" }) : ae.createElement("path", { d: "M13," + (19 + Ct.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: Ct.faceColor }), ae.createElement("rect", { x: 14 - Ct.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Ct.faceColor }), ae.createElement("rect", { x: 20 + Ct.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Ct.faceColor }))));
      }, sunset: function(Pt) {
        var Lt = Pt.name, qt = Pt.colors, Zt = Pt.title, Yt = Pt.square, or = Pt.size, jt = se(Pt, ["name", "colors", "title", "square", "size"]), Ct = function(Pe, Xe) {
          var ve = Ce(Pe), Ke = Xe && Xe.length;
          return Array.from({ length: 4 }, function(ht, wt) {
            return Ve(ve + wt, Xe, Ke);
          });
        }(Lt, qt), Vt = Lt.replace(/\s/g, ""), kt = ae.useId();
        return ae.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: or, height: or }, jt), Zt && ae.createElement("title", null, Lt), ae.createElement("mask", { id: kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ae.createElement("rect", { width: 80, height: 80, rx: Yt ? void 0 : 160, fill: "#FFFFFF" })), ae.createElement("g", { mask: "url(#".concat(kt, ")") }, ae.createElement("path", { fill: "url(#gradient_paint0_linear_" + Vt + ")", d: "M0 0h80v40H0z" }), ae.createElement("path", { fill: "url(#gradient_paint1_linear_" + Vt + ")", d: "M0 40h80v40H0z" })), ae.createElement("defs", null, ae.createElement("linearGradient", { id: "gradient_paint0_linear_" + Vt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, ae.createElement("stop", { stopColor: Ct[0] }), ae.createElement("stop", { offset: 1, stopColor: Ct[1] })), ae.createElement("linearGradient", { id: "gradient_paint1_linear_" + Vt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, ae.createElement("stop", { stopColor: Ct[2] }), ae.createElement("stop", { offset: 1, stopColor: Ct[3] }))));
      }, marble: $t }, Dt = { geometric: "beam", abstract: "bauhaus" }, Wt = function(Pt) {
        var Lt = Pt.variant, qt = Lt === void 0 ? "marble" : Lt, Zt = Pt.colors, Yt = Zt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Zt, or = Pt.name, jt = or === void 0 ? "Clara Barton" : or, Ct = Pt.title, Vt = Ct !== void 0 && Ct, kt = Pt.size, Pe = Pt.square, Xe = Pe !== void 0 && Pe, ve = se(Pt, ["variant", "colors", "name", "title", "size", "square"]), Ke = Nt[Dt[qt] || qt] || $t;
        return ge.a.createElement(Ke, Object.assign({ colors: Yt, name: jt, title: Vt, size: kt, square: Xe }, ve));
      };
      ie.default = Wt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports), $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(B) {
  const z = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    z.current = B;
  }, [
    B
  ]), useCallback((...Y) => {
    const ne = z.current;
    return ne == null ? void 0 : ne(...Y);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (B) => {
  var z;
  return (z = B == null ? void 0 : B.ownerDocument) !== null && z !== void 0 ? z : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (B) => B && "window" in B && B.window === B ? B : $431fbd86ca7dc216$export$b204af158042fbac(B).defaultView || window;
function $c87311424ea30a05$var$testUserAgent(B) {
  var z;
  return typeof window > "u" || window.navigator == null ? !1 : ((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.brands.some((Y) => B.test(Y.brand))) || B.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(B) {
  var z;
  return typeof window < "u" && window.navigator != null ? B.test(((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(B) {
  let z = null;
  return () => (z == null && (z = B()), z);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $6a7db85432448f7f$export$60278871457622de(B) {
  return B.mozInputSource === 0 && B.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && B.pointerType ? B.type === "click" && B.buttons === 1 : B.detail === 0 && !B.pointerType;
}
class $8a9cb279dc87e130$export$905e7fc544a71f36 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(z, Y) {
    this.nativeEvent = Y, this.target = Y.target, this.currentTarget = Y.currentTarget, this.relatedTarget = Y.relatedTarget, this.bubbles = Y.bubbles, this.cancelable = Y.cancelable, this.defaultPrevented = Y.defaultPrevented, this.eventPhase = Y.eventPhase, this.isTrusted = Y.isTrusted, this.timeStamp = Y.timeStamp, this.type = z;
  }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(B) {
  let z = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const ne = z.current;
    return () => {
      ne.observer && (ne.observer.disconnect(), ne.observer = null);
    };
  }, []);
  let Y = $8ae05eaa5c114e9c$export$7f54fc3180508a52((ne) => {
    B == null || B(ne);
  });
  return useCallback((ne) => {
    if (ne.target instanceof HTMLButtonElement || ne.target instanceof HTMLInputElement || ne.target instanceof HTMLTextAreaElement || ne.target instanceof HTMLSelectElement) {
      z.current.isFocused = !0;
      let ie = ne.target, oe = (se) => {
        z.current.isFocused = !1, ie.disabled && Y(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", se)), z.current.observer && (z.current.observer.disconnect(), z.current.observer = null);
      };
      ie.addEventListener("focusout", oe, {
        once: !0
      }), z.current.observer = new MutationObserver(() => {
        if (z.current.isFocused && ie.disabled) {
          var se;
          (se = z.current.observer) === null || se === void 0 || se.disconnect();
          let ae = ie === document.activeElement ? null : document.activeElement;
          ie.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: ae
          })), ie.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: ae
          }));
        }
      }), z.current.observer.observe(ie, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    Y
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(B) {
  let { isDisabled: z, onFocus: Y, onBlur: ne, onFocusChange: ie } = B;
  const oe = useCallback((ge) => {
    if (ge.target === ge.currentTarget)
      return ne && ne(ge), ie && ie(!1), !0;
  }, [
    ne,
    ie
  ]), se = $8a9cb279dc87e130$export$715c682d09d639cc(oe), ae = useCallback((ge) => {
    const Ce = $431fbd86ca7dc216$export$b204af158042fbac(ge.target);
    ge.target === ge.currentTarget && Ce.activeElement === ge.target && (Y && Y(ge), ie && ie(!0), se(ge));
  }, [
    ie,
    Y,
    se
  ]);
  return {
    focusProps: {
      onFocus: !z && (Y || ie || ne) ? ae : void 0,
      onBlur: !z && (ne || ie) ? oe : void 0
    }
  };
}
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(B, z) {
  for (let Y of $507fabe10e71c6fb$var$changeHandlers) Y(B, z);
}
function $507fabe10e71c6fb$var$isValidKey(B) {
  return !(B.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && B.altKey || B.ctrlKey || B.key === "Control" || B.key === "Shift" || B.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(B) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(B) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", B));
}
function $507fabe10e71c6fb$var$handlePointerEvent(B) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (B.type === "mousedown" || B.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", B));
}
function $507fabe10e71c6fb$var$handleClickEvent(B) {
  $6a7db85432448f7f$export$60278871457622de(B) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(B) {
  B.target === window || B.target === document || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", B)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(B))) return;
  const z = $431fbd86ca7dc216$export$f21a1ffae260145a(B), Y = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let ne = z.HTMLElement.prototype.focus;
  z.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, ne.apply(this, arguments);
  }, Y.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), z.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), z.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (Y.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (Y.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), z.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(z, {
    focus: ne
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (B, z) => {
  const Y = $431fbd86ca7dc216$export$f21a1ffae260145a(B), ne = $431fbd86ca7dc216$export$b204af158042fbac(B);
  z && ne.removeEventListener("DOMContentLoaded", z), $507fabe10e71c6fb$export$d90243b58daecda7.has(Y) && (Y.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(Y).focus, ne.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), Y.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), Y.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (ne.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (ne.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(Y));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(B) {
  const z = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let Y;
  return z.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) : (Y = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(B);
  }, z.addEventListener("DOMContentLoaded", Y)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B, Y);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(B, z, Y) {
  var ne;
  const ie = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLInputElement : HTMLInputElement, oe = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLTextAreaElement : HTMLTextAreaElement, se = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLElement : HTMLElement, ae = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).KeyboardEvent : KeyboardEvent;
  return B = B || (Y == null ? void 0 : Y.target) instanceof ie && !$507fabe10e71c6fb$var$nonTextInputTypes.has(Y == null || (ne = Y.target) === null || ne === void 0 ? void 0 : ne.type) || (Y == null ? void 0 : Y.target) instanceof oe || (Y == null ? void 0 : Y.target) instanceof se && (Y == null ? void 0 : Y.target.isContentEditable), !(B && z === "keyboard" && Y instanceof ae && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[Y.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(B, z, Y) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let ne = (ie, oe) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(Y != null && Y.isTextInput), ie, oe) && B($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(ne), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(ne);
    };
  }, z);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(B) {
  let { isDisabled: z, onBlurWithin: Y, onFocusWithin: ne, onFocusWithinChange: ie } = B, oe = useRef({
    isFocusWithin: !1
  }), se = useCallback((Ce) => {
    oe.current.isFocusWithin && !Ce.currentTarget.contains(Ce.relatedTarget) && (oe.current.isFocusWithin = !1, Y && Y(Ce), ie && ie(!1));
  }, [
    Y,
    ie,
    oe
  ]), ae = $8a9cb279dc87e130$export$715c682d09d639cc(se), ge = useCallback((Ce) => {
    !oe.current.isFocusWithin && document.activeElement === Ce.target && (ne && ne(Ce), ie && ie(!0), oe.current.isFocusWithin = !0, ae(Ce));
  }, [
    ne,
    ie,
    ae
  ]);
  return z ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: ge,
      onBlur: se
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(B) {
  B.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(B) {
  let { onHoverStart: z, onHoverChange: Y, onHoverEnd: ne, isDisabled: ie } = B, [oe, se] = useState(!1), ae = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps: ge, triggerHoverEnd: Ce } = useMemo(() => {
    let le = (Ve, $t) => {
      if (ae.pointerType = $t, ie || $t === "touch" || ae.isHovered || !Ve.currentTarget.contains(Ve.target)) return;
      ae.isHovered = !0;
      let Nt = Ve.currentTarget;
      ae.target = Nt, z && z({
        type: "hoverstart",
        target: Nt,
        pointerType: $t
      }), Y && Y(!0), se(!0);
    }, Ee = (Ve, $t) => {
      if (ae.pointerType = "", ae.target = null, $t === "touch" || !ae.isHovered) return;
      ae.isHovered = !1;
      let Nt = Ve.currentTarget;
      ne && ne({
        type: "hoverend",
        target: Nt,
        pointerType: $t
      }), Y && Y(!1), se(!1);
    }, Je = {};
    return typeof PointerEvent < "u" ? (Je.onPointerEnter = (Ve) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && Ve.pointerType === "mouse" || le(Ve, Ve.pointerType);
    }, Je.onPointerLeave = (Ve) => {
      !ie && Ve.currentTarget.contains(Ve.target) && Ee(Ve, Ve.pointerType);
    }) : (Je.onTouchStart = () => {
      ae.ignoreEmulatedMouseEvents = !0;
    }, Je.onMouseEnter = (Ve) => {
      !ae.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && le(Ve, "mouse"), ae.ignoreEmulatedMouseEvents = !1;
    }, Je.onMouseLeave = (Ve) => {
      !ie && Ve.currentTarget.contains(Ve.target) && Ee(Ve, "mouse");
    }), {
      hoverProps: Je,
      triggerHoverEnd: Ee
    };
  }, [
    z,
    Y,
    ne,
    ie,
    ae
  ]);
  return useEffect(() => {
    ie && Ce({
      currentTarget: ae.target
    }, ae.pointerType);
  }, [
    ie
  ]), {
    hoverProps: ge,
    isHovered: oe
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(B = {}) {
  let { autoFocus: z = !1, isTextInput: Y, within: ne } = B, ie = useRef({
    isFocused: !1,
    isFocusVisible: z || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [oe, se] = useState(!1), [ae, ge] = useState(() => ie.current.isFocused && ie.current.isFocusVisible), Ce = useCallback(() => ge(ie.current.isFocused && ie.current.isFocusVisible), []), le = useCallback((Ve) => {
    ie.current.isFocused = Ve, se(Ve), Ce();
  }, [
    Ce
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((Ve) => {
    ie.current.isFocusVisible = Ve, Ce();
  }, [], {
    isTextInput: Y
  });
  let { focusProps: Ee } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: ne,
    onFocusChange: le
  }), { focusWithinProps: Je } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !ne,
    onFocusWithinChange: le
  });
  return {
    isFocused: oe,
    isFocusVisible: ae,
    focusProps: ne ? Je : Ee
  };
}
var i$7 = Object.defineProperty, d$3 = (B, z, Y) => z in B ? i$7(B, z, { enumerable: !0, configurable: !0, writable: !0, value: Y }) : B[z] = Y, r$5 = (B, z, Y) => (d$3(B, typeof z != "symbol" ? z + "" : z, Y), Y);
let o$6 = class {
  constructor() {
    r$5(this, "current", this.detect()), r$5(this, "handoffState", "pending"), r$5(this, "currentId", 0);
  }
  set(z) {
    this.current !== z && (this.handoffState = "pending", this.currentId = 0, this.current = z);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$9 = new o$6();
function u$8(B) {
  return s$9.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
function t$4(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((z) => setTimeout(() => {
    throw z;
  }));
}
function o$5() {
  let B = [], z = { addEventListener(Y, ne, ie, oe) {
    return Y.addEventListener(ne, ie, oe), z.add(() => Y.removeEventListener(ne, ie, oe));
  }, requestAnimationFrame(...Y) {
    let ne = requestAnimationFrame(...Y);
    return z.add(() => cancelAnimationFrame(ne));
  }, nextFrame(...Y) {
    return z.requestAnimationFrame(() => z.requestAnimationFrame(...Y));
  }, setTimeout(...Y) {
    let ne = setTimeout(...Y);
    return z.add(() => clearTimeout(ne));
  }, microTask(...Y) {
    let ne = { current: !0 };
    return t$4(() => {
      ne.current && Y[0]();
    }), z.add(() => {
      ne.current = !1;
    });
  }, style(Y, ne, ie) {
    let oe = Y.style.getPropertyValue(ne);
    return Object.assign(Y.style, { [ne]: ie }), this.add(() => {
      Object.assign(Y.style, { [ne]: oe });
    });
  }, group(Y) {
    let ne = o$5();
    return Y(ne), this.add(() => ne.dispose());
  }, add(Y) {
    return B.includes(Y) || B.push(Y), () => {
      let ne = B.indexOf(Y);
      if (ne >= 0) for (let ie of B.splice(ne, 1)) ie();
    };
  }, dispose() {
    for (let Y of B.splice(0)) Y();
  } };
  return z;
}
function p$2() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
let n$3 = (B, z) => {
  s$9.isServer ? useEffect(B, z) : useLayoutEffect(B, z);
};
function s$8(B) {
  let z = useRef(B);
  return n$3(() => {
    z.current = B;
  }, [B]), z;
}
let o$4 = function(B) {
  let z = s$8(B);
  return React__default.useCallback((...Y) => z.current(...Y), [z]);
};
function E$2(B) {
  let z = B.width / 2, Y = B.height / 2;
  return { top: B.clientY - Y, right: B.clientX + z, bottom: B.clientY + Y, left: B.clientX - z };
}
function P$3(B, z) {
  return !(!B || !z || B.right < z.left || B.left > z.right || B.bottom < z.top || B.top > z.bottom);
}
function w$5({ disabled: B = !1 } = {}) {
  let z = useRef(null), [Y, ne] = useState(!1), ie = p$2(), oe = o$4(() => {
    z.current = null, ne(!1), ie.dispose();
  }), se = o$4((ae) => {
    if (ie.dispose(), z.current === null) {
      z.current = ae.currentTarget, ne(!0);
      {
        let ge = u$8(ae.currentTarget);
        ie.addEventListener(ge, "pointerup", oe, !1), ie.addEventListener(ge, "pointermove", (Ce) => {
          if (z.current) {
            let le = E$2(Ce);
            ne(P$3(le, z.current.getBoundingClientRect()));
          }
        }, !1), ie.addEventListener(ge, "pointercancel", oe, !1);
      }
    }
  });
  return { pressed: Y, pressProps: B ? {} : { onPointerDown: se, onPointerUp: oe, onClick: oe } };
}
let e$4 = createContext(void 0);
function a$b() {
  return useContext(e$4);
}
function t$3(...B) {
  return Array.from(new Set(B.flatMap((z) => typeof z == "string" ? z.split(" ") : []))).filter(Boolean).join(" ");
}
function u$7(B, z, ...Y) {
  if (B in z) {
    let ie = z[B];
    return typeof ie == "function" ? ie(...Y) : ie;
  }
  let ne = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(z).map((ie) => `"${ie}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(ne, u$7), ne;
}
var O$3 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$3 || {}), A$1 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(A$1 || {});
function L$1() {
  let B = U$3();
  return useCallback((z) => C$3({ mergeRefs: B, ...z }), [B]);
}
function C$3({ ourProps: B, theirProps: z, slot: Y, defaultTag: ne, features: ie, visible: oe = !0, name: se, mergeRefs: ae }) {
  ae = ae ?? $$1;
  let ge = P$2(z, B);
  if (oe) return F$2(ge, Y, ne, se, ae);
  let Ce = ie ?? 0;
  if (Ce & 2) {
    let { static: le = !1, ...Ee } = ge;
    if (le) return F$2(Ee, Y, ne, se, ae);
  }
  if (Ce & 1) {
    let { unmount: le = !0, ...Ee } = ge;
    return u$7(le ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F$2({ ...Ee, hidden: !0, style: { display: "none" } }, Y, ne, se, ae);
    } });
  }
  return F$2(ge, Y, ne, se, ae);
}
function F$2(B, z = {}, Y, ne, ie) {
  let { as: oe = Y, children: se, refName: ae = "ref", ...ge } = h$4(B, ["unmount", "static"]), Ce = B.ref !== void 0 ? { [ae]: B.ref } : {}, le = typeof se == "function" ? se(z) : se;
  "className" in ge && ge.className && typeof ge.className == "function" && (ge.className = ge.className(z)), ge["aria-labelledby"] && ge["aria-labelledby"] === ge.id && (ge["aria-labelledby"] = void 0);
  let Ee = {};
  if (z) {
    let Je = !1, Ve = [];
    for (let [$t, Nt] of Object.entries(z)) typeof Nt == "boolean" && (Je = !0), Nt === !0 && Ve.push($t.replace(/([A-Z])/g, (Dt) => `-${Dt.toLowerCase()}`));
    if (Je) {
      Ee["data-headlessui-state"] = Ve.join(" ");
      for (let $t of Ve) Ee[`data-${$t}`] = "";
    }
  }
  if (oe === Fragment && (Object.keys(m$4(ge)).length > 0 || Object.keys(m$4(Ee)).length > 0)) if (!isValidElement(le) || Array.isArray(le) && le.length > 1) {
    if (Object.keys(m$4(ge)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${ne} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(ge)).concat(Object.keys(m$4(Ee))).map((Je) => `  - ${Je}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((Je) => `  - ${Je}`).join(`
`)].join(`
`));
  } else {
    let Je = le.props, Ve = Je == null ? void 0 : Je.className, $t = typeof Ve == "function" ? (...Wt) => t$3(Ve(...Wt), ge.className) : t$3(Ve, ge.className), Nt = $t ? { className: $t } : {}, Dt = P$2(le.props, m$4(h$4(ge, ["ref"])));
    for (let Wt in Ee) Wt in Dt && delete Ee[Wt];
    return cloneElement(le, Object.assign({}, Dt, Ee, Ce, { ref: ie(H$3(le), Ce.ref) }, Nt));
  }
  return createElement(oe, Object.assign({}, h$4(ge, ["ref"]), oe !== Fragment && Ce, oe !== Fragment && Ee), le);
}
function U$3() {
  let B = useRef([]), z = useCallback((Y) => {
    for (let ne of B.current) ne != null && (typeof ne == "function" ? ne(Y) : ne.current = Y);
  }, []);
  return (...Y) => {
    if (!Y.every((ne) => ne == null)) return B.current = Y, z;
  };
}
function $$1(...B) {
  return B.every((z) => z == null) ? void 0 : (z) => {
    for (let Y of B) Y != null && (typeof Y == "function" ? Y(z) : Y.current = z);
  };
}
function P$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let ie in ne) ie.startsWith("on") && typeof ne[ie] == "function" ? (Y[ie] != null || (Y[ie] = []), Y[ie].push(ne[ie])) : z[ie] = ne[ie];
  if (z.disabled || z["aria-disabled"]) for (let ne in Y) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(ne) && (Y[ne] = [(ie) => {
    var oe;
    return (oe = ie == null ? void 0 : ie.preventDefault) == null ? void 0 : oe.call(ie);
  }]);
  for (let ne in Y) Object.assign(z, { [ne](ie, ...oe) {
    let se = Y[ne];
    for (let ae of se) {
      if ((ie instanceof Event || (ie == null ? void 0 : ie.nativeEvent) instanceof Event) && ie.defaultPrevented) return;
      ae(ie, ...oe);
    }
  } });
  return z;
}
function _$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let ie in ne) ie.startsWith("on") && typeof ne[ie] == "function" ? (Y[ie] != null || (Y[ie] = []), Y[ie].push(ne[ie])) : z[ie] = ne[ie];
  for (let ne in Y) Object.assign(z, { [ne](...ie) {
    let oe = Y[ne];
    for (let se of oe) se == null || se(...ie);
  } });
  return z;
}
function K$6(B) {
  var z;
  return Object.assign(forwardRef(B), { displayName: (z = B.displayName) != null ? z : B.name });
}
function m$4(B) {
  let z = Object.assign({}, B);
  for (let Y in z) z[Y] === void 0 && delete z[Y];
  return z;
}
function h$4(B, z = []) {
  let Y = Object.assign({}, B);
  for (let ne of z) ne in Y && delete Y[ne];
  return Y;
}
function H$3(B) {
  return React__default.version.split(".")[0] >= "19" ? B.props.ref : B.ref;
}
let a$a = "span";
var s$7 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$7 || {});
function l$2(B, z) {
  var Y;
  let { features: ne = 1, ...ie } = B, oe = { ref: z, "aria-hidden": (ne & 2) === 2 ? !0 : (Y = ie["aria-hidden"]) != null ? Y : void 0, hidden: (ne & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ne & 4) === 4 && (ne & 2) !== 2 && { display: "none" } } };
  return L$1()({ ourProps: oe, theirProps: ie, slot: {}, defaultTag: a$a, name: "Hidden" });
}
let f$a = K$6(l$2), e$3 = createContext(void 0);
function u$6() {
  return useContext(e$3);
}
function r$4(B) {
  let z = B.parentElement, Y = null;
  for (; z && !(z instanceof HTMLFieldSetElement); ) z instanceof HTMLLegendElement && (Y = z), z = z.parentElement;
  let ne = (z == null ? void 0 : z.getAttribute("disabled")) === "";
  return ne && i$6(Y) ? !1 : ne;
}
function i$6(B) {
  if (!B) return !1;
  let z = B.previousElementSibling;
  for (; z !== null; ) {
    if (z instanceof HTMLLegendElement) return !1;
    z = z.previousElementSibling;
  }
  return !0;
}
let u$5 = Symbol();
function T$2(B, z = !0) {
  return Object.assign(B, { [u$5]: z });
}
function y$4(...B) {
  let z = useRef(B);
  useEffect(() => {
    z.current = B;
  }, [B]);
  let Y = o$4((ne) => {
    for (let ie of z.current) ie != null && (typeof ie == "function" ? ie(ne) : ie.current = ne);
  });
  return B.every((ne) => ne == null || (ne == null ? void 0 : ne[u$5])) ? void 0 : Y;
}
let a$9 = createContext(null);
a$9.displayName = "DescriptionContext";
function f$9() {
  let B = useContext(a$9);
  if (B === null) {
    let z = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, f$9), z;
  }
  return B;
}
function w$4() {
  let [B, z] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(Y) {
    let ne = o$4((oe) => (z((se) => [...se, oe]), () => z((se) => {
      let ae = se.slice(), ge = ae.indexOf(oe);
      return ge !== -1 && ae.splice(ge, 1), ae;
    }))), ie = useMemo(() => ({ register: ne, slot: Y.slot, name: Y.name, props: Y.props, value: Y.value }), [ne, Y.slot, Y.name, Y.props, Y.value]);
    return React__default.createElement(a$9.Provider, { value: ie }, Y.children);
  }, [z])];
}
let S$2 = "p";
function C$2(B, z) {
  let Y = useId$1(), ne = a$b(), { id: ie = `headlessui-description-${Y}`, ...oe } = B, se = f$9(), ae = y$4(z);
  n$3(() => se.register(ie), [ie, se.register]);
  let ge = ne || !1, Ce = useMemo(() => ({ ...se.slot, disabled: ge }), [se.slot, ge]), le = { ref: ae, ...se.props, id: ie };
  return L$1()({ ourProps: le, theirProps: oe, slot: Ce, defaultTag: S$2, name: se.name || "Description" });
}
let _$1 = K$6(C$2), H$2 = Object.assign(_$1, {});
var o$3 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$3 || {});
let c$4 = createContext(null);
c$4.displayName = "LabelContext";
function P$1() {
  let B = useContext(c$4);
  if (B === null) {
    let z = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, P$1), z;
  }
  return B;
}
function I$3(B) {
  var z, Y, ne;
  let ie = (Y = (z = useContext(c$4)) == null ? void 0 : z.value) != null ? Y : void 0;
  return ((ne = void 0) != null ? ne : 0) > 0 ? [ie, ...B].filter(Boolean).join(" ") : ie;
}
function K$5({ inherit: B = !1 } = {}) {
  let z = I$3(), [Y, ne] = useState([]), ie = B ? [z, ...Y].filter(Boolean) : Y;
  return [ie.length > 0 ? ie.join(" ") : void 0, useMemo(() => function(oe) {
    let se = o$4((ge) => (ne((Ce) => [...Ce, ge]), () => ne((Ce) => {
      let le = Ce.slice(), Ee = le.indexOf(ge);
      return Ee !== -1 && le.splice(Ee, 1), le;
    }))), ae = useMemo(() => ({ register: se, slot: oe.slot, name: oe.name, props: oe.props, value: oe.value }), [se, oe.slot, oe.name, oe.props, oe.value]);
    return React__default.createElement(c$4.Provider, { value: ae }, oe.children);
  }, [ne])];
}
let N$1 = "label";
function G$2(B, z) {
  var Y;
  let ne = useId$1(), ie = P$1(), oe = u$6(), se = a$b(), { id: ae = `headlessui-label-${ne}`, htmlFor: ge = oe ?? ((Y = ie.props) == null ? void 0 : Y.htmlFor), passive: Ce = !1, ...le } = B, Ee = y$4(z);
  n$3(() => ie.register(ae), [ae, ie.register]);
  let Je = o$4((Dt) => {
    let Wt = Dt.currentTarget;
    if (Wt instanceof HTMLLabelElement && Dt.preventDefault(), ie.props && "onClick" in ie.props && typeof ie.props.onClick == "function" && ie.props.onClick(Dt), Wt instanceof HTMLLabelElement) {
      let Pt = document.getElementById(Wt.htmlFor);
      if (Pt) {
        let Lt = Pt.getAttribute("disabled");
        if (Lt === "true" || Lt === "") return;
        let qt = Pt.getAttribute("aria-disabled");
        if (qt === "true" || qt === "") return;
        (Pt instanceof HTMLInputElement && (Pt.type === "radio" || Pt.type === "checkbox") || Pt.role === "radio" || Pt.role === "checkbox" || Pt.role === "switch") && Pt.click(), Pt.focus({ preventScroll: !0 });
      }
    }
  }), Ve = se || !1, $t = useMemo(() => ({ ...ie.slot, disabled: Ve }), [ie.slot, Ve]), Nt = { ref: Ee, ...ie.props, id: ae, htmlFor: ge, onClick: Je };
  return Ce && ("onClick" in Nt && (delete Nt.htmlFor, delete Nt.onClick), "onClick" in le && delete le.onClick), L$1()({ ourProps: Nt, theirProps: le, slot: $t, defaultTag: ge ? N$1 : "div", name: ie.name || "Label" });
}
let U$2 = K$6(G$2);
Object.assign(U$2, {});
let e$2 = createContext(() => {
});
function C$1({ value: B, children: z }) {
  return React__default.createElement(e$2.Provider, { value: B }, z);
}
function f$8(B) {
  if (B === null) return { width: 0, height: 0 };
  let { width: z, height: Y } = B.getBoundingClientRect();
  return { width: z, height: Y };
}
function d$2(B, z = !1) {
  let [Y, ne] = useReducer(() => ({}), {}), ie = useMemo(() => f$8(B), [B, Y]);
  return n$3(() => {
    if (!B) return;
    let oe = new ResizeObserver(ne);
    return oe.observe(B), () => {
      oe.disconnect();
    };
  }, [B]), z ? { width: `${ie.width}px`, height: `${ie.height}px` } : ie;
}
let a$8 = class extends Map {
  constructor(z) {
    super(), this.factory = z;
  }
  get(z) {
    let Y = super.get(z);
    return Y === void 0 && (Y = this.factory(z), this.set(z, Y)), Y;
  }
};
function a$7(B, z) {
  let Y = B(), ne = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return Y;
  }, subscribe(ie) {
    return ne.add(ie), () => ne.delete(ie);
  }, dispatch(ie, ...oe) {
    let se = z[ie].call(Y, ...oe);
    se && (Y = se, ne.forEach((ae) => ae()));
  } };
}
function o$2(B) {
  return useSyncExternalStore(B.subscribe, B.getSnapshot, B.getSnapshot);
}
let p$1 = new a$8(() => a$7(() => [], { ADD(B) {
  return this.includes(B) ? this : [...this, B];
}, REMOVE(B) {
  let z = this.indexOf(B);
  if (z === -1) return this;
  let Y = this.slice();
  return Y.splice(z, 1), Y;
} }));
function x$3(B, z) {
  let Y = p$1.get(z), ne = useId$1(), ie = o$2(Y);
  if (n$3(() => {
    if (B) return Y.dispatch("ADD", ne), () => Y.dispatch("REMOVE", ne);
  }, [Y, B]), !B) return !1;
  let oe = ie.indexOf(ne), se = ie.length;
  return oe === -1 && (oe = se, se += 1), oe === se - 1;
}
let f$7 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();
function h$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 0;
  return u$4.set(B, Y + 1), Y !== 0 ? () => m$3(B) : (f$7.set(B, { "aria-hidden": B.getAttribute("aria-hidden"), inert: B.inert }), B.setAttribute("aria-hidden", "true"), B.inert = !0, () => m$3(B));
}
function m$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 1;
  if (Y === 1 ? u$4.delete(B) : u$4.set(B, Y - 1), Y !== 1) return;
  let ne = f$7.get(B);
  ne && (ne["aria-hidden"] === null ? B.removeAttribute("aria-hidden") : B.setAttribute("aria-hidden", ne["aria-hidden"]), B.inert = ne.inert, f$7.delete(B));
}
function y$3(B, { allowed: z, disallowed: Y } = {}) {
  let ne = x$3(B, "inert-others");
  n$3(() => {
    var ie, oe;
    if (!ne) return;
    let se = o$5();
    for (let ge of (ie = Y == null ? void 0 : Y()) != null ? ie : []) ge && se.add(h$3(ge));
    let ae = (oe = z == null ? void 0 : z()) != null ? oe : [];
    for (let ge of ae) {
      if (!ge) continue;
      let Ce = u$8(ge);
      if (!Ce) continue;
      let le = ge.parentElement;
      for (; le && le !== Ce.body; ) {
        for (let Ee of le.children) ae.some((Je) => Ee.contains(Je)) || se.add(h$3(Ee));
        le = le.parentElement;
      }
    }
    return se.dispose;
  }, [ne, z, Y]);
}
function m$2(B, z, Y) {
  let ne = s$8((ie) => {
    let oe = ie.getBoundingClientRect();
    oe.x === 0 && oe.y === 0 && oe.width === 0 && oe.height === 0 && Y();
  });
  useEffect(() => {
    if (!B) return;
    let ie = z === null ? null : z instanceof HTMLElement ? z : z.current;
    if (!ie) return;
    let oe = o$5();
    if (typeof ResizeObserver < "u") {
      let se = new ResizeObserver(() => ne.current(ie));
      se.observe(ie), oe.add(() => se.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let se = new IntersectionObserver(() => ne.current(ie));
      se.observe(ie), oe.add(() => se.disconnect());
    }
    return () => oe.dispose();
  }, [z, ne, B]);
}
let f$6 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var F$1 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B[B.AutoFocus = 64] = "AutoFocus", B))(F$1 || {}), T$1 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(T$1 || {}), y$2 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(y$2 || {});
function b$2(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(f$6)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$1(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(p)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(h$2 || {});
function A(B, z = 0) {
  var Y;
  return B === ((Y = u$8(B)) == null ? void 0 : Y.body) ? !1 : u$7(z, { 0() {
    return B.matches(f$6);
  }, 1() {
    let ne = B;
    for (; ne !== null; ) {
      if (ne.matches(f$6)) return !0;
      ne = ne.parentElement;
    }
    return !1;
  } });
}
function G$1(B) {
  let z = u$8(B);
  o$5().nextFrame(() => {
    z && !A(z.activeElement, 0) && I$2(B);
  });
}
var H$1 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(H$1 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I$2(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let w$3 = ["textarea", "input"].join(",");
function O$2(B) {
  var z, Y;
  return (Y = (z = B == null ? void 0 : B.matches) == null ? void 0 : z.call(B, w$3)) != null ? Y : !1;
}
function _(B, z = (Y) => Y) {
  return B.slice().sort((Y, ne) => {
    let ie = z(Y), oe = z(ne);
    if (ie === null || oe === null) return 0;
    let se = ie.compareDocumentPosition(oe);
    return se & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : se & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$3(B, z) {
  return P(b$2(), z, { relativeTo: B });
}
function P(B, z, { sorted: Y = !0, relativeTo: ne = null, skipElements: ie = [] } = {}) {
  let oe = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, se = Array.isArray(B) ? Y ? _(B) : B : z & 64 ? S$1(B) : b$2(B);
  ie.length > 0 && se.length > 1 && (se = se.filter((Ve) => !ie.some(($t) => $t != null && "current" in $t ? ($t == null ? void 0 : $t.current) === Ve : $t === Ve))), ne = ne ?? oe.activeElement;
  let ae = (() => {
    if (z & 5) return 1;
    if (z & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ge = (() => {
    if (z & 1) return 0;
    if (z & 2) return Math.max(0, se.indexOf(ne)) - 1;
    if (z & 4) return Math.max(0, se.indexOf(ne)) + 1;
    if (z & 8) return se.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Ce = z & 32 ? { preventScroll: !0 } : {}, le = 0, Ee = se.length, Je;
  do {
    if (le >= Ee || le + Ee <= 0) return 0;
    let Ve = ge + le;
    if (z & 16) Ve = (Ve + Ee) % Ee;
    else {
      if (Ve < 0) return 3;
      if (Ve >= Ee) return 1;
    }
    Je = se[Ve], Je == null || Je.focus(Ce), le += ae;
  } while (Je !== oe.activeElement);
  return z & 6 && O$2(Je) && Je.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$5() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$5();
}
function i$4(B, z, Y, ne) {
  let ie = s$8(Y);
  useEffect(() => {
    if (!B) return;
    function oe(se) {
      ie.current(se);
    }
    return document.addEventListener(z, oe, ne), () => document.removeEventListener(z, oe, ne);
  }, [B, z, ne]);
}
function s$6(B, z, Y, ne) {
  let ie = s$8(Y);
  useEffect(() => {
    if (!B) return;
    function oe(se) {
      ie.current(se);
    }
    return window.addEventListener(z, oe, ne), () => window.removeEventListener(z, oe, ne);
  }, [B, z, ne]);
}
const E$1 = 30;
function R$3(B, z, Y) {
  let ne = x$3(B, "outside-click"), ie = s$8(Y), oe = useCallback(function(ge, Ce) {
    if (ge.defaultPrevented) return;
    let le = Ce(ge);
    if (le === null || !le.getRootNode().contains(le) || !le.isConnected) return;
    let Ee = function Je(Ve) {
      return typeof Ve == "function" ? Je(Ve()) : Array.isArray(Ve) || Ve instanceof Set ? Ve : [Ve];
    }(z);
    for (let Je of Ee) if (Je !== null && (Je.contains(le) || ge.composed && ge.composedPath().includes(Je))) return;
    return !A(le, h$2.Loose) && le.tabIndex !== -1 && ge.preventDefault(), ie.current(ge, le);
  }, [ie, z]), se = useRef(null);
  i$4(ne, "pointerdown", (ge) => {
    var Ce, le;
    se.current = ((le = (Ce = ge.composedPath) == null ? void 0 : Ce.call(ge)) == null ? void 0 : le[0]) || ge.target;
  }, !0), i$4(ne, "mousedown", (ge) => {
    var Ce, le;
    se.current = ((le = (Ce = ge.composedPath) == null ? void 0 : Ce.call(ge)) == null ? void 0 : le[0]) || ge.target;
  }, !0), i$4(ne, "click", (ge) => {
    n$2() || se.current && (oe(ge, () => se.current), se.current = null);
  }, !0);
  let ae = useRef({ x: 0, y: 0 });
  i$4(ne, "touchstart", (ge) => {
    ae.current.x = ge.touches[0].clientX, ae.current.y = ge.touches[0].clientY;
  }, !0), i$4(ne, "touchend", (ge) => {
    let Ce = { x: ge.changedTouches[0].clientX, y: ge.changedTouches[0].clientY };
    if (!(Math.abs(Ce.x - ae.current.x) >= E$1 || Math.abs(Ce.y - ae.current.y) >= E$1)) return oe(ge, () => ge.target instanceof HTMLElement ? ge.target : null);
  }, !0), s$6(ne, "blur", (ge) => oe(ge, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$1(...B) {
  return useMemo(() => u$8(...B), [...B]);
}
function E(B, z, Y, ne) {
  let ie = s$8(Y);
  useEffect(() => {
    B = B ?? window;
    function oe(se) {
      ie.current(se);
    }
    return B.addEventListener(z, oe, ne), () => B.removeEventListener(z, oe, ne);
  }, [B, z, ne]);
}
function e$1(B, z) {
  return useMemo(() => {
    var Y;
    if (B.type) return B.type;
    let ne = (Y = B.as) != null ? Y : "button";
    if (typeof ne == "string" && ne.toLowerCase() === "button" || (z == null ? void 0 : z.tagName) === "BUTTON" && !z.hasAttribute("type")) return "button";
  }, [B.type, B.as, z]);
}
function d$1() {
  let B;
  return { before({ doc: z }) {
    var Y;
    let ne = z.documentElement, ie = (Y = z.defaultView) != null ? Y : window;
    B = Math.max(0, ie.innerWidth - ne.clientWidth);
  }, after({ doc: z, d: Y }) {
    let ne = z.documentElement, ie = Math.max(0, ne.clientWidth - ne.offsetWidth), oe = Math.max(0, B - ie);
    Y.style(ne, "paddingRight", `${oe}px`);
  } };
}
function d() {
  return t$2() ? { before({ doc: B, d: z, meta: Y }) {
    function ne(ie) {
      return Y.containers.flatMap((oe) => oe()).some((oe) => oe.contains(ie));
    }
    z.microTask(() => {
      var ie;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let ae = o$5();
        ae.style(B.documentElement, "scrollBehavior", "auto"), z.add(() => z.microTask(() => ae.dispose()));
      }
      let oe = (ie = window.scrollY) != null ? ie : window.pageYOffset, se = null;
      z.addEventListener(B, "click", (ae) => {
        if (ae.target instanceof HTMLElement) try {
          let ge = ae.target.closest("a");
          if (!ge) return;
          let { hash: Ce } = new URL(ge.href), le = B.querySelector(Ce);
          le && !ne(le) && (se = le);
        } catch {
        }
      }, !0), z.addEventListener(B, "touchstart", (ae) => {
        if (ae.target instanceof HTMLElement) if (ne(ae.target)) {
          let ge = ae.target;
          for (; ge.parentElement && ne(ge.parentElement); ) ge = ge.parentElement;
          z.style(ge, "overscrollBehavior", "contain");
        } else z.style(ae.target, "touchAction", "none");
      }), z.addEventListener(B, "touchmove", (ae) => {
        if (ae.target instanceof HTMLElement) {
          if (ae.target.tagName === "INPUT") return;
          if (ne(ae.target)) {
            let ge = ae.target;
            for (; ge.parentElement && ge.dataset.headlessuiPortal !== "" && !(ge.scrollHeight > ge.clientHeight || ge.scrollWidth > ge.clientWidth); ) ge = ge.parentElement;
            ge.dataset.headlessuiPortal === "" && ae.preventDefault();
          } else ae.preventDefault();
        }
      }, { passive: !1 }), z.add(() => {
        var ae;
        let ge = (ae = window.scrollY) != null ? ae : window.pageYOffset;
        oe !== ge && window.scrollTo(0, oe), se && se.isConnected && (se.scrollIntoView({ block: "nearest" }), se = null);
      });
    });
  } } : {};
}
function r$3() {
  return { before({ doc: B, d: z }) {
    z.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let z = {};
  for (let Y of B) Object.assign(z, Y(z));
  return z;
}
let a$6 = a$7(() => /* @__PURE__ */ new Map(), { PUSH(B, z) {
  var Y;
  let ne = (Y = this.get(B)) != null ? Y : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return ne.count++, ne.meta.add(z), this.set(B, ne), this;
}, POP(B, z) {
  let Y = this.get(B);
  return Y && (Y.count--, Y.meta.delete(z)), this;
}, SCROLL_PREVENT({ doc: B, d: z, meta: Y }) {
  let ne = { doc: B, d: z, meta: m$1(Y) }, ie = [d(), d$1(), r$3()];
  ie.forEach(({ before: oe }) => oe == null ? void 0 : oe(ne)), ie.forEach(({ after: oe }) => oe == null ? void 0 : oe(ne));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$6.subscribe(() => {
  let B = a$6.getSnapshot(), z = /* @__PURE__ */ new Map();
  for (let [Y] of B) z.set(Y, Y.documentElement.style.overflow);
  for (let Y of B.values()) {
    let ne = z.get(Y.doc) === "hidden", ie = Y.count !== 0;
    (ie && !ne || !ie && ne) && a$6.dispatch(Y.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", Y), Y.count === 0 && a$6.dispatch("TEARDOWN", Y);
  }
});
function a$5(B, z, Y = () => ({ containers: [] })) {
  let ne = o$2(a$6), ie = z ? ne.get(z) : void 0, oe = ie ? ie.count > 0 : !1;
  return n$3(() => {
    if (!(!z || !B)) return a$6.dispatch("PUSH", z, Y), () => a$6.dispatch("POP", z, Y);
  }, [B, z]), oe;
}
function f$5(B, z, Y = () => [document.body]) {
  let ne = x$3(B, "scroll-lock");
  a$5(ne, z, (ie) => {
    var oe;
    return { containers: [...(oe = ie.containers) != null ? oe : [], Y] };
  });
}
function t$1(B) {
  return [B.screenX, B.screenY];
}
function u$3() {
  let B = useRef([-1, -1]);
  return { wasMoved(z) {
    let Y = t$1(z);
    return B.current[0] === Y[0] && B.current[1] === Y[1] ? !1 : (B.current = Y, !0);
  }, update(z) {
    B.current = t$1(z);
  } };
}
function c$3(B = 0) {
  let [z, Y] = useState(B), ne = useCallback((ge) => Y(ge), [z]), ie = useCallback((ge) => Y((Ce) => Ce | ge), [z]), oe = useCallback((ge) => (z & ge) === ge, [z]), se = useCallback((ge) => Y((Ce) => Ce & ~ge), [Y]), ae = useCallback((ge) => Y((Ce) => Ce ^ ge), [Y]);
  return { flags: z, setFlag: ne, addFlag: ie, hasFlag: oe, removeFlag: se, toggleFlag: ae };
}
var T, b$1;
typeof process$1 < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T = process$1 == null ? void 0 : process$1.env) == null ? void 0 : T.NODE_ENV) === "test" && typeof ((b$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$1.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L = ((B) => (B[B.None = 0] = "None", B[B.Closed = 1] = "Closed", B[B.Enter = 2] = "Enter", B[B.Leave = 4] = "Leave", B))(L || {});
function R$2(B) {
  let z = {};
  for (let Y in B) B[Y] === !0 && (z[`data-${Y}`] = "");
  return z;
}
function x$2(B, z, Y, ne) {
  let [ie, oe] = useState(Y), { hasFlag: se, addFlag: ae, removeFlag: ge } = c$3(B && ie ? 3 : 0), Ce = useRef(!1), le = useRef(!1), Ee = p$2();
  return n$3(() => {
    var Je;
    if (B) {
      if (Y && oe(!0), !z) {
        Y && ae(3);
        return;
      }
      return (Je = ne == null ? void 0 : ne.start) == null || Je.call(ne, Y), C(z, { inFlight: Ce, prepare() {
        le.current ? le.current = !1 : le.current = Ce.current, Ce.current = !0, !le.current && (Y ? (ae(3), ge(4)) : (ae(4), ge(2)));
      }, run() {
        le.current ? Y ? (ge(3), ae(4)) : (ge(4), ae(3)) : Y ? ge(1) : ae(1);
      }, done() {
        var Ve;
        le.current && typeof z.getAnimations == "function" && z.getAnimations().length > 0 || (Ce.current = !1, ge(7), Y || oe(!1), (Ve = ne == null ? void 0 : ne.end) == null || Ve.call(ne, Y));
      } });
    }
  }, [B, Y, z, Ee]), B ? [ie, { closed: se(1), enter: se(2), leave: se(4), transition: se(2) || se(4) }] : [Y, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(B, { prepare: z, run: Y, done: ne, inFlight: ie }) {
  let oe = o$5();
  return j$2(B, { prepare: z, inFlight: ie }), oe.nextFrame(() => {
    Y(), oe.requestAnimationFrame(() => {
      oe.add(M$2(B, ne));
    });
  }), oe.dispose;
}
function M$2(B, z) {
  var Y, ne;
  let ie = o$5();
  if (!B) return ie.dispose;
  let oe = !1;
  ie.add(() => {
    oe = !0;
  });
  let se = (ne = (Y = B.getAnimations) == null ? void 0 : Y.call(B).filter((ae) => ae instanceof CSSTransition)) != null ? ne : [];
  return se.length === 0 ? (z(), ie.dispose) : (Promise.allSettled(se.map((ae) => ae.finished)).then(() => {
    oe || z();
  }), ie.dispose);
}
function j$2(B, { inFlight: z, prepare: Y }) {
  if (z != null && z.current) {
    Y();
    return;
  }
  let ne = B.style.transition;
  B.style.transition = "none", Y(), B.offsetHeight, B.style.transition = ne;
}
function F(B, { container: z, accept: Y, walk: ne }) {
  let ie = useRef(Y), oe = useRef(ne);
  useEffect(() => {
    ie.current = Y, oe.current = ne;
  }, [Y, ne]), n$3(() => {
    if (!z || !B) return;
    let se = u$8(z);
    if (!se) return;
    let ae = ie.current, ge = oe.current, Ce = Object.assign((Ee) => ae(Ee), { acceptNode: ae }), le = se.createTreeWalker(z, NodeFilter.SHOW_ELEMENT, Ce, !1);
    for (; le.nextNode(); ) ge(le.currentNode);
  }, [z, B, ie, oe]);
}
function m(B, z) {
  let Y = useRef([]), ne = o$4(B);
  useEffect(() => {
    let ie = [...Y.current];
    for (let [oe, se] of z.entries()) if (Y.current[oe] !== se) {
      let ae = ne(z, ie);
      return Y.current = z, ae;
    }
  }, [ne, ...z]);
}
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(B) {
  return isNode(B) ? (B.nodeName || "").toLowerCase() : "#document";
}
function getWindow(B) {
  var z;
  return (B == null || (z = B.ownerDocument) == null ? void 0 : z.defaultView) || window;
}
function getDocumentElement(B) {
  var z;
  return (z = (isNode(B) ? B.ownerDocument : B.document) || window.document) == null ? void 0 : z.documentElement;
}
function isNode(B) {
  return hasWindow() ? B instanceof Node || B instanceof getWindow(B).Node : !1;
}
function isElement(B) {
  return hasWindow() ? B instanceof Element || B instanceof getWindow(B).Element : !1;
}
function isHTMLElement(B) {
  return hasWindow() ? B instanceof HTMLElement || B instanceof getWindow(B).HTMLElement : !1;
}
function isShadowRoot(B) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : B instanceof ShadowRoot || B instanceof getWindow(B).ShadowRoot;
}
function isOverflowElement(B) {
  const {
    overflow: z,
    overflowX: Y,
    overflowY: ne,
    display: ie
  } = getComputedStyle$1(B);
  return /auto|scroll|overlay|hidden|clip/.test(z + ne + Y) && !["inline", "contents"].includes(ie);
}
function isTableElement(B) {
  return ["table", "td", "th"].includes(getNodeName(B));
}
function isTopLayer(B) {
  return [":popover-open", ":modal"].some((z) => {
    try {
      return B.matches(z);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(B) {
  const z = isWebKit(), Y = isElement(B) ? getComputedStyle$1(B) : B;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((ne) => Y[ne] ? Y[ne] !== "none" : !1) || (Y.containerType ? Y.containerType !== "normal" : !1) || !z && (Y.backdropFilter ? Y.backdropFilter !== "none" : !1) || !z && (Y.filter ? Y.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((ne) => (Y.willChange || "").includes(ne)) || ["paint", "layout", "strict", "content"].some((ne) => (Y.contain || "").includes(ne));
}
function getContainingBlock(B) {
  let z = getParentNode(B);
  for (; isHTMLElement(z) && !isLastTraversableNode(z); ) {
    if (isContainingBlock(z))
      return z;
    if (isTopLayer(z))
      return null;
    z = getParentNode(z);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(B) {
  return ["html", "body", "#document"].includes(getNodeName(B));
}
function getComputedStyle$1(B) {
  return getWindow(B).getComputedStyle(B);
}
function getNodeScroll(B) {
  return isElement(B) ? {
    scrollLeft: B.scrollLeft,
    scrollTop: B.scrollTop
  } : {
    scrollLeft: B.scrollX,
    scrollTop: B.scrollY
  };
}
function getParentNode(B) {
  if (getNodeName(B) === "html")
    return B;
  const z = (
    // Step into the shadow DOM of the parent of a slotted node.
    B.assignedSlot || // DOM Element detected.
    B.parentNode || // ShadowRoot detected.
    isShadowRoot(B) && B.host || // Fallback.
    getDocumentElement(B)
  );
  return isShadowRoot(z) ? z.host : z;
}
function getNearestOverflowAncestor(B) {
  const z = getParentNode(B);
  return isLastTraversableNode(z) ? B.ownerDocument ? B.ownerDocument.body : B.body : isHTMLElement(z) && isOverflowElement(z) ? z : getNearestOverflowAncestor(z);
}
function getOverflowAncestors(B, z, Y) {
  var ne;
  z === void 0 && (z = []), Y === void 0 && (Y = !0);
  const ie = getNearestOverflowAncestor(B), oe = ie === ((ne = B.ownerDocument) == null ? void 0 : ne.body), se = getWindow(ie);
  if (oe) {
    const ae = getFrameElement(se);
    return z.concat(se, se.visualViewport || [], isOverflowElement(ie) ? ie : [], ae && Y ? getOverflowAncestors(ae) : []);
  }
  return z.concat(ie, getOverflowAncestors(ie, [], Y));
}
function getFrameElement(B) {
  return B.parent && Object.getPrototypeOf(B.parent) ? B.frameElement : null;
}
function getUserAgent() {
  const B = navigator.userAgentData;
  return B && Array.isArray(B.brands) ? B.brands.map((z) => {
    let {
      brand: Y,
      version: ne
    } = z;
    return Y + "/" + ne;
  }).join(" ") : navigator.userAgent;
}
const min$2 = Math.min, max$3 = Math.max, round$2 = Math.round, floor$2 = Math.floor, createCoords = (B) => ({
  x: B,
  y: B
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(B, z, Y) {
  return max$3(B, min$2(z, Y));
}
function evaluate(B, z) {
  return typeof B == "function" ? B(z) : B;
}
function getSide(B) {
  return B.split("-")[0];
}
function getAlignment(B) {
  return B.split("-")[1];
}
function getOppositeAxis(B) {
  return B === "x" ? "y" : "x";
}
function getAxisLength(B) {
  return B === "y" ? "height" : "width";
}
function getSideAxis(B) {
  return ["top", "bottom"].includes(getSide(B)) ? "y" : "x";
}
function getAlignmentAxis(B) {
  return getOppositeAxis(getSideAxis(B));
}
function getAlignmentSides(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = getAlignment(B), ie = getAlignmentAxis(B), oe = getAxisLength(ie);
  let se = ie === "x" ? ne === (Y ? "end" : "start") ? "right" : "left" : ne === "start" ? "bottom" : "top";
  return z.reference[oe] > z.floating[oe] && (se = getOppositePlacement(se)), [se, getOppositePlacement(se)];
}
function getExpandedPlacements(B) {
  const z = getOppositePlacement(B);
  return [getOppositeAlignmentPlacement(B), z, getOppositeAlignmentPlacement(z)];
}
function getOppositeAlignmentPlacement(B) {
  return B.replace(/start|end/g, (z) => oppositeAlignmentMap[z]);
}
function getSideList(B, z, Y) {
  const ne = ["left", "right"], ie = ["right", "left"], oe = ["top", "bottom"], se = ["bottom", "top"];
  switch (B) {
    case "top":
    case "bottom":
      return Y ? z ? ie : ne : z ? ne : ie;
    case "left":
    case "right":
      return z ? oe : se;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(B, z, Y, ne) {
  const ie = getAlignment(B);
  let oe = getSideList(getSide(B), Y === "start", ne);
  return ie && (oe = oe.map((se) => se + "-" + ie), z && (oe = oe.concat(oe.map(getOppositeAlignmentPlacement)))), oe;
}
function getOppositePlacement(B) {
  return B.replace(/left|right|bottom|top/g, (z) => oppositeSideMap[z]);
}
function expandPaddingObject(B) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...B
  };
}
function getPaddingObject(B) {
  return typeof B != "number" ? expandPaddingObject(B) : {
    top: B,
    right: B,
    bottom: B,
    left: B
  };
}
function rectToClientRect(B) {
  const {
    x: z,
    y: Y,
    width: ne,
    height: ie
  } = B;
  return {
    width: ne,
    height: ie,
    top: Y,
    left: z,
    right: z + ne,
    bottom: Y + ie,
    x: z,
    y: Y
  };
}
function computeCoordsFromPlacement(B, z, Y) {
  let {
    reference: ne,
    floating: ie
  } = B;
  const oe = getSideAxis(z), se = getAlignmentAxis(z), ae = getAxisLength(se), ge = getSide(z), Ce = oe === "y", le = ne.x + ne.width / 2 - ie.width / 2, Ee = ne.y + ne.height / 2 - ie.height / 2, Je = ne[ae] / 2 - ie[ae] / 2;
  let Ve;
  switch (ge) {
    case "top":
      Ve = {
        x: le,
        y: ne.y - ie.height
      };
      break;
    case "bottom":
      Ve = {
        x: le,
        y: ne.y + ne.height
      };
      break;
    case "right":
      Ve = {
        x: ne.x + ne.width,
        y: Ee
      };
      break;
    case "left":
      Ve = {
        x: ne.x - ie.width,
        y: Ee
      };
      break;
    default:
      Ve = {
        x: ne.x,
        y: ne.y
      };
  }
  switch (getAlignment(z)) {
    case "start":
      Ve[se] -= Je * (Y && Ce ? -1 : 1);
      break;
    case "end":
      Ve[se] += Je * (Y && Ce ? -1 : 1);
      break;
  }
  return Ve;
}
const computePosition$1 = async (B, z, Y) => {
  const {
    placement: ne = "bottom",
    strategy: ie = "absolute",
    middleware: oe = [],
    platform: se
  } = Y, ae = oe.filter(Boolean), ge = await (se.isRTL == null ? void 0 : se.isRTL(z));
  let Ce = await se.getElementRects({
    reference: B,
    floating: z,
    strategy: ie
  }), {
    x: le,
    y: Ee
  } = computeCoordsFromPlacement(Ce, ne, ge), Je = ne, Ve = {}, $t = 0;
  for (let Nt = 0; Nt < ae.length; Nt++) {
    const {
      name: Dt,
      fn: Wt
    } = ae[Nt], {
      x: Pt,
      y: Lt,
      data: qt,
      reset: Zt
    } = await Wt({
      x: le,
      y: Ee,
      initialPlacement: ne,
      placement: Je,
      strategy: ie,
      middlewareData: Ve,
      rects: Ce,
      platform: se,
      elements: {
        reference: B,
        floating: z
      }
    });
    le = Pt ?? le, Ee = Lt ?? Ee, Ve = {
      ...Ve,
      [Dt]: {
        ...Ve[Dt],
        ...qt
      }
    }, Zt && $t <= 50 && ($t++, typeof Zt == "object" && (Zt.placement && (Je = Zt.placement), Zt.rects && (Ce = Zt.rects === !0 ? await se.getElementRects({
      reference: B,
      floating: z,
      strategy: ie
    }) : Zt.rects), {
      x: le,
      y: Ee
    } = computeCoordsFromPlacement(Ce, Je, ge)), Nt = -1);
  }
  return {
    x: le,
    y: Ee,
    placement: Je,
    strategy: ie,
    middlewareData: Ve
  };
};
async function detectOverflow$1(B, z) {
  var Y;
  z === void 0 && (z = {});
  const {
    x: ne,
    y: ie,
    platform: oe,
    rects: se,
    elements: ae,
    strategy: ge
  } = B, {
    boundary: Ce = "clippingAncestors",
    rootBoundary: le = "viewport",
    elementContext: Ee = "floating",
    altBoundary: Je = !1,
    padding: Ve = 0
  } = evaluate(z, B), $t = getPaddingObject(Ve), Dt = ae[Je ? Ee === "floating" ? "reference" : "floating" : Ee], Wt = rectToClientRect(await oe.getClippingRect({
    element: (Y = await (oe.isElement == null ? void 0 : oe.isElement(Dt))) == null || Y ? Dt : Dt.contextElement || await (oe.getDocumentElement == null ? void 0 : oe.getDocumentElement(ae.floating)),
    boundary: Ce,
    rootBoundary: le,
    strategy: ge
  })), Pt = Ee === "floating" ? {
    x: ne,
    y: ie,
    width: se.floating.width,
    height: se.floating.height
  } : se.reference, Lt = await (oe.getOffsetParent == null ? void 0 : oe.getOffsetParent(ae.floating)), qt = await (oe.isElement == null ? void 0 : oe.isElement(Lt)) ? await (oe.getScale == null ? void 0 : oe.getScale(Lt)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Zt = rectToClientRect(oe.convertOffsetParentRelativeRectToViewportRelativeRect ? await oe.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: ae,
    rect: Pt,
    offsetParent: Lt,
    strategy: ge
  }) : Pt);
  return {
    top: (Wt.top - Zt.top + $t.top) / qt.y,
    bottom: (Zt.bottom - Wt.bottom + $t.bottom) / qt.y,
    left: (Wt.left - Zt.left + $t.left) / qt.x,
    right: (Zt.right - Wt.right + $t.right) / qt.x
  };
}
const flip$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "flip",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: ie,
        middlewareData: oe,
        rects: se,
        initialPlacement: ae,
        platform: ge,
        elements: Ce
      } = z, {
        mainAxis: le = !0,
        crossAxis: Ee = !0,
        fallbackPlacements: Je,
        fallbackStrategy: Ve = "bestFit",
        fallbackAxisSideDirection: $t = "none",
        flipAlignment: Nt = !0,
        ...Dt
      } = evaluate(B, z);
      if ((Y = oe.arrow) != null && Y.alignmentOffset)
        return {};
      const Wt = getSide(ie), Pt = getSideAxis(ae), Lt = getSide(ae) === ae, qt = await (ge.isRTL == null ? void 0 : ge.isRTL(Ce.floating)), Zt = Je || (Lt || !Nt ? [getOppositePlacement(ae)] : getExpandedPlacements(ae)), Yt = $t !== "none";
      !Je && Yt && Zt.push(...getOppositeAxisPlacements(ae, Nt, $t, qt));
      const or = [ae, ...Zt], jt = await detectOverflow$1(z, Dt), Ct = [];
      let Vt = ((ne = oe.flip) == null ? void 0 : ne.overflows) || [];
      if (le && Ct.push(jt[Wt]), Ee) {
        const ve = getAlignmentSides(ie, se, qt);
        Ct.push(jt[ve[0]], jt[ve[1]]);
      }
      if (Vt = [...Vt, {
        placement: ie,
        overflows: Ct
      }], !Ct.every((ve) => ve <= 0)) {
        var kt, Pe;
        const ve = (((kt = oe.flip) == null ? void 0 : kt.index) || 0) + 1, Ke = or[ve];
        if (Ke)
          return {
            data: {
              index: ve,
              overflows: Vt
            },
            reset: {
              placement: Ke
            }
          };
        let ht = (Pe = Vt.filter((wt) => wt.overflows[0] <= 0).sort((wt, vt) => wt.overflows[1] - vt.overflows[1])[0]) == null ? void 0 : Pe.placement;
        if (!ht)
          switch (Ve) {
            case "bestFit": {
              var Xe;
              const wt = (Xe = Vt.filter((vt) => {
                if (Yt) {
                  const xt = getSideAxis(vt.placement);
                  return xt === Pt || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  xt === "y";
                }
                return !0;
              }).map((vt) => [vt.placement, vt.overflows.filter((xt) => xt > 0).reduce((xt, Qe) => xt + Qe, 0)]).sort((vt, xt) => vt[1] - xt[1])[0]) == null ? void 0 : Xe[0];
              wt && (ht = wt);
              break;
            }
            case "initialPlacement":
              ht = ae;
              break;
          }
        if (ie !== ht)
          return {
            reset: {
              placement: ht
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(B, z) {
  const {
    placement: Y,
    platform: ne,
    elements: ie
  } = B, oe = await (ne.isRTL == null ? void 0 : ne.isRTL(ie.floating)), se = getSide(Y), ae = getAlignment(Y), ge = getSideAxis(Y) === "y", Ce = ["left", "top"].includes(se) ? -1 : 1, le = oe && ge ? -1 : 1, Ee = evaluate(z, B);
  let {
    mainAxis: Je,
    crossAxis: Ve,
    alignmentAxis: $t
  } = typeof Ee == "number" ? {
    mainAxis: Ee,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: Ee.mainAxis || 0,
    crossAxis: Ee.crossAxis || 0,
    alignmentAxis: Ee.alignmentAxis
  };
  return ae && typeof $t == "number" && (Ve = ae === "end" ? $t * -1 : $t), ge ? {
    x: Ve * le,
    y: Je * Ce
  } : {
    x: Je * Ce,
    y: Ve * le
  };
}
const offset$2 = function(B) {
  return B === void 0 && (B = 0), {
    name: "offset",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        x: ie,
        y: oe,
        placement: se,
        middlewareData: ae
      } = z, ge = await convertValueToCoords(z, B);
      return se === ((Y = ae.offset) == null ? void 0 : Y.placement) && (ne = ae.arrow) != null && ne.alignmentOffset ? {} : {
        x: ie + ge.x,
        y: oe + ge.y,
        data: {
          ...ge,
          placement: se
        }
      };
    }
  };
}, shift$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "shift",
    options: B,
    async fn(z) {
      const {
        x: Y,
        y: ne,
        placement: ie
      } = z, {
        mainAxis: oe = !0,
        crossAxis: se = !1,
        limiter: ae = {
          fn: (Dt) => {
            let {
              x: Wt,
              y: Pt
            } = Dt;
            return {
              x: Wt,
              y: Pt
            };
          }
        },
        ...ge
      } = evaluate(B, z), Ce = {
        x: Y,
        y: ne
      }, le = await detectOverflow$1(z, ge), Ee = getSideAxis(getSide(ie)), Je = getOppositeAxis(Ee);
      let Ve = Ce[Je], $t = Ce[Ee];
      if (oe) {
        const Dt = Je === "y" ? "top" : "left", Wt = Je === "y" ? "bottom" : "right", Pt = Ve + le[Dt], Lt = Ve - le[Wt];
        Ve = clamp(Pt, Ve, Lt);
      }
      if (se) {
        const Dt = Ee === "y" ? "top" : "left", Wt = Ee === "y" ? "bottom" : "right", Pt = $t + le[Dt], Lt = $t - le[Wt];
        $t = clamp(Pt, $t, Lt);
      }
      const Nt = ae.fn({
        ...z,
        [Je]: Ve,
        [Ee]: $t
      });
      return {
        ...Nt,
        data: {
          x: Nt.x - Y,
          y: Nt.y - ne,
          enabled: {
            [Je]: oe,
            [Ee]: se
          }
        }
      };
    }
  };
}, size$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "size",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: ie,
        rects: oe,
        platform: se,
        elements: ae
      } = z, {
        apply: ge = () => {
        },
        ...Ce
      } = evaluate(B, z), le = await detectOverflow$1(z, Ce), Ee = getSide(ie), Je = getAlignment(ie), Ve = getSideAxis(ie) === "y", {
        width: $t,
        height: Nt
      } = oe.floating;
      let Dt, Wt;
      Ee === "top" || Ee === "bottom" ? (Dt = Ee, Wt = Je === (await (se.isRTL == null ? void 0 : se.isRTL(ae.floating)) ? "start" : "end") ? "left" : "right") : (Wt = Ee, Dt = Je === "end" ? "top" : "bottom");
      const Pt = Nt - le.top - le.bottom, Lt = $t - le.left - le.right, qt = min$2(Nt - le[Dt], Pt), Zt = min$2($t - le[Wt], Lt), Yt = !z.middlewareData.shift;
      let or = qt, jt = Zt;
      if ((Y = z.middlewareData.shift) != null && Y.enabled.x && (jt = Lt), (ne = z.middlewareData.shift) != null && ne.enabled.y && (or = Pt), Yt && !Je) {
        const Vt = max$3(le.left, 0), kt = max$3(le.right, 0), Pe = max$3(le.top, 0), Xe = max$3(le.bottom, 0);
        Ve ? jt = $t - 2 * (Vt !== 0 || kt !== 0 ? Vt + kt : max$3(le.left, le.right)) : or = Nt - 2 * (Pe !== 0 || Xe !== 0 ? Pe + Xe : max$3(le.top, le.bottom));
      }
      await ge({
        ...z,
        availableWidth: jt,
        availableHeight: or
      });
      const Ct = await se.getDimensions(ae.floating);
      return $t !== Ct.width || Nt !== Ct.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(B) {
  const z = getComputedStyle$1(B);
  let Y = parseFloat(z.width) || 0, ne = parseFloat(z.height) || 0;
  const ie = isHTMLElement(B), oe = ie ? B.offsetWidth : Y, se = ie ? B.offsetHeight : ne, ae = round$2(Y) !== oe || round$2(ne) !== se;
  return ae && (Y = oe, ne = se), {
    width: Y,
    height: ne,
    $: ae
  };
}
function unwrapElement(B) {
  return isElement(B) ? B : B.contextElement;
}
function getScale(B) {
  const z = unwrapElement(B);
  if (!isHTMLElement(z))
    return createCoords(1);
  const Y = z.getBoundingClientRect(), {
    width: ne,
    height: ie,
    $: oe
  } = getCssDimensions(z);
  let se = (oe ? round$2(Y.width) : Y.width) / ne, ae = (oe ? round$2(Y.height) : Y.height) / ie;
  return (!se || !Number.isFinite(se)) && (se = 1), (!ae || !Number.isFinite(ae)) && (ae = 1), {
    x: se,
    y: ae
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(B) {
  const z = getWindow(B);
  return !isWebKit() || !z.visualViewport ? noOffsets : {
    x: z.visualViewport.offsetLeft,
    y: z.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(B, z, Y) {
  return z === void 0 && (z = !1), !Y || z && Y !== getWindow(B) ? !1 : z;
}
function getBoundingClientRect(B, z, Y, ne) {
  z === void 0 && (z = !1), Y === void 0 && (Y = !1);
  const ie = B.getBoundingClientRect(), oe = unwrapElement(B);
  let se = createCoords(1);
  z && (ne ? isElement(ne) && (se = getScale(ne)) : se = getScale(B));
  const ae = shouldAddVisualOffsets(oe, Y, ne) ? getVisualOffsets(oe) : createCoords(0);
  let ge = (ie.left + ae.x) / se.x, Ce = (ie.top + ae.y) / se.y, le = ie.width / se.x, Ee = ie.height / se.y;
  if (oe) {
    const Je = getWindow(oe), Ve = ne && isElement(ne) ? getWindow(ne) : ne;
    let $t = Je, Nt = getFrameElement($t);
    for (; Nt && ne && Ve !== $t; ) {
      const Dt = getScale(Nt), Wt = Nt.getBoundingClientRect(), Pt = getComputedStyle$1(Nt), Lt = Wt.left + (Nt.clientLeft + parseFloat(Pt.paddingLeft)) * Dt.x, qt = Wt.top + (Nt.clientTop + parseFloat(Pt.paddingTop)) * Dt.y;
      ge *= Dt.x, Ce *= Dt.y, le *= Dt.x, Ee *= Dt.y, ge += Lt, Ce += qt, $t = getWindow(Nt), Nt = getFrameElement($t);
    }
  }
  return rectToClientRect({
    width: le,
    height: Ee,
    x: ge,
    y: Ce
  });
}
function getWindowScrollBarX(B, z) {
  const Y = getNodeScroll(B).scrollLeft;
  return z ? z.left + Y : getBoundingClientRect(getDocumentElement(B)).left + Y;
}
function getHTMLOffset(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = B.getBoundingClientRect(), ie = ne.left + z.scrollLeft - (Y ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(B, ne)
  )), oe = ne.top + z.scrollTop;
  return {
    x: ie,
    y: oe
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(B) {
  let {
    elements: z,
    rect: Y,
    offsetParent: ne,
    strategy: ie
  } = B;
  const oe = ie === "fixed", se = getDocumentElement(ne), ae = z ? isTopLayer(z.floating) : !1;
  if (ne === se || ae && oe)
    return Y;
  let ge = {
    scrollLeft: 0,
    scrollTop: 0
  }, Ce = createCoords(1);
  const le = createCoords(0), Ee = isHTMLElement(ne);
  if ((Ee || !Ee && !oe) && ((getNodeName(ne) !== "body" || isOverflowElement(se)) && (ge = getNodeScroll(ne)), isHTMLElement(ne))) {
    const Ve = getBoundingClientRect(ne);
    Ce = getScale(ne), le.x = Ve.x + ne.clientLeft, le.y = Ve.y + ne.clientTop;
  }
  const Je = se && !Ee && !oe ? getHTMLOffset(se, ge, !0) : createCoords(0);
  return {
    width: Y.width * Ce.x,
    height: Y.height * Ce.y,
    x: Y.x * Ce.x - ge.scrollLeft * Ce.x + le.x + Je.x,
    y: Y.y * Ce.y - ge.scrollTop * Ce.y + le.y + Je.y
  };
}
function getClientRects(B) {
  return Array.from(B.getClientRects());
}
function getDocumentRect(B) {
  const z = getDocumentElement(B), Y = getNodeScroll(B), ne = B.ownerDocument.body, ie = max$3(z.scrollWidth, z.clientWidth, ne.scrollWidth, ne.clientWidth), oe = max$3(z.scrollHeight, z.clientHeight, ne.scrollHeight, ne.clientHeight);
  let se = -Y.scrollLeft + getWindowScrollBarX(B);
  const ae = -Y.scrollTop;
  return getComputedStyle$1(ne).direction === "rtl" && (se += max$3(z.clientWidth, ne.clientWidth) - ie), {
    width: ie,
    height: oe,
    x: se,
    y: ae
  };
}
function getViewportRect(B, z) {
  const Y = getWindow(B), ne = getDocumentElement(B), ie = Y.visualViewport;
  let oe = ne.clientWidth, se = ne.clientHeight, ae = 0, ge = 0;
  if (ie) {
    oe = ie.width, se = ie.height;
    const Ce = isWebKit();
    (!Ce || Ce && z === "fixed") && (ae = ie.offsetLeft, ge = ie.offsetTop);
  }
  return {
    width: oe,
    height: se,
    x: ae,
    y: ge
  };
}
function getInnerBoundingClientRect(B, z) {
  const Y = getBoundingClientRect(B, !0, z === "fixed"), ne = Y.top + B.clientTop, ie = Y.left + B.clientLeft, oe = isHTMLElement(B) ? getScale(B) : createCoords(1), se = B.clientWidth * oe.x, ae = B.clientHeight * oe.y, ge = ie * oe.x, Ce = ne * oe.y;
  return {
    width: se,
    height: ae,
    x: ge,
    y: Ce
  };
}
function getClientRectFromClippingAncestor(B, z, Y) {
  let ne;
  if (z === "viewport")
    ne = getViewportRect(B, Y);
  else if (z === "document")
    ne = getDocumentRect(getDocumentElement(B));
  else if (isElement(z))
    ne = getInnerBoundingClientRect(z, Y);
  else {
    const ie = getVisualOffsets(B);
    ne = {
      x: z.x - ie.x,
      y: z.y - ie.y,
      width: z.width,
      height: z.height
    };
  }
  return rectToClientRect(ne);
}
function hasFixedPositionAncestor(B, z) {
  const Y = getParentNode(B);
  return Y === z || !isElement(Y) || isLastTraversableNode(Y) ? !1 : getComputedStyle$1(Y).position === "fixed" || hasFixedPositionAncestor(Y, z);
}
function getClippingElementAncestors(B, z) {
  const Y = z.get(B);
  if (Y)
    return Y;
  let ne = getOverflowAncestors(B, [], !1).filter((ae) => isElement(ae) && getNodeName(ae) !== "body"), ie = null;
  const oe = getComputedStyle$1(B).position === "fixed";
  let se = oe ? getParentNode(B) : B;
  for (; isElement(se) && !isLastTraversableNode(se); ) {
    const ae = getComputedStyle$1(se), ge = isContainingBlock(se);
    !ge && ae.position === "fixed" && (ie = null), (oe ? !ge && !ie : !ge && ae.position === "static" && !!ie && ["absolute", "fixed"].includes(ie.position) || isOverflowElement(se) && !ge && hasFixedPositionAncestor(B, se)) ? ne = ne.filter((le) => le !== se) : ie = ae, se = getParentNode(se);
  }
  return z.set(B, ne), ne;
}
function getClippingRect(B) {
  let {
    element: z,
    boundary: Y,
    rootBoundary: ne,
    strategy: ie
  } = B;
  const se = [...Y === "clippingAncestors" ? isTopLayer(z) ? [] : getClippingElementAncestors(z, this._c) : [].concat(Y), ne], ae = se[0], ge = se.reduce((Ce, le) => {
    const Ee = getClientRectFromClippingAncestor(z, le, ie);
    return Ce.top = max$3(Ee.top, Ce.top), Ce.right = min$2(Ee.right, Ce.right), Ce.bottom = min$2(Ee.bottom, Ce.bottom), Ce.left = max$3(Ee.left, Ce.left), Ce;
  }, getClientRectFromClippingAncestor(z, ae, ie));
  return {
    width: ge.right - ge.left,
    height: ge.bottom - ge.top,
    x: ge.left,
    y: ge.top
  };
}
function getDimensions(B) {
  const {
    width: z,
    height: Y
  } = getCssDimensions(B);
  return {
    width: z,
    height: Y
  };
}
function getRectRelativeToOffsetParent(B, z, Y) {
  const ne = isHTMLElement(z), ie = getDocumentElement(z), oe = Y === "fixed", se = getBoundingClientRect(B, !0, oe, z);
  let ae = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ge = createCoords(0);
  if (ne || !ne && !oe)
    if ((getNodeName(z) !== "body" || isOverflowElement(ie)) && (ae = getNodeScroll(z)), ne) {
      const Je = getBoundingClientRect(z, !0, oe, z);
      ge.x = Je.x + z.clientLeft, ge.y = Je.y + z.clientTop;
    } else ie && (ge.x = getWindowScrollBarX(ie));
  const Ce = ie && !ne && !oe ? getHTMLOffset(ie, ae) : createCoords(0), le = se.left + ae.scrollLeft - ge.x - Ce.x, Ee = se.top + ae.scrollTop - ge.y - Ce.y;
  return {
    x: le,
    y: Ee,
    width: se.width,
    height: se.height
  };
}
function isStaticPositioned(B) {
  return getComputedStyle$1(B).position === "static";
}
function getTrueOffsetParent(B, z) {
  if (!isHTMLElement(B) || getComputedStyle$1(B).position === "fixed")
    return null;
  if (z)
    return z(B);
  let Y = B.offsetParent;
  return getDocumentElement(B) === Y && (Y = Y.ownerDocument.body), Y;
}
function getOffsetParent(B, z) {
  const Y = getWindow(B);
  if (isTopLayer(B))
    return Y;
  if (!isHTMLElement(B)) {
    let ie = getParentNode(B);
    for (; ie && !isLastTraversableNode(ie); ) {
      if (isElement(ie) && !isStaticPositioned(ie))
        return ie;
      ie = getParentNode(ie);
    }
    return Y;
  }
  let ne = getTrueOffsetParent(B, z);
  for (; ne && isTableElement(ne) && isStaticPositioned(ne); )
    ne = getTrueOffsetParent(ne, z);
  return ne && isLastTraversableNode(ne) && isStaticPositioned(ne) && !isContainingBlock(ne) ? Y : ne || getContainingBlock(B) || Y;
}
const getElementRects = async function(B) {
  const z = this.getOffsetParent || getOffsetParent, Y = this.getDimensions, ne = await Y(B.floating);
  return {
    reference: getRectRelativeToOffsetParent(B.reference, await z(B.floating), B.strategy),
    floating: {
      x: 0,
      y: 0,
      width: ne.width,
      height: ne.height
    }
  };
};
function isRTL(B) {
  return getComputedStyle$1(B).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(B, z) {
  return B.x === z.x && B.y === z.y && B.width === z.width && B.height === z.height;
}
function observeMove(B, z) {
  let Y = null, ne;
  const ie = getDocumentElement(B);
  function oe() {
    var ae;
    clearTimeout(ne), (ae = Y) == null || ae.disconnect(), Y = null;
  }
  function se(ae, ge) {
    ae === void 0 && (ae = !1), ge === void 0 && (ge = 1), oe();
    const Ce = B.getBoundingClientRect(), {
      left: le,
      top: Ee,
      width: Je,
      height: Ve
    } = Ce;
    if (ae || z(), !Je || !Ve)
      return;
    const $t = floor$2(Ee), Nt = floor$2(ie.clientWidth - (le + Je)), Dt = floor$2(ie.clientHeight - (Ee + Ve)), Wt = floor$2(le), Lt = {
      rootMargin: -$t + "px " + -Nt + "px " + -Dt + "px " + -Wt + "px",
      threshold: max$3(0, min$2(1, ge)) || 1
    };
    let qt = !0;
    function Zt(Yt) {
      const or = Yt[0].intersectionRatio;
      if (or !== ge) {
        if (!qt)
          return se();
        or ? se(!1, or) : ne = setTimeout(() => {
          se(!1, 1e-7);
        }, 1e3);
      }
      or === 1 && !rectsAreEqual(Ce, B.getBoundingClientRect()) && se(), qt = !1;
    }
    try {
      Y = new IntersectionObserver(Zt, {
        ...Lt,
        // Handle <iframe>s
        root: ie.ownerDocument
      });
    } catch {
      Y = new IntersectionObserver(Zt, Lt);
    }
    Y.observe(B);
  }
  return se(!0), oe;
}
function autoUpdate(B, z, Y, ne) {
  ne === void 0 && (ne = {});
  const {
    ancestorScroll: ie = !0,
    ancestorResize: oe = !0,
    elementResize: se = typeof ResizeObserver == "function",
    layoutShift: ae = typeof IntersectionObserver == "function",
    animationFrame: ge = !1
  } = ne, Ce = unwrapElement(B), le = ie || oe ? [...Ce ? getOverflowAncestors(Ce) : [], ...getOverflowAncestors(z)] : [];
  le.forEach((Wt) => {
    ie && Wt.addEventListener("scroll", Y, {
      passive: !0
    }), oe && Wt.addEventListener("resize", Y);
  });
  const Ee = Ce && ae ? observeMove(Ce, Y) : null;
  let Je = -1, Ve = null;
  se && (Ve = new ResizeObserver((Wt) => {
    let [Pt] = Wt;
    Pt && Pt.target === Ce && Ve && (Ve.unobserve(z), cancelAnimationFrame(Je), Je = requestAnimationFrame(() => {
      var Lt;
      (Lt = Ve) == null || Lt.observe(z);
    })), Y();
  }), Ce && !ge && Ve.observe(Ce), Ve.observe(z));
  let $t, Nt = ge ? getBoundingClientRect(B) : null;
  ge && Dt();
  function Dt() {
    const Wt = getBoundingClientRect(B);
    Nt && !rectsAreEqual(Nt, Wt) && Y(), Nt = Wt, $t = requestAnimationFrame(Dt);
  }
  return Y(), () => {
    var Wt;
    le.forEach((Pt) => {
      ie && Pt.removeEventListener("scroll", Y), oe && Pt.removeEventListener("resize", Y);
    }), Ee == null || Ee(), (Wt = Ve) == null || Wt.disconnect(), Ve = null, ge && cancelAnimationFrame($t);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, computePosition = (B, z, Y) => {
  const ne = /* @__PURE__ */ new Map(), ie = {
    platform,
    ...Y
  }, oe = {
    ...ie.platform,
    _c: ne
  };
  return computePosition$1(B, z, {
    ...ie,
    platform: oe
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(B, z) {
  if (B === z)
    return !0;
  if (typeof B != typeof z)
    return !1;
  if (typeof B == "function" && B.toString() === z.toString())
    return !0;
  let Y, ne, ie;
  if (B && z && typeof B == "object") {
    if (Array.isArray(B)) {
      if (Y = B.length, Y !== z.length) return !1;
      for (ne = Y; ne-- !== 0; )
        if (!deepEqual(B[ne], z[ne]))
          return !1;
      return !0;
    }
    if (ie = Object.keys(B), Y = ie.length, Y !== Object.keys(z).length)
      return !1;
    for (ne = Y; ne-- !== 0; )
      if (!{}.hasOwnProperty.call(z, ie[ne]))
        return !1;
    for (ne = Y; ne-- !== 0; ) {
      const oe = ie[ne];
      if (!(oe === "_owner" && B.$$typeof) && !deepEqual(B[oe], z[oe]))
        return !1;
    }
    return !0;
  }
  return B !== B && z !== z;
}
function getDPR(B) {
  return typeof window > "u" ? 1 : (B.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(B, z) {
  const Y = getDPR(B);
  return Math.round(z * Y) / Y;
}
function useLatestRef(B) {
  const z = React.useRef(B);
  return index$1(() => {
    z.current = B;
  }), z;
}
function useFloating$1(B) {
  B === void 0 && (B = {});
  const {
    placement: z = "bottom",
    strategy: Y = "absolute",
    middleware: ne = [],
    platform: ie,
    elements: {
      reference: oe,
      floating: se
    } = {},
    transform: ae = !0,
    whileElementsMounted: ge,
    open: Ce
  } = B, [le, Ee] = React.useState({
    x: 0,
    y: 0,
    strategy: Y,
    placement: z,
    middlewareData: {},
    isPositioned: !1
  }), [Je, Ve] = React.useState(ne);
  deepEqual(Je, ne) || Ve(ne);
  const [$t, Nt] = React.useState(null), [Dt, Wt] = React.useState(null), Pt = React.useCallback((vt) => {
    vt !== Yt.current && (Yt.current = vt, Nt(vt));
  }, []), Lt = React.useCallback((vt) => {
    vt !== or.current && (or.current = vt, Wt(vt));
  }, []), qt = oe || $t, Zt = se || Dt, Yt = React.useRef(null), or = React.useRef(null), jt = React.useRef(le), Ct = ge != null, Vt = useLatestRef(ge), kt = useLatestRef(ie), Pe = useLatestRef(Ce), Xe = React.useCallback(() => {
    if (!Yt.current || !or.current)
      return;
    const vt = {
      placement: z,
      strategy: Y,
      middleware: Je
    };
    kt.current && (vt.platform = kt.current), computePosition(Yt.current, or.current, vt).then((xt) => {
      const Qe = {
        ...xt,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Pe.current !== !1
      };
      ve.current && !deepEqual(jt.current, Qe) && (jt.current = Qe, ReactDOM.flushSync(() => {
        Ee(Qe);
      }));
    });
  }, [Je, z, Y, kt, Pe]);
  index$1(() => {
    Ce === !1 && jt.current.isPositioned && (jt.current.isPositioned = !1, Ee((vt) => ({
      ...vt,
      isPositioned: !1
    })));
  }, [Ce]);
  const ve = React.useRef(!1);
  index$1(() => (ve.current = !0, () => {
    ve.current = !1;
  }), []), index$1(() => {
    if (qt && (Yt.current = qt), Zt && (or.current = Zt), qt && Zt) {
      if (Vt.current)
        return Vt.current(qt, Zt, Xe);
      Xe();
    }
  }, [qt, Zt, Xe, Vt, Ct]);
  const Ke = React.useMemo(() => ({
    reference: Yt,
    floating: or,
    setReference: Pt,
    setFloating: Lt
  }), [Pt, Lt]), ht = React.useMemo(() => ({
    reference: qt,
    floating: Zt
  }), [qt, Zt]), wt = React.useMemo(() => {
    const vt = {
      position: Y,
      left: 0,
      top: 0
    };
    if (!ht.floating)
      return vt;
    const xt = roundByDPR(ht.floating, le.x), Qe = roundByDPR(ht.floating, le.y);
    return ae ? {
      ...vt,
      transform: "translate(" + xt + "px, " + Qe + "px)",
      ...getDPR(ht.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: Y,
      left: xt,
      top: Qe
    };
  }, [Y, ae, ht.floating, le.x, le.y]);
  return React.useMemo(() => ({
    ...le,
    update: Xe,
    refs: Ke,
    elements: ht,
    floatingStyles: wt
  }), [le, Xe, Ke, ht, wt]);
}
const offset = (B, z) => ({
  ...offset$1(B),
  options: [B, z]
}), shift = (B, z) => ({
  ...shift$1(B),
  options: [B, z]
}), flip = (B, z) => ({
  ...flip$1(B),
  options: [B, z]
}), size = (B, z) => ({
  ...size$1(B),
  options: [B, z]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((B) => B());
function useEffectEvent(B) {
  const z = React.useRef(() => {
    if (process$1.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    z.current = B;
  }), React.useCallback(function() {
    for (var Y = arguments.length, ne = new Array(Y), ie = 0; ie < Y; ie++)
      ne[ie] = arguments[ie];
    return z.current == null ? void 0 : z.current(...ne);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [B, z] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    B == null && z(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), B;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
process$1.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const ie = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(ie))) {
    var oe;
    (oe = devMessageSet) == null || oe.add(ie), console.warn(ie);
  }
}
function error() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const ie = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(ie))) {
    var oe;
    (oe = devMessageSet) == null || oe.add(ie), console.error(ie);
  }
}
function createPubSub() {
  const B = /* @__PURE__ */ new Map();
  return {
    emit(z, Y) {
      var ne;
      (ne = B.get(z)) == null || ne.forEach((ie) => ie(Y));
    },
    on(z, Y) {
      B.set(z, [...B.get(z) || [], Y]);
    },
    off(z, Y) {
      var ne;
      B.set(z, ((ne = B.get(z)) == null ? void 0 : ne.filter((ie) => ie !== Y)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var B;
  return ((B = React.useContext(FloatingNodeContext)) == null ? void 0 : B.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(B) {
  const {
    open: z = !1,
    onOpenChange: Y,
    elements: ne
  } = B, ie = useId(), oe = React.useRef({}), [se] = React.useState(() => createPubSub()), ae = useFloatingParentNodeId() != null;
  if (process$1.env.NODE_ENV !== "production") {
    const Ve = ne.reference;
    Ve && !isElement(Ve) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [ge, Ce] = React.useState(ne.reference), le = useEffectEvent((Ve, $t, Nt) => {
    oe.current.openEvent = Ve ? $t : void 0, se.emit("openchange", {
      open: Ve,
      event: $t,
      reason: Nt,
      nested: ae
    }), Y == null || Y(Ve, $t, Nt);
  }), Ee = React.useMemo(() => ({
    setPositionReference: Ce
  }), []), Je = React.useMemo(() => ({
    reference: ge || ne.reference || null,
    floating: ne.floating || null,
    domReference: ne.reference
  }), [ge, ne.reference, ne.floating]);
  return React.useMemo(() => ({
    dataRef: oe,
    open: z,
    onOpenChange: le,
    elements: Je,
    events: se,
    floatingId: ie,
    refs: Ee
  }), [z, le, Je, se, ie, Ee]);
}
function useFloating(B) {
  B === void 0 && (B = {});
  const {
    nodeId: z
  } = B, Y = useFloatingRootContext({
    ...B,
    elements: {
      reference: null,
      floating: null,
      ...B.elements
    }
  }), ne = B.rootContext || Y, ie = ne.elements, [oe, se] = React.useState(null), [ae, ge] = React.useState(null), le = (ie == null ? void 0 : ie.domReference) || oe, Ee = React.useRef(null), Je = useFloatingTree();
  index(() => {
    le && (Ee.current = le);
  }, [le]);
  const Ve = useFloating$1({
    ...B,
    elements: {
      ...ie,
      ...ae && {
        reference: ae
      }
    }
  }), $t = React.useCallback((Lt) => {
    const qt = isElement(Lt) ? {
      getBoundingClientRect: () => Lt.getBoundingClientRect(),
      contextElement: Lt
    } : Lt;
    ge(qt), Ve.refs.setReference(qt);
  }, [Ve.refs]), Nt = React.useCallback((Lt) => {
    (isElement(Lt) || Lt === null) && (Ee.current = Lt, se(Lt)), (isElement(Ve.refs.reference.current) || Ve.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    Lt !== null && !isElement(Lt)) && Ve.refs.setReference(Lt);
  }, [Ve.refs]), Dt = React.useMemo(() => ({
    ...Ve.refs,
    setReference: Nt,
    setPositionReference: $t,
    domReference: Ee
  }), [Ve.refs, Nt, $t]), Wt = React.useMemo(() => ({
    ...Ve.elements,
    domReference: le
  }), [Ve.elements, le]), Pt = React.useMemo(() => ({
    ...Ve,
    ...ne,
    refs: Dt,
    elements: Wt,
    nodeId: z
  }), [Ve, Dt, Wt, z, ne]);
  return index(() => {
    ne.dataRef.current.floatingContext = Pt;
    const Lt = Je == null ? void 0 : Je.nodesRef.current.find((qt) => qt.id === z);
    Lt && (Lt.context = Pt);
  }), React.useMemo(() => ({
    ...Ve,
    context: Pt,
    refs: Dt,
    elements: Wt
  }), [Ve, Dt, Wt, Pt]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(B, z, Y) {
  const ne = /* @__PURE__ */ new Map(), ie = Y === "item";
  let oe = B;
  if (ie && B) {
    const {
      [ACTIVE_KEY]: se,
      [SELECTED_KEY]: ae,
      ...ge
    } = B;
    oe = ge;
  }
  return {
    ...Y === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...oe,
    ...z.map((se) => {
      const ae = se ? se[Y] : null;
      return typeof ae == "function" ? B ? ae(B) : null : ae;
    }).concat(B).reduce((se, ae) => (ae && Object.entries(ae).forEach((ge) => {
      let [Ce, le] = ge;
      if (!(ie && [ACTIVE_KEY, SELECTED_KEY].includes(Ce)))
        if (Ce.indexOf("on") === 0) {
          if (ne.has(Ce) || ne.set(Ce, []), typeof le == "function") {
            var Ee;
            (Ee = ne.get(Ce)) == null || Ee.push(le), se[Ce] = function() {
              for (var Je, Ve = arguments.length, $t = new Array(Ve), Nt = 0; Nt < Ve; Nt++)
                $t[Nt] = arguments[Nt];
              return (Je = ne.get(Ce)) == null ? void 0 : Je.map((Dt) => Dt(...$t)).find((Dt) => Dt !== void 0);
            };
          }
        } else
          se[Ce] = le;
    }), se), {})
  };
}
function useInteractions(B) {
  B === void 0 && (B = []);
  const z = B.map((ae) => ae == null ? void 0 : ae.reference), Y = B.map((ae) => ae == null ? void 0 : ae.floating), ne = B.map((ae) => ae == null ? void 0 : ae.item), ie = React.useCallback(
    (ae) => mergeProps(ae, B, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    z
  ), oe = React.useCallback(
    (ae) => mergeProps(ae, B, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Y
  ), se = React.useCallback(
    (ae) => mergeProps(ae, B, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    ne
  );
  return React.useMemo(() => ({
    getReferenceProps: ie,
    getFloatingProps: oe,
    getItemProps: se
  }), [ie, oe, se]);
}
function getArgsWithCustomFloatingHeight(B, z) {
  return {
    ...B,
    rects: {
      ...B.rects,
      floating: {
        ...B.rects.floating,
        height: z
      }
    }
  };
}
const inner = (B) => ({
  name: "inner",
  options: B,
  async fn(z) {
    const {
      listRef: Y,
      overflowRef: ne,
      onFallbackChange: ie,
      offset: oe = 0,
      index: se = 0,
      minItemsVisible: ae = 4,
      referenceOverflowThreshold: ge = 0,
      scrollRef: Ce,
      ...le
    } = evaluate(B, z), {
      rects: Ee,
      elements: {
        floating: Je
      }
    } = z, Ve = Y.current[se], $t = (Ce == null ? void 0 : Ce.current) || Je, Nt = Je.clientTop || $t.clientTop, Dt = Je.clientTop !== 0, Wt = $t.clientTop !== 0, Pt = Je === $t;
    if (process$1.env.NODE_ENV !== "production" && (z.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.")), !Ve)
      return {};
    const Lt = {
      ...z,
      ...await offset(-Ve.offsetTop - Je.clientTop - Ee.reference.height / 2 - Ve.offsetHeight / 2 - oe).fn(z)
    }, qt = await detectOverflow(getArgsWithCustomFloatingHeight(Lt, $t.scrollHeight + Nt + Je.clientTop), le), Zt = await detectOverflow(Lt, {
      ...le,
      elementContext: "reference"
    }), Yt = max$3(0, qt.top), or = Lt.y + Yt, Vt = ($t.scrollHeight > $t.clientHeight ? (kt) => kt : round$2)(max$3(0, $t.scrollHeight + (Dt && Pt || Wt ? Nt * 2 : 0) - Yt - max$3(0, qt.bottom)));
    if ($t.style.maxHeight = Vt + "px", $t.scrollTop = Yt, ie) {
      const kt = $t.offsetHeight < Ve.offsetHeight * min$2(ae, Y.current.length) - 1 || Zt.top >= -ge || Zt.bottom >= -ge;
      ReactDOM.flushSync(() => ie(kt));
    }
    return ne && (ne.current = await detectOverflow(getArgsWithCustomFloatingHeight({
      ...Lt,
      y: or
    }, $t.offsetHeight + Nt + Je.clientTop), le)), {
      y: or
    };
  }
});
function useInnerOffset(B, z) {
  const {
    open: Y,
    elements: ne
  } = B, {
    enabled: ie = !0,
    overflowRef: oe,
    scrollRef: se,
    onChange: ae
  } = z, ge = useEffectEvent(ae), Ce = React.useRef(!1), le = React.useRef(null), Ee = React.useRef(null);
  React.useEffect(() => {
    if (!ie) return;
    function Ve(Nt) {
      if (Nt.ctrlKey || !$t || oe.current == null)
        return;
      const Dt = Nt.deltaY, Wt = oe.current.top >= -0.5, Pt = oe.current.bottom >= -0.5, Lt = $t.scrollHeight - $t.clientHeight, qt = Dt < 0 ? -1 : 1, Zt = Dt < 0 ? "max" : "min";
      $t.scrollHeight <= $t.clientHeight || (!Wt && Dt > 0 || !Pt && Dt < 0 ? (Nt.preventDefault(), ReactDOM.flushSync(() => {
        ge((Yt) => Yt + Math[Zt](Dt, Lt * qt));
      })) : /firefox/i.test(getUserAgent()) && ($t.scrollTop += Dt));
    }
    const $t = (se == null ? void 0 : se.current) || ne.floating;
    if (Y && $t)
      return $t.addEventListener("wheel", Ve), requestAnimationFrame(() => {
        le.current = $t.scrollTop, oe.current != null && (Ee.current = {
          ...oe.current
        });
      }), () => {
        le.current = null, Ee.current = null, $t.removeEventListener("wheel", Ve);
      };
  }, [ie, Y, ne.floating, oe, se, ge]);
  const Je = React.useMemo(() => ({
    onKeyDown() {
      Ce.current = !0;
    },
    onWheel() {
      Ce.current = !1;
    },
    onPointerMove() {
      Ce.current = !1;
    },
    onScroll() {
      const Ve = (se == null ? void 0 : se.current) || ne.floating;
      if (!(!oe.current || !Ve || !Ce.current)) {
        if (le.current !== null) {
          const $t = Ve.scrollTop - le.current;
          (oe.current.bottom < -0.5 && $t < -1 || oe.current.top < -0.5 && $t > 1) && ReactDOM.flushSync(() => ge((Nt) => Nt + $t));
        }
        requestAnimationFrame(() => {
          le.current = Ve.scrollTop;
        });
      }
    }
  }), [ne.floating, ge, oe, se]);
  return React.useMemo(() => ie ? {
    floating: Je
  } : {}, [ie, Je]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let H = createContext(null);
H.displayName = "PlacementContext";
function xe(B) {
  return useMemo(() => B ? typeof B == "string" ? { to: B } : B : null, [B]);
}
function ye$1() {
  return useContext(y$1).setReference;
}
function Fe$1() {
  return useContext(y$1).getReferenceProps;
}
function be() {
  let { getFloatingProps: B, slot: z } = useContext(y$1);
  return useCallback((...Y) => Object.assign({}, B(...Y), { "data-anchor": z.anchor }), [B, z]);
}
function Re(B = null) {
  B === !1 && (B = null), typeof B == "string" && (B = { to: B });
  let z = useContext(H), Y = useMemo(() => B, [JSON.stringify(B, (ie, oe) => {
    var se;
    return (se = oe == null ? void 0 : oe.outerHTML) != null ? se : oe;
  })]);
  n$3(() => {
    z == null || z(Y ?? null);
  }, [z, Y]);
  let ne = useContext(y$1);
  return useMemo(() => [ne.setFloating, B ? ne.styles : {}], [ne.setFloating, B, ne.styles]);
}
let q = 4;
function Me$1({ children: B, enabled: z = !0 }) {
  let [Y, ne] = useState(null), [ie, oe] = useState(0), se = useRef(null), [ae, ge] = useState(null);
  pe(ae);
  let Ce = z && Y !== null && ae !== null, { to: le = "bottom", gap: Ee = 0, offset: Je = 0, padding: Ve = 0, inner: $t } = ce(Y, ae), [Nt, Dt = "center"] = le.split(" ");
  n$3(() => {
    Ce && oe(0);
  }, [Ce]);
  let { refs: Wt, floatingStyles: Pt, context: Lt } = useFloating({ open: Ce, placement: Nt === "selection" ? Dt === "center" ? "bottom" : `bottom-${Dt}` : Dt === "center" ? `${Nt}` : `${Nt}-${Dt}`, strategy: "absolute", transform: !1, middleware: [offset({ mainAxis: Nt === "selection" ? 0 : Ee, crossAxis: Je }), shift({ padding: Ve }), Nt !== "selection" && flip({ padding: Ve }), Nt === "selection" && $t ? inner({ ...$t, padding: Ve, overflowRef: se, offset: ie, minItemsVisible: q, referenceOverflowThreshold: Ve, onFallbackChange(kt) {
    var Pe, Xe;
    if (!kt) return;
    let ve = Lt.elements.floating;
    if (!ve) return;
    let Ke = parseFloat(getComputedStyle(ve).scrollPaddingBottom) || 0, ht = Math.min(q, ve.childElementCount), wt = 0, vt = 0;
    for (let xt of (Xe = (Pe = Lt.elements.floating) == null ? void 0 : Pe.childNodes) != null ? Xe : []) if (xt instanceof HTMLElement) {
      let Qe = xt.offsetTop, Rt = Qe + xt.clientHeight + Ke, bt = ve.scrollTop, Ht = bt + ve.clientHeight;
      if (Qe >= bt && Rt <= Ht) ht--;
      else {
        vt = Math.max(0, Math.min(Rt, Ht) - Math.max(Qe, bt)), wt = xt.clientHeight;
        break;
      }
    }
    ht >= 1 && oe((xt) => {
      let Qe = wt * ht - vt + Ke;
      return xt >= Qe ? xt : Qe;
    });
  } }) : null, size({ padding: Ve, apply({ availableWidth: kt, availableHeight: Pe, elements: Xe }) {
    Object.assign(Xe.floating.style, { overflow: "auto", maxWidth: `${kt}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${Pe}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [qt = Nt, Zt = Dt] = Lt.placement.split("-");
  Nt === "selection" && (qt = "selection");
  let Yt = useMemo(() => ({ anchor: [qt, Zt].filter(Boolean).join(" ") }), [qt, Zt]), or = useInnerOffset(Lt, { overflowRef: se, onChange: oe }), { getReferenceProps: jt, getFloatingProps: Ct } = useInteractions([or]), Vt = o$4((kt) => {
    ge(kt), Wt.setFloating(kt);
  });
  return React.createElement(H.Provider, { value: ne }, React.createElement(y$1.Provider, { value: { setFloating: Vt, setReference: Wt.setReference, styles: Pt, getReferenceProps: jt, getFloatingProps: Ct, slot: Yt } }, B));
}
function pe(B) {
  n$3(() => {
    if (!B) return;
    let z = new MutationObserver(() => {
      let Y = window.getComputedStyle(B).maxHeight, ne = parseFloat(Y);
      if (isNaN(ne)) return;
      let ie = parseInt(Y);
      isNaN(ie) || ne !== ie && (B.style.maxHeight = `${Math.ceil(ne)}px`);
    });
    return z.observe(B, { attributes: !0, attributeFilter: ["style"] }), () => {
      z.disconnect();
    };
  }, [B]);
}
function ce(B, z) {
  var Y, ne, ie;
  let oe = V$1((Y = B == null ? void 0 : B.gap) != null ? Y : "var(--anchor-gap, 0)", z), se = V$1((ne = B == null ? void 0 : B.offset) != null ? ne : "var(--anchor-offset, 0)", z), ae = V$1((ie = B == null ? void 0 : B.padding) != null ? ie : "var(--anchor-padding, 0)", z);
  return { ...B, gap: oe, offset: se, padding: ae };
}
function V$1(B, z, Y = void 0) {
  let ne = p$2(), ie = o$4((ge, Ce) => {
    if (ge == null) return [Y, null];
    if (typeof ge == "number") return [ge, null];
    if (typeof ge == "string") {
      if (!Ce) return [Y, null];
      let le = J$1(ge, Ce);
      return [le, (Ee) => {
        let Je = D$1(ge);
        {
          let Ve = Je.map(($t) => window.getComputedStyle(Ce).getPropertyValue($t));
          ne.requestAnimationFrame(function $t() {
            ne.nextFrame($t);
            let Nt = !1;
            for (let [Wt, Pt] of Je.entries()) {
              let Lt = window.getComputedStyle(Ce).getPropertyValue(Pt);
              if (Ve[Wt] !== Lt) {
                Ve[Wt] = Lt, Nt = !0;
                break;
              }
            }
            if (!Nt) return;
            let Dt = J$1(ge, Ce);
            le !== Dt && (Ee(Dt), le = Dt);
          });
        }
        return ne.dispose;
      }];
    }
    return [Y, null];
  }), oe = useMemo(() => ie(B, z)[0], [B, z]), [se = oe, ae] = useState();
  return n$3(() => {
    let [ge, Ce] = ie(B, z);
    if (ae(ge), !!Ce) return Ce(ae);
  }, [B, z]), se;
}
function D$1(B) {
  let z = /var\((.*)\)/.exec(B);
  if (z) {
    let Y = z[1].indexOf(",");
    if (Y === -1) return [z[1]];
    let ne = z[1].slice(0, Y).trim(), ie = z[1].slice(Y + 1).trim();
    return ie ? [ne, ...D$1(ie)] : [ne];
  }
  return [];
}
function J$1(B, z) {
  let Y = document.createElement("div");
  z.appendChild(Y), Y.style.setProperty("margin-top", "0px", "important"), Y.style.setProperty("margin-top", B, "important");
  let ne = parseFloat(window.getComputedStyle(Y).marginTop) || 0;
  return z.removeChild(Y), ne;
}
let n = createContext(null);
n.displayName = "OpenClosedContext";
var i$3 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(i$3 || {});
function u$2() {
  return useContext(n);
}
function c$2({ value: B, children: z }) {
  return React__default.createElement(n.Provider, { value: B }, z);
}
function s$5({ children: B }) {
  return React__default.createElement(n.Provider, { value: null }, B);
}
function t(B) {
  function z() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", z));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", z), z());
}
let r$2 = [];
t(() => {
  function B(z) {
    if (!(z.target instanceof HTMLElement) || z.target === document.body || r$2[0] === z.target) return;
    let Y = z.target;
    Y = Y.closest(f$6), r$2.unshift(Y ?? z.target), r$2 = r$2.filter((ne) => ne != null && ne.isConnected), r$2.splice(10);
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function u$1(B) {
  throw new Error("Unexpected object: " + B);
}
var c$1 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$1 || {});
function f$4(B, z) {
  let Y = z.resolveItems();
  if (Y.length <= 0) return null;
  let ne = z.resolveActiveIndex(), ie = ne ?? -1;
  switch (B.focus) {
    case 0: {
      for (let oe = 0; oe < Y.length; ++oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 1: {
      ie === -1 && (ie = Y.length);
      for (let oe = ie - 1; oe >= 0; --oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 2: {
      for (let oe = ie + 1; oe < Y.length; ++oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 3: {
      for (let oe = Y.length - 1; oe >= 0; --oe) if (!z.resolveDisabled(Y[oe], oe, Y)) return oe;
      return ne;
    }
    case 4: {
      for (let oe = 0; oe < Y.length; ++oe) if (z.resolveId(Y[oe], oe, Y) === B.id) return oe;
      return ne;
    }
    case 5:
      return null;
    default:
      u$1(B);
  }
}
function c(B) {
  let z = o$4(B), Y = useRef(!1);
  useEffect(() => (Y.current = !1, () => {
    Y.current = !0, t$4(() => {
      Y.current && z();
    });
  }), [z]);
}
function s$4() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in React ? ((z) => z.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$1() {
  let B = s$4(), [z, Y] = React.useState(s$9.isHandoffComplete);
  return z && s$9.isHandoffComplete === !1 && Y(!1), React.useEffect(() => {
    z !== !0 && Y(!0);
  }, [z]), React.useEffect(() => s$9.handoff(), []), B ? !1 : z;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l(B) {
  return React__default.createElement(e.Provider, { value: B.force }, B.children);
}
function N(B) {
  let z = a$4(), Y = useContext(v), ne = n$1(B), [ie, oe] = useState(() => {
    var se;
    if (!z && Y !== null) return (se = Y.current) != null ? se : null;
    if (s$9.isServer) return null;
    let ae = ne == null ? void 0 : ne.getElementById("headlessui-portal-root");
    if (ae) return ae;
    if (ne === null) return null;
    let ge = ne.createElement("div");
    return ge.setAttribute("id", "headlessui-portal-root"), ne.body.appendChild(ge);
  });
  return useEffect(() => {
    ie !== null && (ne != null && ne.body.contains(ie) || ne == null || ne.body.appendChild(ie));
  }, [ie, ne]), useEffect(() => {
    z || Y !== null && oe(Y.current);
  }, [Y, oe, z]), ie;
}
let M$1 = Fragment, S = K$6(function(B, z) {
  let Y = B, ne = useRef(null), ie = y$4(T$2((Ee) => {
    ne.current = Ee;
  }), z), oe = n$1(ne), se = N(ne), [ae] = useState(() => {
    var Ee;
    return s$9.isServer ? null : (Ee = oe == null ? void 0 : oe.createElement("div")) != null ? Ee : null;
  }), ge = useContext(y), Ce = l$1();
  n$3(() => {
    !se || !ae || se.contains(ae) || (ae.setAttribute("data-headlessui-portal", ""), se.appendChild(ae));
  }, [se, ae]), n$3(() => {
    if (ae && ge) return ge.register(ae);
  }, [ge, ae]), c(() => {
    var Ee;
    !se || !ae || (ae instanceof Node && se.contains(ae) && se.removeChild(ae), se.childNodes.length <= 0 && ((Ee = se.parentElement) == null || Ee.removeChild(se)));
  });
  let le = L$1();
  return Ce ? !se || !ae ? null : createPortal(le({ ourProps: { ref: ie }, theirProps: Y, slot: {}, defaultTag: M$1, name: "Portal" }), ae) : null;
});
function j$1(B, z) {
  let Y = y$4(z), { enabled: ne = !0, ...ie } = B, oe = L$1();
  return ne ? React__default.createElement(S, { ...ie, ref: Y }) : oe({ ourProps: { ref: Y }, theirProps: ie, slot: {}, defaultTag: M$1, name: "Portal" });
}
let W$6 = Fragment, v = createContext(null);
function I$1(B, z) {
  let { target: Y, ...ne } = B, ie = { ref: y$4(z) }, oe = L$1();
  return React__default.createElement(v.Provider, { value: Y }, oe({ ourProps: ie, theirProps: ne, defaultTag: W$6, name: "Popover.Group" }));
}
let y = createContext(null);
function te$1() {
  let B = useContext(y), z = useRef([]), Y = o$4((oe) => (z.current.push(oe), B && B.register(oe), () => ne(oe))), ne = o$4((oe) => {
    let se = z.current.indexOf(oe);
    se !== -1 && z.current.splice(se, 1), B && B.unregister(oe);
  }), ie = useMemo(() => ({ register: Y, unregister: ne, portals: z }), [Y, ne, z]);
  return [z, useMemo(() => function({ children: oe }) {
    return React__default.createElement(y.Provider, { value: ie }, oe);
  }, [ie])];
}
let J = K$6(j$1), X$1 = K$6(I$1), re$1 = Object.assign(J, { Group: X$1 });
function a$3(B, z = typeof document < "u" ? document.defaultView : null, Y) {
  let ne = x$3(B, "escape");
  E(z, "keydown", (ie) => {
    ne && (ie.defaultPrevented || ie.key === o$3.Escape && Y(ie));
  });
}
function f$3() {
  var B;
  let [z] = useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [Y, ne] = useState((B = z == null ? void 0 : z.matches) != null ? B : !1);
  return n$3(() => {
    if (!z) return;
    function ie(oe) {
      ne(oe.matches);
    }
    return z.addEventListener("change", ie), () => z.removeEventListener("change", ie);
  }, [z]), Y;
}
function R$1({ defaultContainers: B = [], portals: z, mainTreeNode: Y } = {}) {
  let ne = n$1(Y), ie = o$4(() => {
    var oe, se;
    let ae = [];
    for (let ge of B) ge !== null && (ge instanceof HTMLElement ? ae.push(ge) : "current" in ge && ge.current instanceof HTMLElement && ae.push(ge.current));
    if (z != null && z.current) for (let ge of z.current) ae.push(ge);
    for (let ge of (oe = ne == null ? void 0 : ne.querySelectorAll("html > *, body > *")) != null ? oe : []) ge !== document.body && ge !== document.head && ge instanceof HTMLElement && ge.id !== "headlessui-portal-root" && (Y && (ge.contains(Y) || ge.contains((se = Y == null ? void 0 : Y.getRootNode()) == null ? void 0 : se.host)) || ae.some((Ce) => ge.contains(Ce)) || ae.push(ge));
    return ae;
  });
  return { resolveContainers: ie, contains: o$4((oe) => ie().some((se) => se.contains(oe))) };
}
let a$2 = createContext(null);
function O$1({ children: B, node: z }) {
  let [Y, ne] = useState(null), ie = b(z ?? Y);
  return React__default.createElement(a$2.Provider, { value: ie }, B, ie === null && React__default.createElement(f$a, { features: s$7.Hidden, ref: (oe) => {
    var se, ae;
    if (oe) {
      for (let ge of (ae = (se = u$8(oe)) == null ? void 0 : se.querySelectorAll("html > *, body > *")) != null ? ae : []) if (ge !== document.body && ge !== document.head && ge instanceof HTMLElement && ge != null && ge.contains(oe)) {
        ne(ge);
        break;
      }
    }
  } }));
}
function b(B = null) {
  var z;
  return (z = useContext(a$2)) != null ? z : B;
}
function f$2() {
  let B = useRef(!1);
  return n$3(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
var a$1 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(a$1 || {});
function u() {
  let B = useRef(0);
  return s$6(!0, "keydown", (z) => {
    z.key === "Tab" && (B.current = z.shiftKey ? 1 : 0);
  }, !0), B;
}
function U$1(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let z = /* @__PURE__ */ new Set();
  for (let Y of B.current) Y.current instanceof HTMLElement && z.add(Y.current);
  return z;
}
let Z = "div";
var x$1 = ((B) => (B[B.None = 0] = "None", B[B.InitialFocus = 1] = "InitialFocus", B[B.TabLock = 2] = "TabLock", B[B.FocusLock = 4] = "FocusLock", B[B.RestoreFocus = 8] = "RestoreFocus", B[B.AutoFocus = 16] = "AutoFocus", B))(x$1 || {});
function $(B, z) {
  let Y = useRef(null), ne = y$4(Y, z), { initialFocus: ie, initialFocusFallback: oe, containers: se, features: ae = 15, ...ge } = B;
  l$1() || (ae = 0);
  let Ce = n$1(Y);
  ee(ae, { ownerDocument: Ce });
  let le = te(ae, { ownerDocument: Ce, container: Y, initialFocus: ie, initialFocusFallback: oe });
  re(ae, { ownerDocument: Ce, container: Y, containers: se, previousActiveElement: le });
  let Ee = u(), Je = o$4((Pt) => {
    let Lt = Y.current;
    Lt && ((qt) => qt())(() => {
      u$7(Ee.current, { [a$1.Forwards]: () => {
        P(Lt, F$1.First, { skipElements: [Pt.relatedTarget, oe] });
      }, [a$1.Backwards]: () => {
        P(Lt, F$1.Last, { skipElements: [Pt.relatedTarget, oe] });
      } });
    });
  }), Ve = x$3(!!(ae & 2), "focus-trap#tab-lock"), $t = p$2(), Nt = useRef(!1), Dt = { ref: ne, onKeyDown(Pt) {
    Pt.key == "Tab" && (Nt.current = !0, $t.requestAnimationFrame(() => {
      Nt.current = !1;
    }));
  }, onBlur(Pt) {
    if (!(ae & 4)) return;
    let Lt = U$1(se);
    Y.current instanceof HTMLElement && Lt.add(Y.current);
    let qt = Pt.relatedTarget;
    qt instanceof HTMLElement && qt.dataset.headlessuiFocusGuard !== "true" && (I(Lt, qt) || (Nt.current ? P(Y.current, u$7(Ee.current, { [a$1.Forwards]: () => F$1.Next, [a$1.Backwards]: () => F$1.Previous }) | F$1.WrapAround, { relativeTo: Pt.target }) : Pt.target instanceof HTMLElement && I$2(Pt.target)));
  } }, Wt = L$1();
  return React__default.createElement(React__default.Fragment, null, Ve && React__default.createElement(f$a, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Je, features: s$7.Focusable }), Wt({ ourProps: Dt, theirProps: ge, defaultTag: Z, name: "FocusTrap" }), Ve && React__default.createElement(f$a, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Je, features: s$7.Focusable }));
}
let D = K$6($), ye = Object.assign(D, { features: x$1 });
function w$2(B = !0) {
  let z = useRef(r$2.slice());
  return m(([Y], [ne]) => {
    ne === !0 && Y === !1 && t$4(() => {
      z.current.splice(0);
    }), ne === !1 && Y === !0 && (z.current = r$2.slice());
  }, [B, r$2, z]), o$4(() => {
    var Y;
    return (Y = z.current.find((ne) => ne != null && ne.isConnected)) != null ? Y : null;
  });
}
function ee(B, { ownerDocument: z }) {
  let Y = !!(B & 8), ne = w$2(Y);
  m(() => {
    Y || (z == null ? void 0 : z.activeElement) === (z == null ? void 0 : z.body) && I$2(ne());
  }, [Y]), c(() => {
    Y && I$2(ne());
  });
}
function te(B, { ownerDocument: z, container: Y, initialFocus: ne, initialFocusFallback: ie }) {
  let oe = useRef(null), se = x$3(!!(B & 1), "focus-trap#initial-focus"), ae = f$2();
  return m(() => {
    if (B === 0) return;
    if (!se) {
      ie != null && ie.current && I$2(ie.current);
      return;
    }
    let ge = Y.current;
    ge && t$4(() => {
      if (!ae.current) return;
      let Ce = z == null ? void 0 : z.activeElement;
      if (ne != null && ne.current) {
        if ((ne == null ? void 0 : ne.current) === Ce) {
          oe.current = Ce;
          return;
        }
      } else if (ge.contains(Ce)) {
        oe.current = Ce;
        return;
      }
      if (ne != null && ne.current) I$2(ne.current);
      else {
        if (B & 16) {
          if (P(ge, F$1.First | F$1.AutoFocus) !== T$1.Error) return;
        } else if (P(ge, F$1.First) !== T$1.Error) return;
        if (ie != null && ie.current && (I$2(ie.current), (z == null ? void 0 : z.activeElement) === ie.current)) return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      oe.current = z == null ? void 0 : z.activeElement;
    });
  }, [ie, se, B]), oe;
}
function re(B, { ownerDocument: z, container: Y, containers: ne, previousActiveElement: ie }) {
  let oe = f$2(), se = !!(B & 4);
  E(z == null ? void 0 : z.defaultView, "focus", (ae) => {
    if (!se || !oe.current) return;
    let ge = U$1(ne);
    Y.current instanceof HTMLElement && ge.add(Y.current);
    let Ce = ie.current;
    if (!Ce) return;
    let le = ae.target;
    le && le instanceof HTMLElement ? I(ge, le) ? (ie.current = le, I$2(le)) : (ae.preventDefault(), ae.stopPropagation(), I$2(Ce)) : I$2(ie.current);
  }, !0);
}
function I(B, z) {
  for (let Y of B) if (Y.contains(z)) return !0;
  return !1;
}
function ue(B) {
  var z;
  return !!(B.enter || B.enterFrom || B.enterTo || B.leave || B.leaveFrom || B.leaveTo) || ((z = B.as) != null ? z : de) !== Fragment || React__default.Children.count(B.children) === 1;
}
let w$1 = createContext(null);
w$1.displayName = "TransitionContext";
var _e = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(_e || {});
function De() {
  let B = useContext(w$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function He$1() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: z }) => z.current !== null).filter(({ state: z }) => z === "visible").length > 0;
}
function Te(B, z) {
  let Y = s$8(B), ne = useRef([]), ie = f$2(), oe = p$2(), se = o$4((Ve, $t = A$1.Hidden) => {
    let Nt = ne.current.findIndex(({ el: Dt }) => Dt === Ve);
    Nt !== -1 && (u$7($t, { [A$1.Unmount]() {
      ne.current.splice(Nt, 1);
    }, [A$1.Hidden]() {
      ne.current[Nt].state = "hidden";
    } }), oe.microTask(() => {
      var Dt;
      !U(ne) && ie.current && ((Dt = Y.current) == null || Dt.call(Y));
    }));
  }), ae = o$4((Ve) => {
    let $t = ne.current.find(({ el: Nt }) => Nt === Ve);
    return $t ? $t.state !== "visible" && ($t.state = "visible") : ne.current.push({ el: Ve, state: "visible" }), () => se(Ve, A$1.Unmount);
  }), ge = useRef([]), Ce = useRef(Promise.resolve()), le = useRef({ enter: [], leave: [] }), Ee = o$4((Ve, $t, Nt) => {
    ge.current.splice(0), z && (z.chains.current[$t] = z.chains.current[$t].filter(([Dt]) => Dt !== Ve)), z == null || z.chains.current[$t].push([Ve, new Promise((Dt) => {
      ge.current.push(Dt);
    })]), z == null || z.chains.current[$t].push([Ve, new Promise((Dt) => {
      Promise.all(le.current[$t].map(([Wt, Pt]) => Pt)).then(() => Dt());
    })]), $t === "enter" ? Ce.current = Ce.current.then(() => z == null ? void 0 : z.wait.current).then(() => Nt($t)) : Nt($t);
  }), Je = o$4((Ve, $t, Nt) => {
    Promise.all(le.current[$t].splice(0).map(([Dt, Wt]) => Wt)).then(() => {
      var Dt;
      (Dt = ge.current.shift()) == null || Dt();
    }).then(() => Nt($t));
  });
  return useMemo(() => ({ children: ne, register: ae, unregister: se, onStart: Ee, onStop: Je, wait: Ce, chains: le }), [ae, se, ne, Ee, Je, le, Ce]);
}
let de = Fragment, fe = O$3.RenderStrategy;
function Ae(B, z) {
  var Y, ne;
  let { transition: ie = !0, beforeEnter: oe, afterEnter: se, beforeLeave: ae, afterLeave: ge, enter: Ce, enterFrom: le, enterTo: Ee, entered: Je, leave: Ve, leaveFrom: $t, leaveTo: Nt, ...Dt } = B, [Wt, Pt] = useState(null), Lt = useRef(null), qt = ue(B), Zt = y$4(...qt ? [Lt, z, Pt] : z === null ? [] : [z]), Yt = (Y = Dt.unmount) == null || Y ? A$1.Unmount : A$1.Hidden, { show: or, appear: jt, initial: Ct } = De(), [Vt, kt] = useState(or ? "visible" : "hidden"), Pe = He$1(), { register: Xe, unregister: ve } = Pe;
  n$3(() => Xe(Lt), [Xe, Lt]), n$3(() => {
    if (Yt === A$1.Hidden && Lt.current) {
      if (or && Vt !== "visible") {
        kt("visible");
        return;
      }
      return u$7(Vt, { hidden: () => ve(Lt), visible: () => Xe(Lt) });
    }
  }, [Vt, Lt, Xe, ve, or, Yt]);
  let Ke = l$1();
  n$3(() => {
    if (qt && Ke && Vt === "visible" && Lt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [Lt, Vt, Ke, qt]);
  let ht = Ct && !jt, wt = jt && or && Ct, vt = useRef(!1), xt = Te(() => {
    vt.current || (kt("hidden"), ve(Lt));
  }, Pe), Qe = o$4((Kt) => {
    vt.current = !0;
    let Gt = Kt ? "enter" : "leave";
    xt.onStart(Lt, Gt, (ur) => {
      ur === "enter" ? oe == null || oe() : ur === "leave" && (ae == null || ae());
    });
  }), Rt = o$4((Kt) => {
    let Gt = Kt ? "enter" : "leave";
    vt.current = !1, xt.onStop(Lt, Gt, (ur) => {
      ur === "enter" ? se == null || se() : ur === "leave" && (ge == null || ge());
    }), Gt === "leave" && !U(xt) && (kt("hidden"), ve(Lt));
  });
  useEffect(() => {
    qt && ie || (Qe(or), Rt(or));
  }, [or, qt, ie]);
  let bt = !(!ie || !qt || !Ke || ht), [, Ht] = x$2(bt, Wt, or, { start: Qe, end: Rt }), ar = m$4({ ref: Zt, className: ((ne = t$3(Dt.className, wt && Ce, wt && le, Ht.enter && Ce, Ht.enter && Ht.closed && le, Ht.enter && !Ht.closed && Ee, Ht.leave && Ve, Ht.leave && !Ht.closed && $t, Ht.leave && Ht.closed && Nt, !Ht.transition && or && Je)) == null ? void 0 : ne.trim()) || void 0, ...R$2(Ht) }), yr = 0;
  Vt === "visible" && (yr |= i$3.Open), Vt === "hidden" && (yr |= i$3.Closed), Ht.enter && (yr |= i$3.Opening), Ht.leave && (yr |= i$3.Closing);
  let rr = L$1();
  return React__default.createElement(M.Provider, { value: xt }, React__default.createElement(c$2, { value: yr }, rr({ ourProps: ar, theirProps: Dt, defaultTag: de, features: fe, visible: Vt === "visible", name: "Transition.Child" })));
}
function Ie$1(B, z) {
  let { show: Y, appear: ne = !1, unmount: ie = !0, ...oe } = B, se = useRef(null), ae = ue(B), ge = y$4(...ae ? [se, z] : z === null ? [] : [z]);
  l$1();
  let Ce = u$2();
  if (Y === void 0 && Ce !== null && (Y = (Ce & i$3.Open) === i$3.Open), Y === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [le, Ee] = useState(Y ? "visible" : "hidden"), Je = Te(() => {
    Y || Ee("hidden");
  }), [Ve, $t] = useState(!0), Nt = useRef([Y]);
  n$3(() => {
    Ve !== !1 && Nt.current[Nt.current.length - 1] !== Y && (Nt.current.push(Y), $t(!1));
  }, [Nt, Y]);
  let Dt = useMemo(() => ({ show: Y, appear: ne, initial: Ve }), [Y, ne, Ve]);
  n$3(() => {
    Y ? Ee("visible") : !U(Je) && se.current !== null && Ee("hidden");
  }, [Y, Je]);
  let Wt = { unmount: ie }, Pt = o$4(() => {
    var Zt;
    Ve && $t(!1), (Zt = B.beforeEnter) == null || Zt.call(B);
  }), Lt = o$4(() => {
    var Zt;
    Ve && $t(!1), (Zt = B.beforeLeave) == null || Zt.call(B);
  }), qt = L$1();
  return React__default.createElement(M.Provider, { value: Je }, React__default.createElement(w$1.Provider, { value: Dt }, qt({ ourProps: { ...Wt, as: Fragment, children: React__default.createElement(me, { ref: ge, ...Wt, ...oe, beforeEnter: Pt, beforeLeave: Lt }) }, theirProps: {}, defaultTag: Fragment, features: fe, visible: le === "visible", name: "Transition" })));
}
function Le(B, z) {
  let Y = useContext(w$1) !== null, ne = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !Y && ne ? React__default.createElement(X, { ref: z, ...B }) : React__default.createElement(me, { ref: z, ...B }));
}
let X = K$6(Ie$1), me = K$6(Ae), Fe = K$6(Le), ze$1 = Object.assign(X, { Child: Fe, Root: X });
var Oe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Oe || {}), he = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(he || {});
let Se = { 0(B, z) {
  return B.titleId === z.id ? B : { ...B, titleId: z.id };
} }, k$1 = createContext(null);
k$1.displayName = "DialogContext";
function O(B) {
  let z = useContext(k$1);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, O), Y;
  }
  return z;
}
function Ie(B, z) {
  return u$7(z.type, Se, B, z);
}
let V = K$6(function(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-${Y}`, open: ie, onClose: oe, initialFocus: se, role: ae = "dialog", autoFocus: ge = !0, __demoMode: Ce = !1, unmount: le = !1, ...Ee } = B, Je = useRef(!1);
  ae = function() {
    return ae === "dialog" || ae === "alertdialog" ? ae : (Je.current || (Je.current = !0, console.warn(`Invalid role [${ae}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Ve = u$2();
  ie === void 0 && Ve !== null && (ie = (Ve & i$3.Open) === i$3.Open);
  let $t = useRef(null), Nt = y$4($t, z), Dt = n$1($t), Wt = ie ? 0 : 1, [Pt, Lt] = useReducer(Ie, { titleId: null, descriptionId: null, panelRef: createRef() }), qt = o$4(() => oe(!1)), Zt = o$4((Rt) => Lt({ type: 0, id: Rt })), Yt = l$1() ? Wt === 0 : !1, [or, jt] = te$1(), Ct = { get current() {
    var Rt;
    return (Rt = Pt.panelRef.current) != null ? Rt : $t.current;
  } }, Vt = b(), { resolveContainers: kt } = R$1({ mainTreeNode: Vt, portals: or, defaultContainers: [Ct] }), Pe = Ve !== null ? (Ve & i$3.Closing) === i$3.Closing : !1;
  y$3(Ce || Pe ? !1 : Yt, { allowed: o$4(() => {
    var Rt, bt;
    return [(bt = (Rt = $t.current) == null ? void 0 : Rt.closest("[data-headlessui-portal]")) != null ? bt : null];
  }), disallowed: o$4(() => {
    var Rt;
    return [(Rt = Vt == null ? void 0 : Vt.closest("body > *:not(#headlessui-portal-root)")) != null ? Rt : null];
  }) }), R$3(Yt, kt, (Rt) => {
    Rt.preventDefault(), qt();
  }), a$3(Yt, Dt == null ? void 0 : Dt.defaultView, (Rt) => {
    Rt.preventDefault(), Rt.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), qt();
  }), f$5(Ce || Pe ? !1 : Yt, Dt, kt), m$2(Yt, $t, qt);
  let [Xe, ve] = w$4(), Ke = useMemo(() => [{ dialogState: Wt, close: qt, setTitleId: Zt, unmount: le }, Pt], [Wt, Pt, qt, Zt, le]), ht = useMemo(() => ({ open: Wt === 0 }), [Wt]), wt = { ref: Nt, id: ne, role: ae, tabIndex: -1, "aria-modal": Ce ? void 0 : Wt === 0 ? !0 : void 0, "aria-labelledby": Pt.titleId, "aria-describedby": Xe, unmount: le }, vt = !f$3(), xt = x$1.None;
  Yt && !Ce && (xt |= x$1.RestoreFocus, xt |= x$1.TabLock, ge && (xt |= x$1.AutoFocus), vt && (xt |= x$1.InitialFocus));
  let Qe = L$1();
  return React__default.createElement(s$5, null, React__default.createElement(l, { force: !0 }, React__default.createElement(re$1, null, React__default.createElement(k$1.Provider, { value: Ke }, React__default.createElement(X$1, { target: $t }, React__default.createElement(l, { force: !1 }, React__default.createElement(ve, { slot: ht }, React__default.createElement(jt, null, React__default.createElement(ye, { initialFocus: se, initialFocusFallback: $t, containers: kt, features: xt }, React__default.createElement(C$1, { value: qt }, Qe({ ourProps: wt, theirProps: Ee, slot: ht, defaultTag: Me, features: Ge, visible: Wt === 0, name: "Dialog" })))))))))));
}), Me = "div", Ge = O$3.RenderStrategy | O$3.Static;
function ke(B, z) {
  let { transition: Y = !1, open: ne, ...ie } = B, oe = u$2(), se = B.hasOwnProperty("open") || oe !== null, ae = B.hasOwnProperty("onClose");
  if (!se && !ae) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!se) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!ae) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!oe && typeof B.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${B.open}`);
  if (typeof B.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${B.onClose}`);
  return (ne !== void 0 || Y) && !ie.static ? React__default.createElement(O$1, null, React__default.createElement(ze$1, { show: ne, transition: Y, unmount: ie.unmount }, React__default.createElement(V, { ref: z, ...ie }))) : React__default.createElement(O$1, null, React__default.createElement(V, { ref: z, open: ne, ...ie }));
}
let we = "div";
function Be(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-panel-${Y}`, transition: ie = !1, ...oe } = B, [{ dialogState: se, unmount: ae }, ge] = O("Dialog.Panel"), Ce = y$4(z, ge.panelRef), le = useMemo(() => ({ open: se === 0 }), [se]), Ee = o$4((Dt) => {
    Dt.stopPropagation();
  }), Je = { ref: Ce, id: ne, onClick: Ee }, Ve = ie ? Fe : Fragment, $t = ie ? { unmount: ae } : {}, Nt = L$1();
  return React__default.createElement(Ve, { ...$t }, Nt({ ourProps: Je, theirProps: oe, slot: le, defaultTag: we, name: "Dialog.Panel" }));
}
let Ue = "div";
function He(B, z) {
  let { transition: Y = !1, ...ne } = B, [{ dialogState: ie, unmount: oe }] = O("Dialog.Backdrop"), se = useMemo(() => ({ open: ie === 0 }), [ie]), ae = { ref: z, "aria-hidden": !0 }, ge = Y ? Fe : Fragment, Ce = Y ? { unmount: oe } : {}, le = L$1();
  return React__default.createElement(ge, { ...Ce }, le({ ourProps: ae, theirProps: ne, slot: se, defaultTag: Ue, name: "Dialog.Backdrop" }));
}
let Ne = "h2";
function We(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-title-${Y}`, ...ie } = B, [{ dialogState: oe, setTitleId: se }] = O("Dialog.Title"), ae = y$4(z);
  useEffect(() => (se(ne), () => se(null)), [ne, se]);
  let ge = useMemo(() => ({ open: oe === 0 }), [oe]), Ce = { ref: ae, id: ne };
  return L$1()({ ourProps: Ce, theirProps: ie, slot: ge, defaultTag: Ne, name: "Dialog.Title" });
}
let $e = K$6(ke), je = K$6(Be);
K$6(He);
let Ye$1 = K$6(We), yt$1 = Object.assign($e, { Panel: je, Title: Ye$1, Description: H$2 });
function s$3(B, z) {
  let Y = useRef({ left: 0, top: 0 });
  if (n$3(() => {
    if (!z) return;
    let ie = z.getBoundingClientRect();
    ie && (Y.current = ie);
  }, [B, z]), z == null || !B || z === document.activeElement) return !1;
  let ne = z.getBoundingClientRect();
  return ne.top !== Y.current.top || ne.left !== Y.current.left;
}
let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var z, Y;
  let ne = (z = B.innerText) != null ? z : "", ie = B.cloneNode(!0);
  if (!(ie instanceof HTMLElement)) return ne;
  let oe = !1;
  for (let ae of ie.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ae.remove(), oe = !0;
  let se = oe ? (Y = ie.innerText) != null ? Y : "" : ne;
  return a.test(se) && (se = se.replace(a, "")), se;
}
function g$2(B) {
  let z = B.getAttribute("aria-label");
  if (typeof z == "string") return z.trim();
  let Y = B.getAttribute("aria-labelledby");
  if (Y) {
    let ne = Y.split(" ").map((ie) => {
      let oe = document.getElementById(ie);
      if (oe) {
        let se = oe.getAttribute("aria-label");
        return typeof se == "string" ? se.trim() : o$1(oe).trim();
      }
      return null;
    }).filter(Boolean);
    if (ne.length > 0) return ne.join(", ");
  }
  return o$1(B).trim();
}
function s$2(B) {
  let z = useRef(""), Y = useRef("");
  return o$4(() => {
    let ne = B.current;
    if (!ne) return "";
    let ie = ne.innerText;
    if (z.current === ie) return Y.current;
    let oe = g$2(ne).trim().toLowerCase();
    return z.current = ie, Y.current = oe, oe;
  });
}
var qe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(qe || {}), ze = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(ze || {}), Ye = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B[B.SetButtonElement = 7] = "SetButtonElement", B[B.SetItemsElement = 8] = "SetItemsElement", B))(Ye || {});
function j(B, z = (Y) => Y) {
  let Y = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, ne = _(z(B.items.slice()), (oe) => oe.dataRef.current.domRef.current), ie = Y ? ne.indexOf(Y) : null;
  return ie === -1 && (ie = null), { items: ne, activeItemIndex: ie };
}
let Ze = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, z) => {
  var Y, ne, ie, oe, se;
  if (B.menuState === 1) return B;
  let ae = { ...B, searchQuery: "", activationTrigger: (Y = z.trigger) != null ? Y : 1, __demoMode: !1 };
  if (z.focus === c$1.Nothing) return { ...ae, activeItemIndex: null };
  if (z.focus === c$1.Specific) return { ...ae, activeItemIndex: B.items.findIndex((le) => le.id === z.id) };
  if (z.focus === c$1.Previous) {
    let le = B.activeItemIndex;
    if (le !== null) {
      let Ee = B.items[le].dataRef.current.domRef, Je = f$4(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Ve) => Ve.id, resolveDisabled: (Ve) => Ve.dataRef.current.disabled });
      if (Je !== null) {
        let Ve = B.items[Je].dataRef.current.domRef;
        if (((ne = Ee.current) == null ? void 0 : ne.previousElementSibling) === Ve.current || ((ie = Ve.current) == null ? void 0 : ie.previousElementSibling) === null) return { ...ae, activeItemIndex: Je };
      }
    }
  } else if (z.focus === c$1.Next) {
    let le = B.activeItemIndex;
    if (le !== null) {
      let Ee = B.items[le].dataRef.current.domRef, Je = f$4(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Ve) => Ve.id, resolveDisabled: (Ve) => Ve.dataRef.current.disabled });
      if (Je !== null) {
        let Ve = B.items[Je].dataRef.current.domRef;
        if (((oe = Ee.current) == null ? void 0 : oe.nextElementSibling) === Ve.current || ((se = Ve.current) == null ? void 0 : se.nextElementSibling) === null) return { ...ae, activeItemIndex: Je };
      }
    }
  }
  let ge = j(B), Ce = f$4(z, { resolveItems: () => ge.items, resolveActiveIndex: () => ge.activeItemIndex, resolveId: (le) => le.id, resolveDisabled: (le) => le.dataRef.current.disabled });
  return { ...ae, ...ge, activeItemIndex: Ce };
}, 3: (B, z) => {
  let Y = B.searchQuery !== "" ? 0 : 1, ne = B.searchQuery + z.value.toLowerCase(), ie = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + Y).concat(B.items.slice(0, B.activeItemIndex + Y)) : B.items).find((se) => {
    var ae;
    return ((ae = se.dataRef.current.textValue) == null ? void 0 : ae.startsWith(ne)) && !se.dataRef.current.disabled;
  }), oe = ie ? B.items.indexOf(ie) : -1;
  return oe === -1 || oe === B.activeItemIndex ? { ...B, searchQuery: ne } : { ...B, searchQuery: ne, activeItemIndex: oe, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, z) => {
  let Y = j(B, (ne) => [...ne, { id: z.id, dataRef: z.dataRef }]);
  return { ...B, ...Y };
}, 6: (B, z) => {
  let Y = j(B, (ne) => {
    let ie = ne.findIndex((oe) => oe.id === z.id);
    return ie !== -1 && ne.splice(ie, 1), ne;
  });
  return { ...B, ...Y, activationTrigger: 1 };
}, 7: (B, z) => B.buttonElement === z.element ? B : { ...B, buttonElement: z.element }, 8: (B, z) => B.itemsElement === z.element ? B : { ...B, itemsElement: z.element } }, Q = createContext(null);
Q.displayName = "MenuContext";
function w(B) {
  let z = useContext(Q);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, w), Y;
  }
  return z;
}
function et(B, z) {
  return u$7(z.type, Ze, B, z);
}
let tt = Fragment;
function nt(B, z) {
  let { __demoMode: Y = !1, ...ne } = B, ie = useReducer(et, { __demoMode: Y, menuState: Y ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: oe, itemsElement: se, buttonElement: ae }, ge] = ie, Ce = y$4(z);
  R$3(oe === 0, [ae, se], ($t, Nt) => {
    ge({ type: 1 }), A(Nt, h$2.Loose) || ($t.preventDefault(), ae == null || ae.focus());
  });
  let le = o$4(() => {
    ge({ type: 1 });
  }), Ee = useMemo(() => ({ open: oe === 0, close: le }), [oe, le]), Je = { ref: Ce }, Ve = L$1();
  return React__default.createElement(Me$1, null, React__default.createElement(Q.Provider, { value: ie }, React__default.createElement(c$2, { value: u$7(oe, { 0: i$3.Open, 1: i$3.Closed }) }, Ve({ ourProps: Je, theirProps: ne, slot: Ee, defaultTag: tt, name: "Menu" }))));
}
let rt = "button";
function ot(B, z) {
  var Y;
  let ne = useId$1(), { id: ie = `headlessui-menu-button-${ne}`, disabled: oe = !1, autoFocus: se = !1, ...ae } = B, [ge, Ce] = w("Menu.Button"), le = Fe$1(), Ee = y$4(z, ye$1(), o$4((or) => Ce({ type: 7, element: or }))), Je = o$4((or) => {
    switch (or.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        or.preventDefault(), or.stopPropagation(), flushSync(() => Ce({ type: 0 })), Ce({ type: 2, focus: c$1.First });
        break;
      case o$3.ArrowUp:
        or.preventDefault(), or.stopPropagation(), flushSync(() => Ce({ type: 0 })), Ce({ type: 2, focus: c$1.Last });
        break;
    }
  }), Ve = o$4((or) => {
    switch (or.key) {
      case o$3.Space:
        or.preventDefault();
        break;
    }
  }), $t = o$4((or) => {
    var jt;
    if (r$4(or.currentTarget)) return or.preventDefault();
    oe || (ge.menuState === 0 ? (flushSync(() => Ce({ type: 1 })), (jt = ge.buttonElement) == null || jt.focus({ preventScroll: !0 })) : (or.preventDefault(), Ce({ type: 0 })));
  }), { isFocusVisible: Nt, focusProps: Dt } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: se }), { isHovered: Wt, hoverProps: Pt } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: oe }), { pressed: Lt, pressProps: qt } = w$5({ disabled: oe }), Zt = useMemo(() => ({ open: ge.menuState === 0, active: Lt || ge.menuState === 0, disabled: oe, hover: Wt, focus: Nt, autofocus: se }), [ge, Wt, Nt, Lt, oe, se]), Yt = _$2(le(), { ref: Ee, id: ie, type: e$1(B, ge.buttonElement), "aria-haspopup": "menu", "aria-controls": (Y = ge.itemsElement) == null ? void 0 : Y.id, "aria-expanded": ge.menuState === 0, disabled: oe || void 0, autoFocus: se, onKeyDown: Je, onKeyUp: Ve, onClick: $t }, Dt, Pt, qt);
  return L$1()({ ourProps: Yt, theirProps: ae, slot: Zt, defaultTag: rt, name: "Menu.Button" });
}
let at = "div", lt = O$3.RenderStrategy | O$3.Static;
function it(B, z) {
  var Y, ne;
  let ie = useId$1(), { id: oe = `headlessui-menu-items-${ie}`, anchor: se, portal: ae = !1, modal: ge = !0, transition: Ce = !1, ...le } = B, Ee = xe(se), [Je, Ve] = w("Menu.Items"), [$t, Nt] = Re(Ee), Dt = be(), [Wt, Pt] = useState(null), Lt = y$4(z, Ee ? $t : null, o$4((vt) => Ve({ type: 8, element: vt })), Pt), qt = n$1(Je.itemsElement);
  Ee && (ae = !0);
  let Zt = u$2(), [Yt, or] = x$2(Ce, Wt, Zt !== null ? (Zt & i$3.Open) === i$3.Open : Je.menuState === 0);
  m$2(Yt, Je.buttonElement, () => {
    Ve({ type: 1 });
  });
  let jt = Je.__demoMode ? !1 : ge && Je.menuState === 0;
  f$5(jt, qt);
  let Ct = Je.__demoMode ? !1 : ge && Je.menuState === 0;
  y$3(Ct, { allowed: useCallback(() => [Je.buttonElement, Je.itemsElement], [Je.buttonElement, Je.itemsElement]) });
  let Vt = Je.menuState !== 0, kt = s$3(Vt, Je.buttonElement) ? !1 : Yt;
  useEffect(() => {
    let vt = Je.itemsElement;
    vt && Je.menuState === 0 && vt !== (qt == null ? void 0 : qt.activeElement) && vt.focus({ preventScroll: !0 });
  }, [Je.menuState, Je.itemsElement, qt]), F(Je.menuState === 0, { container: Je.itemsElement, accept(vt) {
    return vt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : vt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(vt) {
    vt.setAttribute("role", "none");
  } });
  let Pe = p$2(), Xe = o$4((vt) => {
    var xt, Qe, Rt;
    switch (Pe.dispose(), vt.key) {
      case o$3.Space:
        if (Je.searchQuery !== "") return vt.preventDefault(), vt.stopPropagation(), Ve({ type: 3, value: vt.key });
      case o$3.Enter:
        if (vt.preventDefault(), vt.stopPropagation(), Ve({ type: 1 }), Je.activeItemIndex !== null) {
          let { dataRef: bt } = Je.items[Je.activeItemIndex];
          (Qe = (xt = bt.current) == null ? void 0 : xt.domRef.current) == null || Qe.click();
        }
        G$1(Je.buttonElement);
        break;
      case o$3.ArrowDown:
        return vt.preventDefault(), vt.stopPropagation(), Ve({ type: 2, focus: c$1.Next });
      case o$3.ArrowUp:
        return vt.preventDefault(), vt.stopPropagation(), Ve({ type: 2, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return vt.preventDefault(), vt.stopPropagation(), Ve({ type: 2, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return vt.preventDefault(), vt.stopPropagation(), Ve({ type: 2, focus: c$1.Last });
      case o$3.Escape:
        vt.preventDefault(), vt.stopPropagation(), flushSync(() => Ve({ type: 1 })), (Rt = Je.buttonElement) == null || Rt.focus({ preventScroll: !0 });
        break;
      case o$3.Tab:
        vt.preventDefault(), vt.stopPropagation(), flushSync(() => Ve({ type: 1 })), j$3(Je.buttonElement, vt.shiftKey ? F$1.Previous : F$1.Next);
        break;
      default:
        vt.key.length === 1 && (Ve({ type: 3, value: vt.key }), Pe.setTimeout(() => Ve({ type: 4 }), 350));
        break;
    }
  }), ve = o$4((vt) => {
    switch (vt.key) {
      case o$3.Space:
        vt.preventDefault();
        break;
    }
  }), Ke = useMemo(() => ({ open: Je.menuState === 0 }), [Je.menuState]), ht = _$2(Ee ? Dt() : {}, { "aria-activedescendant": Je.activeItemIndex === null || (Y = Je.items[Je.activeItemIndex]) == null ? void 0 : Y.id, "aria-labelledby": (ne = Je.buttonElement) == null ? void 0 : ne.id, id: oe, onKeyDown: Xe, onKeyUp: ve, role: "menu", tabIndex: Je.menuState === 0 ? 0 : void 0, ref: Lt, style: { ...le.style, ...Nt, "--button-width": d$2(Je.buttonElement, !0).width }, ...R$2(or) }), wt = L$1();
  return React__default.createElement(re$1, { enabled: ae ? B.static || Yt : !1 }, wt({ ourProps: ht, theirProps: le, slot: Ke, defaultTag: at, features: lt, visible: kt, name: "Menu.Items" }));
}
let st = Fragment;
function ut(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-item-${Y}`, disabled: ie = !1, ...oe } = B, [se, ae] = w("Menu.Item"), ge = se.activeItemIndex !== null ? se.items[se.activeItemIndex].id === ne : !1, Ce = useRef(null), le = y$4(z, Ce);
  n$3(() => {
    if (!se.__demoMode && se.menuState === 0 && ge && se.activationTrigger !== 0) return o$5().requestAnimationFrame(() => {
      var kt, Pe;
      (Pe = (kt = Ce.current) == null ? void 0 : kt.scrollIntoView) == null || Pe.call(kt, { block: "nearest" });
    });
  }, [se.__demoMode, Ce, ge, se.menuState, se.activationTrigger, se.activeItemIndex]);
  let Ee = s$2(Ce), Je = useRef({ disabled: ie, domRef: Ce, get textValue() {
    return Ee();
  } });
  n$3(() => {
    Je.current.disabled = ie;
  }, [Je, ie]), n$3(() => (ae({ type: 5, id: ne, dataRef: Je }), () => ae({ type: 6, id: ne })), [Je, ne]);
  let Ve = o$4(() => {
    ae({ type: 1 });
  }), $t = o$4((kt) => {
    if (ie) return kt.preventDefault();
    ae({ type: 1 }), G$1(se.buttonElement);
  }), Nt = o$4(() => {
    if (ie) return ae({ type: 2, focus: c$1.Nothing });
    ae({ type: 2, focus: c$1.Specific, id: ne });
  }), Dt = u$3(), Wt = o$4((kt) => {
    Dt.update(kt), !ie && (ge || ae({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), Pt = o$4((kt) => {
    Dt.wasMoved(kt) && (ie || ge || ae({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), Lt = o$4((kt) => {
    Dt.wasMoved(kt) && (ie || ge && ae({ type: 2, focus: c$1.Nothing }));
  }), [qt, Zt] = K$5(), [Yt, or] = w$4(), jt = useMemo(() => ({ active: ge, focus: ge, disabled: ie, close: Ve }), [ge, ie, Ve]), Ct = { id: ne, ref: le, role: "menuitem", tabIndex: ie === !0 ? void 0 : -1, "aria-disabled": ie === !0 ? !0 : void 0, "aria-labelledby": qt, "aria-describedby": Yt, disabled: void 0, onClick: $t, onFocus: Nt, onPointerEnter: Wt, onMouseEnter: Wt, onPointerMove: Pt, onMouseMove: Pt, onPointerLeave: Lt, onMouseLeave: Lt }, Vt = L$1();
  return React__default.createElement(Zt, null, React__default.createElement(or, null, Vt({ ourProps: Ct, theirProps: oe, slot: jt, defaultTag: st, name: "Menu.Item" })));
}
let pt = "div";
function mt(B, z) {
  let [Y, ne] = K$5(), ie = B, oe = { ref: z, "aria-labelledby": Y, role: "group" }, se = L$1();
  return React__default.createElement(ne, null, se({ ourProps: oe, theirProps: ie, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
let dt = "header";
function ct(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-heading-${Y}`, ...ie } = B, oe = P$1();
  n$3(() => oe.register(ne), [ne, oe.register]);
  let se = { id: ne, ref: z, role: "presentation", ...oe.props };
  return L$1()({ ourProps: se, theirProps: ie, slot: {}, defaultTag: dt, name: "Menu.Heading" });
}
let ft$2 = "div";
function Tt(B, z) {
  let Y = B, ne = { ref: z, role: "separator" };
  return L$1()({ ourProps: ne, theirProps: Y, slot: {}, defaultTag: ft$2, name: "Menu.Separator" });
}
let yt = K$6(nt), It = K$6(ot), gt = K$6(it), Et = K$6(ut), Mt = K$6(mt), St = K$6(ct), At = K$6(Tt), rn = Object.assign(yt, { Button: It, Items: gt, Item: Et, Section: Mt, Heading: St, Separator: At });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, z = 4, Y = 5) {
  if (B.length <= z + Y)
    return B;
  const ne = B.slice(0, z), ie = B.slice(B.length - Y);
  return `${ne}...${ie}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: z,
  onViewProfile: Y,
  onChangeWallet: ne,
  onDisconnectWallet: ie,
  renderAvatar: oe
}) {
  const { wallet: se } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    rn,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: ae }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            oe ? oe(B, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: B,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[se],
                alt: `${se} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[z] ?? z })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${ae ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => Y == null ? void 0 : Y(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ne == null ? void 0 : ne(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ie == null ? void 0 : ie(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: B,
  disabled: z
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: z,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength$1(B) {
  var z = getLens$1(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength$1(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray$1(B) {
  var z, Y = getLens$1(B), ne = Y[0], ie = Y[1], oe = new Arr$1(_byteLength$1(B, ne, ie)), se = 0, ae = ie > 0 ? ne - 4 : ne, ge;
  for (ge = 0; ge < ae; ge += 4)
    z = revLookup$1[B.charCodeAt(ge)] << 18 | revLookup$1[B.charCodeAt(ge + 1)] << 12 | revLookup$1[B.charCodeAt(ge + 2)] << 6 | revLookup$1[B.charCodeAt(ge + 3)], oe[se++] = z >> 16 & 255, oe[se++] = z >> 8 & 255, oe[se++] = z & 255;
  return ie === 2 && (z = revLookup$1[B.charCodeAt(ge)] << 2 | revLookup$1[B.charCodeAt(ge + 1)] >> 4, oe[se++] = z & 255), ie === 1 && (z = revLookup$1[B.charCodeAt(ge)] << 10 | revLookup$1[B.charCodeAt(ge + 1)] << 4 | revLookup$1[B.charCodeAt(ge + 2)] >> 2, oe[se++] = z >> 8 & 255, oe[se++] = z & 255), oe;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, z, Y) {
  for (var ne, ie = [], oe = z; oe < Y; oe += 3)
    ne = (B[oe] << 16 & 16711680) + (B[oe + 1] << 8 & 65280) + (B[oe + 2] & 255), ie.push(tripletToBase64$1(ne));
  return ie.join("");
}
function fromByteArray$1(B) {
  for (var z, Y = B.length, ne = Y % 3, ie = [], oe = 16383, se = 0, ae = Y - ne; se < ae; se += oe)
    ie.push(encodeChunk$1(B, se, se + oe > ae ? ae : se + oe));
  return ne === 1 ? (z = B[Y - 1], ie.push(
    lookup$1[z >> 2] + lookup$1[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], ie.push(
    lookup$1[z >> 10] + lookup$1[z >> 4 & 63] + lookup$1[z << 2 & 63] + "="
  )), ie.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, z, Y, ne, ie) {
  var oe, se, ae = ie * 8 - ne - 1, ge = (1 << ae) - 1, Ce = ge >> 1, le = -7, Ee = Y ? ie - 1 : 0, Je = Y ? -1 : 1, Ve = B[z + Ee];
  for (Ee += Je, oe = Ve & (1 << -le) - 1, Ve >>= -le, le += ae; le > 0; oe = oe * 256 + B[z + Ee], Ee += Je, le -= 8)
    ;
  for (se = oe & (1 << -le) - 1, oe >>= -le, le += ne; le > 0; se = se * 256 + B[z + Ee], Ee += Je, le -= 8)
    ;
  if (oe === 0)
    oe = 1 - Ce;
  else {
    if (oe === ge)
      return se ? NaN : (Ve ? -1 : 1) * (1 / 0);
    se = se + Math.pow(2, ne), oe = oe - Ce;
  }
  return (Ve ? -1 : 1) * se * Math.pow(2, oe - ne);
};
ieee754.write = function(B, z, Y, ne, ie, oe) {
  var se, ae, ge, Ce = oe * 8 - ie - 1, le = (1 << Ce) - 1, Ee = le >> 1, Je = ie === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ve = ne ? 0 : oe - 1, $t = ne ? 1 : -1, Nt = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
  for (z = Math.abs(z), isNaN(z) || z === 1 / 0 ? (ae = isNaN(z) ? 1 : 0, se = le) : (se = Math.floor(Math.log(z) / Math.LN2), z * (ge = Math.pow(2, -se)) < 1 && (se--, ge *= 2), se + Ee >= 1 ? z += Je / ge : z += Je * Math.pow(2, 1 - Ee), z * ge >= 2 && (se++, ge /= 2), se + Ee >= le ? (ae = 0, se = le) : se + Ee >= 1 ? (ae = (z * ge - 1) * Math.pow(2, ie), se = se + Ee) : (ae = z * Math.pow(2, Ee - 1) * Math.pow(2, ie), se = 0)); ie >= 8; B[Y + Ve] = ae & 255, Ve += $t, ae /= 256, ie -= 8)
    ;
  for (se = se << ie | ae, Ce += ie; Ce > 0; B[Y + Ve] = se & 255, Ve += $t, se /= 256, Ce -= 8)
    ;
  B[Y + Ve - $t] |= Nt * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const z = base64Js$1, Y = ieee754, ne = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = le, B.SlowBuffer = Zt, B.INSPECT_MAX_BYTES = 50;
  const ie = 2147483647;
  B.kMaxLength = ie;
  const { Uint8Array: oe, ArrayBuffer: se, SharedArrayBuffer: ae } = globalThis;
  le.TYPED_ARRAY_SUPPORT = ge(), !le.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ge() {
    try {
      const zt = new oe(1), Ot = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Ot, oe.prototype), Object.setPrototypeOf(zt, Ot), zt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(le.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(le.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Ce(zt) {
    if (zt > ie)
      throw new RangeError('The value "' + zt + '" is invalid for option "size"');
    const Ot = new oe(zt);
    return Object.setPrototypeOf(Ot, le.prototype), Ot;
  }
  function le(zt, Ot, Ut) {
    if (typeof zt == "number") {
      if (typeof Ot == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return $t(zt);
    }
    return Ee(zt, Ot, Ut);
  }
  le.poolSize = 8192;
  function Ee(zt, Ot, Ut) {
    if (typeof zt == "string")
      return Nt(zt, Ot);
    if (se.isView(zt))
      return Wt(zt);
    if (zt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof zt
      );
    if (Vr(zt, se) || zt && Vr(zt.buffer, se) || typeof ae < "u" && (Vr(zt, ae) || zt && Vr(zt.buffer, ae)))
      return Pt(zt, Ot, Ut);
    if (typeof zt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const tr = zt.valueOf && zt.valueOf();
    if (tr != null && tr !== zt)
      return le.from(tr, Ot, Ut);
    const lr = Lt(zt);
    if (lr) return lr;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof zt[Symbol.toPrimitive] == "function")
      return le.from(zt[Symbol.toPrimitive]("string"), Ot, Ut);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof zt
    );
  }
  le.from = function(zt, Ot, Ut) {
    return Ee(zt, Ot, Ut);
  }, Object.setPrototypeOf(le.prototype, oe.prototype), Object.setPrototypeOf(le, oe);
  function Je(zt) {
    if (typeof zt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (zt < 0)
      throw new RangeError('The value "' + zt + '" is invalid for option "size"');
  }
  function Ve(zt, Ot, Ut) {
    return Je(zt), zt <= 0 ? Ce(zt) : Ot !== void 0 ? typeof Ut == "string" ? Ce(zt).fill(Ot, Ut) : Ce(zt).fill(Ot) : Ce(zt);
  }
  le.alloc = function(zt, Ot, Ut) {
    return Ve(zt, Ot, Ut);
  };
  function $t(zt) {
    return Je(zt), Ce(zt < 0 ? 0 : qt(zt) | 0);
  }
  le.allocUnsafe = function(zt) {
    return $t(zt);
  }, le.allocUnsafeSlow = function(zt) {
    return $t(zt);
  };
  function Nt(zt, Ot) {
    if ((typeof Ot != "string" || Ot === "") && (Ot = "utf8"), !le.isEncoding(Ot))
      throw new TypeError("Unknown encoding: " + Ot);
    const Ut = Yt(zt, Ot) | 0;
    let tr = Ce(Ut);
    const lr = tr.write(zt, Ot);
    return lr !== Ut && (tr = tr.slice(0, lr)), tr;
  }
  function Dt(zt) {
    const Ot = zt.length < 0 ? 0 : qt(zt.length) | 0, Ut = Ce(Ot);
    for (let tr = 0; tr < Ot; tr += 1)
      Ut[tr] = zt[tr] & 255;
    return Ut;
  }
  function Wt(zt) {
    if (Vr(zt, oe)) {
      const Ot = new oe(zt);
      return Pt(Ot.buffer, Ot.byteOffset, Ot.byteLength);
    }
    return Dt(zt);
  }
  function Pt(zt, Ot, Ut) {
    if (Ot < 0 || zt.byteLength < Ot)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (zt.byteLength < Ot + (Ut || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let tr;
    return Ot === void 0 && Ut === void 0 ? tr = new oe(zt) : Ut === void 0 ? tr = new oe(zt, Ot) : tr = new oe(zt, Ot, Ut), Object.setPrototypeOf(tr, le.prototype), tr;
  }
  function Lt(zt) {
    if (le.isBuffer(zt)) {
      const Ot = qt(zt.length) | 0, Ut = Ce(Ot);
      return Ut.length === 0 || zt.copy(Ut, 0, 0, Ot), Ut;
    }
    if (zt.length !== void 0)
      return typeof zt.length != "number" || Zr(zt.length) ? Ce(0) : Dt(zt);
    if (zt.type === "Buffer" && Array.isArray(zt.data))
      return Dt(zt.data);
  }
  function qt(zt) {
    if (zt >= ie)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ie.toString(16) + " bytes");
    return zt | 0;
  }
  function Zt(zt) {
    return +zt != zt && (zt = 0), le.alloc(+zt);
  }
  le.isBuffer = function(Ot) {
    return Ot != null && Ot._isBuffer === !0 && Ot !== le.prototype;
  }, le.compare = function(Ot, Ut) {
    if (Vr(Ot, oe) && (Ot = le.from(Ot, Ot.offset, Ot.byteLength)), Vr(Ut, oe) && (Ut = le.from(Ut, Ut.offset, Ut.byteLength)), !le.isBuffer(Ot) || !le.isBuffer(Ut))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Ot === Ut) return 0;
    let tr = Ot.length, lr = Ut.length;
    for (let vr = 0, _r = Math.min(tr, lr); vr < _r; ++vr)
      if (Ot[vr] !== Ut[vr]) {
        tr = Ot[vr], lr = Ut[vr];
        break;
      }
    return tr < lr ? -1 : lr < tr ? 1 : 0;
  }, le.isEncoding = function(Ot) {
    switch (String(Ot).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, le.concat = function(Ot, Ut) {
    if (!Array.isArray(Ot))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Ot.length === 0)
      return le.alloc(0);
    let tr;
    if (Ut === void 0)
      for (Ut = 0, tr = 0; tr < Ot.length; ++tr)
        Ut += Ot[tr].length;
    const lr = le.allocUnsafe(Ut);
    let vr = 0;
    for (tr = 0; tr < Ot.length; ++tr) {
      let _r = Ot[tr];
      if (Vr(_r, oe))
        vr + _r.length > lr.length ? (le.isBuffer(_r) || (_r = le.from(_r)), _r.copy(lr, vr)) : oe.prototype.set.call(
          lr,
          _r,
          vr
        );
      else if (le.isBuffer(_r))
        _r.copy(lr, vr);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      vr += _r.length;
    }
    return lr;
  };
  function Yt(zt, Ot) {
    if (le.isBuffer(zt))
      return zt.length;
    if (se.isView(zt) || Vr(zt, se))
      return zt.byteLength;
    if (typeof zt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof zt
      );
    const Ut = zt.length, tr = arguments.length > 2 && arguments[2] === !0;
    if (!tr && Ut === 0) return 0;
    let lr = !1;
    for (; ; )
      switch (Ot) {
        case "ascii":
        case "latin1":
        case "binary":
          return Ut;
        case "utf8":
        case "utf-8":
          return Qr(zt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ut * 2;
        case "hex":
          return Ut >>> 1;
        case "base64":
          return Gr(zt).length;
        default:
          if (lr)
            return tr ? -1 : Qr(zt).length;
          Ot = ("" + Ot).toLowerCase(), lr = !0;
      }
  }
  le.byteLength = Yt;
  function or(zt, Ot, Ut) {
    let tr = !1;
    if ((Ot === void 0 || Ot < 0) && (Ot = 0), Ot > this.length || ((Ut === void 0 || Ut > this.length) && (Ut = this.length), Ut <= 0) || (Ut >>>= 0, Ot >>>= 0, Ut <= Ot))
      return "";
    for (zt || (zt = "utf8"); ; )
      switch (zt) {
        case "hex":
          return bt(this, Ot, Ut);
        case "utf8":
        case "utf-8":
          return wt(this, Ot, Ut);
        case "ascii":
          return Qe(this, Ot, Ut);
        case "latin1":
        case "binary":
          return Rt(this, Ot, Ut);
        case "base64":
          return ht(this, Ot, Ut);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ht(this, Ot, Ut);
        default:
          if (tr) throw new TypeError("Unknown encoding: " + zt);
          zt = (zt + "").toLowerCase(), tr = !0;
      }
  }
  le.prototype._isBuffer = !0;
  function jt(zt, Ot, Ut) {
    const tr = zt[Ot];
    zt[Ot] = zt[Ut], zt[Ut] = tr;
  }
  le.prototype.swap16 = function() {
    const Ot = this.length;
    if (Ot % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Ut = 0; Ut < Ot; Ut += 2)
      jt(this, Ut, Ut + 1);
    return this;
  }, le.prototype.swap32 = function() {
    const Ot = this.length;
    if (Ot % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Ut = 0; Ut < Ot; Ut += 4)
      jt(this, Ut, Ut + 3), jt(this, Ut + 1, Ut + 2);
    return this;
  }, le.prototype.swap64 = function() {
    const Ot = this.length;
    if (Ot % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Ut = 0; Ut < Ot; Ut += 8)
      jt(this, Ut, Ut + 7), jt(this, Ut + 1, Ut + 6), jt(this, Ut + 2, Ut + 5), jt(this, Ut + 3, Ut + 4);
    return this;
  }, le.prototype.toString = function() {
    const Ot = this.length;
    return Ot === 0 ? "" : arguments.length === 0 ? wt(this, 0, Ot) : or.apply(this, arguments);
  }, le.prototype.toLocaleString = le.prototype.toString, le.prototype.equals = function(Ot) {
    if (!le.isBuffer(Ot)) throw new TypeError("Argument must be a Buffer");
    return this === Ot ? !0 : le.compare(this, Ot) === 0;
  }, le.prototype.inspect = function() {
    let Ot = "";
    const Ut = B.INSPECT_MAX_BYTES;
    return Ot = this.toString("hex", 0, Ut).replace(/(.{2})/g, "$1 ").trim(), this.length > Ut && (Ot += " ... "), "<Buffer " + Ot + ">";
  }, ne && (le.prototype[ne] = le.prototype.inspect), le.prototype.compare = function(Ot, Ut, tr, lr, vr) {
    if (Vr(Ot, oe) && (Ot = le.from(Ot, Ot.offset, Ot.byteLength)), !le.isBuffer(Ot))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ot
      );
    if (Ut === void 0 && (Ut = 0), tr === void 0 && (tr = Ot ? Ot.length : 0), lr === void 0 && (lr = 0), vr === void 0 && (vr = this.length), Ut < 0 || tr > Ot.length || lr < 0 || vr > this.length)
      throw new RangeError("out of range index");
    if (lr >= vr && Ut >= tr)
      return 0;
    if (lr >= vr)
      return -1;
    if (Ut >= tr)
      return 1;
    if (Ut >>>= 0, tr >>>= 0, lr >>>= 0, vr >>>= 0, this === Ot) return 0;
    let _r = vr - lr, Rr = tr - Ut;
    const Wr = Math.min(_r, Rr), Ir = this.slice(lr, vr), Hr = Ot.slice(Ut, tr);
    for (let Fr = 0; Fr < Wr; ++Fr)
      if (Ir[Fr] !== Hr[Fr]) {
        _r = Ir[Fr], Rr = Hr[Fr];
        break;
      }
    return _r < Rr ? -1 : Rr < _r ? 1 : 0;
  };
  function Ct(zt, Ot, Ut, tr, lr) {
    if (zt.length === 0) return -1;
    if (typeof Ut == "string" ? (tr = Ut, Ut = 0) : Ut > 2147483647 ? Ut = 2147483647 : Ut < -2147483648 && (Ut = -2147483648), Ut = +Ut, Zr(Ut) && (Ut = lr ? 0 : zt.length - 1), Ut < 0 && (Ut = zt.length + Ut), Ut >= zt.length) {
      if (lr) return -1;
      Ut = zt.length - 1;
    } else if (Ut < 0)
      if (lr) Ut = 0;
      else return -1;
    if (typeof Ot == "string" && (Ot = le.from(Ot, tr)), le.isBuffer(Ot))
      return Ot.length === 0 ? -1 : Vt(zt, Ot, Ut, tr, lr);
    if (typeof Ot == "number")
      return Ot = Ot & 255, typeof oe.prototype.indexOf == "function" ? lr ? oe.prototype.indexOf.call(zt, Ot, Ut) : oe.prototype.lastIndexOf.call(zt, Ot, Ut) : Vt(zt, [Ot], Ut, tr, lr);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Vt(zt, Ot, Ut, tr, lr) {
    let vr = 1, _r = zt.length, Rr = Ot.length;
    if (tr !== void 0 && (tr = String(tr).toLowerCase(), tr === "ucs2" || tr === "ucs-2" || tr === "utf16le" || tr === "utf-16le")) {
      if (zt.length < 2 || Ot.length < 2)
        return -1;
      vr = 2, _r /= 2, Rr /= 2, Ut /= 2;
    }
    function Wr(Hr, Fr) {
      return vr === 1 ? Hr[Fr] : Hr.readUInt16BE(Fr * vr);
    }
    let Ir;
    if (lr) {
      let Hr = -1;
      for (Ir = Ut; Ir < _r; Ir++)
        if (Wr(zt, Ir) === Wr(Ot, Hr === -1 ? 0 : Ir - Hr)) {
          if (Hr === -1 && (Hr = Ir), Ir - Hr + 1 === Rr) return Hr * vr;
        } else
          Hr !== -1 && (Ir -= Ir - Hr), Hr = -1;
    } else
      for (Ut + Rr > _r && (Ut = _r - Rr), Ir = Ut; Ir >= 0; Ir--) {
        let Hr = !0;
        for (let Fr = 0; Fr < Rr; Fr++)
          if (Wr(zt, Ir + Fr) !== Wr(Ot, Fr)) {
            Hr = !1;
            break;
          }
        if (Hr) return Ir;
      }
    return -1;
  }
  le.prototype.includes = function(Ot, Ut, tr) {
    return this.indexOf(Ot, Ut, tr) !== -1;
  }, le.prototype.indexOf = function(Ot, Ut, tr) {
    return Ct(this, Ot, Ut, tr, !0);
  }, le.prototype.lastIndexOf = function(Ot, Ut, tr) {
    return Ct(this, Ot, Ut, tr, !1);
  };
  function kt(zt, Ot, Ut, tr) {
    Ut = Number(Ut) || 0;
    const lr = zt.length - Ut;
    tr ? (tr = Number(tr), tr > lr && (tr = lr)) : tr = lr;
    const vr = Ot.length;
    tr > vr / 2 && (tr = vr / 2);
    let _r;
    for (_r = 0; _r < tr; ++_r) {
      const Rr = parseInt(Ot.substr(_r * 2, 2), 16);
      if (Zr(Rr)) return _r;
      zt[Ut + _r] = Rr;
    }
    return _r;
  }
  function Pe(zt, Ot, Ut, tr) {
    return Or(Qr(Ot, zt.length - Ut), zt, Ut, tr);
  }
  function Xe(zt, Ot, Ut, tr) {
    return Or(jr(Ot), zt, Ut, tr);
  }
  function ve(zt, Ot, Ut, tr) {
    return Or(Gr(Ot), zt, Ut, tr);
  }
  function Ke(zt, Ot, Ut, tr) {
    return Or(qr(Ot, zt.length - Ut), zt, Ut, tr);
  }
  le.prototype.write = function(Ot, Ut, tr, lr) {
    if (Ut === void 0)
      lr = "utf8", tr = this.length, Ut = 0;
    else if (tr === void 0 && typeof Ut == "string")
      lr = Ut, tr = this.length, Ut = 0;
    else if (isFinite(Ut))
      Ut = Ut >>> 0, isFinite(tr) ? (tr = tr >>> 0, lr === void 0 && (lr = "utf8")) : (lr = tr, tr = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const vr = this.length - Ut;
    if ((tr === void 0 || tr > vr) && (tr = vr), Ot.length > 0 && (tr < 0 || Ut < 0) || Ut > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    lr || (lr = "utf8");
    let _r = !1;
    for (; ; )
      switch (lr) {
        case "hex":
          return kt(this, Ot, Ut, tr);
        case "utf8":
        case "utf-8":
          return Pe(this, Ot, Ut, tr);
        case "ascii":
        case "latin1":
        case "binary":
          return Xe(this, Ot, Ut, tr);
        case "base64":
          return ve(this, Ot, Ut, tr);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ke(this, Ot, Ut, tr);
        default:
          if (_r) throw new TypeError("Unknown encoding: " + lr);
          lr = ("" + lr).toLowerCase(), _r = !0;
      }
  }, le.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ht(zt, Ot, Ut) {
    return Ot === 0 && Ut === zt.length ? z.fromByteArray(zt) : z.fromByteArray(zt.slice(Ot, Ut));
  }
  function wt(zt, Ot, Ut) {
    Ut = Math.min(zt.length, Ut);
    const tr = [];
    let lr = Ot;
    for (; lr < Ut; ) {
      const vr = zt[lr];
      let _r = null, Rr = vr > 239 ? 4 : vr > 223 ? 3 : vr > 191 ? 2 : 1;
      if (lr + Rr <= Ut) {
        let Wr, Ir, Hr, Fr;
        switch (Rr) {
          case 1:
            vr < 128 && (_r = vr);
            break;
          case 2:
            Wr = zt[lr + 1], (Wr & 192) === 128 && (Fr = (vr & 31) << 6 | Wr & 63, Fr > 127 && (_r = Fr));
            break;
          case 3:
            Wr = zt[lr + 1], Ir = zt[lr + 2], (Wr & 192) === 128 && (Ir & 192) === 128 && (Fr = (vr & 15) << 12 | (Wr & 63) << 6 | Ir & 63, Fr > 2047 && (Fr < 55296 || Fr > 57343) && (_r = Fr));
            break;
          case 4:
            Wr = zt[lr + 1], Ir = zt[lr + 2], Hr = zt[lr + 3], (Wr & 192) === 128 && (Ir & 192) === 128 && (Hr & 192) === 128 && (Fr = (vr & 15) << 18 | (Wr & 63) << 12 | (Ir & 63) << 6 | Hr & 63, Fr > 65535 && Fr < 1114112 && (_r = Fr));
        }
      }
      _r === null ? (_r = 65533, Rr = 1) : _r > 65535 && (_r -= 65536, tr.push(_r >>> 10 & 1023 | 55296), _r = 56320 | _r & 1023), tr.push(_r), lr += Rr;
    }
    return xt(tr);
  }
  const vt = 4096;
  function xt(zt) {
    const Ot = zt.length;
    if (Ot <= vt)
      return String.fromCharCode.apply(String, zt);
    let Ut = "", tr = 0;
    for (; tr < Ot; )
      Ut += String.fromCharCode.apply(
        String,
        zt.slice(tr, tr += vt)
      );
    return Ut;
  }
  function Qe(zt, Ot, Ut) {
    let tr = "";
    Ut = Math.min(zt.length, Ut);
    for (let lr = Ot; lr < Ut; ++lr)
      tr += String.fromCharCode(zt[lr] & 127);
    return tr;
  }
  function Rt(zt, Ot, Ut) {
    let tr = "";
    Ut = Math.min(zt.length, Ut);
    for (let lr = Ot; lr < Ut; ++lr)
      tr += String.fromCharCode(zt[lr]);
    return tr;
  }
  function bt(zt, Ot, Ut) {
    const tr = zt.length;
    (!Ot || Ot < 0) && (Ot = 0), (!Ut || Ut < 0 || Ut > tr) && (Ut = tr);
    let lr = "";
    for (let vr = Ot; vr < Ut; ++vr)
      lr += Lr[zt[vr]];
    return lr;
  }
  function Ht(zt, Ot, Ut) {
    const tr = zt.slice(Ot, Ut);
    let lr = "";
    for (let vr = 0; vr < tr.length - 1; vr += 2)
      lr += String.fromCharCode(tr[vr] + tr[vr + 1] * 256);
    return lr;
  }
  le.prototype.slice = function(Ot, Ut) {
    const tr = this.length;
    Ot = ~~Ot, Ut = Ut === void 0 ? tr : ~~Ut, Ot < 0 ? (Ot += tr, Ot < 0 && (Ot = 0)) : Ot > tr && (Ot = tr), Ut < 0 ? (Ut += tr, Ut < 0 && (Ut = 0)) : Ut > tr && (Ut = tr), Ut < Ot && (Ut = Ot);
    const lr = this.subarray(Ot, Ut);
    return Object.setPrototypeOf(lr, le.prototype), lr;
  };
  function ar(zt, Ot, Ut) {
    if (zt % 1 !== 0 || zt < 0) throw new RangeError("offset is not uint");
    if (zt + Ot > Ut) throw new RangeError("Trying to access beyond buffer length");
  }
  le.prototype.readUintLE = le.prototype.readUIntLE = function(Ot, Ut, tr) {
    Ot = Ot >>> 0, Ut = Ut >>> 0, tr || ar(Ot, Ut, this.length);
    let lr = this[Ot], vr = 1, _r = 0;
    for (; ++_r < Ut && (vr *= 256); )
      lr += this[Ot + _r] * vr;
    return lr;
  }, le.prototype.readUintBE = le.prototype.readUIntBE = function(Ot, Ut, tr) {
    Ot = Ot >>> 0, Ut = Ut >>> 0, tr || ar(Ot, Ut, this.length);
    let lr = this[Ot + --Ut], vr = 1;
    for (; Ut > 0 && (vr *= 256); )
      lr += this[Ot + --Ut] * vr;
    return lr;
  }, le.prototype.readUint8 = le.prototype.readUInt8 = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 1, this.length), this[Ot];
  }, le.prototype.readUint16LE = le.prototype.readUInt16LE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 2, this.length), this[Ot] | this[Ot + 1] << 8;
  }, le.prototype.readUint16BE = le.prototype.readUInt16BE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 2, this.length), this[Ot] << 8 | this[Ot + 1];
  }, le.prototype.readUint32LE = le.prototype.readUInt32LE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 4, this.length), (this[Ot] | this[Ot + 1] << 8 | this[Ot + 2] << 16) + this[Ot + 3] * 16777216;
  }, le.prototype.readUint32BE = le.prototype.readUInt32BE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 4, this.length), this[Ot] * 16777216 + (this[Ot + 1] << 16 | this[Ot + 2] << 8 | this[Ot + 3]);
  }, le.prototype.readBigUInt64LE = Yr(function(Ot) {
    Ot = Ot >>> 0, Br(Ot, "offset");
    const Ut = this[Ot], tr = this[Ot + 7];
    (Ut === void 0 || tr === void 0) && Mr(Ot, this.length - 8);
    const lr = Ut + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 24, vr = this[++Ot] + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + tr * 2 ** 24;
    return BigInt(lr) + (BigInt(vr) << BigInt(32));
  }), le.prototype.readBigUInt64BE = Yr(function(Ot) {
    Ot = Ot >>> 0, Br(Ot, "offset");
    const Ut = this[Ot], tr = this[Ot + 7];
    (Ut === void 0 || tr === void 0) && Mr(Ot, this.length - 8);
    const lr = Ut * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + this[++Ot], vr = this[++Ot] * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + tr;
    return (BigInt(lr) << BigInt(32)) + BigInt(vr);
  }), le.prototype.readIntLE = function(Ot, Ut, tr) {
    Ot = Ot >>> 0, Ut = Ut >>> 0, tr || ar(Ot, Ut, this.length);
    let lr = this[Ot], vr = 1, _r = 0;
    for (; ++_r < Ut && (vr *= 256); )
      lr += this[Ot + _r] * vr;
    return vr *= 128, lr >= vr && (lr -= Math.pow(2, 8 * Ut)), lr;
  }, le.prototype.readIntBE = function(Ot, Ut, tr) {
    Ot = Ot >>> 0, Ut = Ut >>> 0, tr || ar(Ot, Ut, this.length);
    let lr = Ut, vr = 1, _r = this[Ot + --lr];
    for (; lr > 0 && (vr *= 256); )
      _r += this[Ot + --lr] * vr;
    return vr *= 128, _r >= vr && (_r -= Math.pow(2, 8 * Ut)), _r;
  }, le.prototype.readInt8 = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 1, this.length), this[Ot] & 128 ? (255 - this[Ot] + 1) * -1 : this[Ot];
  }, le.prototype.readInt16LE = function(Ot, Ut) {
    Ot = Ot >>> 0, Ut || ar(Ot, 2, this.length);
    const tr = this[Ot] | this[Ot + 1] << 8;
    return tr & 32768 ? tr | 4294901760 : tr;
  }, le.prototype.readInt16BE = function(Ot, Ut) {
    Ot = Ot >>> 0, Ut || ar(Ot, 2, this.length);
    const tr = this[Ot + 1] | this[Ot] << 8;
    return tr & 32768 ? tr | 4294901760 : tr;
  }, le.prototype.readInt32LE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 4, this.length), this[Ot] | this[Ot + 1] << 8 | this[Ot + 2] << 16 | this[Ot + 3] << 24;
  }, le.prototype.readInt32BE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 4, this.length), this[Ot] << 24 | this[Ot + 1] << 16 | this[Ot + 2] << 8 | this[Ot + 3];
  }, le.prototype.readBigInt64LE = Yr(function(Ot) {
    Ot = Ot >>> 0, Br(Ot, "offset");
    const Ut = this[Ot], tr = this[Ot + 7];
    (Ut === void 0 || tr === void 0) && Mr(Ot, this.length - 8);
    const lr = this[Ot + 4] + this[Ot + 5] * 2 ** 8 + this[Ot + 6] * 2 ** 16 + (tr << 24);
    return (BigInt(lr) << BigInt(32)) + BigInt(Ut + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 24);
  }), le.prototype.readBigInt64BE = Yr(function(Ot) {
    Ot = Ot >>> 0, Br(Ot, "offset");
    const Ut = this[Ot], tr = this[Ot + 7];
    (Ut === void 0 || tr === void 0) && Mr(Ot, this.length - 8);
    const lr = (Ut << 24) + // Overflow
    this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + this[++Ot];
    return (BigInt(lr) << BigInt(32)) + BigInt(this[++Ot] * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + tr);
  }), le.prototype.readFloatLE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 4, this.length), Y.read(this, Ot, !0, 23, 4);
  }, le.prototype.readFloatBE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 4, this.length), Y.read(this, Ot, !1, 23, 4);
  }, le.prototype.readDoubleLE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 8, this.length), Y.read(this, Ot, !0, 52, 8);
  }, le.prototype.readDoubleBE = function(Ot, Ut) {
    return Ot = Ot >>> 0, Ut || ar(Ot, 8, this.length), Y.read(this, Ot, !1, 52, 8);
  };
  function yr(zt, Ot, Ut, tr, lr, vr) {
    if (!le.isBuffer(zt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Ot > lr || Ot < vr) throw new RangeError('"value" argument is out of bounds');
    if (Ut + tr > zt.length) throw new RangeError("Index out of range");
  }
  le.prototype.writeUintLE = le.prototype.writeUIntLE = function(Ot, Ut, tr, lr) {
    if (Ot = +Ot, Ut = Ut >>> 0, tr = tr >>> 0, !lr) {
      const Rr = Math.pow(2, 8 * tr) - 1;
      yr(this, Ot, Ut, tr, Rr, 0);
    }
    let vr = 1, _r = 0;
    for (this[Ut] = Ot & 255; ++_r < tr && (vr *= 256); )
      this[Ut + _r] = Ot / vr & 255;
    return Ut + tr;
  }, le.prototype.writeUintBE = le.prototype.writeUIntBE = function(Ot, Ut, tr, lr) {
    if (Ot = +Ot, Ut = Ut >>> 0, tr = tr >>> 0, !lr) {
      const Rr = Math.pow(2, 8 * tr) - 1;
      yr(this, Ot, Ut, tr, Rr, 0);
    }
    let vr = tr - 1, _r = 1;
    for (this[Ut + vr] = Ot & 255; --vr >= 0 && (_r *= 256); )
      this[Ut + vr] = Ot / _r & 255;
    return Ut + tr;
  }, le.prototype.writeUint8 = le.prototype.writeUInt8 = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 1, 255, 0), this[Ut] = Ot & 255, Ut + 1;
  }, le.prototype.writeUint16LE = le.prototype.writeUInt16LE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 2, 65535, 0), this[Ut] = Ot & 255, this[Ut + 1] = Ot >>> 8, Ut + 2;
  }, le.prototype.writeUint16BE = le.prototype.writeUInt16BE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 2, 65535, 0), this[Ut] = Ot >>> 8, this[Ut + 1] = Ot & 255, Ut + 2;
  }, le.prototype.writeUint32LE = le.prototype.writeUInt32LE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 4, 4294967295, 0), this[Ut + 3] = Ot >>> 24, this[Ut + 2] = Ot >>> 16, this[Ut + 1] = Ot >>> 8, this[Ut] = Ot & 255, Ut + 4;
  }, le.prototype.writeUint32BE = le.prototype.writeUInt32BE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 4, 4294967295, 0), this[Ut] = Ot >>> 24, this[Ut + 1] = Ot >>> 16, this[Ut + 2] = Ot >>> 8, this[Ut + 3] = Ot & 255, Ut + 4;
  };
  function rr(zt, Ot, Ut, tr, lr) {
    Ar(Ot, tr, lr, zt, Ut, 7);
    let vr = Number(Ot & BigInt(4294967295));
    zt[Ut++] = vr, vr = vr >> 8, zt[Ut++] = vr, vr = vr >> 8, zt[Ut++] = vr, vr = vr >> 8, zt[Ut++] = vr;
    let _r = Number(Ot >> BigInt(32) & BigInt(4294967295));
    return zt[Ut++] = _r, _r = _r >> 8, zt[Ut++] = _r, _r = _r >> 8, zt[Ut++] = _r, _r = _r >> 8, zt[Ut++] = _r, Ut;
  }
  function Kt(zt, Ot, Ut, tr, lr) {
    Ar(Ot, tr, lr, zt, Ut, 7);
    let vr = Number(Ot & BigInt(4294967295));
    zt[Ut + 7] = vr, vr = vr >> 8, zt[Ut + 6] = vr, vr = vr >> 8, zt[Ut + 5] = vr, vr = vr >> 8, zt[Ut + 4] = vr;
    let _r = Number(Ot >> BigInt(32) & BigInt(4294967295));
    return zt[Ut + 3] = _r, _r = _r >> 8, zt[Ut + 2] = _r, _r = _r >> 8, zt[Ut + 1] = _r, _r = _r >> 8, zt[Ut] = _r, Ut + 8;
  }
  le.prototype.writeBigUInt64LE = Yr(function(Ot, Ut = 0) {
    return rr(this, Ot, Ut, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeBigUInt64BE = Yr(function(Ot, Ut = 0) {
    return Kt(this, Ot, Ut, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeIntLE = function(Ot, Ut, tr, lr) {
    if (Ot = +Ot, Ut = Ut >>> 0, !lr) {
      const Wr = Math.pow(2, 8 * tr - 1);
      yr(this, Ot, Ut, tr, Wr - 1, -Wr);
    }
    let vr = 0, _r = 1, Rr = 0;
    for (this[Ut] = Ot & 255; ++vr < tr && (_r *= 256); )
      Ot < 0 && Rr === 0 && this[Ut + vr - 1] !== 0 && (Rr = 1), this[Ut + vr] = (Ot / _r >> 0) - Rr & 255;
    return Ut + tr;
  }, le.prototype.writeIntBE = function(Ot, Ut, tr, lr) {
    if (Ot = +Ot, Ut = Ut >>> 0, !lr) {
      const Wr = Math.pow(2, 8 * tr - 1);
      yr(this, Ot, Ut, tr, Wr - 1, -Wr);
    }
    let vr = tr - 1, _r = 1, Rr = 0;
    for (this[Ut + vr] = Ot & 255; --vr >= 0 && (_r *= 256); )
      Ot < 0 && Rr === 0 && this[Ut + vr + 1] !== 0 && (Rr = 1), this[Ut + vr] = (Ot / _r >> 0) - Rr & 255;
    return Ut + tr;
  }, le.prototype.writeInt8 = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 1, 127, -128), Ot < 0 && (Ot = 255 + Ot + 1), this[Ut] = Ot & 255, Ut + 1;
  }, le.prototype.writeInt16LE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 2, 32767, -32768), this[Ut] = Ot & 255, this[Ut + 1] = Ot >>> 8, Ut + 2;
  }, le.prototype.writeInt16BE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 2, 32767, -32768), this[Ut] = Ot >>> 8, this[Ut + 1] = Ot & 255, Ut + 2;
  }, le.prototype.writeInt32LE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 4, 2147483647, -2147483648), this[Ut] = Ot & 255, this[Ut + 1] = Ot >>> 8, this[Ut + 2] = Ot >>> 16, this[Ut + 3] = Ot >>> 24, Ut + 4;
  }, le.prototype.writeInt32BE = function(Ot, Ut, tr) {
    return Ot = +Ot, Ut = Ut >>> 0, tr || yr(this, Ot, Ut, 4, 2147483647, -2147483648), Ot < 0 && (Ot = 4294967295 + Ot + 1), this[Ut] = Ot >>> 24, this[Ut + 1] = Ot >>> 16, this[Ut + 2] = Ot >>> 8, this[Ut + 3] = Ot & 255, Ut + 4;
  }, le.prototype.writeBigInt64LE = Yr(function(Ot, Ut = 0) {
    return rr(this, Ot, Ut, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), le.prototype.writeBigInt64BE = Yr(function(Ot, Ut = 0) {
    return Kt(this, Ot, Ut, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Gt(zt, Ot, Ut, tr, lr, vr) {
    if (Ut + tr > zt.length) throw new RangeError("Index out of range");
    if (Ut < 0) throw new RangeError("Index out of range");
  }
  function ur(zt, Ot, Ut, tr, lr) {
    return Ot = +Ot, Ut = Ut >>> 0, lr || Gt(zt, Ot, Ut, 4), Y.write(zt, Ot, Ut, tr, 23, 4), Ut + 4;
  }
  le.prototype.writeFloatLE = function(Ot, Ut, tr) {
    return ur(this, Ot, Ut, !0, tr);
  }, le.prototype.writeFloatBE = function(Ot, Ut, tr) {
    return ur(this, Ot, Ut, !1, tr);
  };
  function gr(zt, Ot, Ut, tr, lr) {
    return Ot = +Ot, Ut = Ut >>> 0, lr || Gt(zt, Ot, Ut, 8), Y.write(zt, Ot, Ut, tr, 52, 8), Ut + 8;
  }
  le.prototype.writeDoubleLE = function(Ot, Ut, tr) {
    return gr(this, Ot, Ut, !0, tr);
  }, le.prototype.writeDoubleBE = function(Ot, Ut, tr) {
    return gr(this, Ot, Ut, !1, tr);
  }, le.prototype.copy = function(Ot, Ut, tr, lr) {
    if (!le.isBuffer(Ot)) throw new TypeError("argument should be a Buffer");
    if (tr || (tr = 0), !lr && lr !== 0 && (lr = this.length), Ut >= Ot.length && (Ut = Ot.length), Ut || (Ut = 0), lr > 0 && lr < tr && (lr = tr), lr === tr || Ot.length === 0 || this.length === 0) return 0;
    if (Ut < 0)
      throw new RangeError("targetStart out of bounds");
    if (tr < 0 || tr >= this.length) throw new RangeError("Index out of range");
    if (lr < 0) throw new RangeError("sourceEnd out of bounds");
    lr > this.length && (lr = this.length), Ot.length - Ut < lr - tr && (lr = Ot.length - Ut + tr);
    const vr = lr - tr;
    return this === Ot && typeof oe.prototype.copyWithin == "function" ? this.copyWithin(Ut, tr, lr) : oe.prototype.set.call(
      Ot,
      this.subarray(tr, lr),
      Ut
    ), vr;
  }, le.prototype.fill = function(Ot, Ut, tr, lr) {
    if (typeof Ot == "string") {
      if (typeof Ut == "string" ? (lr = Ut, Ut = 0, tr = this.length) : typeof tr == "string" && (lr = tr, tr = this.length), lr !== void 0 && typeof lr != "string")
        throw new TypeError("encoding must be a string");
      if (typeof lr == "string" && !le.isEncoding(lr))
        throw new TypeError("Unknown encoding: " + lr);
      if (Ot.length === 1) {
        const _r = Ot.charCodeAt(0);
        (lr === "utf8" && _r < 128 || lr === "latin1") && (Ot = _r);
      }
    } else typeof Ot == "number" ? Ot = Ot & 255 : typeof Ot == "boolean" && (Ot = Number(Ot));
    if (Ut < 0 || this.length < Ut || this.length < tr)
      throw new RangeError("Out of range index");
    if (tr <= Ut)
      return this;
    Ut = Ut >>> 0, tr = tr === void 0 ? this.length : tr >>> 0, Ot || (Ot = 0);
    let vr;
    if (typeof Ot == "number")
      for (vr = Ut; vr < tr; ++vr)
        this[vr] = Ot;
    else {
      const _r = le.isBuffer(Ot) ? Ot : le.from(Ot, lr), Rr = _r.length;
      if (Rr === 0)
        throw new TypeError('The value "' + Ot + '" is invalid for argument "value"');
      for (vr = 0; vr < tr - Ut; ++vr)
        this[vr + Ut] = _r[vr % Rr];
    }
    return this;
  };
  const Qt = {};
  function Jt(zt, Ot, Ut) {
    Qt[zt] = class extends Ut {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Ot.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${zt}]`, this.stack, delete this.name;
      }
      get code() {
        return zt;
      }
      set code(lr) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: lr,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${zt}]: ${this.message}`;
      }
    };
  }
  Jt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(zt) {
      return zt ? `${zt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Jt(
    "ERR_INVALID_ARG_TYPE",
    function(zt, Ot) {
      return `The "${zt}" argument must be of type number. Received type ${typeof Ot}`;
    },
    TypeError
  ), Jt(
    "ERR_OUT_OF_RANGE",
    function(zt, Ot, Ut) {
      let tr = `The value of "${zt}" is out of range.`, lr = Ut;
      return Number.isInteger(Ut) && Math.abs(Ut) > 2 ** 32 ? lr = br(String(Ut)) : typeof Ut == "bigint" && (lr = String(Ut), (Ut > BigInt(2) ** BigInt(32) || Ut < -(BigInt(2) ** BigInt(32))) && (lr = br(lr)), lr += "n"), tr += ` It must be ${Ot}. Received ${lr}`, tr;
    },
    RangeError
  );
  function br(zt) {
    let Ot = "", Ut = zt.length;
    const tr = zt[0] === "-" ? 1 : 0;
    for (; Ut >= tr + 4; Ut -= 3)
      Ot = `_${zt.slice(Ut - 3, Ut)}${Ot}`;
    return `${zt.slice(0, Ut)}${Ot}`;
  }
  function Sr(zt, Ot, Ut) {
    Br(Ot, "offset"), (zt[Ot] === void 0 || zt[Ot + Ut] === void 0) && Mr(Ot, zt.length - (Ut + 1));
  }
  function Ar(zt, Ot, Ut, tr, lr, vr) {
    if (zt > Ut || zt < Ot) {
      const _r = typeof Ot == "bigint" ? "n" : "";
      let Rr;
      throw Ot === 0 || Ot === BigInt(0) ? Rr = `>= 0${_r} and < 2${_r} ** ${(vr + 1) * 8}${_r}` : Rr = `>= -(2${_r} ** ${(vr + 1) * 8 - 1}${_r}) and < 2 ** ${(vr + 1) * 8 - 1}${_r}`, new Qt.ERR_OUT_OF_RANGE("value", Rr, zt);
    }
    Sr(tr, lr, vr);
  }
  function Br(zt, Ot) {
    if (typeof zt != "number")
      throw new Qt.ERR_INVALID_ARG_TYPE(Ot, "number", zt);
  }
  function Mr(zt, Ot, Ut) {
    throw Math.floor(zt) !== zt ? (Br(zt, Ut), new Qt.ERR_OUT_OF_RANGE("offset", "an integer", zt)) : Ot < 0 ? new Qt.ERR_BUFFER_OUT_OF_BOUNDS() : new Qt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Ot}`,
      zt
    );
  }
  const Cr = /[^+/0-9A-Za-z-_]/g;
  function $r(zt) {
    if (zt = zt.split("=")[0], zt = zt.trim().replace(Cr, ""), zt.length < 2) return "";
    for (; zt.length % 4 !== 0; )
      zt = zt + "=";
    return zt;
  }
  function Qr(zt, Ot) {
    Ot = Ot || 1 / 0;
    let Ut;
    const tr = zt.length;
    let lr = null;
    const vr = [];
    for (let _r = 0; _r < tr; ++_r) {
      if (Ut = zt.charCodeAt(_r), Ut > 55295 && Ut < 57344) {
        if (!lr) {
          if (Ut > 56319) {
            (Ot -= 3) > -1 && vr.push(239, 191, 189);
            continue;
          } else if (_r + 1 === tr) {
            (Ot -= 3) > -1 && vr.push(239, 191, 189);
            continue;
          }
          lr = Ut;
          continue;
        }
        if (Ut < 56320) {
          (Ot -= 3) > -1 && vr.push(239, 191, 189), lr = Ut;
          continue;
        }
        Ut = (lr - 55296 << 10 | Ut - 56320) + 65536;
      } else lr && (Ot -= 3) > -1 && vr.push(239, 191, 189);
      if (lr = null, Ut < 128) {
        if ((Ot -= 1) < 0) break;
        vr.push(Ut);
      } else if (Ut < 2048) {
        if ((Ot -= 2) < 0) break;
        vr.push(
          Ut >> 6 | 192,
          Ut & 63 | 128
        );
      } else if (Ut < 65536) {
        if ((Ot -= 3) < 0) break;
        vr.push(
          Ut >> 12 | 224,
          Ut >> 6 & 63 | 128,
          Ut & 63 | 128
        );
      } else if (Ut < 1114112) {
        if ((Ot -= 4) < 0) break;
        vr.push(
          Ut >> 18 | 240,
          Ut >> 12 & 63 | 128,
          Ut >> 6 & 63 | 128,
          Ut & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return vr;
  }
  function jr(zt) {
    const Ot = [];
    for (let Ut = 0; Ut < zt.length; ++Ut)
      Ot.push(zt.charCodeAt(Ut) & 255);
    return Ot;
  }
  function qr(zt, Ot) {
    let Ut, tr, lr;
    const vr = [];
    for (let _r = 0; _r < zt.length && !((Ot -= 2) < 0); ++_r)
      Ut = zt.charCodeAt(_r), tr = Ut >> 8, lr = Ut % 256, vr.push(lr), vr.push(tr);
    return vr;
  }
  function Gr(zt) {
    return z.toByteArray($r(zt));
  }
  function Or(zt, Ot, Ut, tr) {
    let lr;
    for (lr = 0; lr < tr && !(lr + Ut >= Ot.length || lr >= zt.length); ++lr)
      Ot[lr + Ut] = zt[lr];
    return lr;
  }
  function Vr(zt, Ot) {
    return zt instanceof Ot || zt != null && zt.constructor != null && zt.constructor.name != null && zt.constructor.name === Ot.name;
  }
  function Zr(zt) {
    return zt !== zt;
  }
  const Lr = function() {
    const zt = "0123456789abcdef", Ot = new Array(256);
    for (let Ut = 0; Ut < 16; ++Ut) {
      const tr = Ut * 16;
      for (let lr = 0; lr < 16; ++lr)
        Ot[tr + lr] = zt[Ut] + zt[lr];
    }
    return Ot;
  }();
  function Yr(zt) {
    return typeof BigInt > "u" ? en : zt;
  }
  function en() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$E = buffer$1.Buffer;
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, z) {
  var Y;
  return (Y = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : Y.get(z);
}
function _stringify(B) {
  var Y, ne;
  const z = typeof B;
  return z === "string" ? `"${B}"` : z === "number" || z === "bigint" || z === "boolean" ? `${B}` : z === "object" || z === "function" ? (B && ((ne = (Y = Object.getPrototypeOf(B)) == null ? void 0 : Y.constructor) == null ? void 0 : ne.name)) ?? "null" : z;
}
function _addIssue(B, z, Y, ne, ie) {
  const oe = ie && "input" in ie ? ie.input : Y.value, se = (ie == null ? void 0 : ie.expected) ?? B.expects ?? null, ae = (ie == null ? void 0 : ie.received) ?? _stringify(oe), ge = {
    kind: B.kind,
    type: B.type,
    input: oe,
    expected: se,
    received: ae,
    message: `Invalid ${z}: ${se ? `Expected ${se} but r` : "R"}eceived ${ae}`,
    requirement: B.requirement,
    path: ie == null ? void 0 : ie.path,
    issues: ie == null ? void 0 : ie.issues,
    lang: ne.lang,
    abortEarly: ne.abortEarly,
    abortPipeEarly: ne.abortPipeEarly
  }, Ce = B.kind === "schema", le = (ie == null ? void 0 : ie.message) ?? B.message ?? getSpecificMessage(B.reference, ge.lang) ?? (Ce ? getSchemaMessage(ge.lang) : null) ?? ne.message ?? getGlobalMessage(ge.lang);
  le && (ge.message = typeof le == "function" ? (
    // @ts-expect-error
    le(ge)
  ) : le), Ce && (Y.typed = !1), Y.issues ? Y.issues.push(ge) : Y.issues = [ge];
}
function _isValidObjectKey(B, z) {
  return Object.hasOwn(B, z) && z !== "__proto__" && z !== "prototype" && z !== "constructor";
}
function _joinExpects(B, z) {
  const Y = [...new Set(B)];
  return Y.length > 1 ? `(${Y.join(` ${z} `)})` : Y[0] ?? "never";
}
function check$e(B, z) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && !this.requirement(Y.value) && _addIssue(this, "input", Y, ne), Y;
    }
  };
}
function maxLength(B, z) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length > this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function minLength(B, z) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length < this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function getDefault(B, z, Y) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(z, Y)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function array(B, z) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: z,
    _run(Y, ne) {
      var oe;
      const ie = Y.value;
      if (Array.isArray(ie)) {
        Y.typed = !0, Y.value = [];
        for (let se = 0; se < ie.length; se++) {
          const ae = ie[se], ge = this.item._run({ typed: !1, value: ae }, ne);
          if (ge.issues) {
            const Ce = {
              type: "array",
              origin: "value",
              input: ie,
              key: se,
              value: ae
            };
            for (const le of ge.issues)
              le.path ? le.path.unshift(Ce) : le.path = [Ce], (oe = Y.issues) == null || oe.push(le);
            if (Y.issues || (Y.issues = ge.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ge.typed || (Y.typed = !1), Y.value.push(ge.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "boolean" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function enum_(B, z) {
  const Y = Object.entries(B).filter(([ne]) => isNaN(+ne)).map(([, ne]) => ne);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(Y.map(_stringify), "|"),
    async: !1,
    enum: B,
    options: Y,
    message: z,
    _run(ne, ie) {
      return this.options.includes(ne.value) ? ne.typed = !0 : _addIssue(this, "type", ne, ie), ne;
    }
  };
}
function literal(B, z) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: z,
    _run(Y, ne) {
      return Y.value === this.literal ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function looseObject(B, z) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var oe;
      const ie = Y.value;
      if (ie && typeof ie == "object") {
        Y.typed = !0, Y.value = {};
        for (const se in this.entries) {
          const ae = ie[se], ge = this.entries[se]._run(
            { typed: !1, value: ae },
            ne
          );
          if (ge.issues) {
            const Ce = {
              type: "object",
              origin: "value",
              input: ie,
              key: se,
              value: ae
            };
            for (const le of ge.issues)
              le.path ? le.path.unshift(Ce) : le.path = [Ce], (oe = Y.issues) == null || oe.push(le);
            if (Y.issues || (Y.issues = ge.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ge.typed || (Y.typed = !1), (ge.value !== void 0 || se in ie) && (Y.value[se] = ge.value);
        }
        if (!Y.issues || !ne.abortEarly)
          for (const se in ie)
            _isValidObjectKey(ie, se) && !(se in this.entries) && (Y.value[se] = ie[se]);
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function nonOptional(B, z) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: z,
    _run(Y, ne) {
      return Y.value === void 0 ? (_addIssue(this, "type", Y, ne), Y) : this.wrapped._run(Y, ne);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(z, Y) {
      return z.value === null ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function nullish(B, ...z) {
  const Y = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${B.expects} | null | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, ie) {
      return (ne.value === null || ne.value === void 0) && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        ie
      )), ne.value === null || ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, ie);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "number" && !isNaN(z.value) ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function object(B, z) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var oe;
      const ie = Y.value;
      if (ie && typeof ie == "object") {
        Y.typed = !0, Y.value = {};
        for (const se in this.entries) {
          const ae = ie[se], ge = this.entries[se]._run(
            { typed: !1, value: ae },
            ne
          );
          if (ge.issues) {
            const Ce = {
              type: "object",
              origin: "value",
              input: ie,
              key: se,
              value: ae
            };
            for (const le of ge.issues)
              le.path ? le.path.unshift(Ce) : le.path = [Ce], (oe = Y.issues) == null || oe.push(le);
            if (Y.issues || (Y.issues = ge.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ge.typed || (Y.typed = !1), (ge.value !== void 0 || se in ie) && (Y.value[se] = ge.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function optional(B, ...z) {
  const Y = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${B.expects} | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, ie) {
      return ne.value === void 0 && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        ie
      )), ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, ie);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function picklist(B, z) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(B.map(_stringify), "|"),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      return this.options.includes(Y.value) ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function record(B, z, Y) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: B,
    value: z,
    message: Y,
    _run(ne, ie) {
      var se, ae;
      const oe = ne.value;
      if (oe && typeof oe == "object") {
        ne.typed = !0, ne.value = {};
        for (const ge in oe)
          if (_isValidObjectKey(oe, ge)) {
            const Ce = oe[ge], le = this.key._run(
              { typed: !1, value: ge },
              ie
            );
            if (le.issues) {
              const Je = {
                type: "object",
                origin: "key",
                input: oe,
                key: ge,
                value: Ce
              };
              for (const Ve of le.issues)
                Ve.path = [Je], (se = ne.issues) == null || se.push(Ve);
              if (ne.issues || (ne.issues = le.issues), ie.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            const Ee = this.value._run(
              { typed: !1, value: Ce },
              ie
            );
            if (Ee.issues) {
              const Je = {
                type: "object",
                origin: "value",
                input: oe,
                key: ge,
                value: Ce
              };
              for (const Ve of Ee.issues)
                Ve.path ? Ve.path.unshift(Je) : Ve.path = [Je], (ae = ne.issues) == null || ae.push(Ve);
              if (ne.issues || (ne.issues = Ee.issues), ie.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            (!le.typed || !Ee.typed) && (ne.typed = !1), le.typed && (ne.value[le.value] = Ee.value);
          }
      } else
        _addIssue(this, "type", ne, ie);
      return ne;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "string" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function _subIssues(B) {
  let z;
  if (B)
    for (const Y of B)
      z ? z.push(...Y.issues) : z = Y.issues;
  return z;
}
function union(B, z) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      B.map((Y) => Y.expects),
      "|"
    ),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      let ie, oe, se;
      for (const ae of this.options) {
        const ge = ae._run(
          { typed: !1, value: Y.value },
          ne
        );
        if (ge.typed)
          if (ge.issues)
            oe ? oe.push(ge) : oe = [ge];
          else {
            ie = ge;
            break;
          }
        else
          se ? se.push(ge) : se = [ge];
      }
      if (ie)
        return ie;
      if (oe) {
        if (oe.length === 1)
          return oe[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(oe)
        }), Y.typed = !0;
      } else {
        if ((se == null ? void 0 : se.length) === 1)
          return se[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(se)
        });
      }
      return Y;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
function variant(B, z, Y) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: B,
    options: z,
    message: Y,
    _run(ne, ie) {
      const oe = ne.value;
      if (oe && typeof oe == "object") {
        let se, ae = 0, ge = this.key, Ce = [];
        const le = (Ee, Je) => {
          for (const Ve of Ee.options) {
            if (Ve.type === "variant")
              le(Ve, new Set(Je).add(Ve.key));
            else {
              let $t = !0, Nt = 0;
              for (const Dt of Je) {
                if (Ve.entries[Dt]._run(
                  // @ts-expect-error
                  { typed: !1, value: oe[Dt] },
                  ie
                ).issues) {
                  $t = !1, ge !== Dt && (ae < Nt || ae === Nt && Dt in oe && !(ge in oe)) && (ae = Nt, ge = Dt, Ce = []), ge === Dt && Ce.push(
                    Ve.entries[Dt].expects
                  );
                  break;
                }
                Nt++;
              }
              if ($t) {
                const Dt = Ve._run(
                  { typed: !1, value: oe },
                  ie
                );
                (!se || !se.typed && Dt.typed) && (se = Dt);
              }
            }
            if (se && !se.issues)
              break;
          }
        };
        if (le(this, /* @__PURE__ */ new Set([this.key])), se)
          return se;
        _addIssue(this, "type", ne, ie, {
          // @ts-expect-error
          input: oe[ge],
          expected: _joinExpects(Ce, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: oe,
              key: ge,
              // @ts-expect-error
              value: oe[ge]
            }
          ]
        });
      } else
        _addIssue(this, "type", ne, ie);
      return ne;
    }
  };
}
function omit(B, z) {
  const Y = {
    ...B.entries
  };
  for (const ne of z)
    delete Y[ne];
  return { ...B, entries: Y };
}
function pipe(...B) {
  return {
    ...B[0],
    pipe: B,
    _run(z, Y) {
      for (const ne of B)
        if (ne.kind !== "metadata") {
          if (z.issues && (ne.kind === "schema" || ne.kind === "transformation")) {
            z.typed = !1;
            break;
          }
          (!z.issues || !Y.abortEarly && !Y.abortPipeEarly) && (z = ne._run(z, Y));
        }
      return z;
    }
  };
}
function unwrap(B) {
  return B.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength(B) {
  var z = getLens(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray(B) {
  var z, Y = getLens(B), ne = Y[0], ie = Y[1], oe = new Arr(_byteLength(B, ne, ie)), se = 0, ae = ie > 0 ? ne - 4 : ne, ge;
  for (ge = 0; ge < ae; ge += 4)
    z = revLookup[B.charCodeAt(ge)] << 18 | revLookup[B.charCodeAt(ge + 1)] << 12 | revLookup[B.charCodeAt(ge + 2)] << 6 | revLookup[B.charCodeAt(ge + 3)], oe[se++] = z >> 16 & 255, oe[se++] = z >> 8 & 255, oe[se++] = z & 255;
  return ie === 2 && (z = revLookup[B.charCodeAt(ge)] << 2 | revLookup[B.charCodeAt(ge + 1)] >> 4, oe[se++] = z & 255), ie === 1 && (z = revLookup[B.charCodeAt(ge)] << 10 | revLookup[B.charCodeAt(ge + 1)] << 4 | revLookup[B.charCodeAt(ge + 2)] >> 2, oe[se++] = z >> 8 & 255, oe[se++] = z & 255), oe;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, z, Y) {
  for (var ne, ie = [], oe = z; oe < Y; oe += 3)
    ne = (B[oe] << 16 & 16711680) + (B[oe + 1] << 8 & 65280) + (B[oe + 2] & 255), ie.push(tripletToBase64(ne));
  return ie.join("");
}
function fromByteArray(B) {
  for (var z, Y = B.length, ne = Y % 3, ie = [], oe = 16383, se = 0, ae = Y - ne; se < ae; se += oe)
    ie.push(encodeChunk(B, se, se + oe > ae ? ae : se + oe));
  return ne === 1 ? (z = B[Y - 1], ie.push(
    lookup[z >> 2] + lookup[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], ie.push(
    lookup[z >> 10] + lookup[z >> 4 & 63] + lookup[z << 2 & 63] + "="
  )), ie.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode$j;
function decode$j(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error("positive integer expected, got " + B);
}
function isBytes(B) {
  return B instanceof Uint8Array || ArrayBuffer.isView(B) && B.constructor.name === "Uint8Array";
}
function abytes(B, ...z) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (z.length > 0 && !z.includes(B.length))
    throw new Error("Uint8Array expected of length " + z + ", got length=" + B.length);
}
function ahash(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(B.outputLen), anumber(B.blockLen);
}
function aexists(B, z = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (z && B.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(B, z) {
  abytes(B);
  const Y = z.outputLen;
  if (B.length < Y)
    throw new Error("digestInto() expects output buffer of length at least " + Y);
}
var utils$p = {}, crypto$4 = {};
Object.defineProperty(crypto$4, "__esModule", { value: !0 });
crypto$4.crypto = void 0;
crypto$4.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.isLE = void 0, B.isBytes = ne, B.u8 = ie, B.u32 = oe, B.createView = se, B.rotr = ae, B.rotl = ge, B.byteSwap = Ce, B.byteSwap32 = le, B.bytesToHex = Je, B.hexToBytes = Nt, B.asyncLoop = Wt, B.utf8ToBytes = Pt, B.toBytes = Lt, B.concatBytes = qt, B.checkOpts = Yt, B.wrapConstructor = or, B.wrapConstructorWithOpts = jt, B.wrapXOFConstructorWithOpts = Ct, B.randomBytes = Vt;
  const z = crypto$4, Y = _assert;
  function ne(kt) {
    return kt instanceof Uint8Array || ArrayBuffer.isView(kt) && kt.constructor.name === "Uint8Array";
  }
  function ie(kt) {
    return new Uint8Array(kt.buffer, kt.byteOffset, kt.byteLength);
  }
  function oe(kt) {
    return new Uint32Array(kt.buffer, kt.byteOffset, Math.floor(kt.byteLength / 4));
  }
  function se(kt) {
    return new DataView(kt.buffer, kt.byteOffset, kt.byteLength);
  }
  function ae(kt, Pe) {
    return kt << 32 - Pe | kt >>> Pe;
  }
  function ge(kt, Pe) {
    return kt << Pe | kt >>> 32 - Pe >>> 0;
  }
  B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function Ce(kt) {
    return kt << 24 & 4278190080 | kt << 8 & 16711680 | kt >>> 8 & 65280 | kt >>> 24 & 255;
  }
  B.byteSwapIfBE = B.isLE ? (kt) => kt : (kt) => Ce(kt);
  function le(kt) {
    for (let Pe = 0; Pe < kt.length; Pe++)
      kt[Pe] = Ce(kt[Pe]);
  }
  const Ee = /* @__PURE__ */ Array.from({ length: 256 }, (kt, Pe) => Pe.toString(16).padStart(2, "0"));
  function Je(kt) {
    (0, Y.abytes)(kt);
    let Pe = "";
    for (let Xe = 0; Xe < kt.length; Xe++)
      Pe += Ee[kt[Xe]];
    return Pe;
  }
  const Ve = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function $t(kt) {
    if (kt >= Ve._0 && kt <= Ve._9)
      return kt - Ve._0;
    if (kt >= Ve.A && kt <= Ve.F)
      return kt - (Ve.A - 10);
    if (kt >= Ve.a && kt <= Ve.f)
      return kt - (Ve.a - 10);
  }
  function Nt(kt) {
    if (typeof kt != "string")
      throw new Error("hex string expected, got " + typeof kt);
    const Pe = kt.length, Xe = Pe / 2;
    if (Pe % 2)
      throw new Error("hex string expected, got unpadded hex of length " + Pe);
    const ve = new Uint8Array(Xe);
    for (let Ke = 0, ht = 0; Ke < Xe; Ke++, ht += 2) {
      const wt = $t(kt.charCodeAt(ht)), vt = $t(kt.charCodeAt(ht + 1));
      if (wt === void 0 || vt === void 0) {
        const xt = kt[ht] + kt[ht + 1];
        throw new Error('hex string expected, got non-hex character "' + xt + '" at index ' + ht);
      }
      ve[Ke] = wt * 16 + vt;
    }
    return ve;
  }
  const Dt = async () => {
  };
  B.nextTick = Dt;
  async function Wt(kt, Pe, Xe) {
    let ve = Date.now();
    for (let Ke = 0; Ke < kt; Ke++) {
      Xe(Ke);
      const ht = Date.now() - ve;
      ht >= 0 && ht < Pe || (await (0, B.nextTick)(), ve += ht);
    }
  }
  function Pt(kt) {
    if (typeof kt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof kt);
    return new Uint8Array(new TextEncoder().encode(kt));
  }
  function Lt(kt) {
    return typeof kt == "string" && (kt = Pt(kt)), (0, Y.abytes)(kt), kt;
  }
  function qt(...kt) {
    let Pe = 0;
    for (let ve = 0; ve < kt.length; ve++) {
      const Ke = kt[ve];
      (0, Y.abytes)(Ke), Pe += Ke.length;
    }
    const Xe = new Uint8Array(Pe);
    for (let ve = 0, Ke = 0; ve < kt.length; ve++) {
      const ht = kt[ve];
      Xe.set(ht, Ke), Ke += ht.length;
    }
    return Xe;
  }
  class Zt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = Zt;
  function Yt(kt, Pe) {
    if (Pe !== void 0 && {}.toString.call(Pe) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(kt, Pe);
  }
  function or(kt) {
    const Pe = (ve) => kt().update(Lt(ve)).digest(), Xe = kt();
    return Pe.outputLen = Xe.outputLen, Pe.blockLen = Xe.blockLen, Pe.create = () => kt(), Pe;
  }
  function jt(kt) {
    const Pe = (ve, Ke) => kt(Ke).update(Lt(ve)).digest(), Xe = kt({});
    return Pe.outputLen = Xe.outputLen, Pe.blockLen = Xe.blockLen, Pe.create = (ve) => kt(ve), Pe;
  }
  function Ct(kt) {
    const Pe = (ve, Ke) => kt(Ke).update(Lt(ve)).digest(), Xe = kt({});
    return Pe.outputLen = Xe.outputLen, Pe.blockLen = Xe.blockLen, Pe.create = (ve) => kt(ve), Pe;
  }
  function Vt(kt = 32) {
    if (z.crypto && typeof z.crypto.getRandomValues == "function")
      return z.crypto.getRandomValues(new Uint8Array(kt));
    if (z.crypto && typeof z.crypto.randomBytes == "function")
      return z.crypto.randomBytes(kt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$p);
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const z = _assert, Y = utils$p;
  class ne extends Y.Hash {
    constructor(se, ae) {
      super(), this.finished = !1, this.destroyed = !1, (0, z.ahash)(se);
      const ge = (0, Y.toBytes)(ae);
      if (this.iHash = se.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const Ce = this.blockLen, le = new Uint8Array(Ce);
      le.set(ge.length > Ce ? se.create().update(ge).digest() : ge);
      for (let Ee = 0; Ee < le.length; Ee++)
        le[Ee] ^= 54;
      this.iHash.update(le), this.oHash = se.create();
      for (let Ee = 0; Ee < le.length; Ee++)
        le[Ee] ^= 106;
      this.oHash.update(le), le.fill(0);
    }
    update(se) {
      return (0, z.aexists)(this), this.iHash.update(se), this;
    }
    digestInto(se) {
      (0, z.aexists)(this), (0, z.abytes)(se, this.outputLen), this.finished = !0, this.iHash.digestInto(se), this.oHash.update(se), this.oHash.digestInto(se), this.destroy();
    }
    digest() {
      const se = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(se), se;
    }
    _cloneInto(se) {
      se || (se = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ae, iHash: ge, finished: Ce, destroyed: le, blockLen: Ee, outputLen: Je } = this;
      return se = se, se.finished = Ce, se.destroyed = le, se.blockLen = Ee, se.outputLen = Je, se.oHash = ae._cloneInto(se.oHash), se.iHash = ge._cloneInto(se.iHash), se;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = ne;
  const ie = (oe, se, ae) => new ne(oe, se).update(ae).digest();
  B.hmac = ie, B.hmac.create = (oe, se) => new ne(oe, se);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$p;
function setBigUint64(B, z, Y, ne) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(z, Y, ne);
  const ie = BigInt(32), oe = BigInt(4294967295), se = Number(Y >> ie & oe), ae = Number(Y & oe), ge = ne ? 4 : 0, Ce = ne ? 0 : 4;
  B.setUint32(z + ge, se, ne), B.setUint32(z + Ce, ae, ne);
}
function Chi(B, z, Y) {
  return B & z ^ ~B & Y;
}
function Maj(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(z, Y, ne, ie) {
    super(), this.blockLen = z, this.outputLen = Y, this.padOffset = ne, this.isLE = ie, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(z), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(z) {
    (0, _assert_js_1.aexists)(this);
    const { view: Y, buffer: ne, blockLen: ie } = this;
    z = (0, utils_js_1$3.toBytes)(z);
    const oe = z.length;
    for (let se = 0; se < oe; ) {
      const ae = Math.min(ie - this.pos, oe - se);
      if (ae === ie) {
        const ge = (0, utils_js_1$3.createView)(z);
        for (; ie <= oe - se; se += ie)
          this.process(ge, se);
        continue;
      }
      ne.set(z.subarray(se, se + ae), this.pos), this.pos += ae, se += ae, this.pos === ie && (this.process(Y, 0), this.pos = 0);
    }
    return this.length += z.length, this.roundClean(), this;
  }
  digestInto(z) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(z, this), this.finished = !0;
    const { buffer: Y, view: ne, blockLen: ie, isLE: oe } = this;
    let { pos: se } = this;
    Y[se++] = 128, this.buffer.subarray(se).fill(0), this.padOffset > ie - se && (this.process(ne, 0), se = 0);
    for (let Ee = se; Ee < ie; Ee++)
      Y[Ee] = 0;
    setBigUint64(ne, ie - 8, BigInt(this.length * 8), oe), this.process(ne, 0);
    const ae = (0, utils_js_1$3.createView)(z), ge = this.outputLen;
    if (ge % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const Ce = ge / 4, le = this.get();
    if (Ce > le.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ee = 0; Ee < Ce; Ee++)
      ae.setUint32(4 * Ee, le[Ee], oe);
  }
  digest() {
    const { buffer: z, outputLen: Y } = this;
    this.digestInto(z);
    const ne = z.slice(0, Y);
    return this.destroy(), ne;
  }
  _cloneInto(z) {
    z || (z = new this.constructor()), z.set(...this.get());
    const { blockLen: Y, buffer: ne, length: ie, finished: oe, destroyed: se, pos: ae } = this;
    return z.length = ie, z.pos = ae, z.finished = oe, z.destroyed = se, ie % Y && z.buffer.set(ne), z;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$p, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
let SHA256$2 = class extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: ie, E: oe, F: se, G: ae, H: ge } = this;
    return [z, Y, ne, ie, oe, se, ae, ge];
  }
  // prettier-ignore
  set(z, Y, ne, ie, oe, se, ae, ge) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = ie | 0, this.E = oe | 0, this.F = se | 0, this.G = ae | 0, this.H = ge | 0;
  }
  process(z, Y) {
    for (let Ee = 0; Ee < 16; Ee++, Y += 4)
      SHA256_W[Ee] = z.getUint32(Y, !1);
    for (let Ee = 16; Ee < 64; Ee++) {
      const Je = SHA256_W[Ee - 15], Ve = SHA256_W[Ee - 2], $t = (0, utils_js_1$2.rotr)(Je, 7) ^ (0, utils_js_1$2.rotr)(Je, 18) ^ Je >>> 3, Nt = (0, utils_js_1$2.rotr)(Ve, 17) ^ (0, utils_js_1$2.rotr)(Ve, 19) ^ Ve >>> 10;
      SHA256_W[Ee] = Nt + SHA256_W[Ee - 7] + $t + SHA256_W[Ee - 16] | 0;
    }
    let { A: ne, B: ie, C: oe, D: se, E: ae, F: ge, G: Ce, H: le } = this;
    for (let Ee = 0; Ee < 64; Ee++) {
      const Je = (0, utils_js_1$2.rotr)(ae, 6) ^ (0, utils_js_1$2.rotr)(ae, 11) ^ (0, utils_js_1$2.rotr)(ae, 25), Ve = le + Je + (0, _md_js_1$2.Chi)(ae, ge, Ce) + SHA256_K[Ee] + SHA256_W[Ee] | 0, Nt = ((0, utils_js_1$2.rotr)(ne, 2) ^ (0, utils_js_1$2.rotr)(ne, 13) ^ (0, utils_js_1$2.rotr)(ne, 22)) + (0, _md_js_1$2.Maj)(ne, ie, oe) | 0;
      le = Ce, Ce = ge, ge = ae, ae = se + Ve | 0, se = oe, oe = ie, ie = ne, ne = Ve + Nt | 0;
    }
    ne = ne + this.A | 0, ie = ie + this.B | 0, oe = oe + this.C | 0, se = se + this.D | 0, ae = ae + this.E | 0, ge = ge + this.F | 0, Ce = Ce + this.G | 0, le = le + this.H | 0, this.set(ne, ie, oe, se, ae, ge, Ce, le);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
sha256$4.SHA256 = SHA256$2;
let SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256$2());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224$1());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$2 = { exports: {} }, dist$1 = {};
(function(B) {
  Object.defineProperties(B, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  var z = {}, Y = {};
  Y.byteLength = le, Y.toByteArray = Je, Y.fromByteArray = Nt;
  for (var ne = [], ie = [], oe = typeof Uint8Array < "u" ? Uint8Array : Array, se = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ae = 0, ge = se.length; ae < ge; ++ae)
    ne[ae] = se[ae], ie[se.charCodeAt(ae)] = ae;
  ie[45] = 62, ie[95] = 63;
  function Ce(Pt) {
    var Lt = Pt.length;
    if (Lt % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var qt = Pt.indexOf("=");
    qt === -1 && (qt = Lt);
    var Zt = qt === Lt ? 0 : 4 - qt % 4;
    return [qt, Zt];
  }
  function le(Pt) {
    var Lt = Ce(Pt), qt = Lt[0], Zt = Lt[1];
    return (qt + Zt) * 3 / 4 - Zt;
  }
  function Ee(Pt, Lt, qt) {
    return (Lt + qt) * 3 / 4 - qt;
  }
  function Je(Pt) {
    var Lt, qt = Ce(Pt), Zt = qt[0], Yt = qt[1], or = new oe(Ee(Pt, Zt, Yt)), jt = 0, Ct = Yt > 0 ? Zt - 4 : Zt, Vt;
    for (Vt = 0; Vt < Ct; Vt += 4)
      Lt = ie[Pt.charCodeAt(Vt)] << 18 | ie[Pt.charCodeAt(Vt + 1)] << 12 | ie[Pt.charCodeAt(Vt + 2)] << 6 | ie[Pt.charCodeAt(Vt + 3)], or[jt++] = Lt >> 16 & 255, or[jt++] = Lt >> 8 & 255, or[jt++] = Lt & 255;
    return Yt === 2 && (Lt = ie[Pt.charCodeAt(Vt)] << 2 | ie[Pt.charCodeAt(Vt + 1)] >> 4, or[jt++] = Lt & 255), Yt === 1 && (Lt = ie[Pt.charCodeAt(Vt)] << 10 | ie[Pt.charCodeAt(Vt + 1)] << 4 | ie[Pt.charCodeAt(Vt + 2)] >> 2, or[jt++] = Lt >> 8 & 255, or[jt++] = Lt & 255), or;
  }
  function Ve(Pt) {
    return ne[Pt >> 18 & 63] + ne[Pt >> 12 & 63] + ne[Pt >> 6 & 63] + ne[Pt & 63];
  }
  function $t(Pt, Lt, qt) {
    for (var Zt, Yt = [], or = Lt; or < qt; or += 3)
      Zt = (Pt[or] << 16 & 16711680) + (Pt[or + 1] << 8 & 65280) + (Pt[or + 2] & 255), Yt.push(Ve(Zt));
    return Yt.join("");
  }
  function Nt(Pt) {
    for (var Lt, qt = Pt.length, Zt = qt % 3, Yt = [], or = 16383, jt = 0, Ct = qt - Zt; jt < Ct; jt += or)
      Yt.push($t(Pt, jt, jt + or > Ct ? Ct : jt + or));
    return Zt === 1 ? (Lt = Pt[qt - 1], Yt.push(
      ne[Lt >> 2] + ne[Lt << 4 & 63] + "=="
    )) : Zt === 2 && (Lt = (Pt[qt - 2] << 8) + Pt[qt - 1], Yt.push(
      ne[Lt >> 10] + ne[Lt >> 4 & 63] + ne[Lt << 2 & 63] + "="
    )), Yt.join("");
  }
  var Dt = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  Dt.read = function(Pt, Lt, qt, Zt, Yt) {
    var or, jt, Ct = Yt * 8 - Zt - 1, Vt = (1 << Ct) - 1, kt = Vt >> 1, Pe = -7, Xe = qt ? Yt - 1 : 0, ve = qt ? -1 : 1, Ke = Pt[Lt + Xe];
    for (Xe += ve, or = Ke & (1 << -Pe) - 1, Ke >>= -Pe, Pe += Ct; Pe > 0; or = or * 256 + Pt[Lt + Xe], Xe += ve, Pe -= 8)
      ;
    for (jt = or & (1 << -Pe) - 1, or >>= -Pe, Pe += Zt; Pe > 0; jt = jt * 256 + Pt[Lt + Xe], Xe += ve, Pe -= 8)
      ;
    if (or === 0)
      or = 1 - kt;
    else {
      if (or === Vt)
        return jt ? NaN : (Ke ? -1 : 1) * (1 / 0);
      jt = jt + Math.pow(2, Zt), or = or - kt;
    }
    return (Ke ? -1 : 1) * jt * Math.pow(2, or - Zt);
  }, Dt.write = function(Pt, Lt, qt, Zt, Yt, or) {
    var jt, Ct, Vt, kt = or * 8 - Yt - 1, Pe = (1 << kt) - 1, Xe = Pe >> 1, ve = Yt === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ke = Zt ? 0 : or - 1, ht = Zt ? 1 : -1, wt = Lt < 0 || Lt === 0 && 1 / Lt < 0 ? 1 : 0;
    for (Lt = Math.abs(Lt), isNaN(Lt) || Lt === 1 / 0 ? (Ct = isNaN(Lt) ? 1 : 0, jt = Pe) : (jt = Math.floor(Math.log(Lt) / Math.LN2), Lt * (Vt = Math.pow(2, -jt)) < 1 && (jt--, Vt *= 2), jt + Xe >= 1 ? Lt += ve / Vt : Lt += ve * Math.pow(2, 1 - Xe), Lt * Vt >= 2 && (jt++, Vt /= 2), jt + Xe >= Pe ? (Ct = 0, jt = Pe) : jt + Xe >= 1 ? (Ct = (Lt * Vt - 1) * Math.pow(2, Yt), jt = jt + Xe) : (Ct = Lt * Math.pow(2, Xe - 1) * Math.pow(2, Yt), jt = 0)); Yt >= 8; Pt[qt + Ke] = Ct & 255, Ke += ht, Ct /= 256, Yt -= 8)
      ;
    for (jt = jt << Yt | Ct, kt += Yt; kt > 0; Pt[qt + Ke] = jt & 255, Ke += ht, jt /= 256, kt -= 8)
      ;
    Pt[qt + Ke - ht] |= wt * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(Pt) {
    const Lt = Y, qt = Dt, Zt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    Pt.Buffer = Pe, Pt.SlowBuffer = Ht, Pt.INSPECT_MAX_BYTES = 50;
    const Yt = 2147483647;
    Pt.kMaxLength = Yt;
    const { Uint8Array: or, ArrayBuffer: jt, SharedArrayBuffer: Ct } = globalThis;
    Pe.TYPED_ARRAY_SUPPORT = Vt(), !Pe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function Vt() {
      try {
        const Ft = new or(1), _t = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(_t, or.prototype), Object.setPrototypeOf(Ft, _t), Ft.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(Pe.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (Pe.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(Pe.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (Pe.isBuffer(this))
          return this.byteOffset;
      }
    });
    function kt(Ft) {
      if (Ft > Yt)
        throw new RangeError('The value "' + Ft + '" is invalid for option "size"');
      const _t = new or(Ft);
      return Object.setPrototypeOf(_t, Pe.prototype), _t;
    }
    function Pe(Ft, _t, Bt) {
      if (typeof Ft == "number") {
        if (typeof _t == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return ht(Ft);
      }
      return Xe(Ft, _t, Bt);
    }
    Pe.poolSize = 8192;
    function Xe(Ft, _t, Bt) {
      if (typeof Ft == "string")
        return wt(Ft, _t);
      if (jt.isView(Ft))
        return xt(Ft);
      if (Ft == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ft
        );
      if (Jr(Ft, jt) || Ft && Jr(Ft.buffer, jt) || typeof Ct < "u" && (Jr(Ft, Ct) || Ft && Jr(Ft.buffer, Ct)))
        return Qe(Ft, _t, Bt);
      if (typeof Ft == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const Xt = Ft.valueOf && Ft.valueOf();
      if (Xt != null && Xt !== Ft)
        return Pe.from(Xt, _t, Bt);
      const ir = Rt(Ft);
      if (ir) return ir;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Ft[Symbol.toPrimitive] == "function")
        return Pe.from(Ft[Symbol.toPrimitive]("string"), _t, Bt);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Ft
      );
    }
    Pe.from = function(Ft, _t, Bt) {
      return Xe(Ft, _t, Bt);
    }, Object.setPrototypeOf(Pe.prototype, or.prototype), Object.setPrototypeOf(Pe, or);
    function ve(Ft) {
      if (typeof Ft != "number")
        throw new TypeError('"size" argument must be of type number');
      if (Ft < 0)
        throw new RangeError('The value "' + Ft + '" is invalid for option "size"');
    }
    function Ke(Ft, _t, Bt) {
      return ve(Ft), Ft <= 0 ? kt(Ft) : _t !== void 0 ? typeof Bt == "string" ? kt(Ft).fill(_t, Bt) : kt(Ft).fill(_t) : kt(Ft);
    }
    Pe.alloc = function(Ft, _t, Bt) {
      return Ke(Ft, _t, Bt);
    };
    function ht(Ft) {
      return ve(Ft), kt(Ft < 0 ? 0 : bt(Ft) | 0);
    }
    Pe.allocUnsafe = function(Ft) {
      return ht(Ft);
    }, Pe.allocUnsafeSlow = function(Ft) {
      return ht(Ft);
    };
    function wt(Ft, _t) {
      if ((typeof _t != "string" || _t === "") && (_t = "utf8"), !Pe.isEncoding(_t))
        throw new TypeError("Unknown encoding: " + _t);
      const Bt = ar(Ft, _t) | 0;
      let Xt = kt(Bt);
      const ir = Xt.write(Ft, _t);
      return ir !== Bt && (Xt = Xt.slice(0, ir)), Xt;
    }
    function vt(Ft) {
      const _t = Ft.length < 0 ? 0 : bt(Ft.length) | 0, Bt = kt(_t);
      for (let Xt = 0; Xt < _t; Xt += 1)
        Bt[Xt] = Ft[Xt] & 255;
      return Bt;
    }
    function xt(Ft) {
      if (Jr(Ft, or)) {
        const _t = new or(Ft);
        return Qe(_t.buffer, _t.byteOffset, _t.byteLength);
      }
      return vt(Ft);
    }
    function Qe(Ft, _t, Bt) {
      if (_t < 0 || Ft.byteLength < _t)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (Ft.byteLength < _t + (Bt || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let Xt;
      return _t === void 0 && Bt === void 0 ? Xt = new or(Ft) : Bt === void 0 ? Xt = new or(Ft, _t) : Xt = new or(Ft, _t, Bt), Object.setPrototypeOf(Xt, Pe.prototype), Xt;
    }
    function Rt(Ft) {
      if (Pe.isBuffer(Ft)) {
        const _t = bt(Ft.length) | 0, Bt = kt(_t);
        return Bt.length === 0 || Ft.copy(Bt, 0, 0, _t), Bt;
      }
      if (Ft.length !== void 0)
        return typeof Ft.length != "number" || nn(Ft.length) ? kt(0) : vt(Ft);
      if (Ft.type === "Buffer" && Array.isArray(Ft.data))
        return vt(Ft.data);
    }
    function bt(Ft) {
      if (Ft >= Yt)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Yt.toString(16) + " bytes");
      return Ft | 0;
    }
    function Ht(Ft) {
      return +Ft != Ft && (Ft = 0), Pe.alloc(+Ft);
    }
    Pe.isBuffer = function(_t) {
      return _t != null && _t._isBuffer === !0 && _t !== Pe.prototype;
    }, Pe.compare = function(_t, Bt) {
      if (Jr(_t, or) && (_t = Pe.from(_t, _t.offset, _t.byteLength)), Jr(Bt, or) && (Bt = Pe.from(Bt, Bt.offset, Bt.byteLength)), !Pe.isBuffer(_t) || !Pe.isBuffer(Bt))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (_t === Bt) return 0;
      let Xt = _t.length, ir = Bt.length;
      for (let dr = 0, pr = Math.min(Xt, ir); dr < pr; ++dr)
        if (_t[dr] !== Bt[dr]) {
          Xt = _t[dr], ir = Bt[dr];
          break;
        }
      return Xt < ir ? -1 : ir < Xt ? 1 : 0;
    }, Pe.isEncoding = function(_t) {
      switch (String(_t).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, Pe.concat = function(_t, Bt) {
      if (!Array.isArray(_t))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (_t.length === 0)
        return Pe.alloc(0);
      let Xt;
      if (Bt === void 0)
        for (Bt = 0, Xt = 0; Xt < _t.length; ++Xt)
          Bt += _t[Xt].length;
      const ir = Pe.allocUnsafe(Bt);
      let dr = 0;
      for (Xt = 0; Xt < _t.length; ++Xt) {
        let pr = _t[Xt];
        if (Jr(pr, or))
          dr + pr.length > ir.length ? (Pe.isBuffer(pr) || (pr = Pe.from(pr)), pr.copy(ir, dr)) : or.prototype.set.call(
            ir,
            pr,
            dr
          );
        else if (Pe.isBuffer(pr))
          pr.copy(ir, dr);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        dr += pr.length;
      }
      return ir;
    };
    function ar(Ft, _t) {
      if (Pe.isBuffer(Ft))
        return Ft.length;
      if (jt.isView(Ft) || Jr(Ft, jt))
        return Ft.byteLength;
      if (typeof Ft != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Ft
        );
      const Bt = Ft.length, Xt = arguments.length > 2 && arguments[2] === !0;
      if (!Xt && Bt === 0) return 0;
      let ir = !1;
      for (; ; )
        switch (_t) {
          case "ascii":
          case "latin1":
          case "binary":
            return Bt;
          case "utf8":
          case "utf-8":
            return Wr(Ft).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Bt * 2;
          case "hex":
            return Bt >>> 1;
          case "base64":
            return Fr(Ft).length;
          default:
            if (ir)
              return Xt ? -1 : Wr(Ft).length;
            _t = ("" + _t).toLowerCase(), ir = !0;
        }
    }
    Pe.byteLength = ar;
    function yr(Ft, _t, Bt) {
      let Xt = !1;
      if ((_t === void 0 || _t < 0) && (_t = 0), _t > this.length || ((Bt === void 0 || Bt > this.length) && (Bt = this.length), Bt <= 0) || (Bt >>>= 0, _t >>>= 0, Bt <= _t))
        return "";
      for (Ft || (Ft = "utf8"); ; )
        switch (Ft) {
          case "hex":
            return Qr(this, _t, Bt);
          case "utf8":
          case "utf-8":
            return Ar(this, _t, Bt);
          case "ascii":
            return Cr(this, _t, Bt);
          case "latin1":
          case "binary":
            return $r(this, _t, Bt);
          case "base64":
            return Sr(this, _t, Bt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return jr(this, _t, Bt);
          default:
            if (Xt) throw new TypeError("Unknown encoding: " + Ft);
            Ft = (Ft + "").toLowerCase(), Xt = !0;
        }
    }
    Pe.prototype._isBuffer = !0;
    function rr(Ft, _t, Bt) {
      const Xt = Ft[_t];
      Ft[_t] = Ft[Bt], Ft[Bt] = Xt;
    }
    Pe.prototype.swap16 = function() {
      const _t = this.length;
      if (_t % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let Bt = 0; Bt < _t; Bt += 2)
        rr(this, Bt, Bt + 1);
      return this;
    }, Pe.prototype.swap32 = function() {
      const _t = this.length;
      if (_t % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let Bt = 0; Bt < _t; Bt += 4)
        rr(this, Bt, Bt + 3), rr(this, Bt + 1, Bt + 2);
      return this;
    }, Pe.prototype.swap64 = function() {
      const _t = this.length;
      if (_t % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let Bt = 0; Bt < _t; Bt += 8)
        rr(this, Bt, Bt + 7), rr(this, Bt + 1, Bt + 6), rr(this, Bt + 2, Bt + 5), rr(this, Bt + 3, Bt + 4);
      return this;
    }, Pe.prototype.toString = function() {
      const _t = this.length;
      return _t === 0 ? "" : arguments.length === 0 ? Ar(this, 0, _t) : yr.apply(this, arguments);
    }, Pe.prototype.toLocaleString = Pe.prototype.toString, Pe.prototype.equals = function(_t) {
      if (!Pe.isBuffer(_t)) throw new TypeError("Argument must be a Buffer");
      return this === _t ? !0 : Pe.compare(this, _t) === 0;
    }, Pe.prototype.inspect = function() {
      let _t = "";
      const Bt = Pt.INSPECT_MAX_BYTES;
      return _t = this.toString("hex", 0, Bt).replace(/(.{2})/g, "$1 ").trim(), this.length > Bt && (_t += " ... "), "<Buffer " + _t + ">";
    }, Zt && (Pe.prototype[Zt] = Pe.prototype.inspect), Pe.prototype.compare = function(_t, Bt, Xt, ir, dr) {
      if (Jr(_t, or) && (_t = Pe.from(_t, _t.offset, _t.byteLength)), !Pe.isBuffer(_t))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof _t
        );
      if (Bt === void 0 && (Bt = 0), Xt === void 0 && (Xt = _t ? _t.length : 0), ir === void 0 && (ir = 0), dr === void 0 && (dr = this.length), Bt < 0 || Xt > _t.length || ir < 0 || dr > this.length)
        throw new RangeError("out of range index");
      if (ir >= dr && Bt >= Xt)
        return 0;
      if (ir >= dr)
        return -1;
      if (Bt >= Xt)
        return 1;
      if (Bt >>>= 0, Xt >>>= 0, ir >>>= 0, dr >>>= 0, this === _t) return 0;
      let pr = dr - ir, xr = Xt - Bt;
      const Tr = Math.min(pr, xr), nr = this.slice(ir, dr), wr = _t.slice(Bt, Xt);
      for (let Er = 0; Er < Tr; ++Er)
        if (nr[Er] !== wr[Er]) {
          pr = nr[Er], xr = wr[Er];
          break;
        }
      return pr < xr ? -1 : xr < pr ? 1 : 0;
    };
    function Kt(Ft, _t, Bt, Xt, ir) {
      if (Ft.length === 0) return -1;
      if (typeof Bt == "string" ? (Xt = Bt, Bt = 0) : Bt > 2147483647 ? Bt = 2147483647 : Bt < -2147483648 && (Bt = -2147483648), Bt = +Bt, nn(Bt) && (Bt = ir ? 0 : Ft.length - 1), Bt < 0 && (Bt = Ft.length + Bt), Bt >= Ft.length) {
        if (ir) return -1;
        Bt = Ft.length - 1;
      } else if (Bt < 0)
        if (ir) Bt = 0;
        else return -1;
      if (typeof _t == "string" && (_t = Pe.from(_t, Xt)), Pe.isBuffer(_t))
        return _t.length === 0 ? -1 : Gt(Ft, _t, Bt, Xt, ir);
      if (typeof _t == "number")
        return _t = _t & 255, typeof or.prototype.indexOf == "function" ? ir ? or.prototype.indexOf.call(Ft, _t, Bt) : or.prototype.lastIndexOf.call(Ft, _t, Bt) : Gt(Ft, [_t], Bt, Xt, ir);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Gt(Ft, _t, Bt, Xt, ir) {
      let dr = 1, pr = Ft.length, xr = _t.length;
      if (Xt !== void 0 && (Xt = String(Xt).toLowerCase(), Xt === "ucs2" || Xt === "ucs-2" || Xt === "utf16le" || Xt === "utf-16le")) {
        if (Ft.length < 2 || _t.length < 2)
          return -1;
        dr = 2, pr /= 2, xr /= 2, Bt /= 2;
      }
      function Tr(wr, Er) {
        return dr === 1 ? wr[Er] : wr.readUInt16BE(Er * dr);
      }
      let nr;
      if (ir) {
        let wr = -1;
        for (nr = Bt; nr < pr; nr++)
          if (Tr(Ft, nr) === Tr(_t, wr === -1 ? 0 : nr - wr)) {
            if (wr === -1 && (wr = nr), nr - wr + 1 === xr) return wr * dr;
          } else
            wr !== -1 && (nr -= nr - wr), wr = -1;
      } else
        for (Bt + xr > pr && (Bt = pr - xr), nr = Bt; nr >= 0; nr--) {
          let wr = !0;
          for (let Er = 0; Er < xr; Er++)
            if (Tr(Ft, nr + Er) !== Tr(_t, Er)) {
              wr = !1;
              break;
            }
          if (wr) return nr;
        }
      return -1;
    }
    Pe.prototype.includes = function(_t, Bt, Xt) {
      return this.indexOf(_t, Bt, Xt) !== -1;
    }, Pe.prototype.indexOf = function(_t, Bt, Xt) {
      return Kt(this, _t, Bt, Xt, !0);
    }, Pe.prototype.lastIndexOf = function(_t, Bt, Xt) {
      return Kt(this, _t, Bt, Xt, !1);
    };
    function ur(Ft, _t, Bt, Xt) {
      Bt = Number(Bt) || 0;
      const ir = Ft.length - Bt;
      Xt ? (Xt = Number(Xt), Xt > ir && (Xt = ir)) : Xt = ir;
      const dr = _t.length;
      Xt > dr / 2 && (Xt = dr / 2);
      let pr;
      for (pr = 0; pr < Xt; ++pr) {
        const xr = parseInt(_t.substr(pr * 2, 2), 16);
        if (nn(xr)) return pr;
        Ft[Bt + pr] = xr;
      }
      return pr;
    }
    function gr(Ft, _t, Bt, Xt) {
      return Nr(Wr(_t, Ft.length - Bt), Ft, Bt, Xt);
    }
    function Qt(Ft, _t, Bt, Xt) {
      return Nr(Ir(_t), Ft, Bt, Xt);
    }
    function Jt(Ft, _t, Bt, Xt) {
      return Nr(Fr(_t), Ft, Bt, Xt);
    }
    function br(Ft, _t, Bt, Xt) {
      return Nr(Hr(_t, Ft.length - Bt), Ft, Bt, Xt);
    }
    Pe.prototype.write = function(_t, Bt, Xt, ir) {
      if (Bt === void 0)
        ir = "utf8", Xt = this.length, Bt = 0;
      else if (Xt === void 0 && typeof Bt == "string")
        ir = Bt, Xt = this.length, Bt = 0;
      else if (isFinite(Bt))
        Bt = Bt >>> 0, isFinite(Xt) ? (Xt = Xt >>> 0, ir === void 0 && (ir = "utf8")) : (ir = Xt, Xt = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const dr = this.length - Bt;
      if ((Xt === void 0 || Xt > dr) && (Xt = dr), _t.length > 0 && (Xt < 0 || Bt < 0) || Bt > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      ir || (ir = "utf8");
      let pr = !1;
      for (; ; )
        switch (ir) {
          case "hex":
            return ur(this, _t, Bt, Xt);
          case "utf8":
          case "utf-8":
            return gr(this, _t, Bt, Xt);
          case "ascii":
          case "latin1":
          case "binary":
            return Qt(this, _t, Bt, Xt);
          case "base64":
            return Jt(this, _t, Bt, Xt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return br(this, _t, Bt, Xt);
          default:
            if (pr) throw new TypeError("Unknown encoding: " + ir);
            ir = ("" + ir).toLowerCase(), pr = !0;
        }
    }, Pe.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function Sr(Ft, _t, Bt) {
      return _t === 0 && Bt === Ft.length ? Lt.fromByteArray(Ft) : Lt.fromByteArray(Ft.slice(_t, Bt));
    }
    function Ar(Ft, _t, Bt) {
      Bt = Math.min(Ft.length, Bt);
      const Xt = [];
      let ir = _t;
      for (; ir < Bt; ) {
        const dr = Ft[ir];
        let pr = null, xr = dr > 239 ? 4 : dr > 223 ? 3 : dr > 191 ? 2 : 1;
        if (ir + xr <= Bt) {
          let Tr, nr, wr, Er;
          switch (xr) {
            case 1:
              dr < 128 && (pr = dr);
              break;
            case 2:
              Tr = Ft[ir + 1], (Tr & 192) === 128 && (Er = (dr & 31) << 6 | Tr & 63, Er > 127 && (pr = Er));
              break;
            case 3:
              Tr = Ft[ir + 1], nr = Ft[ir + 2], (Tr & 192) === 128 && (nr & 192) === 128 && (Er = (dr & 15) << 12 | (Tr & 63) << 6 | nr & 63, Er > 2047 && (Er < 55296 || Er > 57343) && (pr = Er));
              break;
            case 4:
              Tr = Ft[ir + 1], nr = Ft[ir + 2], wr = Ft[ir + 3], (Tr & 192) === 128 && (nr & 192) === 128 && (wr & 192) === 128 && (Er = (dr & 15) << 18 | (Tr & 63) << 12 | (nr & 63) << 6 | wr & 63, Er > 65535 && Er < 1114112 && (pr = Er));
          }
        }
        pr === null ? (pr = 65533, xr = 1) : pr > 65535 && (pr -= 65536, Xt.push(pr >>> 10 & 1023 | 55296), pr = 56320 | pr & 1023), Xt.push(pr), ir += xr;
      }
      return Mr(Xt);
    }
    const Br = 4096;
    function Mr(Ft) {
      const _t = Ft.length;
      if (_t <= Br)
        return String.fromCharCode.apply(String, Ft);
      let Bt = "", Xt = 0;
      for (; Xt < _t; )
        Bt += String.fromCharCode.apply(
          String,
          Ft.slice(Xt, Xt += Br)
        );
      return Bt;
    }
    function Cr(Ft, _t, Bt) {
      let Xt = "";
      Bt = Math.min(Ft.length, Bt);
      for (let ir = _t; ir < Bt; ++ir)
        Xt += String.fromCharCode(Ft[ir] & 127);
      return Xt;
    }
    function $r(Ft, _t, Bt) {
      let Xt = "";
      Bt = Math.min(Ft.length, Bt);
      for (let ir = _t; ir < Bt; ++ir)
        Xt += String.fromCharCode(Ft[ir]);
      return Xt;
    }
    function Qr(Ft, _t, Bt) {
      const Xt = Ft.length;
      (!_t || _t < 0) && (_t = 0), (!Bt || Bt < 0 || Bt > Xt) && (Bt = Xt);
      let ir = "";
      for (let dr = _t; dr < Bt; ++dr)
        ir += fr[Ft[dr]];
      return ir;
    }
    function jr(Ft, _t, Bt) {
      const Xt = Ft.slice(_t, Bt);
      let ir = "";
      for (let dr = 0; dr < Xt.length - 1; dr += 2)
        ir += String.fromCharCode(Xt[dr] + Xt[dr + 1] * 256);
      return ir;
    }
    Pe.prototype.slice = function(_t, Bt) {
      const Xt = this.length;
      _t = ~~_t, Bt = Bt === void 0 ? Xt : ~~Bt, _t < 0 ? (_t += Xt, _t < 0 && (_t = 0)) : _t > Xt && (_t = Xt), Bt < 0 ? (Bt += Xt, Bt < 0 && (Bt = 0)) : Bt > Xt && (Bt = Xt), Bt < _t && (Bt = _t);
      const ir = this.subarray(_t, Bt);
      return Object.setPrototypeOf(ir, Pe.prototype), ir;
    };
    function qr(Ft, _t, Bt) {
      if (Ft % 1 !== 0 || Ft < 0) throw new RangeError("offset is not uint");
      if (Ft + _t > Bt) throw new RangeError("Trying to access beyond buffer length");
    }
    Pe.prototype.readUintLE = Pe.prototype.readUIntLE = function(_t, Bt, Xt) {
      _t = _t >>> 0, Bt = Bt >>> 0, Xt || qr(_t, Bt, this.length);
      let ir = this[_t], dr = 1, pr = 0;
      for (; ++pr < Bt && (dr *= 256); )
        ir += this[_t + pr] * dr;
      return ir;
    }, Pe.prototype.readUintBE = Pe.prototype.readUIntBE = function(_t, Bt, Xt) {
      _t = _t >>> 0, Bt = Bt >>> 0, Xt || qr(_t, Bt, this.length);
      let ir = this[_t + --Bt], dr = 1;
      for (; Bt > 0 && (dr *= 256); )
        ir += this[_t + --Bt] * dr;
      return ir;
    }, Pe.prototype.readUint8 = Pe.prototype.readUInt8 = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 1, this.length), this[_t];
    }, Pe.prototype.readUint16LE = Pe.prototype.readUInt16LE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 2, this.length), this[_t] | this[_t + 1] << 8;
    }, Pe.prototype.readUint16BE = Pe.prototype.readUInt16BE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 2, this.length), this[_t] << 8 | this[_t + 1];
    }, Pe.prototype.readUint32LE = Pe.prototype.readUInt32LE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 4, this.length), (this[_t] | this[_t + 1] << 8 | this[_t + 2] << 16) + this[_t + 3] * 16777216;
    }, Pe.prototype.readUint32BE = Pe.prototype.readUInt32BE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 4, this.length), this[_t] * 16777216 + (this[_t + 1] << 16 | this[_t + 2] << 8 | this[_t + 3]);
    }, Pe.prototype.readBigUInt64LE = er(function(_t) {
      _t = _t >>> 0, lr(_t, "offset");
      const Bt = this[_t], Xt = this[_t + 7];
      (Bt === void 0 || Xt === void 0) && vr(_t, this.length - 8);
      const ir = Bt + this[++_t] * 2 ** 8 + this[++_t] * 2 ** 16 + this[++_t] * 2 ** 24, dr = this[++_t] + this[++_t] * 2 ** 8 + this[++_t] * 2 ** 16 + Xt * 2 ** 24;
      return BigInt(ir) + (BigInt(dr) << BigInt(32));
    }), Pe.prototype.readBigUInt64BE = er(function(_t) {
      _t = _t >>> 0, lr(_t, "offset");
      const Bt = this[_t], Xt = this[_t + 7];
      (Bt === void 0 || Xt === void 0) && vr(_t, this.length - 8);
      const ir = Bt * 2 ** 24 + this[++_t] * 2 ** 16 + this[++_t] * 2 ** 8 + this[++_t], dr = this[++_t] * 2 ** 24 + this[++_t] * 2 ** 16 + this[++_t] * 2 ** 8 + Xt;
      return (BigInt(ir) << BigInt(32)) + BigInt(dr);
    }), Pe.prototype.readIntLE = function(_t, Bt, Xt) {
      _t = _t >>> 0, Bt = Bt >>> 0, Xt || qr(_t, Bt, this.length);
      let ir = this[_t], dr = 1, pr = 0;
      for (; ++pr < Bt && (dr *= 256); )
        ir += this[_t + pr] * dr;
      return dr *= 128, ir >= dr && (ir -= Math.pow(2, 8 * Bt)), ir;
    }, Pe.prototype.readIntBE = function(_t, Bt, Xt) {
      _t = _t >>> 0, Bt = Bt >>> 0, Xt || qr(_t, Bt, this.length);
      let ir = Bt, dr = 1, pr = this[_t + --ir];
      for (; ir > 0 && (dr *= 256); )
        pr += this[_t + --ir] * dr;
      return dr *= 128, pr >= dr && (pr -= Math.pow(2, 8 * Bt)), pr;
    }, Pe.prototype.readInt8 = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 1, this.length), this[_t] & 128 ? (255 - this[_t] + 1) * -1 : this[_t];
    }, Pe.prototype.readInt16LE = function(_t, Bt) {
      _t = _t >>> 0, Bt || qr(_t, 2, this.length);
      const Xt = this[_t] | this[_t + 1] << 8;
      return Xt & 32768 ? Xt | 4294901760 : Xt;
    }, Pe.prototype.readInt16BE = function(_t, Bt) {
      _t = _t >>> 0, Bt || qr(_t, 2, this.length);
      const Xt = this[_t + 1] | this[_t] << 8;
      return Xt & 32768 ? Xt | 4294901760 : Xt;
    }, Pe.prototype.readInt32LE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 4, this.length), this[_t] | this[_t + 1] << 8 | this[_t + 2] << 16 | this[_t + 3] << 24;
    }, Pe.prototype.readInt32BE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 4, this.length), this[_t] << 24 | this[_t + 1] << 16 | this[_t + 2] << 8 | this[_t + 3];
    }, Pe.prototype.readBigInt64LE = er(function(_t) {
      _t = _t >>> 0, lr(_t, "offset");
      const Bt = this[_t], Xt = this[_t + 7];
      (Bt === void 0 || Xt === void 0) && vr(_t, this.length - 8);
      const ir = this[_t + 4] + this[_t + 5] * 2 ** 8 + this[_t + 6] * 2 ** 16 + (Xt << 24);
      return (BigInt(ir) << BigInt(32)) + BigInt(Bt + this[++_t] * 2 ** 8 + this[++_t] * 2 ** 16 + this[++_t] * 2 ** 24);
    }), Pe.prototype.readBigInt64BE = er(function(_t) {
      _t = _t >>> 0, lr(_t, "offset");
      const Bt = this[_t], Xt = this[_t + 7];
      (Bt === void 0 || Xt === void 0) && vr(_t, this.length - 8);
      const ir = (Bt << 24) + // Overflow
      this[++_t] * 2 ** 16 + this[++_t] * 2 ** 8 + this[++_t];
      return (BigInt(ir) << BigInt(32)) + BigInt(this[++_t] * 2 ** 24 + this[++_t] * 2 ** 16 + this[++_t] * 2 ** 8 + Xt);
    }), Pe.prototype.readFloatLE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 4, this.length), qt.read(this, _t, !0, 23, 4);
    }, Pe.prototype.readFloatBE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 4, this.length), qt.read(this, _t, !1, 23, 4);
    }, Pe.prototype.readDoubleLE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 8, this.length), qt.read(this, _t, !0, 52, 8);
    }, Pe.prototype.readDoubleBE = function(_t, Bt) {
      return _t = _t >>> 0, Bt || qr(_t, 8, this.length), qt.read(this, _t, !1, 52, 8);
    };
    function Gr(Ft, _t, Bt, Xt, ir, dr) {
      if (!Pe.isBuffer(Ft)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (_t > ir || _t < dr) throw new RangeError('"value" argument is out of bounds');
      if (Bt + Xt > Ft.length) throw new RangeError("Index out of range");
    }
    Pe.prototype.writeUintLE = Pe.prototype.writeUIntLE = function(_t, Bt, Xt, ir) {
      if (_t = +_t, Bt = Bt >>> 0, Xt = Xt >>> 0, !ir) {
        const xr = Math.pow(2, 8 * Xt) - 1;
        Gr(this, _t, Bt, Xt, xr, 0);
      }
      let dr = 1, pr = 0;
      for (this[Bt] = _t & 255; ++pr < Xt && (dr *= 256); )
        this[Bt + pr] = _t / dr & 255;
      return Bt + Xt;
    }, Pe.prototype.writeUintBE = Pe.prototype.writeUIntBE = function(_t, Bt, Xt, ir) {
      if (_t = +_t, Bt = Bt >>> 0, Xt = Xt >>> 0, !ir) {
        const xr = Math.pow(2, 8 * Xt) - 1;
        Gr(this, _t, Bt, Xt, xr, 0);
      }
      let dr = Xt - 1, pr = 1;
      for (this[Bt + dr] = _t & 255; --dr >= 0 && (pr *= 256); )
        this[Bt + dr] = _t / pr & 255;
      return Bt + Xt;
    }, Pe.prototype.writeUint8 = Pe.prototype.writeUInt8 = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 1, 255, 0), this[Bt] = _t & 255, Bt + 1;
    }, Pe.prototype.writeUint16LE = Pe.prototype.writeUInt16LE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 2, 65535, 0), this[Bt] = _t & 255, this[Bt + 1] = _t >>> 8, Bt + 2;
    }, Pe.prototype.writeUint16BE = Pe.prototype.writeUInt16BE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 2, 65535, 0), this[Bt] = _t >>> 8, this[Bt + 1] = _t & 255, Bt + 2;
    }, Pe.prototype.writeUint32LE = Pe.prototype.writeUInt32LE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 4, 4294967295, 0), this[Bt + 3] = _t >>> 24, this[Bt + 2] = _t >>> 16, this[Bt + 1] = _t >>> 8, this[Bt] = _t & 255, Bt + 4;
    }, Pe.prototype.writeUint32BE = Pe.prototype.writeUInt32BE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 4, 4294967295, 0), this[Bt] = _t >>> 24, this[Bt + 1] = _t >>> 16, this[Bt + 2] = _t >>> 8, this[Bt + 3] = _t & 255, Bt + 4;
    };
    function Or(Ft, _t, Bt, Xt, ir) {
      tr(_t, Xt, ir, Ft, Bt, 7);
      let dr = Number(_t & BigInt(4294967295));
      Ft[Bt++] = dr, dr = dr >> 8, Ft[Bt++] = dr, dr = dr >> 8, Ft[Bt++] = dr, dr = dr >> 8, Ft[Bt++] = dr;
      let pr = Number(_t >> BigInt(32) & BigInt(4294967295));
      return Ft[Bt++] = pr, pr = pr >> 8, Ft[Bt++] = pr, pr = pr >> 8, Ft[Bt++] = pr, pr = pr >> 8, Ft[Bt++] = pr, Bt;
    }
    function Vr(Ft, _t, Bt, Xt, ir) {
      tr(_t, Xt, ir, Ft, Bt, 7);
      let dr = Number(_t & BigInt(4294967295));
      Ft[Bt + 7] = dr, dr = dr >> 8, Ft[Bt + 6] = dr, dr = dr >> 8, Ft[Bt + 5] = dr, dr = dr >> 8, Ft[Bt + 4] = dr;
      let pr = Number(_t >> BigInt(32) & BigInt(4294967295));
      return Ft[Bt + 3] = pr, pr = pr >> 8, Ft[Bt + 2] = pr, pr = pr >> 8, Ft[Bt + 1] = pr, pr = pr >> 8, Ft[Bt] = pr, Bt + 8;
    }
    Pe.prototype.writeBigUInt64LE = er(function(_t, Bt = 0) {
      return Or(this, _t, Bt, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Pe.prototype.writeBigUInt64BE = er(function(_t, Bt = 0) {
      return Vr(this, _t, Bt, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Pe.prototype.writeIntLE = function(_t, Bt, Xt, ir) {
      if (_t = +_t, Bt = Bt >>> 0, !ir) {
        const Tr = Math.pow(2, 8 * Xt - 1);
        Gr(this, _t, Bt, Xt, Tr - 1, -Tr);
      }
      let dr = 0, pr = 1, xr = 0;
      for (this[Bt] = _t & 255; ++dr < Xt && (pr *= 256); )
        _t < 0 && xr === 0 && this[Bt + dr - 1] !== 0 && (xr = 1), this[Bt + dr] = (_t / pr >> 0) - xr & 255;
      return Bt + Xt;
    }, Pe.prototype.writeIntBE = function(_t, Bt, Xt, ir) {
      if (_t = +_t, Bt = Bt >>> 0, !ir) {
        const Tr = Math.pow(2, 8 * Xt - 1);
        Gr(this, _t, Bt, Xt, Tr - 1, -Tr);
      }
      let dr = Xt - 1, pr = 1, xr = 0;
      for (this[Bt + dr] = _t & 255; --dr >= 0 && (pr *= 256); )
        _t < 0 && xr === 0 && this[Bt + dr + 1] !== 0 && (xr = 1), this[Bt + dr] = (_t / pr >> 0) - xr & 255;
      return Bt + Xt;
    }, Pe.prototype.writeInt8 = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 1, 127, -128), _t < 0 && (_t = 255 + _t + 1), this[Bt] = _t & 255, Bt + 1;
    }, Pe.prototype.writeInt16LE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 2, 32767, -32768), this[Bt] = _t & 255, this[Bt + 1] = _t >>> 8, Bt + 2;
    }, Pe.prototype.writeInt16BE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 2, 32767, -32768), this[Bt] = _t >>> 8, this[Bt + 1] = _t & 255, Bt + 2;
    }, Pe.prototype.writeInt32LE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 4, 2147483647, -2147483648), this[Bt] = _t & 255, this[Bt + 1] = _t >>> 8, this[Bt + 2] = _t >>> 16, this[Bt + 3] = _t >>> 24, Bt + 4;
    }, Pe.prototype.writeInt32BE = function(_t, Bt, Xt) {
      return _t = +_t, Bt = Bt >>> 0, Xt || Gr(this, _t, Bt, 4, 2147483647, -2147483648), _t < 0 && (_t = 4294967295 + _t + 1), this[Bt] = _t >>> 24, this[Bt + 1] = _t >>> 16, this[Bt + 2] = _t >>> 8, this[Bt + 3] = _t & 255, Bt + 4;
    }, Pe.prototype.writeBigInt64LE = er(function(_t, Bt = 0) {
      return Or(this, _t, Bt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Pe.prototype.writeBigInt64BE = er(function(_t, Bt = 0) {
      return Vr(this, _t, Bt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Zr(Ft, _t, Bt, Xt, ir, dr) {
      if (Bt + Xt > Ft.length) throw new RangeError("Index out of range");
      if (Bt < 0) throw new RangeError("Index out of range");
    }
    function Lr(Ft, _t, Bt, Xt, ir) {
      return _t = +_t, Bt = Bt >>> 0, ir || Zr(Ft, _t, Bt, 4), qt.write(Ft, _t, Bt, Xt, 23, 4), Bt + 4;
    }
    Pe.prototype.writeFloatLE = function(_t, Bt, Xt) {
      return Lr(this, _t, Bt, !0, Xt);
    }, Pe.prototype.writeFloatBE = function(_t, Bt, Xt) {
      return Lr(this, _t, Bt, !1, Xt);
    };
    function Yr(Ft, _t, Bt, Xt, ir) {
      return _t = +_t, Bt = Bt >>> 0, ir || Zr(Ft, _t, Bt, 8), qt.write(Ft, _t, Bt, Xt, 52, 8), Bt + 8;
    }
    Pe.prototype.writeDoubleLE = function(_t, Bt, Xt) {
      return Yr(this, _t, Bt, !0, Xt);
    }, Pe.prototype.writeDoubleBE = function(_t, Bt, Xt) {
      return Yr(this, _t, Bt, !1, Xt);
    }, Pe.prototype.copy = function(_t, Bt, Xt, ir) {
      if (!Pe.isBuffer(_t)) throw new TypeError("argument should be a Buffer");
      if (Xt || (Xt = 0), !ir && ir !== 0 && (ir = this.length), Bt >= _t.length && (Bt = _t.length), Bt || (Bt = 0), ir > 0 && ir < Xt && (ir = Xt), ir === Xt || _t.length === 0 || this.length === 0) return 0;
      if (Bt < 0)
        throw new RangeError("targetStart out of bounds");
      if (Xt < 0 || Xt >= this.length) throw new RangeError("Index out of range");
      if (ir < 0) throw new RangeError("sourceEnd out of bounds");
      ir > this.length && (ir = this.length), _t.length - Bt < ir - Xt && (ir = _t.length - Bt + Xt);
      const dr = ir - Xt;
      return this === _t && typeof or.prototype.copyWithin == "function" ? this.copyWithin(Bt, Xt, ir) : or.prototype.set.call(
        _t,
        this.subarray(Xt, ir),
        Bt
      ), dr;
    }, Pe.prototype.fill = function(_t, Bt, Xt, ir) {
      if (typeof _t == "string") {
        if (typeof Bt == "string" ? (ir = Bt, Bt = 0, Xt = this.length) : typeof Xt == "string" && (ir = Xt, Xt = this.length), ir !== void 0 && typeof ir != "string")
          throw new TypeError("encoding must be a string");
        if (typeof ir == "string" && !Pe.isEncoding(ir))
          throw new TypeError("Unknown encoding: " + ir);
        if (_t.length === 1) {
          const pr = _t.charCodeAt(0);
          (ir === "utf8" && pr < 128 || ir === "latin1") && (_t = pr);
        }
      } else typeof _t == "number" ? _t = _t & 255 : typeof _t == "boolean" && (_t = Number(_t));
      if (Bt < 0 || this.length < Bt || this.length < Xt)
        throw new RangeError("Out of range index");
      if (Xt <= Bt)
        return this;
      Bt = Bt >>> 0, Xt = Xt === void 0 ? this.length : Xt >>> 0, _t || (_t = 0);
      let dr;
      if (typeof _t == "number")
        for (dr = Bt; dr < Xt; ++dr)
          this[dr] = _t;
      else {
        const pr = Pe.isBuffer(_t) ? _t : Pe.from(_t, ir), xr = pr.length;
        if (xr === 0)
          throw new TypeError('The value "' + _t + '" is invalid for argument "value"');
        for (dr = 0; dr < Xt - Bt; ++dr)
          this[dr + Bt] = pr[dr % xr];
      }
      return this;
    };
    const en = {};
    function zt(Ft, _t, Bt) {
      en[Ft] = class extends Bt {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: _t.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${Ft}]`, this.stack, delete this.name;
        }
        get code() {
          return Ft;
        }
        set code(ir) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: ir,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${Ft}]: ${this.message}`;
        }
      };
    }
    zt(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(Ft) {
        return Ft ? `${Ft} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), zt(
      "ERR_INVALID_ARG_TYPE",
      function(Ft, _t) {
        return `The "${Ft}" argument must be of type number. Received type ${typeof _t}`;
      },
      TypeError
    ), zt(
      "ERR_OUT_OF_RANGE",
      function(Ft, _t, Bt) {
        let Xt = `The value of "${Ft}" is out of range.`, ir = Bt;
        return Number.isInteger(Bt) && Math.abs(Bt) > 2 ** 32 ? ir = Ot(String(Bt)) : typeof Bt == "bigint" && (ir = String(Bt), (Bt > BigInt(2) ** BigInt(32) || Bt < -(BigInt(2) ** BigInt(32))) && (ir = Ot(ir)), ir += "n"), Xt += ` It must be ${_t}. Received ${ir}`, Xt;
      },
      RangeError
    );
    function Ot(Ft) {
      let _t = "", Bt = Ft.length;
      const Xt = Ft[0] === "-" ? 1 : 0;
      for (; Bt >= Xt + 4; Bt -= 3)
        _t = `_${Ft.slice(Bt - 3, Bt)}${_t}`;
      return `${Ft.slice(0, Bt)}${_t}`;
    }
    function Ut(Ft, _t, Bt) {
      lr(_t, "offset"), (Ft[_t] === void 0 || Ft[_t + Bt] === void 0) && vr(_t, Ft.length - (Bt + 1));
    }
    function tr(Ft, _t, Bt, Xt, ir, dr) {
      if (Ft > Bt || Ft < _t) {
        const pr = typeof _t == "bigint" ? "n" : "";
        let xr;
        throw _t === 0 || _t === BigInt(0) ? xr = `>= 0${pr} and < 2${pr} ** ${(dr + 1) * 8}${pr}` : xr = `>= -(2${pr} ** ${(dr + 1) * 8 - 1}${pr}) and < 2 ** ${(dr + 1) * 8 - 1}${pr}`, new en.ERR_OUT_OF_RANGE("value", xr, Ft);
      }
      Ut(Xt, ir, dr);
    }
    function lr(Ft, _t) {
      if (typeof Ft != "number")
        throw new en.ERR_INVALID_ARG_TYPE(_t, "number", Ft);
    }
    function vr(Ft, _t, Bt) {
      throw Math.floor(Ft) !== Ft ? (lr(Ft, Bt), new en.ERR_OUT_OF_RANGE("offset", "an integer", Ft)) : _t < 0 ? new en.ERR_BUFFER_OUT_OF_BOUNDS() : new en.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${_t}`,
        Ft
      );
    }
    const _r = /[^+/0-9A-Za-z-_]/g;
    function Rr(Ft) {
      if (Ft = Ft.split("=")[0], Ft = Ft.trim().replace(_r, ""), Ft.length < 2) return "";
      for (; Ft.length % 4 !== 0; )
        Ft = Ft + "=";
      return Ft;
    }
    function Wr(Ft, _t) {
      _t = _t || 1 / 0;
      let Bt;
      const Xt = Ft.length;
      let ir = null;
      const dr = [];
      for (let pr = 0; pr < Xt; ++pr) {
        if (Bt = Ft.charCodeAt(pr), Bt > 55295 && Bt < 57344) {
          if (!ir) {
            if (Bt > 56319) {
              (_t -= 3) > -1 && dr.push(239, 191, 189);
              continue;
            } else if (pr + 1 === Xt) {
              (_t -= 3) > -1 && dr.push(239, 191, 189);
              continue;
            }
            ir = Bt;
            continue;
          }
          if (Bt < 56320) {
            (_t -= 3) > -1 && dr.push(239, 191, 189), ir = Bt;
            continue;
          }
          Bt = (ir - 55296 << 10 | Bt - 56320) + 65536;
        } else ir && (_t -= 3) > -1 && dr.push(239, 191, 189);
        if (ir = null, Bt < 128) {
          if ((_t -= 1) < 0) break;
          dr.push(Bt);
        } else if (Bt < 2048) {
          if ((_t -= 2) < 0) break;
          dr.push(
            Bt >> 6 | 192,
            Bt & 63 | 128
          );
        } else if (Bt < 65536) {
          if ((_t -= 3) < 0) break;
          dr.push(
            Bt >> 12 | 224,
            Bt >> 6 & 63 | 128,
            Bt & 63 | 128
          );
        } else if (Bt < 1114112) {
          if ((_t -= 4) < 0) break;
          dr.push(
            Bt >> 18 | 240,
            Bt >> 12 & 63 | 128,
            Bt >> 6 & 63 | 128,
            Bt & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return dr;
    }
    function Ir(Ft) {
      const _t = [];
      for (let Bt = 0; Bt < Ft.length; ++Bt)
        _t.push(Ft.charCodeAt(Bt) & 255);
      return _t;
    }
    function Hr(Ft, _t) {
      let Bt, Xt, ir;
      const dr = [];
      for (let pr = 0; pr < Ft.length && !((_t -= 2) < 0); ++pr)
        Bt = Ft.charCodeAt(pr), Xt = Bt >> 8, ir = Bt % 256, dr.push(ir), dr.push(Xt);
      return dr;
    }
    function Fr(Ft) {
      return Lt.toByteArray(Rr(Ft));
    }
    function Nr(Ft, _t, Bt, Xt) {
      let ir;
      for (ir = 0; ir < Xt && !(ir + Bt >= _t.length || ir >= Ft.length); ++ir)
        _t[ir + Bt] = Ft[ir];
      return ir;
    }
    function Jr(Ft, _t) {
      return Ft instanceof _t || Ft != null && Ft.constructor != null && Ft.constructor.name != null && Ft.constructor.name === _t.name;
    }
    function nn(Ft) {
      return Ft !== Ft;
    }
    const fr = function() {
      const Ft = "0123456789abcdef", _t = new Array(256);
      for (let Bt = 0; Bt < 16; ++Bt) {
        const Xt = Bt * 16;
        for (let ir = 0; ir < 16; ++ir)
          _t[Xt + ir] = Ft[Bt] + Ft[ir];
      }
      return _t;
    }();
    function er(Ft) {
      return typeof BigInt > "u" ? cr : Ft;
    }
    function cr() {
      throw new Error("BigInt not supported");
    }
  })(z);
  const Wt = z.Buffer;
  B.Blob = z.Blob, B.BlobOptions = z.BlobOptions, B.Buffer = z.Buffer, B.File = z.File, B.FileOptions = z.FileOptions, B.INSPECT_MAX_BYTES = z.INSPECT_MAX_BYTES, B.SlowBuffer = z.SlowBuffer, B.TranscodeEncoding = z.TranscodeEncoding, B.atob = z.atob, B.btoa = z.btoa, B.constants = z.constants, B.default = Wt, B.isAscii = z.isAscii, B.isUtf8 = z.isUtf8, B.kMaxLength = z.kMaxLength, B.kStringMaxLength = z.kStringMaxLength, B.resolveObjectURL = z.resolveObjectURL, B.transcode = z.transcode;
})(dist$1);
const Buffer$D = /* @__PURE__ */ getDefaultExportFromCjs(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, z) {
  var Y = dist$1, ne = Y.Buffer;
  function ie(se, ae) {
    for (var ge in se)
      ae[ge] = se[ge];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (ie(Y, z), z.Buffer = oe);
  function oe(se, ae, ge) {
    return ne(se, ae, ge);
  }
  oe.prototype = Object.create(ne.prototype), ie(ne, oe), oe.from = function(se, ae, ge) {
    if (typeof se == "number")
      throw new TypeError("Argument must not be a number");
    return ne(se, ae, ge);
  }, oe.alloc = function(se, ae, ge) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    var Ce = ne(se);
    return ae !== void 0 ? typeof ge == "string" ? Ce.fill(ae, ge) : Ce.fill(ae) : Ce.fill(0), Ce;
  }, oe.allocUnsafe = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return ne(se);
  }, oe.allocUnsafeSlow = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(se);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$C = safeBufferExports$1.Buffer, crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(B, z) {
  if (B > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var Y = Buffer$C.allocUnsafe(B);
  if (B > 0)
    if (B > MAX_BYTES)
      for (var ne = 0; ne < B; ne += MAX_BYTES)
        crypto$3.getRandomValues(Y.slice(ne, ne + MAX_BYTES));
    else
      crypto$3.getRandomValues(Y);
  return typeof z == "function" ? process$1.nextTick(function() {
    z(null, Y);
  }) : Y;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(z, Y) {
  Y && (z.super_ = Y, z.prototype = Object.create(Y.prototype, {
    constructor: {
      value: z,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(z, Y) {
  if (Y) {
    z.super_ = Y;
    var ne = function() {
    };
    ne.prototype = Y.prototype, z.prototype = new ne(), z.prototype.constructor = z;
  }
};
var inherits_browserExports = inherits_browser.exports, readableBrowser$1 = { exports: {} }, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(z, Y, ne) {
  return Function.prototype.apply.call(z, Y, ne);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(z) {
  return Object.getOwnPropertyNames(z).concat(Object.getOwnPropertySymbols(z));
} : ReflectOwnKeys = function(z) {
  return Object.getOwnPropertyNames(z);
};
function ProcessEmitWarning(B) {
  console && console.warn && console.warn(B);
}
var NumberIsNaN = Number.isNaN || function(z) {
  return z !== z;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(B) {
  if (typeof B != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof B);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(B) {
    if (typeof B != "number" || B < 0 || NumberIsNaN(B))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + B + ".");
    defaultMaxListeners = B;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(z) {
  if (typeof z != "number" || z < 0 || NumberIsNaN(z))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + z + ".");
  return this._maxListeners = z, this;
};
function _getMaxListeners(B) {
  return B._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : B._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(z) {
  for (var Y = [], ne = 1; ne < arguments.length; ne++) Y.push(arguments[ne]);
  var ie = z === "error", oe = this._events;
  if (oe !== void 0)
    ie = ie && oe.error === void 0;
  else if (!ie)
    return !1;
  if (ie) {
    var se;
    if (Y.length > 0 && (se = Y[0]), se instanceof Error)
      throw se;
    var ae = new Error("Unhandled error." + (se ? " (" + se.message + ")" : ""));
    throw ae.context = se, ae;
  }
  var ge = oe[z];
  if (ge === void 0)
    return !1;
  if (typeof ge == "function")
    ReflectApply(ge, this, Y);
  else
    for (var Ce = ge.length, le = arrayClone(ge, Ce), ne = 0; ne < Ce; ++ne)
      ReflectApply(le[ne], this, Y);
  return !0;
};
function _addListener(B, z, Y, ne) {
  var ie, oe, se;
  if (checkListener(Y), oe = B._events, oe === void 0 ? (oe = B._events = /* @__PURE__ */ Object.create(null), B._eventsCount = 0) : (oe.newListener !== void 0 && (B.emit(
    "newListener",
    z,
    Y.listener ? Y.listener : Y
  ), oe = B._events), se = oe[z]), se === void 0)
    se = oe[z] = Y, ++B._eventsCount;
  else if (typeof se == "function" ? se = oe[z] = ne ? [Y, se] : [se, Y] : ne ? se.unshift(Y) : se.push(Y), ie = _getMaxListeners(B), ie > 0 && se.length > ie && !se.warned) {
    se.warned = !0;
    var ae = new Error("Possible EventEmitter memory leak detected. " + se.length + " " + String(z) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    ae.name = "MaxListenersExceededWarning", ae.emitter = B, ae.type = z, ae.count = se.length, ProcessEmitWarning(ae);
  }
  return B;
}
EventEmitter.prototype.addListener = function(z, Y) {
  return _addListener(this, z, Y, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(z, Y) {
  return _addListener(this, z, Y, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(B, z, Y) {
  var ne = { fired: !1, wrapFn: void 0, target: B, type: z, listener: Y }, ie = onceWrapper.bind(ne);
  return ie.listener = Y, ne.wrapFn = ie, ie;
}
EventEmitter.prototype.once = function(z, Y) {
  return checkListener(Y), this.on(z, _onceWrap(this, z, Y)), this;
};
EventEmitter.prototype.prependOnceListener = function(z, Y) {
  return checkListener(Y), this.prependListener(z, _onceWrap(this, z, Y)), this;
};
EventEmitter.prototype.removeListener = function(z, Y) {
  var ne, ie, oe, se, ae;
  if (checkListener(Y), ie = this._events, ie === void 0)
    return this;
  if (ne = ie[z], ne === void 0)
    return this;
  if (ne === Y || ne.listener === Y)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ie[z], ie.removeListener && this.emit("removeListener", z, ne.listener || Y));
  else if (typeof ne != "function") {
    for (oe = -1, se = ne.length - 1; se >= 0; se--)
      if (ne[se] === Y || ne[se].listener === Y) {
        ae = ne[se].listener, oe = se;
        break;
      }
    if (oe < 0)
      return this;
    oe === 0 ? ne.shift() : spliceOne(ne, oe), ne.length === 1 && (ie[z] = ne[0]), ie.removeListener !== void 0 && this.emit("removeListener", z, ae || Y);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(z) {
  var Y, ne, ie;
  if (ne = this._events, ne === void 0)
    return this;
  if (ne.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ne[z] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ne[z]), this;
  if (arguments.length === 0) {
    var oe = Object.keys(ne), se;
    for (ie = 0; ie < oe.length; ++ie)
      se = oe[ie], se !== "removeListener" && this.removeAllListeners(se);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (Y = ne[z], typeof Y == "function")
    this.removeListener(z, Y);
  else if (Y !== void 0)
    for (ie = Y.length - 1; ie >= 0; ie--)
      this.removeListener(z, Y[ie]);
  return this;
};
function _listeners(B, z, Y) {
  var ne = B._events;
  if (ne === void 0)
    return [];
  var ie = ne[z];
  return ie === void 0 ? [] : typeof ie == "function" ? Y ? [ie.listener || ie] : [ie] : Y ? unwrapListeners(ie) : arrayClone(ie, ie.length);
}
EventEmitter.prototype.listeners = function(z) {
  return _listeners(this, z, !0);
};
EventEmitter.prototype.rawListeners = function(z) {
  return _listeners(this, z, !1);
};
EventEmitter.listenerCount = function(B, z) {
  return typeof B.listenerCount == "function" ? B.listenerCount(z) : listenerCount.call(B, z);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(B) {
  var z = this._events;
  if (z !== void 0) {
    var Y = z[B];
    if (typeof Y == "function")
      return 1;
    if (Y !== void 0)
      return Y.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(B, z) {
  for (var Y = new Array(z), ne = 0; ne < z; ++ne)
    Y[ne] = B[ne];
  return Y;
}
function spliceOne(B, z) {
  for (; z + 1 < B.length; z++)
    B[z] = B[z + 1];
  B.pop();
}
function unwrapListeners(B) {
  for (var z = new Array(B.length), Y = 0; Y < z.length; ++Y)
    z[Y] = B[Y].listener || B[Y];
  return z;
}
function once(B, z) {
  return new Promise(function(Y, ne) {
    function ie(se) {
      B.removeListener(z, oe), ne(se);
    }
    function oe() {
      typeof B.removeListener == "function" && B.removeListener("error", ie), Y([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(B, z, oe, { once: !0 }), z !== "error" && addErrorHandlerIfEventEmitter(B, ie, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(B, z, Y) {
  typeof B.on == "function" && eventTargetAgnosticAddListener(B, "error", z, Y);
}
function eventTargetAgnosticAddListener(B, z, Y, ne) {
  if (typeof B.on == "function")
    ne.once ? B.once(z, Y) : B.on(z, Y);
  else if (typeof B.addEventListener == "function")
    B.addEventListener(z, function ie(oe) {
      ne.once && B.removeEventListener(z, ie), Y(oe);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof B);
}
var eventsExports = events.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$3 = {}, types$5 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var z = {}, Y = Symbol("test"), ne = Object(Y);
  if (typeof Y == "string" || Object.prototype.toString.call(Y) !== "[object Symbol]" || Object.prototype.toString.call(ne) !== "[object Symbol]")
    return !1;
  var ie = 42;
  z[Y] = ie;
  for (var oe in z)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(z).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(z).length !== 0)
    return !1;
  var se = Object.getOwnPropertySymbols(z);
  if (se.length !== 1 || se[0] !== Y || !Object.prototype.propertyIsEnumerable.call(z, Y))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var ae = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(z, Y)
    );
    if (ae.value !== ie || ae.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range$3 = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(z) {
  return z !== z;
}, $isNaN = _isNaN, sign$2 = function(z) {
  return $isNaN(z) || z === 0 ? z : z < 0 ? -1 : 1;
}, gOPD$3 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$3;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, hasSymbols$1, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, z = shams$1;
  return hasSymbols$1 = function() {
    return typeof B != "function" || typeof Symbol != "function" || typeof B("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : z();
  }, hasSymbols$1;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var B = esObjectAtoms;
  return Object_getPrototypeOf = B.getPrototypeOf || null, Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(z, Y) {
  for (var ne = [], ie = 0; ie < z.length; ie += 1)
    ne[ie] = z[ie];
  for (var oe = 0; oe < Y.length; oe += 1)
    ne[oe + z.length] = Y[oe];
  return ne;
}, slicy = function(z, Y) {
  for (var ne = [], ie = Y, oe = 0; ie < z.length; ie += 1, oe += 1)
    ne[oe] = z[ie];
  return ne;
}, joiny = function(B, z) {
  for (var Y = "", ne = 0; ne < B.length; ne += 1)
    Y += B[ne], ne + 1 < B.length && (Y += z);
  return Y;
}, implementation$1 = function(z) {
  var Y = this;
  if (typeof Y != "function" || toStr$3.apply(Y) !== funcType)
    throw new TypeError(ERROR_MESSAGE + Y);
  for (var ne = slicy(arguments, 1), ie, oe = function() {
    if (this instanceof ie) {
      var le = Y.apply(
        this,
        concatty(ne, arguments)
      );
      return Object(le) === le ? le : this;
    }
    return Y.apply(
      z,
      concatty(ne, arguments)
    );
  }, se = max$1(0, Y.length - ne.length), ae = [], ge = 0; ge < se; ge++)
    ae[ge] = "$" + ge;
  if (ie = Function("binder", "return function (" + joiny(ae, ",") + "){ return binder.apply(this,arguments); }")(oe), Y.prototype) {
    var Ce = function() {
    };
    Ce.prototype = Y.prototype, ie.prototype = new Ce(), Ce.prototype = null;
  }
  return ie;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, functionCall = Function.prototype.call, functionApply = Function.prototype.apply, reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$4 = functionBind, $apply$2 = functionApply, $call$2 = functionCall, $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$4.call($call$2, $apply$2), bind$3 = functionBind, $TypeError$4 = type, $call$1 = functionCall, $actualApply = actualApply$1, callBindApplyHelpers = function(z) {
  if (z.length < 1 || typeof z[0] != "function")
    throw new $TypeError$4("a function is required");
  return $actualApply(bind$3, $call$1, z);
}, get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var B = callBindApplyHelpers, z = gopd$1, Y;
  try {
    Y = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (se) {
    if (!se || typeof se != "object" || !("code" in se) || se.code !== "ERR_PROTO_ACCESS")
      throw se;
  }
  var ne = !!Y && z && z(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), ie = Object, oe = ie.getPrototypeOf;
  return get = ne && typeof ne.get == "function" ? B([ne.get]) : typeof oe == "function" ? (
    /** @type {import('./get')} */
    function(ae) {
      return oe(ae == null ? ae : ie(ae));
    }
  ) : !1, get;
}
var getProto$2, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$2;
  hasRequiredGetProto = 1;
  var B = requireReflect_getPrototypeOf(), z = requireObject_getPrototypeOf(), Y = requireGet();
  return getProto$2 = B ? function(ie) {
    return B(ie);
  } : z ? function(ie) {
    if (!ie || typeof ie != "object" && typeof ie != "function")
      throw new TypeError("getProto: not an object");
    return z(ie);
  } : Y ? function(ie) {
    return Y(ie);
  } : null, getProto$2;
}
var call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call, $hasOwn), undefined$1, $Object = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range$3, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$3 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(B) {
  try {
    return $Function('"use strict"; return (' + B + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = requireHasSymbols()(), getProto$1 = requireGetProto(), $ObjectGPO = requireObject_getPrototypeOf(), $ReflectGPO = requireReflect_getPrototypeOf(), $apply$1 = functionApply, $call = functionCall, needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$1)
  try {
    null.error;
  } catch (B) {
    var errorProto = getProto$1(getProto$1(B));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function B(z) {
  var Y;
  if (z === "%AsyncFunction%")
    Y = getEvalledConstructor("async function () {}");
  else if (z === "%GeneratorFunction%")
    Y = getEvalledConstructor("function* () {}");
  else if (z === "%AsyncGeneratorFunction%")
    Y = getEvalledConstructor("async function* () {}");
  else if (z === "%AsyncGenerator%") {
    var ne = B("%AsyncGeneratorFunction%");
    ne && (Y = ne.prototype);
  } else if (z === "%AsyncIteratorPrototype%") {
    var ie = B("%AsyncGenerator%");
    ie && getProto$1 && (Y = getProto$1(ie.prototype));
  }
  return INTRINSICS[z] = Y, Y;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = hasown, $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(z) {
  var Y = $strSlice(z, 0, 1), ne = $strSlice(z, -1);
  if (Y === "%" && ne !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (ne === "%" && Y !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var ie = [];
  return $replace(z, rePropName, function(oe, se, ae, ge) {
    ie[ie.length] = ae ? $replace(ge, reEscapeChar, "$1") : se || oe;
  }), ie;
}, getBaseIntrinsic = function(z, Y) {
  var ne = z, ie;
  if (hasOwn$1(LEGACY_ALIASES, ne) && (ie = LEGACY_ALIASES[ne], ne = "%" + ie[0] + "%"), hasOwn$1(INTRINSICS, ne)) {
    var oe = INTRINSICS[ne];
    if (oe === needsEval && (oe = doEval(ne)), typeof oe > "u" && !Y)
      throw new $TypeError$3("intrinsic " + z + " exists, but is not available. Please file an issue!");
    return {
      alias: ie,
      name: ne,
      value: oe
    };
  }
  throw new $SyntaxError$1("intrinsic " + z + " does not exist!");
}, getIntrinsic = function(z, Y) {
  if (typeof z != "string" || z.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof Y != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, z) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var ne = stringToPath(z), ie = ne.length > 0 ? ne[0] : "", oe = getBaseIntrinsic("%" + ie + "%", Y), se = oe.name, ae = oe.value, ge = !1, Ce = oe.alias;
  Ce && (ie = Ce[0], $spliceApply(ne, $concat([0, 1], Ce)));
  for (var le = 1, Ee = !0; le < ne.length; le += 1) {
    var Je = ne[le], Ve = $strSlice(Je, 0, 1), $t = $strSlice(Je, -1);
    if ((Ve === '"' || Ve === "'" || Ve === "`" || $t === '"' || $t === "'" || $t === "`") && Ve !== $t)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((Je === "constructor" || !Ee) && (ge = !0), ie += "." + Je, se = "%" + ie + "%", hasOwn$1(INTRINSICS, se))
      ae = INTRINSICS[se];
    else if (ae != null) {
      if (!(Je in ae)) {
        if (!Y)
          throw new $TypeError$3("base intrinsic for " + z + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && le + 1 >= ne.length) {
        var Nt = $gOPD(ae, Je);
        Ee = !!Nt, Ee && "get" in Nt && !("originalValue" in Nt.get) ? ae = Nt.get : ae = ae[Je];
      } else
        Ee = hasOwn$1(ae, Je), ae = ae[Je];
      Ee && !ge && (INTRINSICS[se] = ae);
    }
  }
  return ae;
}, GetIntrinsic$1 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$1 = callBindBasic([GetIntrinsic$1("%String.prototype.indexOf%")]), callBound$5 = function(z, Y) {
  var ne = (
    /** @type {Parameters<typeof callBindBasic>[0][0]} */
    GetIntrinsic$1(z, !!Y)
  );
  return typeof ne == "function" && $indexOf$1(z, ".prototype.") > -1 ? callBindBasic([ne]) : ne;
}, hasToStringTag$4 = shams(), callBound$4 = callBound$5, $toString$2 = callBound$4("Object.prototype.toString"), isStandardArguments = function(z) {
  return hasToStringTag$4 && z && typeof z == "object" && Symbol.toStringTag in z ? !1 : $toString$2(z) === "[object Arguments]";
}, isLegacyArguments = function(z) {
  return isStandardArguments(z) ? !0 : z !== null && typeof z == "object" && "length" in z && typeof z.length == "number" && z.length >= 0 && $toString$2(z) !== "[object Array]" && "callee" in z && $toString$2(z.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$3 = callBound$5, hasToStringTag$3 = shams(), hasOwn = hasown, gOPD$2 = gopd$1, fn;
if (hasToStringTag$3) {
  var $exec$1 = callBound$3("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(z) {
    if (!z || typeof z != "object")
      return !1;
    var Y = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD$2(
        /** @type {{ lastIndex?: unknown }} */
        z,
        "lastIndex"
      )
    ), ne = Y && hasOwn(Y, "value");
    if (!ne)
      return !1;
    try {
      $exec$1(
        z,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (ie) {
      return ie === isRegexMarker;
    }
  };
} else {
  var $toString$1 = callBound$3("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(z) {
    return !z || typeof z != "object" && typeof z != "function" ? !1 : $toString$1(z) === regexClass;
  };
}
var isRegex$1 = fn, callBound$2 = callBound$5, isRegex = isRegex$1, $exec = callBound$2("RegExp.prototype.exec"), $TypeError$2 = type, safeRegexTest$1 = function(z) {
  if (!isRegex(z))
    throw new $TypeError$2("`regex` must be a RegExp");
  return function(ne) {
    return $exec(z, ne) !== null;
  };
}, callBound$1 = callBound$5, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag$2 = shams(), getProto = requireGetProto(), toStr$2 = callBound$1("Object.prototype.toString"), fnToStr$1 = callBound$1("Function.prototype.toString"), getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(z) {
  if (typeof z != "function")
    return !1;
  if (isFnRegex(fnToStr$1(z)))
    return !0;
  if (!hasToStringTag$2) {
    var Y = toStr$2(z);
    return Y === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var ne = getGeneratorFunc();
    GeneratorFunction = ne ? (
      /** @type {GeneratorFunctionConstructor} */
      getProto(ne)
    ) : !1;
  }
  return getProto(z) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (B) {
    B !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(z) {
  try {
    var Y = fnToStr.call(z);
    return constructorRegex.test(Y);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(z) {
  try {
    return isES6ClassFn(z) ? !1 : (fnToStr.call(z), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(z) {
    if ((isIE68 || !z) && (typeof z > "u" || typeof z == "object"))
      try {
        var Y = toStr$1.call(z);
        return (Y === ddaClass || Y === ddaClass2 || Y === ddaClass3 || Y === objectClass) && z("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(z) {
  if (isDDA(z))
    return !0;
  if (!z || typeof z != "function" && typeof z != "object")
    return !1;
  try {
    reflectApply(z, null, badArrayLike);
  } catch (Y) {
    if (Y !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(z) && tryFunctionObject(z);
} : function(z) {
  if (isDDA(z))
    return !0;
  if (!z || typeof z != "function" && typeof z != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(z);
  if (isES6ClassFn(z))
    return !1;
  var Y = toStr$1.call(z);
  return Y !== fnClass && Y !== genClass && !/^\[object HTML/.test(Y) ? !1 : tryFunctionObject(z);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(z, Y, ne) {
  for (var ie = 0, oe = z.length; ie < oe; ie++)
    hasOwnProperty.call(z, ie) && (ne == null ? Y(z[ie], ie, z) : Y.call(ne, z[ie], ie, z));
}, forEachString = function(z, Y, ne) {
  for (var ie = 0, oe = z.length; ie < oe; ie++)
    ne == null ? Y(z.charAt(ie), ie, z) : Y.call(ne, z.charAt(ie), ie, z);
}, forEachObject = function(z, Y, ne) {
  for (var ie in z)
    hasOwnProperty.call(z, ie) && (ne == null ? Y(z[ie], ie, z) : Y.call(ne, z[ie], ie, z));
};
function isArray$1(B) {
  return toStr.call(B) === "[object Array]";
}
var forEach$1 = function(z, Y, ne) {
  if (!isCallable(Y))
    throw new TypeError("iterator must be a function");
  var ie;
  arguments.length >= 3 && (ie = ne), isArray$1(z) ? forEachArray(z, Y, ie) : typeof z == "string" ? forEachString(z, Y, ie) : forEachObject(z, Y, ie);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var z = [], Y = 0; Y < possibleNames.length; Y++)
    typeof g$1[possibleNames[Y]] == "function" && (z[z.length] = possibleNames[Y]);
  return z;
}, callBind$1 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(z, Y, ne) {
  if (!z || typeof z != "object" && typeof z != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof Y != "string" && typeof Y != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var ie = arguments.length > 3 ? arguments[3] : null, oe = arguments.length > 4 ? arguments[4] : null, se = arguments.length > 5 ? arguments[5] : null, ae = arguments.length > 6 ? arguments[6] : !1, ge = !!gopd && gopd(z, Y);
  if ($defineProperty$1)
    $defineProperty$1(z, Y, {
      configurable: se === null && ge ? ge.configurable : !se,
      enumerable: ie === null && ge ? ge.enumerable : !ie,
      value: ne,
      writable: oe === null && ge ? ge.writable : !oe
    });
  else if (ae || !ie && !oe && !se)
    z[Y] = ne;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic("%Math.floor%"), setFunctionLength = function(z, Y) {
  if (typeof z != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof Y != "number" || Y < 0 || Y > 4294967295 || $floor(Y) !== Y)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var ne = arguments.length > 2 && !!arguments[2], ie = !0, oe = !0;
  if ("length" in z && gOPD$1) {
    var se = gOPD$1(z, "length");
    se && !se.configurable && (ie = !1), se && !se.writable && (oe = !1);
  }
  return (ie || oe || !ne) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    z,
    "length",
    Y,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    z,
    "length",
    Y
  )), z;
}, bind = functionBind, $apply = functionApply, actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
(function(B) {
  var z = setFunctionLength, Y = esDefineProperty, ne = callBindApplyHelpers, ie = applyBind;
  B.exports = function(se) {
    var ae = ne(arguments), ge = se.length - (arguments.length - 1);
    return z(
      ae,
      1 + (ge > 0 ? ge : 0),
      !0
    );
  }, Y ? Y(B.exports, "apply", { value: ie }) : B.exports.apply = ie;
})(callBind$1);
var callBindExports = callBind$1.exports, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$5, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function(z, Y) {
  for (var ne = 0; ne < z.length; ne += 1)
    if (z[ne] === Y)
      return ne;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(B) {
  var z = new g[B]();
  if (Symbol.toStringTag in z) {
    var Y = getPrototypeOf(z), ne = gOPD(Y, Symbol.toStringTag);
    if (!ne) {
      var ie = getPrototypeOf(Y);
      ne = gOPD(ie, Symbol.toStringTag);
    }
    cache["$" + B] = callBind(ne.get);
  }
}) : forEach(typedArrays, function(B) {
  var z = new g[B](), Y = z.slice || z.set;
  Y && (cache["$" + B] = callBind(Y));
});
var tryTypedArrays = function(z) {
  var Y = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(ne, ie) {
      if (!Y)
        try {
          "$" + ne(z) === ie && (Y = $slice(ie, 1));
        } catch {
        }
    }
  ), Y;
}, trySlices = function(z) {
  var Y = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(ne, ie) {
      if (!Y)
        try {
          ne(z), Y = $slice(ie, 1);
        } catch {
        }
    }
  ), Y;
}, whichTypedArray$1 = function(z) {
  if (!z || typeof z != "object")
    return !1;
  if (!hasToStringTag) {
    var Y = $slice($toString(z), 8, -1);
    return $indexOf(typedArrays, Y) > -1 ? Y : Y !== "Object" ? !1 : trySlices(z);
  }
  return gOPD ? tryTypedArrays(z) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(z) {
  return !!whichTypedArray(z);
};
(function(B) {
  var z = isArguments, Y = isGeneratorFunction, ne = whichTypedArray$1, ie = isTypedArray;
  function oe($r) {
    return $r.call.bind($r);
  }
  var se = typeof BigInt < "u", ae = typeof Symbol < "u", ge = oe(Object.prototype.toString), Ce = oe(Number.prototype.valueOf), le = oe(String.prototype.valueOf), Ee = oe(Boolean.prototype.valueOf);
  if (se)
    var Je = oe(BigInt.prototype.valueOf);
  if (ae)
    var Ve = oe(Symbol.prototype.valueOf);
  function $t($r, Qr) {
    if (typeof $r != "object")
      return !1;
    try {
      return Qr($r), !0;
    } catch {
      return !1;
    }
  }
  B.isArgumentsObject = z, B.isGeneratorFunction = Y, B.isTypedArray = ie;
  function Nt($r) {
    return typeof Promise < "u" && $r instanceof Promise || $r !== null && typeof $r == "object" && typeof $r.then == "function" && typeof $r.catch == "function";
  }
  B.isPromise = Nt;
  function Dt($r) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView($r) : ie($r) || Ht($r);
  }
  B.isArrayBufferView = Dt;
  function Wt($r) {
    return ne($r) === "Uint8Array";
  }
  B.isUint8Array = Wt;
  function Pt($r) {
    return ne($r) === "Uint8ClampedArray";
  }
  B.isUint8ClampedArray = Pt;
  function Lt($r) {
    return ne($r) === "Uint16Array";
  }
  B.isUint16Array = Lt;
  function qt($r) {
    return ne($r) === "Uint32Array";
  }
  B.isUint32Array = qt;
  function Zt($r) {
    return ne($r) === "Int8Array";
  }
  B.isInt8Array = Zt;
  function Yt($r) {
    return ne($r) === "Int16Array";
  }
  B.isInt16Array = Yt;
  function or($r) {
    return ne($r) === "Int32Array";
  }
  B.isInt32Array = or;
  function jt($r) {
    return ne($r) === "Float32Array";
  }
  B.isFloat32Array = jt;
  function Ct($r) {
    return ne($r) === "Float64Array";
  }
  B.isFloat64Array = Ct;
  function Vt($r) {
    return ne($r) === "BigInt64Array";
  }
  B.isBigInt64Array = Vt;
  function kt($r) {
    return ne($r) === "BigUint64Array";
  }
  B.isBigUint64Array = kt;
  function Pe($r) {
    return ge($r) === "[object Map]";
  }
  Pe.working = typeof Map < "u" && Pe(/* @__PURE__ */ new Map());
  function Xe($r) {
    return typeof Map > "u" ? !1 : Pe.working ? Pe($r) : $r instanceof Map;
  }
  B.isMap = Xe;
  function ve($r) {
    return ge($r) === "[object Set]";
  }
  ve.working = typeof Set < "u" && ve(/* @__PURE__ */ new Set());
  function Ke($r) {
    return typeof Set > "u" ? !1 : ve.working ? ve($r) : $r instanceof Set;
  }
  B.isSet = Ke;
  function ht($r) {
    return ge($r) === "[object WeakMap]";
  }
  ht.working = typeof WeakMap < "u" && ht(/* @__PURE__ */ new WeakMap());
  function wt($r) {
    return typeof WeakMap > "u" ? !1 : ht.working ? ht($r) : $r instanceof WeakMap;
  }
  B.isWeakMap = wt;
  function vt($r) {
    return ge($r) === "[object WeakSet]";
  }
  vt.working = typeof WeakSet < "u" && vt(/* @__PURE__ */ new WeakSet());
  function xt($r) {
    return vt($r);
  }
  B.isWeakSet = xt;
  function Qe($r) {
    return ge($r) === "[object ArrayBuffer]";
  }
  Qe.working = typeof ArrayBuffer < "u" && Qe(new ArrayBuffer());
  function Rt($r) {
    return typeof ArrayBuffer > "u" ? !1 : Qe.working ? Qe($r) : $r instanceof ArrayBuffer;
  }
  B.isArrayBuffer = Rt;
  function bt($r) {
    return ge($r) === "[object DataView]";
  }
  bt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && bt(new DataView(new ArrayBuffer(1), 0, 1));
  function Ht($r) {
    return typeof DataView > "u" ? !1 : bt.working ? bt($r) : $r instanceof DataView;
  }
  B.isDataView = Ht;
  var ar = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function yr($r) {
    return ge($r) === "[object SharedArrayBuffer]";
  }
  function rr($r) {
    return typeof ar > "u" ? !1 : (typeof yr.working > "u" && (yr.working = yr(new ar())), yr.working ? yr($r) : $r instanceof ar);
  }
  B.isSharedArrayBuffer = rr;
  function Kt($r) {
    return ge($r) === "[object AsyncFunction]";
  }
  B.isAsyncFunction = Kt;
  function Gt($r) {
    return ge($r) === "[object Map Iterator]";
  }
  B.isMapIterator = Gt;
  function ur($r) {
    return ge($r) === "[object Set Iterator]";
  }
  B.isSetIterator = ur;
  function gr($r) {
    return ge($r) === "[object Generator]";
  }
  B.isGeneratorObject = gr;
  function Qt($r) {
    return ge($r) === "[object WebAssembly.Module]";
  }
  B.isWebAssemblyCompiledModule = Qt;
  function Jt($r) {
    return $t($r, Ce);
  }
  B.isNumberObject = Jt;
  function br($r) {
    return $t($r, le);
  }
  B.isStringObject = br;
  function Sr($r) {
    return $t($r, Ee);
  }
  B.isBooleanObject = Sr;
  function Ar($r) {
    return se && $t($r, Je);
  }
  B.isBigIntObject = Ar;
  function Br($r) {
    return ae && $t($r, Ve);
  }
  B.isSymbolObject = Br;
  function Mr($r) {
    return Jt($r) || br($r) || Sr($r) || Ar($r) || Br($r);
  }
  B.isBoxedPrimitive = Mr;
  function Cr($r) {
    return typeof Uint8Array < "u" && (Rt($r) || rr($r));
  }
  B.isAnyArrayBuffer = Cr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function($r) {
    Object.defineProperty(B, $r, {
      enumerable: !1,
      value: function() {
        throw new Error($r + " is not supported in userland");
      }
    });
  });
})(types$5);
var isBufferBrowser = function(z) {
  return z && typeof z == "object" && typeof z.copy == "function" && typeof z.fill == "function" && typeof z.readUInt8 == "function";
};
(function(B) {
  var z = Object.getOwnPropertyDescriptors || function(Ht) {
    for (var ar = Object.keys(Ht), yr = {}, rr = 0; rr < ar.length; rr++)
      yr[ar[rr]] = Object.getOwnPropertyDescriptor(Ht, ar[rr]);
    return yr;
  }, Y = /%[sdj%]/g;
  B.format = function(bt) {
    if (!Zt(bt)) {
      for (var Ht = [], ar = 0; ar < arguments.length; ar++)
        Ht.push(se(arguments[ar]));
      return Ht.join(" ");
    }
    for (var ar = 1, yr = arguments, rr = yr.length, Kt = String(bt).replace(Y, function(ur) {
      if (ur === "%%") return "%";
      if (ar >= rr) return ur;
      switch (ur) {
        case "%s":
          return String(yr[ar++]);
        case "%d":
          return Number(yr[ar++]);
        case "%j":
          try {
            return JSON.stringify(yr[ar++]);
          } catch {
            return "[Circular]";
          }
        default:
          return ur;
      }
    }), Gt = yr[ar]; ar < rr; Gt = yr[++ar])
      Pt(Gt) || !Ct(Gt) ? Kt += " " + Gt : Kt += " " + se(Gt);
    return Kt;
  }, B.deprecate = function(bt, Ht) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return bt;
    if (typeof process$1 > "u")
      return function() {
        return B.deprecate(bt, Ht).apply(this, arguments);
      };
    var ar = !1;
    function yr() {
      if (!ar) {
        if (process$1.throwDeprecation)
          throw new Error(Ht);
        process$1.traceDeprecation ? console.trace(Ht) : console.error(Ht), ar = !0;
      }
      return bt.apply(this, arguments);
    }
    return yr;
  };
  var ne = {}, ie = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var oe = process$1.env.NODE_DEBUG;
    oe = oe.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ie = new RegExp("^" + oe + "$", "i");
  }
  B.debuglog = function(bt) {
    if (bt = bt.toUpperCase(), !ne[bt])
      if (ie.test(bt)) {
        var Ht = process$1.pid;
        ne[bt] = function() {
          var ar = B.format.apply(B, arguments);
          console.error("%s %d: %s", bt, Ht, ar);
        };
      } else
        ne[bt] = function() {
        };
    return ne[bt];
  };
  function se(bt, Ht) {
    var ar = {
      seen: [],
      stylize: ge
    };
    return arguments.length >= 3 && (ar.depth = arguments[2]), arguments.length >= 4 && (ar.colors = arguments[3]), Wt(Ht) ? ar.showHidden = Ht : Ht && B._extend(ar, Ht), or(ar.showHidden) && (ar.showHidden = !1), or(ar.depth) && (ar.depth = 2), or(ar.colors) && (ar.colors = !1), or(ar.customInspect) && (ar.customInspect = !0), ar.colors && (ar.stylize = ae), le(ar, bt, ar.depth);
  }
  B.inspect = se, se.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, se.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function ae(bt, Ht) {
    var ar = se.styles[Ht];
    return ar ? "\x1B[" + se.colors[ar][0] + "m" + bt + "\x1B[" + se.colors[ar][1] + "m" : bt;
  }
  function ge(bt, Ht) {
    return bt;
  }
  function Ce(bt) {
    var Ht = {};
    return bt.forEach(function(ar, yr) {
      Ht[ar] = !0;
    }), Ht;
  }
  function le(bt, Ht, ar) {
    if (bt.customInspect && Ht && Pe(Ht.inspect) && // Filter out the util module, it's inspect function is special
    Ht.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
    !(Ht.constructor && Ht.constructor.prototype === Ht)) {
      var yr = Ht.inspect(ar, bt);
      return Zt(yr) || (yr = le(bt, yr, ar)), yr;
    }
    var rr = Ee(bt, Ht);
    if (rr)
      return rr;
    var Kt = Object.keys(Ht), Gt = Ce(Kt);
    if (bt.showHidden && (Kt = Object.getOwnPropertyNames(Ht)), kt(Ht) && (Kt.indexOf("message") >= 0 || Kt.indexOf("description") >= 0))
      return Je(Ht);
    if (Kt.length === 0) {
      if (Pe(Ht)) {
        var ur = Ht.name ? ": " + Ht.name : "";
        return bt.stylize("[Function" + ur + "]", "special");
      }
      if (jt(Ht))
        return bt.stylize(RegExp.prototype.toString.call(Ht), "regexp");
      if (Vt(Ht))
        return bt.stylize(Date.prototype.toString.call(Ht), "date");
      if (kt(Ht))
        return Je(Ht);
    }
    var gr = "", Qt = !1, Jt = ["{", "}"];
    if (Dt(Ht) && (Qt = !0, Jt = ["[", "]"]), Pe(Ht)) {
      var br = Ht.name ? ": " + Ht.name : "";
      gr = " [Function" + br + "]";
    }
    if (jt(Ht) && (gr = " " + RegExp.prototype.toString.call(Ht)), Vt(Ht) && (gr = " " + Date.prototype.toUTCString.call(Ht)), kt(Ht) && (gr = " " + Je(Ht)), Kt.length === 0 && (!Qt || Ht.length == 0))
      return Jt[0] + gr + Jt[1];
    if (ar < 0)
      return jt(Ht) ? bt.stylize(RegExp.prototype.toString.call(Ht), "regexp") : bt.stylize("[Object]", "special");
    bt.seen.push(Ht);
    var Sr;
    return Qt ? Sr = Ve(bt, Ht, ar, Gt, Kt) : Sr = Kt.map(function(Ar) {
      return $t(bt, Ht, ar, Gt, Ar, Qt);
    }), bt.seen.pop(), Nt(Sr, gr, Jt);
  }
  function Ee(bt, Ht) {
    if (or(Ht))
      return bt.stylize("undefined", "undefined");
    if (Zt(Ht)) {
      var ar = "'" + JSON.stringify(Ht).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return bt.stylize(ar, "string");
    }
    if (qt(Ht))
      return bt.stylize("" + Ht, "number");
    if (Wt(Ht))
      return bt.stylize("" + Ht, "boolean");
    if (Pt(Ht))
      return bt.stylize("null", "null");
  }
  function Je(bt) {
    return "[" + Error.prototype.toString.call(bt) + "]";
  }
  function Ve(bt, Ht, ar, yr, rr) {
    for (var Kt = [], Gt = 0, ur = Ht.length; Gt < ur; ++Gt)
      vt(Ht, String(Gt)) ? Kt.push($t(
        bt,
        Ht,
        ar,
        yr,
        String(Gt),
        !0
      )) : Kt.push("");
    return rr.forEach(function(gr) {
      gr.match(/^\d+$/) || Kt.push($t(
        bt,
        Ht,
        ar,
        yr,
        gr,
        !0
      ));
    }), Kt;
  }
  function $t(bt, Ht, ar, yr, rr, Kt) {
    var Gt, ur, gr;
    if (gr = Object.getOwnPropertyDescriptor(Ht, rr) || { value: Ht[rr] }, gr.get ? gr.set ? ur = bt.stylize("[Getter/Setter]", "special") : ur = bt.stylize("[Getter]", "special") : gr.set && (ur = bt.stylize("[Setter]", "special")), vt(yr, rr) || (Gt = "[" + rr + "]"), ur || (bt.seen.indexOf(gr.value) < 0 ? (Pt(ar) ? ur = le(bt, gr.value, null) : ur = le(bt, gr.value, ar - 1), ur.indexOf(`
`) > -1 && (Kt ? ur = ur.split(`
`).map(function(Qt) {
      return "  " + Qt;
    }).join(`
`).slice(2) : ur = `
` + ur.split(`
`).map(function(Qt) {
      return "   " + Qt;
    }).join(`
`))) : ur = bt.stylize("[Circular]", "special")), or(Gt)) {
      if (Kt && rr.match(/^\d+$/))
        return ur;
      Gt = JSON.stringify("" + rr), Gt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Gt = Gt.slice(1, -1), Gt = bt.stylize(Gt, "name")) : (Gt = Gt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Gt = bt.stylize(Gt, "string"));
    }
    return Gt + ": " + ur;
  }
  function Nt(bt, Ht, ar) {
    var yr = bt.reduce(function(rr, Kt) {
      return Kt.indexOf(`
`) >= 0, rr + Kt.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return yr > 60 ? ar[0] + (Ht === "" ? "" : Ht + `
 `) + " " + bt.join(`,
  `) + " " + ar[1] : ar[0] + Ht + " " + bt.join(", ") + " " + ar[1];
  }
  B.types = types$5;
  function Dt(bt) {
    return Array.isArray(bt);
  }
  B.isArray = Dt;
  function Wt(bt) {
    return typeof bt == "boolean";
  }
  B.isBoolean = Wt;
  function Pt(bt) {
    return bt === null;
  }
  B.isNull = Pt;
  function Lt(bt) {
    return bt == null;
  }
  B.isNullOrUndefined = Lt;
  function qt(bt) {
    return typeof bt == "number";
  }
  B.isNumber = qt;
  function Zt(bt) {
    return typeof bt == "string";
  }
  B.isString = Zt;
  function Yt(bt) {
    return typeof bt == "symbol";
  }
  B.isSymbol = Yt;
  function or(bt) {
    return bt === void 0;
  }
  B.isUndefined = or;
  function jt(bt) {
    return Ct(bt) && ve(bt) === "[object RegExp]";
  }
  B.isRegExp = jt, B.types.isRegExp = jt;
  function Ct(bt) {
    return typeof bt == "object" && bt !== null;
  }
  B.isObject = Ct;
  function Vt(bt) {
    return Ct(bt) && ve(bt) === "[object Date]";
  }
  B.isDate = Vt, B.types.isDate = Vt;
  function kt(bt) {
    return Ct(bt) && (ve(bt) === "[object Error]" || bt instanceof Error);
  }
  B.isError = kt, B.types.isNativeError = kt;
  function Pe(bt) {
    return typeof bt == "function";
  }
  B.isFunction = Pe;
  function Xe(bt) {
    return bt === null || typeof bt == "boolean" || typeof bt == "number" || typeof bt == "string" || typeof bt == "symbol" || // ES6 symbol
    typeof bt > "u";
  }
  B.isPrimitive = Xe, B.isBuffer = isBufferBrowser;
  function ve(bt) {
    return Object.prototype.toString.call(bt);
  }
  function Ke(bt) {
    return bt < 10 ? "0" + bt.toString(10) : bt.toString(10);
  }
  var ht = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function wt() {
    var bt = /* @__PURE__ */ new Date(), Ht = [
      Ke(bt.getHours()),
      Ke(bt.getMinutes()),
      Ke(bt.getSeconds())
    ].join(":");
    return [bt.getDate(), ht[bt.getMonth()], Ht].join(" ");
  }
  B.log = function() {
    console.log("%s - %s", wt(), B.format.apply(B, arguments));
  }, B.inherits = inherits_browserExports, B._extend = function(bt, Ht) {
    if (!Ht || !Ct(Ht)) return bt;
    for (var ar = Object.keys(Ht), yr = ar.length; yr--; )
      bt[ar[yr]] = Ht[ar[yr]];
    return bt;
  };
  function vt(bt, Ht) {
    return Object.prototype.hasOwnProperty.call(bt, Ht);
  }
  var xt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  B.promisify = function(Ht) {
    if (typeof Ht != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (xt && Ht[xt]) {
      var ar = Ht[xt];
      if (typeof ar != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(ar, xt, {
        value: ar,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), ar;
    }
    function ar() {
      for (var yr, rr, Kt = new Promise(function(gr, Qt) {
        yr = gr, rr = Qt;
      }), Gt = [], ur = 0; ur < arguments.length; ur++)
        Gt.push(arguments[ur]);
      Gt.push(function(gr, Qt) {
        gr ? rr(gr) : yr(Qt);
      });
      try {
        Ht.apply(this, Gt);
      } catch (gr) {
        rr(gr);
      }
      return Kt;
    }
    return Object.setPrototypeOf(ar, Object.getPrototypeOf(Ht)), xt && Object.defineProperty(ar, xt, {
      value: ar,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      ar,
      z(Ht)
    );
  }, B.promisify.custom = xt;
  function Qe(bt, Ht) {
    if (!bt) {
      var ar = new Error("Promise was rejected with a falsy value");
      ar.reason = bt, bt = ar;
    }
    return Ht(bt);
  }
  function Rt(bt) {
    if (typeof bt != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Ht() {
      for (var ar = [], yr = 0; yr < arguments.length; yr++)
        ar.push(arguments[yr]);
      var rr = ar.pop();
      if (typeof rr != "function")
        throw new TypeError("The last argument must be of type Function");
      var Kt = this, Gt = function() {
        return rr.apply(Kt, arguments);
      };
      bt.apply(this, ar).then(
        function(ur) {
          process$1.nextTick(Gt.bind(null, null, ur));
        },
        function(ur) {
          process$1.nextTick(Qe.bind(null, ur, Gt));
        }
      );
    }
    return Object.setPrototypeOf(Ht, Object.getPrototypeOf(bt)), Object.defineProperties(
      Ht,
      z(bt)
    ), Ht;
  }
  B.callbackify = Rt;
})(util$3);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B($t, Nt) {
    var Dt = Object.keys($t);
    if (Object.getOwnPropertySymbols) {
      var Wt = Object.getOwnPropertySymbols($t);
      Nt && (Wt = Wt.filter(function(Pt) {
        return Object.getOwnPropertyDescriptor($t, Pt).enumerable;
      })), Dt.push.apply(Dt, Wt);
    }
    return Dt;
  }
  function z($t) {
    for (var Nt = 1; Nt < arguments.length; Nt++) {
      var Dt = arguments[Nt] != null ? arguments[Nt] : {};
      Nt % 2 ? B(Object(Dt), !0).forEach(function(Wt) {
        Y($t, Wt, Dt[Wt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties($t, Object.getOwnPropertyDescriptors(Dt)) : B(Object(Dt)).forEach(function(Wt) {
        Object.defineProperty($t, Wt, Object.getOwnPropertyDescriptor(Dt, Wt));
      });
    }
    return $t;
  }
  function Y($t, Nt, Dt) {
    return Nt = se(Nt), Nt in $t ? Object.defineProperty($t, Nt, { value: Dt, enumerable: !0, configurable: !0, writable: !0 }) : $t[Nt] = Dt, $t;
  }
  function ne($t, Nt) {
    if (!($t instanceof Nt))
      throw new TypeError("Cannot call a class as a function");
  }
  function ie($t, Nt) {
    for (var Dt = 0; Dt < Nt.length; Dt++) {
      var Wt = Nt[Dt];
      Wt.enumerable = Wt.enumerable || !1, Wt.configurable = !0, "value" in Wt && (Wt.writable = !0), Object.defineProperty($t, se(Wt.key), Wt);
    }
  }
  function oe($t, Nt, Dt) {
    return Nt && ie($t.prototype, Nt), Object.defineProperty($t, "prototype", { writable: !1 }), $t;
  }
  function se($t) {
    var Nt = ae($t, "string");
    return typeof Nt == "symbol" ? Nt : String(Nt);
  }
  function ae($t, Nt) {
    if (typeof $t != "object" || $t === null) return $t;
    var Dt = $t[Symbol.toPrimitive];
    if (Dt !== void 0) {
      var Wt = Dt.call($t, Nt);
      if (typeof Wt != "object") return Wt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String($t);
  }
  var ge = dist$1, Ce = ge.Buffer, le = util$3, Ee = le.inspect, Je = Ee && Ee.custom || "inspect";
  function Ve($t, Nt, Dt) {
    Ce.prototype.copy.call($t, Nt, Dt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function $t() {
      ne(this, $t), this.head = null, this.tail = null, this.length = 0;
    }
    return oe($t, [{
      key: "push",
      value: function(Dt) {
        var Wt = {
          data: Dt,
          next: null
        };
        this.length > 0 ? this.tail.next = Wt : this.head = Wt, this.tail = Wt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Dt) {
        var Wt = {
          data: Dt,
          next: this.head
        };
        this.length === 0 && (this.tail = Wt), this.head = Wt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Dt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Dt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Dt) {
        if (this.length === 0) return "";
        for (var Wt = this.head, Pt = "" + Wt.data; Wt = Wt.next; ) Pt += Dt + Wt.data;
        return Pt;
      }
    }, {
      key: "concat",
      value: function(Dt) {
        if (this.length === 0) return Ce.alloc(0);
        for (var Wt = Ce.allocUnsafe(Dt >>> 0), Pt = this.head, Lt = 0; Pt; )
          Ve(Pt.data, Wt, Lt), Lt += Pt.data.length, Pt = Pt.next;
        return Wt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Dt, Wt) {
        var Pt;
        return Dt < this.head.data.length ? (Pt = this.head.data.slice(0, Dt), this.head.data = this.head.data.slice(Dt)) : Dt === this.head.data.length ? Pt = this.shift() : Pt = Wt ? this._getString(Dt) : this._getBuffer(Dt), Pt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Dt) {
        var Wt = this.head, Pt = 1, Lt = Wt.data;
        for (Dt -= Lt.length; Wt = Wt.next; ) {
          var qt = Wt.data, Zt = Dt > qt.length ? qt.length : Dt;
          if (Zt === qt.length ? Lt += qt : Lt += qt.slice(0, Dt), Dt -= Zt, Dt === 0) {
            Zt === qt.length ? (++Pt, Wt.next ? this.head = Wt.next : this.head = this.tail = null) : (this.head = Wt, Wt.data = qt.slice(Zt));
            break;
          }
          ++Pt;
        }
        return this.length -= Pt, Lt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Dt) {
        var Wt = Ce.allocUnsafe(Dt), Pt = this.head, Lt = 1;
        for (Pt.data.copy(Wt), Dt -= Pt.data.length; Pt = Pt.next; ) {
          var qt = Pt.data, Zt = Dt > qt.length ? qt.length : Dt;
          if (qt.copy(Wt, Wt.length - Dt, 0, Zt), Dt -= Zt, Dt === 0) {
            Zt === qt.length ? (++Lt, Pt.next ? this.head = Pt.next : this.head = this.tail = null) : (this.head = Pt, Pt.data = qt.slice(Zt));
            break;
          }
          ++Lt;
        }
        return this.length -= Lt, Wt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Je,
      value: function(Dt, Wt) {
        return Ee(this, z(z({}, Wt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), $t;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  function B(se, ae) {
    var ge = this, Ce = this._readableState && this._readableState.destroyed, le = this._writableState && this._writableState.destroyed;
    return Ce || le ? (ae ? ae(se) : se && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(ie, this, se)) : process$1.nextTick(ie, this, se)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(se || null, function(Ee) {
      !ae && Ee ? ge._writableState ? ge._writableState.errorEmitted ? process$1.nextTick(Y, ge) : (ge._writableState.errorEmitted = !0, process$1.nextTick(z, ge, Ee)) : process$1.nextTick(z, ge, Ee) : ae ? (process$1.nextTick(Y, ge), ae(Ee)) : process$1.nextTick(Y, ge);
    }), this);
  }
  function z(se, ae) {
    ie(se, ae), Y(se);
  }
  function Y(se) {
    se._writableState && !se._writableState.emitClose || se._readableState && !se._readableState.emitClose || se.emit("close");
  }
  function ne() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function ie(se, ae) {
    se.emit("error", ae);
  }
  function oe(se, ae) {
    var ge = se._readableState, Ce = se._writableState;
    ge && ge.autoDestroy || Ce && Ce.autoDestroy ? se.destroy(ae) : se.emit("error", ae);
  }
  return destroy_1$1 = {
    destroy: B,
    undestroy: ne,
    errorOrDestroy: oe
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function B(ae, ge) {
    ae.prototype = Object.create(ge.prototype), ae.prototype.constructor = ae, ae.__proto__ = ge;
  }
  var z = {};
  function Y(ae, ge, Ce) {
    Ce || (Ce = Error);
    function le(Je, Ve, $t) {
      return typeof ge == "string" ? ge : ge(Je, Ve, $t);
    }
    var Ee = /* @__PURE__ */ function(Je) {
      B(Ve, Je);
      function Ve($t, Nt, Dt) {
        return Je.call(this, le($t, Nt, Dt)) || this;
      }
      return Ve;
    }(Ce);
    Ee.prototype.name = Ce.name, Ee.prototype.code = ae, z[ae] = Ee;
  }
  function ne(ae, ge) {
    if (Array.isArray(ae)) {
      var Ce = ae.length;
      return ae = ae.map(function(le) {
        return String(le);
      }), Ce > 2 ? "one of ".concat(ge, " ").concat(ae.slice(0, Ce - 1).join(", "), ", or ") + ae[Ce - 1] : Ce === 2 ? "one of ".concat(ge, " ").concat(ae[0], " or ").concat(ae[1]) : "of ".concat(ge, " ").concat(ae[0]);
    } else
      return "of ".concat(ge, " ").concat(String(ae));
  }
  function ie(ae, ge, Ce) {
    return ae.substr(0, ge.length) === ge;
  }
  function oe(ae, ge, Ce) {
    return (Ce === void 0 || Ce > ae.length) && (Ce = ae.length), ae.substring(Ce - ge.length, Ce) === ge;
  }
  function se(ae, ge, Ce) {
    return typeof Ce != "number" && (Ce = 0), Ce + ge.length > ae.length ? !1 : ae.indexOf(ge, Ce) !== -1;
  }
  return Y("ERR_INVALID_OPT_VALUE", function(ae, ge) {
    return 'The value "' + ge + '" is invalid for option "' + ae + '"';
  }, TypeError), Y("ERR_INVALID_ARG_TYPE", function(ae, ge, Ce) {
    var le;
    typeof ge == "string" && ie(ge, "not ") ? (le = "must not be", ge = ge.replace(/^not /, "")) : le = "must be";
    var Ee;
    if (oe(ae, " argument"))
      Ee = "The ".concat(ae, " ").concat(le, " ").concat(ne(ge, "type"));
    else {
      var Je = se(ae, ".") ? "property" : "argument";
      Ee = 'The "'.concat(ae, '" ').concat(Je, " ").concat(le, " ").concat(ne(ge, "type"));
    }
    return Ee += ". Received type ".concat(typeof Ce), Ee;
  }, TypeError), Y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Y("ERR_METHOD_NOT_IMPLEMENTED", function(ae) {
    return "The " + ae + " method is not implemented";
  }), Y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Y("ERR_STREAM_DESTROYED", function(ae) {
    return "Cannot call " + ae + " after a stream was destroyed";
  }), Y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Y("ERR_STREAM_WRITE_AFTER_END", "write after end"), Y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Y("ERR_UNKNOWN_ENCODING", function(ae) {
    return "Unknown encoding: " + ae;
  }, TypeError), Y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = z, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function z(ne, ie, oe) {
    return ne.highWaterMark != null ? ne.highWaterMark : ie ? ne[oe] : null;
  }
  function Y(ne, ie, oe, se) {
    var ae = z(ie, se, oe);
    if (ae != null) {
      if (!(isFinite(ae) && Math.floor(ae) === ae) || ae < 0) {
        var ge = se ? oe : "highWaterMark";
        throw new B(ge, ae);
      }
      return Math.floor(ae);
    }
    return ne.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Y
  }, state;
}
var browser$a = deprecate;
function deprecate(B, z) {
  if (config("noDeprecation"))
    return B;
  var Y = !1;
  function ne() {
    if (!Y) {
      if (config("throwDeprecation"))
        throw new Error(z);
      config("traceDeprecation") ? console.trace(z) : console.warn(z), Y = !0;
    }
    return B.apply(this, arguments);
  }
  return ne;
}
function config(B) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var z = commonjsGlobal.localStorage[B];
  return z == null ? !1 : String(z).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = jt;
  function B(rr) {
    var Kt = this;
    this.next = null, this.entry = null, this.finish = function() {
      yr(Kt, rr);
    };
  }
  var z;
  jt.WritableState = Yt;
  var Y = {
    deprecate: browser$a
  }, ne = requireStreamBrowser(), ie = dist$1.Buffer, oe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function se(rr) {
    return ie.from(rr);
  }
  function ae(rr) {
    return ie.isBuffer(rr) || rr instanceof oe;
  }
  var ge = requireDestroy(), Ce = requireState(), le = Ce.getHighWaterMark, Ee = requireErrorsBrowser().codes, Je = Ee.ERR_INVALID_ARG_TYPE, Ve = Ee.ERR_METHOD_NOT_IMPLEMENTED, $t = Ee.ERR_MULTIPLE_CALLBACK, Nt = Ee.ERR_STREAM_CANNOT_PIPE, Dt = Ee.ERR_STREAM_DESTROYED, Wt = Ee.ERR_STREAM_NULL_VALUES, Pt = Ee.ERR_STREAM_WRITE_AFTER_END, Lt = Ee.ERR_UNKNOWN_ENCODING, qt = ge.errorOrDestroy;
  inherits_browserExports(jt, ne);
  function Zt() {
  }
  function Yt(rr, Kt, Gt) {
    z = z || require_stream_duplex$1(), rr = rr || {}, typeof Gt != "boolean" && (Gt = Kt instanceof z), this.objectMode = !!rr.objectMode, Gt && (this.objectMode = this.objectMode || !!rr.writableObjectMode), this.highWaterMark = le(this, rr, "writableHighWaterMark", Gt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ur = rr.decodeStrings === !1;
    this.decodeStrings = !ur, this.defaultEncoding = rr.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(gr) {
      ht(Kt, gr);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = rr.emitClose !== !1, this.autoDestroy = !!rr.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Yt.prototype.getBuffer = function() {
    for (var Kt = this.bufferedRequest, Gt = []; Kt; )
      Gt.push(Kt), Kt = Kt.next;
    return Gt;
  }, function() {
    try {
      Object.defineProperty(Yt.prototype, "buffer", {
        get: Y.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var or;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (or = Function.prototype[Symbol.hasInstance], Object.defineProperty(jt, Symbol.hasInstance, {
    value: function(Kt) {
      return or.call(this, Kt) ? !0 : this !== jt ? !1 : Kt && Kt._writableState instanceof Yt;
    }
  })) : or = function(Kt) {
    return Kt instanceof this;
  };
  function jt(rr) {
    z = z || require_stream_duplex$1();
    var Kt = this instanceof z;
    if (!Kt && !or.call(jt, this)) return new jt(rr);
    this._writableState = new Yt(rr, this, Kt), this.writable = !0, rr && (typeof rr.write == "function" && (this._write = rr.write), typeof rr.writev == "function" && (this._writev = rr.writev), typeof rr.destroy == "function" && (this._destroy = rr.destroy), typeof rr.final == "function" && (this._final = rr.final)), ne.call(this);
  }
  jt.prototype.pipe = function() {
    qt(this, new Nt());
  };
  function Ct(rr, Kt) {
    var Gt = new Pt();
    qt(rr, Gt), process$1.nextTick(Kt, Gt);
  }
  function Vt(rr, Kt, Gt, ur) {
    var gr;
    return Gt === null ? gr = new Wt() : typeof Gt != "string" && !Kt.objectMode && (gr = new Je("chunk", ["string", "Buffer"], Gt)), gr ? (qt(rr, gr), process$1.nextTick(ur, gr), !1) : !0;
  }
  jt.prototype.write = function(rr, Kt, Gt) {
    var ur = this._writableState, gr = !1, Qt = !ur.objectMode && ae(rr);
    return Qt && !ie.isBuffer(rr) && (rr = se(rr)), typeof Kt == "function" && (Gt = Kt, Kt = null), Qt ? Kt = "buffer" : Kt || (Kt = ur.defaultEncoding), typeof Gt != "function" && (Gt = Zt), ur.ending ? Ct(this, Gt) : (Qt || Vt(this, ur, rr, Gt)) && (ur.pendingcb++, gr = Pe(this, ur, Qt, rr, Kt, Gt)), gr;
  }, jt.prototype.cork = function() {
    this._writableState.corked++;
  }, jt.prototype.uncork = function() {
    var rr = this._writableState;
    rr.corked && (rr.corked--, !rr.writing && !rr.corked && !rr.bufferProcessing && rr.bufferedRequest && xt(this, rr));
  }, jt.prototype.setDefaultEncoding = function(Kt) {
    if (typeof Kt == "string" && (Kt = Kt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Kt + "").toLowerCase()) > -1)) throw new Lt(Kt);
    return this._writableState.defaultEncoding = Kt, this;
  }, Object.defineProperty(jt.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function kt(rr, Kt, Gt) {
    return !rr.objectMode && rr.decodeStrings !== !1 && typeof Kt == "string" && (Kt = ie.from(Kt, Gt)), Kt;
  }
  Object.defineProperty(jt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Pe(rr, Kt, Gt, ur, gr, Qt) {
    if (!Gt) {
      var Jt = kt(Kt, ur, gr);
      ur !== Jt && (Gt = !0, gr = "buffer", ur = Jt);
    }
    var br = Kt.objectMode ? 1 : ur.length;
    Kt.length += br;
    var Sr = Kt.length < Kt.highWaterMark;
    if (Sr || (Kt.needDrain = !0), Kt.writing || Kt.corked) {
      var Ar = Kt.lastBufferedRequest;
      Kt.lastBufferedRequest = {
        chunk: ur,
        encoding: gr,
        isBuf: Gt,
        callback: Qt,
        next: null
      }, Ar ? Ar.next = Kt.lastBufferedRequest : Kt.bufferedRequest = Kt.lastBufferedRequest, Kt.bufferedRequestCount += 1;
    } else
      Xe(rr, Kt, !1, br, ur, gr, Qt);
    return Sr;
  }
  function Xe(rr, Kt, Gt, ur, gr, Qt, Jt) {
    Kt.writelen = ur, Kt.writecb = Jt, Kt.writing = !0, Kt.sync = !0, Kt.destroyed ? Kt.onwrite(new Dt("write")) : Gt ? rr._writev(gr, Kt.onwrite) : rr._write(gr, Qt, Kt.onwrite), Kt.sync = !1;
  }
  function ve(rr, Kt, Gt, ur, gr) {
    --Kt.pendingcb, Gt ? (process$1.nextTick(gr, ur), process$1.nextTick(Ht, rr, Kt), rr._writableState.errorEmitted = !0, qt(rr, ur)) : (gr(ur), rr._writableState.errorEmitted = !0, qt(rr, ur), Ht(rr, Kt));
  }
  function Ke(rr) {
    rr.writing = !1, rr.writecb = null, rr.length -= rr.writelen, rr.writelen = 0;
  }
  function ht(rr, Kt) {
    var Gt = rr._writableState, ur = Gt.sync, gr = Gt.writecb;
    if (typeof gr != "function") throw new $t();
    if (Ke(Gt), Kt) ve(rr, Gt, ur, Kt, gr);
    else {
      var Qt = Qe(Gt) || rr.destroyed;
      !Qt && !Gt.corked && !Gt.bufferProcessing && Gt.bufferedRequest && xt(rr, Gt), ur ? process$1.nextTick(wt, rr, Gt, Qt, gr) : wt(rr, Gt, Qt, gr);
    }
  }
  function wt(rr, Kt, Gt, ur) {
    Gt || vt(rr, Kt), Kt.pendingcb--, ur(), Ht(rr, Kt);
  }
  function vt(rr, Kt) {
    Kt.length === 0 && Kt.needDrain && (Kt.needDrain = !1, rr.emit("drain"));
  }
  function xt(rr, Kt) {
    Kt.bufferProcessing = !0;
    var Gt = Kt.bufferedRequest;
    if (rr._writev && Gt && Gt.next) {
      var ur = Kt.bufferedRequestCount, gr = new Array(ur), Qt = Kt.corkedRequestsFree;
      Qt.entry = Gt;
      for (var Jt = 0, br = !0; Gt; )
        gr[Jt] = Gt, Gt.isBuf || (br = !1), Gt = Gt.next, Jt += 1;
      gr.allBuffers = br, Xe(rr, Kt, !0, Kt.length, gr, "", Qt.finish), Kt.pendingcb++, Kt.lastBufferedRequest = null, Qt.next ? (Kt.corkedRequestsFree = Qt.next, Qt.next = null) : Kt.corkedRequestsFree = new B(Kt), Kt.bufferedRequestCount = 0;
    } else {
      for (; Gt; ) {
        var Sr = Gt.chunk, Ar = Gt.encoding, Br = Gt.callback, Mr = Kt.objectMode ? 1 : Sr.length;
        if (Xe(rr, Kt, !1, Mr, Sr, Ar, Br), Gt = Gt.next, Kt.bufferedRequestCount--, Kt.writing)
          break;
      }
      Gt === null && (Kt.lastBufferedRequest = null);
    }
    Kt.bufferedRequest = Gt, Kt.bufferProcessing = !1;
  }
  jt.prototype._write = function(rr, Kt, Gt) {
    Gt(new Ve("_write()"));
  }, jt.prototype._writev = null, jt.prototype.end = function(rr, Kt, Gt) {
    var ur = this._writableState;
    return typeof rr == "function" ? (Gt = rr, rr = null, Kt = null) : typeof Kt == "function" && (Gt = Kt, Kt = null), rr != null && this.write(rr, Kt), ur.corked && (ur.corked = 1, this.uncork()), ur.ending || ar(this, ur, Gt), this;
  }, Object.defineProperty(jt.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function Qe(rr) {
    return rr.ending && rr.length === 0 && rr.bufferedRequest === null && !rr.finished && !rr.writing;
  }
  function Rt(rr, Kt) {
    rr._final(function(Gt) {
      Kt.pendingcb--, Gt && qt(rr, Gt), Kt.prefinished = !0, rr.emit("prefinish"), Ht(rr, Kt);
    });
  }
  function bt(rr, Kt) {
    !Kt.prefinished && !Kt.finalCalled && (typeof rr._final == "function" && !Kt.destroyed ? (Kt.pendingcb++, Kt.finalCalled = !0, process$1.nextTick(Rt, rr, Kt)) : (Kt.prefinished = !0, rr.emit("prefinish")));
  }
  function Ht(rr, Kt) {
    var Gt = Qe(Kt);
    if (Gt && (bt(rr, Kt), Kt.pendingcb === 0 && (Kt.finished = !0, rr.emit("finish"), Kt.autoDestroy))) {
      var ur = rr._readableState;
      (!ur || ur.autoDestroy && ur.endEmitted) && rr.destroy();
    }
    return Gt;
  }
  function ar(rr, Kt, Gt) {
    Kt.ending = !0, Ht(rr, Kt), Gt && (Kt.finished ? process$1.nextTick(Gt) : rr.once("finish", Gt)), Kt.ended = !0, rr.writable = !1;
  }
  function yr(rr, Kt, Gt) {
    var ur = rr.entry;
    for (rr.entry = null; ur; ) {
      var gr = ur.callback;
      Kt.pendingcb--, gr(Gt), ur = ur.next;
    }
    Kt.corkedRequestsFree.next = rr;
  }
  return Object.defineProperty(jt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Kt) {
      this._writableState && (this._writableState.destroyed = Kt);
    }
  }), jt.prototype.destroy = ge.destroy, jt.prototype._undestroy = ge.undestroy, jt.prototype._destroy = function(rr, Kt) {
    Kt(rr);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(Ce) {
    var le = [];
    for (var Ee in Ce) le.push(Ee);
    return le;
  };
  _stream_duplex$1 = se;
  var z = require_stream_readable$1(), Y = require_stream_writable$1();
  inherits_browserExports(se, z);
  for (var ne = B(Y.prototype), ie = 0; ie < ne.length; ie++) {
    var oe = ne[ie];
    se.prototype[oe] || (se.prototype[oe] = Y.prototype[oe]);
  }
  function se(Ce) {
    if (!(this instanceof se)) return new se(Ce);
    z.call(this, Ce), Y.call(this, Ce), this.allowHalfOpen = !0, Ce && (Ce.readable === !1 && (this.readable = !1), Ce.writable === !1 && (this.writable = !1), Ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ae)));
  }
  Object.defineProperty(se.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(se.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(se.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ae() {
    this._writableState.ended || process$1.nextTick(ge, this);
  }
  function ge(Ce) {
    Ce.end();
  }
  return Object.defineProperty(se.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(le) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = le, this._writableState.destroyed = le);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, Buffer$B = safeBufferExports$1.Buffer, isEncoding = Buffer$B.isEncoding || function(B) {
  switch (B = "" + B, B && B.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(B) {
  if (!B) return "utf8";
  for (var z; ; )
    switch (B) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return B;
      default:
        if (z) return;
        B = ("" + B).toLowerCase(), z = !0;
    }
}
function normalizeEncoding(B) {
  var z = _normalizeEncoding(B);
  if (typeof z != "string" && (Buffer$B.isEncoding === isEncoding || !isEncoding(B))) throw new Error("Unknown encoding: " + B);
  return z || B;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(B) {
  this.encoding = normalizeEncoding(B);
  var z;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, z = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, z = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, z = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$B.allocUnsafe(z);
}
StringDecoder$1.prototype.write = function(B) {
  if (B.length === 0) return "";
  var z, Y;
  if (this.lastNeed) {
    if (z = this.fillLast(B), z === void 0) return "";
    Y = this.lastNeed, this.lastNeed = 0;
  } else
    Y = 0;
  return Y < B.length ? z ? z + this.text(B, Y) : this.text(B, Y) : z || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(B) {
  if (this.lastNeed <= B.length)
    return B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  B.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, B.length), this.lastNeed -= B.length;
};
function utf8CheckByte(B) {
  return B <= 127 ? 0 : B >> 5 === 6 ? 2 : B >> 4 === 14 ? 3 : B >> 3 === 30 ? 4 : B >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(B, z, Y) {
  var ne = z.length - 1;
  if (ne < Y) return 0;
  var ie = utf8CheckByte(z[ne]);
  return ie >= 0 ? (ie > 0 && (B.lastNeed = ie - 1), ie) : --ne < Y || ie === -2 ? 0 : (ie = utf8CheckByte(z[ne]), ie >= 0 ? (ie > 0 && (B.lastNeed = ie - 2), ie) : --ne < Y || ie === -2 ? 0 : (ie = utf8CheckByte(z[ne]), ie >= 0 ? (ie > 0 && (ie === 2 ? ie = 0 : B.lastNeed = ie - 3), ie) : 0));
}
function utf8CheckExtraBytes(B, z, Y) {
  if ((z[0] & 192) !== 128)
    return B.lastNeed = 0, "�";
  if (B.lastNeed > 1 && z.length > 1) {
    if ((z[1] & 192) !== 128)
      return B.lastNeed = 1, "�";
    if (B.lastNeed > 2 && z.length > 2 && (z[2] & 192) !== 128)
      return B.lastNeed = 2, "�";
  }
}
function utf8FillLast(B) {
  var z = this.lastTotal - this.lastNeed, Y = utf8CheckExtraBytes(this, B);
  if (Y !== void 0) return Y;
  if (this.lastNeed <= B.length)
    return B.copy(this.lastChar, z, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  B.copy(this.lastChar, z, 0, B.length), this.lastNeed -= B.length;
}
function utf8Text(B, z) {
  var Y = utf8CheckIncomplete(this, B, z);
  if (!this.lastNeed) return B.toString("utf8", z);
  this.lastTotal = Y;
  var ne = B.length - (Y - this.lastNeed);
  return B.copy(this.lastChar, 0, ne), B.toString("utf8", z, ne);
}
function utf8End(B) {
  var z = B && B.length ? this.write(B) : "";
  return this.lastNeed ? z + "�" : z;
}
function utf16Text(B, z) {
  if ((B.length - z) % 2 === 0) {
    var Y = B.toString("utf16le", z);
    if (Y) {
      var ne = Y.charCodeAt(Y.length - 1);
      if (ne >= 55296 && ne <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1], Y.slice(0, -1);
    }
    return Y;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = B[B.length - 1], B.toString("utf16le", z, B.length - 1);
}
function utf16End(B) {
  var z = B && B.length ? this.write(B) : "";
  if (this.lastNeed) {
    var Y = this.lastTotal - this.lastNeed;
    return z + this.lastChar.toString("utf16le", 0, Y);
  }
  return z;
}
function base64Text(B, z) {
  var Y = (B.length - z) % 3;
  return Y === 0 ? B.toString("base64", z) : (this.lastNeed = 3 - Y, this.lastTotal = 3, Y === 1 ? this.lastChar[0] = B[B.length - 1] : (this.lastChar[0] = B[B.length - 2], this.lastChar[1] = B[B.length - 1]), B.toString("base64", z, B.length - Y));
}
function base64End(B) {
  var z = B && B.length ? this.write(B) : "";
  return this.lastNeed ? z + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : z;
}
function simpleWrite(B) {
  return B.toString(this.encoding);
}
function simpleEnd(B) {
  return B && B.length ? this.write(B) : "";
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function z(oe) {
    var se = !1;
    return function() {
      if (!se) {
        se = !0;
        for (var ae = arguments.length, ge = new Array(ae), Ce = 0; Ce < ae; Ce++)
          ge[Ce] = arguments[Ce];
        oe.apply(this, ge);
      }
    };
  }
  function Y() {
  }
  function ne(oe) {
    return oe.setHeader && typeof oe.abort == "function";
  }
  function ie(oe, se, ae) {
    if (typeof se == "function") return ie(oe, null, se);
    se || (se = {}), ae = z(ae || Y);
    var ge = se.readable || se.readable !== !1 && oe.readable, Ce = se.writable || se.writable !== !1 && oe.writable, le = function() {
      oe.writable || Je();
    }, Ee = oe._writableState && oe._writableState.finished, Je = function() {
      Ce = !1, Ee = !0, ge || ae.call(oe);
    }, Ve = oe._readableState && oe._readableState.endEmitted, $t = function() {
      ge = !1, Ve = !0, Ce || ae.call(oe);
    }, Nt = function(Lt) {
      ae.call(oe, Lt);
    }, Dt = function() {
      var Lt;
      if (ge && !Ve)
        return (!oe._readableState || !oe._readableState.ended) && (Lt = new B()), ae.call(oe, Lt);
      if (Ce && !Ee)
        return (!oe._writableState || !oe._writableState.ended) && (Lt = new B()), ae.call(oe, Lt);
    }, Wt = function() {
      oe.req.on("finish", Je);
    };
    return ne(oe) ? (oe.on("complete", Je), oe.on("abort", Dt), oe.req ? Wt() : oe.on("request", Wt)) : Ce && !oe._writableState && (oe.on("end", le), oe.on("close", le)), oe.on("end", $t), oe.on("finish", Je), se.error !== !1 && oe.on("error", Nt), oe.on("close", Dt), function() {
      oe.removeListener("complete", Je), oe.removeListener("abort", Dt), oe.removeListener("request", Wt), oe.req && oe.req.removeListener("finish", Je), oe.removeListener("end", le), oe.removeListener("close", le), oe.removeListener("finish", Je), oe.removeListener("end", $t), oe.removeListener("error", Nt), oe.removeListener("close", Dt);
    };
  }
  return endOfStream = ie, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function z(Lt, qt, Zt) {
    return qt = Y(qt), qt in Lt ? Object.defineProperty(Lt, qt, { value: Zt, enumerable: !0, configurable: !0, writable: !0 }) : Lt[qt] = Zt, Lt;
  }
  function Y(Lt) {
    var qt = ne(Lt, "string");
    return typeof qt == "symbol" ? qt : String(qt);
  }
  function ne(Lt, qt) {
    if (typeof Lt != "object" || Lt === null) return Lt;
    var Zt = Lt[Symbol.toPrimitive];
    if (Zt !== void 0) {
      var Yt = Zt.call(Lt, qt);
      if (typeof Yt != "object") return Yt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (qt === "string" ? String : Number)(Lt);
  }
  var ie = requireEndOfStream(), oe = Symbol("lastResolve"), se = Symbol("lastReject"), ae = Symbol("error"), ge = Symbol("ended"), Ce = Symbol("lastPromise"), le = Symbol("handlePromise"), Ee = Symbol("stream");
  function Je(Lt, qt) {
    return {
      value: Lt,
      done: qt
    };
  }
  function Ve(Lt) {
    var qt = Lt[oe];
    if (qt !== null) {
      var Zt = Lt[Ee].read();
      Zt !== null && (Lt[Ce] = null, Lt[oe] = null, Lt[se] = null, qt(Je(Zt, !1)));
    }
  }
  function $t(Lt) {
    process$1.nextTick(Ve, Lt);
  }
  function Nt(Lt, qt) {
    return function(Zt, Yt) {
      Lt.then(function() {
        if (qt[ge]) {
          Zt(Je(void 0, !0));
          return;
        }
        qt[le](Zt, Yt);
      }, Yt);
    };
  }
  var Dt = Object.getPrototypeOf(function() {
  }), Wt = Object.setPrototypeOf((B = {
    get stream() {
      return this[Ee];
    },
    next: function() {
      var qt = this, Zt = this[ae];
      if (Zt !== null)
        return Promise.reject(Zt);
      if (this[ge])
        return Promise.resolve(Je(void 0, !0));
      if (this[Ee].destroyed)
        return new Promise(function(Ct, Vt) {
          process$1.nextTick(function() {
            qt[ae] ? Vt(qt[ae]) : Ct(Je(void 0, !0));
          });
        });
      var Yt = this[Ce], or;
      if (Yt)
        or = new Promise(Nt(Yt, this));
      else {
        var jt = this[Ee].read();
        if (jt !== null)
          return Promise.resolve(Je(jt, !1));
        or = new Promise(this[le]);
      }
      return this[Ce] = or, or;
    }
  }, z(B, Symbol.asyncIterator, function() {
    return this;
  }), z(B, "return", function() {
    var qt = this;
    return new Promise(function(Zt, Yt) {
      qt[Ee].destroy(null, function(or) {
        if (or) {
          Yt(or);
          return;
        }
        Zt(Je(void 0, !0));
      });
    });
  }), B), Dt), Pt = function(qt) {
    var Zt, Yt = Object.create(Wt, (Zt = {}, z(Zt, Ee, {
      value: qt,
      writable: !0
    }), z(Zt, oe, {
      value: null,
      writable: !0
    }), z(Zt, se, {
      value: null,
      writable: !0
    }), z(Zt, ae, {
      value: null,
      writable: !0
    }), z(Zt, ge, {
      value: qt._readableState.endEmitted,
      writable: !0
    }), z(Zt, le, {
      value: function(jt, Ct) {
        var Vt = Yt[Ee].read();
        Vt ? (Yt[Ce] = null, Yt[oe] = null, Yt[se] = null, jt(Je(Vt, !1))) : (Yt[oe] = jt, Yt[se] = Ct);
      },
      writable: !0
    }), Zt));
    return Yt[Ce] = null, ie(qt, function(or) {
      if (or && or.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var jt = Yt[se];
        jt !== null && (Yt[Ce] = null, Yt[oe] = null, Yt[se] = null, jt(or)), Yt[ae] = or;
        return;
      }
      var Ct = Yt[oe];
      Ct !== null && (Yt[Ce] = null, Yt[oe] = null, Yt[se] = null, Ct(Je(void 0, !0))), Yt[ge] = !0;
    }), qt.on("readable", $t.bind(null, Yt)), Yt;
  };
  return async_iterator = Pt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Ct;
  var B;
  Ct.ReadableState = jt, eventsExports.EventEmitter;
  var z = function(Jt, br) {
    return Jt.listeners(br).length;
  }, Y = requireStreamBrowser(), ne = dist$1.Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function oe(Qt) {
    return ne.from(Qt);
  }
  function se(Qt) {
    return ne.isBuffer(Qt) || Qt instanceof ie;
  }
  var ae = util$3, ge;
  ae && ae.debuglog ? ge = ae.debuglog("stream") : ge = function() {
  };
  var Ce = requireBuffer_list(), le = requireDestroy(), Ee = requireState(), Je = Ee.getHighWaterMark, Ve = requireErrorsBrowser().codes, $t = Ve.ERR_INVALID_ARG_TYPE, Nt = Ve.ERR_STREAM_PUSH_AFTER_EOF, Dt = Ve.ERR_METHOD_NOT_IMPLEMENTED, Wt = Ve.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Pt, Lt, qt;
  inherits_browserExports(Ct, Y);
  var Zt = le.errorOrDestroy, Yt = ["error", "close", "destroy", "pause", "resume"];
  function or(Qt, Jt, br) {
    if (typeof Qt.prependListener == "function") return Qt.prependListener(Jt, br);
    !Qt._events || !Qt._events[Jt] ? Qt.on(Jt, br) : Array.isArray(Qt._events[Jt]) ? Qt._events[Jt].unshift(br) : Qt._events[Jt] = [br, Qt._events[Jt]];
  }
  function jt(Qt, Jt, br) {
    B = B || require_stream_duplex$1(), Qt = Qt || {}, typeof br != "boolean" && (br = Jt instanceof B), this.objectMode = !!Qt.objectMode, br && (this.objectMode = this.objectMode || !!Qt.readableObjectMode), this.highWaterMark = Je(this, Qt, "readableHighWaterMark", br), this.buffer = new Ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Qt.emitClose !== !1, this.autoDestroy = !!Qt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Qt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Qt.encoding && (Pt || (Pt = string_decoder.StringDecoder), this.decoder = new Pt(Qt.encoding), this.encoding = Qt.encoding);
  }
  function Ct(Qt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof Ct)) return new Ct(Qt);
    var Jt = this instanceof B;
    this._readableState = new jt(Qt, this, Jt), this.readable = !0, Qt && (typeof Qt.read == "function" && (this._read = Qt.read), typeof Qt.destroy == "function" && (this._destroy = Qt.destroy)), Y.call(this);
  }
  Object.defineProperty(Ct.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Jt) {
      this._readableState && (this._readableState.destroyed = Jt);
    }
  }), Ct.prototype.destroy = le.destroy, Ct.prototype._undestroy = le.undestroy, Ct.prototype._destroy = function(Qt, Jt) {
    Jt(Qt);
  }, Ct.prototype.push = function(Qt, Jt) {
    var br = this._readableState, Sr;
    return br.objectMode ? Sr = !0 : typeof Qt == "string" && (Jt = Jt || br.defaultEncoding, Jt !== br.encoding && (Qt = ne.from(Qt, Jt), Jt = ""), Sr = !0), Vt(this, Qt, Jt, !1, Sr);
  }, Ct.prototype.unshift = function(Qt) {
    return Vt(this, Qt, null, !0, !1);
  };
  function Vt(Qt, Jt, br, Sr, Ar) {
    ge("readableAddChunk", Jt);
    var Br = Qt._readableState;
    if (Jt === null)
      Br.reading = !1, ht(Qt, Br);
    else {
      var Mr;
      if (Ar || (Mr = Pe(Br, Jt)), Mr)
        Zt(Qt, Mr);
      else if (Br.objectMode || Jt && Jt.length > 0)
        if (typeof Jt != "string" && !Br.objectMode && Object.getPrototypeOf(Jt) !== ne.prototype && (Jt = oe(Jt)), Sr)
          Br.endEmitted ? Zt(Qt, new Wt()) : kt(Qt, Br, Jt, !0);
        else if (Br.ended)
          Zt(Qt, new Nt());
        else {
          if (Br.destroyed)
            return !1;
          Br.reading = !1, Br.decoder && !br ? (Jt = Br.decoder.write(Jt), Br.objectMode || Jt.length !== 0 ? kt(Qt, Br, Jt, !1) : xt(Qt, Br)) : kt(Qt, Br, Jt, !1);
        }
      else Sr || (Br.reading = !1, xt(Qt, Br));
    }
    return !Br.ended && (Br.length < Br.highWaterMark || Br.length === 0);
  }
  function kt(Qt, Jt, br, Sr) {
    Jt.flowing && Jt.length === 0 && !Jt.sync ? (Jt.awaitDrain = 0, Qt.emit("data", br)) : (Jt.length += Jt.objectMode ? 1 : br.length, Sr ? Jt.buffer.unshift(br) : Jt.buffer.push(br), Jt.needReadable && wt(Qt)), xt(Qt, Jt);
  }
  function Pe(Qt, Jt) {
    var br;
    return !se(Jt) && typeof Jt != "string" && Jt !== void 0 && !Qt.objectMode && (br = new $t("chunk", ["string", "Buffer", "Uint8Array"], Jt)), br;
  }
  Ct.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ct.prototype.setEncoding = function(Qt) {
    Pt || (Pt = string_decoder.StringDecoder);
    var Jt = new Pt(Qt);
    this._readableState.decoder = Jt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var br = this._readableState.buffer.head, Sr = ""; br !== null; )
      Sr += Jt.write(br.data), br = br.next;
    return this._readableState.buffer.clear(), Sr !== "" && this._readableState.buffer.push(Sr), this._readableState.length = Sr.length, this;
  };
  var Xe = 1073741824;
  function ve(Qt) {
    return Qt >= Xe ? Qt = Xe : (Qt--, Qt |= Qt >>> 1, Qt |= Qt >>> 2, Qt |= Qt >>> 4, Qt |= Qt >>> 8, Qt |= Qt >>> 16, Qt++), Qt;
  }
  function Ke(Qt, Jt) {
    return Qt <= 0 || Jt.length === 0 && Jt.ended ? 0 : Jt.objectMode ? 1 : Qt !== Qt ? Jt.flowing && Jt.length ? Jt.buffer.head.data.length : Jt.length : (Qt > Jt.highWaterMark && (Jt.highWaterMark = ve(Qt)), Qt <= Jt.length ? Qt : Jt.ended ? Jt.length : (Jt.needReadable = !0, 0));
  }
  Ct.prototype.read = function(Qt) {
    ge("read", Qt), Qt = parseInt(Qt, 10);
    var Jt = this._readableState, br = Qt;
    if (Qt !== 0 && (Jt.emittedReadable = !1), Qt === 0 && Jt.needReadable && ((Jt.highWaterMark !== 0 ? Jt.length >= Jt.highWaterMark : Jt.length > 0) || Jt.ended))
      return ge("read: emitReadable", Jt.length, Jt.ended), Jt.length === 0 && Jt.ended ? Gt(this) : wt(this), null;
    if (Qt = Ke(Qt, Jt), Qt === 0 && Jt.ended)
      return Jt.length === 0 && Gt(this), null;
    var Sr = Jt.needReadable;
    ge("need readable", Sr), (Jt.length === 0 || Jt.length - Qt < Jt.highWaterMark) && (Sr = !0, ge("length less than watermark", Sr)), Jt.ended || Jt.reading ? (Sr = !1, ge("reading or ended", Sr)) : Sr && (ge("do read"), Jt.reading = !0, Jt.sync = !0, Jt.length === 0 && (Jt.needReadable = !0), this._read(Jt.highWaterMark), Jt.sync = !1, Jt.reading || (Qt = Ke(br, Jt)));
    var Ar;
    return Qt > 0 ? Ar = Kt(Qt, Jt) : Ar = null, Ar === null ? (Jt.needReadable = Jt.length <= Jt.highWaterMark, Qt = 0) : (Jt.length -= Qt, Jt.awaitDrain = 0), Jt.length === 0 && (Jt.ended || (Jt.needReadable = !0), br !== Qt && Jt.ended && Gt(this)), Ar !== null && this.emit("data", Ar), Ar;
  };
  function ht(Qt, Jt) {
    if (ge("onEofChunk"), !Jt.ended) {
      if (Jt.decoder) {
        var br = Jt.decoder.end();
        br && br.length && (Jt.buffer.push(br), Jt.length += Jt.objectMode ? 1 : br.length);
      }
      Jt.ended = !0, Jt.sync ? wt(Qt) : (Jt.needReadable = !1, Jt.emittedReadable || (Jt.emittedReadable = !0, vt(Qt)));
    }
  }
  function wt(Qt) {
    var Jt = Qt._readableState;
    ge("emitReadable", Jt.needReadable, Jt.emittedReadable), Jt.needReadable = !1, Jt.emittedReadable || (ge("emitReadable", Jt.flowing), Jt.emittedReadable = !0, process$1.nextTick(vt, Qt));
  }
  function vt(Qt) {
    var Jt = Qt._readableState;
    ge("emitReadable_", Jt.destroyed, Jt.length, Jt.ended), !Jt.destroyed && (Jt.length || Jt.ended) && (Qt.emit("readable"), Jt.emittedReadable = !1), Jt.needReadable = !Jt.flowing && !Jt.ended && Jt.length <= Jt.highWaterMark, rr(Qt);
  }
  function xt(Qt, Jt) {
    Jt.readingMore || (Jt.readingMore = !0, process$1.nextTick(Qe, Qt, Jt));
  }
  function Qe(Qt, Jt) {
    for (; !Jt.reading && !Jt.ended && (Jt.length < Jt.highWaterMark || Jt.flowing && Jt.length === 0); ) {
      var br = Jt.length;
      if (ge("maybeReadMore read 0"), Qt.read(0), br === Jt.length)
        break;
    }
    Jt.readingMore = !1;
  }
  Ct.prototype._read = function(Qt) {
    Zt(this, new Dt("_read()"));
  }, Ct.prototype.pipe = function(Qt, Jt) {
    var br = this, Sr = this._readableState;
    switch (Sr.pipesCount) {
      case 0:
        Sr.pipes = Qt;
        break;
      case 1:
        Sr.pipes = [Sr.pipes, Qt];
        break;
      default:
        Sr.pipes.push(Qt);
        break;
    }
    Sr.pipesCount += 1, ge("pipe count=%d opts=%j", Sr.pipesCount, Jt);
    var Ar = (!Jt || Jt.end !== !1) && Qt !== process$1.stdout && Qt !== process$1.stderr, Br = Ar ? Cr : Zr;
    Sr.endEmitted ? process$1.nextTick(Br) : br.once("end", Br), Qt.on("unpipe", Mr);
    function Mr(Lr, Yr) {
      ge("onunpipe"), Lr === br && Yr && Yr.hasUnpiped === !1 && (Yr.hasUnpiped = !0, jr());
    }
    function Cr() {
      ge("onend"), Qt.end();
    }
    var $r = Rt(br);
    Qt.on("drain", $r);
    var Qr = !1;
    function jr() {
      ge("cleanup"), Qt.removeListener("close", Or), Qt.removeListener("finish", Vr), Qt.removeListener("drain", $r), Qt.removeListener("error", Gr), Qt.removeListener("unpipe", Mr), br.removeListener("end", Cr), br.removeListener("end", Zr), br.removeListener("data", qr), Qr = !0, Sr.awaitDrain && (!Qt._writableState || Qt._writableState.needDrain) && $r();
    }
    br.on("data", qr);
    function qr(Lr) {
      ge("ondata");
      var Yr = Qt.write(Lr);
      ge("dest.write", Yr), Yr === !1 && ((Sr.pipesCount === 1 && Sr.pipes === Qt || Sr.pipesCount > 1 && gr(Sr.pipes, Qt) !== -1) && !Qr && (ge("false write response, pause", Sr.awaitDrain), Sr.awaitDrain++), br.pause());
    }
    function Gr(Lr) {
      ge("onerror", Lr), Zr(), Qt.removeListener("error", Gr), z(Qt, "error") === 0 && Zt(Qt, Lr);
    }
    or(Qt, "error", Gr);
    function Or() {
      Qt.removeListener("finish", Vr), Zr();
    }
    Qt.once("close", Or);
    function Vr() {
      ge("onfinish"), Qt.removeListener("close", Or), Zr();
    }
    Qt.once("finish", Vr);
    function Zr() {
      ge("unpipe"), br.unpipe(Qt);
    }
    return Qt.emit("pipe", br), Sr.flowing || (ge("pipe resume"), br.resume()), Qt;
  };
  function Rt(Qt) {
    return function() {
      var br = Qt._readableState;
      ge("pipeOnDrain", br.awaitDrain), br.awaitDrain && br.awaitDrain--, br.awaitDrain === 0 && z(Qt, "data") && (br.flowing = !0, rr(Qt));
    };
  }
  Ct.prototype.unpipe = function(Qt) {
    var Jt = this._readableState, br = {
      hasUnpiped: !1
    };
    if (Jt.pipesCount === 0) return this;
    if (Jt.pipesCount === 1)
      return Qt && Qt !== Jt.pipes ? this : (Qt || (Qt = Jt.pipes), Jt.pipes = null, Jt.pipesCount = 0, Jt.flowing = !1, Qt && Qt.emit("unpipe", this, br), this);
    if (!Qt) {
      var Sr = Jt.pipes, Ar = Jt.pipesCount;
      Jt.pipes = null, Jt.pipesCount = 0, Jt.flowing = !1;
      for (var Br = 0; Br < Ar; Br++) Sr[Br].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Mr = gr(Jt.pipes, Qt);
    return Mr === -1 ? this : (Jt.pipes.splice(Mr, 1), Jt.pipesCount -= 1, Jt.pipesCount === 1 && (Jt.pipes = Jt.pipes[0]), Qt.emit("unpipe", this, br), this);
  }, Ct.prototype.on = function(Qt, Jt) {
    var br = Y.prototype.on.call(this, Qt, Jt), Sr = this._readableState;
    return Qt === "data" ? (Sr.readableListening = this.listenerCount("readable") > 0, Sr.flowing !== !1 && this.resume()) : Qt === "readable" && !Sr.endEmitted && !Sr.readableListening && (Sr.readableListening = Sr.needReadable = !0, Sr.flowing = !1, Sr.emittedReadable = !1, ge("on readable", Sr.length, Sr.reading), Sr.length ? wt(this) : Sr.reading || process$1.nextTick(Ht, this)), br;
  }, Ct.prototype.addListener = Ct.prototype.on, Ct.prototype.removeListener = function(Qt, Jt) {
    var br = Y.prototype.removeListener.call(this, Qt, Jt);
    return Qt === "readable" && process$1.nextTick(bt, this), br;
  }, Ct.prototype.removeAllListeners = function(Qt) {
    var Jt = Y.prototype.removeAllListeners.apply(this, arguments);
    return (Qt === "readable" || Qt === void 0) && process$1.nextTick(bt, this), Jt;
  };
  function bt(Qt) {
    var Jt = Qt._readableState;
    Jt.readableListening = Qt.listenerCount("readable") > 0, Jt.resumeScheduled && !Jt.paused ? Jt.flowing = !0 : Qt.listenerCount("data") > 0 && Qt.resume();
  }
  function Ht(Qt) {
    ge("readable nexttick read 0"), Qt.read(0);
  }
  Ct.prototype.resume = function() {
    var Qt = this._readableState;
    return Qt.flowing || (ge("resume"), Qt.flowing = !Qt.readableListening, ar(this, Qt)), Qt.paused = !1, this;
  };
  function ar(Qt, Jt) {
    Jt.resumeScheduled || (Jt.resumeScheduled = !0, process$1.nextTick(yr, Qt, Jt));
  }
  function yr(Qt, Jt) {
    ge("resume", Jt.reading), Jt.reading || Qt.read(0), Jt.resumeScheduled = !1, Qt.emit("resume"), rr(Qt), Jt.flowing && !Jt.reading && Qt.read(0);
  }
  Ct.prototype.pause = function() {
    return ge("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ge("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function rr(Qt) {
    var Jt = Qt._readableState;
    for (ge("flow", Jt.flowing); Jt.flowing && Qt.read() !== null; ) ;
  }
  Ct.prototype.wrap = function(Qt) {
    var Jt = this, br = this._readableState, Sr = !1;
    Qt.on("end", function() {
      if (ge("wrapped end"), br.decoder && !br.ended) {
        var Mr = br.decoder.end();
        Mr && Mr.length && Jt.push(Mr);
      }
      Jt.push(null);
    }), Qt.on("data", function(Mr) {
      if (ge("wrapped data"), br.decoder && (Mr = br.decoder.write(Mr)), !(br.objectMode && Mr == null) && !(!br.objectMode && (!Mr || !Mr.length))) {
        var Cr = Jt.push(Mr);
        Cr || (Sr = !0, Qt.pause());
      }
    });
    for (var Ar in Qt)
      this[Ar] === void 0 && typeof Qt[Ar] == "function" && (this[Ar] = /* @__PURE__ */ function(Cr) {
        return function() {
          return Qt[Cr].apply(Qt, arguments);
        };
      }(Ar));
    for (var Br = 0; Br < Yt.length; Br++)
      Qt.on(Yt[Br], this.emit.bind(this, Yt[Br]));
    return this._read = function(Mr) {
      ge("wrapped _read", Mr), Sr && (Sr = !1, Qt.resume());
    }, this;
  }, typeof Symbol == "function" && (Ct.prototype[Symbol.asyncIterator] = function() {
    return Lt === void 0 && (Lt = requireAsync_iterator()), Lt(this);
  }), Object.defineProperty(Ct.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Ct.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Ct.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Jt) {
      this._readableState && (this._readableState.flowing = Jt);
    }
  }), Ct._fromList = Kt, Object.defineProperty(Ct.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Kt(Qt, Jt) {
    if (Jt.length === 0) return null;
    var br;
    return Jt.objectMode ? br = Jt.buffer.shift() : !Qt || Qt >= Jt.length ? (Jt.decoder ? br = Jt.buffer.join("") : Jt.buffer.length === 1 ? br = Jt.buffer.first() : br = Jt.buffer.concat(Jt.length), Jt.buffer.clear()) : br = Jt.buffer.consume(Qt, Jt.decoder), br;
  }
  function Gt(Qt) {
    var Jt = Qt._readableState;
    ge("endReadable", Jt.endEmitted), Jt.endEmitted || (Jt.ended = !0, process$1.nextTick(ur, Jt, Qt));
  }
  function ur(Qt, Jt) {
    if (ge("endReadableNT", Qt.endEmitted, Qt.length), !Qt.endEmitted && Qt.length === 0 && (Qt.endEmitted = !0, Jt.readable = !1, Jt.emit("end"), Qt.autoDestroy)) {
      var br = Jt._writableState;
      (!br || br.autoDestroy && br.finished) && Jt.destroy();
    }
  }
  typeof Symbol == "function" && (Ct.from = function(Qt, Jt) {
    return qt === void 0 && (qt = requireFromBrowser()), qt(Ct, Qt, Jt);
  });
  function gr(Qt, Jt) {
    for (var br = 0, Sr = Qt.length; br < Sr; br++)
      if (Qt[br] === Jt) return br;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = ae;
  var B = requireErrorsBrowser().codes, z = B.ERR_METHOD_NOT_IMPLEMENTED, Y = B.ERR_MULTIPLE_CALLBACK, ne = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, ie = B.ERR_TRANSFORM_WITH_LENGTH_0, oe = require_stream_duplex$1();
  inherits_browserExports(ae, oe);
  function se(le, Ee) {
    var Je = this._transformState;
    Je.transforming = !1;
    var Ve = Je.writecb;
    if (Ve === null)
      return this.emit("error", new Y());
    Je.writechunk = null, Je.writecb = null, Ee != null && this.push(Ee), Ve(le);
    var $t = this._readableState;
    $t.reading = !1, ($t.needReadable || $t.length < $t.highWaterMark) && this._read($t.highWaterMark);
  }
  function ae(le) {
    if (!(this instanceof ae)) return new ae(le);
    oe.call(this, le), this._transformState = {
      afterTransform: se.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, le && (typeof le.transform == "function" && (this._transform = le.transform), typeof le.flush == "function" && (this._flush = le.flush)), this.on("prefinish", ge);
  }
  function ge() {
    var le = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Ee, Je) {
      Ce(le, Ee, Je);
    }) : Ce(this, null, null);
  }
  ae.prototype.push = function(le, Ee) {
    return this._transformState.needTransform = !1, oe.prototype.push.call(this, le, Ee);
  }, ae.prototype._transform = function(le, Ee, Je) {
    Je(new z("_transform()"));
  }, ae.prototype._write = function(le, Ee, Je) {
    var Ve = this._transformState;
    if (Ve.writecb = Je, Ve.writechunk = le, Ve.writeencoding = Ee, !Ve.transforming) {
      var $t = this._readableState;
      (Ve.needTransform || $t.needReadable || $t.length < $t.highWaterMark) && this._read($t.highWaterMark);
    }
  }, ae.prototype._read = function(le) {
    var Ee = this._transformState;
    Ee.writechunk !== null && !Ee.transforming ? (Ee.transforming = !0, this._transform(Ee.writechunk, Ee.writeencoding, Ee.afterTransform)) : Ee.needTransform = !0;
  }, ae.prototype._destroy = function(le, Ee) {
    oe.prototype._destroy.call(this, le, function(Je) {
      Ee(Je);
    });
  };
  function Ce(le, Ee, Je) {
    if (Ee) return le.emit("error", Ee);
    if (Je != null && le.push(Je), le._writableState.length) throw new ie();
    if (le._transformState.transforming) throw new ne();
    return le.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough$1;
  hasRequired_stream_passthrough = 1, _stream_passthrough$1 = z;
  var B = require_stream_transform();
  inherits_browserExports(z, B);
  function z(Y) {
    if (!(this instanceof z)) return new z(Y);
    B.call(this, Y);
  }
  return z.prototype._transform = function(Y, ne, ie) {
    ie(null, Y);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var B;
  function z(Je) {
    var Ve = !1;
    return function() {
      Ve || (Ve = !0, Je.apply(void 0, arguments));
    };
  }
  var Y = requireErrorsBrowser().codes, ne = Y.ERR_MISSING_ARGS, ie = Y.ERR_STREAM_DESTROYED;
  function oe(Je) {
    if (Je) throw Je;
  }
  function se(Je) {
    return Je.setHeader && typeof Je.abort == "function";
  }
  function ae(Je, Ve, $t, Nt) {
    Nt = z(Nt);
    var Dt = !1;
    Je.on("close", function() {
      Dt = !0;
    }), B === void 0 && (B = requireEndOfStream()), B(Je, {
      readable: Ve,
      writable: $t
    }, function(Pt) {
      if (Pt) return Nt(Pt);
      Dt = !0, Nt();
    });
    var Wt = !1;
    return function(Pt) {
      if (!Dt && !Wt) {
        if (Wt = !0, se(Je)) return Je.abort();
        if (typeof Je.destroy == "function") return Je.destroy();
        Nt(Pt || new ie("pipe"));
      }
    };
  }
  function ge(Je) {
    Je();
  }
  function Ce(Je, Ve) {
    return Je.pipe(Ve);
  }
  function le(Je) {
    return !Je.length || typeof Je[Je.length - 1] != "function" ? oe : Je.pop();
  }
  function Ee() {
    for (var Je = arguments.length, Ve = new Array(Je), $t = 0; $t < Je; $t++)
      Ve[$t] = arguments[$t];
    var Nt = le(Ve);
    if (Array.isArray(Ve[0]) && (Ve = Ve[0]), Ve.length < 2)
      throw new ne("streams");
    var Dt, Wt = Ve.map(function(Pt, Lt) {
      var qt = Lt < Ve.length - 1, Zt = Lt > 0;
      return ae(Pt, qt, Zt, function(Yt) {
        Dt || (Dt = Yt), Yt && Wt.forEach(ge), !qt && (Wt.forEach(ge), Nt(Dt));
      });
    });
    return Ve.reduce(Ce);
  }
  return pipeline_1 = Ee, pipeline_1;
}
(function(B, z) {
  z = B.exports = require_stream_readable$1(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable$1(), z.Duplex = require_stream_duplex$1(), z.Transform = require_stream_transform(), z.PassThrough = require_stream_passthrough(), z.finished = requireEndOfStream(), z.pipeline = requirePipeline();
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$A = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$q = inherits_browserExports;
function throwIfNotStringOrBuffer(B, z) {
  if (!Buffer$A.isBuffer(B) && typeof B != "string")
    throw new TypeError(z + " must be a string or a buffer");
}
function HashBase$2(B) {
  Transform$7.call(this), this._block = Buffer$A.allocUnsafe(B), this._blockSize = B, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$q(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(B, z, Y) {
  var ne = null;
  try {
    this.update(B, z);
  } catch (ie) {
    ne = ie;
  }
  Y(ne);
};
HashBase$2.prototype._flush = function(B) {
  var z = null;
  try {
    this.push(this.digest());
  } catch (Y) {
    z = Y;
  }
  B(z);
};
HashBase$2.prototype.update = function(B, z) {
  if (throwIfNotStringOrBuffer(B, "Data"), this._finalized) throw new Error("Digest already called");
  Buffer$A.isBuffer(B) || (B = Buffer$A.from(B, z));
  for (var Y = this._block, ne = 0; this._blockOffset + B.length - ne >= this._blockSize; ) {
    for (var ie = this._blockOffset; ie < this._blockSize; ) Y[ie++] = B[ne++];
    this._update(), this._blockOffset = 0;
  }
  for (; ne < B.length; ) Y[this._blockOffset++] = B[ne++];
  for (var oe = 0, se = B.length * 8; se > 0; ++oe)
    this._length[oe] += se, se = this._length[oe] / 4294967296 | 0, se > 0 && (this._length[oe] -= 4294967296 * se);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(B) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var z = this._digest();
  B !== void 0 && (z = z.toString(B)), this._block.fill(0), this._blockOffset = 0;
  for (var Y = 0; Y < 4; ++Y) this._length[Y] = 0;
  return z;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$p = inherits_browserExports, HashBase$1 = hashBase, Buffer$z = safeBufferExports$1.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$p(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var B = ARRAY16$1, z = 0; z < 16; ++z) B[z] = this._block.readInt32LE(z * 4);
  var Y = this._a, ne = this._b, ie = this._c, oe = this._d;
  Y = fnF(Y, ne, ie, oe, B[0], 3614090360, 7), oe = fnF(oe, Y, ne, ie, B[1], 3905402710, 12), ie = fnF(ie, oe, Y, ne, B[2], 606105819, 17), ne = fnF(ne, ie, oe, Y, B[3], 3250441966, 22), Y = fnF(Y, ne, ie, oe, B[4], 4118548399, 7), oe = fnF(oe, Y, ne, ie, B[5], 1200080426, 12), ie = fnF(ie, oe, Y, ne, B[6], 2821735955, 17), ne = fnF(ne, ie, oe, Y, B[7], 4249261313, 22), Y = fnF(Y, ne, ie, oe, B[8], 1770035416, 7), oe = fnF(oe, Y, ne, ie, B[9], 2336552879, 12), ie = fnF(ie, oe, Y, ne, B[10], 4294925233, 17), ne = fnF(ne, ie, oe, Y, B[11], 2304563134, 22), Y = fnF(Y, ne, ie, oe, B[12], 1804603682, 7), oe = fnF(oe, Y, ne, ie, B[13], 4254626195, 12), ie = fnF(ie, oe, Y, ne, B[14], 2792965006, 17), ne = fnF(ne, ie, oe, Y, B[15], 1236535329, 22), Y = fnG(Y, ne, ie, oe, B[1], 4129170786, 5), oe = fnG(oe, Y, ne, ie, B[6], 3225465664, 9), ie = fnG(ie, oe, Y, ne, B[11], 643717713, 14), ne = fnG(ne, ie, oe, Y, B[0], 3921069994, 20), Y = fnG(Y, ne, ie, oe, B[5], 3593408605, 5), oe = fnG(oe, Y, ne, ie, B[10], 38016083, 9), ie = fnG(ie, oe, Y, ne, B[15], 3634488961, 14), ne = fnG(ne, ie, oe, Y, B[4], 3889429448, 20), Y = fnG(Y, ne, ie, oe, B[9], 568446438, 5), oe = fnG(oe, Y, ne, ie, B[14], 3275163606, 9), ie = fnG(ie, oe, Y, ne, B[3], 4107603335, 14), ne = fnG(ne, ie, oe, Y, B[8], 1163531501, 20), Y = fnG(Y, ne, ie, oe, B[13], 2850285829, 5), oe = fnG(oe, Y, ne, ie, B[2], 4243563512, 9), ie = fnG(ie, oe, Y, ne, B[7], 1735328473, 14), ne = fnG(ne, ie, oe, Y, B[12], 2368359562, 20), Y = fnH(Y, ne, ie, oe, B[5], 4294588738, 4), oe = fnH(oe, Y, ne, ie, B[8], 2272392833, 11), ie = fnH(ie, oe, Y, ne, B[11], 1839030562, 16), ne = fnH(ne, ie, oe, Y, B[14], 4259657740, 23), Y = fnH(Y, ne, ie, oe, B[1], 2763975236, 4), oe = fnH(oe, Y, ne, ie, B[4], 1272893353, 11), ie = fnH(ie, oe, Y, ne, B[7], 4139469664, 16), ne = fnH(ne, ie, oe, Y, B[10], 3200236656, 23), Y = fnH(Y, ne, ie, oe, B[13], 681279174, 4), oe = fnH(oe, Y, ne, ie, B[0], 3936430074, 11), ie = fnH(ie, oe, Y, ne, B[3], 3572445317, 16), ne = fnH(ne, ie, oe, Y, B[6], 76029189, 23), Y = fnH(Y, ne, ie, oe, B[9], 3654602809, 4), oe = fnH(oe, Y, ne, ie, B[12], 3873151461, 11), ie = fnH(ie, oe, Y, ne, B[15], 530742520, 16), ne = fnH(ne, ie, oe, Y, B[2], 3299628645, 23), Y = fnI(Y, ne, ie, oe, B[0], 4096336452, 6), oe = fnI(oe, Y, ne, ie, B[7], 1126891415, 10), ie = fnI(ie, oe, Y, ne, B[14], 2878612391, 15), ne = fnI(ne, ie, oe, Y, B[5], 4237533241, 21), Y = fnI(Y, ne, ie, oe, B[12], 1700485571, 6), oe = fnI(oe, Y, ne, ie, B[3], 2399980690, 10), ie = fnI(ie, oe, Y, ne, B[10], 4293915773, 15), ne = fnI(ne, ie, oe, Y, B[1], 2240044497, 21), Y = fnI(Y, ne, ie, oe, B[8], 1873313359, 6), oe = fnI(oe, Y, ne, ie, B[15], 4264355552, 10), ie = fnI(ie, oe, Y, ne, B[6], 2734768916, 15), ne = fnI(ne, ie, oe, Y, B[13], 1309151649, 21), Y = fnI(Y, ne, ie, oe, B[4], 4149444226, 6), oe = fnI(oe, Y, ne, ie, B[11], 3174756917, 10), ie = fnI(ie, oe, Y, ne, B[2], 718787259, 15), ne = fnI(ne, ie, oe, Y, B[9], 3951481745, 21), this._a = this._a + Y | 0, this._b = this._b + ne | 0, this._c = this._c + ie | 0, this._d = this._d + oe | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var B = Buffer$z.allocUnsafe(16);
  return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B;
};
function rotl$1(B, z) {
  return B << z | B >>> 32 - z;
}
function fnF(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (z & Y | ~z & ne) + ie + oe | 0, se) + z | 0;
}
function fnG(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (z & ne | Y & ~ne) + ie + oe | 0, se) + z | 0;
}
function fnH(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (z ^ Y ^ ne) + ie + oe | 0, se) + z | 0;
}
function fnI(B, z, Y, ne, ie, oe, se) {
  return rotl$1(B + (Y ^ (z | ~ne)) + ie + oe | 0, se) + z | 0;
}
var md5_js = MD5$3, Buffer$y = dist$1.Buffer, inherits$o = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$5() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$o(RIPEMD160$5, HashBase);
RIPEMD160$5.prototype._update = function() {
  for (var B = ARRAY16, z = 0; z < 16; ++z) B[z] = this._block.readInt32LE(z * 4);
  for (var Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = this._a | 0, ge = this._b | 0, Ce = this._c | 0, le = this._d | 0, Ee = this._e | 0, Je = 0; Je < 80; Je += 1) {
    var Ve, $t;
    Je < 16 ? (Ve = fn1(Y, ne, ie, oe, se, B[zl[Je]], hl[0], sl[Je]), $t = fn5(ae, ge, Ce, le, Ee, B[zr[Je]], hr[0], sr[Je])) : Je < 32 ? (Ve = fn2(Y, ne, ie, oe, se, B[zl[Je]], hl[1], sl[Je]), $t = fn4(ae, ge, Ce, le, Ee, B[zr[Je]], hr[1], sr[Je])) : Je < 48 ? (Ve = fn3(Y, ne, ie, oe, se, B[zl[Je]], hl[2], sl[Je]), $t = fn3(ae, ge, Ce, le, Ee, B[zr[Je]], hr[2], sr[Je])) : Je < 64 ? (Ve = fn4(Y, ne, ie, oe, se, B[zl[Je]], hl[3], sl[Je]), $t = fn2(ae, ge, Ce, le, Ee, B[zr[Je]], hr[3], sr[Je])) : (Ve = fn5(Y, ne, ie, oe, se, B[zl[Je]], hl[4], sl[Je]), $t = fn1(ae, ge, Ce, le, Ee, B[zr[Je]], hr[4], sr[Je])), Y = se, se = oe, oe = rotl(ie, 10), ie = ne, ne = Ve, ae = Ee, Ee = le, le = rotl(Ce, 10), Ce = ge, ge = $t;
  }
  var Nt = this._b + ie + le | 0;
  this._b = this._c + oe + Ee | 0, this._c = this._d + se + ae | 0, this._d = this._e + Y + ge | 0, this._e = this._a + ne + Ce | 0, this._a = Nt;
};
RIPEMD160$5.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var B = Buffer$y.alloc ? Buffer$y.alloc(20) : new Buffer$y(20);
  return B.writeInt32LE(this._a, 0), B.writeInt32LE(this._b, 4), B.writeInt32LE(this._c, 8), B.writeInt32LE(this._d, 12), B.writeInt32LE(this._e, 16), B;
};
function rotl(B, z) {
  return B << z | B >>> 32 - z;
}
function fn1(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z ^ Y ^ ne) + oe + se | 0, ae) + ie | 0;
}
function fn2(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z & Y | ~z & ne) + oe + se | 0, ae) + ie | 0;
}
function fn3(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + ((z | ~Y) ^ ne) + oe + se | 0, ae) + ie | 0;
}
function fn4(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z & ne | Y & ~ne) + oe + se | 0, ae) + ie | 0;
}
function fn5(B, z, Y, ne, ie, oe, se, ae) {
  return rotl(B + (z ^ (Y | ~ne)) + oe + se | 0, ae) + ie | 0;
}
var ripemd160$1 = RIPEMD160$5, sha_js = { exports: {} }, Buffer$x = safeBufferExports$1.Buffer;
function Hash$7(B, z) {
  this._block = Buffer$x.alloc(B), this._finalSize = z, this._blockSize = B, this._len = 0;
}
Hash$7.prototype.update = function(B, z) {
  typeof B == "string" && (z = z || "utf8", B = Buffer$x.from(B, z));
  for (var Y = this._block, ne = this._blockSize, ie = B.length, oe = this._len, se = 0; se < ie; ) {
    for (var ae = oe % ne, ge = Math.min(ie - se, ne - ae), Ce = 0; Ce < ge; Ce++)
      Y[ae + Ce] = B[se + Ce];
    oe += ge, se += ge, oe % ne === 0 && this._update(Y);
  }
  return this._len += ie, this;
};
Hash$7.prototype.digest = function(B) {
  var z = this._len % this._blockSize;
  this._block[z] = 128, this._block.fill(0, z + 1), z >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var Y = this._len * 8;
  if (Y <= 4294967295)
    this._block.writeUInt32BE(Y, this._blockSize - 4);
  else {
    var ne = (Y & 4294967295) >>> 0, ie = (Y - ne) / 4294967296;
    this._block.writeUInt32BE(ie, this._blockSize - 8), this._block.writeUInt32BE(ne, this._blockSize - 4);
  }
  this._update(this._block);
  var oe = this._hash();
  return B ? oe.toString(B) : oe;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$n = inherits_browserExports, Hash$6 = hash$3, Buffer$w = safeBufferExports$1.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$n(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(B) {
  return B << 5 | B >>> 27;
}
function rotl30$1(B) {
  return B << 30 | B >>> 2;
}
function ft$1(B, z, Y, ne) {
  return B === 0 ? z & Y | ~z & ne : B === 2 ? z & Y | z & ne | Y & ne : z ^ Y ^ ne;
}
Sha.prototype._update = function(B) {
  for (var z = this._w, Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = 0; ae < 16; ++ae) z[ae] = B.readInt32BE(ae * 4);
  for (; ae < 80; ++ae) z[ae] = z[ae - 3] ^ z[ae - 8] ^ z[ae - 14] ^ z[ae - 16];
  for (var ge = 0; ge < 80; ++ge) {
    var Ce = ~~(ge / 20), le = rotl5$1(Y) + ft$1(Ce, ne, ie, oe) + se + z[ge] + K$4[Ce] | 0;
    se = oe, oe = ie, ie = rotl30$1(ne), ne = Y, Y = le;
  }
  this._a = Y + this._a | 0, this._b = ne + this._b | 0, this._c = ie + this._c | 0, this._d = oe + this._d | 0, this._e = se + this._e | 0;
};
Sha.prototype._hash = function() {
  var B = Buffer$w.allocUnsafe(20);
  return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
};
var sha$4 = Sha, inherits$m = inherits_browserExports, Hash$5 = hash$3, Buffer$v = safeBufferExports$1.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$m(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(B) {
  return B << 1 | B >>> 31;
}
function rotl5(B) {
  return B << 5 | B >>> 27;
}
function rotl30(B) {
  return B << 30 | B >>> 2;
}
function ft(B, z, Y, ne) {
  return B === 0 ? z & Y | ~z & ne : B === 2 ? z & Y | z & ne | Y & ne : z ^ Y ^ ne;
}
Sha1.prototype._update = function(B) {
  for (var z = this._w, Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = 0; ae < 16; ++ae) z[ae] = B.readInt32BE(ae * 4);
  for (; ae < 80; ++ae) z[ae] = rotl1(z[ae - 3] ^ z[ae - 8] ^ z[ae - 14] ^ z[ae - 16]);
  for (var ge = 0; ge < 80; ++ge) {
    var Ce = ~~(ge / 20), le = rotl5(Y) + ft(Ce, ne, ie, oe) + se + z[ge] + K$3[Ce] | 0;
    se = oe, oe = ie, ie = rotl30(ne), ne = Y, Y = le;
  }
  this._a = Y + this._a | 0, this._b = ne + this._b | 0, this._c = ie + this._c | 0, this._d = oe + this._d | 0, this._e = se + this._e | 0;
};
Sha1.prototype._hash = function() {
  var B = Buffer$v.allocUnsafe(20);
  return B.writeInt32BE(this._a | 0, 0), B.writeInt32BE(this._b | 0, 4), B.writeInt32BE(this._c | 0, 8), B.writeInt32BE(this._d | 0, 12), B.writeInt32BE(this._e | 0, 16), B;
};
var sha1$1 = Sha1, inherits$l = inherits_browserExports, Hash$4 = hash$3, Buffer$u = safeBufferExports$1.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$l(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(B, z, Y) {
  return Y ^ B & (z ^ Y);
}
function maj$1(B, z, Y) {
  return B & z | Y & (B | z);
}
function sigma0$1(B) {
  return (B >>> 2 | B << 30) ^ (B >>> 13 | B << 19) ^ (B >>> 22 | B << 10);
}
function sigma1$1(B) {
  return (B >>> 6 | B << 26) ^ (B >>> 11 | B << 21) ^ (B >>> 25 | B << 7);
}
function gamma0(B) {
  return (B >>> 7 | B << 25) ^ (B >>> 18 | B << 14) ^ B >>> 3;
}
function gamma1(B) {
  return (B >>> 17 | B << 15) ^ (B >>> 19 | B << 13) ^ B >>> 10;
}
Sha256$1.prototype._update = function(B) {
  for (var z = this._w, Y = this._a | 0, ne = this._b | 0, ie = this._c | 0, oe = this._d | 0, se = this._e | 0, ae = this._f | 0, ge = this._g | 0, Ce = this._h | 0, le = 0; le < 16; ++le) z[le] = B.readInt32BE(le * 4);
  for (; le < 64; ++le) z[le] = gamma1(z[le - 2]) + z[le - 7] + gamma0(z[le - 15]) + z[le - 16] | 0;
  for (var Ee = 0; Ee < 64; ++Ee) {
    var Je = Ce + sigma1$1(se) + ch(se, ae, ge) + K$2[Ee] + z[Ee] | 0, Ve = sigma0$1(Y) + maj$1(Y, ne, ie) | 0;
    Ce = ge, ge = ae, ae = se, se = oe + Je | 0, oe = ie, ie = ne, ne = Y, Y = Je + Ve | 0;
  }
  this._a = Y + this._a | 0, this._b = ne + this._b | 0, this._c = ie + this._c | 0, this._d = oe + this._d | 0, this._e = se + this._e | 0, this._f = ae + this._f | 0, this._g = ge + this._g | 0, this._h = Ce + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var B = Buffer$u.allocUnsafe(32);
  return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B.writeInt32BE(this._h, 28), B;
};
var sha256$3 = Sha256$1, inherits$k = inherits_browserExports, Sha256 = sha256$3, Hash$3 = hash$3, Buffer$t = safeBufferExports$1.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$k(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var B = Buffer$t.allocUnsafe(28);
  return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B;
};
var sha224$1 = Sha224, inherits$j = inherits_browserExports, Hash$2 = hash$3, Buffer$s = safeBufferExports$1.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$j(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(B, z, Y) {
  return Y ^ B & (z ^ Y);
}
function maj(B, z, Y) {
  return B & z | Y & (B | z);
}
function sigma0(B, z) {
  return (B >>> 28 | z << 4) ^ (z >>> 2 | B << 30) ^ (z >>> 7 | B << 25);
}
function sigma1(B, z) {
  return (B >>> 14 | z << 18) ^ (B >>> 18 | z << 14) ^ (z >>> 9 | B << 23);
}
function Gamma0(B, z) {
  return (B >>> 1 | z << 31) ^ (B >>> 8 | z << 24) ^ B >>> 7;
}
function Gamma0l(B, z) {
  return (B >>> 1 | z << 31) ^ (B >>> 8 | z << 24) ^ (B >>> 7 | z << 25);
}
function Gamma1(B, z) {
  return (B >>> 19 | z << 13) ^ (z >>> 29 | B << 3) ^ B >>> 6;
}
function Gamma1l(B, z) {
  return (B >>> 19 | z << 13) ^ (z >>> 29 | B << 3) ^ (B >>> 6 | z << 26);
}
function getCarry(B, z) {
  return B >>> 0 < z >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(B) {
  for (var z = this._w, Y = this._ah | 0, ne = this._bh | 0, ie = this._ch | 0, oe = this._dh | 0, se = this._eh | 0, ae = this._fh | 0, ge = this._gh | 0, Ce = this._hh | 0, le = this._al | 0, Ee = this._bl | 0, Je = this._cl | 0, Ve = this._dl | 0, $t = this._el | 0, Nt = this._fl | 0, Dt = this._gl | 0, Wt = this._hl | 0, Pt = 0; Pt < 32; Pt += 2)
    z[Pt] = B.readInt32BE(Pt * 4), z[Pt + 1] = B.readInt32BE(Pt * 4 + 4);
  for (; Pt < 160; Pt += 2) {
    var Lt = z[Pt - 30], qt = z[Pt - 15 * 2 + 1], Zt = Gamma0(Lt, qt), Yt = Gamma0l(qt, Lt);
    Lt = z[Pt - 2 * 2], qt = z[Pt - 2 * 2 + 1];
    var or = Gamma1(Lt, qt), jt = Gamma1l(qt, Lt), Ct = z[Pt - 7 * 2], Vt = z[Pt - 7 * 2 + 1], kt = z[Pt - 16 * 2], Pe = z[Pt - 16 * 2 + 1], Xe = Yt + Vt | 0, ve = Zt + Ct + getCarry(Xe, Yt) | 0;
    Xe = Xe + jt | 0, ve = ve + or + getCarry(Xe, jt) | 0, Xe = Xe + Pe | 0, ve = ve + kt + getCarry(Xe, Pe) | 0, z[Pt] = ve, z[Pt + 1] = Xe;
  }
  for (var Ke = 0; Ke < 160; Ke += 2) {
    ve = z[Ke], Xe = z[Ke + 1];
    var ht = maj(Y, ne, ie), wt = maj(le, Ee, Je), vt = sigma0(Y, le), xt = sigma0(le, Y), Qe = sigma1(se, $t), Rt = sigma1($t, se), bt = K$1[Ke], Ht = K$1[Ke + 1], ar = Ch(se, ae, ge), yr = Ch($t, Nt, Dt), rr = Wt + Rt | 0, Kt = Ce + Qe + getCarry(rr, Wt) | 0;
    rr = rr + yr | 0, Kt = Kt + ar + getCarry(rr, yr) | 0, rr = rr + Ht | 0, Kt = Kt + bt + getCarry(rr, Ht) | 0, rr = rr + Xe | 0, Kt = Kt + ve + getCarry(rr, Xe) | 0;
    var Gt = xt + wt | 0, ur = vt + ht + getCarry(Gt, xt) | 0;
    Ce = ge, Wt = Dt, ge = ae, Dt = Nt, ae = se, Nt = $t, $t = Ve + rr | 0, se = oe + Kt + getCarry($t, Ve) | 0, oe = ie, Ve = Je, ie = ne, Je = Ee, ne = Y, Ee = le, le = rr + Gt | 0, Y = Kt + ur + getCarry(le, rr) | 0;
  }
  this._al = this._al + le | 0, this._bl = this._bl + Ee | 0, this._cl = this._cl + Je | 0, this._dl = this._dl + Ve | 0, this._el = this._el + $t | 0, this._fl = this._fl + Nt | 0, this._gl = this._gl + Dt | 0, this._hl = this._hl + Wt | 0, this._ah = this._ah + Y + getCarry(this._al, le) | 0, this._bh = this._bh + ne + getCarry(this._bl, Ee) | 0, this._ch = this._ch + ie + getCarry(this._cl, Je) | 0, this._dh = this._dh + oe + getCarry(this._dl, Ve) | 0, this._eh = this._eh + se + getCarry(this._el, $t) | 0, this._fh = this._fh + ae + getCarry(this._fl, Nt) | 0, this._gh = this._gh + ge + getCarry(this._gl, Dt) | 0, this._hh = this._hh + Ce + getCarry(this._hl, Wt) | 0;
};
Sha512.prototype._hash = function() {
  var B = Buffer$s.allocUnsafe(64);
  function z(Y, ne, ie) {
    B.writeInt32BE(Y, ie), B.writeInt32BE(ne, ie + 4);
  }
  return z(this._ah, this._al, 0), z(this._bh, this._bl, 8), z(this._ch, this._cl, 16), z(this._dh, this._dl, 24), z(this._eh, this._el, 32), z(this._fh, this._fl, 40), z(this._gh, this._gl, 48), z(this._hh, this._hl, 56), B;
};
var sha512$1 = Sha512, inherits$i = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$r = safeBufferExports$1.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$i(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var B = Buffer$r.allocUnsafe(48);
  function z(Y, ne, ie) {
    B.writeInt32BE(Y, ie), B.writeInt32BE(ne, ie + 4);
  }
  return z(this._ah, this._al, 0), z(this._bh, this._bl, 8), z(this._ch, this._cl, 16), z(this._dh, this._dl, 24), z(this._eh, this._el, 32), z(this._fh, this._fl, 40), B;
};
var sha384$1 = Sha384, exports = sha_js.exports = function(z) {
  z = z.toLowerCase();
  var Y = exports[z];
  if (!Y) throw new Error(z + " is not supported (we accept pull requests)");
  return new Y();
};
exports.sha = sha$4;
exports.sha1 = sha1$1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$3;
exports.sha384 = sha384$1;
exports.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$h = inherits_browserExports;
inherits$h(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = require_stream_passthrough();
Stream.finished = requireEndOfStream();
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(B, z) {
  var Y = this;
  function ne(le) {
    B.writable && B.write(le) === !1 && Y.pause && Y.pause();
  }
  Y.on("data", ne);
  function ie() {
    Y.readable && Y.resume && Y.resume();
  }
  B.on("drain", ie), !B._isStdio && (!z || z.end !== !1) && (Y.on("end", se), Y.on("close", ae));
  var oe = !1;
  function se() {
    oe || (oe = !0, B.end());
  }
  function ae() {
    oe || (oe = !0, typeof B.destroy == "function" && B.destroy());
  }
  function ge(le) {
    if (Ce(), EE.listenerCount(this, "error") === 0)
      throw le;
  }
  Y.on("error", ge), B.on("error", ge);
  function Ce() {
    Y.removeListener("data", ne), B.removeListener("drain", ie), Y.removeListener("end", se), Y.removeListener("close", ae), Y.removeListener("error", ge), B.removeListener("error", ge), Y.removeListener("end", Ce), Y.removeListener("close", Ce), B.removeListener("close", Ce);
  }
  return Y.on("end", Ce), Y.on("close", Ce), B.on("close", Ce), B.emit("pipe", Y), B;
};
var Buffer$q = safeBufferExports$1.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports;
function CipherBase$1(B) {
  Transform$6.call(this), this.hashMode = typeof B == "string", this.hashMode ? this[B] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
var useUint8Array = typeof Uint8Array < "u", useArrayBuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$q.prototype instanceof Uint8Array || Buffer$q.TYPED_ARRAY_SUPPORT);
function toBuffer$4(B, z) {
  if (B instanceof Buffer$q)
    return B;
  if (typeof B == "string")
    return Buffer$q.from(B, z);
  if (useArrayBuffer && ArrayBuffer.isView(B)) {
    if (B.byteLength === 0)
      return Buffer$q.alloc(0);
    var Y = Buffer$q.from(B.buffer, B.byteOffset, B.byteLength);
    if (Y.byteLength === B.byteLength)
      return Y;
  }
  if (useUint8Array && B instanceof Uint8Array || Buffer$q.isBuffer(B) && B.constructor && typeof B.constructor.isBuffer == "function" && B.constructor.isBuffer(B))
    return Buffer$q.from(B);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
CipherBase$1.prototype.update = function(B, z, Y) {
  var ne = toBuffer$4(B, z), ie = this._update(ne);
  return this.hashMode ? this : (Y && (ie = this._toString(ie, Y)), ie);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(B, z, Y) {
  var ne;
  try {
    this.hashMode ? this._update(B) : this.push(this._update(B));
  } catch (ie) {
    ne = ie;
  } finally {
    Y(ne);
  }
};
CipherBase$1.prototype._flush = function(B) {
  var z;
  try {
    this.push(this.__final());
  } catch (Y) {
    z = Y;
  }
  B(z);
};
CipherBase$1.prototype._finalOrDigest = function(B) {
  var z = this.__final() || Buffer$q.alloc(0);
  return B && (z = this._toString(z, B, !0)), z;
};
CipherBase$1.prototype._toString = function(B, z, Y) {
  if (this._decoder || (this._decoder = new StringDecoder(z), this._encoding = z), this._encoding !== z)
    throw new Error("can’t switch encodings");
  var ne = this._decoder.write(B);
  return Y && (ne += this._decoder.end()), ne;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$4 = ripemd160$1, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(B) {
  Base$5.call(this, "digest"), this._hash = B;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(B) {
  this._hash.update(B);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(z) {
  return z = z.toLowerCase(), z === "md5" ? new MD5$2() : z === "rmd160" || z === "ripemd160" ? new RIPEMD160$4() : new Hash(sha$3(z));
}, inherits$e = inherits_browserExports, Buffer$p = safeBufferExports$1.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$p.alloc(128), blocksize = 64;
function Hmac$3(B, z) {
  Base$4.call(this, "digest"), typeof z == "string" && (z = Buffer$p.from(z)), this._alg = B, this._key = z, z.length > blocksize ? z = B(z) : z.length < blocksize && (z = Buffer$p.concat([z, ZEROS$2], blocksize));
  for (var Y = this._ipad = Buffer$p.allocUnsafe(blocksize), ne = this._opad = Buffer$p.allocUnsafe(blocksize), ie = 0; ie < blocksize; ie++)
    Y[ie] = z[ie] ^ 54, ne[ie] = z[ie] ^ 92;
  this._hash = [Y];
}
inherits$e(Hmac$3, Base$4);
Hmac$3.prototype._update = function(B) {
  this._hash.push(B);
};
Hmac$3.prototype._final = function() {
  var B = this._alg(Buffer$p.concat(this._hash));
  return this._alg(Buffer$p.concat([this._opad, B]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(B) {
  return new MD5$1().update(B).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$o = safeBufferExports$1.Buffer, md5$1 = md5$2, RIPEMD160$3 = ripemd160$1, sha$2 = sha_jsExports, ZEROS$1 = Buffer$o.alloc(128);
function Hmac$2(B, z) {
  Base$3.call(this, "digest"), typeof z == "string" && (z = Buffer$o.from(z));
  var Y = B === "sha512" || B === "sha384" ? 128 : 64;
  if (this._alg = B, this._key = z, z.length > Y) {
    var ne = B === "rmd160" ? new RIPEMD160$3() : sha$2(B);
    z = ne.update(z).digest();
  } else z.length < Y && (z = Buffer$o.concat([z, ZEROS$1], Y));
  for (var ie = this._ipad = Buffer$o.allocUnsafe(Y), oe = this._opad = Buffer$o.allocUnsafe(Y), se = 0; se < Y; se++)
    ie[se] = z[se] ^ 54, oe[se] = z[se] ^ 92;
  this._hash = B === "rmd160" ? new RIPEMD160$3() : sha$2(B), this._hash.update(ie);
}
inherits$d(Hmac$2, Base$3);
Hmac$2.prototype._update = function(B) {
  this._hash.update(B);
};
Hmac$2.prototype._final = function() {
  var B = this._hash.digest(), z = this._alg === "rmd160" ? new RIPEMD160$3() : sha$2(this._alg);
  return z.update(this._opad).update(B).digest();
};
var browser$8 = function(z, Y) {
  return z = z.toLowerCase(), z === "rmd160" || z === "ripemd160" ? new Hmac$2("rmd160", Y) : z === "md5" ? new Legacy(md5$1, Y) : new Hmac$2(z, Y);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(B, z) {
  if (typeof B != "number")
    throw new TypeError("Iterations not a number");
  if (B < 0)
    throw new TypeError("Bad iterations");
  if (typeof z != "number")
    throw new TypeError("Key length not a number");
  if (z < 0 || z > MAX_ALLOC || z !== z)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$n = safeBufferExports$1.Buffer, toBuffer$3 = function(B, z, Y) {
  if (Buffer$n.isBuffer(B))
    return B;
  if (typeof B == "string")
    return Buffer$n.from(B, z);
  if (ArrayBuffer.isView(B))
    return Buffer$n.from(B.buffer);
  throw new TypeError(Y + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$2 = ripemd160$1, sha$1 = sha_jsExports, Buffer$m = safeBufferExports$1.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$2 = toBuffer$3, ZEROS = Buffer$m.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(B, z, Y) {
  var ne = getDigest(B), ie = B === "sha512" || B === "sha384" ? 128 : 64;
  z.length > ie ? z = ne(z) : z.length < ie && (z = Buffer$m.concat([z, ZEROS], ie));
  for (var oe = Buffer$m.allocUnsafe(ie + sizes[B]), se = Buffer$m.allocUnsafe(ie + sizes[B]), ae = 0; ae < ie; ae++)
    oe[ae] = z[ae] ^ 54, se[ae] = z[ae] ^ 92;
  var ge = Buffer$m.allocUnsafe(ie + Y + 4);
  oe.copy(ge, 0, 0, ie), this.ipad1 = ge, this.ipad2 = oe, this.opad = se, this.alg = B, this.blocksize = ie, this.hash = ne, this.size = sizes[B];
}
Hmac$1.prototype.run = function(B, z) {
  B.copy(z, this.blocksize);
  var Y = this.hash(z);
  return Y.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(B) {
  function z(ne) {
    return sha$1(B).update(ne).digest();
  }
  function Y(ne) {
    return new RIPEMD160$2().update(ne).digest();
  }
  return B === "rmd160" || B === "ripemd160" ? Y : B === "md5" ? md5 : z;
}
function pbkdf2(B, z, Y, ne, ie) {
  checkParameters$1(Y, ne), B = toBuffer$2(B, defaultEncoding$1, "Password"), z = toBuffer$2(z, defaultEncoding$1, "Salt"), ie = ie || "sha1";
  var oe = new Hmac$1(ie, B, z.length), se = Buffer$m.allocUnsafe(ne), ae = Buffer$m.allocUnsafe(z.length + 4);
  z.copy(ae, 0, 0, z.length);
  for (var ge = 0, Ce = sizes[ie], le = Math.ceil(ne / Ce), Ee = 1; Ee <= le; Ee++) {
    ae.writeUInt32BE(Ee, z.length);
    for (var Je = oe.run(ae, oe.ipad1), Ve = Je, $t = 1; $t < Y; $t++) {
      Ve = oe.run(Ve, oe.ipad2);
      for (var Nt = 0; Nt < Ce; Nt++) Je[Nt] ^= Ve[Nt];
    }
    Je.copy(se, ge), ge += Ce;
  }
  return se;
}
var syncBrowser = pbkdf2, Buffer$l = safeBufferExports$1.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer$1 = toBuffer$3, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(B) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[B] !== void 0)
    return checks[B];
  ZERO_BUF = ZERO_BUF || Buffer$l.alloc(8);
  var z = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, B).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[B] = z, z;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(B, z, Y, ne, ie) {
  return subtle.importKey(
    "raw",
    B,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(oe) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: z,
      iterations: Y,
      hash: {
        name: ie
      }
    }, oe, ne << 3);
  }).then(function(oe) {
    return Buffer$l.from(oe);
  });
}
function resolvePromise(B, z) {
  B.then(function(Y) {
    getNextTick()(function() {
      z(null, Y);
    });
  }, function(Y) {
    getNextTick()(function() {
      z(Y);
    });
  });
}
var async = function(B, z, Y, ne, ie, oe) {
  typeof ie == "function" && (oe = ie, ie = void 0), ie = ie || "sha1";
  var se = toBrowser[ie.toLowerCase()];
  if (!se || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var ae;
      try {
        ae = sync(B, z, Y, ne, ie);
      } catch (ge) {
        return oe(ge);
      }
      oe(null, ae);
    });
    return;
  }
  if (checkParameters(Y, ne), B = toBuffer$1(B, defaultEncoding, "Password"), z = toBuffer$1(z, defaultEncoding, "Salt"), typeof oe != "function") throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(se).then(function(ae) {
    return ae ? browserPbkdf2(B, z, Y, ne, se) : sync(B, z, Y, ne, ie);
  }), oe);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$o = {};
utils$o.readUInt32BE = function(z, Y) {
  var ne = z[0 + Y] << 24 | z[1 + Y] << 16 | z[2 + Y] << 8 | z[3 + Y];
  return ne >>> 0;
};
utils$o.writeUInt32BE = function(z, Y, ne) {
  z[0 + ne] = Y >>> 24, z[1 + ne] = Y >>> 16 & 255, z[2 + ne] = Y >>> 8 & 255, z[3 + ne] = Y & 255;
};
utils$o.ip = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = 6; ae >= 0; ae -= 2) {
    for (var ge = 0; ge <= 24; ge += 8)
      oe <<= 1, oe |= Y >>> ge + ae & 1;
    for (var ge = 0; ge <= 24; ge += 8)
      oe <<= 1, oe |= z >>> ge + ae & 1;
  }
  for (var ae = 6; ae >= 0; ae -= 2) {
    for (var ge = 1; ge <= 25; ge += 8)
      se <<= 1, se |= Y >>> ge + ae & 1;
    for (var ge = 1; ge <= 25; ge += 8)
      se <<= 1, se |= z >>> ge + ae & 1;
  }
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.rip = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = 0; ae < 4; ae++)
    for (var ge = 24; ge >= 0; ge -= 8)
      oe <<= 1, oe |= Y >>> ge + ae & 1, oe <<= 1, oe |= z >>> ge + ae & 1;
  for (var ae = 4; ae < 8; ae++)
    for (var ge = 24; ge >= 0; ge -= 8)
      se <<= 1, se |= Y >>> ge + ae & 1, se <<= 1, se |= z >>> ge + ae & 1;
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.pc1 = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = 7; ae >= 5; ae--) {
    for (var ge = 0; ge <= 24; ge += 8)
      oe <<= 1, oe |= Y >> ge + ae & 1;
    for (var ge = 0; ge <= 24; ge += 8)
      oe <<= 1, oe |= z >> ge + ae & 1;
  }
  for (var ge = 0; ge <= 24; ge += 8)
    oe <<= 1, oe |= Y >> ge + ae & 1;
  for (var ae = 1; ae <= 3; ae++) {
    for (var ge = 0; ge <= 24; ge += 8)
      se <<= 1, se |= Y >> ge + ae & 1;
    for (var ge = 0; ge <= 24; ge += 8)
      se <<= 1, se |= z >> ge + ae & 1;
  }
  for (var ge = 0; ge <= 24; ge += 8)
    se <<= 1, se |= z >> ge + ae & 1;
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.r28shl = function(z, Y) {
  return z << Y & 268435455 | z >>> 28 - Y;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$o.pc2 = function(z, Y, ne, ie) {
  for (var oe = 0, se = 0, ae = pc2table.length >>> 1, ge = 0; ge < ae; ge++)
    oe <<= 1, oe |= z >>> pc2table[ge] & 1;
  for (var ge = ae; ge < pc2table.length; ge++)
    se <<= 1, se |= Y >>> pc2table[ge] & 1;
  ne[ie + 0] = oe >>> 0, ne[ie + 1] = se >>> 0;
};
utils$o.expand = function(z, Y, ne) {
  var ie = 0, oe = 0;
  ie = (z & 1) << 5 | z >>> 27;
  for (var se = 23; se >= 15; se -= 4)
    ie <<= 6, ie |= z >>> se & 63;
  for (var se = 11; se >= 3; se -= 4)
    oe |= z >>> se & 63, oe <<= 6;
  oe |= (z & 31) << 1 | z >>> 31, Y[ne + 0] = ie >>> 0, Y[ne + 1] = oe >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$o.substitute = function(z, Y) {
  for (var ne = 0, ie = 0; ie < 4; ie++) {
    var oe = z >>> 18 - ie * 6 & 63, se = sTable[ie * 64 + oe];
    ne <<= 4, ne |= se;
  }
  for (var ie = 0; ie < 4; ie++) {
    var oe = Y >>> 18 - ie * 6 & 63, se = sTable[4 * 64 + ie * 64 + oe];
    ne <<= 4, ne |= se;
  }
  return ne >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$o.permute = function(z) {
  for (var Y = 0, ne = 0; ne < permuteTable.length; ne++)
    Y <<= 1, Y |= z >>> permuteTable[ne] & 1;
  return Y >>> 0;
};
utils$o.padSplit = function(z, Y, ne) {
  for (var ie = z.toString(2); ie.length < Y; )
    ie = "0" + ie;
  for (var oe = [], se = 0; se < Y; se += ne)
    oe.push(ie.slice(se, se + ne));
  return oe.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(B, z) {
  if (!B)
    throw new Error(z || "Assertion failed");
}
assert$j.equal = function(z, Y, ne) {
  if (z != Y)
    throw new Error(ne || "Assertion failed: " + z + " != " + Y);
};
var assert$i = minimalisticAssert;
function Cipher$3(B) {
  this.options = B, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = B.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(z) {
  return z.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(z) : this._updateEncrypt(z);
};
Cipher$3.prototype._buffer = function(z, Y) {
  for (var ne = Math.min(this.buffer.length - this.bufferOff, z.length - Y), ie = 0; ie < ne; ie++)
    this.buffer[this.bufferOff + ie] = z[Y + ie];
  return this.bufferOff += ne, ne;
};
Cipher$3.prototype._flushBuffer = function(z, Y) {
  return this._update(this.buffer, 0, z, Y), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(z) {
  var Y = 0, ne = 0, ie = (this.bufferOff + z.length) / this.blockSize | 0, oe = new Array(ie * this.blockSize);
  this.bufferOff !== 0 && (Y += this._buffer(z, Y), this.bufferOff === this.buffer.length && (ne += this._flushBuffer(oe, ne)));
  for (var se = z.length - (z.length - Y) % this.blockSize; Y < se; Y += this.blockSize)
    this._update(z, Y, oe, ne), ne += this.blockSize;
  for (; Y < z.length; Y++, this.bufferOff++)
    this.buffer[this.bufferOff] = z[Y];
  return oe;
};
Cipher$3.prototype._updateDecrypt = function(z) {
  for (var Y = 0, ne = 0, ie = Math.ceil((this.bufferOff + z.length) / this.blockSize) - 1, oe = new Array(ie * this.blockSize); ie > 0; ie--)
    Y += this._buffer(z, Y), ne += this._flushBuffer(oe, ne);
  return Y += this._buffer(z, Y), oe;
};
Cipher$3.prototype.final = function(z) {
  var Y;
  z && (Y = this.update(z));
  var ne;
  return this.type === "encrypt" ? ne = this._finalEncrypt() : ne = this._finalDecrypt(), Y ? Y.concat(ne) : ne;
};
Cipher$3.prototype._pad = function(z, Y) {
  if (Y === 0)
    return !1;
  for (; Y < z.length; )
    z[Y++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var z = new Array(this.blockSize);
  return this._update(this.buffer, 0, z, 0), z;
};
Cipher$3.prototype._unpad = function(z) {
  return z;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var z = new Array(this.blockSize);
  return this._flushBuffer(z, 0), this._unpad(z);
};
var assert$h = minimalisticAssert, inherits$c = inherits_browserExports, utils$n = utils$o, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(B) {
  Cipher$2.call(this, B);
  var z = new DESState();
  this._desState = z, this.deriveKeys(z, B.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(z) {
  return new DES$3(z);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(z, Y) {
  z.keys = new Array(16 * 2), assert$h.equal(Y.length, this.blockSize, "Invalid key length");
  var ne = utils$n.readUInt32BE(Y, 0), ie = utils$n.readUInt32BE(Y, 4);
  utils$n.pc1(ne, ie, z.tmp, 0), ne = z.tmp[0], ie = z.tmp[1];
  for (var oe = 0; oe < z.keys.length; oe += 2) {
    var se = shiftTable[oe >>> 1];
    ne = utils$n.r28shl(ne, se), ie = utils$n.r28shl(ie, se), utils$n.pc2(ne, ie, z.keys, oe);
  }
};
DES$3.prototype._update = function(z, Y, ne, ie) {
  var oe = this._desState, se = utils$n.readUInt32BE(z, Y), ae = utils$n.readUInt32BE(z, Y + 4);
  utils$n.ip(se, ae, oe.tmp, 0), se = oe.tmp[0], ae = oe.tmp[1], this.type === "encrypt" ? this._encrypt(oe, se, ae, oe.tmp, 0) : this._decrypt(oe, se, ae, oe.tmp, 0), se = oe.tmp[0], ae = oe.tmp[1], utils$n.writeUInt32BE(ne, se, ie), utils$n.writeUInt32BE(ne, ae, ie + 4);
};
DES$3.prototype._pad = function(z, Y) {
  if (this.padding === !1)
    return !1;
  for (var ne = z.length - Y, ie = Y; ie < z.length; ie++)
    z[ie] = ne;
  return !0;
};
DES$3.prototype._unpad = function(z) {
  if (this.padding === !1)
    return z;
  for (var Y = z[z.length - 1], ne = z.length - Y; ne < z.length; ne++)
    assert$h.equal(z[ne], Y);
  return z.slice(0, z.length - Y);
};
DES$3.prototype._encrypt = function(z, Y, ne, ie, oe) {
  for (var se = Y, ae = ne, ge = 0; ge < z.keys.length; ge += 2) {
    var Ce = z.keys[ge], le = z.keys[ge + 1];
    utils$n.expand(ae, z.tmp, 0), Ce ^= z.tmp[0], le ^= z.tmp[1];
    var Ee = utils$n.substitute(Ce, le), Je = utils$n.permute(Ee), Ve = ae;
    ae = (se ^ Je) >>> 0, se = Ve;
  }
  utils$n.rip(ae, se, ie, oe);
};
DES$3.prototype._decrypt = function(z, Y, ne, ie, oe) {
  for (var se = ne, ae = Y, ge = z.keys.length - 2; ge >= 0; ge -= 2) {
    var Ce = z.keys[ge], le = z.keys[ge + 1];
    utils$n.expand(se, z.tmp, 0), Ce ^= z.tmp[0], le ^= z.tmp[1];
    var Ee = utils$n.substitute(Ce, le), Je = utils$n.permute(Ee), Ve = se;
    se = (ae ^ Je) >>> 0, ae = Ve;
  }
  utils$n.rip(se, ae, ie, oe);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(B) {
  assert$g.equal(B.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var z = 0; z < this.iv.length; z++)
    this.iv[z] = B[z];
}
function instantiate(B) {
  function z(oe) {
    B.call(this, oe), this._cbcInit();
  }
  inherits$b(z, B);
  for (var Y = Object.keys(proto), ne = 0; ne < Y.length; ne++) {
    var ie = Y[ne];
    z.prototype[ie] = proto[ie];
  }
  return z.create = function(se) {
    return new z(se);
  }, z;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var z = new CBCState(this.options.iv);
  this._cbcState = z;
};
proto._update = function(z, Y, ne, ie) {
  var oe = this._cbcState, se = this.constructor.super_.prototype, ae = oe.iv;
  if (this.type === "encrypt") {
    for (var ge = 0; ge < this.blockSize; ge++)
      ae[ge] ^= z[Y + ge];
    se._update.call(this, ae, 0, ne, ie);
    for (var ge = 0; ge < this.blockSize; ge++)
      ae[ge] = ne[ie + ge];
  } else {
    se._update.call(this, z, Y, ne, ie);
    for (var ge = 0; ge < this.blockSize; ge++)
      ne[ie + ge] ^= ae[ge];
    for (var ge = 0; ge < this.blockSize; ge++)
      ae[ge] = z[Y + ge];
  }
};
var assert$f = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(B, z) {
  assert$f.equal(z.length, 24, "Invalid key length");
  var Y = z.slice(0, 8), ne = z.slice(8, 16), ie = z.slice(16, 24);
  B === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: Y }),
    DES$2.create({ type: "decrypt", key: ne }),
    DES$2.create({ type: "encrypt", key: ie })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: ie }),
    DES$2.create({ type: "encrypt", key: ne }),
    DES$2.create({ type: "decrypt", key: Y })
  ];
}
function EDE(B) {
  Cipher$1.call(this, B);
  var z = new EDEState(this.type, this.options.key);
  this._edeState = z;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(z) {
  return new EDE(z);
};
EDE.prototype._update = function(z, Y, ne, ie) {
  var oe = this._edeState;
  oe.ciphers[0]._update(z, Y, ne, ie), oe.ciphers[1]._update(ne, ie, ne, ie), oe.ciphers[2]._update(ne, ie, ne, ie);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$o;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$k = safeBufferExports$1.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(B) {
  CipherBase.call(this);
  var z = B.mode.toLowerCase(), Y = modes$3[z], ne;
  B.decrypt ? ne = "decrypt" : ne = "encrypt";
  var ie = B.key;
  Buffer$k.isBuffer(ie) || (ie = Buffer$k.from(ie)), (z === "des-ede" || z === "des-ede-cbc") && (ie = Buffer$k.concat([ie, ie.slice(0, 8)]));
  var oe = B.iv;
  Buffer$k.isBuffer(oe) || (oe = Buffer$k.from(oe)), this._des = Y.create({
    key: ie,
    iv: oe,
    type: ne
  });
}
DES$1.prototype._update = function(B) {
  return Buffer$k.from(this._des.update(B));
};
DES$1.prototype._final = function() {
  return Buffer$k.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(B, z) {
  return B._cipher.encryptBlock(z);
};
ecb.decrypt = function(B, z) {
  return B._cipher.decryptBlock(z);
};
var cbc = {}, bufferXor = function(z, Y) {
  for (var ne = Math.min(z.length, Y.length), ie = new Buffer$D(ne), oe = 0; oe < ne; ++oe)
    ie[oe] = z[oe] ^ Y[oe];
  return ie;
}, xor$7 = bufferXor;
cbc.encrypt = function(B, z) {
  var Y = xor$7(z, B._prev);
  return B._prev = B._cipher.encryptBlock(Y), B._prev;
};
cbc.decrypt = function(B, z) {
  var Y = B._prev;
  B._prev = z;
  var ne = B._cipher.decryptBlock(z);
  return xor$7(ne, Y);
};
var cfb = {}, Buffer$j = safeBufferExports$1.Buffer, xor$6 = bufferXor;
function encryptStart(B, z, Y) {
  var ne = z.length, ie = xor$6(z, B._cache);
  return B._cache = B._cache.slice(ne), B._prev = Buffer$j.concat([B._prev, Y ? z : ie]), ie;
}
cfb.encrypt = function(B, z, Y) {
  for (var ne = Buffer$j.allocUnsafe(0), ie; z.length; )
    if (B._cache.length === 0 && (B._cache = B._cipher.encryptBlock(B._prev), B._prev = Buffer$j.allocUnsafe(0)), B._cache.length <= z.length)
      ie = B._cache.length, ne = Buffer$j.concat([ne, encryptStart(B, z.slice(0, ie), Y)]), z = z.slice(ie);
    else {
      ne = Buffer$j.concat([ne, encryptStart(B, z, Y)]);
      break;
    }
  return ne;
};
var cfb8 = {}, Buffer$i = safeBufferExports$1.Buffer;
function encryptByte$1(B, z, Y) {
  var ne = B._cipher.encryptBlock(B._prev), ie = ne[0] ^ z;
  return B._prev = Buffer$i.concat([
    B._prev.slice(1),
    Buffer$i.from([Y ? z : ie])
  ]), ie;
}
cfb8.encrypt = function(B, z, Y) {
  for (var ne = z.length, ie = Buffer$i.allocUnsafe(ne), oe = -1; ++oe < ne; )
    ie[oe] = encryptByte$1(B, z[oe], Y);
  return ie;
};
var cfb1 = {}, Buffer$h = safeBufferExports$1.Buffer;
function encryptByte(B, z, Y) {
  for (var ne, ie = -1, oe = 8, se = 0, ae, ge; ++ie < oe; )
    ne = B._cipher.encryptBlock(B._prev), ae = z & 1 << 7 - ie ? 128 : 0, ge = ne[0] ^ ae, se += (ge & 128) >> ie % 8, B._prev = shiftIn(B._prev, Y ? ae : ge);
  return se;
}
function shiftIn(B, z) {
  var Y = B.length, ne = -1, ie = Buffer$h.allocUnsafe(B.length);
  for (B = Buffer$h.concat([B, Buffer$h.from([z])]); ++ne < Y; )
    ie[ne] = B[ne] << 1 | B[ne + 1] >> 7;
  return ie;
}
cfb1.encrypt = function(B, z, Y) {
  for (var ne = z.length, ie = Buffer$h.allocUnsafe(ne), oe = -1; ++oe < ne; )
    ie[oe] = encryptByte(B, z[oe], Y);
  return ie;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(B) {
  return B._prev = B._cipher.encryptBlock(B._prev), B._prev;
}
ofb.encrypt = function(B, z) {
  for (; B._cache.length < z.length; )
    B._cache = Buffer$D.concat([B._cache, getBlock$1(B)]);
  var Y = B._cache.slice(0, z.length);
  return B._cache = B._cache.slice(z.length), xor$5(z, Y);
};
var ctr = {};
function incr32$2(B) {
  for (var z = B.length, Y; z--; )
    if (Y = B.readUInt8(z), Y === 255)
      B.writeUInt8(0, z);
    else {
      Y++, B.writeUInt8(Y, z);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$g = safeBufferExports$1.Buffer, incr32$1 = incr32_1;
function getBlock(B) {
  var z = B._cipher.encryptBlockRaw(B._prev);
  return incr32$1(B._prev), z;
}
var blockSize = 16;
ctr.encrypt = function(B, z) {
  var Y = Math.ceil(z.length / blockSize), ne = B._cache.length;
  B._cache = Buffer$g.concat([
    B._cache,
    Buffer$g.allocUnsafe(Y * blockSize)
  ]);
  for (var ie = 0; ie < Y; ie++) {
    var oe = getBlock(B), se = ne + ie * blockSize;
    B._cache.writeUInt32BE(oe[0], se + 0), B._cache.writeUInt32BE(oe[1], se + 4), B._cache.writeUInt32BE(oe[2], se + 8), B._cache.writeUInt32BE(oe[3], se + 12);
  }
  var ae = B._cache.slice(0, z.length);
  return B._cache = B._cache.slice(z.length), xor$4(z, ae);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$f = safeBufferExports$1.Buffer;
function asUInt32Array(B) {
  Buffer$f.isBuffer(B) || (B = Buffer$f.from(B));
  for (var z = B.length / 4 | 0, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = B.readUInt32BE(ne * 4);
  return Y;
}
function scrubVec(B) {
  for (var z = 0; z < B.length; B++)
    B[z] = 0;
}
function cryptBlock(B, z, Y, ne, ie) {
  for (var oe = Y[0], se = Y[1], ae = Y[2], ge = Y[3], Ce = B[0] ^ z[0], le = B[1] ^ z[1], Ee = B[2] ^ z[2], Je = B[3] ^ z[3], Ve, $t, Nt, Dt, Wt = 4, Pt = 1; Pt < ie; Pt++)
    Ve = oe[Ce >>> 24] ^ se[le >>> 16 & 255] ^ ae[Ee >>> 8 & 255] ^ ge[Je & 255] ^ z[Wt++], $t = oe[le >>> 24] ^ se[Ee >>> 16 & 255] ^ ae[Je >>> 8 & 255] ^ ge[Ce & 255] ^ z[Wt++], Nt = oe[Ee >>> 24] ^ se[Je >>> 16 & 255] ^ ae[Ce >>> 8 & 255] ^ ge[le & 255] ^ z[Wt++], Dt = oe[Je >>> 24] ^ se[Ce >>> 16 & 255] ^ ae[le >>> 8 & 255] ^ ge[Ee & 255] ^ z[Wt++], Ce = Ve, le = $t, Ee = Nt, Je = Dt;
  return Ve = (ne[Ce >>> 24] << 24 | ne[le >>> 16 & 255] << 16 | ne[Ee >>> 8 & 255] << 8 | ne[Je & 255]) ^ z[Wt++], $t = (ne[le >>> 24] << 24 | ne[Ee >>> 16 & 255] << 16 | ne[Je >>> 8 & 255] << 8 | ne[Ce & 255]) ^ z[Wt++], Nt = (ne[Ee >>> 24] << 24 | ne[Je >>> 16 & 255] << 16 | ne[Ce >>> 8 & 255] << 8 | ne[le & 255]) ^ z[Wt++], Dt = (ne[Je >>> 24] << 24 | ne[Ce >>> 16 & 255] << 16 | ne[le >>> 8 & 255] << 8 | ne[Ee & 255]) ^ z[Wt++], Ve = Ve >>> 0, $t = $t >>> 0, Nt = Nt >>> 0, Dt = Dt >>> 0, [Ve, $t, Nt, Dt];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var B = new Array(256), z = 0; z < 256; z++)
    z < 128 ? B[z] = z << 1 : B[z] = z << 1 ^ 283;
  for (var Y = [], ne = [], ie = [[], [], [], []], oe = [[], [], [], []], se = 0, ae = 0, ge = 0; ge < 256; ++ge) {
    var Ce = ae ^ ae << 1 ^ ae << 2 ^ ae << 3 ^ ae << 4;
    Ce = Ce >>> 8 ^ Ce & 255 ^ 99, Y[se] = Ce, ne[Ce] = se;
    var le = B[se], Ee = B[le], Je = B[Ee], Ve = B[Ce] * 257 ^ Ce * 16843008;
    ie[0][se] = Ve << 24 | Ve >>> 8, ie[1][se] = Ve << 16 | Ve >>> 16, ie[2][se] = Ve << 8 | Ve >>> 24, ie[3][se] = Ve, Ve = Je * 16843009 ^ Ee * 65537 ^ le * 257 ^ se * 16843008, oe[0][Ce] = Ve << 24 | Ve >>> 8, oe[1][Ce] = Ve << 16 | Ve >>> 16, oe[2][Ce] = Ve << 8 | Ve >>> 24, oe[3][Ce] = Ve, se === 0 ? se = ae = 1 : (se = le ^ B[B[B[Je ^ le]]], ae ^= B[B[ae]]);
  }
  return {
    SBOX: Y,
    INV_SBOX: ne,
    SUB_MIX: ie,
    INV_SUB_MIX: oe
  };
}();
function AES(B) {
  this._key = asUInt32Array(B), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var B = this._key, z = B.length, Y = z + 6, ne = (Y + 1) * 4, ie = [], oe = 0; oe < z; oe++)
    ie[oe] = B[oe];
  for (oe = z; oe < ne; oe++) {
    var se = ie[oe - 1];
    oe % z === 0 ? (se = se << 8 | se >>> 24, se = G.SBOX[se >>> 24] << 24 | G.SBOX[se >>> 16 & 255] << 16 | G.SBOX[se >>> 8 & 255] << 8 | G.SBOX[se & 255], se ^= RCON[oe / z | 0] << 24) : z > 6 && oe % z === 4 && (se = G.SBOX[se >>> 24] << 24 | G.SBOX[se >>> 16 & 255] << 16 | G.SBOX[se >>> 8 & 255] << 8 | G.SBOX[se & 255]), ie[oe] = ie[oe - z] ^ se;
  }
  for (var ae = [], ge = 0; ge < ne; ge++) {
    var Ce = ne - ge, le = ie[Ce - (ge % 4 ? 0 : 4)];
    ge < 4 || Ce <= 4 ? ae[ge] = le : ae[ge] = G.INV_SUB_MIX[0][G.SBOX[le >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[le >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[le >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[le & 255]];
  }
  this._nRounds = Y, this._keySchedule = ie, this._invKeySchedule = ae;
};
AES.prototype.encryptBlockRaw = function(B) {
  return B = asUInt32Array(B), cryptBlock(B, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(B) {
  var z = this.encryptBlockRaw(B), Y = Buffer$f.allocUnsafe(16);
  return Y.writeUInt32BE(z[0], 0), Y.writeUInt32BE(z[1], 4), Y.writeUInt32BE(z[2], 8), Y.writeUInt32BE(z[3], 12), Y;
};
AES.prototype.decryptBlock = function(B) {
  B = asUInt32Array(B);
  var z = B[1];
  B[1] = B[3], B[3] = z;
  var Y = cryptBlock(B, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), ne = Buffer$f.allocUnsafe(16);
  return ne.writeUInt32BE(Y[0], 0), ne.writeUInt32BE(Y[3], 4), ne.writeUInt32BE(Y[2], 8), ne.writeUInt32BE(Y[1], 12), ne;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$e = safeBufferExports$1.Buffer, ZEROES = Buffer$e.alloc(16, 0);
function toArray$1(B) {
  return [
    B.readUInt32BE(0),
    B.readUInt32BE(4),
    B.readUInt32BE(8),
    B.readUInt32BE(12)
  ];
}
function fromArray(B) {
  var z = Buffer$e.allocUnsafe(16);
  return z.writeUInt32BE(B[0] >>> 0, 0), z.writeUInt32BE(B[1] >>> 0, 4), z.writeUInt32BE(B[2] >>> 0, 8), z.writeUInt32BE(B[3] >>> 0, 12), z;
}
function GHASH$1(B) {
  this.h = B, this.state = Buffer$e.alloc(16, 0), this.cache = Buffer$e.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(B) {
  for (var z = -1; ++z < B.length; )
    this.state[z] ^= B[z];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var B = toArray$1(this.h), z = [0, 0, 0, 0], Y, ne, ie, oe = -1; ++oe < 128; ) {
    for (ne = (this.state[~~(oe / 8)] & 1 << 7 - oe % 8) !== 0, ne && (z[0] ^= B[0], z[1] ^= B[1], z[2] ^= B[2], z[3] ^= B[3]), ie = (B[3] & 1) !== 0, Y = 3; Y > 0; Y--)
      B[Y] = B[Y] >>> 1 | (B[Y - 1] & 1) << 31;
    B[0] = B[0] >>> 1, ie && (B[0] = B[0] ^ 225 << 24);
  }
  this.state = fromArray(z);
};
GHASH$1.prototype.update = function(B) {
  this.cache = Buffer$e.concat([this.cache, B]);
  for (var z; this.cache.length >= 16; )
    z = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(z);
};
GHASH$1.prototype.final = function(B, z) {
  return this.cache.length && this.ghash(Buffer$e.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, B, 0, z])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$d = safeBufferExports$1.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(B, z) {
  var Y = 0;
  B.length !== z.length && Y++;
  for (var ne = Math.min(B.length, z.length), ie = 0; ie < ne; ++ie)
    Y += B[ie] ^ z[ie];
  return Y;
}
function calcIv(B, z, Y) {
  if (z.length === 12)
    return B._finID = Buffer$d.concat([z, Buffer$d.from([0, 0, 0, 1])]), Buffer$d.concat([z, Buffer$d.from([0, 0, 0, 2])]);
  var ne = new GHASH(Y), ie = z.length, oe = ie % 16;
  ne.update(z), oe && (oe = 16 - oe, ne.update(Buffer$d.alloc(oe, 0))), ne.update(Buffer$d.alloc(8, 0));
  var se = ie * 8, ae = Buffer$d.alloc(8);
  ae.writeUIntBE(se, 0, 8), ne.update(ae), B._finID = ne.state;
  var ge = Buffer$d.from(B._finID);
  return incr32(ge), ge;
}
function StreamCipher$3(B, z, Y, ne) {
  Transform$5.call(this);
  var ie = Buffer$d.alloc(4, 0);
  this._cipher = new aes$4.AES(z);
  var oe = this._cipher.encryptBlock(ie);
  this._ghash = new GHASH(oe), Y = calcIv(this, Y, oe), this._prev = Buffer$d.from(Y), this._cache = Buffer$d.allocUnsafe(0), this._secCache = Buffer$d.allocUnsafe(0), this._decrypt = ne, this._alen = 0, this._len = 0, this._mode = B, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(B) {
  if (!this._called && this._alen) {
    var z = 16 - this._alen % 16;
    z < 16 && (z = Buffer$d.alloc(z, 0), this._ghash.update(z));
  }
  this._called = !0;
  var Y = this._mode.encrypt(this, B);
  return this._decrypt ? this._ghash.update(B) : this._ghash.update(Y), this._len += B.length, Y;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var B = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(B, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = B, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$d.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(z) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = z;
};
StreamCipher$3.prototype.setAAD = function(z) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(z), this._alen += z.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$c = safeBufferExports$1.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(B, z, Y, ne) {
  Transform$4.call(this), this._cipher = new aes$3.AES(z), this._prev = Buffer$c.from(Y), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = ne, this._mode = B;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(B) {
  return this._mode.encrypt(this, B, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$b = safeBufferExports$1.Buffer, MD5 = md5_js;
function EVP_BytesToKey(B, z, Y, ne) {
  if (Buffer$b.isBuffer(B) || (B = Buffer$b.from(B, "binary")), z && (Buffer$b.isBuffer(z) || (z = Buffer$b.from(z, "binary")), z.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var ie = Y / 8, oe = Buffer$b.alloc(ie), se = Buffer$b.alloc(ne || 0), ae = Buffer$b.alloc(0); ie > 0 || ne > 0; ) {
    var ge = new MD5();
    ge.update(ae), ge.update(B), z && ge.update(z), ae = ge.digest();
    var Ce = 0;
    if (ie > 0) {
      var le = oe.length - ie;
      Ce = Math.min(ie, ae.length), ae.copy(oe, le, 0, Ce), ie -= Ce;
    }
    if (Ce < ae.length && ne > 0) {
      var Ee = se.length - ne, Je = Math.min(ne, ae.length - Ce);
      ae.copy(se, Ee, Ce, Ce + Je), ne -= Je;
    }
  }
  return ae.fill(0), { key: oe, iv: se };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$a = safeBufferExports$1.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(B, z, Y) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(z), this._prev = Buffer$a.from(Y), this._mode = B, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(B) {
  this._cache.add(B);
  for (var z, Y, ne = []; z = this._cache.get(); )
    Y = this._mode.encrypt(this, z), ne.push(Y);
  return Buffer$a.concat(ne);
};
var PADDING = Buffer$a.alloc(16, 16);
Cipher.prototype._final = function() {
  var B = this._cache.flush();
  if (this._autopadding)
    return B = this._mode.encrypt(this, B), this._cipher.scrub(), B;
  if (!B.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(B) {
  return this._autopadding = !!B, this;
};
function Splitter$1() {
  this.cache = Buffer$a.allocUnsafe(0);
}
Splitter$1.prototype.add = function(B) {
  this.cache = Buffer$a.concat([this.cache, B]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var B = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), B;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var B = 16 - this.cache.length, z = Buffer$a.allocUnsafe(B), Y = -1; ++Y < B; )
    z.writeUInt8(B, Y);
  return Buffer$a.concat([this.cache, z]);
};
function createCipheriv$1(B, z, Y) {
  var ne = MODES$1[B.toLowerCase()];
  if (!ne) throw new TypeError("invalid suite type");
  if (typeof z == "string" && (z = Buffer$a.from(z)), z.length !== ne.key / 8) throw new TypeError("invalid key length " + z.length);
  if (typeof Y == "string" && (Y = Buffer$a.from(Y)), ne.mode !== "GCM" && Y.length !== ne.iv) throw new TypeError("invalid iv length " + Y.length);
  return ne.type === "stream" ? new StreamCipher$1(ne.module, z, Y) : ne.type === "auth" ? new AuthCipher$1(ne.module, z, Y) : new Cipher(ne.module, z, Y);
}
function createCipher$1(B, z) {
  var Y = MODES$1[B.toLowerCase()];
  if (!Y) throw new TypeError("invalid suite type");
  var ne = ebtk$2(z, !1, Y.key, Y.iv);
  return createCipheriv$1(B, ne.key, ne.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$9 = safeBufferExports$1.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(B, z, Y) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(z), this._prev = Buffer$9.from(Y), this._mode = B, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(B) {
  this._cache.add(B);
  for (var z, Y, ne = []; z = this._cache.get(this._autopadding); )
    Y = this._mode.decrypt(this, z), ne.push(Y);
  return Buffer$9.concat(ne);
};
Decipher.prototype._final = function() {
  var B = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, B));
  if (B)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(B) {
  return this._autopadding = !!B, this;
};
function Splitter() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter.prototype.add = function(B) {
  this.cache = Buffer$9.concat([this.cache, B]);
};
Splitter.prototype.get = function(B) {
  var z;
  if (B) {
    if (this.cache.length > 16)
      return z = this.cache.slice(0, 16), this.cache = this.cache.slice(16), z;
  } else if (this.cache.length >= 16)
    return z = this.cache.slice(0, 16), this.cache = this.cache.slice(16), z;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(B) {
  var z = B[15];
  if (z < 1 || z > 16)
    throw new Error("unable to decrypt data");
  for (var Y = -1; ++Y < z; )
    if (B[Y + (16 - z)] !== z)
      throw new Error("unable to decrypt data");
  if (z !== 16)
    return B.slice(0, 16 - z);
}
function createDecipheriv$1(B, z, Y) {
  var ne = MODES[B.toLowerCase()];
  if (!ne) throw new TypeError("invalid suite type");
  if (typeof Y == "string" && (Y = Buffer$9.from(Y)), ne.mode !== "GCM" && Y.length !== ne.iv) throw new TypeError("invalid iv length " + Y.length);
  if (typeof z == "string" && (z = Buffer$9.from(z)), z.length !== ne.key / 8) throw new TypeError("invalid key length " + z.length);
  return ne.type === "stream" ? new StreamCipher(ne.module, z, Y, !0) : ne.type === "auth" ? new AuthCipher(ne.module, z, Y, !0) : new Decipher(ne.module, z, Y);
}
function createDecipher$1(B, z) {
  var Y = MODES[B.toLowerCase()];
  if (!Y) throw new TypeError("invalid suite type");
  var ne = ebtk$1(z, !1, Y.key, Y.iv);
  return createDecipheriv$1(B, ne.key, ne.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(B) {
  B["des-ecb"] = {
    key: 8,
    iv: 0
  }, B["des-cbc"] = B.des = {
    key: 8,
    iv: 8
  }, B["des-ede3-cbc"] = B.des3 = {
    key: 24,
    iv: 8
  }, B["des-ede3"] = {
    key: 24,
    iv: 0
  }, B["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, B["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(B, z) {
  B = B.toLowerCase();
  var Y, ne;
  if (aesModes[B])
    Y = aesModes[B].key, ne = aesModes[B].iv;
  else if (desModes[B])
    Y = desModes[B].key * 8, ne = desModes[B].iv;
  else
    throw new TypeError("invalid suite type");
  var ie = ebtk(z, !1, Y, ne);
  return createCipheriv(B, ie.key, ie.iv);
}
function createDecipher(B, z) {
  B = B.toLowerCase();
  var Y, ne;
  if (aesModes[B])
    Y = aesModes[B].key, ne = aesModes[B].iv;
  else if (desModes[B])
    Y = desModes[B].key * 8, ne = desModes[B].iv;
  else
    throw new TypeError("invalid suite type");
  var ie = ebtk(z, !1, Y, ne);
  return createDecipheriv(B, ie.key, ie.iv);
}
function createCipheriv(B, z, Y) {
  if (B = B.toLowerCase(), aesModes[B]) return aes.createCipheriv(B, z, Y);
  if (desModes[B]) return new DES({ key: z, iv: Y, mode: B });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(B, z, Y) {
  if (B = B.toLowerCase(), aesModes[B]) return aes.createDecipheriv(B, z, Y);
  if (desModes[B]) return new DES({ key: z, iv: Y, mode: B, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
(function(B) {
  (function(z, Y) {
    function ne(kt, Pe) {
      if (!kt) throw new Error(Pe || "Assertion failed");
    }
    function ie(kt, Pe) {
      kt.super_ = Pe;
      var Xe = function() {
      };
      Xe.prototype = Pe.prototype, kt.prototype = new Xe(), kt.prototype.constructor = kt;
    }
    function oe(kt, Pe, Xe) {
      if (oe.isBN(kt))
        return kt;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, kt !== null && ((Pe === "le" || Pe === "be") && (Xe = Pe, Pe = 10), this._init(kt || 0, Pe || 10, Xe || "be"));
    }
    typeof z == "object" ? z.exports = oe : Y.BN = oe, oe.BN = oe, oe.wordSize = 26;
    var se;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? se = window.Buffer : se = dist$1.Buffer;
    } catch {
    }
    oe.isBN = function(Pe) {
      return Pe instanceof oe ? !0 : Pe !== null && typeof Pe == "object" && Pe.constructor.wordSize === oe.wordSize && Array.isArray(Pe.words);
    }, oe.max = function(Pe, Xe) {
      return Pe.cmp(Xe) > 0 ? Pe : Xe;
    }, oe.min = function(Pe, Xe) {
      return Pe.cmp(Xe) < 0 ? Pe : Xe;
    }, oe.prototype._init = function(Pe, Xe, ve) {
      if (typeof Pe == "number")
        return this._initNumber(Pe, Xe, ve);
      if (typeof Pe == "object")
        return this._initArray(Pe, Xe, ve);
      Xe === "hex" && (Xe = 16), ne(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), Pe = Pe.toString().replace(/\s+/g, "");
      var Ke = 0;
      Pe[0] === "-" && (Ke++, this.negative = 1), Ke < Pe.length && (Xe === 16 ? this._parseHex(Pe, Ke, ve) : (this._parseBase(Pe, Xe, Ke), ve === "le" && this._initArray(this.toArray(), Xe, ve)));
    }, oe.prototype._initNumber = function(Pe, Xe, ve) {
      Pe < 0 && (this.negative = 1, Pe = -Pe), Pe < 67108864 ? (this.words = [Pe & 67108863], this.length = 1) : Pe < 4503599627370496 ? (this.words = [
        Pe & 67108863,
        Pe / 67108864 & 67108863
      ], this.length = 2) : (ne(Pe < 9007199254740992), this.words = [
        Pe & 67108863,
        Pe / 67108864 & 67108863,
        1
      ], this.length = 3), ve === "le" && this._initArray(this.toArray(), Xe, ve);
    }, oe.prototype._initArray = function(Pe, Xe, ve) {
      if (ne(typeof Pe.length == "number"), Pe.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(Pe.length / 3), this.words = new Array(this.length);
      for (var Ke = 0; Ke < this.length; Ke++)
        this.words[Ke] = 0;
      var ht, wt, vt = 0;
      if (ve === "be")
        for (Ke = Pe.length - 1, ht = 0; Ke >= 0; Ke -= 3)
          wt = Pe[Ke] | Pe[Ke - 1] << 8 | Pe[Ke - 2] << 16, this.words[ht] |= wt << vt & 67108863, this.words[ht + 1] = wt >>> 26 - vt & 67108863, vt += 24, vt >= 26 && (vt -= 26, ht++);
      else if (ve === "le")
        for (Ke = 0, ht = 0; Ke < Pe.length; Ke += 3)
          wt = Pe[Ke] | Pe[Ke + 1] << 8 | Pe[Ke + 2] << 16, this.words[ht] |= wt << vt & 67108863, this.words[ht + 1] = wt >>> 26 - vt & 67108863, vt += 24, vt >= 26 && (vt -= 26, ht++);
      return this.strip();
    };
    function ae(kt, Pe) {
      var Xe = kt.charCodeAt(Pe);
      return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
    }
    function ge(kt, Pe, Xe) {
      var ve = ae(kt, Xe);
      return Xe - 1 >= Pe && (ve |= ae(kt, Xe - 1) << 4), ve;
    }
    oe.prototype._parseHex = function(Pe, Xe, ve) {
      this.length = Math.ceil((Pe.length - Xe) / 6), this.words = new Array(this.length);
      for (var Ke = 0; Ke < this.length; Ke++)
        this.words[Ke] = 0;
      var ht = 0, wt = 0, vt;
      if (ve === "be")
        for (Ke = Pe.length - 1; Ke >= Xe; Ke -= 2)
          vt = ge(Pe, Xe, Ke) << ht, this.words[wt] |= vt & 67108863, ht >= 18 ? (ht -= 18, wt += 1, this.words[wt] |= vt >>> 26) : ht += 8;
      else {
        var xt = Pe.length - Xe;
        for (Ke = xt % 2 === 0 ? Xe + 1 : Xe; Ke < Pe.length; Ke += 2)
          vt = ge(Pe, Xe, Ke) << ht, this.words[wt] |= vt & 67108863, ht >= 18 ? (ht -= 18, wt += 1, this.words[wt] |= vt >>> 26) : ht += 8;
      }
      this.strip();
    };
    function Ce(kt, Pe, Xe, ve) {
      for (var Ke = 0, ht = Math.min(kt.length, Xe), wt = Pe; wt < ht; wt++) {
        var vt = kt.charCodeAt(wt) - 48;
        Ke *= ve, vt >= 49 ? Ke += vt - 49 + 10 : vt >= 17 ? Ke += vt - 17 + 10 : Ke += vt;
      }
      return Ke;
    }
    oe.prototype._parseBase = function(Pe, Xe, ve) {
      this.words = [0], this.length = 1;
      for (var Ke = 0, ht = 1; ht <= 67108863; ht *= Xe)
        Ke++;
      Ke--, ht = ht / Xe | 0;
      for (var wt = Pe.length - ve, vt = wt % Ke, xt = Math.min(wt, wt - vt) + ve, Qe = 0, Rt = ve; Rt < xt; Rt += Ke)
        Qe = Ce(Pe, Rt, Rt + Ke, Xe), this.imuln(ht), this.words[0] + Qe < 67108864 ? this.words[0] += Qe : this._iaddn(Qe);
      if (vt !== 0) {
        var bt = 1;
        for (Qe = Ce(Pe, Rt, Pe.length, Xe), Rt = 0; Rt < vt; Rt++)
          bt *= Xe;
        this.imuln(bt), this.words[0] + Qe < 67108864 ? this.words[0] += Qe : this._iaddn(Qe);
      }
      this.strip();
    }, oe.prototype.copy = function(Pe) {
      Pe.words = new Array(this.length);
      for (var Xe = 0; Xe < this.length; Xe++)
        Pe.words[Xe] = this.words[Xe];
      Pe.length = this.length, Pe.negative = this.negative, Pe.red = this.red;
    }, oe.prototype.clone = function() {
      var Pe = new oe(null);
      return this.copy(Pe), Pe;
    }, oe.prototype._expand = function(Pe) {
      for (; this.length < Pe; )
        this.words[this.length++] = 0;
      return this;
    }, oe.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, oe.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, oe.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var le = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Je = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    oe.prototype.toString = function(Pe, Xe) {
      Pe = Pe || 10, Xe = Xe | 0 || 1;
      var ve;
      if (Pe === 16 || Pe === "hex") {
        ve = "";
        for (var Ke = 0, ht = 0, wt = 0; wt < this.length; wt++) {
          var vt = this.words[wt], xt = ((vt << Ke | ht) & 16777215).toString(16);
          ht = vt >>> 24 - Ke & 16777215, Ke += 2, Ke >= 26 && (Ke -= 26, wt--), ht !== 0 || wt !== this.length - 1 ? ve = le[6 - xt.length] + xt + ve : ve = xt + ve;
        }
        for (ht !== 0 && (ve = ht.toString(16) + ve); ve.length % Xe !== 0; )
          ve = "0" + ve;
        return this.negative !== 0 && (ve = "-" + ve), ve;
      }
      if (Pe === (Pe | 0) && Pe >= 2 && Pe <= 36) {
        var Qe = Ee[Pe], Rt = Je[Pe];
        ve = "";
        var bt = this.clone();
        for (bt.negative = 0; !bt.isZero(); ) {
          var Ht = bt.modn(Rt).toString(Pe);
          bt = bt.idivn(Rt), bt.isZero() ? ve = Ht + ve : ve = le[Qe - Ht.length] + Ht + ve;
        }
        for (this.isZero() && (ve = "0" + ve); ve.length % Xe !== 0; )
          ve = "0" + ve;
        return this.negative !== 0 && (ve = "-" + ve), ve;
      }
      ne(!1, "Base should be between 2 and 36");
    }, oe.prototype.toNumber = function() {
      var Pe = this.words[0];
      return this.length === 2 ? Pe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Pe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Pe : Pe;
    }, oe.prototype.toJSON = function() {
      return this.toString(16);
    }, oe.prototype.toBuffer = function(Pe, Xe) {
      return ne(typeof se < "u"), this.toArrayLike(se, Pe, Xe);
    }, oe.prototype.toArray = function(Pe, Xe) {
      return this.toArrayLike(Array, Pe, Xe);
    }, oe.prototype.toArrayLike = function(Pe, Xe, ve) {
      var Ke = this.byteLength(), ht = ve || Math.max(1, Ke);
      ne(Ke <= ht, "byte array longer than desired length"), ne(ht > 0, "Requested array length <= 0"), this.strip();
      var wt = Xe === "le", vt = new Pe(ht), xt, Qe, Rt = this.clone();
      if (wt) {
        for (Qe = 0; !Rt.isZero(); Qe++)
          xt = Rt.andln(255), Rt.iushrn(8), vt[Qe] = xt;
        for (; Qe < ht; Qe++)
          vt[Qe] = 0;
      } else {
        for (Qe = 0; Qe < ht - Ke; Qe++)
          vt[Qe] = 0;
        for (Qe = 0; !Rt.isZero(); Qe++)
          xt = Rt.andln(255), Rt.iushrn(8), vt[ht - Qe - 1] = xt;
      }
      return vt;
    }, Math.clz32 ? oe.prototype._countBits = function(Pe) {
      return 32 - Math.clz32(Pe);
    } : oe.prototype._countBits = function(Pe) {
      var Xe = Pe, ve = 0;
      return Xe >= 4096 && (ve += 13, Xe >>>= 13), Xe >= 64 && (ve += 7, Xe >>>= 7), Xe >= 8 && (ve += 4, Xe >>>= 4), Xe >= 2 && (ve += 2, Xe >>>= 2), ve + Xe;
    }, oe.prototype._zeroBits = function(Pe) {
      if (Pe === 0) return 26;
      var Xe = Pe, ve = 0;
      return Xe & 8191 || (ve += 13, Xe >>>= 13), Xe & 127 || (ve += 7, Xe >>>= 7), Xe & 15 || (ve += 4, Xe >>>= 4), Xe & 3 || (ve += 2, Xe >>>= 2), Xe & 1 || ve++, ve;
    }, oe.prototype.bitLength = function() {
      var Pe = this.words[this.length - 1], Xe = this._countBits(Pe);
      return (this.length - 1) * 26 + Xe;
    };
    function Ve(kt) {
      for (var Pe = new Array(kt.bitLength()), Xe = 0; Xe < Pe.length; Xe++) {
        var ve = Xe / 26 | 0, Ke = Xe % 26;
        Pe[Xe] = (kt.words[ve] & 1 << Ke) >>> Ke;
      }
      return Pe;
    }
    oe.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var Pe = 0, Xe = 0; Xe < this.length; Xe++) {
        var ve = this._zeroBits(this.words[Xe]);
        if (Pe += ve, ve !== 26) break;
      }
      return Pe;
    }, oe.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, oe.prototype.toTwos = function(Pe) {
      return this.negative !== 0 ? this.abs().inotn(Pe).iaddn(1) : this.clone();
    }, oe.prototype.fromTwos = function(Pe) {
      return this.testn(Pe - 1) ? this.notn(Pe).iaddn(1).ineg() : this.clone();
    }, oe.prototype.isNeg = function() {
      return this.negative !== 0;
    }, oe.prototype.neg = function() {
      return this.clone().ineg();
    }, oe.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, oe.prototype.iuor = function(Pe) {
      for (; this.length < Pe.length; )
        this.words[this.length++] = 0;
      for (var Xe = 0; Xe < Pe.length; Xe++)
        this.words[Xe] = this.words[Xe] | Pe.words[Xe];
      return this.strip();
    }, oe.prototype.ior = function(Pe) {
      return ne((this.negative | Pe.negative) === 0), this.iuor(Pe);
    }, oe.prototype.or = function(Pe) {
      return this.length > Pe.length ? this.clone().ior(Pe) : Pe.clone().ior(this);
    }, oe.prototype.uor = function(Pe) {
      return this.length > Pe.length ? this.clone().iuor(Pe) : Pe.clone().iuor(this);
    }, oe.prototype.iuand = function(Pe) {
      var Xe;
      this.length > Pe.length ? Xe = Pe : Xe = this;
      for (var ve = 0; ve < Xe.length; ve++)
        this.words[ve] = this.words[ve] & Pe.words[ve];
      return this.length = Xe.length, this.strip();
    }, oe.prototype.iand = function(Pe) {
      return ne((this.negative | Pe.negative) === 0), this.iuand(Pe);
    }, oe.prototype.and = function(Pe) {
      return this.length > Pe.length ? this.clone().iand(Pe) : Pe.clone().iand(this);
    }, oe.prototype.uand = function(Pe) {
      return this.length > Pe.length ? this.clone().iuand(Pe) : Pe.clone().iuand(this);
    }, oe.prototype.iuxor = function(Pe) {
      var Xe, ve;
      this.length > Pe.length ? (Xe = this, ve = Pe) : (Xe = Pe, ve = this);
      for (var Ke = 0; Ke < ve.length; Ke++)
        this.words[Ke] = Xe.words[Ke] ^ ve.words[Ke];
      if (this !== Xe)
        for (; Ke < Xe.length; Ke++)
          this.words[Ke] = Xe.words[Ke];
      return this.length = Xe.length, this.strip();
    }, oe.prototype.ixor = function(Pe) {
      return ne((this.negative | Pe.negative) === 0), this.iuxor(Pe);
    }, oe.prototype.xor = function(Pe) {
      return this.length > Pe.length ? this.clone().ixor(Pe) : Pe.clone().ixor(this);
    }, oe.prototype.uxor = function(Pe) {
      return this.length > Pe.length ? this.clone().iuxor(Pe) : Pe.clone().iuxor(this);
    }, oe.prototype.inotn = function(Pe) {
      ne(typeof Pe == "number" && Pe >= 0);
      var Xe = Math.ceil(Pe / 26) | 0, ve = Pe % 26;
      this._expand(Xe), ve > 0 && Xe--;
      for (var Ke = 0; Ke < Xe; Ke++)
        this.words[Ke] = ~this.words[Ke] & 67108863;
      return ve > 0 && (this.words[Ke] = ~this.words[Ke] & 67108863 >> 26 - ve), this.strip();
    }, oe.prototype.notn = function(Pe) {
      return this.clone().inotn(Pe);
    }, oe.prototype.setn = function(Pe, Xe) {
      ne(typeof Pe == "number" && Pe >= 0);
      var ve = Pe / 26 | 0, Ke = Pe % 26;
      return this._expand(ve + 1), Xe ? this.words[ve] = this.words[ve] | 1 << Ke : this.words[ve] = this.words[ve] & ~(1 << Ke), this.strip();
    }, oe.prototype.iadd = function(Pe) {
      var Xe;
      if (this.negative !== 0 && Pe.negative === 0)
        return this.negative = 0, Xe = this.isub(Pe), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && Pe.negative !== 0)
        return Pe.negative = 0, Xe = this.isub(Pe), Pe.negative = 1, Xe._normSign();
      var ve, Ke;
      this.length > Pe.length ? (ve = this, Ke = Pe) : (ve = Pe, Ke = this);
      for (var ht = 0, wt = 0; wt < Ke.length; wt++)
        Xe = (ve.words[wt] | 0) + (Ke.words[wt] | 0) + ht, this.words[wt] = Xe & 67108863, ht = Xe >>> 26;
      for (; ht !== 0 && wt < ve.length; wt++)
        Xe = (ve.words[wt] | 0) + ht, this.words[wt] = Xe & 67108863, ht = Xe >>> 26;
      if (this.length = ve.length, ht !== 0)
        this.words[this.length] = ht, this.length++;
      else if (ve !== this)
        for (; wt < ve.length; wt++)
          this.words[wt] = ve.words[wt];
      return this;
    }, oe.prototype.add = function(Pe) {
      var Xe;
      return Pe.negative !== 0 && this.negative === 0 ? (Pe.negative = 0, Xe = this.sub(Pe), Pe.negative ^= 1, Xe) : Pe.negative === 0 && this.negative !== 0 ? (this.negative = 0, Xe = Pe.sub(this), this.negative = 1, Xe) : this.length > Pe.length ? this.clone().iadd(Pe) : Pe.clone().iadd(this);
    }, oe.prototype.isub = function(Pe) {
      if (Pe.negative !== 0) {
        Pe.negative = 0;
        var Xe = this.iadd(Pe);
        return Pe.negative = 1, Xe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(Pe), this.negative = 1, this._normSign();
      var ve = this.cmp(Pe);
      if (ve === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Ke, ht;
      ve > 0 ? (Ke = this, ht = Pe) : (Ke = Pe, ht = this);
      for (var wt = 0, vt = 0; vt < ht.length; vt++)
        Xe = (Ke.words[vt] | 0) - (ht.words[vt] | 0) + wt, wt = Xe >> 26, this.words[vt] = Xe & 67108863;
      for (; wt !== 0 && vt < Ke.length; vt++)
        Xe = (Ke.words[vt] | 0) + wt, wt = Xe >> 26, this.words[vt] = Xe & 67108863;
      if (wt === 0 && vt < Ke.length && Ke !== this)
        for (; vt < Ke.length; vt++)
          this.words[vt] = Ke.words[vt];
      return this.length = Math.max(this.length, vt), Ke !== this && (this.negative = 1), this.strip();
    }, oe.prototype.sub = function(Pe) {
      return this.clone().isub(Pe);
    };
    function $t(kt, Pe, Xe) {
      Xe.negative = Pe.negative ^ kt.negative;
      var ve = kt.length + Pe.length | 0;
      Xe.length = ve, ve = ve - 1 | 0;
      var Ke = kt.words[0] | 0, ht = Pe.words[0] | 0, wt = Ke * ht, vt = wt & 67108863, xt = wt / 67108864 | 0;
      Xe.words[0] = vt;
      for (var Qe = 1; Qe < ve; Qe++) {
        for (var Rt = xt >>> 26, bt = xt & 67108863, Ht = Math.min(Qe, Pe.length - 1), ar = Math.max(0, Qe - kt.length + 1); ar <= Ht; ar++) {
          var yr = Qe - ar | 0;
          Ke = kt.words[yr] | 0, ht = Pe.words[ar] | 0, wt = Ke * ht + bt, Rt += wt / 67108864 | 0, bt = wt & 67108863;
        }
        Xe.words[Qe] = bt | 0, xt = Rt | 0;
      }
      return xt !== 0 ? Xe.words[Qe] = xt | 0 : Xe.length--, Xe.strip();
    }
    var Nt = function(Pe, Xe, ve) {
      var Ke = Pe.words, ht = Xe.words, wt = ve.words, vt = 0, xt, Qe, Rt, bt = Ke[0] | 0, Ht = bt & 8191, ar = bt >>> 13, yr = Ke[1] | 0, rr = yr & 8191, Kt = yr >>> 13, Gt = Ke[2] | 0, ur = Gt & 8191, gr = Gt >>> 13, Qt = Ke[3] | 0, Jt = Qt & 8191, br = Qt >>> 13, Sr = Ke[4] | 0, Ar = Sr & 8191, Br = Sr >>> 13, Mr = Ke[5] | 0, Cr = Mr & 8191, $r = Mr >>> 13, Qr = Ke[6] | 0, jr = Qr & 8191, qr = Qr >>> 13, Gr = Ke[7] | 0, Or = Gr & 8191, Vr = Gr >>> 13, Zr = Ke[8] | 0, Lr = Zr & 8191, Yr = Zr >>> 13, en = Ke[9] | 0, zt = en & 8191, Ot = en >>> 13, Ut = ht[0] | 0, tr = Ut & 8191, lr = Ut >>> 13, vr = ht[1] | 0, _r = vr & 8191, Rr = vr >>> 13, Wr = ht[2] | 0, Ir = Wr & 8191, Hr = Wr >>> 13, Fr = ht[3] | 0, Nr = Fr & 8191, Jr = Fr >>> 13, nn = ht[4] | 0, fr = nn & 8191, er = nn >>> 13, cr = ht[5] | 0, Ft = cr & 8191, _t = cr >>> 13, Bt = ht[6] | 0, Xt = Bt & 8191, ir = Bt >>> 13, dr = ht[7] | 0, pr = dr & 8191, xr = dr >>> 13, Tr = ht[8] | 0, nr = Tr & 8191, wr = Tr >>> 13, Er = ht[9] | 0, Pr = Er & 8191, Dr = Er >>> 13;
      ve.negative = Pe.negative ^ Xe.negative, ve.length = 19, xt = Math.imul(Ht, tr), Qe = Math.imul(Ht, lr), Qe = Qe + Math.imul(ar, tr) | 0, Rt = Math.imul(ar, lr);
      var Ur = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, xt = Math.imul(rr, tr), Qe = Math.imul(rr, lr), Qe = Qe + Math.imul(Kt, tr) | 0, Rt = Math.imul(Kt, lr), xt = xt + Math.imul(Ht, _r) | 0, Qe = Qe + Math.imul(Ht, Rr) | 0, Qe = Qe + Math.imul(ar, _r) | 0, Rt = Rt + Math.imul(ar, Rr) | 0;
      var kr = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, xt = Math.imul(ur, tr), Qe = Math.imul(ur, lr), Qe = Qe + Math.imul(gr, tr) | 0, Rt = Math.imul(gr, lr), xt = xt + Math.imul(rr, _r) | 0, Qe = Qe + Math.imul(rr, Rr) | 0, Qe = Qe + Math.imul(Kt, _r) | 0, Rt = Rt + Math.imul(Kt, Rr) | 0, xt = xt + Math.imul(Ht, Ir) | 0, Qe = Qe + Math.imul(Ht, Hr) | 0, Qe = Qe + Math.imul(ar, Ir) | 0, Rt = Rt + Math.imul(ar, Hr) | 0;
      var Xr = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, xt = Math.imul(Jt, tr), Qe = Math.imul(Jt, lr), Qe = Qe + Math.imul(br, tr) | 0, Rt = Math.imul(br, lr), xt = xt + Math.imul(ur, _r) | 0, Qe = Qe + Math.imul(ur, Rr) | 0, Qe = Qe + Math.imul(gr, _r) | 0, Rt = Rt + Math.imul(gr, Rr) | 0, xt = xt + Math.imul(rr, Ir) | 0, Qe = Qe + Math.imul(rr, Hr) | 0, Qe = Qe + Math.imul(Kt, Ir) | 0, Rt = Rt + Math.imul(Kt, Hr) | 0, xt = xt + Math.imul(Ht, Nr) | 0, Qe = Qe + Math.imul(Ht, Jr) | 0, Qe = Qe + Math.imul(ar, Nr) | 0, Rt = Rt + Math.imul(ar, Jr) | 0;
      var sn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, xt = Math.imul(Ar, tr), Qe = Math.imul(Ar, lr), Qe = Qe + Math.imul(Br, tr) | 0, Rt = Math.imul(Br, lr), xt = xt + Math.imul(Jt, _r) | 0, Qe = Qe + Math.imul(Jt, Rr) | 0, Qe = Qe + Math.imul(br, _r) | 0, Rt = Rt + Math.imul(br, Rr) | 0, xt = xt + Math.imul(ur, Ir) | 0, Qe = Qe + Math.imul(ur, Hr) | 0, Qe = Qe + Math.imul(gr, Ir) | 0, Rt = Rt + Math.imul(gr, Hr) | 0, xt = xt + Math.imul(rr, Nr) | 0, Qe = Qe + Math.imul(rr, Jr) | 0, Qe = Qe + Math.imul(Kt, Nr) | 0, Rt = Rt + Math.imul(Kt, Jr) | 0, xt = xt + Math.imul(Ht, fr) | 0, Qe = Qe + Math.imul(Ht, er) | 0, Qe = Qe + Math.imul(ar, fr) | 0, Rt = Rt + Math.imul(ar, er) | 0;
      var tn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, xt = Math.imul(Cr, tr), Qe = Math.imul(Cr, lr), Qe = Qe + Math.imul($r, tr) | 0, Rt = Math.imul($r, lr), xt = xt + Math.imul(Ar, _r) | 0, Qe = Qe + Math.imul(Ar, Rr) | 0, Qe = Qe + Math.imul(Br, _r) | 0, Rt = Rt + Math.imul(Br, Rr) | 0, xt = xt + Math.imul(Jt, Ir) | 0, Qe = Qe + Math.imul(Jt, Hr) | 0, Qe = Qe + Math.imul(br, Ir) | 0, Rt = Rt + Math.imul(br, Hr) | 0, xt = xt + Math.imul(ur, Nr) | 0, Qe = Qe + Math.imul(ur, Jr) | 0, Qe = Qe + Math.imul(gr, Nr) | 0, Rt = Rt + Math.imul(gr, Jr) | 0, xt = xt + Math.imul(rr, fr) | 0, Qe = Qe + Math.imul(rr, er) | 0, Qe = Qe + Math.imul(Kt, fr) | 0, Rt = Rt + Math.imul(Kt, er) | 0, xt = xt + Math.imul(Ht, Ft) | 0, Qe = Qe + Math.imul(Ht, _t) | 0, Qe = Qe + Math.imul(ar, Ft) | 0, Rt = Rt + Math.imul(ar, _t) | 0;
      var on = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, xt = Math.imul(jr, tr), Qe = Math.imul(jr, lr), Qe = Qe + Math.imul(qr, tr) | 0, Rt = Math.imul(qr, lr), xt = xt + Math.imul(Cr, _r) | 0, Qe = Qe + Math.imul(Cr, Rr) | 0, Qe = Qe + Math.imul($r, _r) | 0, Rt = Rt + Math.imul($r, Rr) | 0, xt = xt + Math.imul(Ar, Ir) | 0, Qe = Qe + Math.imul(Ar, Hr) | 0, Qe = Qe + Math.imul(Br, Ir) | 0, Rt = Rt + Math.imul(Br, Hr) | 0, xt = xt + Math.imul(Jt, Nr) | 0, Qe = Qe + Math.imul(Jt, Jr) | 0, Qe = Qe + Math.imul(br, Nr) | 0, Rt = Rt + Math.imul(br, Jr) | 0, xt = xt + Math.imul(ur, fr) | 0, Qe = Qe + Math.imul(ur, er) | 0, Qe = Qe + Math.imul(gr, fr) | 0, Rt = Rt + Math.imul(gr, er) | 0, xt = xt + Math.imul(rr, Ft) | 0, Qe = Qe + Math.imul(rr, _t) | 0, Qe = Qe + Math.imul(Kt, Ft) | 0, Rt = Rt + Math.imul(Kt, _t) | 0, xt = xt + Math.imul(Ht, Xt) | 0, Qe = Qe + Math.imul(Ht, ir) | 0, Qe = Qe + Math.imul(ar, Xt) | 0, Rt = Rt + Math.imul(ar, ir) | 0;
      var cn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, xt = Math.imul(Or, tr), Qe = Math.imul(Or, lr), Qe = Qe + Math.imul(Vr, tr) | 0, Rt = Math.imul(Vr, lr), xt = xt + Math.imul(jr, _r) | 0, Qe = Qe + Math.imul(jr, Rr) | 0, Qe = Qe + Math.imul(qr, _r) | 0, Rt = Rt + Math.imul(qr, Rr) | 0, xt = xt + Math.imul(Cr, Ir) | 0, Qe = Qe + Math.imul(Cr, Hr) | 0, Qe = Qe + Math.imul($r, Ir) | 0, Rt = Rt + Math.imul($r, Hr) | 0, xt = xt + Math.imul(Ar, Nr) | 0, Qe = Qe + Math.imul(Ar, Jr) | 0, Qe = Qe + Math.imul(Br, Nr) | 0, Rt = Rt + Math.imul(Br, Jr) | 0, xt = xt + Math.imul(Jt, fr) | 0, Qe = Qe + Math.imul(Jt, er) | 0, Qe = Qe + Math.imul(br, fr) | 0, Rt = Rt + Math.imul(br, er) | 0, xt = xt + Math.imul(ur, Ft) | 0, Qe = Qe + Math.imul(ur, _t) | 0, Qe = Qe + Math.imul(gr, Ft) | 0, Rt = Rt + Math.imul(gr, _t) | 0, xt = xt + Math.imul(rr, Xt) | 0, Qe = Qe + Math.imul(rr, ir) | 0, Qe = Qe + Math.imul(Kt, Xt) | 0, Rt = Rt + Math.imul(Kt, ir) | 0, xt = xt + Math.imul(Ht, pr) | 0, Qe = Qe + Math.imul(Ht, xr) | 0, Qe = Qe + Math.imul(ar, pr) | 0, Rt = Rt + Math.imul(ar, xr) | 0;
      var ln = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, xt = Math.imul(Lr, tr), Qe = Math.imul(Lr, lr), Qe = Qe + Math.imul(Yr, tr) | 0, Rt = Math.imul(Yr, lr), xt = xt + Math.imul(Or, _r) | 0, Qe = Qe + Math.imul(Or, Rr) | 0, Qe = Qe + Math.imul(Vr, _r) | 0, Rt = Rt + Math.imul(Vr, Rr) | 0, xt = xt + Math.imul(jr, Ir) | 0, Qe = Qe + Math.imul(jr, Hr) | 0, Qe = Qe + Math.imul(qr, Ir) | 0, Rt = Rt + Math.imul(qr, Hr) | 0, xt = xt + Math.imul(Cr, Nr) | 0, Qe = Qe + Math.imul(Cr, Jr) | 0, Qe = Qe + Math.imul($r, Nr) | 0, Rt = Rt + Math.imul($r, Jr) | 0, xt = xt + Math.imul(Ar, fr) | 0, Qe = Qe + Math.imul(Ar, er) | 0, Qe = Qe + Math.imul(Br, fr) | 0, Rt = Rt + Math.imul(Br, er) | 0, xt = xt + Math.imul(Jt, Ft) | 0, Qe = Qe + Math.imul(Jt, _t) | 0, Qe = Qe + Math.imul(br, Ft) | 0, Rt = Rt + Math.imul(br, _t) | 0, xt = xt + Math.imul(ur, Xt) | 0, Qe = Qe + Math.imul(ur, ir) | 0, Qe = Qe + Math.imul(gr, Xt) | 0, Rt = Rt + Math.imul(gr, ir) | 0, xt = xt + Math.imul(rr, pr) | 0, Qe = Qe + Math.imul(rr, xr) | 0, Qe = Qe + Math.imul(Kt, pr) | 0, Rt = Rt + Math.imul(Kt, xr) | 0, xt = xt + Math.imul(Ht, nr) | 0, Qe = Qe + Math.imul(Ht, wr) | 0, Qe = Qe + Math.imul(ar, nr) | 0, Rt = Rt + Math.imul(ar, wr) | 0;
      var un = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, xt = Math.imul(zt, tr), Qe = Math.imul(zt, lr), Qe = Qe + Math.imul(Ot, tr) | 0, Rt = Math.imul(Ot, lr), xt = xt + Math.imul(Lr, _r) | 0, Qe = Qe + Math.imul(Lr, Rr) | 0, Qe = Qe + Math.imul(Yr, _r) | 0, Rt = Rt + Math.imul(Yr, Rr) | 0, xt = xt + Math.imul(Or, Ir) | 0, Qe = Qe + Math.imul(Or, Hr) | 0, Qe = Qe + Math.imul(Vr, Ir) | 0, Rt = Rt + Math.imul(Vr, Hr) | 0, xt = xt + Math.imul(jr, Nr) | 0, Qe = Qe + Math.imul(jr, Jr) | 0, Qe = Qe + Math.imul(qr, Nr) | 0, Rt = Rt + Math.imul(qr, Jr) | 0, xt = xt + Math.imul(Cr, fr) | 0, Qe = Qe + Math.imul(Cr, er) | 0, Qe = Qe + Math.imul($r, fr) | 0, Rt = Rt + Math.imul($r, er) | 0, xt = xt + Math.imul(Ar, Ft) | 0, Qe = Qe + Math.imul(Ar, _t) | 0, Qe = Qe + Math.imul(Br, Ft) | 0, Rt = Rt + Math.imul(Br, _t) | 0, xt = xt + Math.imul(Jt, Xt) | 0, Qe = Qe + Math.imul(Jt, ir) | 0, Qe = Qe + Math.imul(br, Xt) | 0, Rt = Rt + Math.imul(br, ir) | 0, xt = xt + Math.imul(ur, pr) | 0, Qe = Qe + Math.imul(ur, xr) | 0, Qe = Qe + Math.imul(gr, pr) | 0, Rt = Rt + Math.imul(gr, xr) | 0, xt = xt + Math.imul(rr, nr) | 0, Qe = Qe + Math.imul(rr, wr) | 0, Qe = Qe + Math.imul(Kt, nr) | 0, Rt = Rt + Math.imul(Kt, wr) | 0, xt = xt + Math.imul(Ht, Pr) | 0, Qe = Qe + Math.imul(Ht, Dr) | 0, Qe = Qe + Math.imul(ar, Pr) | 0, Rt = Rt + Math.imul(ar, Dr) | 0;
      var an = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, xt = Math.imul(zt, _r), Qe = Math.imul(zt, Rr), Qe = Qe + Math.imul(Ot, _r) | 0, Rt = Math.imul(Ot, Rr), xt = xt + Math.imul(Lr, Ir) | 0, Qe = Qe + Math.imul(Lr, Hr) | 0, Qe = Qe + Math.imul(Yr, Ir) | 0, Rt = Rt + Math.imul(Yr, Hr) | 0, xt = xt + Math.imul(Or, Nr) | 0, Qe = Qe + Math.imul(Or, Jr) | 0, Qe = Qe + Math.imul(Vr, Nr) | 0, Rt = Rt + Math.imul(Vr, Jr) | 0, xt = xt + Math.imul(jr, fr) | 0, Qe = Qe + Math.imul(jr, er) | 0, Qe = Qe + Math.imul(qr, fr) | 0, Rt = Rt + Math.imul(qr, er) | 0, xt = xt + Math.imul(Cr, Ft) | 0, Qe = Qe + Math.imul(Cr, _t) | 0, Qe = Qe + Math.imul($r, Ft) | 0, Rt = Rt + Math.imul($r, _t) | 0, xt = xt + Math.imul(Ar, Xt) | 0, Qe = Qe + Math.imul(Ar, ir) | 0, Qe = Qe + Math.imul(Br, Xt) | 0, Rt = Rt + Math.imul(Br, ir) | 0, xt = xt + Math.imul(Jt, pr) | 0, Qe = Qe + Math.imul(Jt, xr) | 0, Qe = Qe + Math.imul(br, pr) | 0, Rt = Rt + Math.imul(br, xr) | 0, xt = xt + Math.imul(ur, nr) | 0, Qe = Qe + Math.imul(ur, wr) | 0, Qe = Qe + Math.imul(gr, nr) | 0, Rt = Rt + Math.imul(gr, wr) | 0, xt = xt + Math.imul(rr, Pr) | 0, Qe = Qe + Math.imul(rr, Dr) | 0, Qe = Qe + Math.imul(Kt, Pr) | 0, Rt = Rt + Math.imul(Kt, Dr) | 0;
      var dn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, xt = Math.imul(zt, Ir), Qe = Math.imul(zt, Hr), Qe = Qe + Math.imul(Ot, Ir) | 0, Rt = Math.imul(Ot, Hr), xt = xt + Math.imul(Lr, Nr) | 0, Qe = Qe + Math.imul(Lr, Jr) | 0, Qe = Qe + Math.imul(Yr, Nr) | 0, Rt = Rt + Math.imul(Yr, Jr) | 0, xt = xt + Math.imul(Or, fr) | 0, Qe = Qe + Math.imul(Or, er) | 0, Qe = Qe + Math.imul(Vr, fr) | 0, Rt = Rt + Math.imul(Vr, er) | 0, xt = xt + Math.imul(jr, Ft) | 0, Qe = Qe + Math.imul(jr, _t) | 0, Qe = Qe + Math.imul(qr, Ft) | 0, Rt = Rt + Math.imul(qr, _t) | 0, xt = xt + Math.imul(Cr, Xt) | 0, Qe = Qe + Math.imul(Cr, ir) | 0, Qe = Qe + Math.imul($r, Xt) | 0, Rt = Rt + Math.imul($r, ir) | 0, xt = xt + Math.imul(Ar, pr) | 0, Qe = Qe + Math.imul(Ar, xr) | 0, Qe = Qe + Math.imul(Br, pr) | 0, Rt = Rt + Math.imul(Br, xr) | 0, xt = xt + Math.imul(Jt, nr) | 0, Qe = Qe + Math.imul(Jt, wr) | 0, Qe = Qe + Math.imul(br, nr) | 0, Rt = Rt + Math.imul(br, wr) | 0, xt = xt + Math.imul(ur, Pr) | 0, Qe = Qe + Math.imul(ur, Dr) | 0, Qe = Qe + Math.imul(gr, Pr) | 0, Rt = Rt + Math.imul(gr, Dr) | 0;
      var hn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, xt = Math.imul(zt, Nr), Qe = Math.imul(zt, Jr), Qe = Qe + Math.imul(Ot, Nr) | 0, Rt = Math.imul(Ot, Jr), xt = xt + Math.imul(Lr, fr) | 0, Qe = Qe + Math.imul(Lr, er) | 0, Qe = Qe + Math.imul(Yr, fr) | 0, Rt = Rt + Math.imul(Yr, er) | 0, xt = xt + Math.imul(Or, Ft) | 0, Qe = Qe + Math.imul(Or, _t) | 0, Qe = Qe + Math.imul(Vr, Ft) | 0, Rt = Rt + Math.imul(Vr, _t) | 0, xt = xt + Math.imul(jr, Xt) | 0, Qe = Qe + Math.imul(jr, ir) | 0, Qe = Qe + Math.imul(qr, Xt) | 0, Rt = Rt + Math.imul(qr, ir) | 0, xt = xt + Math.imul(Cr, pr) | 0, Qe = Qe + Math.imul(Cr, xr) | 0, Qe = Qe + Math.imul($r, pr) | 0, Rt = Rt + Math.imul($r, xr) | 0, xt = xt + Math.imul(Ar, nr) | 0, Qe = Qe + Math.imul(Ar, wr) | 0, Qe = Qe + Math.imul(Br, nr) | 0, Rt = Rt + Math.imul(Br, wr) | 0, xt = xt + Math.imul(Jt, Pr) | 0, Qe = Qe + Math.imul(Jt, Dr) | 0, Qe = Qe + Math.imul(br, Pr) | 0, Rt = Rt + Math.imul(br, Dr) | 0;
      var pn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, xt = Math.imul(zt, fr), Qe = Math.imul(zt, er), Qe = Qe + Math.imul(Ot, fr) | 0, Rt = Math.imul(Ot, er), xt = xt + Math.imul(Lr, Ft) | 0, Qe = Qe + Math.imul(Lr, _t) | 0, Qe = Qe + Math.imul(Yr, Ft) | 0, Rt = Rt + Math.imul(Yr, _t) | 0, xt = xt + Math.imul(Or, Xt) | 0, Qe = Qe + Math.imul(Or, ir) | 0, Qe = Qe + Math.imul(Vr, Xt) | 0, Rt = Rt + Math.imul(Vr, ir) | 0, xt = xt + Math.imul(jr, pr) | 0, Qe = Qe + Math.imul(jr, xr) | 0, Qe = Qe + Math.imul(qr, pr) | 0, Rt = Rt + Math.imul(qr, xr) | 0, xt = xt + Math.imul(Cr, nr) | 0, Qe = Qe + Math.imul(Cr, wr) | 0, Qe = Qe + Math.imul($r, nr) | 0, Rt = Rt + Math.imul($r, wr) | 0, xt = xt + Math.imul(Ar, Pr) | 0, Qe = Qe + Math.imul(Ar, Dr) | 0, Qe = Qe + Math.imul(Br, Pr) | 0, Rt = Rt + Math.imul(Br, Dr) | 0;
      var yn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, xt = Math.imul(zt, Ft), Qe = Math.imul(zt, _t), Qe = Qe + Math.imul(Ot, Ft) | 0, Rt = Math.imul(Ot, _t), xt = xt + Math.imul(Lr, Xt) | 0, Qe = Qe + Math.imul(Lr, ir) | 0, Qe = Qe + Math.imul(Yr, Xt) | 0, Rt = Rt + Math.imul(Yr, ir) | 0, xt = xt + Math.imul(Or, pr) | 0, Qe = Qe + Math.imul(Or, xr) | 0, Qe = Qe + Math.imul(Vr, pr) | 0, Rt = Rt + Math.imul(Vr, xr) | 0, xt = xt + Math.imul(jr, nr) | 0, Qe = Qe + Math.imul(jr, wr) | 0, Qe = Qe + Math.imul(qr, nr) | 0, Rt = Rt + Math.imul(qr, wr) | 0, xt = xt + Math.imul(Cr, Pr) | 0, Qe = Qe + Math.imul(Cr, Dr) | 0, Qe = Qe + Math.imul($r, Pr) | 0, Rt = Rt + Math.imul($r, Dr) | 0;
      var mn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, xt = Math.imul(zt, Xt), Qe = Math.imul(zt, ir), Qe = Qe + Math.imul(Ot, Xt) | 0, Rt = Math.imul(Ot, ir), xt = xt + Math.imul(Lr, pr) | 0, Qe = Qe + Math.imul(Lr, xr) | 0, Qe = Qe + Math.imul(Yr, pr) | 0, Rt = Rt + Math.imul(Yr, xr) | 0, xt = xt + Math.imul(Or, nr) | 0, Qe = Qe + Math.imul(Or, wr) | 0, Qe = Qe + Math.imul(Vr, nr) | 0, Rt = Rt + Math.imul(Vr, wr) | 0, xt = xt + Math.imul(jr, Pr) | 0, Qe = Qe + Math.imul(jr, Dr) | 0, Qe = Qe + Math.imul(qr, Pr) | 0, Rt = Rt + Math.imul(qr, Dr) | 0;
      var gn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, xt = Math.imul(zt, pr), Qe = Math.imul(zt, xr), Qe = Qe + Math.imul(Ot, pr) | 0, Rt = Math.imul(Ot, xr), xt = xt + Math.imul(Lr, nr) | 0, Qe = Qe + Math.imul(Lr, wr) | 0, Qe = Qe + Math.imul(Yr, nr) | 0, Rt = Rt + Math.imul(Yr, wr) | 0, xt = xt + Math.imul(Or, Pr) | 0, Qe = Qe + Math.imul(Or, Dr) | 0, Qe = Qe + Math.imul(Vr, Pr) | 0, Rt = Rt + Math.imul(Vr, Dr) | 0;
      var vn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, xt = Math.imul(zt, nr), Qe = Math.imul(zt, wr), Qe = Qe + Math.imul(Ot, nr) | 0, Rt = Math.imul(Ot, wr), xt = xt + Math.imul(Lr, Pr) | 0, Qe = Qe + Math.imul(Lr, Dr) | 0, Qe = Qe + Math.imul(Yr, Pr) | 0, Rt = Rt + Math.imul(Yr, Dr) | 0;
      var wn = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      vt = (Rt + (Qe >>> 13) | 0) + (wn >>> 26) | 0, wn &= 67108863, xt = Math.imul(zt, Pr), Qe = Math.imul(zt, Dr), Qe = Qe + Math.imul(Ot, Pr) | 0, Rt = Math.imul(Ot, Dr);
      var _n = (vt + xt | 0) + ((Qe & 8191) << 13) | 0;
      return vt = (Rt + (Qe >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, wt[0] = Ur, wt[1] = kr, wt[2] = Xr, wt[3] = sn, wt[4] = tn, wt[5] = on, wt[6] = cn, wt[7] = ln, wt[8] = un, wt[9] = an, wt[10] = dn, wt[11] = hn, wt[12] = pn, wt[13] = yn, wt[14] = mn, wt[15] = gn, wt[16] = vn, wt[17] = wn, wt[18] = _n, vt !== 0 && (wt[19] = vt, ve.length++), ve;
    };
    Math.imul || (Nt = $t);
    function Dt(kt, Pe, Xe) {
      Xe.negative = Pe.negative ^ kt.negative, Xe.length = kt.length + Pe.length;
      for (var ve = 0, Ke = 0, ht = 0; ht < Xe.length - 1; ht++) {
        var wt = Ke;
        Ke = 0;
        for (var vt = ve & 67108863, xt = Math.min(ht, Pe.length - 1), Qe = Math.max(0, ht - kt.length + 1); Qe <= xt; Qe++) {
          var Rt = ht - Qe, bt = kt.words[Rt] | 0, Ht = Pe.words[Qe] | 0, ar = bt * Ht, yr = ar & 67108863;
          wt = wt + (ar / 67108864 | 0) | 0, yr = yr + vt | 0, vt = yr & 67108863, wt = wt + (yr >>> 26) | 0, Ke += wt >>> 26, wt &= 67108863;
        }
        Xe.words[ht] = vt, ve = wt, wt = Ke;
      }
      return ve !== 0 ? Xe.words[ht] = ve : Xe.length--, Xe.strip();
    }
    function Wt(kt, Pe, Xe) {
      var ve = new Pt();
      return ve.mulp(kt, Pe, Xe);
    }
    oe.prototype.mulTo = function(Pe, Xe) {
      var ve, Ke = this.length + Pe.length;
      return this.length === 10 && Pe.length === 10 ? ve = Nt(this, Pe, Xe) : Ke < 63 ? ve = $t(this, Pe, Xe) : Ke < 1024 ? ve = Dt(this, Pe, Xe) : ve = Wt(this, Pe, Xe), ve;
    };
    function Pt(kt, Pe) {
      this.x = kt, this.y = Pe;
    }
    Pt.prototype.makeRBT = function(Pe) {
      for (var Xe = new Array(Pe), ve = oe.prototype._countBits(Pe) - 1, Ke = 0; Ke < Pe; Ke++)
        Xe[Ke] = this.revBin(Ke, ve, Pe);
      return Xe;
    }, Pt.prototype.revBin = function(Pe, Xe, ve) {
      if (Pe === 0 || Pe === ve - 1) return Pe;
      for (var Ke = 0, ht = 0; ht < Xe; ht++)
        Ke |= (Pe & 1) << Xe - ht - 1, Pe >>= 1;
      return Ke;
    }, Pt.prototype.permute = function(Pe, Xe, ve, Ke, ht, wt) {
      for (var vt = 0; vt < wt; vt++)
        Ke[vt] = Xe[Pe[vt]], ht[vt] = ve[Pe[vt]];
    }, Pt.prototype.transform = function(Pe, Xe, ve, Ke, ht, wt) {
      this.permute(wt, Pe, Xe, ve, Ke, ht);
      for (var vt = 1; vt < ht; vt <<= 1)
        for (var xt = vt << 1, Qe = Math.cos(2 * Math.PI / xt), Rt = Math.sin(2 * Math.PI / xt), bt = 0; bt < ht; bt += xt)
          for (var Ht = Qe, ar = Rt, yr = 0; yr < vt; yr++) {
            var rr = ve[bt + yr], Kt = Ke[bt + yr], Gt = ve[bt + yr + vt], ur = Ke[bt + yr + vt], gr = Ht * Gt - ar * ur;
            ur = Ht * ur + ar * Gt, Gt = gr, ve[bt + yr] = rr + Gt, Ke[bt + yr] = Kt + ur, ve[bt + yr + vt] = rr - Gt, Ke[bt + yr + vt] = Kt - ur, yr !== xt && (gr = Qe * Ht - Rt * ar, ar = Qe * ar + Rt * Ht, Ht = gr);
          }
    }, Pt.prototype.guessLen13b = function(Pe, Xe) {
      var ve = Math.max(Xe, Pe) | 1, Ke = ve & 1, ht = 0;
      for (ve = ve / 2 | 0; ve; ve = ve >>> 1)
        ht++;
      return 1 << ht + 1 + Ke;
    }, Pt.prototype.conjugate = function(Pe, Xe, ve) {
      if (!(ve <= 1))
        for (var Ke = 0; Ke < ve / 2; Ke++) {
          var ht = Pe[Ke];
          Pe[Ke] = Pe[ve - Ke - 1], Pe[ve - Ke - 1] = ht, ht = Xe[Ke], Xe[Ke] = -Xe[ve - Ke - 1], Xe[ve - Ke - 1] = -ht;
        }
    }, Pt.prototype.normalize13b = function(Pe, Xe) {
      for (var ve = 0, Ke = 0; Ke < Xe / 2; Ke++) {
        var ht = Math.round(Pe[2 * Ke + 1] / Xe) * 8192 + Math.round(Pe[2 * Ke] / Xe) + ve;
        Pe[Ke] = ht & 67108863, ht < 67108864 ? ve = 0 : ve = ht / 67108864 | 0;
      }
      return Pe;
    }, Pt.prototype.convert13b = function(Pe, Xe, ve, Ke) {
      for (var ht = 0, wt = 0; wt < Xe; wt++)
        ht = ht + (Pe[wt] | 0), ve[2 * wt] = ht & 8191, ht = ht >>> 13, ve[2 * wt + 1] = ht & 8191, ht = ht >>> 13;
      for (wt = 2 * Xe; wt < Ke; ++wt)
        ve[wt] = 0;
      ne(ht === 0), ne((ht & -8192) === 0);
    }, Pt.prototype.stub = function(Pe) {
      for (var Xe = new Array(Pe), ve = 0; ve < Pe; ve++)
        Xe[ve] = 0;
      return Xe;
    }, Pt.prototype.mulp = function(Pe, Xe, ve) {
      var Ke = 2 * this.guessLen13b(Pe.length, Xe.length), ht = this.makeRBT(Ke), wt = this.stub(Ke), vt = new Array(Ke), xt = new Array(Ke), Qe = new Array(Ke), Rt = new Array(Ke), bt = new Array(Ke), Ht = new Array(Ke), ar = ve.words;
      ar.length = Ke, this.convert13b(Pe.words, Pe.length, vt, Ke), this.convert13b(Xe.words, Xe.length, Rt, Ke), this.transform(vt, wt, xt, Qe, Ke, ht), this.transform(Rt, wt, bt, Ht, Ke, ht);
      for (var yr = 0; yr < Ke; yr++) {
        var rr = xt[yr] * bt[yr] - Qe[yr] * Ht[yr];
        Qe[yr] = xt[yr] * Ht[yr] + Qe[yr] * bt[yr], xt[yr] = rr;
      }
      return this.conjugate(xt, Qe, Ke), this.transform(xt, Qe, ar, wt, Ke, ht), this.conjugate(ar, wt, Ke), this.normalize13b(ar, Ke), ve.negative = Pe.negative ^ Xe.negative, ve.length = Pe.length + Xe.length, ve.strip();
    }, oe.prototype.mul = function(Pe) {
      var Xe = new oe(null);
      return Xe.words = new Array(this.length + Pe.length), this.mulTo(Pe, Xe);
    }, oe.prototype.mulf = function(Pe) {
      var Xe = new oe(null);
      return Xe.words = new Array(this.length + Pe.length), Wt(this, Pe, Xe);
    }, oe.prototype.imul = function(Pe) {
      return this.clone().mulTo(Pe, this);
    }, oe.prototype.imuln = function(Pe) {
      ne(typeof Pe == "number"), ne(Pe < 67108864);
      for (var Xe = 0, ve = 0; ve < this.length; ve++) {
        var Ke = (this.words[ve] | 0) * Pe, ht = (Ke & 67108863) + (Xe & 67108863);
        Xe >>= 26, Xe += Ke / 67108864 | 0, Xe += ht >>> 26, this.words[ve] = ht & 67108863;
      }
      return Xe !== 0 && (this.words[ve] = Xe, this.length++), this;
    }, oe.prototype.muln = function(Pe) {
      return this.clone().imuln(Pe);
    }, oe.prototype.sqr = function() {
      return this.mul(this);
    }, oe.prototype.isqr = function() {
      return this.imul(this.clone());
    }, oe.prototype.pow = function(Pe) {
      var Xe = Ve(Pe);
      if (Xe.length === 0) return new oe(1);
      for (var ve = this, Ke = 0; Ke < Xe.length && Xe[Ke] === 0; Ke++, ve = ve.sqr())
        ;
      if (++Ke < Xe.length)
        for (var ht = ve.sqr(); Ke < Xe.length; Ke++, ht = ht.sqr())
          Xe[Ke] !== 0 && (ve = ve.mul(ht));
      return ve;
    }, oe.prototype.iushln = function(Pe) {
      ne(typeof Pe == "number" && Pe >= 0);
      var Xe = Pe % 26, ve = (Pe - Xe) / 26, Ke = 67108863 >>> 26 - Xe << 26 - Xe, ht;
      if (Xe !== 0) {
        var wt = 0;
        for (ht = 0; ht < this.length; ht++) {
          var vt = this.words[ht] & Ke, xt = (this.words[ht] | 0) - vt << Xe;
          this.words[ht] = xt | wt, wt = vt >>> 26 - Xe;
        }
        wt && (this.words[ht] = wt, this.length++);
      }
      if (ve !== 0) {
        for (ht = this.length - 1; ht >= 0; ht--)
          this.words[ht + ve] = this.words[ht];
        for (ht = 0; ht < ve; ht++)
          this.words[ht] = 0;
        this.length += ve;
      }
      return this.strip();
    }, oe.prototype.ishln = function(Pe) {
      return ne(this.negative === 0), this.iushln(Pe);
    }, oe.prototype.iushrn = function(Pe, Xe, ve) {
      ne(typeof Pe == "number" && Pe >= 0);
      var Ke;
      Xe ? Ke = (Xe - Xe % 26) / 26 : Ke = 0;
      var ht = Pe % 26, wt = Math.min((Pe - ht) / 26, this.length), vt = 67108863 ^ 67108863 >>> ht << ht, xt = ve;
      if (Ke -= wt, Ke = Math.max(0, Ke), xt) {
        for (var Qe = 0; Qe < wt; Qe++)
          xt.words[Qe] = this.words[Qe];
        xt.length = wt;
      }
      if (wt !== 0) if (this.length > wt)
        for (this.length -= wt, Qe = 0; Qe < this.length; Qe++)
          this.words[Qe] = this.words[Qe + wt];
      else
        this.words[0] = 0, this.length = 1;
      var Rt = 0;
      for (Qe = this.length - 1; Qe >= 0 && (Rt !== 0 || Qe >= Ke); Qe--) {
        var bt = this.words[Qe] | 0;
        this.words[Qe] = Rt << 26 - ht | bt >>> ht, Rt = bt & vt;
      }
      return xt && Rt !== 0 && (xt.words[xt.length++] = Rt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, oe.prototype.ishrn = function(Pe, Xe, ve) {
      return ne(this.negative === 0), this.iushrn(Pe, Xe, ve);
    }, oe.prototype.shln = function(Pe) {
      return this.clone().ishln(Pe);
    }, oe.prototype.ushln = function(Pe) {
      return this.clone().iushln(Pe);
    }, oe.prototype.shrn = function(Pe) {
      return this.clone().ishrn(Pe);
    }, oe.prototype.ushrn = function(Pe) {
      return this.clone().iushrn(Pe);
    }, oe.prototype.testn = function(Pe) {
      ne(typeof Pe == "number" && Pe >= 0);
      var Xe = Pe % 26, ve = (Pe - Xe) / 26, Ke = 1 << Xe;
      if (this.length <= ve) return !1;
      var ht = this.words[ve];
      return !!(ht & Ke);
    }, oe.prototype.imaskn = function(Pe) {
      ne(typeof Pe == "number" && Pe >= 0);
      var Xe = Pe % 26, ve = (Pe - Xe) / 26;
      if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ve)
        return this;
      if (Xe !== 0 && ve++, this.length = Math.min(ve, this.length), Xe !== 0) {
        var Ke = 67108863 ^ 67108863 >>> Xe << Xe;
        this.words[this.length - 1] &= Ke;
      }
      return this.strip();
    }, oe.prototype.maskn = function(Pe) {
      return this.clone().imaskn(Pe);
    }, oe.prototype.iaddn = function(Pe) {
      return ne(typeof Pe == "number"), ne(Pe < 67108864), Pe < 0 ? this.isubn(-Pe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Pe ? (this.words[0] = Pe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Pe), this.negative = 1, this) : this._iaddn(Pe);
    }, oe.prototype._iaddn = function(Pe) {
      this.words[0] += Pe;
      for (var Xe = 0; Xe < this.length && this.words[Xe] >= 67108864; Xe++)
        this.words[Xe] -= 67108864, Xe === this.length - 1 ? this.words[Xe + 1] = 1 : this.words[Xe + 1]++;
      return this.length = Math.max(this.length, Xe + 1), this;
    }, oe.prototype.isubn = function(Pe) {
      if (ne(typeof Pe == "number"), ne(Pe < 67108864), Pe < 0) return this.iaddn(-Pe);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(Pe), this.negative = 1, this;
      if (this.words[0] -= Pe, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Xe = 0; Xe < this.length && this.words[Xe] < 0; Xe++)
          this.words[Xe] += 67108864, this.words[Xe + 1] -= 1;
      return this.strip();
    }, oe.prototype.addn = function(Pe) {
      return this.clone().iaddn(Pe);
    }, oe.prototype.subn = function(Pe) {
      return this.clone().isubn(Pe);
    }, oe.prototype.iabs = function() {
      return this.negative = 0, this;
    }, oe.prototype.abs = function() {
      return this.clone().iabs();
    }, oe.prototype._ishlnsubmul = function(Pe, Xe, ve) {
      var Ke = Pe.length + ve, ht;
      this._expand(Ke);
      var wt, vt = 0;
      for (ht = 0; ht < Pe.length; ht++) {
        wt = (this.words[ht + ve] | 0) + vt;
        var xt = (Pe.words[ht] | 0) * Xe;
        wt -= xt & 67108863, vt = (wt >> 26) - (xt / 67108864 | 0), this.words[ht + ve] = wt & 67108863;
      }
      for (; ht < this.length - ve; ht++)
        wt = (this.words[ht + ve] | 0) + vt, vt = wt >> 26, this.words[ht + ve] = wt & 67108863;
      if (vt === 0) return this.strip();
      for (ne(vt === -1), vt = 0, ht = 0; ht < this.length; ht++)
        wt = -(this.words[ht] | 0) + vt, vt = wt >> 26, this.words[ht] = wt & 67108863;
      return this.negative = 1, this.strip();
    }, oe.prototype._wordDiv = function(Pe, Xe) {
      var ve = this.length - Pe.length, Ke = this.clone(), ht = Pe, wt = ht.words[ht.length - 1] | 0, vt = this._countBits(wt);
      ve = 26 - vt, ve !== 0 && (ht = ht.ushln(ve), Ke.iushln(ve), wt = ht.words[ht.length - 1] | 0);
      var xt = Ke.length - ht.length, Qe;
      if (Xe !== "mod") {
        Qe = new oe(null), Qe.length = xt + 1, Qe.words = new Array(Qe.length);
        for (var Rt = 0; Rt < Qe.length; Rt++)
          Qe.words[Rt] = 0;
      }
      var bt = Ke.clone()._ishlnsubmul(ht, 1, xt);
      bt.negative === 0 && (Ke = bt, Qe && (Qe.words[xt] = 1));
      for (var Ht = xt - 1; Ht >= 0; Ht--) {
        var ar = (Ke.words[ht.length + Ht] | 0) * 67108864 + (Ke.words[ht.length + Ht - 1] | 0);
        for (ar = Math.min(ar / wt | 0, 67108863), Ke._ishlnsubmul(ht, ar, Ht); Ke.negative !== 0; )
          ar--, Ke.negative = 0, Ke._ishlnsubmul(ht, 1, Ht), Ke.isZero() || (Ke.negative ^= 1);
        Qe && (Qe.words[Ht] = ar);
      }
      return Qe && Qe.strip(), Ke.strip(), Xe !== "div" && ve !== 0 && Ke.iushrn(ve), {
        div: Qe || null,
        mod: Ke
      };
    }, oe.prototype.divmod = function(Pe, Xe, ve) {
      if (ne(!Pe.isZero()), this.isZero())
        return {
          div: new oe(0),
          mod: new oe(0)
        };
      var Ke, ht, wt;
      return this.negative !== 0 && Pe.negative === 0 ? (wt = this.neg().divmod(Pe, Xe), Xe !== "mod" && (Ke = wt.div.neg()), Xe !== "div" && (ht = wt.mod.neg(), ve && ht.negative !== 0 && ht.iadd(Pe)), {
        div: Ke,
        mod: ht
      }) : this.negative === 0 && Pe.negative !== 0 ? (wt = this.divmod(Pe.neg(), Xe), Xe !== "mod" && (Ke = wt.div.neg()), {
        div: Ke,
        mod: wt.mod
      }) : this.negative & Pe.negative ? (wt = this.neg().divmod(Pe.neg(), Xe), Xe !== "div" && (ht = wt.mod.neg(), ve && ht.negative !== 0 && ht.isub(Pe)), {
        div: wt.div,
        mod: ht
      }) : Pe.length > this.length || this.cmp(Pe) < 0 ? {
        div: new oe(0),
        mod: this
      } : Pe.length === 1 ? Xe === "div" ? {
        div: this.divn(Pe.words[0]),
        mod: null
      } : Xe === "mod" ? {
        div: null,
        mod: new oe(this.modn(Pe.words[0]))
      } : {
        div: this.divn(Pe.words[0]),
        mod: new oe(this.modn(Pe.words[0]))
      } : this._wordDiv(Pe, Xe);
    }, oe.prototype.div = function(Pe) {
      return this.divmod(Pe, "div", !1).div;
    }, oe.prototype.mod = function(Pe) {
      return this.divmod(Pe, "mod", !1).mod;
    }, oe.prototype.umod = function(Pe) {
      return this.divmod(Pe, "mod", !0).mod;
    }, oe.prototype.divRound = function(Pe) {
      var Xe = this.divmod(Pe);
      if (Xe.mod.isZero()) return Xe.div;
      var ve = Xe.div.negative !== 0 ? Xe.mod.isub(Pe) : Xe.mod, Ke = Pe.ushrn(1), ht = Pe.andln(1), wt = ve.cmp(Ke);
      return wt < 0 || ht === 1 && wt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
    }, oe.prototype.modn = function(Pe) {
      ne(Pe <= 67108863);
      for (var Xe = (1 << 26) % Pe, ve = 0, Ke = this.length - 1; Ke >= 0; Ke--)
        ve = (Xe * ve + (this.words[Ke] | 0)) % Pe;
      return ve;
    }, oe.prototype.idivn = function(Pe) {
      ne(Pe <= 67108863);
      for (var Xe = 0, ve = this.length - 1; ve >= 0; ve--) {
        var Ke = (this.words[ve] | 0) + Xe * 67108864;
        this.words[ve] = Ke / Pe | 0, Xe = Ke % Pe;
      }
      return this.strip();
    }, oe.prototype.divn = function(Pe) {
      return this.clone().idivn(Pe);
    }, oe.prototype.egcd = function(Pe) {
      ne(Pe.negative === 0), ne(!Pe.isZero());
      var Xe = this, ve = Pe.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(Pe) : Xe = Xe.clone();
      for (var Ke = new oe(1), ht = new oe(0), wt = new oe(0), vt = new oe(1), xt = 0; Xe.isEven() && ve.isEven(); )
        Xe.iushrn(1), ve.iushrn(1), ++xt;
      for (var Qe = ve.clone(), Rt = Xe.clone(); !Xe.isZero(); ) {
        for (var bt = 0, Ht = 1; !(Xe.words[0] & Ht) && bt < 26; ++bt, Ht <<= 1) ;
        if (bt > 0)
          for (Xe.iushrn(bt); bt-- > 0; )
            (Ke.isOdd() || ht.isOdd()) && (Ke.iadd(Qe), ht.isub(Rt)), Ke.iushrn(1), ht.iushrn(1);
        for (var ar = 0, yr = 1; !(ve.words[0] & yr) && ar < 26; ++ar, yr <<= 1) ;
        if (ar > 0)
          for (ve.iushrn(ar); ar-- > 0; )
            (wt.isOdd() || vt.isOdd()) && (wt.iadd(Qe), vt.isub(Rt)), wt.iushrn(1), vt.iushrn(1);
        Xe.cmp(ve) >= 0 ? (Xe.isub(ve), Ke.isub(wt), ht.isub(vt)) : (ve.isub(Xe), wt.isub(Ke), vt.isub(ht));
      }
      return {
        a: wt,
        b: vt,
        gcd: ve.iushln(xt)
      };
    }, oe.prototype._invmp = function(Pe) {
      ne(Pe.negative === 0), ne(!Pe.isZero());
      var Xe = this, ve = Pe.clone();
      Xe.negative !== 0 ? Xe = Xe.umod(Pe) : Xe = Xe.clone();
      for (var Ke = new oe(1), ht = new oe(0), wt = ve.clone(); Xe.cmpn(1) > 0 && ve.cmpn(1) > 0; ) {
        for (var vt = 0, xt = 1; !(Xe.words[0] & xt) && vt < 26; ++vt, xt <<= 1) ;
        if (vt > 0)
          for (Xe.iushrn(vt); vt-- > 0; )
            Ke.isOdd() && Ke.iadd(wt), Ke.iushrn(1);
        for (var Qe = 0, Rt = 1; !(ve.words[0] & Rt) && Qe < 26; ++Qe, Rt <<= 1) ;
        if (Qe > 0)
          for (ve.iushrn(Qe); Qe-- > 0; )
            ht.isOdd() && ht.iadd(wt), ht.iushrn(1);
        Xe.cmp(ve) >= 0 ? (Xe.isub(ve), Ke.isub(ht)) : (ve.isub(Xe), ht.isub(Ke));
      }
      var bt;
      return Xe.cmpn(1) === 0 ? bt = Ke : bt = ht, bt.cmpn(0) < 0 && bt.iadd(Pe), bt;
    }, oe.prototype.gcd = function(Pe) {
      if (this.isZero()) return Pe.abs();
      if (Pe.isZero()) return this.abs();
      var Xe = this.clone(), ve = Pe.clone();
      Xe.negative = 0, ve.negative = 0;
      for (var Ke = 0; Xe.isEven() && ve.isEven(); Ke++)
        Xe.iushrn(1), ve.iushrn(1);
      do {
        for (; Xe.isEven(); )
          Xe.iushrn(1);
        for (; ve.isEven(); )
          ve.iushrn(1);
        var ht = Xe.cmp(ve);
        if (ht < 0) {
          var wt = Xe;
          Xe = ve, ve = wt;
        } else if (ht === 0 || ve.cmpn(1) === 0)
          break;
        Xe.isub(ve);
      } while (!0);
      return ve.iushln(Ke);
    }, oe.prototype.invm = function(Pe) {
      return this.egcd(Pe).a.umod(Pe);
    }, oe.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, oe.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, oe.prototype.andln = function(Pe) {
      return this.words[0] & Pe;
    }, oe.prototype.bincn = function(Pe) {
      ne(typeof Pe == "number");
      var Xe = Pe % 26, ve = (Pe - Xe) / 26, Ke = 1 << Xe;
      if (this.length <= ve)
        return this._expand(ve + 1), this.words[ve] |= Ke, this;
      for (var ht = Ke, wt = ve; ht !== 0 && wt < this.length; wt++) {
        var vt = this.words[wt] | 0;
        vt += ht, ht = vt >>> 26, vt &= 67108863, this.words[wt] = vt;
      }
      return ht !== 0 && (this.words[wt] = ht, this.length++), this;
    }, oe.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, oe.prototype.cmpn = function(Pe) {
      var Xe = Pe < 0;
      if (this.negative !== 0 && !Xe) return -1;
      if (this.negative === 0 && Xe) return 1;
      this.strip();
      var ve;
      if (this.length > 1)
        ve = 1;
      else {
        Xe && (Pe = -Pe), ne(Pe <= 67108863, "Number is too big");
        var Ke = this.words[0] | 0;
        ve = Ke === Pe ? 0 : Ke < Pe ? -1 : 1;
      }
      return this.negative !== 0 ? -ve | 0 : ve;
    }, oe.prototype.cmp = function(Pe) {
      if (this.negative !== 0 && Pe.negative === 0) return -1;
      if (this.negative === 0 && Pe.negative !== 0) return 1;
      var Xe = this.ucmp(Pe);
      return this.negative !== 0 ? -Xe | 0 : Xe;
    }, oe.prototype.ucmp = function(Pe) {
      if (this.length > Pe.length) return 1;
      if (this.length < Pe.length) return -1;
      for (var Xe = 0, ve = this.length - 1; ve >= 0; ve--) {
        var Ke = this.words[ve] | 0, ht = Pe.words[ve] | 0;
        if (Ke !== ht) {
          Ke < ht ? Xe = -1 : Ke > ht && (Xe = 1);
          break;
        }
      }
      return Xe;
    }, oe.prototype.gtn = function(Pe) {
      return this.cmpn(Pe) === 1;
    }, oe.prototype.gt = function(Pe) {
      return this.cmp(Pe) === 1;
    }, oe.prototype.gten = function(Pe) {
      return this.cmpn(Pe) >= 0;
    }, oe.prototype.gte = function(Pe) {
      return this.cmp(Pe) >= 0;
    }, oe.prototype.ltn = function(Pe) {
      return this.cmpn(Pe) === -1;
    }, oe.prototype.lt = function(Pe) {
      return this.cmp(Pe) === -1;
    }, oe.prototype.lten = function(Pe) {
      return this.cmpn(Pe) <= 0;
    }, oe.prototype.lte = function(Pe) {
      return this.cmp(Pe) <= 0;
    }, oe.prototype.eqn = function(Pe) {
      return this.cmpn(Pe) === 0;
    }, oe.prototype.eq = function(Pe) {
      return this.cmp(Pe) === 0;
    }, oe.red = function(Pe) {
      return new Ct(Pe);
    }, oe.prototype.toRed = function(Pe) {
      return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), Pe.convertTo(this)._forceRed(Pe);
    }, oe.prototype.fromRed = function() {
      return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, oe.prototype._forceRed = function(Pe) {
      return this.red = Pe, this;
    }, oe.prototype.forceRed = function(Pe) {
      return ne(!this.red, "Already a number in reduction context"), this._forceRed(Pe);
    }, oe.prototype.redAdd = function(Pe) {
      return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, Pe);
    }, oe.prototype.redIAdd = function(Pe) {
      return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Pe);
    }, oe.prototype.redSub = function(Pe) {
      return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, Pe);
    }, oe.prototype.redISub = function(Pe) {
      return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, Pe);
    }, oe.prototype.redShl = function(Pe) {
      return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, Pe);
    }, oe.prototype.redMul = function(Pe) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Pe), this.red.mul(this, Pe);
    }, oe.prototype.redIMul = function(Pe) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Pe), this.red.imul(this, Pe);
    }, oe.prototype.redSqr = function() {
      return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, oe.prototype.redISqr = function() {
      return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, oe.prototype.redSqrt = function() {
      return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, oe.prototype.redInvm = function() {
      return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, oe.prototype.redNeg = function() {
      return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, oe.prototype.redPow = function(Pe) {
      return ne(this.red && !Pe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Pe);
    };
    var Lt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function qt(kt, Pe) {
      this.name = kt, this.p = new oe(Pe, 16), this.n = this.p.bitLength(), this.k = new oe(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    qt.prototype._tmp = function() {
      var Pe = new oe(null);
      return Pe.words = new Array(Math.ceil(this.n / 13)), Pe;
    }, qt.prototype.ireduce = function(Pe) {
      var Xe = Pe, ve;
      do
        this.split(Xe, this.tmp), Xe = this.imulK(Xe), Xe = Xe.iadd(this.tmp), ve = Xe.bitLength();
      while (ve > this.n);
      var Ke = ve < this.n ? -1 : Xe.ucmp(this.p);
      return Ke === 0 ? (Xe.words[0] = 0, Xe.length = 1) : Ke > 0 ? Xe.isub(this.p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
    }, qt.prototype.split = function(Pe, Xe) {
      Pe.iushrn(this.n, 0, Xe);
    }, qt.prototype.imulK = function(Pe) {
      return Pe.imul(this.k);
    };
    function Zt() {
      qt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ie(Zt, qt), Zt.prototype.split = function(Pe, Xe) {
      for (var ve = 4194303, Ke = Math.min(Pe.length, 9), ht = 0; ht < Ke; ht++)
        Xe.words[ht] = Pe.words[ht];
      if (Xe.length = Ke, Pe.length <= 9) {
        Pe.words[0] = 0, Pe.length = 1;
        return;
      }
      var wt = Pe.words[9];
      for (Xe.words[Xe.length++] = wt & ve, ht = 10; ht < Pe.length; ht++) {
        var vt = Pe.words[ht] | 0;
        Pe.words[ht - 10] = (vt & ve) << 4 | wt >>> 22, wt = vt;
      }
      wt >>>= 22, Pe.words[ht - 10] = wt, wt === 0 && Pe.length > 10 ? Pe.length -= 10 : Pe.length -= 9;
    }, Zt.prototype.imulK = function(Pe) {
      Pe.words[Pe.length] = 0, Pe.words[Pe.length + 1] = 0, Pe.length += 2;
      for (var Xe = 0, ve = 0; ve < Pe.length; ve++) {
        var Ke = Pe.words[ve] | 0;
        Xe += Ke * 977, Pe.words[ve] = Xe & 67108863, Xe = Ke * 64 + (Xe / 67108864 | 0);
      }
      return Pe.words[Pe.length - 1] === 0 && (Pe.length--, Pe.words[Pe.length - 1] === 0 && Pe.length--), Pe;
    };
    function Yt() {
      qt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ie(Yt, qt);
    function or() {
      qt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ie(or, qt);
    function jt() {
      qt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ie(jt, qt), jt.prototype.imulK = function(Pe) {
      for (var Xe = 0, ve = 0; ve < Pe.length; ve++) {
        var Ke = (Pe.words[ve] | 0) * 19 + Xe, ht = Ke & 67108863;
        Ke >>>= 26, Pe.words[ve] = ht, Xe = Ke;
      }
      return Xe !== 0 && (Pe.words[Pe.length++] = Xe), Pe;
    }, oe._prime = function(Pe) {
      if (Lt[Pe]) return Lt[Pe];
      var Xe;
      if (Pe === "k256")
        Xe = new Zt();
      else if (Pe === "p224")
        Xe = new Yt();
      else if (Pe === "p192")
        Xe = new or();
      else if (Pe === "p25519")
        Xe = new jt();
      else
        throw new Error("Unknown prime " + Pe);
      return Lt[Pe] = Xe, Xe;
    };
    function Ct(kt) {
      if (typeof kt == "string") {
        var Pe = oe._prime(kt);
        this.m = Pe.p, this.prime = Pe;
      } else
        ne(kt.gtn(1), "modulus must be greater than 1"), this.m = kt, this.prime = null;
    }
    Ct.prototype._verify1 = function(Pe) {
      ne(Pe.negative === 0, "red works only with positives"), ne(Pe.red, "red works only with red numbers");
    }, Ct.prototype._verify2 = function(Pe, Xe) {
      ne((Pe.negative | Xe.negative) === 0, "red works only with positives"), ne(
        Pe.red && Pe.red === Xe.red,
        "red works only with red numbers"
      );
    }, Ct.prototype.imod = function(Pe) {
      return this.prime ? this.prime.ireduce(Pe)._forceRed(this) : Pe.umod(this.m)._forceRed(this);
    }, Ct.prototype.neg = function(Pe) {
      return Pe.isZero() ? Pe.clone() : this.m.sub(Pe)._forceRed(this);
    }, Ct.prototype.add = function(Pe, Xe) {
      this._verify2(Pe, Xe);
      var ve = Pe.add(Xe);
      return ve.cmp(this.m) >= 0 && ve.isub(this.m), ve._forceRed(this);
    }, Ct.prototype.iadd = function(Pe, Xe) {
      this._verify2(Pe, Xe);
      var ve = Pe.iadd(Xe);
      return ve.cmp(this.m) >= 0 && ve.isub(this.m), ve;
    }, Ct.prototype.sub = function(Pe, Xe) {
      this._verify2(Pe, Xe);
      var ve = Pe.sub(Xe);
      return ve.cmpn(0) < 0 && ve.iadd(this.m), ve._forceRed(this);
    }, Ct.prototype.isub = function(Pe, Xe) {
      this._verify2(Pe, Xe);
      var ve = Pe.isub(Xe);
      return ve.cmpn(0) < 0 && ve.iadd(this.m), ve;
    }, Ct.prototype.shl = function(Pe, Xe) {
      return this._verify1(Pe), this.imod(Pe.ushln(Xe));
    }, Ct.prototype.imul = function(Pe, Xe) {
      return this._verify2(Pe, Xe), this.imod(Pe.imul(Xe));
    }, Ct.prototype.mul = function(Pe, Xe) {
      return this._verify2(Pe, Xe), this.imod(Pe.mul(Xe));
    }, Ct.prototype.isqr = function(Pe) {
      return this.imul(Pe, Pe.clone());
    }, Ct.prototype.sqr = function(Pe) {
      return this.mul(Pe, Pe);
    }, Ct.prototype.sqrt = function(Pe) {
      if (Pe.isZero()) return Pe.clone();
      var Xe = this.m.andln(3);
      if (ne(Xe % 2 === 1), Xe === 3) {
        var ve = this.m.add(new oe(1)).iushrn(2);
        return this.pow(Pe, ve);
      }
      for (var Ke = this.m.subn(1), ht = 0; !Ke.isZero() && Ke.andln(1) === 0; )
        ht++, Ke.iushrn(1);
      ne(!Ke.isZero());
      var wt = new oe(1).toRed(this), vt = wt.redNeg(), xt = this.m.subn(1).iushrn(1), Qe = this.m.bitLength();
      for (Qe = new oe(2 * Qe * Qe).toRed(this); this.pow(Qe, xt).cmp(vt) !== 0; )
        Qe.redIAdd(vt);
      for (var Rt = this.pow(Qe, Ke), bt = this.pow(Pe, Ke.addn(1).iushrn(1)), Ht = this.pow(Pe, Ke), ar = ht; Ht.cmp(wt) !== 0; ) {
        for (var yr = Ht, rr = 0; yr.cmp(wt) !== 0; rr++)
          yr = yr.redSqr();
        ne(rr < ar);
        var Kt = this.pow(Rt, new oe(1).iushln(ar - rr - 1));
        bt = bt.redMul(Kt), Rt = Kt.redSqr(), Ht = Ht.redMul(Rt), ar = rr;
      }
      return bt;
    }, Ct.prototype.invm = function(Pe) {
      var Xe = Pe._invmp(this.m);
      return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
    }, Ct.prototype.pow = function(Pe, Xe) {
      if (Xe.isZero()) return new oe(1).toRed(this);
      if (Xe.cmpn(1) === 0) return Pe.clone();
      var ve = 4, Ke = new Array(1 << ve);
      Ke[0] = new oe(1).toRed(this), Ke[1] = Pe;
      for (var ht = 2; ht < Ke.length; ht++)
        Ke[ht] = this.mul(Ke[ht - 1], Pe);
      var wt = Ke[0], vt = 0, xt = 0, Qe = Xe.bitLength() % 26;
      for (Qe === 0 && (Qe = 26), ht = Xe.length - 1; ht >= 0; ht--) {
        for (var Rt = Xe.words[ht], bt = Qe - 1; bt >= 0; bt--) {
          var Ht = Rt >> bt & 1;
          if (wt !== Ke[0] && (wt = this.sqr(wt)), Ht === 0 && vt === 0) {
            xt = 0;
            continue;
          }
          vt <<= 1, vt |= Ht, xt++, !(xt !== ve && (ht !== 0 || bt !== 0)) && (wt = this.mul(wt, Ke[vt]), xt = 0, vt = 0);
        }
        Qe = 26;
      }
      return wt;
    }, Ct.prototype.convertTo = function(Pe) {
      var Xe = Pe.umod(this.m);
      return Xe === Pe ? Xe.clone() : Xe;
    }, Ct.prototype.convertFrom = function(Pe) {
      var Xe = Pe.clone();
      return Xe.red = null, Xe;
    }, oe.mont = function(Pe) {
      return new Vt(Pe);
    };
    function Vt(kt) {
      Ct.call(this, kt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new oe(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ie(Vt, Ct), Vt.prototype.convertTo = function(Pe) {
      return this.imod(Pe.ushln(this.shift));
    }, Vt.prototype.convertFrom = function(Pe) {
      var Xe = this.imod(Pe.mul(this.rinv));
      return Xe.red = null, Xe;
    }, Vt.prototype.imul = function(Pe, Xe) {
      if (Pe.isZero() || Xe.isZero())
        return Pe.words[0] = 0, Pe.length = 1, Pe;
      var ve = Pe.imul(Xe), Ke = ve.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = ve.isub(Ke).iushrn(this.shift), wt = ht;
      return ht.cmp(this.m) >= 0 ? wt = ht.isub(this.m) : ht.cmpn(0) < 0 && (wt = ht.iadd(this.m)), wt._forceRed(this);
    }, Vt.prototype.mul = function(Pe, Xe) {
      if (Pe.isZero() || Xe.isZero()) return new oe(0)._forceRed(this);
      var ve = Pe.mul(Xe), Ke = ve.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = ve.isub(Ke).iushrn(this.shift), wt = ht;
      return ht.cmp(this.m) >= 0 ? wt = ht.isub(this.m) : ht.cmpn(0) < 0 && (wt = ht.iadd(this.m)), wt._forceRed(this);
    }, Vt.prototype.invm = function(Pe) {
      var Xe = this.imod(Pe._invmp(this.m).mul(this.r2));
      return Xe._forceRed(this);
    };
  })(B, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(ie) {
    return B || (B = new z(null)), B.generate(ie);
  };
  function z(ne) {
    this.rand = ne;
  }
  if (brorand.exports.Rand = z, z.prototype.generate = function(ie) {
    return this._rand(ie);
  }, z.prototype._rand = function(ie) {
    if (this.rand.getBytes)
      return this.rand.getBytes(ie);
    for (var oe = new Uint8Array(ie), se = 0; se < oe.length; se++)
      oe[se] = this.rand.getByte();
    return oe;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? z.prototype._rand = function(ie) {
      var oe = new Uint8Array(ie);
      return self.crypto.getRandomValues(oe), oe;
    } : self.msCrypto && self.msCrypto.getRandomValues ? z.prototype._rand = function(ie) {
      var oe = new Uint8Array(ie);
      return self.msCrypto.getRandomValues(oe), oe;
    } : typeof window == "object" && (z.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Y = requireCryptoBrowserify();
      if (typeof Y.randomBytes != "function")
        throw new Error("Not supported");
      z.prototype._rand = function(ie) {
        return Y.randomBytes(ie);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = bnExports$1, z = requireBrorand();
  function Y(ne) {
    this.rand = ne || new z.Rand();
  }
  return mr = Y, Y.create = function(ie) {
    return new Y(ie);
  }, Y.prototype._randbelow = function(ie) {
    var oe = ie.bitLength(), se = Math.ceil(oe / 8);
    do
      var ae = new B(this.rand.generate(se));
    while (ae.cmp(ie) >= 0);
    return ae;
  }, Y.prototype._randrange = function(ie, oe) {
    var se = oe.sub(ie);
    return ie.add(this._randbelow(se));
  }, Y.prototype.test = function(ie, oe, se) {
    var ae = ie.bitLength(), ge = B.mont(ie), Ce = new B(1).toRed(ge);
    oe || (oe = Math.max(1, ae / 48 | 0));
    for (var le = ie.subn(1), Ee = 0; !le.testn(Ee); Ee++)
      ;
    for (var Je = ie.shrn(Ee), Ve = le.toRed(ge), $t = !0; oe > 0; oe--) {
      var Nt = this._randrange(new B(2), le);
      se && se(Nt);
      var Dt = Nt.toRed(ge).redPow(Je);
      if (!(Dt.cmp(Ce) === 0 || Dt.cmp(Ve) === 0)) {
        for (var Wt = 1; Wt < Ee; Wt++) {
          if (Dt = Dt.redSqr(), Dt.cmp(Ce) === 0)
            return !1;
          if (Dt.cmp(Ve) === 0)
            break;
        }
        if (Wt === Ee)
          return !1;
      }
    }
    return $t;
  }, Y.prototype.getDivisor = function(ie, oe) {
    var se = ie.bitLength(), ae = B.mont(ie), ge = new B(1).toRed(ae);
    oe || (oe = Math.max(1, se / 48 | 0));
    for (var Ce = ie.subn(1), le = 0; !Ce.testn(le); le++)
      ;
    for (var Ee = ie.shrn(le), Je = Ce.toRed(ae); oe > 0; oe--) {
      var Ve = this._randrange(new B(2), Ce), $t = ie.gcd(Ve);
      if ($t.cmpn(1) !== 0)
        return $t;
      var Nt = Ve.toRed(ae).redPow(Ee);
      if (!(Nt.cmp(ge) === 0 || Nt.cmp(Je) === 0)) {
        for (var Dt = 1; Dt < le; Dt++) {
          if (Nt = Nt.redSqr(), Nt.cmp(ge) === 0)
            return Nt.fromRed().subn(1).gcd(ie);
          if (Nt.cmp(Je) === 0)
            break;
        }
        if (Dt === le)
          return Nt = Nt.redSqr(), Nt.fromRed().subn(1).gcd(ie);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = browserExports;
  generatePrime = Dt, Dt.simpleSieve = $t, Dt.fermatTest = Nt;
  var z = bnExports$1, Y = new z(24), ne = requireMr(), ie = new ne(), oe = new z(1), se = new z(2), ae = new z(5);
  new z(16), new z(8);
  var ge = new z(10), Ce = new z(3);
  new z(7);
  var le = new z(11), Ee = new z(4);
  new z(12);
  var Je = null;
  function Ve() {
    if (Je !== null)
      return Je;
    var Wt = 1048576, Pt = [];
    Pt[0] = 2;
    for (var Lt = 1, qt = 3; qt < Wt; qt += 2) {
      for (var Zt = Math.ceil(Math.sqrt(qt)), Yt = 0; Yt < Lt && Pt[Yt] <= Zt && qt % Pt[Yt] !== 0; Yt++)
        ;
      Lt !== Yt && Pt[Yt] <= Zt || (Pt[Lt++] = qt);
    }
    return Je = Pt, Pt;
  }
  function $t(Wt) {
    for (var Pt = Ve(), Lt = 0; Lt < Pt.length; Lt++)
      if (Wt.modn(Pt[Lt]) === 0)
        return Wt.cmpn(Pt[Lt]) === 0;
    return !0;
  }
  function Nt(Wt) {
    var Pt = z.mont(Wt);
    return se.toRed(Pt).redPow(Wt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Dt(Wt, Pt) {
    if (Wt < 16)
      return Pt === 2 || Pt === 5 ? new z([140, 123]) : new z([140, 39]);
    Pt = new z(Pt);
    for (var Lt, qt; ; ) {
      for (Lt = new z(B(Math.ceil(Wt / 8))); Lt.bitLength() > Wt; )
        Lt.ishrn(1);
      if (Lt.isEven() && Lt.iadd(oe), Lt.testn(1) || Lt.iadd(se), Pt.cmp(se)) {
        if (!Pt.cmp(ae))
          for (; Lt.mod(ge).cmp(Ce); )
            Lt.iadd(Ee);
      } else for (; Lt.mod(Y).cmp(le); )
        Lt.iadd(Ee);
      if (qt = Lt.shrn(1), $t(qt) && $t(Lt) && Nt(qt) && Nt(Lt) && ie.test(qt) && ie.test(Lt))
        return Lt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = bnExports$1, z = requireMr(), Y = new z(), ne = new B(24), ie = new B(11), oe = new B(10), se = new B(3), ae = new B(7), ge = requireGeneratePrime(), Ce = browserExports;
  dh = $t;
  function le(Dt, Wt) {
    return Wt = Wt || "utf8", Buffer$D.isBuffer(Dt) || (Dt = new Buffer$D(Dt, Wt)), this._pub = new B(Dt), this;
  }
  function Ee(Dt, Wt) {
    return Wt = Wt || "utf8", Buffer$D.isBuffer(Dt) || (Dt = new Buffer$D(Dt, Wt)), this._priv = new B(Dt), this;
  }
  var Je = {};
  function Ve(Dt, Wt) {
    var Pt = Wt.toString("hex"), Lt = [Pt, Dt.toString(16)].join("_");
    if (Lt in Je)
      return Je[Lt];
    var qt = 0;
    if (Dt.isEven() || !ge.simpleSieve || !ge.fermatTest(Dt) || !Y.test(Dt))
      return qt += 1, Pt === "02" || Pt === "05" ? qt += 8 : qt += 4, Je[Lt] = qt, qt;
    Y.test(Dt.shrn(1)) || (qt += 2);
    var Zt;
    switch (Pt) {
      case "02":
        Dt.mod(ne).cmp(ie) && (qt += 8);
        break;
      case "05":
        Zt = Dt.mod(oe), Zt.cmp(se) && Zt.cmp(ae) && (qt += 8);
        break;
      default:
        qt += 4;
    }
    return Je[Lt] = qt, qt;
  }
  function $t(Dt, Wt, Pt) {
    this.setGenerator(Wt), this.__prime = new B(Dt), this._prime = B.mont(this.__prime), this._primeLen = Dt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Pt ? (this.setPublicKey = le, this.setPrivateKey = Ee) : this._primeCode = 8;
  }
  Object.defineProperty($t.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ve(this.__prime, this.__gen)), this._primeCode;
    }
  }), $t.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(Ce(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, $t.prototype.computeSecret = function(Dt) {
    Dt = new B(Dt), Dt = Dt.toRed(this._prime);
    var Wt = Dt.redPow(this._priv).fromRed(), Pt = new Buffer$D(Wt.toArray()), Lt = this.getPrime();
    if (Pt.length < Lt.length) {
      var qt = new Buffer$D(Lt.length - Pt.length);
      qt.fill(0), Pt = Buffer$D.concat([qt, Pt]);
    }
    return Pt;
  }, $t.prototype.getPublicKey = function(Wt) {
    return Nt(this._pub, Wt);
  }, $t.prototype.getPrivateKey = function(Wt) {
    return Nt(this._priv, Wt);
  }, $t.prototype.getPrime = function(Dt) {
    return Nt(this.__prime, Dt);
  }, $t.prototype.getGenerator = function(Dt) {
    return Nt(this._gen, Dt);
  }, $t.prototype.setGenerator = function(Dt, Wt) {
    return Wt = Wt || "utf8", Buffer$D.isBuffer(Dt) || (Dt = new Buffer$D(Dt, Wt)), this.__gen = Dt, this._gen = new B(Dt), this;
  };
  function Nt(Dt, Wt) {
    var Pt = new Buffer$D(Dt.toArray());
    return Wt ? Pt.toString(Wt) : Pt;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var B = requireGeneratePrime(), z = require$$1$1, Y = requireDh();
  function ne(se) {
    var ae = new Buffer$D(z[se].prime, "hex"), ge = new Buffer$D(z[se].gen, "hex");
    return new Y(ae, ge);
  }
  var ie = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function oe(se, ae, ge, Ce) {
    return Buffer$D.isBuffer(ae) || ie[ae] === void 0 ? oe(se, "binary", ae, ge) : (ae = ae || "binary", Ce = Ce || "binary", ge = ge || new Buffer$D([2]), Buffer$D.isBuffer(ge) || (ge = new Buffer$D(ge, Ce)), typeof se == "number" ? new Y(B(se, ge), ge, !0) : (Buffer$D.isBuffer(se) || (se = new Buffer$D(se, ae)), new Y(se, ge, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ne, browser$4.createDiffieHellman = browser$4.DiffieHellman = oe, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1;
function nextTick(B, z, Y, ne) {
  if (typeof B != "function")
    throw new TypeError('"callback" argument must be a function');
  var ie = arguments.length, oe, se;
  switch (ie) {
    case 0:
    case 1:
      return process$1.nextTick(B);
    case 2:
      return process$1.nextTick(function() {
        B.call(null, z);
      });
    case 3:
      return process$1.nextTick(function() {
        B.call(null, z, Y);
      });
    case 4:
      return process$1.nextTick(function() {
        B.call(null, z, Y, ne);
      });
    default:
      for (oe = new Array(ie - 1), se = 0; se < oe.length; )
        oe[se++] = arguments[se];
      return process$1.nextTick(function() {
        B.apply(null, oe);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(B) {
  return toString.call(B) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, safeBuffer$1 = { exports: {} };
(function(B, z) {
  var Y = dist$1, ne = Y.Buffer;
  function ie(se, ae) {
    for (var ge in se)
      ae[ge] = se[ge];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (ie(Y, z), z.Buffer = oe);
  function oe(se, ae, ge) {
    return ne(se, ae, ge);
  }
  ie(ne, oe), oe.from = function(se, ae, ge) {
    if (typeof se == "number")
      throw new TypeError("Argument must not be a number");
    return ne(se, ae, ge);
  }, oe.alloc = function(se, ae, ge) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    var Ce = ne(se);
    return ae !== void 0 ? typeof ge == "string" ? Ce.fill(ae, ge) : Ce.fill(ae) : Ce.fill(0), Ce;
  }, oe.allocUnsafe = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return ne(se);
  }, oe.allocUnsafeSlow = function(se) {
    if (typeof se != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(se);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, util$2 = {};
function isArray(B) {
  return Array.isArray ? Array.isArray(B) : objectToString(B) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(B) {
  return typeof B == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(B) {
  return B === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(B) {
  return B == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber(B) {
  return typeof B == "number";
}
util$2.isNumber = isNumber;
function isString(B) {
  return typeof B == "string";
}
util$2.isString = isString;
function isSymbol(B) {
  return typeof B == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(B) {
  return B === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(B) {
  return objectToString(B) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject(B) {
  return typeof B == "object" && B !== null;
}
util$2.isObject = isObject;
function isDate(B) {
  return objectToString(B) === "[object Date]";
}
util$2.isDate = isDate;
function isError(B) {
  return objectToString(B) === "[object Error]" || B instanceof Error;
}
util$2.isError = isError;
function isFunction(B) {
  return typeof B == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(B) {
  return B === null || typeof B == "boolean" || typeof B == "number" || typeof B == "string" || typeof B == "symbol" || // ES6 symbol
  typeof B > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = dist$1.Buffer.isBuffer;
function objectToString(B) {
  return Object.prototype.toString.call(B);
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function z(oe, se) {
      if (!(oe instanceof se))
        throw new TypeError("Cannot call a class as a function");
    }
    var Y = safeBufferExports.Buffer, ne = util$3;
    function ie(oe, se, ae) {
      oe.copy(se, ae);
    }
    B.exports = function() {
      function oe() {
        z(this, oe), this.head = null, this.tail = null, this.length = 0;
      }
      return oe.prototype.push = function(ae) {
        var ge = { data: ae, next: null };
        this.length > 0 ? this.tail.next = ge : this.head = ge, this.tail = ge, ++this.length;
      }, oe.prototype.unshift = function(ae) {
        var ge = { data: ae, next: this.head };
        this.length === 0 && (this.tail = ge), this.head = ge, ++this.length;
      }, oe.prototype.shift = function() {
        if (this.length !== 0) {
          var ae = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ae;
        }
      }, oe.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, oe.prototype.join = function(ae) {
        if (this.length === 0) return "";
        for (var ge = this.head, Ce = "" + ge.data; ge = ge.next; )
          Ce += ae + ge.data;
        return Ce;
      }, oe.prototype.concat = function(ae) {
        if (this.length === 0) return Y.alloc(0);
        for (var ge = Y.allocUnsafe(ae >>> 0), Ce = this.head, le = 0; Ce; )
          ie(Ce.data, ge, le), le += Ce.data.length, Ce = Ce.next;
        return ge;
      }, oe;
    }(), ne && ne.inspect && ne.inspect.custom && (B.exports.prototype[ne.inspect.custom] = function() {
      var oe = ne.inspect({ length: this.length });
      return this.constructor.name + " " + oe;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(B, z) {
  var Y = this, ne = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
  return ne || ie ? (z ? z(B) : B && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, B)) : pna.nextTick(emitErrorNT, this, B)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(B || null, function(oe) {
    !z && oe ? Y._writableState ? Y._writableState.errorEmitted || (Y._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, Y, oe)) : pna.nextTick(emitErrorNT, Y, oe) : z && z(oe);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(B, z) {
  B.emit("error", z);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = processNextickArgsExports;
  _stream_writable = Nt;
  function z(wt) {
    var vt = this;
    this.next = null, this.entry = null, this.finish = function() {
      ht(vt, wt);
    };
  }
  var Y = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, ne;
  Nt.WritableState = Ve;
  var ie = Object.create(util$2);
  ie.inherits = inherits_browserExports;
  var oe = {
    deprecate: browser$a
  }, se = streamBrowser, ae = safeBufferExports.Buffer, ge = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Ce(wt) {
    return ae.from(wt);
  }
  function le(wt) {
    return ae.isBuffer(wt) || wt instanceof ge;
  }
  var Ee = destroy_1;
  ie.inherits(Nt, se);
  function Je() {
  }
  function Ve(wt, vt) {
    ne = ne || require_stream_duplex(), wt = wt || {};
    var xt = vt instanceof ne;
    this.objectMode = !!wt.objectMode, xt && (this.objectMode = this.objectMode || !!wt.writableObjectMode);
    var Qe = wt.highWaterMark, Rt = wt.writableHighWaterMark, bt = this.objectMode ? 16 : 16 * 1024;
    Qe || Qe === 0 ? this.highWaterMark = Qe : xt && (Rt || Rt === 0) ? this.highWaterMark = Rt : this.highWaterMark = bt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ht = wt.decodeStrings === !1;
    this.decodeStrings = !Ht, this.defaultEncoding = wt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ar) {
      or(vt, ar);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new z(this);
  }
  Ve.prototype.getBuffer = function() {
    for (var vt = this.bufferedRequest, xt = []; vt; )
      xt.push(vt), vt = vt.next;
    return xt;
  }, function() {
    try {
      Object.defineProperty(Ve.prototype, "buffer", {
        get: oe.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var $t;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? ($t = Function.prototype[Symbol.hasInstance], Object.defineProperty(Nt, Symbol.hasInstance, {
    value: function(wt) {
      return $t.call(this, wt) ? !0 : this !== Nt ? !1 : wt && wt._writableState instanceof Ve;
    }
  })) : $t = function(wt) {
    return wt instanceof this;
  };
  function Nt(wt) {
    if (ne = ne || require_stream_duplex(), !$t.call(Nt, this) && !(this instanceof ne))
      return new Nt(wt);
    this._writableState = new Ve(wt, this), this.writable = !0, wt && (typeof wt.write == "function" && (this._write = wt.write), typeof wt.writev == "function" && (this._writev = wt.writev), typeof wt.destroy == "function" && (this._destroy = wt.destroy), typeof wt.final == "function" && (this._final = wt.final)), se.call(this);
  }
  Nt.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Dt(wt, vt) {
    var xt = new Error("write after end");
    wt.emit("error", xt), B.nextTick(vt, xt);
  }
  function Wt(wt, vt, xt, Qe) {
    var Rt = !0, bt = !1;
    return xt === null ? bt = new TypeError("May not write null values to stream") : typeof xt != "string" && xt !== void 0 && !vt.objectMode && (bt = new TypeError("Invalid non-string/buffer chunk")), bt && (wt.emit("error", bt), B.nextTick(Qe, bt), Rt = !1), Rt;
  }
  Nt.prototype.write = function(wt, vt, xt) {
    var Qe = this._writableState, Rt = !1, bt = !Qe.objectMode && le(wt);
    return bt && !ae.isBuffer(wt) && (wt = Ce(wt)), typeof vt == "function" && (xt = vt, vt = null), bt ? vt = "buffer" : vt || (vt = Qe.defaultEncoding), typeof xt != "function" && (xt = Je), Qe.ended ? Dt(this, xt) : (bt || Wt(this, Qe, wt, xt)) && (Qe.pendingcb++, Rt = Lt(this, Qe, bt, wt, vt, xt)), Rt;
  }, Nt.prototype.cork = function() {
    var wt = this._writableState;
    wt.corked++;
  }, Nt.prototype.uncork = function() {
    var wt = this._writableState;
    wt.corked && (wt.corked--, !wt.writing && !wt.corked && !wt.bufferProcessing && wt.bufferedRequest && Vt(this, wt));
  }, Nt.prototype.setDefaultEncoding = function(vt) {
    if (typeof vt == "string" && (vt = vt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((vt + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + vt);
    return this._writableState.defaultEncoding = vt, this;
  };
  function Pt(wt, vt, xt) {
    return !wt.objectMode && wt.decodeStrings !== !1 && typeof vt == "string" && (vt = ae.from(vt, xt)), vt;
  }
  Object.defineProperty(Nt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Lt(wt, vt, xt, Qe, Rt, bt) {
    if (!xt) {
      var Ht = Pt(vt, Qe, Rt);
      Qe !== Ht && (xt = !0, Rt = "buffer", Qe = Ht);
    }
    var ar = vt.objectMode ? 1 : Qe.length;
    vt.length += ar;
    var yr = vt.length < vt.highWaterMark;
    if (yr || (vt.needDrain = !0), vt.writing || vt.corked) {
      var rr = vt.lastBufferedRequest;
      vt.lastBufferedRequest = {
        chunk: Qe,
        encoding: Rt,
        isBuf: xt,
        callback: bt,
        next: null
      }, rr ? rr.next = vt.lastBufferedRequest : vt.bufferedRequest = vt.lastBufferedRequest, vt.bufferedRequestCount += 1;
    } else
      qt(wt, vt, !1, ar, Qe, Rt, bt);
    return yr;
  }
  function qt(wt, vt, xt, Qe, Rt, bt, Ht) {
    vt.writelen = Qe, vt.writecb = Ht, vt.writing = !0, vt.sync = !0, xt ? wt._writev(Rt, vt.onwrite) : wt._write(Rt, bt, vt.onwrite), vt.sync = !1;
  }
  function Zt(wt, vt, xt, Qe, Rt) {
    --vt.pendingcb, xt ? (B.nextTick(Rt, Qe), B.nextTick(ve, wt, vt), wt._writableState.errorEmitted = !0, wt.emit("error", Qe)) : (Rt(Qe), wt._writableState.errorEmitted = !0, wt.emit("error", Qe), ve(wt, vt));
  }
  function Yt(wt) {
    wt.writing = !1, wt.writecb = null, wt.length -= wt.writelen, wt.writelen = 0;
  }
  function or(wt, vt) {
    var xt = wt._writableState, Qe = xt.sync, Rt = xt.writecb;
    if (Yt(xt), vt) Zt(wt, xt, Qe, vt, Rt);
    else {
      var bt = kt(xt);
      !bt && !xt.corked && !xt.bufferProcessing && xt.bufferedRequest && Vt(wt, xt), Qe ? Y(jt, wt, xt, bt, Rt) : jt(wt, xt, bt, Rt);
    }
  }
  function jt(wt, vt, xt, Qe) {
    xt || Ct(wt, vt), vt.pendingcb--, Qe(), ve(wt, vt);
  }
  function Ct(wt, vt) {
    vt.length === 0 && vt.needDrain && (vt.needDrain = !1, wt.emit("drain"));
  }
  function Vt(wt, vt) {
    vt.bufferProcessing = !0;
    var xt = vt.bufferedRequest;
    if (wt._writev && xt && xt.next) {
      var Qe = vt.bufferedRequestCount, Rt = new Array(Qe), bt = vt.corkedRequestsFree;
      bt.entry = xt;
      for (var Ht = 0, ar = !0; xt; )
        Rt[Ht] = xt, xt.isBuf || (ar = !1), xt = xt.next, Ht += 1;
      Rt.allBuffers = ar, qt(wt, vt, !0, vt.length, Rt, "", bt.finish), vt.pendingcb++, vt.lastBufferedRequest = null, bt.next ? (vt.corkedRequestsFree = bt.next, bt.next = null) : vt.corkedRequestsFree = new z(vt), vt.bufferedRequestCount = 0;
    } else {
      for (; xt; ) {
        var yr = xt.chunk, rr = xt.encoding, Kt = xt.callback, Gt = vt.objectMode ? 1 : yr.length;
        if (qt(wt, vt, !1, Gt, yr, rr, Kt), xt = xt.next, vt.bufferedRequestCount--, vt.writing)
          break;
      }
      xt === null && (vt.lastBufferedRequest = null);
    }
    vt.bufferedRequest = xt, vt.bufferProcessing = !1;
  }
  Nt.prototype._write = function(wt, vt, xt) {
    xt(new Error("_write() is not implemented"));
  }, Nt.prototype._writev = null, Nt.prototype.end = function(wt, vt, xt) {
    var Qe = this._writableState;
    typeof wt == "function" ? (xt = wt, wt = null, vt = null) : typeof vt == "function" && (xt = vt, vt = null), wt != null && this.write(wt, vt), Qe.corked && (Qe.corked = 1, this.uncork()), Qe.ending || Ke(this, Qe, xt);
  };
  function kt(wt) {
    return wt.ending && wt.length === 0 && wt.bufferedRequest === null && !wt.finished && !wt.writing;
  }
  function Pe(wt, vt) {
    wt._final(function(xt) {
      vt.pendingcb--, xt && wt.emit("error", xt), vt.prefinished = !0, wt.emit("prefinish"), ve(wt, vt);
    });
  }
  function Xe(wt, vt) {
    !vt.prefinished && !vt.finalCalled && (typeof wt._final == "function" ? (vt.pendingcb++, vt.finalCalled = !0, B.nextTick(Pe, wt, vt)) : (vt.prefinished = !0, wt.emit("prefinish")));
  }
  function ve(wt, vt) {
    var xt = kt(vt);
    return xt && (Xe(wt, vt), vt.pendingcb === 0 && (vt.finished = !0, wt.emit("finish"))), xt;
  }
  function Ke(wt, vt, xt) {
    vt.ending = !0, ve(wt, vt), xt && (vt.finished ? B.nextTick(xt) : wt.once("finish", xt)), vt.ended = !0, wt.writable = !1;
  }
  function ht(wt, vt, xt) {
    var Qe = wt.entry;
    for (wt.entry = null; Qe; ) {
      var Rt = Qe.callback;
      vt.pendingcb--, Rt(xt), Qe = Qe.next;
    }
    vt.corkedRequestsFree.next = wt;
  }
  return Object.defineProperty(Nt.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(wt) {
      this._writableState && (this._writableState.destroyed = wt);
    }
  }), Nt.prototype.destroy = Ee.destroy, Nt.prototype._undestroy = Ee.undestroy, Nt.prototype._destroy = function(wt, vt) {
    this.end(), vt(wt);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = processNextickArgsExports, z = Object.keys || function(Ee) {
    var Je = [];
    for (var Ve in Ee)
      Je.push(Ve);
    return Je;
  };
  _stream_duplex = ge;
  var Y = Object.create(util$2);
  Y.inherits = inherits_browserExports;
  var ne = require_stream_readable(), ie = require_stream_writable();
  Y.inherits(ge, ne);
  for (var oe = z(ie.prototype), se = 0; se < oe.length; se++) {
    var ae = oe[se];
    ge.prototype[ae] || (ge.prototype[ae] = ie.prototype[ae]);
  }
  function ge(Ee) {
    if (!(this instanceof ge)) return new ge(Ee);
    ne.call(this, Ee), ie.call(this, Ee), Ee && Ee.readable === !1 && (this.readable = !1), Ee && Ee.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Ee && Ee.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", Ce);
  }
  Object.defineProperty(ge.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ce() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(le, this);
  }
  function le(Ee) {
    Ee.end();
  }
  return Object.defineProperty(ge.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ee) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ee, this._writableState.destroyed = Ee);
    }
  }), ge.prototype._destroy = function(Ee, Je) {
    this.push(null), this.end(), B.nextTick(Je, Ee);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = processNextickArgsExports;
  _stream_readable = Pt;
  var z = isarray, Y;
  Pt.ReadableState = Wt, eventsExports.EventEmitter;
  var ne = function(Kt, Gt) {
    return Kt.listeners(Gt).length;
  }, ie = streamBrowser, oe = safeBufferExports.Buffer, se = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ae(Kt) {
    return oe.from(Kt);
  }
  function ge(Kt) {
    return oe.isBuffer(Kt) || Kt instanceof se;
  }
  var Ce = Object.create(util$2);
  Ce.inherits = inherits_browserExports;
  var le = util$3, Ee = void 0;
  le && le.debuglog ? Ee = le.debuglog("stream") : Ee = function() {
  };
  var Je = requireBufferList(), Ve = destroy_1, $t;
  Ce.inherits(Pt, ie);
  var Nt = ["error", "close", "destroy", "pause", "resume"];
  function Dt(Kt, Gt, ur) {
    if (typeof Kt.prependListener == "function") return Kt.prependListener(Gt, ur);
    !Kt._events || !Kt._events[Gt] ? Kt.on(Gt, ur) : z(Kt._events[Gt]) ? Kt._events[Gt].unshift(ur) : Kt._events[Gt] = [ur, Kt._events[Gt]];
  }
  function Wt(Kt, Gt) {
    Y = Y || require_stream_duplex(), Kt = Kt || {};
    var ur = Gt instanceof Y;
    this.objectMode = !!Kt.objectMode, ur && (this.objectMode = this.objectMode || !!Kt.readableObjectMode);
    var gr = Kt.highWaterMark, Qt = Kt.readableHighWaterMark, Jt = this.objectMode ? 16 : 16 * 1024;
    gr || gr === 0 ? this.highWaterMark = gr : ur && (Qt || Qt === 0) ? this.highWaterMark = Qt : this.highWaterMark = Jt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Je(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Kt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Kt.encoding && ($t || ($t = string_decoder.StringDecoder), this.decoder = new $t(Kt.encoding), this.encoding = Kt.encoding);
  }
  function Pt(Kt) {
    if (Y = Y || require_stream_duplex(), !(this instanceof Pt)) return new Pt(Kt);
    this._readableState = new Wt(Kt, this), this.readable = !0, Kt && (typeof Kt.read == "function" && (this._read = Kt.read), typeof Kt.destroy == "function" && (this._destroy = Kt.destroy)), ie.call(this);
  }
  Object.defineProperty(Pt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Kt) {
      this._readableState && (this._readableState.destroyed = Kt);
    }
  }), Pt.prototype.destroy = Ve.destroy, Pt.prototype._undestroy = Ve.undestroy, Pt.prototype._destroy = function(Kt, Gt) {
    this.push(null), Gt(Kt);
  }, Pt.prototype.push = function(Kt, Gt) {
    var ur = this._readableState, gr;
    return ur.objectMode ? gr = !0 : typeof Kt == "string" && (Gt = Gt || ur.defaultEncoding, Gt !== ur.encoding && (Kt = oe.from(Kt, Gt), Gt = ""), gr = !0), Lt(this, Kt, Gt, !1, gr);
  }, Pt.prototype.unshift = function(Kt) {
    return Lt(this, Kt, null, !0, !1);
  };
  function Lt(Kt, Gt, ur, gr, Qt) {
    var Jt = Kt._readableState;
    if (Gt === null)
      Jt.reading = !1, Vt(Kt, Jt);
    else {
      var br;
      Qt || (br = Zt(Jt, Gt)), br ? Kt.emit("error", br) : Jt.objectMode || Gt && Gt.length > 0 ? (typeof Gt != "string" && !Jt.objectMode && Object.getPrototypeOf(Gt) !== oe.prototype && (Gt = ae(Gt)), gr ? Jt.endEmitted ? Kt.emit("error", new Error("stream.unshift() after end event")) : qt(Kt, Jt, Gt, !0) : Jt.ended ? Kt.emit("error", new Error("stream.push() after EOF")) : (Jt.reading = !1, Jt.decoder && !ur ? (Gt = Jt.decoder.write(Gt), Jt.objectMode || Gt.length !== 0 ? qt(Kt, Jt, Gt, !1) : Xe(Kt, Jt)) : qt(Kt, Jt, Gt, !1))) : gr || (Jt.reading = !1);
    }
    return Yt(Jt);
  }
  function qt(Kt, Gt, ur, gr) {
    Gt.flowing && Gt.length === 0 && !Gt.sync ? (Kt.emit("data", ur), Kt.read(0)) : (Gt.length += Gt.objectMode ? 1 : ur.length, gr ? Gt.buffer.unshift(ur) : Gt.buffer.push(ur), Gt.needReadable && kt(Kt)), Xe(Kt, Gt);
  }
  function Zt(Kt, Gt) {
    var ur;
    return !ge(Gt) && typeof Gt != "string" && Gt !== void 0 && !Kt.objectMode && (ur = new TypeError("Invalid non-string/buffer chunk")), ur;
  }
  function Yt(Kt) {
    return !Kt.ended && (Kt.needReadable || Kt.length < Kt.highWaterMark || Kt.length === 0);
  }
  Pt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Pt.prototype.setEncoding = function(Kt) {
    return $t || ($t = string_decoder.StringDecoder), this._readableState.decoder = new $t(Kt), this._readableState.encoding = Kt, this;
  };
  var or = 8388608;
  function jt(Kt) {
    return Kt >= or ? Kt = or : (Kt--, Kt |= Kt >>> 1, Kt |= Kt >>> 2, Kt |= Kt >>> 4, Kt |= Kt >>> 8, Kt |= Kt >>> 16, Kt++), Kt;
  }
  function Ct(Kt, Gt) {
    return Kt <= 0 || Gt.length === 0 && Gt.ended ? 0 : Gt.objectMode ? 1 : Kt !== Kt ? Gt.flowing && Gt.length ? Gt.buffer.head.data.length : Gt.length : (Kt > Gt.highWaterMark && (Gt.highWaterMark = jt(Kt)), Kt <= Gt.length ? Kt : Gt.ended ? Gt.length : (Gt.needReadable = !0, 0));
  }
  Pt.prototype.read = function(Kt) {
    Ee("read", Kt), Kt = parseInt(Kt, 10);
    var Gt = this._readableState, ur = Kt;
    if (Kt !== 0 && (Gt.emittedReadable = !1), Kt === 0 && Gt.needReadable && (Gt.length >= Gt.highWaterMark || Gt.ended))
      return Ee("read: emitReadable", Gt.length, Gt.ended), Gt.length === 0 && Gt.ended ? ar(this) : kt(this), null;
    if (Kt = Ct(Kt, Gt), Kt === 0 && Gt.ended)
      return Gt.length === 0 && ar(this), null;
    var gr = Gt.needReadable;
    Ee("need readable", gr), (Gt.length === 0 || Gt.length - Kt < Gt.highWaterMark) && (gr = !0, Ee("length less than watermark", gr)), Gt.ended || Gt.reading ? (gr = !1, Ee("reading or ended", gr)) : gr && (Ee("do read"), Gt.reading = !0, Gt.sync = !0, Gt.length === 0 && (Gt.needReadable = !0), this._read(Gt.highWaterMark), Gt.sync = !1, Gt.reading || (Kt = Ct(ur, Gt)));
    var Qt;
    return Kt > 0 ? Qt = Qe(Kt, Gt) : Qt = null, Qt === null ? (Gt.needReadable = !0, Kt = 0) : Gt.length -= Kt, Gt.length === 0 && (Gt.ended || (Gt.needReadable = !0), ur !== Kt && Gt.ended && ar(this)), Qt !== null && this.emit("data", Qt), Qt;
  };
  function Vt(Kt, Gt) {
    if (!Gt.ended) {
      if (Gt.decoder) {
        var ur = Gt.decoder.end();
        ur && ur.length && (Gt.buffer.push(ur), Gt.length += Gt.objectMode ? 1 : ur.length);
      }
      Gt.ended = !0, kt(Kt);
    }
  }
  function kt(Kt) {
    var Gt = Kt._readableState;
    Gt.needReadable = !1, Gt.emittedReadable || (Ee("emitReadable", Gt.flowing), Gt.emittedReadable = !0, Gt.sync ? B.nextTick(Pe, Kt) : Pe(Kt));
  }
  function Pe(Kt) {
    Ee("emit readable"), Kt.emit("readable"), xt(Kt);
  }
  function Xe(Kt, Gt) {
    Gt.readingMore || (Gt.readingMore = !0, B.nextTick(ve, Kt, Gt));
  }
  function ve(Kt, Gt) {
    for (var ur = Gt.length; !Gt.reading && !Gt.flowing && !Gt.ended && Gt.length < Gt.highWaterMark && (Ee("maybeReadMore read 0"), Kt.read(0), ur !== Gt.length); )
      ur = Gt.length;
    Gt.readingMore = !1;
  }
  Pt.prototype._read = function(Kt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, Pt.prototype.pipe = function(Kt, Gt) {
    var ur = this, gr = this._readableState;
    switch (gr.pipesCount) {
      case 0:
        gr.pipes = Kt;
        break;
      case 1:
        gr.pipes = [gr.pipes, Kt];
        break;
      default:
        gr.pipes.push(Kt);
        break;
    }
    gr.pipesCount += 1, Ee("pipe count=%d opts=%j", gr.pipesCount, Gt);
    var Qt = (!Gt || Gt.end !== !1) && Kt !== process$1.stdout && Kt !== process$1.stderr, Jt = Qt ? Sr : Gr;
    gr.endEmitted ? B.nextTick(Jt) : ur.once("end", Jt), Kt.on("unpipe", br);
    function br(Or, Vr) {
      Ee("onunpipe"), Or === ur && Vr && Vr.hasUnpiped === !1 && (Vr.hasUnpiped = !0, Mr());
    }
    function Sr() {
      Ee("onend"), Kt.end();
    }
    var Ar = Ke(ur);
    Kt.on("drain", Ar);
    var Br = !1;
    function Mr() {
      Ee("cleanup"), Kt.removeListener("close", jr), Kt.removeListener("finish", qr), Kt.removeListener("drain", Ar), Kt.removeListener("error", Qr), Kt.removeListener("unpipe", br), ur.removeListener("end", Sr), ur.removeListener("end", Gr), ur.removeListener("data", $r), Br = !0, gr.awaitDrain && (!Kt._writableState || Kt._writableState.needDrain) && Ar();
    }
    var Cr = !1;
    ur.on("data", $r);
    function $r(Or) {
      Ee("ondata"), Cr = !1;
      var Vr = Kt.write(Or);
      Vr === !1 && !Cr && ((gr.pipesCount === 1 && gr.pipes === Kt || gr.pipesCount > 1 && rr(gr.pipes, Kt) !== -1) && !Br && (Ee("false write response, pause", gr.awaitDrain), gr.awaitDrain++, Cr = !0), ur.pause());
    }
    function Qr(Or) {
      Ee("onerror", Or), Gr(), Kt.removeListener("error", Qr), ne(Kt, "error") === 0 && Kt.emit("error", Or);
    }
    Dt(Kt, "error", Qr);
    function jr() {
      Kt.removeListener("finish", qr), Gr();
    }
    Kt.once("close", jr);
    function qr() {
      Ee("onfinish"), Kt.removeListener("close", jr), Gr();
    }
    Kt.once("finish", qr);
    function Gr() {
      Ee("unpipe"), ur.unpipe(Kt);
    }
    return Kt.emit("pipe", ur), gr.flowing || (Ee("pipe resume"), ur.resume()), Kt;
  };
  function Ke(Kt) {
    return function() {
      var Gt = Kt._readableState;
      Ee("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && ne(Kt, "data") && (Gt.flowing = !0, xt(Kt));
    };
  }
  Pt.prototype.unpipe = function(Kt) {
    var Gt = this._readableState, ur = { hasUnpiped: !1 };
    if (Gt.pipesCount === 0) return this;
    if (Gt.pipesCount === 1)
      return Kt && Kt !== Gt.pipes ? this : (Kt || (Kt = Gt.pipes), Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1, Kt && Kt.emit("unpipe", this, ur), this);
    if (!Kt) {
      var gr = Gt.pipes, Qt = Gt.pipesCount;
      Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1;
      for (var Jt = 0; Jt < Qt; Jt++)
        gr[Jt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var br = rr(Gt.pipes, Kt);
    return br === -1 ? this : (Gt.pipes.splice(br, 1), Gt.pipesCount -= 1, Gt.pipesCount === 1 && (Gt.pipes = Gt.pipes[0]), Kt.emit("unpipe", this, ur), this);
  }, Pt.prototype.on = function(Kt, Gt) {
    var ur = ie.prototype.on.call(this, Kt, Gt);
    if (Kt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Kt === "readable") {
      var gr = this._readableState;
      !gr.endEmitted && !gr.readableListening && (gr.readableListening = gr.needReadable = !0, gr.emittedReadable = !1, gr.reading ? gr.length && kt(this) : B.nextTick(ht, this));
    }
    return ur;
  }, Pt.prototype.addListener = Pt.prototype.on;
  function ht(Kt) {
    Ee("readable nexttick read 0"), Kt.read(0);
  }
  Pt.prototype.resume = function() {
    var Kt = this._readableState;
    return Kt.flowing || (Ee("resume"), Kt.flowing = !0, wt(this, Kt)), this;
  };
  function wt(Kt, Gt) {
    Gt.resumeScheduled || (Gt.resumeScheduled = !0, B.nextTick(vt, Kt, Gt));
  }
  function vt(Kt, Gt) {
    Gt.reading || (Ee("resume read 0"), Kt.read(0)), Gt.resumeScheduled = !1, Gt.awaitDrain = 0, Kt.emit("resume"), xt(Kt), Gt.flowing && !Gt.reading && Kt.read(0);
  }
  Pt.prototype.pause = function() {
    return Ee("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ee("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function xt(Kt) {
    var Gt = Kt._readableState;
    for (Ee("flow", Gt.flowing); Gt.flowing && Kt.read() !== null; )
      ;
  }
  Pt.prototype.wrap = function(Kt) {
    var Gt = this, ur = this._readableState, gr = !1;
    Kt.on("end", function() {
      if (Ee("wrapped end"), ur.decoder && !ur.ended) {
        var br = ur.decoder.end();
        br && br.length && Gt.push(br);
      }
      Gt.push(null);
    }), Kt.on("data", function(br) {
      if (Ee("wrapped data"), ur.decoder && (br = ur.decoder.write(br)), !(ur.objectMode && br == null) && !(!ur.objectMode && (!br || !br.length))) {
        var Sr = Gt.push(br);
        Sr || (gr = !0, Kt.pause());
      }
    });
    for (var Qt in Kt)
      this[Qt] === void 0 && typeof Kt[Qt] == "function" && (this[Qt] = /* @__PURE__ */ function(br) {
        return function() {
          return Kt[br].apply(Kt, arguments);
        };
      }(Qt));
    for (var Jt = 0; Jt < Nt.length; Jt++)
      Kt.on(Nt[Jt], this.emit.bind(this, Nt[Jt]));
    return this._read = function(br) {
      Ee("wrapped _read", br), gr && (gr = !1, Kt.resume());
    }, this;
  }, Object.defineProperty(Pt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Pt._fromList = Qe;
  function Qe(Kt, Gt) {
    if (Gt.length === 0) return null;
    var ur;
    return Gt.objectMode ? ur = Gt.buffer.shift() : !Kt || Kt >= Gt.length ? (Gt.decoder ? ur = Gt.buffer.join("") : Gt.buffer.length === 1 ? ur = Gt.buffer.head.data : ur = Gt.buffer.concat(Gt.length), Gt.buffer.clear()) : ur = Rt(Kt, Gt.buffer, Gt.decoder), ur;
  }
  function Rt(Kt, Gt, ur) {
    var gr;
    return Kt < Gt.head.data.length ? (gr = Gt.head.data.slice(0, Kt), Gt.head.data = Gt.head.data.slice(Kt)) : Kt === Gt.head.data.length ? gr = Gt.shift() : gr = ur ? bt(Kt, Gt) : Ht(Kt, Gt), gr;
  }
  function bt(Kt, Gt) {
    var ur = Gt.head, gr = 1, Qt = ur.data;
    for (Kt -= Qt.length; ur = ur.next; ) {
      var Jt = ur.data, br = Kt > Jt.length ? Jt.length : Kt;
      if (br === Jt.length ? Qt += Jt : Qt += Jt.slice(0, Kt), Kt -= br, Kt === 0) {
        br === Jt.length ? (++gr, ur.next ? Gt.head = ur.next : Gt.head = Gt.tail = null) : (Gt.head = ur, ur.data = Jt.slice(br));
        break;
      }
      ++gr;
    }
    return Gt.length -= gr, Qt;
  }
  function Ht(Kt, Gt) {
    var ur = oe.allocUnsafe(Kt), gr = Gt.head, Qt = 1;
    for (gr.data.copy(ur), Kt -= gr.data.length; gr = gr.next; ) {
      var Jt = gr.data, br = Kt > Jt.length ? Jt.length : Kt;
      if (Jt.copy(ur, ur.length - Kt, 0, br), Kt -= br, Kt === 0) {
        br === Jt.length ? (++Qt, gr.next ? Gt.head = gr.next : Gt.head = Gt.tail = null) : (Gt.head = gr, gr.data = Jt.slice(br));
        break;
      }
      ++Qt;
    }
    return Gt.length -= Qt, ur;
  }
  function ar(Kt) {
    var Gt = Kt._readableState;
    if (Gt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Gt.endEmitted || (Gt.ended = !0, B.nextTick(yr, Gt, Kt));
  }
  function yr(Kt, Gt) {
    !Kt.endEmitted && Kt.length === 0 && (Kt.endEmitted = !0, Gt.readable = !1, Gt.emit("end"));
  }
  function rr(Kt, Gt) {
    for (var ur = 0, gr = Kt.length; ur < gr; ur++)
      if (Kt[ur] === Gt) return ur;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(B, z) {
  var Y = this._transformState;
  Y.transforming = !1;
  var ne = Y.writecb;
  if (!ne)
    return this.emit("error", new Error("write callback called multiple times"));
  Y.writechunk = null, Y.writecb = null, z != null && this.push(z), ne(B);
  var ie = this._readableState;
  ie.reading = !1, (ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark);
}
function Transform$1(B) {
  if (!(this instanceof Transform$1)) return new Transform$1(B);
  Duplex.call(this, B), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var B = this;
  typeof this._flush == "function" ? this._flush(function(z, Y) {
    done(B, z, Y);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(B, z) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, B, z);
};
Transform$1.prototype._transform = function(B, z, Y) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(B, z, Y) {
  var ne = this._transformState;
  if (ne.writecb = Y, ne.writechunk = B, ne.writeencoding = z, !ne.transforming) {
    var ie = this._readableState;
    (ne.needTransform || ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark);
  }
};
Transform$1.prototype._read = function(B) {
  var z = this._transformState;
  z.writechunk !== null && z.writecb && !z.transforming ? (z.transforming = !0, this._transform(z.writechunk, z.writeencoding, z.afterTransform)) : z.needTransform = !0;
};
Transform$1.prototype._destroy = function(B, z) {
  var Y = this;
  Duplex.prototype._destroy.call(this, B, function(ne) {
    z(ne), Y.emit("close");
  });
};
function done(B, z, Y) {
  if (z) return B.emit("error", z);
  if (Y != null && B.push(Y), B._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (B._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return B.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(B) {
  if (!(this instanceof PassThrough)) return new PassThrough(B);
  Transform.call(this, B);
}
PassThrough.prototype._transform = function(B, z, Y) {
  Y(null, B);
};
(function(B, z) {
  z = B.exports = require_stream_readable(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable(), z.Duplex = require_stream_duplex(), z.Transform = _stream_transform, z.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn = { exports: {} };
bn.exports;
(function(B) {
  (function(z, Y) {
    function ne(Xe, ve) {
      if (!Xe) throw new Error(ve || "Assertion failed");
    }
    function ie(Xe, ve) {
      Xe.super_ = ve;
      var Ke = function() {
      };
      Ke.prototype = ve.prototype, Xe.prototype = new Ke(), Xe.prototype.constructor = Xe;
    }
    function oe(Xe, ve, Ke) {
      if (oe.isBN(Xe))
        return Xe;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, Xe !== null && ((ve === "le" || ve === "be") && (Ke = ve, ve = 10), this._init(Xe || 0, ve || 10, Ke || "be"));
    }
    typeof z == "object" ? z.exports = oe : Y.BN = oe, oe.BN = oe, oe.wordSize = 26;
    var se;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? se = window.Buffer : se = dist$1.Buffer;
    } catch {
    }
    oe.isBN = function(ve) {
      return ve instanceof oe ? !0 : ve !== null && typeof ve == "object" && ve.constructor.wordSize === oe.wordSize && Array.isArray(ve.words);
    }, oe.max = function(ve, Ke) {
      return ve.cmp(Ke) > 0 ? ve : Ke;
    }, oe.min = function(ve, Ke) {
      return ve.cmp(Ke) < 0 ? ve : Ke;
    }, oe.prototype._init = function(ve, Ke, ht) {
      if (typeof ve == "number")
        return this._initNumber(ve, Ke, ht);
      if (typeof ve == "object")
        return this._initArray(ve, Ke, ht);
      Ke === "hex" && (Ke = 16), ne(Ke === (Ke | 0) && Ke >= 2 && Ke <= 36), ve = ve.toString().replace(/\s+/g, "");
      var wt = 0;
      ve[0] === "-" && (wt++, this.negative = 1), wt < ve.length && (Ke === 16 ? this._parseHex(ve, wt, ht) : (this._parseBase(ve, Ke, wt), ht === "le" && this._initArray(this.toArray(), Ke, ht)));
    }, oe.prototype._initNumber = function(ve, Ke, ht) {
      ve < 0 && (this.negative = 1, ve = -ve), ve < 67108864 ? (this.words = [ve & 67108863], this.length = 1) : ve < 4503599627370496 ? (this.words = [
        ve & 67108863,
        ve / 67108864 & 67108863
      ], this.length = 2) : (ne(ve < 9007199254740992), this.words = [
        ve & 67108863,
        ve / 67108864 & 67108863,
        1
      ], this.length = 3), ht === "le" && this._initArray(this.toArray(), Ke, ht);
    }, oe.prototype._initArray = function(ve, Ke, ht) {
      if (ne(typeof ve.length == "number"), ve.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ve.length / 3), this.words = new Array(this.length);
      for (var wt = 0; wt < this.length; wt++)
        this.words[wt] = 0;
      var vt, xt, Qe = 0;
      if (ht === "be")
        for (wt = ve.length - 1, vt = 0; wt >= 0; wt -= 3)
          xt = ve[wt] | ve[wt - 1] << 8 | ve[wt - 2] << 16, this.words[vt] |= xt << Qe & 67108863, this.words[vt + 1] = xt >>> 26 - Qe & 67108863, Qe += 24, Qe >= 26 && (Qe -= 26, vt++);
      else if (ht === "le")
        for (wt = 0, vt = 0; wt < ve.length; wt += 3)
          xt = ve[wt] | ve[wt + 1] << 8 | ve[wt + 2] << 16, this.words[vt] |= xt << Qe & 67108863, this.words[vt + 1] = xt >>> 26 - Qe & 67108863, Qe += 24, Qe >= 26 && (Qe -= 26, vt++);
      return this._strip();
    };
    function ae(Xe, ve) {
      var Ke = Xe.charCodeAt(ve);
      if (Ke >= 48 && Ke <= 57)
        return Ke - 48;
      if (Ke >= 65 && Ke <= 70)
        return Ke - 55;
      if (Ke >= 97 && Ke <= 102)
        return Ke - 87;
      ne(!1, "Invalid character in " + Xe);
    }
    function ge(Xe, ve, Ke) {
      var ht = ae(Xe, Ke);
      return Ke - 1 >= ve && (ht |= ae(Xe, Ke - 1) << 4), ht;
    }
    oe.prototype._parseHex = function(ve, Ke, ht) {
      this.length = Math.ceil((ve.length - Ke) / 6), this.words = new Array(this.length);
      for (var wt = 0; wt < this.length; wt++)
        this.words[wt] = 0;
      var vt = 0, xt = 0, Qe;
      if (ht === "be")
        for (wt = ve.length - 1; wt >= Ke; wt -= 2)
          Qe = ge(ve, Ke, wt) << vt, this.words[xt] |= Qe & 67108863, vt >= 18 ? (vt -= 18, xt += 1, this.words[xt] |= Qe >>> 26) : vt += 8;
      else {
        var Rt = ve.length - Ke;
        for (wt = Rt % 2 === 0 ? Ke + 1 : Ke; wt < ve.length; wt += 2)
          Qe = ge(ve, Ke, wt) << vt, this.words[xt] |= Qe & 67108863, vt >= 18 ? (vt -= 18, xt += 1, this.words[xt] |= Qe >>> 26) : vt += 8;
      }
      this._strip();
    };
    function Ce(Xe, ve, Ke, ht) {
      for (var wt = 0, vt = 0, xt = Math.min(Xe.length, Ke), Qe = ve; Qe < xt; Qe++) {
        var Rt = Xe.charCodeAt(Qe) - 48;
        wt *= ht, Rt >= 49 ? vt = Rt - 49 + 10 : Rt >= 17 ? vt = Rt - 17 + 10 : vt = Rt, ne(Rt >= 0 && vt < ht, "Invalid character"), wt += vt;
      }
      return wt;
    }
    oe.prototype._parseBase = function(ve, Ke, ht) {
      this.words = [0], this.length = 1;
      for (var wt = 0, vt = 1; vt <= 67108863; vt *= Ke)
        wt++;
      wt--, vt = vt / Ke | 0;
      for (var xt = ve.length - ht, Qe = xt % wt, Rt = Math.min(xt, xt - Qe) + ht, bt = 0, Ht = ht; Ht < Rt; Ht += wt)
        bt = Ce(ve, Ht, Ht + wt, Ke), this.imuln(vt), this.words[0] + bt < 67108864 ? this.words[0] += bt : this._iaddn(bt);
      if (Qe !== 0) {
        var ar = 1;
        for (bt = Ce(ve, Ht, ve.length, Ke), Ht = 0; Ht < Qe; Ht++)
          ar *= Ke;
        this.imuln(ar), this.words[0] + bt < 67108864 ? this.words[0] += bt : this._iaddn(bt);
      }
      this._strip();
    }, oe.prototype.copy = function(ve) {
      ve.words = new Array(this.length);
      for (var Ke = 0; Ke < this.length; Ke++)
        ve.words[Ke] = this.words[Ke];
      ve.length = this.length, ve.negative = this.negative, ve.red = this.red;
    };
    function le(Xe, ve) {
      Xe.words = ve.words, Xe.length = ve.length, Xe.negative = ve.negative, Xe.red = ve.red;
    }
    if (oe.prototype._move = function(ve) {
      le(ve, this);
    }, oe.prototype.clone = function() {
      var ve = new oe(null);
      return this.copy(ve), ve;
    }, oe.prototype._expand = function(ve) {
      for (; this.length < ve; )
        this.words[this.length++] = 0;
      return this;
    }, oe.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, oe.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        oe.prototype[Symbol.for("nodejs.util.inspect.custom")] = Ee;
      } catch {
        oe.prototype.inspect = Ee;
      }
    else
      oe.prototype.inspect = Ee;
    function Ee() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Je = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ve = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], $t = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    oe.prototype.toString = function(ve, Ke) {
      ve = ve || 10, Ke = Ke | 0 || 1;
      var ht;
      if (ve === 16 || ve === "hex") {
        ht = "";
        for (var wt = 0, vt = 0, xt = 0; xt < this.length; xt++) {
          var Qe = this.words[xt], Rt = ((Qe << wt | vt) & 16777215).toString(16);
          vt = Qe >>> 24 - wt & 16777215, wt += 2, wt >= 26 && (wt -= 26, xt--), vt !== 0 || xt !== this.length - 1 ? ht = Je[6 - Rt.length] + Rt + ht : ht = Rt + ht;
        }
        for (vt !== 0 && (ht = vt.toString(16) + ht); ht.length % Ke !== 0; )
          ht = "0" + ht;
        return this.negative !== 0 && (ht = "-" + ht), ht;
      }
      if (ve === (ve | 0) && ve >= 2 && ve <= 36) {
        var bt = Ve[ve], Ht = $t[ve];
        ht = "";
        var ar = this.clone();
        for (ar.negative = 0; !ar.isZero(); ) {
          var yr = ar.modrn(Ht).toString(ve);
          ar = ar.idivn(Ht), ar.isZero() ? ht = yr + ht : ht = Je[bt - yr.length] + yr + ht;
        }
        for (this.isZero() && (ht = "0" + ht); ht.length % Ke !== 0; )
          ht = "0" + ht;
        return this.negative !== 0 && (ht = "-" + ht), ht;
      }
      ne(!1, "Base should be between 2 and 36");
    }, oe.prototype.toNumber = function() {
      var ve = this.words[0];
      return this.length === 2 ? ve += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ve += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ve : ve;
    }, oe.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, se && (oe.prototype.toBuffer = function(ve, Ke) {
      return this.toArrayLike(se, ve, Ke);
    }), oe.prototype.toArray = function(ve, Ke) {
      return this.toArrayLike(Array, ve, Ke);
    };
    var Nt = function(ve, Ke) {
      return ve.allocUnsafe ? ve.allocUnsafe(Ke) : new ve(Ke);
    };
    oe.prototype.toArrayLike = function(ve, Ke, ht) {
      this._strip();
      var wt = this.byteLength(), vt = ht || Math.max(1, wt);
      ne(wt <= vt, "byte array longer than desired length"), ne(vt > 0, "Requested array length <= 0");
      var xt = Nt(ve, vt), Qe = Ke === "le" ? "LE" : "BE";
      return this["_toArrayLike" + Qe](xt, wt), xt;
    }, oe.prototype._toArrayLikeLE = function(ve, Ke) {
      for (var ht = 0, wt = 0, vt = 0, xt = 0; vt < this.length; vt++) {
        var Qe = this.words[vt] << xt | wt;
        ve[ht++] = Qe & 255, ht < ve.length && (ve[ht++] = Qe >> 8 & 255), ht < ve.length && (ve[ht++] = Qe >> 16 & 255), xt === 6 ? (ht < ve.length && (ve[ht++] = Qe >> 24 & 255), wt = 0, xt = 0) : (wt = Qe >>> 24, xt += 2);
      }
      if (ht < ve.length)
        for (ve[ht++] = wt; ht < ve.length; )
          ve[ht++] = 0;
    }, oe.prototype._toArrayLikeBE = function(ve, Ke) {
      for (var ht = ve.length - 1, wt = 0, vt = 0, xt = 0; vt < this.length; vt++) {
        var Qe = this.words[vt] << xt | wt;
        ve[ht--] = Qe & 255, ht >= 0 && (ve[ht--] = Qe >> 8 & 255), ht >= 0 && (ve[ht--] = Qe >> 16 & 255), xt === 6 ? (ht >= 0 && (ve[ht--] = Qe >> 24 & 255), wt = 0, xt = 0) : (wt = Qe >>> 24, xt += 2);
      }
      if (ht >= 0)
        for (ve[ht--] = wt; ht >= 0; )
          ve[ht--] = 0;
    }, Math.clz32 ? oe.prototype._countBits = function(ve) {
      return 32 - Math.clz32(ve);
    } : oe.prototype._countBits = function(ve) {
      var Ke = ve, ht = 0;
      return Ke >= 4096 && (ht += 13, Ke >>>= 13), Ke >= 64 && (ht += 7, Ke >>>= 7), Ke >= 8 && (ht += 4, Ke >>>= 4), Ke >= 2 && (ht += 2, Ke >>>= 2), ht + Ke;
    }, oe.prototype._zeroBits = function(ve) {
      if (ve === 0) return 26;
      var Ke = ve, ht = 0;
      return Ke & 8191 || (ht += 13, Ke >>>= 13), Ke & 127 || (ht += 7, Ke >>>= 7), Ke & 15 || (ht += 4, Ke >>>= 4), Ke & 3 || (ht += 2, Ke >>>= 2), Ke & 1 || ht++, ht;
    }, oe.prototype.bitLength = function() {
      var ve = this.words[this.length - 1], Ke = this._countBits(ve);
      return (this.length - 1) * 26 + Ke;
    };
    function Dt(Xe) {
      for (var ve = new Array(Xe.bitLength()), Ke = 0; Ke < ve.length; Ke++) {
        var ht = Ke / 26 | 0, wt = Ke % 26;
        ve[Ke] = Xe.words[ht] >>> wt & 1;
      }
      return ve;
    }
    oe.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ve = 0, Ke = 0; Ke < this.length; Ke++) {
        var ht = this._zeroBits(this.words[Ke]);
        if (ve += ht, ht !== 26) break;
      }
      return ve;
    }, oe.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, oe.prototype.toTwos = function(ve) {
      return this.negative !== 0 ? this.abs().inotn(ve).iaddn(1) : this.clone();
    }, oe.prototype.fromTwos = function(ve) {
      return this.testn(ve - 1) ? this.notn(ve).iaddn(1).ineg() : this.clone();
    }, oe.prototype.isNeg = function() {
      return this.negative !== 0;
    }, oe.prototype.neg = function() {
      return this.clone().ineg();
    }, oe.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, oe.prototype.iuor = function(ve) {
      for (; this.length < ve.length; )
        this.words[this.length++] = 0;
      for (var Ke = 0; Ke < ve.length; Ke++)
        this.words[Ke] = this.words[Ke] | ve.words[Ke];
      return this._strip();
    }, oe.prototype.ior = function(ve) {
      return ne((this.negative | ve.negative) === 0), this.iuor(ve);
    }, oe.prototype.or = function(ve) {
      return this.length > ve.length ? this.clone().ior(ve) : ve.clone().ior(this);
    }, oe.prototype.uor = function(ve) {
      return this.length > ve.length ? this.clone().iuor(ve) : ve.clone().iuor(this);
    }, oe.prototype.iuand = function(ve) {
      var Ke;
      this.length > ve.length ? Ke = ve : Ke = this;
      for (var ht = 0; ht < Ke.length; ht++)
        this.words[ht] = this.words[ht] & ve.words[ht];
      return this.length = Ke.length, this._strip();
    }, oe.prototype.iand = function(ve) {
      return ne((this.negative | ve.negative) === 0), this.iuand(ve);
    }, oe.prototype.and = function(ve) {
      return this.length > ve.length ? this.clone().iand(ve) : ve.clone().iand(this);
    }, oe.prototype.uand = function(ve) {
      return this.length > ve.length ? this.clone().iuand(ve) : ve.clone().iuand(this);
    }, oe.prototype.iuxor = function(ve) {
      var Ke, ht;
      this.length > ve.length ? (Ke = this, ht = ve) : (Ke = ve, ht = this);
      for (var wt = 0; wt < ht.length; wt++)
        this.words[wt] = Ke.words[wt] ^ ht.words[wt];
      if (this !== Ke)
        for (; wt < Ke.length; wt++)
          this.words[wt] = Ke.words[wt];
      return this.length = Ke.length, this._strip();
    }, oe.prototype.ixor = function(ve) {
      return ne((this.negative | ve.negative) === 0), this.iuxor(ve);
    }, oe.prototype.xor = function(ve) {
      return this.length > ve.length ? this.clone().ixor(ve) : ve.clone().ixor(this);
    }, oe.prototype.uxor = function(ve) {
      return this.length > ve.length ? this.clone().iuxor(ve) : ve.clone().iuxor(this);
    }, oe.prototype.inotn = function(ve) {
      ne(typeof ve == "number" && ve >= 0);
      var Ke = Math.ceil(ve / 26) | 0, ht = ve % 26;
      this._expand(Ke), ht > 0 && Ke--;
      for (var wt = 0; wt < Ke; wt++)
        this.words[wt] = ~this.words[wt] & 67108863;
      return ht > 0 && (this.words[wt] = ~this.words[wt] & 67108863 >> 26 - ht), this._strip();
    }, oe.prototype.notn = function(ve) {
      return this.clone().inotn(ve);
    }, oe.prototype.setn = function(ve, Ke) {
      ne(typeof ve == "number" && ve >= 0);
      var ht = ve / 26 | 0, wt = ve % 26;
      return this._expand(ht + 1), Ke ? this.words[ht] = this.words[ht] | 1 << wt : this.words[ht] = this.words[ht] & ~(1 << wt), this._strip();
    }, oe.prototype.iadd = function(ve) {
      var Ke;
      if (this.negative !== 0 && ve.negative === 0)
        return this.negative = 0, Ke = this.isub(ve), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ve.negative !== 0)
        return ve.negative = 0, Ke = this.isub(ve), ve.negative = 1, Ke._normSign();
      var ht, wt;
      this.length > ve.length ? (ht = this, wt = ve) : (ht = ve, wt = this);
      for (var vt = 0, xt = 0; xt < wt.length; xt++)
        Ke = (ht.words[xt] | 0) + (wt.words[xt] | 0) + vt, this.words[xt] = Ke & 67108863, vt = Ke >>> 26;
      for (; vt !== 0 && xt < ht.length; xt++)
        Ke = (ht.words[xt] | 0) + vt, this.words[xt] = Ke & 67108863, vt = Ke >>> 26;
      if (this.length = ht.length, vt !== 0)
        this.words[this.length] = vt, this.length++;
      else if (ht !== this)
        for (; xt < ht.length; xt++)
          this.words[xt] = ht.words[xt];
      return this;
    }, oe.prototype.add = function(ve) {
      var Ke;
      return ve.negative !== 0 && this.negative === 0 ? (ve.negative = 0, Ke = this.sub(ve), ve.negative ^= 1, Ke) : ve.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ke = ve.sub(this), this.negative = 1, Ke) : this.length > ve.length ? this.clone().iadd(ve) : ve.clone().iadd(this);
    }, oe.prototype.isub = function(ve) {
      if (ve.negative !== 0) {
        ve.negative = 0;
        var Ke = this.iadd(ve);
        return ve.negative = 1, Ke._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ve), this.negative = 1, this._normSign();
      var ht = this.cmp(ve);
      if (ht === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var wt, vt;
      ht > 0 ? (wt = this, vt = ve) : (wt = ve, vt = this);
      for (var xt = 0, Qe = 0; Qe < vt.length; Qe++)
        Ke = (wt.words[Qe] | 0) - (vt.words[Qe] | 0) + xt, xt = Ke >> 26, this.words[Qe] = Ke & 67108863;
      for (; xt !== 0 && Qe < wt.length; Qe++)
        Ke = (wt.words[Qe] | 0) + xt, xt = Ke >> 26, this.words[Qe] = Ke & 67108863;
      if (xt === 0 && Qe < wt.length && wt !== this)
        for (; Qe < wt.length; Qe++)
          this.words[Qe] = wt.words[Qe];
      return this.length = Math.max(this.length, Qe), wt !== this && (this.negative = 1), this._strip();
    }, oe.prototype.sub = function(ve) {
      return this.clone().isub(ve);
    };
    function Wt(Xe, ve, Ke) {
      Ke.negative = ve.negative ^ Xe.negative;
      var ht = Xe.length + ve.length | 0;
      Ke.length = ht, ht = ht - 1 | 0;
      var wt = Xe.words[0] | 0, vt = ve.words[0] | 0, xt = wt * vt, Qe = xt & 67108863, Rt = xt / 67108864 | 0;
      Ke.words[0] = Qe;
      for (var bt = 1; bt < ht; bt++) {
        for (var Ht = Rt >>> 26, ar = Rt & 67108863, yr = Math.min(bt, ve.length - 1), rr = Math.max(0, bt - Xe.length + 1); rr <= yr; rr++) {
          var Kt = bt - rr | 0;
          wt = Xe.words[Kt] | 0, vt = ve.words[rr] | 0, xt = wt * vt + ar, Ht += xt / 67108864 | 0, ar = xt & 67108863;
        }
        Ke.words[bt] = ar | 0, Rt = Ht | 0;
      }
      return Rt !== 0 ? Ke.words[bt] = Rt | 0 : Ke.length--, Ke._strip();
    }
    var Pt = function(ve, Ke, ht) {
      var wt = ve.words, vt = Ke.words, xt = ht.words, Qe = 0, Rt, bt, Ht, ar = wt[0] | 0, yr = ar & 8191, rr = ar >>> 13, Kt = wt[1] | 0, Gt = Kt & 8191, ur = Kt >>> 13, gr = wt[2] | 0, Qt = gr & 8191, Jt = gr >>> 13, br = wt[3] | 0, Sr = br & 8191, Ar = br >>> 13, Br = wt[4] | 0, Mr = Br & 8191, Cr = Br >>> 13, $r = wt[5] | 0, Qr = $r & 8191, jr = $r >>> 13, qr = wt[6] | 0, Gr = qr & 8191, Or = qr >>> 13, Vr = wt[7] | 0, Zr = Vr & 8191, Lr = Vr >>> 13, Yr = wt[8] | 0, en = Yr & 8191, zt = Yr >>> 13, Ot = wt[9] | 0, Ut = Ot & 8191, tr = Ot >>> 13, lr = vt[0] | 0, vr = lr & 8191, _r = lr >>> 13, Rr = vt[1] | 0, Wr = Rr & 8191, Ir = Rr >>> 13, Hr = vt[2] | 0, Fr = Hr & 8191, Nr = Hr >>> 13, Jr = vt[3] | 0, nn = Jr & 8191, fr = Jr >>> 13, er = vt[4] | 0, cr = er & 8191, Ft = er >>> 13, _t = vt[5] | 0, Bt = _t & 8191, Xt = _t >>> 13, ir = vt[6] | 0, dr = ir & 8191, pr = ir >>> 13, xr = vt[7] | 0, Tr = xr & 8191, nr = xr >>> 13, wr = vt[8] | 0, Er = wr & 8191, Pr = wr >>> 13, Dr = vt[9] | 0, Ur = Dr & 8191, kr = Dr >>> 13;
      ht.negative = ve.negative ^ Ke.negative, ht.length = 19, Rt = Math.imul(yr, vr), bt = Math.imul(yr, _r), bt = bt + Math.imul(rr, vr) | 0, Ht = Math.imul(rr, _r);
      var Xr = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, Rt = Math.imul(Gt, vr), bt = Math.imul(Gt, _r), bt = bt + Math.imul(ur, vr) | 0, Ht = Math.imul(ur, _r), Rt = Rt + Math.imul(yr, Wr) | 0, bt = bt + Math.imul(yr, Ir) | 0, bt = bt + Math.imul(rr, Wr) | 0, Ht = Ht + Math.imul(rr, Ir) | 0;
      var sn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, Rt = Math.imul(Qt, vr), bt = Math.imul(Qt, _r), bt = bt + Math.imul(Jt, vr) | 0, Ht = Math.imul(Jt, _r), Rt = Rt + Math.imul(Gt, Wr) | 0, bt = bt + Math.imul(Gt, Ir) | 0, bt = bt + Math.imul(ur, Wr) | 0, Ht = Ht + Math.imul(ur, Ir) | 0, Rt = Rt + Math.imul(yr, Fr) | 0, bt = bt + Math.imul(yr, Nr) | 0, bt = bt + Math.imul(rr, Fr) | 0, Ht = Ht + Math.imul(rr, Nr) | 0;
      var tn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, Rt = Math.imul(Sr, vr), bt = Math.imul(Sr, _r), bt = bt + Math.imul(Ar, vr) | 0, Ht = Math.imul(Ar, _r), Rt = Rt + Math.imul(Qt, Wr) | 0, bt = bt + Math.imul(Qt, Ir) | 0, bt = bt + Math.imul(Jt, Wr) | 0, Ht = Ht + Math.imul(Jt, Ir) | 0, Rt = Rt + Math.imul(Gt, Fr) | 0, bt = bt + Math.imul(Gt, Nr) | 0, bt = bt + Math.imul(ur, Fr) | 0, Ht = Ht + Math.imul(ur, Nr) | 0, Rt = Rt + Math.imul(yr, nn) | 0, bt = bt + Math.imul(yr, fr) | 0, bt = bt + Math.imul(rr, nn) | 0, Ht = Ht + Math.imul(rr, fr) | 0;
      var on = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, Rt = Math.imul(Mr, vr), bt = Math.imul(Mr, _r), bt = bt + Math.imul(Cr, vr) | 0, Ht = Math.imul(Cr, _r), Rt = Rt + Math.imul(Sr, Wr) | 0, bt = bt + Math.imul(Sr, Ir) | 0, bt = bt + Math.imul(Ar, Wr) | 0, Ht = Ht + Math.imul(Ar, Ir) | 0, Rt = Rt + Math.imul(Qt, Fr) | 0, bt = bt + Math.imul(Qt, Nr) | 0, bt = bt + Math.imul(Jt, Fr) | 0, Ht = Ht + Math.imul(Jt, Nr) | 0, Rt = Rt + Math.imul(Gt, nn) | 0, bt = bt + Math.imul(Gt, fr) | 0, bt = bt + Math.imul(ur, nn) | 0, Ht = Ht + Math.imul(ur, fr) | 0, Rt = Rt + Math.imul(yr, cr) | 0, bt = bt + Math.imul(yr, Ft) | 0, bt = bt + Math.imul(rr, cr) | 0, Ht = Ht + Math.imul(rr, Ft) | 0;
      var cn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, Rt = Math.imul(Qr, vr), bt = Math.imul(Qr, _r), bt = bt + Math.imul(jr, vr) | 0, Ht = Math.imul(jr, _r), Rt = Rt + Math.imul(Mr, Wr) | 0, bt = bt + Math.imul(Mr, Ir) | 0, bt = bt + Math.imul(Cr, Wr) | 0, Ht = Ht + Math.imul(Cr, Ir) | 0, Rt = Rt + Math.imul(Sr, Fr) | 0, bt = bt + Math.imul(Sr, Nr) | 0, bt = bt + Math.imul(Ar, Fr) | 0, Ht = Ht + Math.imul(Ar, Nr) | 0, Rt = Rt + Math.imul(Qt, nn) | 0, bt = bt + Math.imul(Qt, fr) | 0, bt = bt + Math.imul(Jt, nn) | 0, Ht = Ht + Math.imul(Jt, fr) | 0, Rt = Rt + Math.imul(Gt, cr) | 0, bt = bt + Math.imul(Gt, Ft) | 0, bt = bt + Math.imul(ur, cr) | 0, Ht = Ht + Math.imul(ur, Ft) | 0, Rt = Rt + Math.imul(yr, Bt) | 0, bt = bt + Math.imul(yr, Xt) | 0, bt = bt + Math.imul(rr, Bt) | 0, Ht = Ht + Math.imul(rr, Xt) | 0;
      var ln = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, Rt = Math.imul(Gr, vr), bt = Math.imul(Gr, _r), bt = bt + Math.imul(Or, vr) | 0, Ht = Math.imul(Or, _r), Rt = Rt + Math.imul(Qr, Wr) | 0, bt = bt + Math.imul(Qr, Ir) | 0, bt = bt + Math.imul(jr, Wr) | 0, Ht = Ht + Math.imul(jr, Ir) | 0, Rt = Rt + Math.imul(Mr, Fr) | 0, bt = bt + Math.imul(Mr, Nr) | 0, bt = bt + Math.imul(Cr, Fr) | 0, Ht = Ht + Math.imul(Cr, Nr) | 0, Rt = Rt + Math.imul(Sr, nn) | 0, bt = bt + Math.imul(Sr, fr) | 0, bt = bt + Math.imul(Ar, nn) | 0, Ht = Ht + Math.imul(Ar, fr) | 0, Rt = Rt + Math.imul(Qt, cr) | 0, bt = bt + Math.imul(Qt, Ft) | 0, bt = bt + Math.imul(Jt, cr) | 0, Ht = Ht + Math.imul(Jt, Ft) | 0, Rt = Rt + Math.imul(Gt, Bt) | 0, bt = bt + Math.imul(Gt, Xt) | 0, bt = bt + Math.imul(ur, Bt) | 0, Ht = Ht + Math.imul(ur, Xt) | 0, Rt = Rt + Math.imul(yr, dr) | 0, bt = bt + Math.imul(yr, pr) | 0, bt = bt + Math.imul(rr, dr) | 0, Ht = Ht + Math.imul(rr, pr) | 0;
      var un = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, Rt = Math.imul(Zr, vr), bt = Math.imul(Zr, _r), bt = bt + Math.imul(Lr, vr) | 0, Ht = Math.imul(Lr, _r), Rt = Rt + Math.imul(Gr, Wr) | 0, bt = bt + Math.imul(Gr, Ir) | 0, bt = bt + Math.imul(Or, Wr) | 0, Ht = Ht + Math.imul(Or, Ir) | 0, Rt = Rt + Math.imul(Qr, Fr) | 0, bt = bt + Math.imul(Qr, Nr) | 0, bt = bt + Math.imul(jr, Fr) | 0, Ht = Ht + Math.imul(jr, Nr) | 0, Rt = Rt + Math.imul(Mr, nn) | 0, bt = bt + Math.imul(Mr, fr) | 0, bt = bt + Math.imul(Cr, nn) | 0, Ht = Ht + Math.imul(Cr, fr) | 0, Rt = Rt + Math.imul(Sr, cr) | 0, bt = bt + Math.imul(Sr, Ft) | 0, bt = bt + Math.imul(Ar, cr) | 0, Ht = Ht + Math.imul(Ar, Ft) | 0, Rt = Rt + Math.imul(Qt, Bt) | 0, bt = bt + Math.imul(Qt, Xt) | 0, bt = bt + Math.imul(Jt, Bt) | 0, Ht = Ht + Math.imul(Jt, Xt) | 0, Rt = Rt + Math.imul(Gt, dr) | 0, bt = bt + Math.imul(Gt, pr) | 0, bt = bt + Math.imul(ur, dr) | 0, Ht = Ht + Math.imul(ur, pr) | 0, Rt = Rt + Math.imul(yr, Tr) | 0, bt = bt + Math.imul(yr, nr) | 0, bt = bt + Math.imul(rr, Tr) | 0, Ht = Ht + Math.imul(rr, nr) | 0;
      var an = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, Rt = Math.imul(en, vr), bt = Math.imul(en, _r), bt = bt + Math.imul(zt, vr) | 0, Ht = Math.imul(zt, _r), Rt = Rt + Math.imul(Zr, Wr) | 0, bt = bt + Math.imul(Zr, Ir) | 0, bt = bt + Math.imul(Lr, Wr) | 0, Ht = Ht + Math.imul(Lr, Ir) | 0, Rt = Rt + Math.imul(Gr, Fr) | 0, bt = bt + Math.imul(Gr, Nr) | 0, bt = bt + Math.imul(Or, Fr) | 0, Ht = Ht + Math.imul(Or, Nr) | 0, Rt = Rt + Math.imul(Qr, nn) | 0, bt = bt + Math.imul(Qr, fr) | 0, bt = bt + Math.imul(jr, nn) | 0, Ht = Ht + Math.imul(jr, fr) | 0, Rt = Rt + Math.imul(Mr, cr) | 0, bt = bt + Math.imul(Mr, Ft) | 0, bt = bt + Math.imul(Cr, cr) | 0, Ht = Ht + Math.imul(Cr, Ft) | 0, Rt = Rt + Math.imul(Sr, Bt) | 0, bt = bt + Math.imul(Sr, Xt) | 0, bt = bt + Math.imul(Ar, Bt) | 0, Ht = Ht + Math.imul(Ar, Xt) | 0, Rt = Rt + Math.imul(Qt, dr) | 0, bt = bt + Math.imul(Qt, pr) | 0, bt = bt + Math.imul(Jt, dr) | 0, Ht = Ht + Math.imul(Jt, pr) | 0, Rt = Rt + Math.imul(Gt, Tr) | 0, bt = bt + Math.imul(Gt, nr) | 0, bt = bt + Math.imul(ur, Tr) | 0, Ht = Ht + Math.imul(ur, nr) | 0, Rt = Rt + Math.imul(yr, Er) | 0, bt = bt + Math.imul(yr, Pr) | 0, bt = bt + Math.imul(rr, Er) | 0, Ht = Ht + Math.imul(rr, Pr) | 0;
      var dn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, Rt = Math.imul(Ut, vr), bt = Math.imul(Ut, _r), bt = bt + Math.imul(tr, vr) | 0, Ht = Math.imul(tr, _r), Rt = Rt + Math.imul(en, Wr) | 0, bt = bt + Math.imul(en, Ir) | 0, bt = bt + Math.imul(zt, Wr) | 0, Ht = Ht + Math.imul(zt, Ir) | 0, Rt = Rt + Math.imul(Zr, Fr) | 0, bt = bt + Math.imul(Zr, Nr) | 0, bt = bt + Math.imul(Lr, Fr) | 0, Ht = Ht + Math.imul(Lr, Nr) | 0, Rt = Rt + Math.imul(Gr, nn) | 0, bt = bt + Math.imul(Gr, fr) | 0, bt = bt + Math.imul(Or, nn) | 0, Ht = Ht + Math.imul(Or, fr) | 0, Rt = Rt + Math.imul(Qr, cr) | 0, bt = bt + Math.imul(Qr, Ft) | 0, bt = bt + Math.imul(jr, cr) | 0, Ht = Ht + Math.imul(jr, Ft) | 0, Rt = Rt + Math.imul(Mr, Bt) | 0, bt = bt + Math.imul(Mr, Xt) | 0, bt = bt + Math.imul(Cr, Bt) | 0, Ht = Ht + Math.imul(Cr, Xt) | 0, Rt = Rt + Math.imul(Sr, dr) | 0, bt = bt + Math.imul(Sr, pr) | 0, bt = bt + Math.imul(Ar, dr) | 0, Ht = Ht + Math.imul(Ar, pr) | 0, Rt = Rt + Math.imul(Qt, Tr) | 0, bt = bt + Math.imul(Qt, nr) | 0, bt = bt + Math.imul(Jt, Tr) | 0, Ht = Ht + Math.imul(Jt, nr) | 0, Rt = Rt + Math.imul(Gt, Er) | 0, bt = bt + Math.imul(Gt, Pr) | 0, bt = bt + Math.imul(ur, Er) | 0, Ht = Ht + Math.imul(ur, Pr) | 0, Rt = Rt + Math.imul(yr, Ur) | 0, bt = bt + Math.imul(yr, kr) | 0, bt = bt + Math.imul(rr, Ur) | 0, Ht = Ht + Math.imul(rr, kr) | 0;
      var hn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, Rt = Math.imul(Ut, Wr), bt = Math.imul(Ut, Ir), bt = bt + Math.imul(tr, Wr) | 0, Ht = Math.imul(tr, Ir), Rt = Rt + Math.imul(en, Fr) | 0, bt = bt + Math.imul(en, Nr) | 0, bt = bt + Math.imul(zt, Fr) | 0, Ht = Ht + Math.imul(zt, Nr) | 0, Rt = Rt + Math.imul(Zr, nn) | 0, bt = bt + Math.imul(Zr, fr) | 0, bt = bt + Math.imul(Lr, nn) | 0, Ht = Ht + Math.imul(Lr, fr) | 0, Rt = Rt + Math.imul(Gr, cr) | 0, bt = bt + Math.imul(Gr, Ft) | 0, bt = bt + Math.imul(Or, cr) | 0, Ht = Ht + Math.imul(Or, Ft) | 0, Rt = Rt + Math.imul(Qr, Bt) | 0, bt = bt + Math.imul(Qr, Xt) | 0, bt = bt + Math.imul(jr, Bt) | 0, Ht = Ht + Math.imul(jr, Xt) | 0, Rt = Rt + Math.imul(Mr, dr) | 0, bt = bt + Math.imul(Mr, pr) | 0, bt = bt + Math.imul(Cr, dr) | 0, Ht = Ht + Math.imul(Cr, pr) | 0, Rt = Rt + Math.imul(Sr, Tr) | 0, bt = bt + Math.imul(Sr, nr) | 0, bt = bt + Math.imul(Ar, Tr) | 0, Ht = Ht + Math.imul(Ar, nr) | 0, Rt = Rt + Math.imul(Qt, Er) | 0, bt = bt + Math.imul(Qt, Pr) | 0, bt = bt + Math.imul(Jt, Er) | 0, Ht = Ht + Math.imul(Jt, Pr) | 0, Rt = Rt + Math.imul(Gt, Ur) | 0, bt = bt + Math.imul(Gt, kr) | 0, bt = bt + Math.imul(ur, Ur) | 0, Ht = Ht + Math.imul(ur, kr) | 0;
      var pn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, Rt = Math.imul(Ut, Fr), bt = Math.imul(Ut, Nr), bt = bt + Math.imul(tr, Fr) | 0, Ht = Math.imul(tr, Nr), Rt = Rt + Math.imul(en, nn) | 0, bt = bt + Math.imul(en, fr) | 0, bt = bt + Math.imul(zt, nn) | 0, Ht = Ht + Math.imul(zt, fr) | 0, Rt = Rt + Math.imul(Zr, cr) | 0, bt = bt + Math.imul(Zr, Ft) | 0, bt = bt + Math.imul(Lr, cr) | 0, Ht = Ht + Math.imul(Lr, Ft) | 0, Rt = Rt + Math.imul(Gr, Bt) | 0, bt = bt + Math.imul(Gr, Xt) | 0, bt = bt + Math.imul(Or, Bt) | 0, Ht = Ht + Math.imul(Or, Xt) | 0, Rt = Rt + Math.imul(Qr, dr) | 0, bt = bt + Math.imul(Qr, pr) | 0, bt = bt + Math.imul(jr, dr) | 0, Ht = Ht + Math.imul(jr, pr) | 0, Rt = Rt + Math.imul(Mr, Tr) | 0, bt = bt + Math.imul(Mr, nr) | 0, bt = bt + Math.imul(Cr, Tr) | 0, Ht = Ht + Math.imul(Cr, nr) | 0, Rt = Rt + Math.imul(Sr, Er) | 0, bt = bt + Math.imul(Sr, Pr) | 0, bt = bt + Math.imul(Ar, Er) | 0, Ht = Ht + Math.imul(Ar, Pr) | 0, Rt = Rt + Math.imul(Qt, Ur) | 0, bt = bt + Math.imul(Qt, kr) | 0, bt = bt + Math.imul(Jt, Ur) | 0, Ht = Ht + Math.imul(Jt, kr) | 0;
      var yn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, Rt = Math.imul(Ut, nn), bt = Math.imul(Ut, fr), bt = bt + Math.imul(tr, nn) | 0, Ht = Math.imul(tr, fr), Rt = Rt + Math.imul(en, cr) | 0, bt = bt + Math.imul(en, Ft) | 0, bt = bt + Math.imul(zt, cr) | 0, Ht = Ht + Math.imul(zt, Ft) | 0, Rt = Rt + Math.imul(Zr, Bt) | 0, bt = bt + Math.imul(Zr, Xt) | 0, bt = bt + Math.imul(Lr, Bt) | 0, Ht = Ht + Math.imul(Lr, Xt) | 0, Rt = Rt + Math.imul(Gr, dr) | 0, bt = bt + Math.imul(Gr, pr) | 0, bt = bt + Math.imul(Or, dr) | 0, Ht = Ht + Math.imul(Or, pr) | 0, Rt = Rt + Math.imul(Qr, Tr) | 0, bt = bt + Math.imul(Qr, nr) | 0, bt = bt + Math.imul(jr, Tr) | 0, Ht = Ht + Math.imul(jr, nr) | 0, Rt = Rt + Math.imul(Mr, Er) | 0, bt = bt + Math.imul(Mr, Pr) | 0, bt = bt + Math.imul(Cr, Er) | 0, Ht = Ht + Math.imul(Cr, Pr) | 0, Rt = Rt + Math.imul(Sr, Ur) | 0, bt = bt + Math.imul(Sr, kr) | 0, bt = bt + Math.imul(Ar, Ur) | 0, Ht = Ht + Math.imul(Ar, kr) | 0;
      var mn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, Rt = Math.imul(Ut, cr), bt = Math.imul(Ut, Ft), bt = bt + Math.imul(tr, cr) | 0, Ht = Math.imul(tr, Ft), Rt = Rt + Math.imul(en, Bt) | 0, bt = bt + Math.imul(en, Xt) | 0, bt = bt + Math.imul(zt, Bt) | 0, Ht = Ht + Math.imul(zt, Xt) | 0, Rt = Rt + Math.imul(Zr, dr) | 0, bt = bt + Math.imul(Zr, pr) | 0, bt = bt + Math.imul(Lr, dr) | 0, Ht = Ht + Math.imul(Lr, pr) | 0, Rt = Rt + Math.imul(Gr, Tr) | 0, bt = bt + Math.imul(Gr, nr) | 0, bt = bt + Math.imul(Or, Tr) | 0, Ht = Ht + Math.imul(Or, nr) | 0, Rt = Rt + Math.imul(Qr, Er) | 0, bt = bt + Math.imul(Qr, Pr) | 0, bt = bt + Math.imul(jr, Er) | 0, Ht = Ht + Math.imul(jr, Pr) | 0, Rt = Rt + Math.imul(Mr, Ur) | 0, bt = bt + Math.imul(Mr, kr) | 0, bt = bt + Math.imul(Cr, Ur) | 0, Ht = Ht + Math.imul(Cr, kr) | 0;
      var gn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, Rt = Math.imul(Ut, Bt), bt = Math.imul(Ut, Xt), bt = bt + Math.imul(tr, Bt) | 0, Ht = Math.imul(tr, Xt), Rt = Rt + Math.imul(en, dr) | 0, bt = bt + Math.imul(en, pr) | 0, bt = bt + Math.imul(zt, dr) | 0, Ht = Ht + Math.imul(zt, pr) | 0, Rt = Rt + Math.imul(Zr, Tr) | 0, bt = bt + Math.imul(Zr, nr) | 0, bt = bt + Math.imul(Lr, Tr) | 0, Ht = Ht + Math.imul(Lr, nr) | 0, Rt = Rt + Math.imul(Gr, Er) | 0, bt = bt + Math.imul(Gr, Pr) | 0, bt = bt + Math.imul(Or, Er) | 0, Ht = Ht + Math.imul(Or, Pr) | 0, Rt = Rt + Math.imul(Qr, Ur) | 0, bt = bt + Math.imul(Qr, kr) | 0, bt = bt + Math.imul(jr, Ur) | 0, Ht = Ht + Math.imul(jr, kr) | 0;
      var vn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, Rt = Math.imul(Ut, dr), bt = Math.imul(Ut, pr), bt = bt + Math.imul(tr, dr) | 0, Ht = Math.imul(tr, pr), Rt = Rt + Math.imul(en, Tr) | 0, bt = bt + Math.imul(en, nr) | 0, bt = bt + Math.imul(zt, Tr) | 0, Ht = Ht + Math.imul(zt, nr) | 0, Rt = Rt + Math.imul(Zr, Er) | 0, bt = bt + Math.imul(Zr, Pr) | 0, bt = bt + Math.imul(Lr, Er) | 0, Ht = Ht + Math.imul(Lr, Pr) | 0, Rt = Rt + Math.imul(Gr, Ur) | 0, bt = bt + Math.imul(Gr, kr) | 0, bt = bt + Math.imul(Or, Ur) | 0, Ht = Ht + Math.imul(Or, kr) | 0;
      var wn = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (wn >>> 26) | 0, wn &= 67108863, Rt = Math.imul(Ut, Tr), bt = Math.imul(Ut, nr), bt = bt + Math.imul(tr, Tr) | 0, Ht = Math.imul(tr, nr), Rt = Rt + Math.imul(en, Er) | 0, bt = bt + Math.imul(en, Pr) | 0, bt = bt + Math.imul(zt, Er) | 0, Ht = Ht + Math.imul(zt, Pr) | 0, Rt = Rt + Math.imul(Zr, Ur) | 0, bt = bt + Math.imul(Zr, kr) | 0, bt = bt + Math.imul(Lr, Ur) | 0, Ht = Ht + Math.imul(Lr, kr) | 0;
      var _n = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + (_n >>> 26) | 0, _n &= 67108863, Rt = Math.imul(Ut, Er), bt = Math.imul(Ut, Pr), bt = bt + Math.imul(tr, Er) | 0, Ht = Math.imul(tr, Pr), Rt = Rt + Math.imul(en, Ur) | 0, bt = bt + Math.imul(en, kr) | 0, bt = bt + Math.imul(zt, Ur) | 0, Ht = Ht + Math.imul(zt, kr) | 0;
      var $n = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      Qe = (Ht + (bt >>> 13) | 0) + ($n >>> 26) | 0, $n &= 67108863, Rt = Math.imul(Ut, Ur), bt = Math.imul(Ut, kr), bt = bt + Math.imul(tr, Ur) | 0, Ht = Math.imul(tr, kr);
      var En = (Qe + Rt | 0) + ((bt & 8191) << 13) | 0;
      return Qe = (Ht + (bt >>> 13) | 0) + (En >>> 26) | 0, En &= 67108863, xt[0] = Xr, xt[1] = sn, xt[2] = tn, xt[3] = on, xt[4] = cn, xt[5] = ln, xt[6] = un, xt[7] = an, xt[8] = dn, xt[9] = hn, xt[10] = pn, xt[11] = yn, xt[12] = mn, xt[13] = gn, xt[14] = vn, xt[15] = wn, xt[16] = _n, xt[17] = $n, xt[18] = En, Qe !== 0 && (xt[19] = Qe, ht.length++), ht;
    };
    Math.imul || (Pt = Wt);
    function Lt(Xe, ve, Ke) {
      Ke.negative = ve.negative ^ Xe.negative, Ke.length = Xe.length + ve.length;
      for (var ht = 0, wt = 0, vt = 0; vt < Ke.length - 1; vt++) {
        var xt = wt;
        wt = 0;
        for (var Qe = ht & 67108863, Rt = Math.min(vt, ve.length - 1), bt = Math.max(0, vt - Xe.length + 1); bt <= Rt; bt++) {
          var Ht = vt - bt, ar = Xe.words[Ht] | 0, yr = ve.words[bt] | 0, rr = ar * yr, Kt = rr & 67108863;
          xt = xt + (rr / 67108864 | 0) | 0, Kt = Kt + Qe | 0, Qe = Kt & 67108863, xt = xt + (Kt >>> 26) | 0, wt += xt >>> 26, xt &= 67108863;
        }
        Ke.words[vt] = Qe, ht = xt, xt = wt;
      }
      return ht !== 0 ? Ke.words[vt] = ht : Ke.length--, Ke._strip();
    }
    function qt(Xe, ve, Ke) {
      return Lt(Xe, ve, Ke);
    }
    oe.prototype.mulTo = function(ve, Ke) {
      var ht, wt = this.length + ve.length;
      return this.length === 10 && ve.length === 10 ? ht = Pt(this, ve, Ke) : wt < 63 ? ht = Wt(this, ve, Ke) : wt < 1024 ? ht = Lt(this, ve, Ke) : ht = qt(this, ve, Ke), ht;
    }, oe.prototype.mul = function(ve) {
      var Ke = new oe(null);
      return Ke.words = new Array(this.length + ve.length), this.mulTo(ve, Ke);
    }, oe.prototype.mulf = function(ve) {
      var Ke = new oe(null);
      return Ke.words = new Array(this.length + ve.length), qt(this, ve, Ke);
    }, oe.prototype.imul = function(ve) {
      return this.clone().mulTo(ve, this);
    }, oe.prototype.imuln = function(ve) {
      var Ke = ve < 0;
      Ke && (ve = -ve), ne(typeof ve == "number"), ne(ve < 67108864);
      for (var ht = 0, wt = 0; wt < this.length; wt++) {
        var vt = (this.words[wt] | 0) * ve, xt = (vt & 67108863) + (ht & 67108863);
        ht >>= 26, ht += vt / 67108864 | 0, ht += xt >>> 26, this.words[wt] = xt & 67108863;
      }
      return ht !== 0 && (this.words[wt] = ht, this.length++), Ke ? this.ineg() : this;
    }, oe.prototype.muln = function(ve) {
      return this.clone().imuln(ve);
    }, oe.prototype.sqr = function() {
      return this.mul(this);
    }, oe.prototype.isqr = function() {
      return this.imul(this.clone());
    }, oe.prototype.pow = function(ve) {
      var Ke = Dt(ve);
      if (Ke.length === 0) return new oe(1);
      for (var ht = this, wt = 0; wt < Ke.length && Ke[wt] === 0; wt++, ht = ht.sqr())
        ;
      if (++wt < Ke.length)
        for (var vt = ht.sqr(); wt < Ke.length; wt++, vt = vt.sqr())
          Ke[wt] !== 0 && (ht = ht.mul(vt));
      return ht;
    }, oe.prototype.iushln = function(ve) {
      ne(typeof ve == "number" && ve >= 0);
      var Ke = ve % 26, ht = (ve - Ke) / 26, wt = 67108863 >>> 26 - Ke << 26 - Ke, vt;
      if (Ke !== 0) {
        var xt = 0;
        for (vt = 0; vt < this.length; vt++) {
          var Qe = this.words[vt] & wt, Rt = (this.words[vt] | 0) - Qe << Ke;
          this.words[vt] = Rt | xt, xt = Qe >>> 26 - Ke;
        }
        xt && (this.words[vt] = xt, this.length++);
      }
      if (ht !== 0) {
        for (vt = this.length - 1; vt >= 0; vt--)
          this.words[vt + ht] = this.words[vt];
        for (vt = 0; vt < ht; vt++)
          this.words[vt] = 0;
        this.length += ht;
      }
      return this._strip();
    }, oe.prototype.ishln = function(ve) {
      return ne(this.negative === 0), this.iushln(ve);
    }, oe.prototype.iushrn = function(ve, Ke, ht) {
      ne(typeof ve == "number" && ve >= 0);
      var wt;
      Ke ? wt = (Ke - Ke % 26) / 26 : wt = 0;
      var vt = ve % 26, xt = Math.min((ve - vt) / 26, this.length), Qe = 67108863 ^ 67108863 >>> vt << vt, Rt = ht;
      if (wt -= xt, wt = Math.max(0, wt), Rt) {
        for (var bt = 0; bt < xt; bt++)
          Rt.words[bt] = this.words[bt];
        Rt.length = xt;
      }
      if (xt !== 0) if (this.length > xt)
        for (this.length -= xt, bt = 0; bt < this.length; bt++)
          this.words[bt] = this.words[bt + xt];
      else
        this.words[0] = 0, this.length = 1;
      var Ht = 0;
      for (bt = this.length - 1; bt >= 0 && (Ht !== 0 || bt >= wt); bt--) {
        var ar = this.words[bt] | 0;
        this.words[bt] = Ht << 26 - vt | ar >>> vt, Ht = ar & Qe;
      }
      return Rt && Ht !== 0 && (Rt.words[Rt.length++] = Ht), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, oe.prototype.ishrn = function(ve, Ke, ht) {
      return ne(this.negative === 0), this.iushrn(ve, Ke, ht);
    }, oe.prototype.shln = function(ve) {
      return this.clone().ishln(ve);
    }, oe.prototype.ushln = function(ve) {
      return this.clone().iushln(ve);
    }, oe.prototype.shrn = function(ve) {
      return this.clone().ishrn(ve);
    }, oe.prototype.ushrn = function(ve) {
      return this.clone().iushrn(ve);
    }, oe.prototype.testn = function(ve) {
      ne(typeof ve == "number" && ve >= 0);
      var Ke = ve % 26, ht = (ve - Ke) / 26, wt = 1 << Ke;
      if (this.length <= ht) return !1;
      var vt = this.words[ht];
      return !!(vt & wt);
    }, oe.prototype.imaskn = function(ve) {
      ne(typeof ve == "number" && ve >= 0);
      var Ke = ve % 26, ht = (ve - Ke) / 26;
      if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ht)
        return this;
      if (Ke !== 0 && ht++, this.length = Math.min(ht, this.length), Ke !== 0) {
        var wt = 67108863 ^ 67108863 >>> Ke << Ke;
        this.words[this.length - 1] &= wt;
      }
      return this._strip();
    }, oe.prototype.maskn = function(ve) {
      return this.clone().imaskn(ve);
    }, oe.prototype.iaddn = function(ve) {
      return ne(typeof ve == "number"), ne(ve < 67108864), ve < 0 ? this.isubn(-ve) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ve ? (this.words[0] = ve - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ve), this.negative = 1, this) : this._iaddn(ve);
    }, oe.prototype._iaddn = function(ve) {
      this.words[0] += ve;
      for (var Ke = 0; Ke < this.length && this.words[Ke] >= 67108864; Ke++)
        this.words[Ke] -= 67108864, Ke === this.length - 1 ? this.words[Ke + 1] = 1 : this.words[Ke + 1]++;
      return this.length = Math.max(this.length, Ke + 1), this;
    }, oe.prototype.isubn = function(ve) {
      if (ne(typeof ve == "number"), ne(ve < 67108864), ve < 0) return this.iaddn(-ve);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ve), this.negative = 1, this;
      if (this.words[0] -= ve, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Ke = 0; Ke < this.length && this.words[Ke] < 0; Ke++)
          this.words[Ke] += 67108864, this.words[Ke + 1] -= 1;
      return this._strip();
    }, oe.prototype.addn = function(ve) {
      return this.clone().iaddn(ve);
    }, oe.prototype.subn = function(ve) {
      return this.clone().isubn(ve);
    }, oe.prototype.iabs = function() {
      return this.negative = 0, this;
    }, oe.prototype.abs = function() {
      return this.clone().iabs();
    }, oe.prototype._ishlnsubmul = function(ve, Ke, ht) {
      var wt = ve.length + ht, vt;
      this._expand(wt);
      var xt, Qe = 0;
      for (vt = 0; vt < ve.length; vt++) {
        xt = (this.words[vt + ht] | 0) + Qe;
        var Rt = (ve.words[vt] | 0) * Ke;
        xt -= Rt & 67108863, Qe = (xt >> 26) - (Rt / 67108864 | 0), this.words[vt + ht] = xt & 67108863;
      }
      for (; vt < this.length - ht; vt++)
        xt = (this.words[vt + ht] | 0) + Qe, Qe = xt >> 26, this.words[vt + ht] = xt & 67108863;
      if (Qe === 0) return this._strip();
      for (ne(Qe === -1), Qe = 0, vt = 0; vt < this.length; vt++)
        xt = -(this.words[vt] | 0) + Qe, Qe = xt >> 26, this.words[vt] = xt & 67108863;
      return this.negative = 1, this._strip();
    }, oe.prototype._wordDiv = function(ve, Ke) {
      var ht = this.length - ve.length, wt = this.clone(), vt = ve, xt = vt.words[vt.length - 1] | 0, Qe = this._countBits(xt);
      ht = 26 - Qe, ht !== 0 && (vt = vt.ushln(ht), wt.iushln(ht), xt = vt.words[vt.length - 1] | 0);
      var Rt = wt.length - vt.length, bt;
      if (Ke !== "mod") {
        bt = new oe(null), bt.length = Rt + 1, bt.words = new Array(bt.length);
        for (var Ht = 0; Ht < bt.length; Ht++)
          bt.words[Ht] = 0;
      }
      var ar = wt.clone()._ishlnsubmul(vt, 1, Rt);
      ar.negative === 0 && (wt = ar, bt && (bt.words[Rt] = 1));
      for (var yr = Rt - 1; yr >= 0; yr--) {
        var rr = (wt.words[vt.length + yr] | 0) * 67108864 + (wt.words[vt.length + yr - 1] | 0);
        for (rr = Math.min(rr / xt | 0, 67108863), wt._ishlnsubmul(vt, rr, yr); wt.negative !== 0; )
          rr--, wt.negative = 0, wt._ishlnsubmul(vt, 1, yr), wt.isZero() || (wt.negative ^= 1);
        bt && (bt.words[yr] = rr);
      }
      return bt && bt._strip(), wt._strip(), Ke !== "div" && ht !== 0 && wt.iushrn(ht), {
        div: bt || null,
        mod: wt
      };
    }, oe.prototype.divmod = function(ve, Ke, ht) {
      if (ne(!ve.isZero()), this.isZero())
        return {
          div: new oe(0),
          mod: new oe(0)
        };
      var wt, vt, xt;
      return this.negative !== 0 && ve.negative === 0 ? (xt = this.neg().divmod(ve, Ke), Ke !== "mod" && (wt = xt.div.neg()), Ke !== "div" && (vt = xt.mod.neg(), ht && vt.negative !== 0 && vt.iadd(ve)), {
        div: wt,
        mod: vt
      }) : this.negative === 0 && ve.negative !== 0 ? (xt = this.divmod(ve.neg(), Ke), Ke !== "mod" && (wt = xt.div.neg()), {
        div: wt,
        mod: xt.mod
      }) : this.negative & ve.negative ? (xt = this.neg().divmod(ve.neg(), Ke), Ke !== "div" && (vt = xt.mod.neg(), ht && vt.negative !== 0 && vt.isub(ve)), {
        div: xt.div,
        mod: vt
      }) : ve.length > this.length || this.cmp(ve) < 0 ? {
        div: new oe(0),
        mod: this
      } : ve.length === 1 ? Ke === "div" ? {
        div: this.divn(ve.words[0]),
        mod: null
      } : Ke === "mod" ? {
        div: null,
        mod: new oe(this.modrn(ve.words[0]))
      } : {
        div: this.divn(ve.words[0]),
        mod: new oe(this.modrn(ve.words[0]))
      } : this._wordDiv(ve, Ke);
    }, oe.prototype.div = function(ve) {
      return this.divmod(ve, "div", !1).div;
    }, oe.prototype.mod = function(ve) {
      return this.divmod(ve, "mod", !1).mod;
    }, oe.prototype.umod = function(ve) {
      return this.divmod(ve, "mod", !0).mod;
    }, oe.prototype.divRound = function(ve) {
      var Ke = this.divmod(ve);
      if (Ke.mod.isZero()) return Ke.div;
      var ht = Ke.div.negative !== 0 ? Ke.mod.isub(ve) : Ke.mod, wt = ve.ushrn(1), vt = ve.andln(1), xt = ht.cmp(wt);
      return xt < 0 || vt === 1 && xt === 0 ? Ke.div : Ke.div.negative !== 0 ? Ke.div.isubn(1) : Ke.div.iaddn(1);
    }, oe.prototype.modrn = function(ve) {
      var Ke = ve < 0;
      Ke && (ve = -ve), ne(ve <= 67108863);
      for (var ht = (1 << 26) % ve, wt = 0, vt = this.length - 1; vt >= 0; vt--)
        wt = (ht * wt + (this.words[vt] | 0)) % ve;
      return Ke ? -wt : wt;
    }, oe.prototype.modn = function(ve) {
      return this.modrn(ve);
    }, oe.prototype.idivn = function(ve) {
      var Ke = ve < 0;
      Ke && (ve = -ve), ne(ve <= 67108863);
      for (var ht = 0, wt = this.length - 1; wt >= 0; wt--) {
        var vt = (this.words[wt] | 0) + ht * 67108864;
        this.words[wt] = vt / ve | 0, ht = vt % ve;
      }
      return this._strip(), Ke ? this.ineg() : this;
    }, oe.prototype.divn = function(ve) {
      return this.clone().idivn(ve);
    }, oe.prototype.egcd = function(ve) {
      ne(ve.negative === 0), ne(!ve.isZero());
      var Ke = this, ht = ve.clone();
      Ke.negative !== 0 ? Ke = Ke.umod(ve) : Ke = Ke.clone();
      for (var wt = new oe(1), vt = new oe(0), xt = new oe(0), Qe = new oe(1), Rt = 0; Ke.isEven() && ht.isEven(); )
        Ke.iushrn(1), ht.iushrn(1), ++Rt;
      for (var bt = ht.clone(), Ht = Ke.clone(); !Ke.isZero(); ) {
        for (var ar = 0, yr = 1; !(Ke.words[0] & yr) && ar < 26; ++ar, yr <<= 1) ;
        if (ar > 0)
          for (Ke.iushrn(ar); ar-- > 0; )
            (wt.isOdd() || vt.isOdd()) && (wt.iadd(bt), vt.isub(Ht)), wt.iushrn(1), vt.iushrn(1);
        for (var rr = 0, Kt = 1; !(ht.words[0] & Kt) && rr < 26; ++rr, Kt <<= 1) ;
        if (rr > 0)
          for (ht.iushrn(rr); rr-- > 0; )
            (xt.isOdd() || Qe.isOdd()) && (xt.iadd(bt), Qe.isub(Ht)), xt.iushrn(1), Qe.iushrn(1);
        Ke.cmp(ht) >= 0 ? (Ke.isub(ht), wt.isub(xt), vt.isub(Qe)) : (ht.isub(Ke), xt.isub(wt), Qe.isub(vt));
      }
      return {
        a: xt,
        b: Qe,
        gcd: ht.iushln(Rt)
      };
    }, oe.prototype._invmp = function(ve) {
      ne(ve.negative === 0), ne(!ve.isZero());
      var Ke = this, ht = ve.clone();
      Ke.negative !== 0 ? Ke = Ke.umod(ve) : Ke = Ke.clone();
      for (var wt = new oe(1), vt = new oe(0), xt = ht.clone(); Ke.cmpn(1) > 0 && ht.cmpn(1) > 0; ) {
        for (var Qe = 0, Rt = 1; !(Ke.words[0] & Rt) && Qe < 26; ++Qe, Rt <<= 1) ;
        if (Qe > 0)
          for (Ke.iushrn(Qe); Qe-- > 0; )
            wt.isOdd() && wt.iadd(xt), wt.iushrn(1);
        for (var bt = 0, Ht = 1; !(ht.words[0] & Ht) && bt < 26; ++bt, Ht <<= 1) ;
        if (bt > 0)
          for (ht.iushrn(bt); bt-- > 0; )
            vt.isOdd() && vt.iadd(xt), vt.iushrn(1);
        Ke.cmp(ht) >= 0 ? (Ke.isub(ht), wt.isub(vt)) : (ht.isub(Ke), vt.isub(wt));
      }
      var ar;
      return Ke.cmpn(1) === 0 ? ar = wt : ar = vt, ar.cmpn(0) < 0 && ar.iadd(ve), ar;
    }, oe.prototype.gcd = function(ve) {
      if (this.isZero()) return ve.abs();
      if (ve.isZero()) return this.abs();
      var Ke = this.clone(), ht = ve.clone();
      Ke.negative = 0, ht.negative = 0;
      for (var wt = 0; Ke.isEven() && ht.isEven(); wt++)
        Ke.iushrn(1), ht.iushrn(1);
      do {
        for (; Ke.isEven(); )
          Ke.iushrn(1);
        for (; ht.isEven(); )
          ht.iushrn(1);
        var vt = Ke.cmp(ht);
        if (vt < 0) {
          var xt = Ke;
          Ke = ht, ht = xt;
        } else if (vt === 0 || ht.cmpn(1) === 0)
          break;
        Ke.isub(ht);
      } while (!0);
      return ht.iushln(wt);
    }, oe.prototype.invm = function(ve) {
      return this.egcd(ve).a.umod(ve);
    }, oe.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, oe.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, oe.prototype.andln = function(ve) {
      return this.words[0] & ve;
    }, oe.prototype.bincn = function(ve) {
      ne(typeof ve == "number");
      var Ke = ve % 26, ht = (ve - Ke) / 26, wt = 1 << Ke;
      if (this.length <= ht)
        return this._expand(ht + 1), this.words[ht] |= wt, this;
      for (var vt = wt, xt = ht; vt !== 0 && xt < this.length; xt++) {
        var Qe = this.words[xt] | 0;
        Qe += vt, vt = Qe >>> 26, Qe &= 67108863, this.words[xt] = Qe;
      }
      return vt !== 0 && (this.words[xt] = vt, this.length++), this;
    }, oe.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, oe.prototype.cmpn = function(ve) {
      var Ke = ve < 0;
      if (this.negative !== 0 && !Ke) return -1;
      if (this.negative === 0 && Ke) return 1;
      this._strip();
      var ht;
      if (this.length > 1)
        ht = 1;
      else {
        Ke && (ve = -ve), ne(ve <= 67108863, "Number is too big");
        var wt = this.words[0] | 0;
        ht = wt === ve ? 0 : wt < ve ? -1 : 1;
      }
      return this.negative !== 0 ? -ht | 0 : ht;
    }, oe.prototype.cmp = function(ve) {
      if (this.negative !== 0 && ve.negative === 0) return -1;
      if (this.negative === 0 && ve.negative !== 0) return 1;
      var Ke = this.ucmp(ve);
      return this.negative !== 0 ? -Ke | 0 : Ke;
    }, oe.prototype.ucmp = function(ve) {
      if (this.length > ve.length) return 1;
      if (this.length < ve.length) return -1;
      for (var Ke = 0, ht = this.length - 1; ht >= 0; ht--) {
        var wt = this.words[ht] | 0, vt = ve.words[ht] | 0;
        if (wt !== vt) {
          wt < vt ? Ke = -1 : wt > vt && (Ke = 1);
          break;
        }
      }
      return Ke;
    }, oe.prototype.gtn = function(ve) {
      return this.cmpn(ve) === 1;
    }, oe.prototype.gt = function(ve) {
      return this.cmp(ve) === 1;
    }, oe.prototype.gten = function(ve) {
      return this.cmpn(ve) >= 0;
    }, oe.prototype.gte = function(ve) {
      return this.cmp(ve) >= 0;
    }, oe.prototype.ltn = function(ve) {
      return this.cmpn(ve) === -1;
    }, oe.prototype.lt = function(ve) {
      return this.cmp(ve) === -1;
    }, oe.prototype.lten = function(ve) {
      return this.cmpn(ve) <= 0;
    }, oe.prototype.lte = function(ve) {
      return this.cmp(ve) <= 0;
    }, oe.prototype.eqn = function(ve) {
      return this.cmpn(ve) === 0;
    }, oe.prototype.eq = function(ve) {
      return this.cmp(ve) === 0;
    }, oe.red = function(ve) {
      return new kt(ve);
    }, oe.prototype.toRed = function(ve) {
      return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), ve.convertTo(this)._forceRed(ve);
    }, oe.prototype.fromRed = function() {
      return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, oe.prototype._forceRed = function(ve) {
      return this.red = ve, this;
    }, oe.prototype.forceRed = function(ve) {
      return ne(!this.red, "Already a number in reduction context"), this._forceRed(ve);
    }, oe.prototype.redAdd = function(ve) {
      return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, ve);
    }, oe.prototype.redIAdd = function(ve) {
      return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ve);
    }, oe.prototype.redSub = function(ve) {
      return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, ve);
    }, oe.prototype.redISub = function(ve) {
      return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, ve);
    }, oe.prototype.redShl = function(ve) {
      return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, ve);
    }, oe.prototype.redMul = function(ve) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ve), this.red.mul(this, ve);
    }, oe.prototype.redIMul = function(ve) {
      return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, ve), this.red.imul(this, ve);
    }, oe.prototype.redSqr = function() {
      return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, oe.prototype.redISqr = function() {
      return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, oe.prototype.redSqrt = function() {
      return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, oe.prototype.redInvm = function() {
      return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, oe.prototype.redNeg = function() {
      return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, oe.prototype.redPow = function(ve) {
      return ne(this.red && !ve.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ve);
    };
    var Zt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Yt(Xe, ve) {
      this.name = Xe, this.p = new oe(ve, 16), this.n = this.p.bitLength(), this.k = new oe(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Yt.prototype._tmp = function() {
      var ve = new oe(null);
      return ve.words = new Array(Math.ceil(this.n / 13)), ve;
    }, Yt.prototype.ireduce = function(ve) {
      var Ke = ve, ht;
      do
        this.split(Ke, this.tmp), Ke = this.imulK(Ke), Ke = Ke.iadd(this.tmp), ht = Ke.bitLength();
      while (ht > this.n);
      var wt = ht < this.n ? -1 : Ke.ucmp(this.p);
      return wt === 0 ? (Ke.words[0] = 0, Ke.length = 1) : wt > 0 ? Ke.isub(this.p) : Ke.strip !== void 0 ? Ke.strip() : Ke._strip(), Ke;
    }, Yt.prototype.split = function(ve, Ke) {
      ve.iushrn(this.n, 0, Ke);
    }, Yt.prototype.imulK = function(ve) {
      return ve.imul(this.k);
    };
    function or() {
      Yt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    ie(or, Yt), or.prototype.split = function(ve, Ke) {
      for (var ht = 4194303, wt = Math.min(ve.length, 9), vt = 0; vt < wt; vt++)
        Ke.words[vt] = ve.words[vt];
      if (Ke.length = wt, ve.length <= 9) {
        ve.words[0] = 0, ve.length = 1;
        return;
      }
      var xt = ve.words[9];
      for (Ke.words[Ke.length++] = xt & ht, vt = 10; vt < ve.length; vt++) {
        var Qe = ve.words[vt] | 0;
        ve.words[vt - 10] = (Qe & ht) << 4 | xt >>> 22, xt = Qe;
      }
      xt >>>= 22, ve.words[vt - 10] = xt, xt === 0 && ve.length > 10 ? ve.length -= 10 : ve.length -= 9;
    }, or.prototype.imulK = function(ve) {
      ve.words[ve.length] = 0, ve.words[ve.length + 1] = 0, ve.length += 2;
      for (var Ke = 0, ht = 0; ht < ve.length; ht++) {
        var wt = ve.words[ht] | 0;
        Ke += wt * 977, ve.words[ht] = Ke & 67108863, Ke = wt * 64 + (Ke / 67108864 | 0);
      }
      return ve.words[ve.length - 1] === 0 && (ve.length--, ve.words[ve.length - 1] === 0 && ve.length--), ve;
    };
    function jt() {
      Yt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    ie(jt, Yt);
    function Ct() {
      Yt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    ie(Ct, Yt);
    function Vt() {
      Yt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    ie(Vt, Yt), Vt.prototype.imulK = function(ve) {
      for (var Ke = 0, ht = 0; ht < ve.length; ht++) {
        var wt = (ve.words[ht] | 0) * 19 + Ke, vt = wt & 67108863;
        wt >>>= 26, ve.words[ht] = vt, Ke = wt;
      }
      return Ke !== 0 && (ve.words[ve.length++] = Ke), ve;
    }, oe._prime = function(ve) {
      if (Zt[ve]) return Zt[ve];
      var Ke;
      if (ve === "k256")
        Ke = new or();
      else if (ve === "p224")
        Ke = new jt();
      else if (ve === "p192")
        Ke = new Ct();
      else if (ve === "p25519")
        Ke = new Vt();
      else
        throw new Error("Unknown prime " + ve);
      return Zt[ve] = Ke, Ke;
    };
    function kt(Xe) {
      if (typeof Xe == "string") {
        var ve = oe._prime(Xe);
        this.m = ve.p, this.prime = ve;
      } else
        ne(Xe.gtn(1), "modulus must be greater than 1"), this.m = Xe, this.prime = null;
    }
    kt.prototype._verify1 = function(ve) {
      ne(ve.negative === 0, "red works only with positives"), ne(ve.red, "red works only with red numbers");
    }, kt.prototype._verify2 = function(ve, Ke) {
      ne((ve.negative | Ke.negative) === 0, "red works only with positives"), ne(
        ve.red && ve.red === Ke.red,
        "red works only with red numbers"
      );
    }, kt.prototype.imod = function(ve) {
      return this.prime ? this.prime.ireduce(ve)._forceRed(this) : (le(ve, ve.umod(this.m)._forceRed(this)), ve);
    }, kt.prototype.neg = function(ve) {
      return ve.isZero() ? ve.clone() : this.m.sub(ve)._forceRed(this);
    }, kt.prototype.add = function(ve, Ke) {
      this._verify2(ve, Ke);
      var ht = ve.add(Ke);
      return ht.cmp(this.m) >= 0 && ht.isub(this.m), ht._forceRed(this);
    }, kt.prototype.iadd = function(ve, Ke) {
      this._verify2(ve, Ke);
      var ht = ve.iadd(Ke);
      return ht.cmp(this.m) >= 0 && ht.isub(this.m), ht;
    }, kt.prototype.sub = function(ve, Ke) {
      this._verify2(ve, Ke);
      var ht = ve.sub(Ke);
      return ht.cmpn(0) < 0 && ht.iadd(this.m), ht._forceRed(this);
    }, kt.prototype.isub = function(ve, Ke) {
      this._verify2(ve, Ke);
      var ht = ve.isub(Ke);
      return ht.cmpn(0) < 0 && ht.iadd(this.m), ht;
    }, kt.prototype.shl = function(ve, Ke) {
      return this._verify1(ve), this.imod(ve.ushln(Ke));
    }, kt.prototype.imul = function(ve, Ke) {
      return this._verify2(ve, Ke), this.imod(ve.imul(Ke));
    }, kt.prototype.mul = function(ve, Ke) {
      return this._verify2(ve, Ke), this.imod(ve.mul(Ke));
    }, kt.prototype.isqr = function(ve) {
      return this.imul(ve, ve.clone());
    }, kt.prototype.sqr = function(ve) {
      return this.mul(ve, ve);
    }, kt.prototype.sqrt = function(ve) {
      if (ve.isZero()) return ve.clone();
      var Ke = this.m.andln(3);
      if (ne(Ke % 2 === 1), Ke === 3) {
        var ht = this.m.add(new oe(1)).iushrn(2);
        return this.pow(ve, ht);
      }
      for (var wt = this.m.subn(1), vt = 0; !wt.isZero() && wt.andln(1) === 0; )
        vt++, wt.iushrn(1);
      ne(!wt.isZero());
      var xt = new oe(1).toRed(this), Qe = xt.redNeg(), Rt = this.m.subn(1).iushrn(1), bt = this.m.bitLength();
      for (bt = new oe(2 * bt * bt).toRed(this); this.pow(bt, Rt).cmp(Qe) !== 0; )
        bt.redIAdd(Qe);
      for (var Ht = this.pow(bt, wt), ar = this.pow(ve, wt.addn(1).iushrn(1)), yr = this.pow(ve, wt), rr = vt; yr.cmp(xt) !== 0; ) {
        for (var Kt = yr, Gt = 0; Kt.cmp(xt) !== 0; Gt++)
          Kt = Kt.redSqr();
        ne(Gt < rr);
        var ur = this.pow(Ht, new oe(1).iushln(rr - Gt - 1));
        ar = ar.redMul(ur), Ht = ur.redSqr(), yr = yr.redMul(Ht), rr = Gt;
      }
      return ar;
    }, kt.prototype.invm = function(ve) {
      var Ke = ve._invmp(this.m);
      return Ke.negative !== 0 ? (Ke.negative = 0, this.imod(Ke).redNeg()) : this.imod(Ke);
    }, kt.prototype.pow = function(ve, Ke) {
      if (Ke.isZero()) return new oe(1).toRed(this);
      if (Ke.cmpn(1) === 0) return ve.clone();
      var ht = 4, wt = new Array(1 << ht);
      wt[0] = new oe(1).toRed(this), wt[1] = ve;
      for (var vt = 2; vt < wt.length; vt++)
        wt[vt] = this.mul(wt[vt - 1], ve);
      var xt = wt[0], Qe = 0, Rt = 0, bt = Ke.bitLength() % 26;
      for (bt === 0 && (bt = 26), vt = Ke.length - 1; vt >= 0; vt--) {
        for (var Ht = Ke.words[vt], ar = bt - 1; ar >= 0; ar--) {
          var yr = Ht >> ar & 1;
          if (xt !== wt[0] && (xt = this.sqr(xt)), yr === 0 && Qe === 0) {
            Rt = 0;
            continue;
          }
          Qe <<= 1, Qe |= yr, Rt++, !(Rt !== ht && (vt !== 0 || ar !== 0)) && (xt = this.mul(xt, wt[Qe]), Rt = 0, Qe = 0);
        }
        bt = 26;
      }
      return xt;
    }, kt.prototype.convertTo = function(ve) {
      var Ke = ve.umod(this.m);
      return Ke === ve ? Ke.clone() : Ke;
    }, kt.prototype.convertFrom = function(ve) {
      var Ke = ve.clone();
      return Ke.red = null, Ke;
    }, oe.mont = function(ve) {
      return new Pe(ve);
    };
    function Pe(Xe) {
      kt.call(this, Xe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new oe(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    ie(Pe, kt), Pe.prototype.convertTo = function(ve) {
      return this.imod(ve.ushln(this.shift));
    }, Pe.prototype.convertFrom = function(ve) {
      var Ke = this.imod(ve.mul(this.rinv));
      return Ke.red = null, Ke;
    }, Pe.prototype.imul = function(ve, Ke) {
      if (ve.isZero() || Ke.isZero())
        return ve.words[0] = 0, ve.length = 1, ve;
      var ht = ve.imul(Ke), wt = ht.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), vt = ht.isub(wt).iushrn(this.shift), xt = vt;
      return vt.cmp(this.m) >= 0 ? xt = vt.isub(this.m) : vt.cmpn(0) < 0 && (xt = vt.iadd(this.m)), xt._forceRed(this);
    }, Pe.prototype.mul = function(ve, Ke) {
      if (ve.isZero() || Ke.isZero()) return new oe(0)._forceRed(this);
      var ht = ve.mul(Ke), wt = ht.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), vt = ht.isub(wt).iushrn(this.shift), xt = vt;
      return vt.cmp(this.m) >= 0 ? xt = vt.isub(this.m) : vt.cmpn(0) < 0 && (xt = vt.iadd(this.m)), xt._forceRed(this);
    }, Pe.prototype.invm = function(ve) {
      var Ke = this.imod(ve._invmp(this.m).mul(this.r2));
      return Ke._forceRed(this);
    };
  })(B, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$a = bnExports, randomBytes$1 = browserExports, Buffer$8 = safeBufferExports$1.Buffer;
function getr(B) {
  var z = B.modulus.byteLength(), Y;
  do
    Y = new BN$a(randomBytes$1(z));
  while (Y.cmp(B.modulus) >= 0 || !Y.umod(B.prime1) || !Y.umod(B.prime2));
  return Y;
}
function blind(B) {
  var z = getr(B), Y = z.toRed(BN$a.mont(B.modulus)).redPow(new BN$a(B.publicExponent)).fromRed();
  return { blinder: Y, unblinder: z.invm(B.modulus) };
}
function crt$2(B, z) {
  var Y = blind(z), ne = z.modulus.byteLength(), ie = new BN$a(B).mul(Y.blinder).umod(z.modulus), oe = ie.toRed(BN$a.mont(z.prime1)), se = ie.toRed(BN$a.mont(z.prime2)), ae = z.coefficient, ge = z.prime1, Ce = z.prime2, le = oe.redPow(z.exponent1).fromRed(), Ee = se.redPow(z.exponent2).fromRed(), Je = le.isub(Ee).imul(ae).umod(ge).imul(Ce);
  return Ee.iadd(Je).imul(Y.unblinder).umod(z.modulus).toArrayLike(Buffer$8, "be", ne);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$m = {}, utils$l = {};
(function(B) {
  var z = B;
  function Y(oe, se) {
    if (Array.isArray(oe))
      return oe.slice();
    if (!oe)
      return [];
    var ae = [];
    if (typeof oe != "string") {
      for (var ge = 0; ge < oe.length; ge++)
        ae[ge] = oe[ge] | 0;
      return ae;
    }
    if (se === "hex") {
      oe = oe.replace(/[^a-z0-9]+/ig, ""), oe.length % 2 !== 0 && (oe = "0" + oe);
      for (var ge = 0; ge < oe.length; ge += 2)
        ae.push(parseInt(oe[ge] + oe[ge + 1], 16));
    } else
      for (var ge = 0; ge < oe.length; ge++) {
        var Ce = oe.charCodeAt(ge), le = Ce >> 8, Ee = Ce & 255;
        le ? ae.push(le, Ee) : ae.push(Ee);
      }
    return ae;
  }
  z.toArray = Y;
  function ne(oe) {
    return oe.length === 1 ? "0" + oe : oe;
  }
  z.zero2 = ne;
  function ie(oe) {
    for (var se = "", ae = 0; ae < oe.length; ae++)
      se += ne(oe[ae].toString(16));
    return se;
  }
  z.toHex = ie, z.encode = function(se, ae) {
    return ae === "hex" ? ie(se) : se;
  };
})(utils$l);
(function(B) {
  var z = B, Y = bnExports$1, ne = minimalisticAssert, ie = utils$l;
  z.assert = ne, z.toArray = ie.toArray, z.zero2 = ie.zero2, z.toHex = ie.toHex, z.encode = ie.encode;
  function oe(le, Ee, Je) {
    var Ve = new Array(Math.max(le.bitLength(), Je) + 1), $t;
    for ($t = 0; $t < Ve.length; $t += 1)
      Ve[$t] = 0;
    var Nt = 1 << Ee + 1, Dt = le.clone();
    for ($t = 0; $t < Ve.length; $t++) {
      var Wt, Pt = Dt.andln(Nt - 1);
      Dt.isOdd() ? (Pt > (Nt >> 1) - 1 ? Wt = (Nt >> 1) - Pt : Wt = Pt, Dt.isubn(Wt)) : Wt = 0, Ve[$t] = Wt, Dt.iushrn(1);
    }
    return Ve;
  }
  z.getNAF = oe;
  function se(le, Ee) {
    var Je = [
      [],
      []
    ];
    le = le.clone(), Ee = Ee.clone();
    for (var Ve = 0, $t = 0, Nt; le.cmpn(-Ve) > 0 || Ee.cmpn(-$t) > 0; ) {
      var Dt = le.andln(3) + Ve & 3, Wt = Ee.andln(3) + $t & 3;
      Dt === 3 && (Dt = -1), Wt === 3 && (Wt = -1);
      var Pt;
      Dt & 1 ? (Nt = le.andln(7) + Ve & 7, (Nt === 3 || Nt === 5) && Wt === 2 ? Pt = -Dt : Pt = Dt) : Pt = 0, Je[0].push(Pt);
      var Lt;
      Wt & 1 ? (Nt = Ee.andln(7) + $t & 7, (Nt === 3 || Nt === 5) && Dt === 2 ? Lt = -Wt : Lt = Wt) : Lt = 0, Je[1].push(Lt), 2 * Ve === Pt + 1 && (Ve = 1 - Ve), 2 * $t === Lt + 1 && ($t = 1 - $t), le.iushrn(1), Ee.iushrn(1);
    }
    return Je;
  }
  z.getJSF = se;
  function ae(le, Ee, Je) {
    var Ve = "_" + Ee;
    le.prototype[Ee] = function() {
      return this[Ve] !== void 0 ? this[Ve] : this[Ve] = Je.call(this);
    };
  }
  z.cachedProperty = ae;
  function ge(le) {
    return typeof le == "string" ? z.toArray(le, "hex") : le;
  }
  z.parseBytes = ge;
  function Ce(le) {
    return new Y(le, "hex", "le");
  }
  z.intFromLE = Ce;
})(utils$m);
var curve = {}, BN$9 = bnExports$1, utils$k = utils$m, getNAF = utils$k.getNAF, getJSF = utils$k.getJSF, assert$e = utils$k.assert;
function BaseCurve(B, z) {
  this.type = B, this.p = new BN$9(z.p, 16), this.red = z.prime ? BN$9.red(z.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = z.n && new BN$9(z.n, 16), this.g = z.g && this.pointFromJSON(z.g, z.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var Y = this.n && this.p.div(this.n);
  !Y || Y.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$3 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(z, Y) {
  assert$e(z.precomputed);
  var ne = z._getDoubles(), ie = getNAF(Y, 1, this._bitLength), oe = (1 << ne.step + 1) - (ne.step % 2 === 0 ? 2 : 1);
  oe /= 3;
  var se = [], ae, ge;
  for (ae = 0; ae < ie.length; ae += ne.step) {
    ge = 0;
    for (var Ce = ae + ne.step - 1; Ce >= ae; Ce--)
      ge = (ge << 1) + ie[Ce];
    se.push(ge);
  }
  for (var le = this.jpoint(null, null, null), Ee = this.jpoint(null, null, null), Je = oe; Je > 0; Je--) {
    for (ae = 0; ae < se.length; ae++)
      ge = se[ae], ge === Je ? Ee = Ee.mixedAdd(ne.points[ae]) : ge === -Je && (Ee = Ee.mixedAdd(ne.points[ae].neg()));
    le = le.add(Ee);
  }
  return le.toP();
};
BaseCurve.prototype._wnafMul = function(z, Y) {
  var ne = 4, ie = z._getNAFPoints(ne);
  ne = ie.wnd;
  for (var oe = ie.points, se = getNAF(Y, ne, this._bitLength), ae = this.jpoint(null, null, null), ge = se.length - 1; ge >= 0; ge--) {
    for (var Ce = 0; ge >= 0 && se[ge] === 0; ge--)
      Ce++;
    if (ge >= 0 && Ce++, ae = ae.dblp(Ce), ge < 0)
      break;
    var le = se[ge];
    assert$e(le !== 0), z.type === "affine" ? le > 0 ? ae = ae.mixedAdd(oe[le - 1 >> 1]) : ae = ae.mixedAdd(oe[-le - 1 >> 1].neg()) : le > 0 ? ae = ae.add(oe[le - 1 >> 1]) : ae = ae.add(oe[-le - 1 >> 1].neg());
  }
  return z.type === "affine" ? ae.toP() : ae;
};
BaseCurve.prototype._wnafMulAdd = function(z, Y, ne, ie, oe) {
  var se = this._wnafT1, ae = this._wnafT2, ge = this._wnafT3, Ce = 0, le, Ee, Je;
  for (le = 0; le < ie; le++) {
    Je = Y[le];
    var Ve = Je._getNAFPoints(z);
    se[le] = Ve.wnd, ae[le] = Ve.points;
  }
  for (le = ie - 1; le >= 1; le -= 2) {
    var $t = le - 1, Nt = le;
    if (se[$t] !== 1 || se[Nt] !== 1) {
      ge[$t] = getNAF(ne[$t], se[$t], this._bitLength), ge[Nt] = getNAF(ne[Nt], se[Nt], this._bitLength), Ce = Math.max(ge[$t].length, Ce), Ce = Math.max(ge[Nt].length, Ce);
      continue;
    }
    var Dt = [
      Y[$t],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      Y[Nt]
      /* 7 */
    ];
    Y[$t].y.cmp(Y[Nt].y) === 0 ? (Dt[1] = Y[$t].add(Y[Nt]), Dt[2] = Y[$t].toJ().mixedAdd(Y[Nt].neg())) : Y[$t].y.cmp(Y[Nt].y.redNeg()) === 0 ? (Dt[1] = Y[$t].toJ().mixedAdd(Y[Nt]), Dt[2] = Y[$t].add(Y[Nt].neg())) : (Dt[1] = Y[$t].toJ().mixedAdd(Y[Nt]), Dt[2] = Y[$t].toJ().mixedAdd(Y[Nt].neg()));
    var Wt = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], Pt = getJSF(ne[$t], ne[Nt]);
    for (Ce = Math.max(Pt[0].length, Ce), ge[$t] = new Array(Ce), ge[Nt] = new Array(Ce), Ee = 0; Ee < Ce; Ee++) {
      var Lt = Pt[0][Ee] | 0, qt = Pt[1][Ee] | 0;
      ge[$t][Ee] = Wt[(Lt + 1) * 3 + (qt + 1)], ge[Nt][Ee] = 0, ae[$t] = Dt;
    }
  }
  var Zt = this.jpoint(null, null, null), Yt = this._wnafT4;
  for (le = Ce; le >= 0; le--) {
    for (var or = 0; le >= 0; ) {
      var jt = !0;
      for (Ee = 0; Ee < ie; Ee++)
        Yt[Ee] = ge[Ee][le] | 0, Yt[Ee] !== 0 && (jt = !1);
      if (!jt)
        break;
      or++, le--;
    }
    if (le >= 0 && or++, Zt = Zt.dblp(or), le < 0)
      break;
    for (Ee = 0; Ee < ie; Ee++) {
      var Ct = Yt[Ee];
      Ct !== 0 && (Ct > 0 ? Je = ae[Ee][Ct - 1 >> 1] : Ct < 0 && (Je = ae[Ee][-Ct - 1 >> 1].neg()), Je.type === "affine" ? Zt = Zt.mixedAdd(Je) : Zt = Zt.add(Je));
    }
  }
  for (le = 0; le < ie; le++)
    ae[le] = null;
  return oe ? Zt : Zt.toP();
};
function BasePoint(B, z) {
  this.curve = B, this.type = z, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(z, Y) {
  z = utils$k.toArray(z, Y);
  var ne = this.p.byteLength();
  if ((z[0] === 4 || z[0] === 6 || z[0] === 7) && z.length - 1 === 2 * ne) {
    z[0] === 6 ? assert$e(z[z.length - 1] % 2 === 0) : z[0] === 7 && assert$e(z[z.length - 1] % 2 === 1);
    var ie = this.point(
      z.slice(1, 1 + ne),
      z.slice(1 + ne, 1 + 2 * ne)
    );
    return ie;
  } else if ((z[0] === 2 || z[0] === 3) && z.length - 1 === ne)
    return this.pointFromX(z.slice(1, 1 + ne), z[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(z) {
  return this.encode(z, !0);
};
BasePoint.prototype._encode = function(z) {
  var Y = this.curve.p.byteLength(), ne = this.getX().toArray("be", Y);
  return z ? [this.getY().isEven() ? 2 : 3].concat(ne) : [4].concat(ne, this.getY().toArray("be", Y));
};
BasePoint.prototype.encode = function(z, Y) {
  return utils$k.encode(this._encode(Y), z);
};
BasePoint.prototype.precompute = function(z) {
  if (this.precomputed)
    return this;
  var Y = {
    doubles: null,
    naf: null,
    beta: null
  };
  return Y.naf = this._getNAFPoints(8), Y.doubles = this._getDoubles(4, z), Y.beta = this._getBeta(), this.precomputed = Y, this;
};
BasePoint.prototype._hasDoubles = function(z) {
  if (!this.precomputed)
    return !1;
  var Y = this.precomputed.doubles;
  return Y ? Y.points.length >= Math.ceil((z.bitLength() + 1) / Y.step) : !1;
};
BasePoint.prototype._getDoubles = function(z, Y) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var ne = [this], ie = this, oe = 0; oe < Y; oe += z) {
    for (var se = 0; se < z; se++)
      ie = ie.dbl();
    ne.push(ie);
  }
  return {
    step: z,
    points: ne
  };
};
BasePoint.prototype._getNAFPoints = function(z) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var Y = [this], ne = (1 << z) - 1, ie = ne === 1 ? null : this.dbl(), oe = 1; oe < ne; oe++)
    Y[oe] = Y[oe - 1].add(ie);
  return {
    wnd: z,
    points: Y
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(z) {
  for (var Y = this, ne = 0; ne < z; ne++)
    Y = Y.dbl();
  return Y;
};
var utils$j = utils$m, BN$8 = bnExports$1, inherits$4 = inherits_browserExports, Base$2 = base$3, assert$d = utils$j.assert;
function ShortCurve(B) {
  Base$2.call(this, "short", B), this.a = new BN$8(B.a, 16).toRed(this.red), this.b = new BN$8(B.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(B), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(z) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var Y, ne;
    if (z.beta)
      Y = new BN$8(z.beta, 16).toRed(this.red);
    else {
      var ie = this._getEndoRoots(this.p);
      Y = ie[0].cmp(ie[1]) < 0 ? ie[0] : ie[1], Y = Y.toRed(this.red);
    }
    if (z.lambda)
      ne = new BN$8(z.lambda, 16);
    else {
      var oe = this._getEndoRoots(this.n);
      this.g.mul(oe[0]).x.cmp(this.g.x.redMul(Y)) === 0 ? ne = oe[0] : (ne = oe[1], assert$d(this.g.mul(ne).x.cmp(this.g.x.redMul(Y)) === 0));
    }
    var se;
    return z.basis ? se = z.basis.map(function(ae) {
      return {
        a: new BN$8(ae.a, 16),
        b: new BN$8(ae.b, 16)
      };
    }) : se = this._getEndoBasis(ne), {
      beta: Y,
      lambda: ne,
      basis: se
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(z) {
  var Y = z === this.p ? this.red : BN$8.mont(z), ne = new BN$8(2).toRed(Y).redInvm(), ie = ne.redNeg(), oe = new BN$8(3).toRed(Y).redNeg().redSqrt().redMul(ne), se = ie.redAdd(oe).fromRed(), ae = ie.redSub(oe).fromRed();
  return [se, ae];
};
ShortCurve.prototype._getEndoBasis = function(z) {
  for (var Y = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), ne = z, ie = this.n.clone(), oe = new BN$8(1), se = new BN$8(0), ae = new BN$8(0), ge = new BN$8(1), Ce, le, Ee, Je, Ve, $t, Nt, Dt = 0, Wt, Pt; ne.cmpn(0) !== 0; ) {
    var Lt = ie.div(ne);
    Wt = ie.sub(Lt.mul(ne)), Pt = ae.sub(Lt.mul(oe));
    var qt = ge.sub(Lt.mul(se));
    if (!Ee && Wt.cmp(Y) < 0)
      Ce = Nt.neg(), le = oe, Ee = Wt.neg(), Je = Pt;
    else if (Ee && ++Dt === 2)
      break;
    Nt = Wt, ie = ne, ne = Wt, ae = oe, oe = Pt, ge = se, se = qt;
  }
  Ve = Wt.neg(), $t = Pt;
  var Zt = Ee.sqr().add(Je.sqr()), Yt = Ve.sqr().add($t.sqr());
  return Yt.cmp(Zt) >= 0 && (Ve = Ce, $t = le), Ee.negative && (Ee = Ee.neg(), Je = Je.neg()), Ve.negative && (Ve = Ve.neg(), $t = $t.neg()), [
    { a: Ee, b: Je },
    { a: Ve, b: $t }
  ];
};
ShortCurve.prototype._endoSplit = function(z) {
  var Y = this.endo.basis, ne = Y[0], ie = Y[1], oe = ie.b.mul(z).divRound(this.n), se = ne.b.neg().mul(z).divRound(this.n), ae = oe.mul(ne.a), ge = se.mul(ie.a), Ce = oe.mul(ne.b), le = se.mul(ie.b), Ee = z.sub(ae).sub(ge), Je = Ce.add(le).neg();
  return { k1: Ee, k2: Je };
};
ShortCurve.prototype.pointFromX = function(z, Y) {
  z = new BN$8(z, 16), z.red || (z = z.toRed(this.red));
  var ne = z.redSqr().redMul(z).redIAdd(z.redMul(this.a)).redIAdd(this.b), ie = ne.redSqrt();
  if (ie.redSqr().redSub(ne).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var oe = ie.fromRed().isOdd();
  return (Y && !oe || !Y && oe) && (ie = ie.redNeg()), this.point(z, ie);
};
ShortCurve.prototype.validate = function(z) {
  if (z.inf)
    return !0;
  var Y = z.x, ne = z.y, ie = this.a.redMul(Y), oe = Y.redSqr().redMul(Y).redIAdd(ie).redIAdd(this.b);
  return ne.redSqr().redISub(oe).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(z, Y, ne) {
  for (var ie = this._endoWnafT1, oe = this._endoWnafT2, se = 0; se < z.length; se++) {
    var ae = this._endoSplit(Y[se]), ge = z[se], Ce = ge._getBeta();
    ae.k1.negative && (ae.k1.ineg(), ge = ge.neg(!0)), ae.k2.negative && (ae.k2.ineg(), Ce = Ce.neg(!0)), ie[se * 2] = ge, ie[se * 2 + 1] = Ce, oe[se * 2] = ae.k1, oe[se * 2 + 1] = ae.k2;
  }
  for (var le = this._wnafMulAdd(1, ie, oe, se * 2, ne), Ee = 0; Ee < se * 2; Ee++)
    ie[Ee] = null, oe[Ee] = null;
  return le;
};
function Point$2(B, z, Y, ne) {
  Base$2.BasePoint.call(this, B, "affine"), z === null && Y === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(z, 16), this.y = new BN$8(Y, 16), ne && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(z, Y, ne) {
  return new Point$2(this, z, Y, ne);
};
ShortCurve.prototype.pointFromJSON = function(z, Y) {
  return Point$2.fromJSON(this, z, Y);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var z = this.precomputed;
    if (z && z.beta)
      return z.beta;
    var Y = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (z) {
      var ne = this.curve, ie = function(oe) {
        return ne.point(oe.x.redMul(ne.endo.beta), oe.y);
      };
      z.beta = Y, Y.precomputed = {
        beta: null,
        naf: z.naf && {
          wnd: z.naf.wnd,
          points: z.naf.points.map(ie)
        },
        doubles: z.doubles && {
          step: z.doubles.step,
          points: z.doubles.points.map(ie)
        }
      };
    }
    return Y;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(z, Y, ne) {
  typeof Y == "string" && (Y = JSON.parse(Y));
  var ie = z.point(Y[0], Y[1], ne);
  if (!Y[2])
    return ie;
  function oe(ae) {
    return z.point(ae[0], ae[1], ne);
  }
  var se = Y[2];
  return ie.precomputed = {
    beta: null,
    doubles: se.doubles && {
      step: se.doubles.step,
      points: [ie].concat(se.doubles.points.map(oe))
    },
    naf: se.naf && {
      wnd: se.naf.wnd,
      points: [ie].concat(se.naf.points.map(oe))
    }
  }, ie;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(z) {
  if (this.inf)
    return z;
  if (z.inf)
    return this;
  if (this.eq(z))
    return this.dbl();
  if (this.neg().eq(z))
    return this.curve.point(null, null);
  if (this.x.cmp(z.x) === 0)
    return this.curve.point(null, null);
  var Y = this.y.redSub(z.y);
  Y.cmpn(0) !== 0 && (Y = Y.redMul(this.x.redSub(z.x).redInvm()));
  var ne = Y.redSqr().redISub(this.x).redISub(z.x), ie = Y.redMul(this.x.redSub(ne)).redISub(this.y);
  return this.curve.point(ne, ie);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var z = this.y.redAdd(this.y);
  if (z.cmpn(0) === 0)
    return this.curve.point(null, null);
  var Y = this.curve.a, ne = this.x.redSqr(), ie = z.redInvm(), oe = ne.redAdd(ne).redIAdd(ne).redIAdd(Y).redMul(ie), se = oe.redSqr().redISub(this.x.redAdd(this.x)), ae = oe.redMul(this.x.redSub(se)).redISub(this.y);
  return this.curve.point(se, ae);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(z) {
  return z = new BN$8(z, 16), this.isInfinity() ? this : this._hasDoubles(z) ? this.curve._fixedNafMul(this, z) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [z]) : this.curve._wnafMul(this, z);
};
Point$2.prototype.mulAdd = function(z, Y, ne) {
  var ie = [this, Y], oe = [z, ne];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ie, oe) : this.curve._wnafMulAdd(1, ie, oe, 2);
};
Point$2.prototype.jmulAdd = function(z, Y, ne) {
  var ie = [this, Y], oe = [z, ne];
  return this.curve.endo ? this.curve._endoWnafMulAdd(ie, oe, !0) : this.curve._wnafMulAdd(1, ie, oe, 2, !0);
};
Point$2.prototype.eq = function(z) {
  return this === z || this.inf === z.inf && (this.inf || this.x.cmp(z.x) === 0 && this.y.cmp(z.y) === 0);
};
Point$2.prototype.neg = function(z) {
  if (this.inf)
    return this;
  var Y = this.curve.point(this.x, this.y.redNeg());
  if (z && this.precomputed) {
    var ne = this.precomputed, ie = function(oe) {
      return oe.neg();
    };
    Y.precomputed = {
      naf: ne.naf && {
        wnd: ne.naf.wnd,
        points: ne.naf.points.map(ie)
      },
      doubles: ne.doubles && {
        step: ne.doubles.step,
        points: ne.doubles.points.map(ie)
      }
    };
  }
  return Y;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var z = this.curve.jpoint(this.x, this.y, this.curve.one);
  return z;
};
function JPoint(B, z, Y, ne) {
  Base$2.BasePoint.call(this, B, "jacobian"), z === null && Y === null && ne === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(z, 16), this.y = new BN$8(Y, 16), this.z = new BN$8(ne, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(z, Y, ne) {
  return new JPoint(this, z, Y, ne);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var z = this.z.redInvm(), Y = z.redSqr(), ne = this.x.redMul(Y), ie = this.y.redMul(Y).redMul(z);
  return this.curve.point(ne, ie);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(z) {
  if (this.isInfinity())
    return z;
  if (z.isInfinity())
    return this;
  var Y = z.z.redSqr(), ne = this.z.redSqr(), ie = this.x.redMul(Y), oe = z.x.redMul(ne), se = this.y.redMul(Y.redMul(z.z)), ae = z.y.redMul(ne.redMul(this.z)), ge = ie.redSub(oe), Ce = se.redSub(ae);
  if (ge.cmpn(0) === 0)
    return Ce.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var le = ge.redSqr(), Ee = le.redMul(ge), Je = ie.redMul(le), Ve = Ce.redSqr().redIAdd(Ee).redISub(Je).redISub(Je), $t = Ce.redMul(Je.redISub(Ve)).redISub(se.redMul(Ee)), Nt = this.z.redMul(z.z).redMul(ge);
  return this.curve.jpoint(Ve, $t, Nt);
};
JPoint.prototype.mixedAdd = function(z) {
  if (this.isInfinity())
    return z.toJ();
  if (z.isInfinity())
    return this;
  var Y = this.z.redSqr(), ne = this.x, ie = z.x.redMul(Y), oe = this.y, se = z.y.redMul(Y).redMul(this.z), ae = ne.redSub(ie), ge = oe.redSub(se);
  if (ae.cmpn(0) === 0)
    return ge.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Ce = ae.redSqr(), le = Ce.redMul(ae), Ee = ne.redMul(Ce), Je = ge.redSqr().redIAdd(le).redISub(Ee).redISub(Ee), Ve = ge.redMul(Ee.redISub(Je)).redISub(oe.redMul(le)), $t = this.z.redMul(ae);
  return this.curve.jpoint(Je, Ve, $t);
};
JPoint.prototype.dblp = function(z) {
  if (z === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!z)
    return this.dbl();
  var Y;
  if (this.curve.zeroA || this.curve.threeA) {
    var ne = this;
    for (Y = 0; Y < z; Y++)
      ne = ne.dbl();
    return ne;
  }
  var ie = this.curve.a, oe = this.curve.tinv, se = this.x, ae = this.y, ge = this.z, Ce = ge.redSqr().redSqr(), le = ae.redAdd(ae);
  for (Y = 0; Y < z; Y++) {
    var Ee = se.redSqr(), Je = le.redSqr(), Ve = Je.redSqr(), $t = Ee.redAdd(Ee).redIAdd(Ee).redIAdd(ie.redMul(Ce)), Nt = se.redMul(Je), Dt = $t.redSqr().redISub(Nt.redAdd(Nt)), Wt = Nt.redISub(Dt), Pt = $t.redMul(Wt);
    Pt = Pt.redIAdd(Pt).redISub(Ve);
    var Lt = le.redMul(ge);
    Y + 1 < z && (Ce = Ce.redMul(Ve)), se = Dt, ge = Lt, le = Pt;
  }
  return this.curve.jpoint(se, le.redMul(oe), ge);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var z, Y, ne;
  if (this.zOne) {
    var ie = this.x.redSqr(), oe = this.y.redSqr(), se = oe.redSqr(), ae = this.x.redAdd(oe).redSqr().redISub(ie).redISub(se);
    ae = ae.redIAdd(ae);
    var ge = ie.redAdd(ie).redIAdd(ie), Ce = ge.redSqr().redISub(ae).redISub(ae), le = se.redIAdd(se);
    le = le.redIAdd(le), le = le.redIAdd(le), z = Ce, Y = ge.redMul(ae.redISub(Ce)).redISub(le), ne = this.y.redAdd(this.y);
  } else {
    var Ee = this.x.redSqr(), Je = this.y.redSqr(), Ve = Je.redSqr(), $t = this.x.redAdd(Je).redSqr().redISub(Ee).redISub(Ve);
    $t = $t.redIAdd($t);
    var Nt = Ee.redAdd(Ee).redIAdd(Ee), Dt = Nt.redSqr(), Wt = Ve.redIAdd(Ve);
    Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt), z = Dt.redISub($t).redISub($t), Y = Nt.redMul($t.redISub(z)).redISub(Wt), ne = this.y.redMul(this.z), ne = ne.redIAdd(ne);
  }
  return this.curve.jpoint(z, Y, ne);
};
JPoint.prototype._threeDbl = function() {
  var z, Y, ne;
  if (this.zOne) {
    var ie = this.x.redSqr(), oe = this.y.redSqr(), se = oe.redSqr(), ae = this.x.redAdd(oe).redSqr().redISub(ie).redISub(se);
    ae = ae.redIAdd(ae);
    var ge = ie.redAdd(ie).redIAdd(ie).redIAdd(this.curve.a), Ce = ge.redSqr().redISub(ae).redISub(ae);
    z = Ce;
    var le = se.redIAdd(se);
    le = le.redIAdd(le), le = le.redIAdd(le), Y = ge.redMul(ae.redISub(Ce)).redISub(le), ne = this.y.redAdd(this.y);
  } else {
    var Ee = this.z.redSqr(), Je = this.y.redSqr(), Ve = this.x.redMul(Je), $t = this.x.redSub(Ee).redMul(this.x.redAdd(Ee));
    $t = $t.redAdd($t).redIAdd($t);
    var Nt = Ve.redIAdd(Ve);
    Nt = Nt.redIAdd(Nt);
    var Dt = Nt.redAdd(Nt);
    z = $t.redSqr().redISub(Dt), ne = this.y.redAdd(this.z).redSqr().redISub(Je).redISub(Ee);
    var Wt = Je.redSqr();
    Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt), Y = $t.redMul(Nt.redISub(z)).redISub(Wt);
  }
  return this.curve.jpoint(z, Y, ne);
};
JPoint.prototype._dbl = function() {
  var z = this.curve.a, Y = this.x, ne = this.y, ie = this.z, oe = ie.redSqr().redSqr(), se = Y.redSqr(), ae = ne.redSqr(), ge = se.redAdd(se).redIAdd(se).redIAdd(z.redMul(oe)), Ce = Y.redAdd(Y);
  Ce = Ce.redIAdd(Ce);
  var le = Ce.redMul(ae), Ee = ge.redSqr().redISub(le.redAdd(le)), Je = le.redISub(Ee), Ve = ae.redSqr();
  Ve = Ve.redIAdd(Ve), Ve = Ve.redIAdd(Ve), Ve = Ve.redIAdd(Ve);
  var $t = ge.redMul(Je).redISub(Ve), Nt = ne.redAdd(ne).redMul(ie);
  return this.curve.jpoint(Ee, $t, Nt);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var z = this.x.redSqr(), Y = this.y.redSqr(), ne = this.z.redSqr(), ie = Y.redSqr(), oe = z.redAdd(z).redIAdd(z), se = oe.redSqr(), ae = this.x.redAdd(Y).redSqr().redISub(z).redISub(ie);
  ae = ae.redIAdd(ae), ae = ae.redAdd(ae).redIAdd(ae), ae = ae.redISub(se);
  var ge = ae.redSqr(), Ce = ie.redIAdd(ie);
  Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce);
  var le = oe.redIAdd(ae).redSqr().redISub(se).redISub(ge).redISub(Ce), Ee = Y.redMul(le);
  Ee = Ee.redIAdd(Ee), Ee = Ee.redIAdd(Ee);
  var Je = this.x.redMul(ge).redISub(Ee);
  Je = Je.redIAdd(Je), Je = Je.redIAdd(Je);
  var Ve = this.y.redMul(le.redMul(Ce.redISub(le)).redISub(ae.redMul(ge)));
  Ve = Ve.redIAdd(Ve), Ve = Ve.redIAdd(Ve), Ve = Ve.redIAdd(Ve);
  var $t = this.z.redAdd(ae).redSqr().redISub(ne).redISub(ge);
  return this.curve.jpoint(Je, Ve, $t);
};
JPoint.prototype.mul = function(z, Y) {
  return z = new BN$8(z, Y), this.curve._wnafMul(this, z);
};
JPoint.prototype.eq = function(z) {
  if (z.type === "affine")
    return this.eq(z.toJ());
  if (this === z)
    return !0;
  var Y = this.z.redSqr(), ne = z.z.redSqr();
  if (this.x.redMul(ne).redISub(z.x.redMul(Y)).cmpn(0) !== 0)
    return !1;
  var ie = Y.redMul(this.z), oe = ne.redMul(z.z);
  return this.y.redMul(oe).redISub(z.y.redMul(ie)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(z) {
  var Y = this.z.redSqr(), ne = z.toRed(this.curve.red).redMul(Y);
  if (this.x.cmp(ne) === 0)
    return !0;
  for (var ie = z.clone(), oe = this.curve.redN.redMul(Y); ; ) {
    if (ie.iadd(this.curve.n), ie.cmp(this.curve.p) >= 0)
      return !1;
    if (ne.redIAdd(oe), this.x.cmp(ne) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$1, inherits$3 = inherits_browserExports, Base$1 = base$3, utils$i = utils$m;
function MontCurve(B) {
  Base$1.call(this, "mont", B), this.a = new BN$7(B.a, 16).toRed(this.red), this.b = new BN$7(B.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(z) {
  var Y = z.normalize().x, ne = Y.redSqr(), ie = ne.redMul(Y).redAdd(ne.redMul(this.a)).redAdd(Y), oe = ie.redSqrt();
  return oe.redSqr().cmp(ie) === 0;
};
function Point$1(B, z, Y) {
  Base$1.BasePoint.call(this, B, "projective"), z === null && Y === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(z, 16), this.z = new BN$7(Y, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(z, Y) {
  return this.point(utils$i.toArray(z, Y), 1);
};
MontCurve.prototype.point = function(z, Y) {
  return new Point$1(this, z, Y);
};
MontCurve.prototype.pointFromJSON = function(z) {
  return Point$1.fromJSON(this, z);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(z, Y) {
  return new Point$1(z, Y[0], Y[1] || z.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var z = this.x.redAdd(this.z), Y = z.redSqr(), ne = this.x.redSub(this.z), ie = ne.redSqr(), oe = Y.redSub(ie), se = Y.redMul(ie), ae = oe.redMul(ie.redAdd(this.curve.a24.redMul(oe)));
  return this.curve.point(se, ae);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(z, Y) {
  var ne = this.x.redAdd(this.z), ie = this.x.redSub(this.z), oe = z.x.redAdd(z.z), se = z.x.redSub(z.z), ae = se.redMul(ne), ge = oe.redMul(ie), Ce = Y.z.redMul(ae.redAdd(ge).redSqr()), le = Y.x.redMul(ae.redISub(ge).redSqr());
  return this.curve.point(Ce, le);
};
Point$1.prototype.mul = function(z) {
  for (var Y = z.clone(), ne = this, ie = this.curve.point(null, null), oe = this, se = []; Y.cmpn(0) !== 0; Y.iushrn(1))
    se.push(Y.andln(1));
  for (var ae = se.length - 1; ae >= 0; ae--)
    se[ae] === 0 ? (ne = ne.diffAdd(ie, oe), ie = ie.dbl()) : (ie = ne.diffAdd(ie, oe), ne = ne.dbl());
  return ie;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(z) {
  return this.getX().cmp(z.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$h = utils$m, BN$6 = bnExports$1, inherits$2 = inherits_browserExports, Base = base$3, assert$c = utils$h.assert;
function EdwardsCurve(B) {
  this.twisted = (B.a | 0) !== 1, this.mOneA = this.twisted && (B.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", B), this.a = new BN$6(B.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(B.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(B.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (B.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(z) {
  return this.mOneA ? z.redNeg() : this.a.redMul(z);
};
EdwardsCurve.prototype._mulC = function(z) {
  return this.oneC ? z : this.c.redMul(z);
};
EdwardsCurve.prototype.jpoint = function(z, Y, ne, ie) {
  return this.point(z, Y, ne, ie);
};
EdwardsCurve.prototype.pointFromX = function(z, Y) {
  z = new BN$6(z, 16), z.red || (z = z.toRed(this.red));
  var ne = z.redSqr(), ie = this.c2.redSub(this.a.redMul(ne)), oe = this.one.redSub(this.c2.redMul(this.d).redMul(ne)), se = ie.redMul(oe.redInvm()), ae = se.redSqrt();
  if (ae.redSqr().redSub(se).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var ge = ae.fromRed().isOdd();
  return (Y && !ge || !Y && ge) && (ae = ae.redNeg()), this.point(z, ae);
};
EdwardsCurve.prototype.pointFromY = function(z, Y) {
  z = new BN$6(z, 16), z.red || (z = z.toRed(this.red));
  var ne = z.redSqr(), ie = ne.redSub(this.c2), oe = ne.redMul(this.d).redMul(this.c2).redSub(this.a), se = ie.redMul(oe.redInvm());
  if (se.cmp(this.zero) === 0) {
    if (Y)
      throw new Error("invalid point");
    return this.point(this.zero, z);
  }
  var ae = se.redSqrt();
  if (ae.redSqr().redSub(se).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return ae.fromRed().isOdd() !== Y && (ae = ae.redNeg()), this.point(ae, z);
};
EdwardsCurve.prototype.validate = function(z) {
  if (z.isInfinity())
    return !0;
  z.normalize();
  var Y = z.x.redSqr(), ne = z.y.redSqr(), ie = Y.redMul(this.a).redAdd(ne), oe = this.c2.redMul(this.one.redAdd(this.d.redMul(Y).redMul(ne)));
  return ie.cmp(oe) === 0;
};
function Point(B, z, Y, ne, ie) {
  Base.BasePoint.call(this, B, "projective"), z === null && Y === null && ne === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(z, 16), this.y = new BN$6(Y, 16), this.z = ne ? new BN$6(ne, 16) : this.curve.one, this.t = ie && new BN$6(ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(z) {
  return Point.fromJSON(this, z);
};
EdwardsCurve.prototype.point = function(z, Y, ne, ie) {
  return new Point(this, z, Y, ne, ie);
};
Point.fromJSON = function(z, Y) {
  return new Point(z, Y[0], Y[1], Y[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var z = this.x.redSqr(), Y = this.y.redSqr(), ne = this.z.redSqr();
  ne = ne.redIAdd(ne);
  var ie = this.curve._mulA(z), oe = this.x.redAdd(this.y).redSqr().redISub(z).redISub(Y), se = ie.redAdd(Y), ae = se.redSub(ne), ge = ie.redSub(Y), Ce = oe.redMul(ae), le = se.redMul(ge), Ee = oe.redMul(ge), Je = ae.redMul(se);
  return this.curve.point(Ce, le, Je, Ee);
};
Point.prototype._projDbl = function() {
  var z = this.x.redAdd(this.y).redSqr(), Y = this.x.redSqr(), ne = this.y.redSqr(), ie, oe, se, ae, ge, Ce;
  if (this.curve.twisted) {
    ae = this.curve._mulA(Y);
    var le = ae.redAdd(ne);
    this.zOne ? (ie = z.redSub(Y).redSub(ne).redMul(le.redSub(this.curve.two)), oe = le.redMul(ae.redSub(ne)), se = le.redSqr().redSub(le).redSub(le)) : (ge = this.z.redSqr(), Ce = le.redSub(ge).redISub(ge), ie = z.redSub(Y).redISub(ne).redMul(Ce), oe = le.redMul(ae.redSub(ne)), se = le.redMul(Ce));
  } else
    ae = Y.redAdd(ne), ge = this.curve._mulC(this.z).redSqr(), Ce = ae.redSub(ge).redSub(ge), ie = this.curve._mulC(z.redISub(ae)).redMul(Ce), oe = this.curve._mulC(ae).redMul(Y.redISub(ne)), se = ae.redMul(Ce);
  return this.curve.point(ie, oe, se);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(z) {
  var Y = this.y.redSub(this.x).redMul(z.y.redSub(z.x)), ne = this.y.redAdd(this.x).redMul(z.y.redAdd(z.x)), ie = this.t.redMul(this.curve.dd).redMul(z.t), oe = this.z.redMul(z.z.redAdd(z.z)), se = ne.redSub(Y), ae = oe.redSub(ie), ge = oe.redAdd(ie), Ce = ne.redAdd(Y), le = se.redMul(ae), Ee = ge.redMul(Ce), Je = se.redMul(Ce), Ve = ae.redMul(ge);
  return this.curve.point(le, Ee, Ve, Je);
};
Point.prototype._projAdd = function(z) {
  var Y = this.z.redMul(z.z), ne = Y.redSqr(), ie = this.x.redMul(z.x), oe = this.y.redMul(z.y), se = this.curve.d.redMul(ie).redMul(oe), ae = ne.redSub(se), ge = ne.redAdd(se), Ce = this.x.redAdd(this.y).redMul(z.x.redAdd(z.y)).redISub(ie).redISub(oe), le = Y.redMul(ae).redMul(Ce), Ee, Je;
  return this.curve.twisted ? (Ee = Y.redMul(ge).redMul(oe.redSub(this.curve._mulA(ie))), Je = ae.redMul(ge)) : (Ee = Y.redMul(ge).redMul(oe.redSub(ie)), Je = this.curve._mulC(ae).redMul(ge)), this.curve.point(le, Ee, Je);
};
Point.prototype.add = function(z) {
  return this.isInfinity() ? z : z.isInfinity() ? this : this.curve.extended ? this._extAdd(z) : this._projAdd(z);
};
Point.prototype.mul = function(z) {
  return this._hasDoubles(z) ? this.curve._fixedNafMul(this, z) : this.curve._wnafMul(this, z);
};
Point.prototype.mulAdd = function(z, Y, ne) {
  return this.curve._wnafMulAdd(1, [this, Y], [z, ne], 2, !1);
};
Point.prototype.jmulAdd = function(z, Y, ne) {
  return this.curve._wnafMulAdd(1, [this, Y], [z, ne], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var z = this.z.redInvm();
  return this.x = this.x.redMul(z), this.y = this.y.redMul(z), this.t && (this.t = this.t.redMul(z)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(z) {
  return this === z || this.getX().cmp(z.getX()) === 0 && this.getY().cmp(z.getY()) === 0;
};
Point.prototype.eqXToP = function(z) {
  var Y = z.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(Y) === 0)
    return !0;
  for (var ne = z.clone(), ie = this.curve.redN.redMul(this.z); ; ) {
    if (ne.iadd(this.curve.n), ne.cmp(this.curve.p) >= 0)
      return !1;
    if (Y.redIAdd(ie), this.x.cmp(Y) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(B) {
  var z = B;
  z.base = base$3, z.short = short, z.mont = mont, z.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$g = {}, assert$b = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$g.inherits = inherits$1;
function isSurrogatePair(B, z) {
  return (B.charCodeAt(z) & 64512) !== 55296 || z < 0 || z + 1 >= B.length ? !1 : (B.charCodeAt(z + 1) & 64512) === 56320;
}
function toArray(B, z) {
  if (Array.isArray(B))
    return B.slice();
  if (!B)
    return [];
  var Y = [];
  if (typeof B == "string")
    if (z) {
      if (z === "hex")
        for (B = B.replace(/[^a-z0-9]+/ig, ""), B.length % 2 !== 0 && (B = "0" + B), ie = 0; ie < B.length; ie += 2)
          Y.push(parseInt(B[ie] + B[ie + 1], 16));
    } else for (var ne = 0, ie = 0; ie < B.length; ie++) {
      var oe = B.charCodeAt(ie);
      oe < 128 ? Y[ne++] = oe : oe < 2048 ? (Y[ne++] = oe >> 6 | 192, Y[ne++] = oe & 63 | 128) : isSurrogatePair(B, ie) ? (oe = 65536 + ((oe & 1023) << 10) + (B.charCodeAt(++ie) & 1023), Y[ne++] = oe >> 18 | 240, Y[ne++] = oe >> 12 & 63 | 128, Y[ne++] = oe >> 6 & 63 | 128, Y[ne++] = oe & 63 | 128) : (Y[ne++] = oe >> 12 | 224, Y[ne++] = oe >> 6 & 63 | 128, Y[ne++] = oe & 63 | 128);
    }
  else
    for (ie = 0; ie < B.length; ie++)
      Y[ie] = B[ie] | 0;
  return Y;
}
utils$g.toArray = toArray;
function toHex(B) {
  for (var z = "", Y = 0; Y < B.length; Y++)
    z += zero2(B[Y].toString(16));
  return z;
}
utils$g.toHex = toHex;
function htonl(B) {
  var z = B >>> 24 | B >>> 8 & 65280 | B << 8 & 16711680 | (B & 255) << 24;
  return z >>> 0;
}
utils$g.htonl = htonl;
function toHex32(B, z) {
  for (var Y = "", ne = 0; ne < B.length; ne++) {
    var ie = B[ne];
    z === "little" && (ie = htonl(ie)), Y += zero8(ie.toString(16));
  }
  return Y;
}
utils$g.toHex32 = toHex32;
function zero2(B) {
  return B.length === 1 ? "0" + B : B;
}
utils$g.zero2 = zero2;
function zero8(B) {
  return B.length === 7 ? "0" + B : B.length === 6 ? "00" + B : B.length === 5 ? "000" + B : B.length === 4 ? "0000" + B : B.length === 3 ? "00000" + B : B.length === 2 ? "000000" + B : B.length === 1 ? "0000000" + B : B;
}
utils$g.zero8 = zero8;
function join32(B, z, Y, ne) {
  var ie = Y - z;
  assert$b(ie % 4 === 0);
  for (var oe = new Array(ie / 4), se = 0, ae = z; se < oe.length; se++, ae += 4) {
    var ge;
    ne === "big" ? ge = B[ae] << 24 | B[ae + 1] << 16 | B[ae + 2] << 8 | B[ae + 3] : ge = B[ae + 3] << 24 | B[ae + 2] << 16 | B[ae + 1] << 8 | B[ae], oe[se] = ge >>> 0;
  }
  return oe;
}
utils$g.join32 = join32;
function split32(B, z) {
  for (var Y = new Array(B.length * 4), ne = 0, ie = 0; ne < B.length; ne++, ie += 4) {
    var oe = B[ne];
    z === "big" ? (Y[ie] = oe >>> 24, Y[ie + 1] = oe >>> 16 & 255, Y[ie + 2] = oe >>> 8 & 255, Y[ie + 3] = oe & 255) : (Y[ie + 3] = oe >>> 24, Y[ie + 2] = oe >>> 16 & 255, Y[ie + 1] = oe >>> 8 & 255, Y[ie] = oe & 255);
  }
  return Y;
}
utils$g.split32 = split32;
function rotr32$1(B, z) {
  return B >>> z | B << 32 - z;
}
utils$g.rotr32 = rotr32$1;
function rotl32$2(B, z) {
  return B << z | B >>> 32 - z;
}
utils$g.rotl32 = rotl32$2;
function sum32$3(B, z) {
  return B + z >>> 0;
}
utils$g.sum32 = sum32$3;
function sum32_3$1(B, z, Y) {
  return B + z + Y >>> 0;
}
utils$g.sum32_3 = sum32_3$1;
function sum32_4$2(B, z, Y, ne) {
  return B + z + Y + ne >>> 0;
}
utils$g.sum32_4 = sum32_4$2;
function sum32_5$2(B, z, Y, ne, ie) {
  return B + z + Y + ne + ie >>> 0;
}
utils$g.sum32_5 = sum32_5$2;
function sum64$1(B, z, Y, ne) {
  var ie = B[z], oe = B[z + 1], se = ne + oe >>> 0, ae = (se < ne ? 1 : 0) + Y + ie;
  B[z] = ae >>> 0, B[z + 1] = se;
}
utils$g.sum64 = sum64$1;
function sum64_hi$1(B, z, Y, ne) {
  var ie = z + ne >>> 0, oe = (ie < z ? 1 : 0) + B + Y;
  return oe >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;
function sum64_lo$1(B, z, Y, ne) {
  var ie = z + ne;
  return ie >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(B, z, Y, ne, ie, oe, se, ae) {
  var ge = 0, Ce = z;
  Ce = Ce + ne >>> 0, ge += Ce < z ? 1 : 0, Ce = Ce + oe >>> 0, ge += Ce < oe ? 1 : 0, Ce = Ce + ae >>> 0, ge += Ce < ae ? 1 : 0;
  var le = B + Y + ie + se + ge;
  return le >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(B, z, Y, ne, ie, oe, se, ae) {
  var ge = z + ne + oe + ae;
  return ge >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(B, z, Y, ne, ie, oe, se, ae, ge, Ce) {
  var le = 0, Ee = z;
  Ee = Ee + ne >>> 0, le += Ee < z ? 1 : 0, Ee = Ee + oe >>> 0, le += Ee < oe ? 1 : 0, Ee = Ee + ae >>> 0, le += Ee < ae ? 1 : 0, Ee = Ee + Ce >>> 0, le += Ee < Ce ? 1 : 0;
  var Je = B + Y + ie + se + ge + le;
  return Je >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(B, z, Y, ne, ie, oe, se, ae, ge, Ce) {
  var le = z + ne + oe + ae + Ce;
  return le >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(B, z, Y) {
  var ne = z << 32 - Y | B >>> Y;
  return ne >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(B, z, Y) {
  var ne = B << 32 - Y | z >>> Y;
  return ne >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(B, z, Y) {
  return B >>> Y;
}
utils$g.shr64_hi = shr64_hi$1;
function shr64_lo$1(B, z, Y) {
  var ne = B << 32 - Y | z >>> Y;
  return ne >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(z, Y) {
  if (z = utils$f.toArray(z, Y), this.pending ? this.pending = this.pending.concat(z) : this.pending = z, this.pendingTotal += z.length, this.pending.length >= this._delta8) {
    z = this.pending;
    var ne = z.length % this._delta8;
    this.pending = z.slice(z.length - ne, z.length), this.pending.length === 0 && (this.pending = null), z = utils$f.join32(z, 0, z.length - ne, this.endian);
    for (var ie = 0; ie < z.length; ie += this._delta32)
      this._update(z, ie, ie + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(z) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(z);
};
BlockHash$4.prototype._pad = function() {
  var z = this.pendingTotal, Y = this._delta8, ne = Y - (z + this.padLength) % Y, ie = new Array(ne + this.padLength);
  ie[0] = 128;
  for (var oe = 1; oe < ne; oe++)
    ie[oe] = 0;
  if (z <<= 3, this.endian === "big") {
    for (var se = 8; se < this.padLength; se++)
      ie[oe++] = 0;
    ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = z >>> 24 & 255, ie[oe++] = z >>> 16 & 255, ie[oe++] = z >>> 8 & 255, ie[oe++] = z & 255;
  } else
    for (ie[oe++] = z & 255, ie[oe++] = z >>> 8 & 255, ie[oe++] = z >>> 16 & 255, ie[oe++] = z >>> 24 & 255, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, ie[oe++] = 0, se = 8; se < this.padLength; se++)
      ie[oe++] = 0;
  return ie;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(B, z, Y, ne) {
  if (B === 0)
    return ch32$1(z, Y, ne);
  if (B === 1 || B === 3)
    return p32(z, Y, ne);
  if (B === 2)
    return maj32$1(z, Y, ne);
}
common$4.ft_1 = ft_1$1;
function ch32$1(B, z, Y) {
  return B & z ^ ~B & Y;
}
common$4.ch32 = ch32$1;
function maj32$1(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
common$4.maj32 = maj32$1;
function p32(B, z, Y) {
  return B ^ z ^ Y;
}
common$4.p32 = p32;
function s0_256$1(B) {
  return rotr32(B, 2) ^ rotr32(B, 13) ^ rotr32(B, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(B) {
  return rotr32(B, 6) ^ rotr32(B, 11) ^ rotr32(B, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(B) {
  return rotr32(B, 7) ^ rotr32(B, 18) ^ B >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(B) {
  return rotr32(B, 17) ^ rotr32(B, 19) ^ B >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1$1() {
  if (!(this instanceof SHA1$1))
    return new SHA1$1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$d.inherits(SHA1$1, BlockHash$3);
var _1 = SHA1$1;
SHA1$1.blockSize = 512;
SHA1$1.outSize = 160;
SHA1$1.hmacStrength = 80;
SHA1$1.padLength = 64;
SHA1$1.prototype._update = function(z, Y) {
  for (var ne = this.W, ie = 0; ie < 16; ie++)
    ne[ie] = z[Y + ie];
  for (; ie < ne.length; ie++)
    ne[ie] = rotl32$1(ne[ie - 3] ^ ne[ie - 8] ^ ne[ie - 14] ^ ne[ie - 16], 1);
  var oe = this.h[0], se = this.h[1], ae = this.h[2], ge = this.h[3], Ce = this.h[4];
  for (ie = 0; ie < ne.length; ie++) {
    var le = ~~(ie / 20), Ee = sum32_5$1(rotl32$1(oe, 5), ft_1(le, se, ae, ge), Ce, ne[ie], sha1_K[le]);
    Ce = ge, ge = ae, ae = rotl32$1(se, 30), se = oe, oe = Ee;
  }
  this.h[0] = sum32$2(this.h[0], oe), this.h[1] = sum32$2(this.h[1], se), this.h[2] = sum32$2(this.h[2], ae), this.h[3] = sum32$2(this.h[3], ge), this.h[4] = sum32$2(this.h[4], Ce);
};
SHA1$1.prototype._digest = function(z) {
  return z === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(z, Y) {
  for (var ne = this.W, ie = 0; ie < 16; ie++)
    ne[ie] = z[Y + ie];
  for (; ie < ne.length; ie++)
    ne[ie] = sum32_4$1(g1_256(ne[ie - 2]), ne[ie - 7], g0_256(ne[ie - 15]), ne[ie - 16]);
  var oe = this.h[0], se = this.h[1], ae = this.h[2], ge = this.h[3], Ce = this.h[4], le = this.h[5], Ee = this.h[6], Je = this.h[7];
  for (assert$9(this.k.length === ne.length), ie = 0; ie < ne.length; ie++) {
    var Ve = sum32_5(Je, s1_256(Ce), ch32(Ce, le, Ee), this.k[ie], ne[ie]), $t = sum32$1(s0_256(oe), maj32(oe, se, ae));
    Je = Ee, Ee = le, le = Ce, Ce = sum32$1(ge, Ve), ge = ae, ae = se, se = oe, oe = sum32$1(Ve, $t);
  }
  this.h[0] = sum32$1(this.h[0], oe), this.h[1] = sum32$1(this.h[1], se), this.h[2] = sum32$1(this.h[2], ae), this.h[3] = sum32$1(this.h[3], ge), this.h[4] = sum32$1(this.h[4], Ce), this.h[5] = sum32$1(this.h[5], le), this.h[6] = sum32$1(this.h[6], Ee), this.h[7] = sum32$1(this.h[7], Je);
};
SHA256$1.prototype._digest = function(z) {
  return z === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(z) {
  return z === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(z, Y) {
  for (var ne = this.W, ie = 0; ie < 32; ie++)
    ne[ie] = z[Y + ie];
  for (; ie < ne.length; ie += 2) {
    var oe = g1_512_hi(ne[ie - 4], ne[ie - 3]), se = g1_512_lo(ne[ie - 4], ne[ie - 3]), ae = ne[ie - 14], ge = ne[ie - 13], Ce = g0_512_hi(ne[ie - 30], ne[ie - 29]), le = g0_512_lo(ne[ie - 30], ne[ie - 29]), Ee = ne[ie - 32], Je = ne[ie - 31];
    ne[ie] = sum64_4_hi(
      oe,
      se,
      ae,
      ge,
      Ce,
      le,
      Ee,
      Je
    ), ne[ie + 1] = sum64_4_lo(
      oe,
      se,
      ae,
      ge,
      Ce,
      le,
      Ee,
      Je
    );
  }
};
SHA512$1.prototype._update = function(z, Y) {
  this._prepareBlock(z, Y);
  var ne = this.W, ie = this.h[0], oe = this.h[1], se = this.h[2], ae = this.h[3], ge = this.h[4], Ce = this.h[5], le = this.h[6], Ee = this.h[7], Je = this.h[8], Ve = this.h[9], $t = this.h[10], Nt = this.h[11], Dt = this.h[12], Wt = this.h[13], Pt = this.h[14], Lt = this.h[15];
  assert$8(this.k.length === ne.length);
  for (var qt = 0; qt < ne.length; qt += 2) {
    var Zt = Pt, Yt = Lt, or = s1_512_hi(Je, Ve), jt = s1_512_lo(Je, Ve), Ct = ch64_hi(Je, Ve, $t, Nt, Dt), Vt = ch64_lo(Je, Ve, $t, Nt, Dt, Wt), kt = this.k[qt], Pe = this.k[qt + 1], Xe = ne[qt], ve = ne[qt + 1], Ke = sum64_5_hi(
      Zt,
      Yt,
      or,
      jt,
      Ct,
      Vt,
      kt,
      Pe,
      Xe,
      ve
    ), ht = sum64_5_lo(
      Zt,
      Yt,
      or,
      jt,
      Ct,
      Vt,
      kt,
      Pe,
      Xe,
      ve
    );
    Zt = s0_512_hi(ie, oe), Yt = s0_512_lo(ie, oe), or = maj64_hi(ie, oe, se, ae, ge), jt = maj64_lo(ie, oe, se, ae, ge, Ce);
    var wt = sum64_hi(Zt, Yt, or, jt), vt = sum64_lo(Zt, Yt, or, jt);
    Pt = Dt, Lt = Wt, Dt = $t, Wt = Nt, $t = Je, Nt = Ve, Je = sum64_hi(le, Ee, Ke, ht), Ve = sum64_lo(Ee, Ee, Ke, ht), le = ge, Ee = Ce, ge = se, Ce = ae, se = ie, ae = oe, ie = sum64_hi(Ke, ht, wt, vt), oe = sum64_lo(Ke, ht, wt, vt);
  }
  sum64(this.h, 0, ie, oe), sum64(this.h, 2, se, ae), sum64(this.h, 4, ge, Ce), sum64(this.h, 6, le, Ee), sum64(this.h, 8, Je, Ve), sum64(this.h, 10, $t, Nt), sum64(this.h, 12, Dt, Wt), sum64(this.h, 14, Pt, Lt);
};
SHA512$1.prototype._digest = function(z) {
  return z === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
function ch64_hi(B, z, Y, ne, ie) {
  var oe = B & Y ^ ~B & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function ch64_lo(B, z, Y, ne, ie, oe) {
  var se = z & ne ^ ~z & oe;
  return se < 0 && (se += 4294967296), se;
}
function maj64_hi(B, z, Y, ne, ie) {
  var oe = B & Y ^ B & ie ^ Y & ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function maj64_lo(B, z, Y, ne, ie, oe) {
  var se = z & ne ^ z & oe ^ ne & oe;
  return se < 0 && (se += 4294967296), se;
}
function s0_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 28), ne = rotr64_hi(z, B, 2), ie = rotr64_hi(z, B, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s0_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 28), ne = rotr64_lo(z, B, 2), ie = rotr64_lo(z, B, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s1_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 14), ne = rotr64_hi(B, z, 18), ie = rotr64_hi(z, B, 9), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function s1_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 14), ne = rotr64_lo(B, z, 18), ie = rotr64_lo(z, B, 9), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g0_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 1), ne = rotr64_hi(B, z, 8), ie = shr64_hi(B, z, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g0_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 1), ne = rotr64_lo(B, z, 8), ie = shr64_lo(B, z, 7), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g1_512_hi(B, z) {
  var Y = rotr64_hi(B, z, 19), ne = rotr64_hi(z, B, 29), ie = shr64_hi(B, z, 6), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
function g1_512_lo(B, z) {
  var Y = rotr64_lo(B, z, 19), ne = rotr64_lo(z, B, 29), ie = shr64_lo(B, z, 6), oe = Y ^ ne ^ ie;
  return oe < 0 && (oe += 4294967296), oe;
}
var utils$9 = utils$g, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(z) {
  return z === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160$1() {
  if (!(this instanceof RIPEMD160$1))
    return new RIPEMD160$1();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$8.inherits(RIPEMD160$1, BlockHash);
ripemd.ripemd160 = RIPEMD160$1;
RIPEMD160$1.blockSize = 512;
RIPEMD160$1.outSize = 160;
RIPEMD160$1.hmacStrength = 192;
RIPEMD160$1.padLength = 64;
RIPEMD160$1.prototype._update = function(z, Y) {
  for (var ne = this.h[0], ie = this.h[1], oe = this.h[2], se = this.h[3], ae = this.h[4], ge = ne, Ce = ie, le = oe, Ee = se, Je = ae, Ve = 0; Ve < 80; Ve++) {
    var $t = sum32(
      rotl32(
        sum32_4(ne, f$1(Ve, ie, oe, se), z[r$1[Ve] + Y], K(Ve)),
        s$1[Ve]
      ),
      ae
    );
    ne = ae, ae = se, se = rotl32(oe, 10), oe = ie, ie = $t, $t = sum32(
      rotl32(
        sum32_4(ge, f$1(79 - Ve, Ce, le, Ee), z[rh[Ve] + Y], Kh(Ve)),
        sh[Ve]
      ),
      Je
    ), ge = Je, Je = Ee, Ee = rotl32(le, 10), le = Ce, Ce = $t;
  }
  $t = sum32_3(this.h[1], oe, Ee), this.h[1] = sum32_3(this.h[2], se, Je), this.h[2] = sum32_3(this.h[3], ae, ge), this.h[3] = sum32_3(this.h[4], ne, Ce), this.h[4] = sum32_3(this.h[0], ie, le), this.h[0] = $t;
};
RIPEMD160$1.prototype._digest = function(z) {
  return z === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
function f$1(B, z, Y, ne) {
  return B <= 15 ? z ^ Y ^ ne : B <= 31 ? z & Y | ~z & ne : B <= 47 ? (z | ~Y) ^ ne : B <= 63 ? z & ne | Y & ~ne : z ^ (Y | ~ne);
}
function K(B) {
  return B <= 15 ? 0 : B <= 31 ? 1518500249 : B <= 47 ? 1859775393 : B <= 63 ? 2400959708 : 2840853838;
}
function Kh(B) {
  return B <= 15 ? 1352829926 : B <= 31 ? 1548603684 : B <= 47 ? 1836072691 : B <= 63 ? 2053994217 : 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$7 = utils$g, assert$7 = minimalisticAssert;
function Hmac(B, z, Y) {
  if (!(this instanceof Hmac))
    return new Hmac(B, z, Y);
  this.Hash = B, this.blockSize = B.blockSize / 8, this.outSize = B.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(z, Y));
}
var hmac = Hmac;
Hmac.prototype._init = function(z) {
  z.length > this.blockSize && (z = new this.Hash().update(z).digest()), assert$7(z.length <= this.blockSize);
  for (var Y = z.length; Y < this.blockSize; Y++)
    z.push(0);
  for (Y = 0; Y < z.length; Y++)
    z[Y] ^= 54;
  for (this.inner = new this.Hash().update(z), Y = 0; Y < z.length; Y++)
    z[Y] ^= 106;
  this.outer = new this.Hash().update(z);
};
Hmac.prototype.update = function(z, Y) {
  return this.inner.update(z, Y), this;
};
Hmac.prototype.digest = function(z) {
  return this.outer.update(this.inner.digest()), this.outer.digest(z);
};
(function(B) {
  var z = B;
  z.utils = utils$g, z.common = common$5, z.sha = sha, z.ripemd = ripemd, z.hmac = hmac, z.sha1 = z.sha.sha1, z.sha256 = z.sha.sha256, z.sha224 = z.sha.sha224, z.sha384 = z.sha.sha384, z.sha512 = z.sha.sha512, z.ripemd160 = z.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(B) {
  var z = B, Y = hash$2, ne = curve, ie = utils$m, oe = ie.assert;
  function se(Ce) {
    Ce.type === "short" ? this.curve = new ne.short(Ce) : Ce.type === "edwards" ? this.curve = new ne.edwards(Ce) : this.curve = new ne.mont(Ce), this.g = this.curve.g, this.n = this.curve.n, this.hash = Ce.hash, oe(this.g.validate(), "Invalid curve"), oe(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  z.PresetCurve = se;
  function ae(Ce, le) {
    Object.defineProperty(z, Ce, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Ee = new se(le);
        return Object.defineProperty(z, Ce, {
          configurable: !0,
          enumerable: !0,
          value: Ee
        }), Ee;
      }
    });
  }
  ae("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), ae("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), ae("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), ae("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Y.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), ae("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Y.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), ae("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), ae("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Y.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var ge;
  try {
    ge = requireSecp256k1();
  } catch {
    ge = void 0;
  }
  ae("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Y.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      ge
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$6 = utils$l, assert$6 = minimalisticAssert;
function HmacDRBG(B) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(B);
  this.hash = B.hash, this.predResist = !!B.predResist, this.outLen = this.hash.outSize, this.minEntropy = B.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var z = utils$6.toArray(B.entropy, B.entropyEnc || "hex"), Y = utils$6.toArray(B.nonce, B.nonceEnc || "hex"), ne = utils$6.toArray(B.pers, B.persEnc || "hex");
  assert$6(
    z.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(z, Y, ne);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(z, Y, ne) {
  var ie = z.concat(Y).concat(ne);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var oe = 0; oe < this.V.length; oe++)
    this.K[oe] = 0, this.V[oe] = 1;
  this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(z) {
  var Y = this._hmac().update(this.V).update([0]);
  z && (Y = Y.update(z)), this.K = Y.digest(), this.V = this._hmac().update(this.V).digest(), z && (this.K = this._hmac().update(this.V).update([1]).update(z).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(z, Y, ne, ie) {
  typeof Y != "string" && (ie = ne, ne = Y, Y = null), z = utils$6.toArray(z, Y), ne = utils$6.toArray(ne, ie), assert$6(
    z.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(z.concat(ne || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(z, Y, ne, ie) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof Y != "string" && (ie = ne, ne = Y, Y = null), ne && (ne = utils$6.toArray(ne, ie || "hex"), this._update(ne));
  for (var oe = []; oe.length < z; )
    this.V = this._hmac().update(this.V).digest(), oe = oe.concat(this.V);
  var se = oe.slice(0, z);
  return this._update(ne), this._reseed++, utils$6.encode(se, Y);
};
var BN$5 = bnExports$1, utils$5 = utils$m, assert$5 = utils$5.assert;
function KeyPair$2(B, z) {
  this.ec = B, this.priv = null, this.pub = null, z.priv && this._importPrivate(z.priv, z.privEnc), z.pub && this._importPublic(z.pub, z.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(z, Y, ne) {
  return Y instanceof KeyPair$2 ? Y : new KeyPair$2(z, {
    pub: Y,
    pubEnc: ne
  });
};
KeyPair$2.fromPrivate = function(z, Y, ne) {
  return Y instanceof KeyPair$2 ? Y : new KeyPair$2(z, {
    priv: Y,
    privEnc: ne
  });
};
KeyPair$2.prototype.validate = function() {
  var z = this.getPublic();
  return z.isInfinity() ? { result: !1, reason: "Invalid public key" } : z.validate() ? z.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(z, Y) {
  return typeof z == "string" && (Y = z, z = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), Y ? this.pub.encode(Y, z) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(z) {
  return z === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(z, Y) {
  this.priv = new BN$5(z, Y || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(z, Y) {
  if (z.x || z.y) {
    this.ec.curve.type === "mont" ? assert$5(z.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(z.x && z.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(z.x, z.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(z, Y);
};
KeyPair$2.prototype.derive = function(z) {
  return z.validate() || assert$5(z.validate(), "public point not validated"), z.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(z, Y, ne) {
  return this.ec.sign(z, this, Y, ne);
};
KeyPair$2.prototype.verify = function(z, Y, ne) {
  return this.ec.verify(z, Y, this, void 0, ne);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$1, utils$4 = utils$m, assert$4 = utils$4.assert;
function Signature$2(B, z) {
  if (B instanceof Signature$2)
    return B;
  this._importDER(B, z) || (assert$4(B.r && B.s, "Signature without r or s"), this.r = new BN$4(B.r, 16), this.s = new BN$4(B.s, 16), B.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = B.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(B, z) {
  var Y = B[z.place++];
  if (!(Y & 128))
    return Y;
  var ne = Y & 15;
  if (ne === 0 || ne > 4 || B[z.place] === 0)
    return !1;
  for (var ie = 0, oe = 0, se = z.place; oe < ne; oe++, se++)
    ie <<= 8, ie |= B[se], ie >>>= 0;
  return ie <= 127 ? !1 : (z.place = se, ie);
}
function rmPadding(B) {
  for (var z = 0, Y = B.length - 1; !B[z] && !(B[z + 1] & 128) && z < Y; )
    z++;
  return z === 0 ? B : B.slice(z);
}
Signature$2.prototype._importDER = function(z, Y) {
  z = utils$4.toArray(z, Y);
  var ne = new Position();
  if (z[ne.place++] !== 48)
    return !1;
  var ie = getLength(z, ne);
  if (ie === !1 || ie + ne.place !== z.length || z[ne.place++] !== 2)
    return !1;
  var oe = getLength(z, ne);
  if (oe === !1 || z[ne.place] & 128)
    return !1;
  var se = z.slice(ne.place, oe + ne.place);
  if (ne.place += oe, z[ne.place++] !== 2)
    return !1;
  var ae = getLength(z, ne);
  if (ae === !1 || z.length !== ae + ne.place || z[ne.place] & 128)
    return !1;
  var ge = z.slice(ne.place, ae + ne.place);
  if (se[0] === 0)
    if (se[1] & 128)
      se = se.slice(1);
    else
      return !1;
  if (ge[0] === 0)
    if (ge[1] & 128)
      ge = ge.slice(1);
    else
      return !1;
  return this.r = new BN$4(se), this.s = new BN$4(ge), this.recoveryParam = null, !0;
};
function constructLength(B, z) {
  if (z < 128) {
    B.push(z);
    return;
  }
  var Y = 1 + (Math.log(z) / Math.LN2 >>> 3);
  for (B.push(Y | 128); --Y; )
    B.push(z >>> (Y << 3) & 255);
  B.push(z);
}
Signature$2.prototype.toDER = function(z) {
  var Y = this.r.toArray(), ne = this.s.toArray();
  for (Y[0] & 128 && (Y = [0].concat(Y)), ne[0] & 128 && (ne = [0].concat(ne)), Y = rmPadding(Y), ne = rmPadding(ne); !ne[0] && !(ne[1] & 128); )
    ne = ne.slice(1);
  var ie = [2];
  constructLength(ie, Y.length), ie = ie.concat(Y), ie.push(2), constructLength(ie, ne.length);
  var oe = ie.concat(ne), se = [48];
  return constructLength(se, oe.length), se = se.concat(oe), utils$4.encode(se, z);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = bnExports$1, z = hmacDrbg, Y = utils$m, ne = curves$1, ie = requireBrorand(), oe = Y.assert, se = key$1, ae = signature$1;
  function ge(Ce) {
    if (!(this instanceof ge))
      return new ge(Ce);
    typeof Ce == "string" && (oe(
      Object.prototype.hasOwnProperty.call(ne, Ce),
      "Unknown curve " + Ce
    ), Ce = ne[Ce]), Ce instanceof ne.PresetCurve && (Ce = { curve: Ce }), this.curve = Ce.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Ce.curve.g, this.g.precompute(Ce.curve.n.bitLength() + 1), this.hash = Ce.hash || Ce.curve.hash;
  }
  return ec = ge, ge.prototype.keyPair = function(le) {
    return new se(this, le);
  }, ge.prototype.keyFromPrivate = function(le, Ee) {
    return se.fromPrivate(this, le, Ee);
  }, ge.prototype.keyFromPublic = function(le, Ee) {
    return se.fromPublic(this, le, Ee);
  }, ge.prototype.genKeyPair = function(le) {
    le || (le = {});
    for (var Ee = new z({
      hash: this.hash,
      pers: le.pers,
      persEnc: le.persEnc || "utf8",
      entropy: le.entropy || ie(this.hash.hmacStrength),
      entropyEnc: le.entropy && le.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Je = this.n.byteLength(), Ve = this.n.sub(new B(2)); ; ) {
      var $t = new B(Ee.generate(Je));
      if (!($t.cmp(Ve) > 0))
        return $t.iaddn(1), this.keyFromPrivate($t);
    }
  }, ge.prototype._truncateToN = function(le, Ee, Je) {
    var Ve;
    if (B.isBN(le) || typeof le == "number")
      le = new B(le, 16), Ve = le.byteLength();
    else if (typeof le == "object")
      Ve = le.length, le = new B(le, 16);
    else {
      var $t = le.toString();
      Ve = $t.length + 1 >>> 1, le = new B($t, 16);
    }
    typeof Je != "number" && (Je = Ve * 8);
    var Nt = Je - this.n.bitLength();
    return Nt > 0 && (le = le.ushrn(Nt)), !Ee && le.cmp(this.n) >= 0 ? le.sub(this.n) : le;
  }, ge.prototype.sign = function(le, Ee, Je, Ve) {
    if (typeof Je == "object" && (Ve = Je, Je = null), Ve || (Ve = {}), typeof le != "string" && typeof le != "number" && !B.isBN(le)) {
      oe(
        typeof le == "object" && le && typeof le.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), oe(le.length >>> 0 === le.length);
      for (var $t = 0; $t < le.length; $t++) oe((le[$t] & 255) === le[$t]);
    }
    Ee = this.keyFromPrivate(Ee, Je), le = this._truncateToN(le, !1, Ve.msgBitLength), oe(!le.isNeg(), "Can not sign a negative message");
    var Nt = this.n.byteLength(), Dt = Ee.getPrivate().toArray("be", Nt), Wt = le.toArray("be", Nt);
    oe(new B(Wt).eq(le), "Can not sign message");
    for (var Pt = new z({
      hash: this.hash,
      entropy: Dt,
      nonce: Wt,
      pers: Ve.pers,
      persEnc: Ve.persEnc || "utf8"
    }), Lt = this.n.sub(new B(1)), qt = 0; ; qt++) {
      var Zt = Ve.k ? Ve.k(qt) : new B(Pt.generate(this.n.byteLength()));
      if (Zt = this._truncateToN(Zt, !0), !(Zt.cmpn(1) <= 0 || Zt.cmp(Lt) >= 0)) {
        var Yt = this.g.mul(Zt);
        if (!Yt.isInfinity()) {
          var or = Yt.getX(), jt = or.umod(this.n);
          if (jt.cmpn(0) !== 0) {
            var Ct = Zt.invm(this.n).mul(jt.mul(Ee.getPrivate()).iadd(le));
            if (Ct = Ct.umod(this.n), Ct.cmpn(0) !== 0) {
              var Vt = (Yt.getY().isOdd() ? 1 : 0) | (or.cmp(jt) !== 0 ? 2 : 0);
              return Ve.canonical && Ct.cmp(this.nh) > 0 && (Ct = this.n.sub(Ct), Vt ^= 1), new ae({ r: jt, s: Ct, recoveryParam: Vt });
            }
          }
        }
      }
    }
  }, ge.prototype.verify = function(le, Ee, Je, Ve, $t) {
    $t || ($t = {}), le = this._truncateToN(le, !1, $t.msgBitLength), Je = this.keyFromPublic(Je, Ve), Ee = new ae(Ee, "hex");
    var Nt = Ee.r, Dt = Ee.s;
    if (Nt.cmpn(1) < 0 || Nt.cmp(this.n) >= 0 || Dt.cmpn(1) < 0 || Dt.cmp(this.n) >= 0)
      return !1;
    var Wt = Dt.invm(this.n), Pt = Wt.mul(le).umod(this.n), Lt = Wt.mul(Nt).umod(this.n), qt;
    return this.curve._maxwellTrick ? (qt = this.g.jmulAdd(Pt, Je.getPublic(), Lt), qt.isInfinity() ? !1 : qt.eqXToP(Nt)) : (qt = this.g.mulAdd(Pt, Je.getPublic(), Lt), qt.isInfinity() ? !1 : qt.getX().umod(this.n).cmp(Nt) === 0);
  }, ge.prototype.recoverPubKey = function(Ce, le, Ee, Je) {
    oe((3 & Ee) === Ee, "The recovery param is more than two bits"), le = new ae(le, Je);
    var Ve = this.n, $t = new B(Ce), Nt = le.r, Dt = le.s, Wt = Ee & 1, Pt = Ee >> 1;
    if (Nt.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Pt)
      throw new Error("Unable to find sencond key candinate");
    Pt ? Nt = this.curve.pointFromX(Nt.add(this.curve.n), Wt) : Nt = this.curve.pointFromX(Nt, Wt);
    var Lt = le.r.invm(Ve), qt = Ve.sub($t).mul(Lt).umod(Ve), Zt = Dt.mul(Lt).umod(Ve);
    return this.g.mulAdd(qt, Nt, Zt);
  }, ge.prototype.getKeyRecoveryParam = function(Ce, le, Ee, Je) {
    if (le = new ae(le, Je), le.recoveryParam !== null)
      return le.recoveryParam;
    for (var Ve = 0; Ve < 4; Ve++) {
      var $t;
      try {
        $t = this.recoverPubKey(Ce, le, Ve);
      } catch {
        continue;
      }
      if ($t.eq(Ee))
        return Ve;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$3 = utils$m, assert$3 = utils$3.assert, parseBytes$2 = utils$3.parseBytes, cachedProperty$1 = utils$3.cachedProperty;
function KeyPair$1(B, z) {
  this.eddsa = B, this._secret = parseBytes$2(z.secret), B.isPoint(z.pub) ? this._pub = z.pub : this._pubBytes = parseBytes$2(z.pub);
}
KeyPair$1.fromPublic = function(z, Y) {
  return Y instanceof KeyPair$1 ? Y : new KeyPair$1(z, { pub: Y });
};
KeyPair$1.fromSecret = function(z, Y) {
  return Y instanceof KeyPair$1 ? Y : new KeyPair$1(z, { secret: Y });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var z = this.eddsa, Y = this.hash(), ne = z.encodingLength - 1, ie = Y.slice(0, z.encodingLength);
  return ie[0] &= 248, ie[ne] &= 127, ie[ne] |= 64, ie;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(z) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(z, this);
};
KeyPair$1.prototype.verify = function(z, Y) {
  return this.eddsa.verify(z, Y, this);
};
KeyPair$1.prototype.getSecret = function(z) {
  return assert$3(this._secret, "KeyPair is public only"), utils$3.encode(this.secret(), z);
};
KeyPair$1.prototype.getPublic = function(z) {
  return utils$3.encode(this.pubBytes(), z);
};
var key = KeyPair$1, BN$3 = bnExports$1, utils$2 = utils$m, assert$2 = utils$2.assert, cachedProperty = utils$2.cachedProperty, parseBytes$1 = utils$2.parseBytes;
function Signature$1(B, z) {
  this.eddsa = B, typeof z != "object" && (z = parseBytes$1(z)), Array.isArray(z) && (assert$2(z.length === B.encodingLength * 2, "Signature has invalid size"), z = {
    R: z.slice(0, B.encodingLength),
    S: z.slice(B.encodingLength)
  }), assert$2(z.R && z.S, "Signature without R or S"), B.isPoint(z.R) && (this._R = z.R), z.S instanceof BN$3 && (this._S = z.S), this._Rencoded = Array.isArray(z.R) ? z.R : z.Rencoded, this._Sencoded = Array.isArray(z.S) ? z.S : z.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$2.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$1 = utils$m, assert$1 = utils$1.assert, parseBytes = utils$1.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(B) {
  if (assert$1(B === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(B);
  B = curves[B].curve, this.curve = B, this.g = B.g, this.g.precompute(B.n.bitLength() + 1), this.pointClass = B.point().constructor, this.encodingLength = Math.ceil(B.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(z, Y) {
  z = parseBytes(z);
  var ne = this.keyFromSecret(Y), ie = this.hashInt(ne.messagePrefix(), z), oe = this.g.mul(ie), se = this.encodePoint(oe), ae = this.hashInt(se, ne.pubBytes(), z).mul(ne.priv()), ge = ie.add(ae).umod(this.curve.n);
  return this.makeSignature({ R: oe, S: ge, Rencoded: se });
};
EDDSA.prototype.verify = function(z, Y, ne) {
  if (z = parseBytes(z), Y = this.makeSignature(Y), Y.S().gte(Y.eddsa.curve.n) || Y.S().isNeg())
    return !1;
  var ie = this.keyFromPublic(ne), oe = this.hashInt(Y.Rencoded(), ie.pubBytes(), z), se = this.g.mul(Y.S()), ae = Y.R().add(ie.pub().mul(oe));
  return ae.eq(se);
};
EDDSA.prototype.hashInt = function() {
  for (var z = this.hash(), Y = 0; Y < arguments.length; Y++)
    z.update(arguments[Y]);
  return utils$1.intFromLE(z.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(z) {
  return KeyPair.fromPublic(this, z);
};
EDDSA.prototype.keyFromSecret = function(z) {
  return KeyPair.fromSecret(this, z);
};
EDDSA.prototype.makeSignature = function(z) {
  return z instanceof Signature ? z : new Signature(this, z);
};
EDDSA.prototype.encodePoint = function(z) {
  var Y = z.getY().toArray("le", this.encodingLength);
  return Y[this.encodingLength - 1] |= z.getX().isOdd() ? 128 : 0, Y;
};
EDDSA.prototype.decodePoint = function(z) {
  z = utils$1.parseBytes(z);
  var Y = z.length - 1, ne = z.slice(0, Y).concat(z[Y] & -129), ie = (z[Y] & 128) !== 0, oe = utils$1.intFromLE(ne);
  return this.curve.pointFromY(oe, ie);
};
EDDSA.prototype.encodeInt = function(z) {
  return z.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(z) {
  return utils$1.intFromLE(z);
};
EDDSA.prototype.isPoint = function(z) {
  return z instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var z = B;
    z.version = require$$0.version, z.utils = utils$m, z.rand = requireBrorand(), z.curve = curve, z.curves = curves$1, z.ec = requireEc(), z.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, z) {
      if (B.indexOf) return B.indexOf(z);
      for (var Y = 0; Y < B.length; Y++)
        if (B[Y] === z) return Y;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var z = [];
      for (var Y in B) z.push(Y);
      return z;
    }, forEach = function(B, z) {
      if (B.forEach) return B.forEach(z);
      for (var Y = 0; Y < B.length; Y++)
        z(B[Y], Y, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, z, Y) {
          Object.defineProperty(B, z, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Y
          });
        };
      } catch {
        return function(z, Y, ne) {
          z[Y] = ne;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(z) {
      if (!(this instanceof Script)) return new Script(z);
      this.code = z;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var z = document.createElement("iframe");
      z.style || (z.style = {}), z.style.display = "none", document.body.appendChild(z);
      var Y = z.contentWindow, ne = Y.eval, ie = Y.execScript;
      !ne && ie && (ie.call(Y, "null"), ne = Y.eval), forEach(Object_keys(B), function(ae) {
        Y[ae] = B[ae];
      }), forEach(globals, function(ae) {
        B[ae] && (Y[ae] = B[ae]);
      });
      var oe = Object_keys(Y), se = ne.call(Y, this.code);
      return forEach(Object_keys(Y), function(ae) {
        (ae in B || indexOf(oe, ae) === -1) && (B[ae] = Y[ae]);
      }), forEach(globals, function(ae) {
        ae in B || defineProp(B, ae, Y[ae]);
      }), document.body.removeChild(z), se;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var z = Script.createContext(B), Y = this.runInContext(z);
      return B && forEach(Object_keys(z), function(ne) {
        B[ne] = z[ne];
      }), Y;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(z) {
        var Y = Script(z);
        return Y[B].apply(Y, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var z = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(Y) {
        z[Y] = B[Y];
      }), z;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var z = requireAsn1(), Y = inherits_browserExports, ne = B;
    ne.define = function(se, ae) {
      return new ie(se, ae);
    };
    function ie(oe, se) {
      this.name = oe, this.body = se, this.decoders = {}, this.encoders = {};
    }
    ie.prototype._createNamed = function(se) {
      var ae;
      try {
        ae = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ae = function(Ce) {
          this._initNamed(Ce);
        };
      }
      return Y(ae, se), ae.prototype._initNamed = function(Ce) {
        se.call(this, Ce);
      }, new ae(this);
    }, ie.prototype._getDecoder = function(se) {
      return se = se || "der", this.decoders.hasOwnProperty(se) || (this.decoders[se] = this._createNamed(z.decoders[se])), this.decoders[se];
    }, ie.prototype.decode = function(se, ae, ge) {
      return this._getDecoder(ae).decode(se, ge);
    }, ie.prototype._getEncoder = function(se) {
      return se = se || "der", this.encoders.hasOwnProperty(se) || (this.encoders[se] = this._createNamed(z.encoders[se])), this.encoders[se];
    }, ie.prototype.encode = function(se, ae, ge) {
      return this._getEncoder(ae).encode(se, ge);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(B) {
  this._reporterState = {
    obj: null,
    path: [],
    options: B || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function B(z) {
  return z instanceof ReporterError;
};
Reporter.prototype.save = function B() {
  var z = this._reporterState;
  return { obj: z.obj, pathLen: z.path.length };
};
Reporter.prototype.restore = function B(z) {
  var Y = this._reporterState;
  Y.obj = z.obj, Y.path = Y.path.slice(0, z.pathLen);
};
Reporter.prototype.enterKey = function B(z) {
  return this._reporterState.path.push(z);
};
Reporter.prototype.exitKey = function B(z) {
  var Y = this._reporterState;
  Y.path = Y.path.slice(0, z - 1);
};
Reporter.prototype.leaveKey = function B(z, Y, ne) {
  var ie = this._reporterState;
  this.exitKey(z), ie.obj !== null && (ie.obj[Y] = ne);
};
Reporter.prototype.path = function B() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function B() {
  var z = this._reporterState, Y = z.obj;
  return z.obj = {}, Y;
};
Reporter.prototype.leaveObject = function B(z) {
  var Y = this._reporterState, ne = Y.obj;
  return Y.obj = z, ne;
};
Reporter.prototype.error = function B(z) {
  var Y, ne = this._reporterState, ie = z instanceof ReporterError;
  if (ie ? Y = z : Y = new ReporterError(ne.path.map(function(oe) {
    return "[" + JSON.stringify(oe) + "]";
  }).join(""), z.message || z, z.stack), !ne.options.partial)
    throw Y;
  return ie || ne.errors.push(Y), Y;
};
Reporter.prototype.wrapResult = function B(z) {
  var Y = this._reporterState;
  return Y.options.partial ? {
    result: this.isError(z) ? null : z,
    errors: Y.errors
  } : z;
};
function ReporterError(B, z) {
  this.path = B, this.rethrow(z);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function B(z) {
  if (this.message = z + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (Y) {
      this.stack = Y.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = inherits_browserExports, z = requireBase().Reporter, Y = dist$1.Buffer;
  function ne(oe, se) {
    if (z.call(this, se), !Y.isBuffer(oe)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = oe, this.offset = 0, this.length = oe.length;
  }
  B(ne, z), buffer.DecoderBuffer = ne, ne.prototype.save = function() {
    return { offset: this.offset, reporter: z.prototype.save.call(this) };
  }, ne.prototype.restore = function(se) {
    var ae = new ne(this.base);
    return ae.offset = se.offset, ae.length = this.offset, this.offset = se.offset, z.prototype.restore.call(this, se.reporter), ae;
  }, ne.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, ne.prototype.readUInt8 = function(se) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(se || "DecoderBuffer overrun");
  }, ne.prototype.skip = function(se, ae) {
    if (!(this.offset + se <= this.length))
      return this.error(ae || "DecoderBuffer overrun");
    var ge = new ne(this.base);
    return ge._reporterState = this._reporterState, ge.offset = this.offset, ge.length = this.offset + se, this.offset += se, ge;
  }, ne.prototype.raw = function(se) {
    return this.base.slice(se ? se.offset : this.offset, this.length);
  };
  function ie(oe, se) {
    if (Array.isArray(oe))
      this.length = 0, this.value = oe.map(function(ae) {
        return ae instanceof ie || (ae = new ie(ae, se)), this.length += ae.length, ae;
      }, this);
    else if (typeof oe == "number") {
      if (!(0 <= oe && oe <= 255))
        return se.error("non-byte EncoderBuffer value");
      this.value = oe, this.length = 1;
    } else if (typeof oe == "string")
      this.value = oe, this.length = Y.byteLength(oe);
    else if (Y.isBuffer(oe))
      this.value = oe, this.length = oe.length;
    else
      return se.error("Unsupported type: " + typeof oe);
  }
  return buffer.EncoderBuffer = ie, ie.prototype.join = function(se, ae) {
    return se || (se = new Y(this.length)), ae || (ae = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ge) {
      ge.join(se, ae), ae += ge.length;
    }) : (typeof this.value == "number" ? se[ae] = this.value : typeof this.value == "string" ? se.write(this.value, ae) : Y.isBuffer(this.value) && this.value.copy(se, ae), ae += this.length)), se;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, z = requireBase().EncoderBuffer, Y = requireBase().DecoderBuffer, ne = minimalisticAssert, ie = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], oe = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(ie), se = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ae(Ce, le) {
    var Ee = {};
    this._baseState = Ee, Ee.enc = Ce, Ee.parent = le || null, Ee.children = null, Ee.tag = null, Ee.args = null, Ee.reverseArgs = null, Ee.choice = null, Ee.optional = !1, Ee.any = !1, Ee.obj = !1, Ee.use = null, Ee.useDecoder = null, Ee.key = null, Ee.default = null, Ee.explicit = null, Ee.implicit = null, Ee.contains = null, Ee.parent || (Ee.children = [], this._wrap());
  }
  node = ae;
  var ge = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ae.prototype.clone = function() {
    var le = this._baseState, Ee = {};
    ge.forEach(function(Ve) {
      Ee[Ve] = le[Ve];
    });
    var Je = new this.constructor(Ee.parent);
    return Je._baseState = Ee, Je;
  }, ae.prototype._wrap = function() {
    var le = this._baseState;
    oe.forEach(function(Ee) {
      this[Ee] = function() {
        var Ve = new this.constructor(this);
        return le.children.push(Ve), Ve[Ee].apply(Ve, arguments);
      };
    }, this);
  }, ae.prototype._init = function(le) {
    var Ee = this._baseState;
    ne(Ee.parent === null), le.call(this), Ee.children = Ee.children.filter(function(Je) {
      return Je._baseState.parent === this;
    }, this), ne.equal(Ee.children.length, 1, "Root node can have only one child");
  }, ae.prototype._useArgs = function(le) {
    var Ee = this._baseState, Je = le.filter(function(Ve) {
      return Ve instanceof this.constructor;
    }, this);
    le = le.filter(function(Ve) {
      return !(Ve instanceof this.constructor);
    }, this), Je.length !== 0 && (ne(Ee.children === null), Ee.children = Je, Je.forEach(function(Ve) {
      Ve._baseState.parent = this;
    }, this)), le.length !== 0 && (ne(Ee.args === null), Ee.args = le, Ee.reverseArgs = le.map(function(Ve) {
      if (typeof Ve != "object" || Ve.constructor !== Object)
        return Ve;
      var $t = {};
      return Object.keys(Ve).forEach(function(Nt) {
        Nt == (Nt | 0) && (Nt |= 0);
        var Dt = Ve[Nt];
        $t[Dt] = Nt;
      }), $t;
    }));
  }, se.forEach(function(Ce) {
    ae.prototype[Ce] = function() {
      var Ee = this._baseState;
      throw new Error(Ce + " not implemented for encoding: " + Ee.enc);
    };
  }), ie.forEach(function(Ce) {
    ae.prototype[Ce] = function() {
      var Ee = this._baseState, Je = Array.prototype.slice.call(arguments);
      return ne(Ee.tag === null), Ee.tag = Ce, this._useArgs(Je), this;
    };
  }), ae.prototype.use = function(le) {
    ne(le);
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.use = le, this;
  }, ae.prototype.optional = function() {
    var le = this._baseState;
    return le.optional = !0, this;
  }, ae.prototype.def = function(le) {
    var Ee = this._baseState;
    return ne(Ee.default === null), Ee.default = le, Ee.optional = !0, this;
  }, ae.prototype.explicit = function(le) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.explicit = le, this;
  }, ae.prototype.implicit = function(le) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.implicit = le, this;
  }, ae.prototype.obj = function() {
    var le = this._baseState, Ee = Array.prototype.slice.call(arguments);
    return le.obj = !0, Ee.length !== 0 && this._useArgs(Ee), this;
  }, ae.prototype.key = function(le) {
    var Ee = this._baseState;
    return ne(Ee.key === null), Ee.key = le, this;
  }, ae.prototype.any = function() {
    var le = this._baseState;
    return le.any = !0, this;
  }, ae.prototype.choice = function(le) {
    var Ee = this._baseState;
    return ne(Ee.choice === null), Ee.choice = le, this._useArgs(Object.keys(le).map(function(Je) {
      return le[Je];
    })), this;
  }, ae.prototype.contains = function(le) {
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.contains = le, this;
  }, ae.prototype._decode = function(le, Ee) {
    var Je = this._baseState;
    if (Je.parent === null)
      return le.wrapResult(Je.children[0]._decode(le, Ee));
    var Ve = Je.default, $t = !0, Nt = null;
    if (Je.key !== null && (Nt = le.enterKey(Je.key)), Je.optional) {
      var Dt = null;
      if (Je.explicit !== null ? Dt = Je.explicit : Je.implicit !== null ? Dt = Je.implicit : Je.tag !== null && (Dt = Je.tag), Dt === null && !Je.any) {
        var Wt = le.save();
        try {
          Je.choice === null ? this._decodeGeneric(Je.tag, le, Ee) : this._decodeChoice(le, Ee), $t = !0;
        } catch {
          $t = !1;
        }
        le.restore(Wt);
      } else if ($t = this._peekTag(le, Dt, Je.any), le.isError($t))
        return $t;
    }
    var Pt;
    if (Je.obj && $t && (Pt = le.enterObject()), $t) {
      if (Je.explicit !== null) {
        var Lt = this._decodeTag(le, Je.explicit);
        if (le.isError(Lt))
          return Lt;
        le = Lt;
      }
      var qt = le.offset;
      if (Je.use === null && Je.choice === null) {
        if (Je.any)
          var Wt = le.save();
        var Zt = this._decodeTag(
          le,
          Je.implicit !== null ? Je.implicit : Je.tag,
          Je.any
        );
        if (le.isError(Zt))
          return Zt;
        Je.any ? Ve = le.raw(Wt) : le = Zt;
      }
      if (Ee && Ee.track && Je.tag !== null && Ee.track(le.path(), qt, le.length, "tagged"), Ee && Ee.track && Je.tag !== null && Ee.track(le.path(), le.offset, le.length, "content"), Je.any ? Ve = Ve : Je.choice === null ? Ve = this._decodeGeneric(Je.tag, le, Ee) : Ve = this._decodeChoice(le, Ee), le.isError(Ve))
        return Ve;
      if (!Je.any && Je.choice === null && Je.children !== null && Je.children.forEach(function(jt) {
        jt._decode(le, Ee);
      }), Je.contains && (Je.tag === "octstr" || Je.tag === "bitstr")) {
        var Yt = new Y(Ve);
        Ve = this._getUse(Je.contains, le._reporterState.obj)._decode(Yt, Ee);
      }
    }
    return Je.obj && $t && (Ve = le.leaveObject(Pt)), Je.key !== null && (Ve !== null || $t === !0) ? le.leaveKey(Nt, Je.key, Ve) : Nt !== null && le.exitKey(Nt), Ve;
  }, ae.prototype._decodeGeneric = function(le, Ee, Je) {
    var Ve = this._baseState;
    return le === "seq" || le === "set" ? null : le === "seqof" || le === "setof" ? this._decodeList(Ee, le, Ve.args[0], Je) : /str$/.test(le) ? this._decodeStr(Ee, le, Je) : le === "objid" && Ve.args ? this._decodeObjid(Ee, Ve.args[0], Ve.args[1], Je) : le === "objid" ? this._decodeObjid(Ee, null, null, Je) : le === "gentime" || le === "utctime" ? this._decodeTime(Ee, le, Je) : le === "null_" ? this._decodeNull(Ee, Je) : le === "bool" ? this._decodeBool(Ee, Je) : le === "objDesc" ? this._decodeStr(Ee, le, Je) : le === "int" || le === "enum" ? this._decodeInt(Ee, Ve.args && Ve.args[0], Je) : Ve.use !== null ? this._getUse(Ve.use, Ee._reporterState.obj)._decode(Ee, Je) : Ee.error("unknown tag: " + le);
  }, ae.prototype._getUse = function(le, Ee) {
    var Je = this._baseState;
    return Je.useDecoder = this._use(le, Ee), ne(Je.useDecoder._baseState.parent === null), Je.useDecoder = Je.useDecoder._baseState.children[0], Je.implicit !== Je.useDecoder._baseState.implicit && (Je.useDecoder = Je.useDecoder.clone(), Je.useDecoder._baseState.implicit = Je.implicit), Je.useDecoder;
  }, ae.prototype._decodeChoice = function(le, Ee) {
    var Je = this._baseState, Ve = null, $t = !1;
    return Object.keys(Je.choice).some(function(Nt) {
      var Dt = le.save(), Wt = Je.choice[Nt];
      try {
        var Pt = Wt._decode(le, Ee);
        if (le.isError(Pt))
          return !1;
        Ve = { type: Nt, value: Pt }, $t = !0;
      } catch {
        return le.restore(Dt), !1;
      }
      return !0;
    }, this), $t ? Ve : le.error("Choice not matched");
  }, ae.prototype._createEncoderBuffer = function(le) {
    return new z(le, this.reporter);
  }, ae.prototype._encode = function(le, Ee, Je) {
    var Ve = this._baseState;
    if (!(Ve.default !== null && Ve.default === le)) {
      var $t = this._encodeValue(le, Ee, Je);
      if ($t !== void 0 && !this._skipDefault($t, Ee, Je))
        return $t;
    }
  }, ae.prototype._encodeValue = function(le, Ee, Je) {
    var Ve = this._baseState;
    if (Ve.parent === null)
      return Ve.children[0]._encode(le, Ee || new B());
    var Wt = null;
    if (this.reporter = Ee, Ve.optional && le === void 0)
      if (Ve.default !== null)
        le = Ve.default;
      else
        return;
    var $t = null, Nt = !1;
    if (Ve.any)
      Wt = this._createEncoderBuffer(le);
    else if (Ve.choice)
      Wt = this._encodeChoice(le, Ee);
    else if (Ve.contains)
      $t = this._getUse(Ve.contains, Je)._encode(le, Ee), Nt = !0;
    else if (Ve.children)
      $t = Ve.children.map(function(qt) {
        if (qt._baseState.tag === "null_")
          return qt._encode(null, Ee, le);
        if (qt._baseState.key === null)
          return Ee.error("Child should have a key");
        var Zt = Ee.enterKey(qt._baseState.key);
        if (typeof le != "object")
          return Ee.error("Child expected, but input is not object");
        var Yt = qt._encode(le[qt._baseState.key], Ee, le);
        return Ee.leaveKey(Zt), Yt;
      }, this).filter(function(qt) {
        return qt;
      }), $t = this._createEncoderBuffer($t);
    else if (Ve.tag === "seqof" || Ve.tag === "setof") {
      if (!(Ve.args && Ve.args.length === 1))
        return Ee.error("Too many args for : " + Ve.tag);
      if (!Array.isArray(le))
        return Ee.error("seqof/setof, but data is not Array");
      var Dt = this.clone();
      Dt._baseState.implicit = null, $t = this._createEncoderBuffer(le.map(function(qt) {
        var Zt = this._baseState;
        return this._getUse(Zt.args[0], le)._encode(qt, Ee);
      }, Dt));
    } else Ve.use !== null ? Wt = this._getUse(Ve.use, Je)._encode(le, Ee) : ($t = this._encodePrimitive(Ve.tag, le), Nt = !0);
    var Wt;
    if (!Ve.any && Ve.choice === null) {
      var Pt = Ve.implicit !== null ? Ve.implicit : Ve.tag, Lt = Ve.implicit === null ? "universal" : "context";
      Pt === null ? Ve.use === null && Ee.error("Tag could be omitted only for .use()") : Ve.use === null && (Wt = this._encodeComposite(Pt, Nt, Lt, $t));
    }
    return Ve.explicit !== null && (Wt = this._encodeComposite(Ve.explicit, !1, "context", Wt)), Wt;
  }, ae.prototype._encodeChoice = function(le, Ee) {
    var Je = this._baseState, Ve = Je.choice[le.type];
    return Ve || ne(
      !1,
      le.type + " not found in " + JSON.stringify(Object.keys(Je.choice))
    ), Ve._encode(le.value, Ee);
  }, ae.prototype._encodePrimitive = function(le, Ee) {
    var Je = this._baseState;
    if (/str$/.test(le))
      return this._encodeStr(Ee, le);
    if (le === "objid" && Je.args)
      return this._encodeObjid(Ee, Je.reverseArgs[0], Je.args[1]);
    if (le === "objid")
      return this._encodeObjid(Ee, null, null);
    if (le === "gentime" || le === "utctime")
      return this._encodeTime(Ee, le);
    if (le === "null_")
      return this._encodeNull();
    if (le === "int" || le === "enum")
      return this._encodeInt(Ee, Je.args && Je.reverseArgs[0]);
    if (le === "bool")
      return this._encodeBool(Ee);
    if (le === "objDesc")
      return this._encodeStr(Ee, le);
    throw new Error("Unsupported tag: " + le);
  }, ae.prototype._isNumstr = function(le) {
    return /^[0-9 ]*$/.test(le);
  }, ae.prototype._isPrintstr = function(le) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(le);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var z = B;
    z.Reporter = reporter.Reporter, z.DecoderBuffer = requireBuffer().DecoderBuffer, z.EncoderBuffer = requireBuffer().EncoderBuffer, z.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var z = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = z._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = z._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var z = B;
    z._reverse = function(ne) {
      var ie = {};
      return Object.keys(ne).forEach(function(oe) {
        (oe | 0) == oe && (oe = oe | 0);
        var se = ne[oe];
        ie[se] = oe;
      }), ie;
    }, z.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = inherits_browserExports, z = requireAsn1(), Y = z.base, ne = z.bignum, ie = z.constants.der;
  function oe(Ce) {
    this.enc = "der", this.name = Ce.name, this.entity = Ce, this.tree = new se(), this.tree._init(Ce.body);
  }
  der_1$1 = oe, oe.prototype.decode = function(le, Ee) {
    return le instanceof Y.DecoderBuffer || (le = new Y.DecoderBuffer(le, Ee)), this.tree._decode(le, Ee);
  };
  function se(Ce) {
    Y.Node.call(this, "der", Ce);
  }
  B(se, Y.Node), se.prototype._peekTag = function(le, Ee, Je) {
    if (le.isEmpty())
      return !1;
    var Ve = le.save(), $t = ae(le, 'Failed to peek tag: "' + Ee + '"');
    return le.isError($t) ? $t : (le.restore(Ve), $t.tag === Ee || $t.tagStr === Ee || $t.tagStr + "of" === Ee || Je);
  }, se.prototype._decodeTag = function(le, Ee, Je) {
    var Ve = ae(
      le,
      'Failed to decode tag of "' + Ee + '"'
    );
    if (le.isError(Ve))
      return Ve;
    var $t = ge(
      le,
      Ve.primitive,
      'Failed to get length of "' + Ee + '"'
    );
    if (le.isError($t))
      return $t;
    if (!Je && Ve.tag !== Ee && Ve.tagStr !== Ee && Ve.tagStr + "of" !== Ee)
      return le.error('Failed to match tag: "' + Ee + '"');
    if (Ve.primitive || $t !== null)
      return le.skip($t, 'Failed to match body of: "' + Ee + '"');
    var Nt = le.save(), Dt = this._skipUntilEnd(
      le,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return le.isError(Dt) ? Dt : ($t = le.offset - Nt.offset, le.restore(Nt), le.skip($t, 'Failed to match body of: "' + Ee + '"'));
  }, se.prototype._skipUntilEnd = function(le, Ee) {
    for (; ; ) {
      var Je = ae(le, Ee);
      if (le.isError(Je))
        return Je;
      var Ve = ge(le, Je.primitive, Ee);
      if (le.isError(Ve))
        return Ve;
      var $t;
      if (Je.primitive || Ve !== null ? $t = le.skip(Ve) : $t = this._skipUntilEnd(le, Ee), le.isError($t))
        return $t;
      if (Je.tagStr === "end")
        break;
    }
  }, se.prototype._decodeList = function(le, Ee, Je, Ve) {
    for (var $t = []; !le.isEmpty(); ) {
      var Nt = this._peekTag(le, "end");
      if (le.isError(Nt))
        return Nt;
      var Dt = Je.decode(le, "der", Ve);
      if (le.isError(Dt) && Nt)
        break;
      $t.push(Dt);
    }
    return $t;
  }, se.prototype._decodeStr = function(le, Ee) {
    if (Ee === "bitstr") {
      var Je = le.readUInt8();
      return le.isError(Je) ? Je : { unused: Je, data: le.raw() };
    } else if (Ee === "bmpstr") {
      var Ve = le.raw();
      if (Ve.length % 2 === 1)
        return le.error("Decoding of string type: bmpstr length mismatch");
      for (var $t = "", Nt = 0; Nt < Ve.length / 2; Nt++)
        $t += String.fromCharCode(Ve.readUInt16BE(Nt * 2));
      return $t;
    } else if (Ee === "numstr") {
      var Dt = le.raw().toString("ascii");
      return this._isNumstr(Dt) ? Dt : le.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (Ee === "octstr")
        return le.raw();
      if (Ee === "objDesc")
        return le.raw();
      if (Ee === "printstr") {
        var Wt = le.raw().toString("ascii");
        return this._isPrintstr(Wt) ? Wt : le.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(Ee) ? le.raw().toString() : le.error("Decoding of string type: " + Ee + " unsupported");
    }
  }, se.prototype._decodeObjid = function(le, Ee, Je) {
    for (var Ve, $t = [], Nt = 0; !le.isEmpty(); ) {
      var Dt = le.readUInt8();
      Nt <<= 7, Nt |= Dt & 127, Dt & 128 || ($t.push(Nt), Nt = 0);
    }
    Dt & 128 && $t.push(Nt);
    var Wt = $t[0] / 40 | 0, Pt = $t[0] % 40;
    if (Je ? Ve = $t : Ve = [Wt, Pt].concat($t.slice(1)), Ee) {
      var Lt = Ee[Ve.join(" ")];
      Lt === void 0 && (Lt = Ee[Ve.join(".")]), Lt !== void 0 && (Ve = Lt);
    }
    return Ve;
  }, se.prototype._decodeTime = function(le, Ee) {
    var Je = le.raw().toString();
    if (Ee === "gentime")
      var Ve = Je.slice(0, 4) | 0, $t = Je.slice(4, 6) | 0, Nt = Je.slice(6, 8) | 0, Dt = Je.slice(8, 10) | 0, Wt = Je.slice(10, 12) | 0, Pt = Je.slice(12, 14) | 0;
    else if (Ee === "utctime") {
      var Ve = Je.slice(0, 2) | 0, $t = Je.slice(2, 4) | 0, Nt = Je.slice(4, 6) | 0, Dt = Je.slice(6, 8) | 0, Wt = Je.slice(8, 10) | 0, Pt = Je.slice(10, 12) | 0;
      Ve < 70 ? Ve = 2e3 + Ve : Ve = 1900 + Ve;
    } else
      return le.error("Decoding " + Ee + " time is not supported yet");
    return Date.UTC(Ve, $t - 1, Nt, Dt, Wt, Pt, 0);
  }, se.prototype._decodeNull = function(le) {
    return null;
  }, se.prototype._decodeBool = function(le) {
    var Ee = le.readUInt8();
    return le.isError(Ee) ? Ee : Ee !== 0;
  }, se.prototype._decodeInt = function(le, Ee) {
    var Je = le.raw(), Ve = new ne(Je);
    return Ee && (Ve = Ee[Ve.toString(10)] || Ve), Ve;
  }, se.prototype._use = function(le, Ee) {
    return typeof le == "function" && (le = le(Ee)), le._getDecoder("der").tree;
  };
  function ae(Ce, le) {
    var Ee = Ce.readUInt8(le);
    if (Ce.isError(Ee))
      return Ee;
    var Je = ie.tagClass[Ee >> 6], Ve = (Ee & 32) === 0;
    if ((Ee & 31) === 31) {
      var $t = Ee;
      for (Ee = 0; ($t & 128) === 128; ) {
        if ($t = Ce.readUInt8(le), Ce.isError($t))
          return $t;
        Ee <<= 7, Ee |= $t & 127;
      }
    } else
      Ee &= 31;
    var Nt = ie.tag[Ee];
    return {
      cls: Je,
      primitive: Ve,
      tag: Ee,
      tagStr: Nt
    };
  }
  function ge(Ce, le, Ee) {
    var Je = Ce.readUInt8(Ee);
    if (Ce.isError(Je))
      return Je;
    if (!le && Je === 128)
      return null;
    if (!(Je & 128))
      return Je;
    var Ve = Je & 127;
    if (Ve > 4)
      return Ce.error("length octect is too long");
    Je = 0;
    for (var $t = 0; $t < Ve; $t++) {
      Je <<= 8;
      var Nt = Ce.readUInt8(Ee);
      if (Ce.isError(Nt))
        return Nt;
      Je |= Nt;
    }
    return Je;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = inherits_browserExports, z = dist$1.Buffer, Y = requireDer$1();
  function ne(ie) {
    Y.call(this, ie), this.enc = "pem";
  }
  return B(ne, Y), pem$1 = ne, ne.prototype.decode = function(oe, se) {
    for (var ae = oe.toString().split(/[\r\n]+/g), ge = se.label.toUpperCase(), Ce = /^-----(BEGIN|END) ([^-]+)-----$/, le = -1, Ee = -1, Je = 0; Je < ae.length; Je++) {
      var Ve = ae[Je].match(Ce);
      if (Ve !== null && Ve[2] === ge)
        if (le === -1) {
          if (Ve[1] !== "BEGIN")
            break;
          le = Je;
        } else {
          if (Ve[1] !== "END")
            break;
          Ee = Je;
          break;
        }
    }
    if (le === -1 || Ee === -1)
      throw new Error("PEM section not found for: " + ge);
    var $t = ae.slice(le + 1, Ee).join("");
    $t.replace(/[^a-z0-9\+\/=]+/gi, "");
    var Nt = new z($t, "base64");
    return Y.prototype.decode.call(this, Nt, se);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var z = B;
    z.der = requireDer$1(), z.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = inherits_browserExports, z = dist$1.Buffer, Y = requireAsn1(), ne = Y.base, ie = Y.constants.der;
  function oe(Ce) {
    this.enc = "der", this.name = Ce.name, this.entity = Ce, this.tree = new se(), this.tree._init(Ce.body);
  }
  der_1 = oe, oe.prototype.encode = function(le, Ee) {
    return this.tree._encode(le, Ee).join();
  };
  function se(Ce) {
    ne.Node.call(this, "der", Ce);
  }
  B(se, ne.Node), se.prototype._encodeComposite = function(le, Ee, Je, Ve) {
    var $t = ge(le, Ee, Je, this.reporter);
    if (Ve.length < 128) {
      var Wt = new z(2);
      return Wt[0] = $t, Wt[1] = Ve.length, this._createEncoderBuffer([Wt, Ve]);
    }
    for (var Nt = 1, Dt = Ve.length; Dt >= 256; Dt >>= 8)
      Nt++;
    var Wt = new z(2 + Nt);
    Wt[0] = $t, Wt[1] = 128 | Nt;
    for (var Dt = 1 + Nt, Pt = Ve.length; Pt > 0; Dt--, Pt >>= 8)
      Wt[Dt] = Pt & 255;
    return this._createEncoderBuffer([Wt, Ve]);
  }, se.prototype._encodeStr = function(le, Ee) {
    if (Ee === "bitstr")
      return this._createEncoderBuffer([le.unused | 0, le.data]);
    if (Ee === "bmpstr") {
      for (var Je = new z(le.length * 2), Ve = 0; Ve < le.length; Ve++)
        Je.writeUInt16BE(le.charCodeAt(Ve), Ve * 2);
      return this._createEncoderBuffer(Je);
    } else return Ee === "numstr" ? this._isNumstr(le) ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : Ee === "printstr" ? this._isPrintstr(le) ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(Ee) ? this._createEncoderBuffer(le) : Ee === "objDesc" ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: " + Ee + " unsupported");
  }, se.prototype._encodeObjid = function(le, Ee, Je) {
    if (typeof le == "string") {
      if (!Ee)
        return this.reporter.error("string objid given, but no values map found");
      if (!Ee.hasOwnProperty(le))
        return this.reporter.error("objid not found in values map");
      le = Ee[le].split(/[\s\.]+/g);
      for (var Ve = 0; Ve < le.length; Ve++)
        le[Ve] |= 0;
    } else if (Array.isArray(le)) {
      le = le.slice();
      for (var Ve = 0; Ve < le.length; Ve++)
        le[Ve] |= 0;
    }
    if (!Array.isArray(le))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(le));
    if (!Je) {
      if (le[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      le.splice(0, 2, le[0] * 40 + le[1]);
    }
    for (var $t = 0, Ve = 0; Ve < le.length; Ve++) {
      var Nt = le[Ve];
      for ($t++; Nt >= 128; Nt >>= 7)
        $t++;
    }
    for (var Dt = new z($t), Wt = Dt.length - 1, Ve = le.length - 1; Ve >= 0; Ve--) {
      var Nt = le[Ve];
      for (Dt[Wt--] = Nt & 127; (Nt >>= 7) > 0; )
        Dt[Wt--] = 128 | Nt & 127;
    }
    return this._createEncoderBuffer(Dt);
  };
  function ae(Ce) {
    return Ce < 10 ? "0" + Ce : Ce;
  }
  se.prototype._encodeTime = function(le, Ee) {
    var Je, Ve = new Date(le);
    return Ee === "gentime" ? Je = [
      ae(Ve.getFullYear()),
      ae(Ve.getUTCMonth() + 1),
      ae(Ve.getUTCDate()),
      ae(Ve.getUTCHours()),
      ae(Ve.getUTCMinutes()),
      ae(Ve.getUTCSeconds()),
      "Z"
    ].join("") : Ee === "utctime" ? Je = [
      ae(Ve.getFullYear() % 100),
      ae(Ve.getUTCMonth() + 1),
      ae(Ve.getUTCDate()),
      ae(Ve.getUTCHours()),
      ae(Ve.getUTCMinutes()),
      ae(Ve.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + Ee + " time is not supported yet"), this._encodeStr(Je, "octstr");
  }, se.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, se.prototype._encodeInt = function(le, Ee) {
    if (typeof le == "string") {
      if (!Ee)
        return this.reporter.error("String int or enum given, but no values map");
      if (!Ee.hasOwnProperty(le))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(le));
      le = Ee[le];
    }
    if (typeof le != "number" && !z.isBuffer(le)) {
      var Je = le.toArray();
      !le.sign && Je[0] & 128 && Je.unshift(0), le = new z(Je);
    }
    if (z.isBuffer(le)) {
      var Ve = le.length;
      le.length === 0 && Ve++;
      var Nt = new z(Ve);
      return le.copy(Nt), le.length === 0 && (Nt[0] = 0), this._createEncoderBuffer(Nt);
    }
    if (le < 128)
      return this._createEncoderBuffer(le);
    if (le < 256)
      return this._createEncoderBuffer([0, le]);
    for (var Ve = 1, $t = le; $t >= 256; $t >>= 8)
      Ve++;
    for (var Nt = new Array(Ve), $t = Nt.length - 1; $t >= 0; $t--)
      Nt[$t] = le & 255, le >>= 8;
    return Nt[0] & 128 && Nt.unshift(0), this._createEncoderBuffer(new z(Nt));
  }, se.prototype._encodeBool = function(le) {
    return this._createEncoderBuffer(le ? 255 : 0);
  }, se.prototype._use = function(le, Ee) {
    return typeof le == "function" && (le = le(Ee)), le._getEncoder("der").tree;
  }, se.prototype._skipDefault = function(le, Ee, Je) {
    var Ve = this._baseState, $t;
    if (Ve.default === null)
      return !1;
    var Nt = le.join();
    if (Ve.defaultBuffer === void 0 && (Ve.defaultBuffer = this._encodeValue(Ve.default, Ee, Je).join()), Nt.length !== Ve.defaultBuffer.length)
      return !1;
    for ($t = 0; $t < Nt.length; $t++)
      if (Nt[$t] !== Ve.defaultBuffer[$t])
        return !1;
    return !0;
  };
  function ge(Ce, le, Ee, Je) {
    var Ve;
    if (Ce === "seqof" ? Ce = "seq" : Ce === "setof" && (Ce = "set"), ie.tagByName.hasOwnProperty(Ce))
      Ve = ie.tagByName[Ce];
    else if (typeof Ce == "number" && (Ce | 0) === Ce)
      Ve = Ce;
    else
      return Je.error("Unknown tag: " + Ce);
    return Ve >= 31 ? Je.error("Multi-octet tag encoding unsupported") : (le || (Ve |= 32), Ve |= ie.tagClassByName[Ee || "universal"] << 6, Ve);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = inherits_browserExports, z = requireDer();
  function Y(ne) {
    z.call(this, ne), this.enc = "pem";
  }
  return B(Y, z), pem = Y, Y.prototype.encode = function(ie, oe) {
    for (var se = z.prototype.encode.call(this, ie), ae = se.toString("base64"), ge = ["-----BEGIN " + oe.label + "-----"], Ce = 0; Ce < ae.length; Ce += 64)
      ge.push(ae.slice(Ce, Ce + 64));
    return ge.push("-----END " + oe.label + "-----"), ge.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var z = B;
    z.der = requireDer(), z.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(B) {
    var z = B;
    z.bignum = bnExports$1, z.define = requireApi().define, z.base = requireBase(), z.constants = requireConstants(), z.decoders = requireDecoders(), z.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$7 = safeBufferExports$1.Buffer, fixProc$1 = function(B, z) {
  var Y = B.toString(), ne = Y.match(findProc), ie;
  if (ne) {
    var se = "aes" + ne[1], ae = Buffer$7.from(ne[2], "hex"), ge = Buffer$7.from(ne[3].replace(/[\r\n]/g, ""), "base64"), Ce = evp(z, ae.slice(0, 8), parseInt(ne[1], 10)).key, le = [], Ee = ciphers$1.createDecipheriv(se, Ce, ae);
    le.push(Ee.update(ge)), le.push(Ee.final()), ie = Buffer$7.concat(le);
  } else {
    var oe = Y.match(fullRegex);
    ie = Buffer$7.from(oe[2].replace(/[\r\n]/g, ""), "base64");
  }
  var Je = Y.match(startRegex)[1];
  return {
    tag: Je,
    data: ie
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$6 = safeBufferExports$1.Buffer;
function decrypt(B, z) {
  var Y = B.algorithm.decrypt.kde.kdeparams.salt, ne = parseInt(B.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ie = aesid[B.algorithm.decrypt.cipher.algo.join(".")], oe = B.algorithm.decrypt.cipher.iv, se = B.subjectPrivateKey, ae = parseInt(ie.split("-")[1], 10) / 8, ge = compat.pbkdf2Sync(z, Y, ne, ae, "sha1"), Ce = ciphers.createDecipheriv(ie, ge, oe), le = [];
  return le.push(Ce.update(se)), le.push(Ce.final()), Buffer$6.concat(le);
}
function parseKeys$2(B) {
  var z;
  typeof B == "object" && !Buffer$6.isBuffer(B) && (z = B.passphrase, B = B.key), typeof B == "string" && (B = Buffer$6.from(B));
  var Y = fixProc(B, z), ne = Y.tag, ie = Y.data, oe, se;
  switch (ne) {
    case "CERTIFICATE":
      se = asn1.certificate.decode(ie, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (se || (se = asn1.PublicKey.decode(ie, "der")), oe = se.algorithm.algorithm.join("."), oe) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(se.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return se.subjectPrivateKey = se.subjectPublicKey, {
            type: "ec",
            data: se
          };
        case "1.2.840.10040.4.1":
          return se.algorithm.params.pub_key = asn1.DSAparam.decode(se.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: se.algorithm.params
          };
        default:
          throw new Error("unknown key id " + oe);
      }
    case "ENCRYPTED PRIVATE KEY":
      ie = asn1.EncryptedPrivateKey.decode(ie, "der"), ie = decrypt(ie, z);
    case "PRIVATE KEY":
      switch (se = asn1.PrivateKey.decode(ie, "der"), oe = se.algorithm.algorithm.join("."), oe) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(se.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: se.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(se.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return se.algorithm.params.priv_key = asn1.DSAparam.decode(se.subjectPrivateKey, "der"), {
            type: "dsa",
            params: se.algorithm.params
          };
        default:
          throw new Error("unknown key id " + oe);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(ie, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(ie, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(ie, "der")
      };
    case "EC PRIVATE KEY":
      return ie = asn1.ECPrivateKey.decode(ie, "der"), {
        curve: ie.parameters.value,
        privateKey: ie.privateKey
      };
    default:
      throw new Error("unknown key type " + ne);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports$1.Buffer, z = browser$8, Y = browserifyRsa, ne = requireElliptic().ec, ie = bnExports, oe = parseAsn1, se = require$$4, ae = 1;
  function ge(Wt, Pt, Lt, qt, Zt) {
    var Yt = oe(Pt);
    if (Yt.curve) {
      if (qt !== "ecdsa" && qt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return Ce(Wt, Yt);
    } else if (Yt.type === "dsa") {
      if (qt !== "dsa")
        throw new Error("wrong private key type");
      return le(Wt, Yt, Lt);
    }
    if (qt !== "rsa" && qt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Pt.padding !== void 0 && Pt.padding !== ae)
      throw new Error("illegal or unsupported padding mode");
    Wt = B.concat([Zt, Wt]);
    for (var or = Yt.modulus.byteLength(), jt = [0, 1]; Wt.length + jt.length + 1 < or; )
      jt.push(255);
    jt.push(0);
    for (var Ct = -1; ++Ct < Wt.length; )
      jt.push(Wt[Ct]);
    var Vt = Y(jt, Yt);
    return Vt;
  }
  function Ce(Wt, Pt) {
    var Lt = se[Pt.curve.join(".")];
    if (!Lt)
      throw new Error("unknown curve " + Pt.curve.join("."));
    var qt = new ne(Lt), Zt = qt.keyFromPrivate(Pt.privateKey), Yt = Zt.sign(Wt);
    return B.from(Yt.toDER());
  }
  function le(Wt, Pt, Lt) {
    for (var qt = Pt.params.priv_key, Zt = Pt.params.p, Yt = Pt.params.q, or = Pt.params.g, jt = new ie(0), Ct, Vt = Ve(Wt, Yt).mod(Yt), kt = !1, Pe = Je(qt, Yt, Wt, Lt); kt === !1; )
      Ct = Nt(Yt, Pe, Lt), jt = Dt(or, Ct, Zt, Yt), kt = Ct.invm(Yt).imul(Vt.add(qt.mul(jt))).mod(Yt), kt.cmpn(0) === 0 && (kt = !1, jt = new ie(0));
    return Ee(jt, kt);
  }
  function Ee(Wt, Pt) {
    Wt = Wt.toArray(), Pt = Pt.toArray(), Wt[0] & 128 && (Wt = [0].concat(Wt)), Pt[0] & 128 && (Pt = [0].concat(Pt));
    var Lt = Wt.length + Pt.length + 4, qt = [
      48,
      Lt,
      2,
      Wt.length
    ];
    return qt = qt.concat(Wt, [2, Pt.length], Pt), B.from(qt);
  }
  function Je(Wt, Pt, Lt, qt) {
    if (Wt = B.from(Wt.toArray()), Wt.length < Pt.byteLength()) {
      var Zt = B.alloc(Pt.byteLength() - Wt.length);
      Wt = B.concat([Zt, Wt]);
    }
    var Yt = Lt.length, or = $t(Lt, Pt), jt = B.alloc(Yt);
    jt.fill(1);
    var Ct = B.alloc(Yt);
    return Ct = z(qt, Ct).update(jt).update(B.from([0])).update(Wt).update(or).digest(), jt = z(qt, Ct).update(jt).digest(), Ct = z(qt, Ct).update(jt).update(B.from([1])).update(Wt).update(or).digest(), jt = z(qt, Ct).update(jt).digest(), { k: Ct, v: jt };
  }
  function Ve(Wt, Pt) {
    var Lt = new ie(Wt), qt = (Wt.length << 3) - Pt.bitLength();
    return qt > 0 && Lt.ishrn(qt), Lt;
  }
  function $t(Wt, Pt) {
    Wt = Ve(Wt, Pt), Wt = Wt.mod(Pt);
    var Lt = B.from(Wt.toArray());
    if (Lt.length < Pt.byteLength()) {
      var qt = B.alloc(Pt.byteLength() - Lt.length);
      Lt = B.concat([qt, Lt]);
    }
    return Lt;
  }
  function Nt(Wt, Pt, Lt) {
    var qt, Zt;
    do {
      for (qt = B.alloc(0); qt.length * 8 < Wt.bitLength(); )
        Pt.v = z(Lt, Pt.k).update(Pt.v).digest(), qt = B.concat([qt, Pt.v]);
      Zt = Ve(qt, Wt), Pt.k = z(Lt, Pt.k).update(Pt.v).update(B.from([0])).digest(), Pt.v = z(Lt, Pt.k).update(Pt.v).digest();
    } while (Zt.cmp(Wt) !== -1);
    return Zt;
  }
  function Dt(Wt, Pt, Lt, qt) {
    return Wt.toRed(ie.mont(Lt)).redPow(Pt).fromRed().mod(qt);
  }
  return sign.exports = ge, sign.exports.getKey = Je, sign.exports.makeKey = Nt, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var B = safeBufferExports$1.Buffer, z = bnExports, Y = requireElliptic().ec, ne = parseAsn1, ie = require$$4;
  function oe(Ce, le, Ee, Je, Ve) {
    var $t = ne(Ee);
    if ($t.type === "ec") {
      if (Je !== "ecdsa" && Je !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return se(Ce, le, $t);
    } else if ($t.type === "dsa") {
      if (Je !== "dsa")
        throw new Error("wrong public key type");
      return ae(Ce, le, $t);
    }
    if (Je !== "rsa" && Je !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    le = B.concat([Ve, le]);
    for (var Nt = $t.modulus.byteLength(), Dt = [1], Wt = 0; le.length + Dt.length + 2 < Nt; )
      Dt.push(255), Wt += 1;
    Dt.push(0);
    for (var Pt = -1; ++Pt < le.length; )
      Dt.push(le[Pt]);
    Dt = B.from(Dt);
    var Lt = z.mont($t.modulus);
    Ce = new z(Ce).toRed(Lt), Ce = Ce.redPow(new z($t.publicExponent)), Ce = B.from(Ce.fromRed().toArray());
    var qt = Wt < 8 ? 1 : 0;
    for (Nt = Math.min(Ce.length, Dt.length), Ce.length !== Dt.length && (qt = 1), Pt = -1; ++Pt < Nt; )
      qt |= Ce[Pt] ^ Dt[Pt];
    return qt === 0;
  }
  function se(Ce, le, Ee) {
    var Je = ie[Ee.data.algorithm.curve.join(".")];
    if (!Je)
      throw new Error("unknown curve " + Ee.data.algorithm.curve.join("."));
    var Ve = new Y(Je), $t = Ee.data.subjectPrivateKey.data;
    return Ve.verify(le, Ce, $t);
  }
  function ae(Ce, le, Ee) {
    var Je = Ee.data.p, Ve = Ee.data.q, $t = Ee.data.g, Nt = Ee.data.pub_key, Dt = ne.signature.decode(Ce, "der"), Wt = Dt.s, Pt = Dt.r;
    ge(Wt, Ve), ge(Pt, Ve);
    var Lt = z.mont(Je), qt = Wt.invm(Ve), Zt = $t.toRed(Lt).redPow(new z(le).mul(qt).mod(Ve)).fromRed().mul(Nt.toRed(Lt).redPow(Pt.mul(qt).mod(Ve)).fromRed()).mod(Je).mod(Ve);
    return Zt.cmp(Pt) === 0;
  }
  function ge(Ce, le) {
    if (Ce.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (Ce.cmp(le) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = oe, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var B = safeBufferExports$1.Buffer, z = browser$9, Y = readableBrowserExports, ne = inherits_browserExports, ie = requireSign(), oe = requireVerify(), se = require$$6;
  Object.keys(se).forEach(function(Ee) {
    se[Ee].id = B.from(se[Ee].id, "hex"), se[Ee.toLowerCase()] = se[Ee];
  });
  function ae(Ee) {
    Y.Writable.call(this);
    var Je = se[Ee];
    if (!Je)
      throw new Error("Unknown message digest");
    this._hashType = Je.hash, this._hash = z(Je.hash), this._tag = Je.id, this._signType = Je.sign;
  }
  ne(ae, Y.Writable), ae.prototype._write = function(Je, Ve, $t) {
    this._hash.update(Je), $t();
  }, ae.prototype.update = function(Je, Ve) {
    return this._hash.update(typeof Je == "string" ? B.from(Je, Ve) : Je), this;
  }, ae.prototype.sign = function(Je, Ve) {
    this.end();
    var $t = this._hash.digest(), Nt = ie($t, Je, this._hashType, this._signType, this._tag);
    return Ve ? Nt.toString(Ve) : Nt;
  };
  function ge(Ee) {
    Y.Writable.call(this);
    var Je = se[Ee];
    if (!Je)
      throw new Error("Unknown message digest");
    this._hash = z(Je.hash), this._tag = Je.id, this._signType = Je.sign;
  }
  ne(ge, Y.Writable), ge.prototype._write = function(Je, Ve, $t) {
    this._hash.update(Je), $t();
  }, ge.prototype.update = function(Je, Ve) {
    return this._hash.update(typeof Je == "string" ? B.from(Je, Ve) : Je), this;
  }, ge.prototype.verify = function(Je, Ve, $t) {
    var Nt = typeof Ve == "string" ? B.from(Ve, $t) : Ve;
    this.end();
    var Dt = this._hash.digest();
    return oe(Nt, Dt, Je, this._signType, this._tag);
  };
  function Ce(Ee) {
    return new ae(Ee);
  }
  function le(Ee) {
    return new ge(Ee);
  }
  return browser$3 = {
    Sign: Ce,
    Verify: le,
    createSign: Ce,
    createVerify: le
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var B = requireElliptic(), z = bnExports$1;
  browser$2 = function(se) {
    return new ne(se);
  };
  var Y = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Y.p224 = Y.secp224r1, Y.p256 = Y.secp256r1 = Y.prime256v1, Y.p192 = Y.secp192r1 = Y.prime192v1, Y.p384 = Y.secp384r1, Y.p521 = Y.secp521r1;
  function ne(oe) {
    this.curveType = Y[oe], this.curveType || (this.curveType = {
      name: oe
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  ne.prototype.generateKeys = function(oe, se) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(oe, se);
  }, ne.prototype.computeSecret = function(oe, se, ae) {
    se = se || "utf8", Buffer$D.isBuffer(oe) || (oe = new Buffer$D(oe, se));
    var ge = this.curve.keyFromPublic(oe).getPublic(), Ce = ge.mul(this.keys.getPrivate()).getX();
    return ie(Ce, ae, this.curveType.byteLength);
  }, ne.prototype.getPublicKey = function(oe, se) {
    var ae = this.keys.getPublic(se === "compressed", !0);
    return se === "hybrid" && (ae[ae.length - 1] % 2 ? ae[0] = 7 : ae[0] = 6), ie(ae, oe);
  }, ne.prototype.getPrivateKey = function(oe) {
    return ie(this.keys.getPrivate(), oe);
  }, ne.prototype.setPublicKey = function(oe, se) {
    return se = se || "utf8", Buffer$D.isBuffer(oe) || (oe = new Buffer$D(oe, se)), this.keys._importPublic(oe), this;
  }, ne.prototype.setPrivateKey = function(oe, se) {
    se = se || "utf8", Buffer$D.isBuffer(oe) || (oe = new Buffer$D(oe, se));
    var ae = new z(oe);
    return ae = ae.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ae), this;
  };
  function ie(oe, se, ae) {
    Array.isArray(oe) || (oe = oe.toArray());
    var ge = new Buffer$D(oe);
    if (ae && ge.length < ae) {
      var Ce = new Buffer$D(ae - ge.length);
      Ce.fill(0), ge = Buffer$D.concat([Ce, ge]);
    }
    return se ? ge.toString(se) : ge;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$5 = safeBufferExports$1.Buffer, mgf$2 = function(B, z) {
  for (var Y = Buffer$5.alloc(0), ne = 0, ie; Y.length < z; )
    ie = i2ops(ne++), Y = Buffer$5.concat([Y, createHash$2("sha1").update(B).update(ie).digest()]);
  return Y.slice(0, z);
};
function i2ops(B) {
  var z = Buffer$5.allocUnsafe(4);
  return z.writeUInt32BE(B, 0), z;
}
var xor$2 = function B(z, Y) {
  for (var ne = z.length, ie = -1; ++ie < ne; )
    z[ie] ^= Y[ie];
  return z;
}, BN$2 = bnExports$1, Buffer$4 = safeBufferExports$1.Buffer;
function withPublic$2(B, z) {
  return Buffer$4.from(B.toRed(BN$2.mont(z.modulus)).redPow(new BN$2(z.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$1, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$3 = safeBufferExports$1.Buffer, publicEncrypt = function B(z, Y, ne) {
  var ie;
  z.padding ? ie = z.padding : ne ? ie = 1 : ie = 4;
  var oe = parseKeys$1(z), se;
  if (ie === 4)
    se = oaep$1(oe, Y);
  else if (ie === 1)
    se = pkcs1$1(oe, Y, ne);
  else if (ie === 3) {
    if (se = new BN$1(Y), se.cmp(oe.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return ne ? crt$1(se, oe) : withPublic$1(se, oe);
};
function oaep$1(B, z) {
  var Y = B.modulus.byteLength(), ne = z.length, ie = createHash$1("sha1").update(Buffer$3.alloc(0)).digest(), oe = ie.length, se = 2 * oe;
  if (ne > Y - se - 2)
    throw new Error("message too long");
  var ae = Buffer$3.alloc(Y - ne - se - 2), ge = Y - oe - 1, Ce = randomBytes(oe), le = xor$1(Buffer$3.concat([ie, ae, Buffer$3.alloc(1, 1), z], ge), mgf$1(Ce, ge)), Ee = xor$1(Ce, mgf$1(le, oe));
  return new BN$1(Buffer$3.concat([Buffer$3.alloc(1), Ee, le], Y));
}
function pkcs1$1(B, z, Y) {
  var ne = z.length, ie = B.modulus.byteLength();
  if (ne > ie - 11)
    throw new Error("message too long");
  var oe;
  return Y ? oe = Buffer$3.alloc(ie - ne - 3, 255) : oe = nonZero(ie - ne - 3), new BN$1(Buffer$3.concat([Buffer$3.from([0, Y ? 1 : 2]), oe, Buffer$3.alloc(1), z], ie));
}
function nonZero(B) {
  for (var z = Buffer$3.allocUnsafe(B), Y = 0, ne = randomBytes(B * 2), ie = 0, oe; Y < B; )
    ie === ne.length && (ne = randomBytes(B * 2), ie = 0), oe = ne[ie++], oe && (z[Y++] = oe);
  return z;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$1, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$2 = safeBufferExports$1.Buffer, privateDecrypt = function B(z, Y, ne) {
  var ie;
  z.padding ? ie = z.padding : ne ? ie = 1 : ie = 4;
  var oe = parseKeys(z), se = oe.modulus.byteLength();
  if (Y.length > se || new BN(Y).cmp(oe.modulus) >= 0)
    throw new Error("decryption error");
  var ae;
  ne ? ae = withPublic(new BN(Y), oe) : ae = crt(Y, oe);
  var ge = Buffer$2.alloc(se - ae.length);
  if (ae = Buffer$2.concat([ge, ae], se), ie === 4)
    return oaep(oe, ae);
  if (ie === 1)
    return pkcs1(oe, ae, ne);
  if (ie === 3)
    return ae;
  throw new Error("unknown padding");
};
function oaep(B, z) {
  var Y = B.modulus.byteLength(), ne = createHash("sha1").update(Buffer$2.alloc(0)).digest(), ie = ne.length;
  if (z[0] !== 0)
    throw new Error("decryption error");
  var oe = z.slice(1, ie + 1), se = z.slice(ie + 1), ae = xor(oe, mgf(se, ie)), ge = xor(se, mgf(ae, Y - ie - 1));
  if (compare$1(ne, ge.slice(0, ie)))
    throw new Error("decryption error");
  for (var Ce = ie; ge[Ce] === 0; )
    Ce++;
  if (ge[Ce++] !== 1)
    throw new Error("decryption error");
  return ge.slice(Ce);
}
function pkcs1(B, z, Y) {
  for (var ne = z.slice(0, 2), ie = 2, oe = 0; z[ie++] !== 0; )
    if (ie >= z.length) {
      oe++;
      break;
    }
  var se = z.slice(2, ie - 1);
  if ((ne.toString("hex") !== "0002" && !Y || ne.toString("hex") !== "0001" && Y) && oe++, se.length < 8 && oe++, oe)
    throw new Error("decryption error");
  return z.slice(ie);
}
function compare$1(B, z) {
  B = Buffer$2.from(B), z = Buffer$2.from(z);
  var Y = 0, ne = B.length;
  B.length !== z.length && (Y++, ne = Math.min(B.length, z.length));
  for (var ie = -1; ++ie < ne; )
    Y += B[ie] ^ z[ie];
  return Y;
}
(function(B) {
  B.publicEncrypt = publicEncrypt, B.privateDecrypt = privateDecrypt, B.privateEncrypt = function(Y, ne) {
    return B.publicEncrypt(Y, ne, !0);
  }, B.publicDecrypt = function(Y, ne) {
    return B.privateDecrypt(Y, ne, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$1, randombytes = browserExports, Buffer$1 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(B, z) {
  if (typeof B != "number" || B !== B)
    throw new TypeError("offset must be a number");
  if (B > kMaxUint32 || B < 0)
    throw new TypeError("offset must be a uint32");
  if (B > kBufferMaxLength || B > z)
    throw new RangeError("offset out of range");
}
function assertSize(B, z, Y) {
  if (typeof B != "number" || B !== B)
    throw new TypeError("size must be a number");
  if (B > kMaxUint32 || B < 0)
    throw new TypeError("size must be a uint32");
  if (B + z > Y || B > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(B, z, Y, ne) {
  if (!Buffer$1.isBuffer(B) && !(B instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof z == "function")
    ne = z, z = 0, Y = B.length;
  else if (typeof Y == "function")
    ne = Y, Y = B.length - z;
  else if (typeof ne != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(z, B.length), assertSize(Y, z, B.length), actualFill(B, z, Y, ne);
}
function actualFill(B, z, Y, ne) {
  if (process$1.browser) {
    var ie = B.buffer, oe = new Uint8Array(ie, z, Y);
    if (crypto$2.getRandomValues(oe), ne) {
      process$1.nextTick(function() {
        ne(null, B);
      });
      return;
    }
    return B;
  }
  if (ne) {
    randombytes(Y, function(ae, ge) {
      if (ae)
        return ne(ae);
      ge.copy(B, z), ne(null, B);
    });
    return;
  }
  var se = randombytes(Y);
  return se.copy(B, z), B;
}
function randomFillSync(B, z, Y) {
  if (typeof z > "u" && (z = 0), !Buffer$1.isBuffer(B) && !(B instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(z, B.length), Y === void 0 && (Y = B.length - z), assertSize(Y, z, B.length), actualFill(B, z, Y);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var B = algos, z = Object.keys(B), Y = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(z);
  cryptoBrowserify.getHashes = function() {
    return Y;
  };
  var ne = browser$7;
  cryptoBrowserify.pbkdf2 = ne.pbkdf2, cryptoBrowserify.pbkdf2Sync = ne.pbkdf2Sync;
  var ie = browser$6;
  cryptoBrowserify.Cipher = ie.Cipher, cryptoBrowserify.createCipher = ie.createCipher, cryptoBrowserify.Cipheriv = ie.Cipheriv, cryptoBrowserify.createCipheriv = ie.createCipheriv, cryptoBrowserify.Decipher = ie.Decipher, cryptoBrowserify.createDecipher = ie.createDecipher, cryptoBrowserify.Decipheriv = ie.Decipheriv, cryptoBrowserify.createDecipheriv = ie.createDecipheriv, cryptoBrowserify.getCiphers = ie.getCiphers, cryptoBrowserify.listCiphers = ie.listCiphers;
  var oe = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = oe.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = oe.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = oe.getDiffieHellman, cryptoBrowserify.createDiffieHellman = oe.createDiffieHellman, cryptoBrowserify.DiffieHellman = oe.DiffieHellman;
  var se = requireBrowser$1();
  cryptoBrowserify.createSign = se.createSign, cryptoBrowserify.Sign = se.Sign, cryptoBrowserify.createVerify = se.createVerify, cryptoBrowserify.Verify = se.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var ae = browser$1;
  cryptoBrowserify.publicEncrypt = ae.publicEncrypt, cryptoBrowserify.privateEncrypt = ae.privateEncrypt, cryptoBrowserify.publicDecrypt = ae.publicDecrypt, cryptoBrowserify.privateDecrypt = ae.privateDecrypt;
  var ge = browser;
  return cryptoBrowserify.randomFill = ge.randomFill, cryptoBrowserify.randomFillSync = ge.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const z = requireCryptoBrowserify(), Y = BigInt(0), ne = BigInt(1), ie = BigInt(2), oe = BigInt(3), se = BigInt(8), ae = Object.freeze({
    a: Y,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: ne,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = ae;
  const ge = (fr, er) => (fr + er / ie) / er, Ce = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(fr) {
      const { n: er } = ae, cr = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ft = -ne * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), _t = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Bt = cr, Xt = BigInt("0x100000000000000000000000000000000"), ir = ge(Bt * fr, er), dr = ge(-Ft * fr, er);
      let pr = Ht(fr - ir * cr - dr * _t, er), xr = Ht(-ir * Ft - dr * Bt, er);
      const Tr = pr > Xt, nr = xr > Xt;
      if (Tr && (pr = er - pr), nr && (xr = er - xr), pr > Xt || xr > Xt)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + fr);
      return { k1neg: Tr, k1: pr, k2neg: nr, k2: xr };
    }
  }, le = 32, Ee = 32, Je = 32, Ve = le + 1, $t = 2 * le + 1;
  function Nt(fr) {
    const { a: er, b: cr } = ae, Ft = Ht(fr * fr), _t = Ht(Ft * fr);
    return Ht(_t + er * fr + cr);
  }
  const Dt = ae.a === Y;
  class Wt extends Error {
    constructor(er) {
      super(er);
    }
  }
  function Pt(fr) {
    if (!(fr instanceof Lt))
      throw new TypeError("JacobianPoint expected");
  }
  class Lt {
    constructor(er, cr, Ft) {
      this.x = er, this.y = cr, this.z = Ft;
    }
    static fromAffine(er) {
      if (!(er instanceof Yt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return er.equals(Yt.ZERO) ? Lt.ZERO : new Lt(er.x, er.y, ne);
    }
    static toAffineBatch(er) {
      const cr = Kt(er.map((Ft) => Ft.z));
      return er.map((Ft, _t) => Ft.toAffine(cr[_t]));
    }
    static normalizeZ(er) {
      return Lt.toAffineBatch(er).map(Lt.fromAffine);
    }
    equals(er) {
      Pt(er);
      const { x: cr, y: Ft, z: _t } = this, { x: Bt, y: Xt, z: ir } = er, dr = Ht(_t * _t), pr = Ht(ir * ir), xr = Ht(cr * pr), Tr = Ht(Bt * dr), nr = Ht(Ht(Ft * ir) * pr), wr = Ht(Ht(Xt * _t) * dr);
      return xr === Tr && nr === wr;
    }
    negate() {
      return new Lt(this.x, Ht(-this.y), this.z);
    }
    double() {
      const { x: er, y: cr, z: Ft } = this, _t = Ht(er * er), Bt = Ht(cr * cr), Xt = Ht(Bt * Bt), ir = er + Bt, dr = Ht(ie * (Ht(ir * ir) - _t - Xt)), pr = Ht(oe * _t), xr = Ht(pr * pr), Tr = Ht(xr - ie * dr), nr = Ht(pr * (dr - Tr) - se * Xt), wr = Ht(ie * cr * Ft);
      return new Lt(Tr, nr, wr);
    }
    add(er) {
      Pt(er);
      const { x: cr, y: Ft, z: _t } = this, { x: Bt, y: Xt, z: ir } = er;
      if (Bt === Y || Xt === Y)
        return this;
      if (cr === Y || Ft === Y)
        return er;
      const dr = Ht(_t * _t), pr = Ht(ir * ir), xr = Ht(cr * pr), Tr = Ht(Bt * dr), nr = Ht(Ht(Ft * ir) * pr), wr = Ht(Ht(Xt * _t) * dr), Er = Ht(Tr - xr), Pr = Ht(wr - nr);
      if (Er === Y)
        return Pr === Y ? this.double() : Lt.ZERO;
      const Dr = Ht(Er * Er), Ur = Ht(Er * Dr), kr = Ht(xr * Dr), Xr = Ht(Pr * Pr - Ur - ie * kr), sn = Ht(Pr * (kr - Xr) - nr * Ur), tn = Ht(_t * ir * Er);
      return new Lt(Xr, sn, tn);
    }
    subtract(er) {
      return this.add(er.negate());
    }
    multiplyUnsafe(er) {
      const cr = Lt.ZERO;
      if (typeof er == "bigint" && er === Y)
        return cr;
      let Ft = bt(er);
      if (Ft === ne)
        return this;
      if (!Dt) {
        let Tr = cr, nr = this;
        for (; Ft > Y; )
          Ft & ne && (Tr = Tr.add(nr)), nr = nr.double(), Ft >>= ne;
        return Tr;
      }
      let { k1neg: _t, k1: Bt, k2neg: Xt, k2: ir } = Ce.splitScalar(Ft), dr = cr, pr = cr, xr = this;
      for (; Bt > Y || ir > Y; )
        Bt & ne && (dr = dr.add(xr)), ir & ne && (pr = pr.add(xr)), xr = xr.double(), Bt >>= ne, ir >>= ne;
      return _t && (dr = dr.negate()), Xt && (pr = pr.negate()), pr = new Lt(Ht(pr.x * Ce.beta), pr.y, pr.z), dr.add(pr);
    }
    precomputeWindow(er) {
      const cr = Dt ? 128 / er + 1 : 256 / er + 1, Ft = [];
      let _t = this, Bt = _t;
      for (let Xt = 0; Xt < cr; Xt++) {
        Bt = _t, Ft.push(Bt);
        for (let ir = 1; ir < 2 ** (er - 1); ir++)
          Bt = Bt.add(_t), Ft.push(Bt);
        _t = Bt.double();
      }
      return Ft;
    }
    wNAF(er, cr) {
      !cr && this.equals(Lt.BASE) && (cr = Yt.BASE);
      const Ft = cr && cr._WINDOW_SIZE || 1;
      if (256 % Ft)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let _t = cr && Zt.get(cr);
      _t || (_t = this.precomputeWindow(Ft), cr && Ft !== 1 && (_t = Lt.normalizeZ(_t), Zt.set(cr, _t)));
      let Bt = Lt.ZERO, Xt = Lt.BASE;
      const ir = 1 + (Dt ? 128 / Ft : 256 / Ft), dr = 2 ** (Ft - 1), pr = BigInt(2 ** Ft - 1), xr = 2 ** Ft, Tr = BigInt(Ft);
      for (let nr = 0; nr < ir; nr++) {
        const wr = nr * dr;
        let Er = Number(er & pr);
        er >>= Tr, Er > dr && (Er -= xr, er += ne);
        const Pr = wr, Dr = wr + Math.abs(Er) - 1, Ur = nr % 2 !== 0, kr = Er < 0;
        Er === 0 ? Xt = Xt.add(qt(Ur, _t[Pr])) : Bt = Bt.add(qt(kr, _t[Dr]));
      }
      return { p: Bt, f: Xt };
    }
    multiply(er, cr) {
      let Ft = bt(er), _t, Bt;
      if (Dt) {
        const { k1neg: Xt, k1: ir, k2neg: dr, k2: pr } = Ce.splitScalar(Ft);
        let { p: xr, f: Tr } = this.wNAF(ir, cr), { p: nr, f: wr } = this.wNAF(pr, cr);
        xr = qt(Xt, xr), nr = qt(dr, nr), nr = new Lt(Ht(nr.x * Ce.beta), nr.y, nr.z), _t = xr.add(nr), Bt = Tr.add(wr);
      } else {
        const { p: Xt, f: ir } = this.wNAF(Ft, cr);
        _t = Xt, Bt = ir;
      }
      return Lt.normalizeZ([_t, Bt])[0];
    }
    toAffine(er) {
      const { x: cr, y: Ft, z: _t } = this, Bt = this.equals(Lt.ZERO);
      er == null && (er = Bt ? se : rr(_t));
      const Xt = er, ir = Ht(Xt * Xt), dr = Ht(ir * Xt), pr = Ht(cr * ir), xr = Ht(Ft * dr), Tr = Ht(_t * Xt);
      if (Bt)
        return Yt.ZERO;
      if (Tr !== ne)
        throw new Error("invZ was invalid");
      return new Yt(pr, xr);
    }
  }
  Lt.BASE = new Lt(ae.Gx, ae.Gy, ne), Lt.ZERO = new Lt(Y, ne, Y);
  function qt(fr, er) {
    const cr = er.negate();
    return fr ? cr : er;
  }
  const Zt = /* @__PURE__ */ new WeakMap();
  class Yt {
    constructor(er, cr) {
      this.x = er, this.y = cr;
    }
    _setWindowSize(er) {
      this._WINDOW_SIZE = er, Zt.delete(this);
    }
    hasEvenY() {
      return this.y % ie === Y;
    }
    static fromCompressedHex(er) {
      const cr = er.length === 32, Ft = Qe(cr ? er : er.subarray(1));
      if (!Sr(Ft))
        throw new Error("Point is not on curve");
      const _t = Nt(Ft);
      let Bt = yr(_t);
      const Xt = (Bt & ne) === ne;
      cr ? Xt && (Bt = Ht(-Bt)) : (er[0] & 1) === 1 !== Xt && (Bt = Ht(-Bt));
      const ir = new Yt(Ft, Bt);
      return ir.assertValidity(), ir;
    }
    static fromUncompressedHex(er) {
      const cr = Qe(er.subarray(1, le + 1)), Ft = Qe(er.subarray(le + 1, le * 2 + 1)), _t = new Yt(cr, Ft);
      return _t.assertValidity(), _t;
    }
    static fromHex(er) {
      const cr = Rt(er), Ft = cr.length, _t = cr[0];
      if (Ft === le)
        return this.fromCompressedHex(cr);
      if (Ft === Ve && (_t === 2 || _t === 3))
        return this.fromCompressedHex(cr);
      if (Ft === $t && _t === 4)
        return this.fromUncompressedHex(cr);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ve} compressed bytes or ${$t} uncompressed bytes, not ${Ft}`);
    }
    static fromPrivateKey(er) {
      return Yt.BASE.multiply(Br(er));
    }
    static fromSignature(er, cr, Ft) {
      const { r: _t, s: Bt } = Cr(cr);
      if (![0, 1, 2, 3].includes(Ft))
        throw new Error("Cannot recover: invalid recovery bit");
      const Xt = ur(Rt(er)), { n: ir } = ae, dr = Ft === 2 || Ft === 3 ? _t + ir : _t, pr = rr(dr, ir), xr = Ht(-Xt * pr, ir), Tr = Ht(Bt * pr, ir), nr = Ft & 1 ? "03" : "02", wr = Yt.fromHex(nr + Ke(dr)), Er = Yt.BASE.multiplyAndAddUnsafe(wr, xr, Tr);
      if (!Er)
        throw new Error("Cannot recover signature: point at infinify");
      return Er.assertValidity(), Er;
    }
    toRawBytes(er = !1) {
      return xt(this.toHex(er));
    }
    toHex(er = !1) {
      const cr = Ke(this.x);
      return er ? `${this.hasEvenY() ? "02" : "03"}${cr}` : `04${cr}${Ke(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const er = "Point is not on elliptic curve", { x: cr, y: Ft } = this;
      if (!Sr(cr) || !Sr(Ft))
        throw new Error(er);
      const _t = Ht(Ft * Ft), Bt = Nt(cr);
      if (Ht(_t - Bt) !== Y)
        throw new Error(er);
    }
    equals(er) {
      return this.x === er.x && this.y === er.y;
    }
    negate() {
      return new Yt(this.x, Ht(-this.y));
    }
    double() {
      return Lt.fromAffine(this).double().toAffine();
    }
    add(er) {
      return Lt.fromAffine(this).add(Lt.fromAffine(er)).toAffine();
    }
    subtract(er) {
      return this.add(er.negate());
    }
    multiply(er) {
      return Lt.fromAffine(this).multiply(er, this).toAffine();
    }
    multiplyAndAddUnsafe(er, cr, Ft) {
      const _t = Lt.fromAffine(this), Bt = cr === Y || cr === ne || this !== Yt.BASE ? _t.multiplyUnsafe(cr) : _t.multiply(cr), Xt = Lt.fromAffine(er).multiplyUnsafe(Ft), ir = Bt.add(Xt);
      return ir.equals(Lt.ZERO) ? void 0 : ir.toAffine();
    }
  }
  B.Point = Yt, Yt.BASE = new Yt(ae.Gx, ae.Gy), Yt.ZERO = new Yt(Y, Y);
  function or(fr) {
    return Number.parseInt(fr[0], 16) >= 8 ? "00" + fr : fr;
  }
  function jt(fr) {
    if (fr.length < 2 || fr[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Xe(fr)}`);
    const er = fr[1], cr = fr.subarray(2, er + 2);
    if (!er || cr.length !== er)
      throw new Error("Invalid signature integer: wrong length");
    if (cr[0] === 0 && cr[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: Qe(cr), left: fr.subarray(er + 2) };
  }
  function Ct(fr) {
    if (fr.length < 2 || fr[0] != 48)
      throw new Error(`Invalid signature tag: ${Xe(fr)}`);
    if (fr[1] !== fr.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: er, left: cr } = jt(fr.subarray(2)), { data: Ft, left: _t } = jt(cr);
    if (_t.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Xe(_t)}`);
    return { r: er, s: Ft };
  }
  class Vt {
    constructor(er, cr) {
      this.r = er, this.s = cr, this.assertValidity();
    }
    static fromCompact(er) {
      const cr = er instanceof Uint8Array, Ft = "Signature.fromCompact";
      if (typeof er != "string" && !cr)
        throw new TypeError(`${Ft}: Expected string or Uint8Array`);
      const _t = cr ? Xe(er) : er;
      if (_t.length !== 128)
        throw new Error(`${Ft}: Expected 64-byte hex`);
      return new Vt(vt(_t.slice(0, 64)), vt(_t.slice(64, 128)));
    }
    static fromDER(er) {
      const cr = er instanceof Uint8Array;
      if (typeof er != "string" && !cr)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Ft, s: _t } = Ct(cr ? er : xt(er));
      return new Vt(Ft, _t);
    }
    static fromHex(er) {
      return this.fromDER(er);
    }
    assertValidity() {
      const { r: er, s: cr } = this;
      if (!br(er))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!br(cr))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const er = ae.n >> ne;
      return this.s > er;
    }
    normalizeS() {
      return this.hasHighS() ? new Vt(this.r, Ht(-this.s, ae.n)) : this;
    }
    toDERRawBytes() {
      return xt(this.toDERHex());
    }
    toDERHex() {
      const er = or(wt(this.s)), cr = or(wt(this.r)), Ft = er.length / 2, _t = cr.length / 2, Bt = wt(Ft), Xt = wt(_t);
      return `30${wt(_t + Ft + 4)}02${Xt}${cr}02${Bt}${er}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return xt(this.toCompactHex());
    }
    toCompactHex() {
      return Ke(this.r) + Ke(this.s);
    }
  }
  B.Signature = Vt;
  function kt(...fr) {
    if (!fr.every((Ft) => Ft instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (fr.length === 1)
      return fr[0];
    const er = fr.reduce((Ft, _t) => Ft + _t.length, 0), cr = new Uint8Array(er);
    for (let Ft = 0, _t = 0; Ft < fr.length; Ft++) {
      const Bt = fr[Ft];
      cr.set(Bt, _t), _t += Bt.length;
    }
    return cr;
  }
  const Pe = Array.from({ length: 256 }, (fr, er) => er.toString(16).padStart(2, "0"));
  function Xe(fr) {
    if (!(fr instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let er = "";
    for (let cr = 0; cr < fr.length; cr++)
      er += Pe[fr[cr]];
    return er;
  }
  const ve = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Ke(fr) {
    if (typeof fr != "bigint")
      throw new Error("Expected bigint");
    if (!(Y <= fr && fr < ve))
      throw new Error("Expected number 0 <= n < 2^256");
    return fr.toString(16).padStart(64, "0");
  }
  function ht(fr) {
    const er = xt(Ke(fr));
    if (er.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return er;
  }
  function wt(fr) {
    const er = fr.toString(16);
    return er.length & 1 ? `0${er}` : er;
  }
  function vt(fr) {
    if (typeof fr != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof fr);
    return BigInt(`0x${fr}`);
  }
  function xt(fr) {
    if (typeof fr != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof fr);
    if (fr.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + fr.length);
    const er = new Uint8Array(fr.length / 2);
    for (let cr = 0; cr < er.length; cr++) {
      const Ft = cr * 2, _t = fr.slice(Ft, Ft + 2), Bt = Number.parseInt(_t, 16);
      if (Number.isNaN(Bt) || Bt < 0)
        throw new Error("Invalid byte sequence");
      er[cr] = Bt;
    }
    return er;
  }
  function Qe(fr) {
    return vt(Xe(fr));
  }
  function Rt(fr) {
    return fr instanceof Uint8Array ? Uint8Array.from(fr) : xt(fr);
  }
  function bt(fr) {
    if (typeof fr == "number" && Number.isSafeInteger(fr) && fr > 0)
      return BigInt(fr);
    if (typeof fr == "bigint" && br(fr))
      return fr;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Ht(fr, er = ae.P) {
    const cr = fr % er;
    return cr >= Y ? cr : er + cr;
  }
  function ar(fr, er) {
    const { P: cr } = ae;
    let Ft = fr;
    for (; er-- > Y; )
      Ft *= Ft, Ft %= cr;
    return Ft;
  }
  function yr(fr) {
    const { P: er } = ae, cr = BigInt(6), Ft = BigInt(11), _t = BigInt(22), Bt = BigInt(23), Xt = BigInt(44), ir = BigInt(88), dr = fr * fr * fr % er, pr = dr * dr * fr % er, xr = ar(pr, oe) * pr % er, Tr = ar(xr, oe) * pr % er, nr = ar(Tr, ie) * dr % er, wr = ar(nr, Ft) * nr % er, Er = ar(wr, _t) * wr % er, Pr = ar(Er, Xt) * Er % er, Dr = ar(Pr, ir) * Pr % er, Ur = ar(Dr, Xt) * Er % er, kr = ar(Ur, oe) * pr % er, Xr = ar(kr, Bt) * wr % er, sn = ar(Xr, cr) * dr % er, tn = ar(sn, ie);
    if (tn * tn % er !== fr)
      throw new Error("Cannot find square root");
    return tn;
  }
  function rr(fr, er = ae.P) {
    if (fr === Y || er <= Y)
      throw new Error(`invert: expected positive integers, got n=${fr} mod=${er}`);
    let cr = Ht(fr, er), Ft = er, _t = Y, Bt = ne;
    for (; cr !== Y; ) {
      const ir = Ft / cr, dr = Ft % cr, pr = _t - Bt * ir;
      Ft = cr, cr = dr, _t = Bt, Bt = pr;
    }
    if (Ft !== ne)
      throw new Error("invert: does not exist");
    return Ht(_t, er);
  }
  function Kt(fr, er = ae.P) {
    const cr = new Array(fr.length), Ft = fr.reduce((Bt, Xt, ir) => Xt === Y ? Bt : (cr[ir] = Bt, Ht(Bt * Xt, er)), ne), _t = rr(Ft, er);
    return fr.reduceRight((Bt, Xt, ir) => Xt === Y ? Bt : (cr[ir] = Ht(Bt * cr[ir], er), Ht(Bt * Xt, er)), _t), cr;
  }
  function Gt(fr) {
    const er = fr.length * 8 - Ee * 8, cr = Qe(fr);
    return er > 0 ? cr >> BigInt(er) : cr;
  }
  function ur(fr, er = !1) {
    const cr = Gt(fr);
    if (er)
      return cr;
    const { n: Ft } = ae;
    return cr >= Ft ? cr - Ft : cr;
  }
  let gr, Qt;
  class Jt {
    constructor(er, cr) {
      if (this.hashLen = er, this.qByteLen = cr, typeof er != "number" || er < 2)
        throw new Error("hashLen must be a number");
      if (typeof cr != "number" || cr < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(er).fill(1), this.k = new Uint8Array(er).fill(0), this.counter = 0;
    }
    hmac(...er) {
      return B.utils.hmacSha256(this.k, ...er);
    }
    hmacSync(...er) {
      return Qt(this.k, ...er);
    }
    checkSync() {
      if (typeof Qt != "function")
        throw new Wt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(er = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), er), this.v = await this.hmac(this.v), er.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), er), this.v = await this.hmac(this.v));
    }
    reseedSync(er = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), er), this.v = this.hmacSync(this.v), er.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), er), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let er = 0;
      const cr = [];
      for (; er < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Ft = this.v.slice();
        cr.push(Ft), er += this.v.length;
      }
      return kt(...cr);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let er = 0;
      const cr = [];
      for (; er < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Ft = this.v.slice();
        cr.push(Ft), er += this.v.length;
      }
      return kt(...cr);
    }
  }
  function br(fr) {
    return Y < fr && fr < ae.n;
  }
  function Sr(fr) {
    return Y < fr && fr < ae.P;
  }
  function Ar(fr, er, cr, Ft = !0) {
    const { n: _t } = ae, Bt = ur(fr, !0);
    if (!br(Bt))
      return;
    const Xt = rr(Bt, _t), ir = Yt.BASE.multiply(Bt), dr = Ht(ir.x, _t);
    if (dr === Y)
      return;
    const pr = Ht(Xt * Ht(er + cr * dr, _t), _t);
    if (pr === Y)
      return;
    let xr = new Vt(dr, pr), Tr = (ir.x === xr.r ? 0 : 2) | Number(ir.y & ne);
    return Ft && xr.hasHighS() && (xr = xr.normalizeS(), Tr ^= 1), { sig: xr, recovery: Tr };
  }
  function Br(fr) {
    let er;
    if (typeof fr == "bigint")
      er = fr;
    else if (typeof fr == "number" && Number.isSafeInteger(fr) && fr > 0)
      er = BigInt(fr);
    else if (typeof fr == "string") {
      if (fr.length !== 2 * Ee)
        throw new Error("Expected 32 bytes of private key");
      er = vt(fr);
    } else if (fr instanceof Uint8Array) {
      if (fr.length !== Ee)
        throw new Error("Expected 32 bytes of private key");
      er = Qe(fr);
    } else
      throw new TypeError("Expected valid private key");
    if (!br(er))
      throw new Error("Expected private key: 0 < key < n");
    return er;
  }
  function Mr(fr) {
    return fr instanceof Yt ? (fr.assertValidity(), fr) : Yt.fromHex(fr);
  }
  function Cr(fr) {
    if (fr instanceof Vt)
      return fr.assertValidity(), fr;
    try {
      return Vt.fromDER(fr);
    } catch {
      return Vt.fromCompact(fr);
    }
  }
  function $r(fr, er = !1) {
    return Yt.fromPrivateKey(fr).toRawBytes(er);
  }
  B.getPublicKey = $r;
  function Qr(fr, er, cr, Ft = !1) {
    return Yt.fromSignature(fr, er, cr).toRawBytes(Ft);
  }
  B.recoverPublicKey = Qr;
  function jr(fr) {
    const er = fr instanceof Uint8Array, cr = typeof fr == "string", Ft = (er || cr) && fr.length;
    return er ? Ft === Ve || Ft === $t : cr ? Ft === Ve * 2 || Ft === $t * 2 : fr instanceof Yt;
  }
  function qr(fr, er, cr = !1) {
    if (jr(fr))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!jr(er))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Ft = Mr(er);
    return Ft.assertValidity(), Ft.multiply(Br(fr)).toRawBytes(cr);
  }
  B.getSharedSecret = qr;
  function Gr(fr) {
    const er = fr.length > le ? fr.slice(0, le) : fr;
    return Qe(er);
  }
  function Or(fr) {
    const er = Gr(fr), cr = Ht(er, ae.n);
    return Vr(cr < Y ? er : cr);
  }
  function Vr(fr) {
    return ht(fr);
  }
  function Zr(fr, er, cr) {
    if (fr == null)
      throw new Error(`sign: expected valid message hash, not "${fr}"`);
    const Ft = Rt(fr), _t = Br(er), Bt = [Vr(_t), Or(Ft)];
    if (cr != null) {
      cr === !0 && (cr = B.utils.randomBytes(le));
      const dr = Rt(cr);
      if (dr.length !== le)
        throw new Error(`sign: Expected ${le} bytes of extra data`);
      Bt.push(dr);
    }
    const Xt = kt(...Bt), ir = Gr(Ft);
    return { seed: Xt, m: ir, d: _t };
  }
  function Lr(fr, er) {
    const { sig: cr, recovery: Ft } = fr, { der: _t, recovered: Bt } = Object.assign({ canonical: !0, der: !0 }, er), Xt = _t ? cr.toDERRawBytes() : cr.toCompactRawBytes();
    return Bt ? [Xt, Ft] : Xt;
  }
  async function Yr(fr, er, cr = {}) {
    const { seed: Ft, m: _t, d: Bt } = Zr(fr, er, cr.extraEntropy), Xt = new Jt(Je, Ee);
    await Xt.reseed(Ft);
    let ir;
    for (; !(ir = Ar(await Xt.generate(), _t, Bt, cr.canonical)); )
      await Xt.reseed();
    return Lr(ir, cr);
  }
  B.sign = Yr;
  function en(fr, er, cr = {}) {
    const { seed: Ft, m: _t, d: Bt } = Zr(fr, er, cr.extraEntropy), Xt = new Jt(Je, Ee);
    Xt.reseedSync(Ft);
    let ir;
    for (; !(ir = Ar(Xt.generateSync(), _t, Bt, cr.canonical)); )
      Xt.reseedSync();
    return Lr(ir, cr);
  }
  B.signSync = en;
  const zt = { strict: !0 };
  function Ot(fr, er, cr, Ft = zt) {
    let _t;
    try {
      _t = Cr(fr), er = Rt(er);
    } catch {
      return !1;
    }
    const { r: Bt, s: Xt } = _t;
    if (Ft.strict && _t.hasHighS())
      return !1;
    const ir = ur(er);
    let dr;
    try {
      dr = Mr(cr);
    } catch {
      return !1;
    }
    const { n: pr } = ae, xr = rr(Xt, pr), Tr = Ht(ir * xr, pr), nr = Ht(Bt * xr, pr), wr = Yt.BASE.multiplyAndAddUnsafe(dr, Tr, nr);
    return wr ? Ht(wr.x, pr) === Bt : !1;
  }
  B.verify = Ot;
  function Ut(fr) {
    return Ht(Qe(fr), ae.n);
  }
  class tr {
    constructor(er, cr) {
      this.r = er, this.s = cr, this.assertValidity();
    }
    static fromHex(er) {
      const cr = Rt(er);
      if (cr.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${cr.length}`);
      const Ft = Qe(cr.subarray(0, 32)), _t = Qe(cr.subarray(32, 64));
      return new tr(Ft, _t);
    }
    assertValidity() {
      const { r: er, s: cr } = this;
      if (!Sr(er) || !br(cr))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Ke(this.r) + Ke(this.s);
    }
    toRawBytes() {
      return xt(this.toHex());
    }
  }
  function lr(fr) {
    return Yt.fromPrivateKey(fr).toRawX();
  }
  class vr {
    constructor(er, cr, Ft = B.utils.randomBytes()) {
      if (er == null)
        throw new TypeError(`sign: Expected valid message, not "${er}"`);
      this.m = Rt(er);
      const { x: _t, scalar: Bt } = this.getScalar(Br(cr));
      if (this.px = _t, this.d = Bt, this.rand = Rt(Ft), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(er) {
      const cr = Yt.fromPrivateKey(er), Ft = cr.hasEvenY() ? er : ae.n - er;
      return { point: cr, scalar: Ft, x: cr.toRawX() };
    }
    initNonce(er, cr) {
      return ht(er ^ Qe(cr));
    }
    finalizeNonce(er) {
      const cr = Ht(Qe(er), ae.n);
      if (cr === Y)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Ft, x: _t, scalar: Bt } = this.getScalar(cr);
      return { R: Ft, rx: _t, k: Bt };
    }
    finalizeSig(er, cr, Ft, _t) {
      return new tr(er.x, Ht(cr + Ft * _t, ae.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: er, d: cr, px: Ft, rand: _t } = this, Bt = B.utils.taggedHash, Xt = this.initNonce(cr, await Bt(Jr.aux, _t)), { R: ir, rx: dr, k: pr } = this.finalizeNonce(await Bt(Jr.nonce, Xt, Ft, er)), xr = Ut(await Bt(Jr.challenge, dr, Ft, er)), Tr = this.finalizeSig(ir, pr, xr, cr);
      return await Hr(Tr, er, Ft) || this.error(), Tr;
    }
    calcSync() {
      const { m: er, d: cr, px: Ft, rand: _t } = this, Bt = B.utils.taggedHashSync, Xt = this.initNonce(cr, Bt(Jr.aux, _t)), { R: ir, rx: dr, k: pr } = this.finalizeNonce(Bt(Jr.nonce, Xt, Ft, er)), xr = Ut(Bt(Jr.challenge, dr, Ft, er)), Tr = this.finalizeSig(ir, pr, xr, cr);
      return Fr(Tr, er, Ft) || this.error(), Tr;
    }
  }
  async function _r(fr, er, cr) {
    return new vr(fr, er, cr).calc();
  }
  function Rr(fr, er, cr) {
    return new vr(fr, er, cr).calcSync();
  }
  function Wr(fr, er, cr) {
    const Ft = fr instanceof tr, _t = Ft ? fr : tr.fromHex(fr);
    return Ft && _t.assertValidity(), {
      ..._t,
      m: Rt(er),
      P: Mr(cr)
    };
  }
  function Ir(fr, er, cr, Ft) {
    const _t = Yt.BASE.multiplyAndAddUnsafe(er, Br(cr), Ht(-Ft, ae.n));
    return !(!_t || !_t.hasEvenY() || _t.x !== fr);
  }
  async function Hr(fr, er, cr) {
    try {
      const { r: Ft, s: _t, m: Bt, P: Xt } = Wr(fr, er, cr), ir = Ut(await B.utils.taggedHash(Jr.challenge, ht(Ft), Xt.toRawX(), Bt));
      return Ir(Ft, Xt, _t, ir);
    } catch {
      return !1;
    }
  }
  function Fr(fr, er, cr) {
    try {
      const { r: Ft, s: _t, m: Bt, P: Xt } = Wr(fr, er, cr), ir = Ut(B.utils.taggedHashSync(Jr.challenge, ht(Ft), Xt.toRawX(), Bt));
      return Ir(Ft, Xt, _t, ir);
    } catch (Ft) {
      if (Ft instanceof Wt)
        throw Ft;
      return !1;
    }
  }
  B.schnorr = {
    Signature: tr,
    getPublicKey: lr,
    sign: _r,
    verify: Hr,
    signSync: Rr,
    verifySync: Fr
  }, Yt.BASE._setWindowSize(8);
  const Nr = {
    node: z,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Jr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, nn = {};
  B.utils = {
    bytesToHex: Xe,
    hexToBytes: xt,
    concatBytes: kt,
    mod: Ht,
    invert: rr,
    isValidPrivateKey(fr) {
      try {
        return Br(fr), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: ht,
    _normalizePrivateKey: Br,
    hashToPrivateKey: (fr) => {
      fr = Rt(fr);
      const er = Ee + 8;
      if (fr.length < er || fr.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const cr = Ht(Qe(fr), ae.n - ne) + ne;
      return ht(cr);
    },
    randomBytes: (fr = 32) => {
      if (Nr.web)
        return Nr.web.getRandomValues(new Uint8Array(fr));
      if (Nr.node) {
        const { randomBytes: er } = Nr.node;
        return Uint8Array.from(er(fr));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(Ee + 8)),
    precompute(fr = 8, er = Yt.BASE) {
      const cr = er === Yt.BASE ? er : new Yt(er.x, er.y);
      return cr._setWindowSize(fr), cr.multiply(oe), cr;
    },
    sha256: async (...fr) => {
      if (Nr.web) {
        const er = await Nr.web.subtle.digest("SHA-256", kt(...fr));
        return new Uint8Array(er);
      } else if (Nr.node) {
        const { createHash: er } = Nr.node, cr = er("sha256");
        return fr.forEach((Ft) => cr.update(Ft)), Uint8Array.from(cr.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (fr, ...er) => {
      if (Nr.web) {
        const cr = await Nr.web.subtle.importKey("raw", fr, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Ft = kt(...er), _t = await Nr.web.subtle.sign("HMAC", cr, Ft);
        return new Uint8Array(_t);
      } else if (Nr.node) {
        const { createHmac: cr } = Nr.node, Ft = cr("sha256", fr);
        return er.forEach((_t) => Ft.update(_t)), Uint8Array.from(Ft.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (fr, ...er) => {
      let cr = nn[fr];
      if (cr === void 0) {
        const Ft = await B.utils.sha256(Uint8Array.from(fr, (_t) => _t.charCodeAt(0)));
        cr = kt(Ft, Ft), nn[fr] = cr;
      }
      return B.utils.sha256(cr, ...er);
    },
    taggedHashSync: (fr, ...er) => {
      if (typeof gr != "function")
        throw new Wt("sha256Sync is undefined, you need to set it");
      let cr = nn[fr];
      if (cr === void 0) {
        const Ft = gr(Uint8Array.from(fr, (_t) => _t.charCodeAt(0)));
        cr = kt(Ft, Ft), nn[fr] = cr;
      }
      return gr(cr, ...er);
    },
    _JacobianPoint: Lt
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return gr;
      },
      set(fr) {
        gr || (gr = fr);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Qt;
      },
      set(fr) {
        Qt || (Qt = fr);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const z = paramBytesForAlg[B];
  if (z)
    return z;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, z) {
  const Y = signatureAsBytes(B), ne = getParamBytesForAlg(z), ie = ne + 1, oe = Y.length;
  let se = 0;
  if (Y[se++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ae = Y[se++];
  if (ae === (MAX_OCTET | 1) && (ae = Y[se++]), oe - se < ae)
    throw new Error(`"seq" specified length of "${ae}", only "${oe - se}" remaining`);
  if (Y[se++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ge = Y[se++];
  if (oe - se - 2 < ge)
    throw new Error(`"r" specified length of "${ge}", only "${oe - se - 2}" available`);
  if (ie < ge)
    throw new Error(`"r" specified length of "${ge}", max of "${ie}" is acceptable`);
  const Ce = se;
  if (se += ge, Y[se++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const le = Y[se++];
  if (oe - se !== le)
    throw new Error(`"s" specified length of "${le}", expected "${oe - se}"`);
  if (ie < le)
    throw new Error(`"s" specified length of "${le}", max of "${ie}" is acceptable`);
  const Ee = se;
  if (se += le, se !== oe)
    throw new Error(`Expected to consume entire array, but "${oe - se}" bytes remain`);
  const Je = ne - ge, Ve = ne - le, $t = new Uint8Array(Je + ge + Ve + le);
  for (se = 0; se < Je; ++se)
    $t[se] = 0;
  $t.set(Y.subarray(Ce + Math.max(-Je, 0), Ce + ge), se), se = ne;
  for (const Nt = se; se < Nt + Ve; ++se)
    $t[se] = 0;
  return $t.set(Y.subarray(Ee + Math.max(-Ve, 0), Ee + le), se), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)($t));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, z, Y) {
  let ne = 0;
  for (; z + ne < Y && B[z + ne] === 0; )
    ++ne;
  return B[z + ne] >= MAX_OCTET && --ne, ne;
}
function joseToDer(B, z) {
  B = signatureAsBytes(B);
  const Y = getParamBytesForAlg(z), ne = B.length;
  if (ne !== Y * 2)
    throw new TypeError(`"${z}" signatures must be "${Y * 2}" bytes, saw "${ne}"`);
  const ie = countPadding(B, 0, Y), oe = countPadding(B, Y, B.length), se = Y - ie, ae = Y - oe, ge = 2 + se + 1 + 1 + ae, Ce = ge < MAX_OCTET, le = new Uint8Array((Ce ? 2 : 3) + ge);
  let Ee = 0;
  return le[Ee++] = ENCODED_TAG_SEQ, Ce ? le[Ee++] = ge : (le[Ee++] = MAX_OCTET | 1, le[Ee++] = ge & 255), le[Ee++] = ENCODED_TAG_INT, le[Ee++] = se, ie < 0 ? (le[Ee++] = 0, le.set(B.subarray(0, Y), Ee), Ee += Y) : (le.set(B.subarray(ie, Y), Ee), Ee += Y - ie), le[Ee++] = ENCODED_TAG_INT, le[Ee++] = ae, oe < 0 ? (le[Ee++] = 0, le.set(B.subarray(Y), Ee)) : le.set(B.subarray(Y + oe), Ee), le;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(z) {
    super(), this.name = "MissingParametersError", this.message = z || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(z) {
    super(), this.name = "InvalidTokenError", this.message = z || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$p;
secp.utils.hmacSha256Sync = (B, ...z) => {
  const Y = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return z.forEach((ne) => Y.update(ne)), Y.digest();
};
class SECP256K1Client {
  static derivePublicKey(z, Y = !0) {
    return z.length === 66 && (z = z.slice(0, 64)), z.length < 64 && (z = z.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(z, Y));
  }
  static signHash(z, Y, ne = "jose") {
    if (!z || !Y)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const ie = secp.signSync(z, Y.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (ne === "der")
      return (0, utils_1$2.bytesToHex)(ie);
    if (ne === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(ie, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(z) {
    return (0, ecdsaSigFormatter_1.joseToDer)(z, "ES256");
  }
  static verifyHash(z, Y, ne) {
    if (!z || !Y || !ne)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(Y, z, ne, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const z = secp256k1$1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return z.SECP256K1Client;
  } });
  const Y = {
    ES256K: z.SECP256K1Client
  };
  B.cryptoClients = Y;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function ie(oe) {
    return oe instanceof Y ? oe : new Y(function(se) {
      se(oe);
    });
  }
  return new (Y || (Y = Promise))(function(oe, se) {
    function ae(le) {
      try {
        Ce(ne.next(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ge(le) {
      try {
        Ce(ne.throw(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function Ce(le) {
      le.done ? oe(le.value) : ie(le.value).then(ae, ge);
    }
    Ce((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const Y = typeof B == "string" ? new TextEncoder().encode(B) : B, ne = yield crypto.subtle.digest("SHA-256", Y);
        return new Uint8Array(ne);
      } else {
        const Y = requireCryptoBrowserify();
        if (!Y.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(Y.createHash("sha256").update(B).digest());
      }
    } catch (z) {
      return console.log(z), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function ie(oe) {
    return oe instanceof Y ? oe : new Y(function(se) {
      se(oe);
    });
  }
  return new (Y || (Y = Promise))(function(oe, se) {
    function ae(le) {
      try {
        Ce(ne.next(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function ge(le) {
      try {
        Ce(ne.throw(le));
      } catch (Ee) {
        se(Ee);
      }
    }
    function Ce(le) {
      le.done ? oe(le.value) : ie(le.value).then(ae, ge);
    }
    Ce((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(B, z) {
  const Y = [], ne = base64url$2.encode(JSON.stringify(z));
  Y.push(ne);
  const ie = base64url$2.encode(JSON.stringify(B));
  return Y.push(ie), Y.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof z != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (z = z.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(z))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[z], this.rawPrivateKey = Y;
  }
  header(z = {}) {
    const Y = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, Y, z);
  }
  sign(z, Y = !1, ne = {}) {
    const ie = this.header(ne), oe = createSigningInput(z, ie), se = (0, sha256_1$1.hashSha256)(oe);
    return this.createWithSignedHash(z, Y, ie, oe, se);
  }
  signAsync(z, Y = !1, ne = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const ie = this.header(ne), oe = createSigningInput(z, ie), se = yield (0, sha256_1$1.hashSha256Async)(oe);
      return this.createWithSignedHash(z, Y, ie, oe, se);
    });
  }
  createWithSignedHash(z, Y, ne, ie, oe) {
    const se = this.cryptoClient.signHash(oe, this.rawPrivateKey);
    return Y ? {
      header: [base64url$2.encode(JSON.stringify(ne))],
      payload: JSON.stringify(z),
      signature: [se]
    } : [ie, se].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof z != "string")
      throw "signing algorithm parameter must be a string";
    if (z = z.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(z))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[z], this.rawPublicKey = Y;
  }
  verify(z) {
    return typeof z == "string" ? this.verifyCompact(z, !1) : typeof z == "object" ? this.verifyExpanded(z, !1) : !1;
  }
  verifyAsync(z) {
    return typeof z == "string" ? this.verifyCompact(z, !0) : typeof z == "object" ? this.verifyExpanded(z, !0) : Promise.resolve(!1);
  }
  verifyCompact(z, Y) {
    const ne = z.split("."), ie = ne[0] + "." + ne[1], oe = (se) => {
      const ae = this.cryptoClient.loadSignature(ne[2]);
      return this.cryptoClient.verifyHash(se, ae, this.rawPublicKey);
    };
    if (Y)
      return (0, sha256_1.hashSha256Async)(ie).then((se) => oe(se));
    {
      const se = (0, sha256_1.hashSha256)(ie);
      return oe(se);
    }
  }
  verifyExpanded(z, Y) {
    const ne = [z.header.join("."), base64url$1.encode(z.payload)].join(".");
    let ie = !0;
    const oe = (se) => (z.signature.map((ae) => {
      const ge = this.cryptoClient.loadSignature(ae);
      this.cryptoClient.verifyHash(se, ge, this.rawPublicKey) || (ie = !1);
    }), ie);
    if (Y)
      return (0, sha256_1.hashSha256Async)(ne).then((se) => oe(se));
    {
      const se = (0, sha256_1.hashSha256)(ne);
      return oe(se);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const z = B.split("."), Y = JSON.parse(base64url.decode(z[0])), ne = JSON.parse(base64url.decode(z[1])), ie = z[2];
    return {
      header: Y,
      payload: ne,
      signature: ie
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let z = B.payload;
    B.payload[0] !== "{" && (z = base64url.decode(z));
    const Y = [];
    return B.header.map((ne) => {
      const ie = JSON.parse(base64url.decode(ne));
      Y.push(ie);
    }), {
      header: Y,
      payload: JSON.parse(z),
      signature: B.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(B) {
  var z = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ne, ie, oe, se) {
    se === void 0 && (se = oe);
    var ae = Object.getOwnPropertyDescriptor(ie, oe);
    (!ae || ("get" in ae ? !ie.__esModule : ae.writable || ae.configurable)) && (ae = { enumerable: !0, get: function() {
      return ie[oe];
    } }), Object.defineProperty(ne, se, ae);
  } : function(ne, ie, oe, se) {
    se === void 0 && (se = oe), ne[se] = ie[oe];
  }), Y = commonjsGlobal && commonjsGlobal.__exportStar || function(ne, ie) {
    for (var oe in ne) oe !== "default" && !Object.prototype.hasOwnProperty.call(ie, oe) && z(ie, ne, oe);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), Y(signer, B), Y(verifier, B), Y(decode$i, B), Y(errors$1, B), Y(cryptoClients, B);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const B = Array(256).fill(-1);
  for (let z = 0; z < r.length; ++z) B[r.charCodeAt(z)] = z;
})();
var s, i, o, h$1 = (s = function(B, z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.bech32m = z.bech32 = void 0;
  const Y = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ne = {};
  for (let Ee = 0; Ee < 32; Ee++) {
    const Je = Y.charAt(Ee);
    ne[Je] = Ee;
  }
  function ie(Ee) {
    const Je = Ee >> 25;
    return (33554431 & Ee) << 5 ^ 996825010 & -(Je >> 0 & 1) ^ 642813549 & -(Je >> 1 & 1) ^ 513874426 & -(Je >> 2 & 1) ^ 1027748829 & -(Je >> 3 & 1) ^ 705979059 & -(Je >> 4 & 1);
  }
  function oe(Ee) {
    let Je = 1;
    for (let Ve = 0; Ve < Ee.length; ++Ve) {
      const $t = Ee.charCodeAt(Ve);
      if ($t < 33 || $t > 126) return "Invalid prefix (" + Ee + ")";
      Je = ie(Je) ^ $t >> 5;
    }
    Je = ie(Je);
    for (let Ve = 0; Ve < Ee.length; ++Ve) {
      const $t = Ee.charCodeAt(Ve);
      Je = ie(Je) ^ 31 & $t;
    }
    return Je;
  }
  function se(Ee, Je, Ve, $t) {
    let Nt = 0, Dt = 0;
    const Wt = (1 << Ve) - 1, Pt = [];
    for (let Lt = 0; Lt < Ee.length; ++Lt) for (Nt = Nt << Je | Ee[Lt], Dt += Je; Dt >= Ve; ) Dt -= Ve, Pt.push(Nt >> Dt & Wt);
    if ($t) Dt > 0 && Pt.push(Nt << Ve - Dt & Wt);
    else {
      if (Dt >= Je) return "Excess padding";
      if (Nt << Ve - Dt & Wt) return "Non-zero padding";
    }
    return Pt;
  }
  function ae(Ee) {
    return se(Ee, 8, 5, !0);
  }
  function ge(Ee) {
    const Je = se(Ee, 5, 8, !1);
    if (Array.isArray(Je)) return Je;
  }
  function Ce(Ee) {
    const Je = se(Ee, 5, 8, !1);
    if (Array.isArray(Je)) return Je;
    throw new Error(Je);
  }
  function le(Ee) {
    let Je;
    function Ve($t, Nt) {
      if (Nt = Nt || 90, $t.length < 8) return $t + " too short";
      if ($t.length > Nt) return "Exceeds length limit";
      const Dt = $t.toLowerCase(), Wt = $t.toUpperCase();
      if ($t !== Dt && $t !== Wt) return "Mixed-case string " + $t;
      const Pt = ($t = Dt).lastIndexOf("1");
      if (Pt === -1) return "No separator character for " + $t;
      if (Pt === 0) return "Missing prefix for " + $t;
      const Lt = $t.slice(0, Pt), qt = $t.slice(Pt + 1);
      if (qt.length < 6) return "Data too short";
      let Zt = oe(Lt);
      if (typeof Zt == "string") return Zt;
      const Yt = [];
      for (let or = 0; or < qt.length; ++or) {
        const jt = qt.charAt(or), Ct = ne[jt];
        if (Ct === void 0) return "Unknown character " + jt;
        Zt = ie(Zt) ^ Ct, or + 6 >= qt.length || Yt.push(Ct);
      }
      return Zt !== Je ? "Invalid checksum for " + $t : { prefix: Lt, words: Yt };
    }
    return Je = Ee === "bech32" ? 1 : 734539939, { decodeUnsafe: function($t, Nt) {
      const Dt = Ve($t, Nt);
      if (typeof Dt == "object") return Dt;
    }, decode: function($t, Nt) {
      const Dt = Ve($t, Nt);
      if (typeof Dt == "object") return Dt;
      throw new Error(Dt);
    }, encode: function($t, Nt, Dt) {
      if (Dt = Dt || 90, $t.length + 7 + Nt.length > Dt) throw new TypeError("Exceeds length limit");
      let Wt = oe($t = $t.toLowerCase());
      if (typeof Wt == "string") throw new Error(Wt);
      let Pt = $t + "1";
      for (let Lt = 0; Lt < Nt.length; ++Lt) {
        const qt = Nt[Lt];
        if (qt >> 5) throw new Error("Non 5-bit word");
        Wt = ie(Wt) ^ qt, Pt += Y.charAt(qt);
      }
      for (let Lt = 0; Lt < 6; ++Lt) Wt = ie(Wt);
      Wt ^= Je;
      for (let Lt = 0; Lt < 6; ++Lt) Pt += Y.charAt(Wt >> 5 * (5 - Lt) & 31);
      return Pt;
    }, toWords: ae, fromWordsUnsafe: ge, fromWords: Ce };
  }
  z.bech32 = le("bech32"), z.bech32m = le("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
async function getProviderOrThrow(B) {
  var Y;
  const z = await (B == null ? void 0 : B()) || ((Y = window.XverseProviders) == null ? void 0 : Y.BitcoinProvider) || window.BitcoinProvider;
  if (!z)
    throw new Error("No Bitcoin wallet installed");
  return z;
}
var BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Testnet4 = "Testnet4", B.Signet = "Signet", B.Regtest = "Regtest", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), getAddress = async (B) => {
  var ne, ie;
  const z = await getProviderOrThrow(B.getProvider), { purposes: Y } = B.payload;
  if (!Y)
    throw new Error("Address purposes are required");
  try {
    const oe = lib$1.createUnsecuredToken(B.payload), se = await z.connect(oe);
    (ne = B.onFinish) == null || ne.call(B, se);
  } catch (oe) {
    console.error("[Connect] Error during address request", oe), (ie = B.onCancel) == null || ie.call(B);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((B) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
async function waitForUnisatExtensionReady() {
  let B = 0;
  const z = 20;
  for (; B < z; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const Y = await window.unisat.getAccounts();
        if (Y && Y.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((Y) => {
      setTimeout(Y, 100);
    });
  }
  return !1;
}
const NETWORK_TO_BITCOIN_NETWORK_TYPE = {
  mainnet: BitcoinNetworkType.Mainnet,
  testnet: BitcoinNetworkType.Testnet,
  signet: BitcoinNetworkType.Signet
}, getXverseAddresses = async (B) => {
  var oe;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((oe = window.XverseProviders) == null ? void 0 : oe.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const Y = async () => window.XverseProviders.BitcoinProvider, ne = [], ie = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: B === Network.TESTNET ? BitcoinNetworkType.Testnet4 : NETWORK_TO_BITCOIN_NETWORK_TYPE[B]
      }
    },
    getProvider: Y,
    onFinish: (se) => {
      if (console.log("==>response", se), !se || !se.addresses || se.addresses.length !== 2)
        throw new BrowserWalletSigningError(
          "Failed to retrieve addresses using selected wallet"
        );
      se.addresses.forEach((ae) => {
        const ge = getAddressFormat(ae.address, B);
        let Ce = ae.publicKey;
        ge === "taproot" && (Ce = Buffer$E.from(ae.publicKey, "hex").length === 33 ? Ce : `02${Ce}`), ne.push({
          publicKey: Ce,
          address: ae.address,
          format: ge
        });
      });
    },
    onCancel: () => {
      throw new BrowserWalletRequestCancelledByUserError();
    }
  };
  return await getAddress(ie), ne;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work\  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: B,
  wallet: z,
  chain: Y = Chain.BITCOIN
}, { readOnly: ne = !1 } = {}) => {
  switch (z) {
    case Wallet.UNISAT: {
      const oe = await getAddresses$3(B === "testnet4" ? "testnet" : B, Y, { readOnly: ne });
      if (!oe || oe.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const se = oe[0];
      return {
        address: {
          ordinals: se.address,
          payments: se.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: se.publicKey
        },
        format: {
          ordinals: se.format,
          payments: se.format
        }
      };
    }
    case Wallet.XVERSE: {
      const ie = await getXverseAddresses(B);
      if (!ie || ie.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const oe = ie.find(
        (ae) => ae.format === "p2sh-p2wpkh" || ae.format === "segwit"
      );
      if (!oe)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const se = ie.find(
        (ae) => ae.format === "taproot"
      );
      if (!se)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: se.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: se.format,
          payments: oe.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const ie = await getAddresses$2(B);
      if (!ie || ie.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const oe = ie.find(
        (ae) => ae.format === "segwit" || ae.format === "p2sh-p2wpkh"
      );
      if (!oe)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const se = ie.find(
        (ae) => ae.format === "taproot"
      );
      if (!se)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: se.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: se.format,
          payments: oe.format
        }
      };
    }
    case Wallet.LEATHER: {
      const ie = await getAddresses$1(B);
      if (!ie || ie.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const oe = ie.find(
        (ae) => ae.format === "segwit"
      );
      if (!oe)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const se = ie.find(
        (ae) => ae.format === "taproot"
      );
      if (!se)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: se.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: se.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: se.format,
          payments: oe.format
        }
      };
    }
    case Wallet.OKX: {
      const ie = await getAddresses(B);
      if (!ie || ie.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const oe = ie[0];
      return {
        address: {
          ordinals: oe.address,
          payments: oe.address
        },
        publicKey: {
          ordinals: oe.publicKey,
          payments: oe.publicKey
        },
        format: {
          ordinals: oe.format,
          payments: oe.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: B,
  onError: z
}) {
  const {
    updateAddress: Y,
    network: ne,
    updateWallet: ie,
    updatePublicKey: oe,
    updateFormat: se,
    disconnectWallet: ae,
    address: ge,
    publicKey: Ce,
    format: le,
    wallet: Ee,
    chain: Je
  } = useOrdConnect(), Ve = (Nt, Dt) => {
    z(Dt.message ?? Dt.toString()), console.error(`Error while connecting to ${Nt} wallet`, Dt), ae(), Dt instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[Nt],
      "_blank",
      "noopener,noreferrer"
    );
  }, $t = async (Nt, { readOnly: Dt = !1 } = {}) => {
    try {
      const { address: Wt, publicKey: Pt, format: Lt } = await connectWallet(
        { network: ne, wallet: Nt, chain: Je },
        { readOnly: Dt }
      );
      return Y({
        ordinals: Wt.ordinals,
        payments: Wt.payments
      }), oe({
        ordinals: Pt.ordinals,
        payments: Pt.payments
      }), ie(Nt), se({
        ordinals: Lt.ordinals,
        payments: Lt.payments
      }), B(), !0;
    } catch (Wt) {
      return console.log("===>err", Wt), Ve(Nt, Wt), !1;
    }
  };
  return useEffect(() => {
    if (Ee !== Wallet.UNISAT)
      return;
    let Nt = !0, Dt = !1;
    const Wt = () => $t(Wallet.UNISAT);
    return ge && Ce && le && (async () => {
      const Lt = await waitForUnisatExtensionReady();
      if (Nt) {
        if (!Lt) {
          ae();
          return;
        }
        Dt = await $t(Wallet.UNISAT, {
          readOnly: !0
        }), Nt && Dt && window.unisat.addListener("accountsChanged", Wt);
      }
    })(), () => {
      Nt = !1, Dt && window.unisat.removeListener("accountsChanged", Wt);
    };
  }, [Ee]), { connectWallet: $t };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  onConnect: z,
  icon: Y,
  renderAvatar: ne,
  isPreferred: ie
}) {
  const oe = isMobileUserAgent(), { wallet: se, address: ae } = useOrdConnect(), [ge, Ce] = useState(!1), le = WALLET_TO_NAME[B], Ee = async () => {
    Ce(!0);
    try {
      await z();
    } catch {
    }
    Ce(!1);
  }, Je = se === B && ae.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Ee,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: Y, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: le }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: oe ? "Available on app" : "" })
        ] }),
        se === B && ae.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          ne ? ne(ae.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: oe ? 12 : 16,
              variant: "beam",
              name: ae.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(ae.ordinals) })
        ] }) : null,
        !Je && ie ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        ge ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: oe ? 20 : 24,
            height: oe ? 20 : 24,
            alt: `${le} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: oe ? 20 : 24,
            height: oe ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: B,
  closeModal: z,
  renderAvatar: Y,
  preferredWallet: ne,
  walletsOrder: ie,
  visibleWallets: oe
}) {
  const [se, ae] = useState(""), { connectWallet: ge } = useConnect({
    onClose: z,
    onError: (Ve) => ae(Ve)
  }), { network: Ce, chain: le } = useOrdConnect(), Ee = isMobileUserAgent(), Je = useMemo(() => {
    const $t = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ge(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: Ee && Ce !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ge(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: Ee,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ge(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ge(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ge(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: Ee,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((Dt) => (oe || []).includes(Dt.wallet)).filter(
      (Dt) => Dt.chains.includes(le) && !Dt.hidden
    );
    return ie ? $t.map((Dt) => {
      const Wt = ie.findIndex(
        (Pt) => Pt === Dt.wallet
      );
      return Wt >= 0 ? { ...Dt, order: Wt } : Dt;
    }).sort((Dt, Wt) => Dt.order - Wt.order) : $t;
  }, [Ee, Ce, ie, ge, oe, le]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ze$1, { appear: !0, show: B, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    yt$1,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: z,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[le],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: z,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: Je.map((Ve, $t) => {
                  const Nt = $t === Je.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Ve.wallet,
                        onConnect: async () => {
                          ae("");
                          const Dt = Ve.onConnect().then((Pt) => (Pt && ae(""), Pt)), Wt = await Promise.race([
                            Dt,
                            new Promise((Pt) => {
                              setTimeout(() => Pt("timeout"), 5e3);
                            })
                          ]);
                          return typeof Wt == "string" ? (ae(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), Dt) : Wt;
                        },
                        icon: Ve.icon,
                        renderAvatar: Y,
                        isPreferred: ne === Ve.wallet
                      }
                    ),
                    !Nt && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Ve.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: se })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: B,
  onViewProfile: z,
  onChangeWalletClick: Y,
  onDisconnectWalletClick: ne,
  renderAvatar: ie,
  preferredWallet: oe,
  walletsOrder: se
}) {
  const {
    address: ae,
    disconnectWallet: ge,
    network: Ce,
    isModalOpen: le,
    openModal: Ee,
    closeModal: Je,
    visibleWallets: Ve
  } = useOrdConnect(), $t = useHasMounted(), Nt = () => B ? null : ae != null && ae.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ae.ordinals,
      network: Ce,
      onViewProfile: z,
      onChangeWallet: () => {
        Ee(), Y == null || Y();
      },
      onDisconnectWallet: () => {
        ge(), ne == null || ne();
      },
      renderAvatar: ie
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !$t, openModal: Ee });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    Nt(),
    $t ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: le,
        closeModal: Je,
        renderAvatar: ie,
        preferredWallet: oe,
        walletsOrder: se,
        visibleWallets: Ve
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var z, Y, ne, ie = Pt.prototype = { constructor: Pt, toString: null, valueOf: null }, oe = new Pt(1), se = 20, ae = 4, ge = -7, Ce = 21, le = -1e7, Ee = 1e7, Je = !1, Ve = 1, $t = 0, Nt = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, Dt = "0123456789abcdefghijklmnopqrstuvwxyz", Wt = !0;
  function Pt(jt, Ct) {
    var Vt, kt, Pe, Xe, ve, Ke, ht, wt, vt = this;
    if (!(vt instanceof Pt)) return new Pt(jt, Ct);
    if (Ct == null) {
      if (jt && jt._isBigNumber === !0) {
        vt.s = jt.s, !jt.c || jt.e > Ee ? vt.c = vt.e = null : jt.e < le ? vt.c = [vt.e = 0] : (vt.e = jt.e, vt.c = jt.c.slice());
        return;
      }
      if ((Ke = typeof jt == "number") && jt * 0 == 0) {
        if (vt.s = 1 / jt < 0 ? (jt = -jt, -1) : 1, jt === ~~jt) {
          for (Xe = 0, ve = jt; ve >= 10; ve /= 10, Xe++) ;
          Xe > Ee ? vt.c = vt.e = null : (vt.e = Xe, vt.c = [jt]);
          return;
        }
        wt = String(jt);
      } else {
        if (!isNumeric.test(wt = String(jt))) return ne(vt, wt, Ke);
        vt.s = wt.charCodeAt(0) == 45 ? (wt = wt.slice(1), -1) : 1;
      }
      (Xe = wt.indexOf(".")) > -1 && (wt = wt.replace(".", "")), (ve = wt.search(/e/i)) > 0 ? (Xe < 0 && (Xe = ve), Xe += +wt.slice(ve + 1), wt = wt.substring(0, ve)) : Xe < 0 && (Xe = wt.length);
    } else {
      if (intCheck(Ct, 2, Dt.length, "Base"), Ct == 10 && Wt)
        return vt = new Pt(jt), Yt(vt, se + vt.e + 1, ae);
      if (wt = String(jt), Ke = typeof jt == "number") {
        if (jt * 0 != 0) return ne(vt, wt, Ke, Ct);
        if (vt.s = 1 / jt < 0 ? (wt = wt.slice(1), -1) : 1, Pt.DEBUG && wt.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + jt);
      } else
        vt.s = wt.charCodeAt(0) === 45 ? (wt = wt.slice(1), -1) : 1;
      for (Vt = Dt.slice(0, Ct), Xe = ve = 0, ht = wt.length; ve < ht; ve++)
        if (Vt.indexOf(kt = wt.charAt(ve)) < 0) {
          if (kt == ".") {
            if (ve > Xe) {
              Xe = ht;
              continue;
            }
          } else if (!Pe && (wt == wt.toUpperCase() && (wt = wt.toLowerCase()) || wt == wt.toLowerCase() && (wt = wt.toUpperCase()))) {
            Pe = !0, ve = -1, Xe = 0;
            continue;
          }
          return ne(vt, String(jt), Ke, Ct);
        }
      Ke = !1, wt = Y(wt, Ct, 10, vt.s), (Xe = wt.indexOf(".")) > -1 ? wt = wt.replace(".", "") : Xe = wt.length;
    }
    for (ve = 0; wt.charCodeAt(ve) === 48; ve++) ;
    for (ht = wt.length; wt.charCodeAt(--ht) === 48; ) ;
    if (wt = wt.slice(ve, ++ht)) {
      if (ht -= ve, Ke && Pt.DEBUG && ht > 15 && (jt > MAX_SAFE_INTEGER$2 || jt !== mathfloor(jt)))
        throw Error(tooManyDigits + vt.s * jt);
      if ((Xe = Xe - ve - 1) > Ee)
        vt.c = vt.e = null;
      else if (Xe < le)
        vt.c = [vt.e = 0];
      else {
        if (vt.e = Xe, vt.c = [], ve = (Xe + 1) % LOG_BASE, Xe < 0 && (ve += LOG_BASE), ve < ht) {
          for (ve && vt.c.push(+wt.slice(0, ve)), ht -= LOG_BASE; ve < ht; )
            vt.c.push(+wt.slice(ve, ve += LOG_BASE));
          ve = LOG_BASE - (wt = wt.slice(ve)).length;
        } else
          ve -= ht;
        for (; ve--; wt += "0") ;
        vt.c.push(+wt);
      }
    } else
      vt.c = [vt.e = 0];
  }
  Pt.clone = clone, Pt.ROUND_UP = 0, Pt.ROUND_DOWN = 1, Pt.ROUND_CEIL = 2, Pt.ROUND_FLOOR = 3, Pt.ROUND_HALF_UP = 4, Pt.ROUND_HALF_DOWN = 5, Pt.ROUND_HALF_EVEN = 6, Pt.ROUND_HALF_CEIL = 7, Pt.ROUND_HALF_FLOOR = 8, Pt.EUCLID = 9, Pt.config = Pt.set = function(jt) {
    var Ct, Vt;
    if (jt != null)
      if (typeof jt == "object") {
        if (jt.hasOwnProperty(Ct = "DECIMAL_PLACES") && (Vt = jt[Ct], intCheck(Vt, 0, MAX, Ct), se = Vt), jt.hasOwnProperty(Ct = "ROUNDING_MODE") && (Vt = jt[Ct], intCheck(Vt, 0, 8, Ct), ae = Vt), jt.hasOwnProperty(Ct = "EXPONENTIAL_AT") && (Vt = jt[Ct], Vt && Vt.pop ? (intCheck(Vt[0], -1e9, 0, Ct), intCheck(Vt[1], 0, MAX, Ct), ge = Vt[0], Ce = Vt[1]) : (intCheck(Vt, -1e9, MAX, Ct), ge = -(Ce = Vt < 0 ? -Vt : Vt))), jt.hasOwnProperty(Ct = "RANGE"))
          if (Vt = jt[Ct], Vt && Vt.pop)
            intCheck(Vt[0], -1e9, -1, Ct), intCheck(Vt[1], 1, MAX, Ct), le = Vt[0], Ee = Vt[1];
          else if (intCheck(Vt, -1e9, MAX, Ct), Vt)
            le = -(Ee = Vt < 0 ? -Vt : Vt);
          else
            throw Error(bignumberError + Ct + " cannot be zero: " + Vt);
        if (jt.hasOwnProperty(Ct = "CRYPTO"))
          if (Vt = jt[Ct], Vt === !!Vt)
            if (Vt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Je = Vt;
              else
                throw Je = !Vt, Error(bignumberError + "crypto unavailable");
            else
              Je = Vt;
          else
            throw Error(bignumberError + Ct + " not true or false: " + Vt);
        if (jt.hasOwnProperty(Ct = "MODULO_MODE") && (Vt = jt[Ct], intCheck(Vt, 0, 9, Ct), Ve = Vt), jt.hasOwnProperty(Ct = "POW_PRECISION") && (Vt = jt[Ct], intCheck(Vt, 0, MAX, Ct), $t = Vt), jt.hasOwnProperty(Ct = "FORMAT"))
          if (Vt = jt[Ct], typeof Vt == "object") Nt = Vt;
          else throw Error(bignumberError + Ct + " not an object: " + Vt);
        if (jt.hasOwnProperty(Ct = "ALPHABET"))
          if (Vt = jt[Ct], typeof Vt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Vt))
            Wt = Vt.slice(0, 10) == "0123456789", Dt = Vt;
          else
            throw Error(bignumberError + Ct + " invalid: " + Vt);
      } else
        throw Error(bignumberError + "Object expected: " + jt);
    return {
      DECIMAL_PLACES: se,
      ROUNDING_MODE: ae,
      EXPONENTIAL_AT: [ge, Ce],
      RANGE: [le, Ee],
      CRYPTO: Je,
      MODULO_MODE: Ve,
      POW_PRECISION: $t,
      FORMAT: Nt,
      ALPHABET: Dt
    };
  }, Pt.isBigNumber = function(jt) {
    if (!jt || jt._isBigNumber !== !0) return !1;
    if (!Pt.DEBUG) return !0;
    var Ct, Vt, kt = jt.c, Pe = jt.e, Xe = jt.s;
    e: if ({}.toString.call(kt) == "[object Array]") {
      if ((Xe === 1 || Xe === -1) && Pe >= -1e9 && Pe <= MAX && Pe === mathfloor(Pe)) {
        if (kt[0] === 0) {
          if (Pe === 0 && kt.length === 1) return !0;
          break e;
        }
        if (Ct = (Pe + 1) % LOG_BASE, Ct < 1 && (Ct += LOG_BASE), String(kt[0]).length == Ct) {
          for (Ct = 0; Ct < kt.length; Ct++)
            if (Vt = kt[Ct], Vt < 0 || Vt >= BASE || Vt !== mathfloor(Vt)) break e;
          if (Vt !== 0) return !0;
        }
      }
    } else if (kt === null && Pe === null && (Xe === null || Xe === 1 || Xe === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + jt);
  }, Pt.maximum = Pt.max = function() {
    return qt(arguments, -1);
  }, Pt.minimum = Pt.min = function() {
    return qt(arguments, 1);
  }, Pt.random = function() {
    var jt = 9007199254740992, Ct = Math.random() * jt & 2097151 ? function() {
      return mathfloor(Math.random() * jt);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Vt) {
      var kt, Pe, Xe, ve, Ke, ht = 0, wt = [], vt = new Pt(oe);
      if (Vt == null ? Vt = se : intCheck(Vt, 0, MAX), ve = mathceil(Vt / LOG_BASE), Je)
        if (crypto.getRandomValues) {
          for (kt = crypto.getRandomValues(new Uint32Array(ve *= 2)); ht < ve; )
            Ke = kt[ht] * 131072 + (kt[ht + 1] >>> 11), Ke >= 9e15 ? (Pe = crypto.getRandomValues(new Uint32Array(2)), kt[ht] = Pe[0], kt[ht + 1] = Pe[1]) : (wt.push(Ke % 1e14), ht += 2);
          ht = ve / 2;
        } else if (crypto.randomBytes) {
          for (kt = crypto.randomBytes(ve *= 7); ht < ve; )
            Ke = (kt[ht] & 31) * 281474976710656 + kt[ht + 1] * 1099511627776 + kt[ht + 2] * 4294967296 + kt[ht + 3] * 16777216 + (kt[ht + 4] << 16) + (kt[ht + 5] << 8) + kt[ht + 6], Ke >= 9e15 ? crypto.randomBytes(7).copy(kt, ht) : (wt.push(Ke % 1e14), ht += 7);
          ht = ve / 7;
        } else
          throw Je = !1, Error(bignumberError + "crypto unavailable");
      if (!Je)
        for (; ht < ve; )
          Ke = Ct(), Ke < 9e15 && (wt[ht++] = Ke % 1e14);
      for (ve = wt[--ht], Vt %= LOG_BASE, ve && Vt && (Ke = POWS_TEN[LOG_BASE - Vt], wt[ht] = mathfloor(ve / Ke) * Ke); wt[ht] === 0; wt.pop(), ht--) ;
      if (ht < 0)
        wt = [Xe = 0];
      else {
        for (Xe = -1; wt[0] === 0; wt.splice(0, 1), Xe -= LOG_BASE) ;
        for (ht = 1, Ke = wt[0]; Ke >= 10; Ke /= 10, ht++) ;
        ht < LOG_BASE && (Xe -= LOG_BASE - ht);
      }
      return vt.e = Xe, vt.c = wt, vt;
    };
  }(), Pt.sum = function() {
    for (var jt = 1, Ct = arguments, Vt = new Pt(Ct[0]); jt < Ct.length; ) Vt = Vt.plus(Ct[jt++]);
    return Vt;
  }, Y = /* @__PURE__ */ function() {
    var jt = "0123456789";
    function Ct(Vt, kt, Pe, Xe) {
      for (var ve, Ke = [0], ht, wt = 0, vt = Vt.length; wt < vt; ) {
        for (ht = Ke.length; ht--; Ke[ht] *= kt) ;
        for (Ke[0] += Xe.indexOf(Vt.charAt(wt++)), ve = 0; ve < Ke.length; ve++)
          Ke[ve] > Pe - 1 && (Ke[ve + 1] == null && (Ke[ve + 1] = 0), Ke[ve + 1] += Ke[ve] / Pe | 0, Ke[ve] %= Pe);
      }
      return Ke.reverse();
    }
    return function(Vt, kt, Pe, Xe, ve) {
      var Ke, ht, wt, vt, xt, Qe, Rt, bt, Ht = Vt.indexOf("."), ar = se, yr = ae;
      for (Ht >= 0 && (vt = $t, $t = 0, Vt = Vt.replace(".", ""), bt = new Pt(kt), Qe = bt.pow(Vt.length - Ht), $t = vt, bt.c = Ct(
        toFixedPoint(coeffToString(Qe.c), Qe.e, "0"),
        10,
        Pe,
        jt
      ), bt.e = bt.c.length), Rt = Ct(Vt, kt, Pe, ve ? (Ke = Dt, jt) : (Ke = jt, Dt)), wt = vt = Rt.length; Rt[--vt] == 0; Rt.pop()) ;
      if (!Rt[0]) return Ke.charAt(0);
      if (Ht < 0 ? --wt : (Qe.c = Rt, Qe.e = wt, Qe.s = Xe, Qe = z(Qe, bt, ar, yr, Pe), Rt = Qe.c, xt = Qe.r, wt = Qe.e), ht = wt + ar + 1, Ht = Rt[ht], vt = Pe / 2, xt = xt || ht < 0 || Rt[ht + 1] != null, xt = yr < 4 ? (Ht != null || xt) && (yr == 0 || yr == (Qe.s < 0 ? 3 : 2)) : Ht > vt || Ht == vt && (yr == 4 || xt || yr == 6 && Rt[ht - 1] & 1 || yr == (Qe.s < 0 ? 8 : 7)), ht < 1 || !Rt[0])
        Vt = xt ? toFixedPoint(Ke.charAt(1), -ar, Ke.charAt(0)) : Ke.charAt(0);
      else {
        if (Rt.length = ht, xt)
          for (--Pe; ++Rt[--ht] > Pe; )
            Rt[ht] = 0, ht || (++wt, Rt = [1].concat(Rt));
        for (vt = Rt.length; !Rt[--vt]; ) ;
        for (Ht = 0, Vt = ""; Ht <= vt; Vt += Ke.charAt(Rt[Ht++])) ;
        Vt = toFixedPoint(Vt, wt, Ke.charAt(0));
      }
      return Vt;
    };
  }(), z = /* @__PURE__ */ function() {
    function jt(kt, Pe, Xe) {
      var ve, Ke, ht, wt, vt = 0, xt = kt.length, Qe = Pe % SQRT_BASE, Rt = Pe / SQRT_BASE | 0;
      for (kt = kt.slice(); xt--; )
        ht = kt[xt] % SQRT_BASE, wt = kt[xt] / SQRT_BASE | 0, ve = Rt * ht + wt * Qe, Ke = Qe * ht + ve % SQRT_BASE * SQRT_BASE + vt, vt = (Ke / Xe | 0) + (ve / SQRT_BASE | 0) + Rt * wt, kt[xt] = Ke % Xe;
      return vt && (kt = [vt].concat(kt)), kt;
    }
    function Ct(kt, Pe, Xe, ve) {
      var Ke, ht;
      if (Xe != ve)
        ht = Xe > ve ? 1 : -1;
      else
        for (Ke = ht = 0; Ke < Xe; Ke++)
          if (kt[Ke] != Pe[Ke]) {
            ht = kt[Ke] > Pe[Ke] ? 1 : -1;
            break;
          }
      return ht;
    }
    function Vt(kt, Pe, Xe, ve) {
      for (var Ke = 0; Xe--; )
        kt[Xe] -= Ke, Ke = kt[Xe] < Pe[Xe] ? 1 : 0, kt[Xe] = Ke * ve + kt[Xe] - Pe[Xe];
      for (; !kt[0] && kt.length > 1; kt.splice(0, 1)) ;
    }
    return function(kt, Pe, Xe, ve, Ke) {
      var ht, wt, vt, xt, Qe, Rt, bt, Ht, ar, yr, rr, Kt, Gt, ur, gr, Qt, Jt, br = kt.s == Pe.s ? 1 : -1, Sr = kt.c, Ar = Pe.c;
      if (!Sr || !Sr[0] || !Ar || !Ar[0])
        return new Pt(
          // Return NaN if either NaN, or both Infinity or 0.
          !kt.s || !Pe.s || (Sr ? Ar && Sr[0] == Ar[0] : !Ar) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            Sr && Sr[0] == 0 || !Ar ? br * 0 : br / 0
          )
        );
      for (Ht = new Pt(br), ar = Ht.c = [], wt = kt.e - Pe.e, br = Xe + wt + 1, Ke || (Ke = BASE, wt = bitFloor(kt.e / LOG_BASE) - bitFloor(Pe.e / LOG_BASE), br = br / LOG_BASE | 0), vt = 0; Ar[vt] == (Sr[vt] || 0); vt++) ;
      if (Ar[vt] > (Sr[vt] || 0) && wt--, br < 0)
        ar.push(1), xt = !0;
      else {
        for (ur = Sr.length, Qt = Ar.length, vt = 0, br += 2, Qe = mathfloor(Ke / (Ar[0] + 1)), Qe > 1 && (Ar = jt(Ar, Qe, Ke), Sr = jt(Sr, Qe, Ke), Qt = Ar.length, ur = Sr.length), Gt = Qt, yr = Sr.slice(0, Qt), rr = yr.length; rr < Qt; yr[rr++] = 0) ;
        Jt = Ar.slice(), Jt = [0].concat(Jt), gr = Ar[0], Ar[1] >= Ke / 2 && gr++;
        do {
          if (Qe = 0, ht = Ct(Ar, yr, Qt, rr), ht < 0) {
            if (Kt = yr[0], Qt != rr && (Kt = Kt * Ke + (yr[1] || 0)), Qe = mathfloor(Kt / gr), Qe > 1)
              for (Qe >= Ke && (Qe = Ke - 1), Rt = jt(Ar, Qe, Ke), bt = Rt.length, rr = yr.length; Ct(Rt, yr, bt, rr) == 1; )
                Qe--, Vt(Rt, Qt < bt ? Jt : Ar, bt, Ke), bt = Rt.length, ht = 1;
            else
              Qe == 0 && (ht = Qe = 1), Rt = Ar.slice(), bt = Rt.length;
            if (bt < rr && (Rt = [0].concat(Rt)), Vt(yr, Rt, rr, Ke), rr = yr.length, ht == -1)
              for (; Ct(Ar, yr, Qt, rr) < 1; )
                Qe++, Vt(yr, Qt < rr ? Jt : Ar, rr, Ke), rr = yr.length;
          } else ht === 0 && (Qe++, yr = [0]);
          ar[vt++] = Qe, yr[0] ? yr[rr++] = Sr[Gt] || 0 : (yr = [Sr[Gt]], rr = 1);
        } while ((Gt++ < ur || yr[0] != null) && br--);
        xt = yr[0] != null, ar[0] || ar.splice(0, 1);
      }
      if (Ke == BASE) {
        for (vt = 1, br = ar[0]; br >= 10; br /= 10, vt++) ;
        Yt(Ht, Xe + (Ht.e = vt + wt * LOG_BASE - 1) + 1, ve, xt);
      } else
        Ht.e = wt, Ht.r = +xt;
      return Ht;
    };
  }();
  function Lt(jt, Ct, Vt, kt) {
    var Pe, Xe, ve, Ke, ht;
    if (Vt == null ? Vt = ae : intCheck(Vt, 0, 8), !jt.c) return jt.toString();
    if (Pe = jt.c[0], ve = jt.e, Ct == null)
      ht = coeffToString(jt.c), ht = kt == 1 || kt == 2 && (ve <= ge || ve >= Ce) ? toExponential(ht, ve) : toFixedPoint(ht, ve, "0");
    else if (jt = Yt(new Pt(jt), Ct, Vt), Xe = jt.e, ht = coeffToString(jt.c), Ke = ht.length, kt == 1 || kt == 2 && (Ct <= Xe || Xe <= ge)) {
      for (; Ke < Ct; ht += "0", Ke++) ;
      ht = toExponential(ht, Xe);
    } else if (Ct -= ve, ht = toFixedPoint(ht, Xe, "0"), Xe + 1 > Ke) {
      if (--Ct > 0) for (ht += "."; Ct--; ht += "0") ;
    } else if (Ct += Xe - Ke, Ct > 0)
      for (Xe + 1 == Ke && (ht += "."); Ct--; ht += "0") ;
    return jt.s < 0 && Pe ? "-" + ht : ht;
  }
  function qt(jt, Ct) {
    for (var Vt, kt, Pe = 1, Xe = new Pt(jt[0]); Pe < jt.length; Pe++)
      kt = new Pt(jt[Pe]), (!kt.s || (Vt = compare(Xe, kt)) === Ct || Vt === 0 && Xe.s === Ct) && (Xe = kt);
    return Xe;
  }
  function Zt(jt, Ct, Vt) {
    for (var kt = 1, Pe = Ct.length; !Ct[--Pe]; Ct.pop()) ;
    for (Pe = Ct[0]; Pe >= 10; Pe /= 10, kt++) ;
    return (Vt = kt + Vt * LOG_BASE - 1) > Ee ? jt.c = jt.e = null : Vt < le ? jt.c = [jt.e = 0] : (jt.e = Vt, jt.c = Ct), jt;
  }
  ne = /* @__PURE__ */ function() {
    var jt = /^(-?)0([xbo])(?=\w[\w.]*$)/i, Ct = /^([^.]+)\.$/, Vt = /^\.([^.]+)$/, kt = /^-?(Infinity|NaN)$/, Pe = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Xe, ve, Ke, ht) {
      var wt, vt = Ke ? ve : ve.replace(Pe, "");
      if (kt.test(vt))
        Xe.s = isNaN(vt) ? null : vt < 0 ? -1 : 1;
      else {
        if (!Ke && (vt = vt.replace(jt, function(xt, Qe, Rt) {
          return wt = (Rt = Rt.toLowerCase()) == "x" ? 16 : Rt == "b" ? 2 : 8, !ht || ht == wt ? Qe : xt;
        }), ht && (wt = ht, vt = vt.replace(Ct, "$1").replace(Vt, "0.$1")), ve != vt))
          return new Pt(vt, wt);
        if (Pt.DEBUG)
          throw Error(bignumberError + "Not a" + (ht ? " base " + ht : "") + " number: " + ve);
        Xe.s = null;
      }
      Xe.c = Xe.e = null;
    };
  }();
  function Yt(jt, Ct, Vt, kt) {
    var Pe, Xe, ve, Ke, ht, wt, vt, xt = jt.c, Qe = POWS_TEN;
    if (xt) {
      e: {
        for (Pe = 1, Ke = xt[0]; Ke >= 10; Ke /= 10, Pe++) ;
        if (Xe = Ct - Pe, Xe < 0)
          Xe += LOG_BASE, ve = Ct, ht = xt[wt = 0], vt = mathfloor(ht / Qe[Pe - ve - 1] % 10);
        else if (wt = mathceil((Xe + 1) / LOG_BASE), wt >= xt.length)
          if (kt) {
            for (; xt.length <= wt; xt.push(0)) ;
            ht = vt = 0, Pe = 1, Xe %= LOG_BASE, ve = Xe - LOG_BASE + 1;
          } else
            break e;
        else {
          for (ht = Ke = xt[wt], Pe = 1; Ke >= 10; Ke /= 10, Pe++) ;
          Xe %= LOG_BASE, ve = Xe - LOG_BASE + Pe, vt = ve < 0 ? 0 : mathfloor(ht / Qe[Pe - ve - 1] % 10);
        }
        if (kt = kt || Ct < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xt[wt + 1] != null || (ve < 0 ? ht : ht % Qe[Pe - ve - 1]), kt = Vt < 4 ? (vt || kt) && (Vt == 0 || Vt == (jt.s < 0 ? 3 : 2)) : vt > 5 || vt == 5 && (Vt == 4 || kt || Vt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Xe > 0 ? ve > 0 ? ht / Qe[Pe - ve] : 0 : xt[wt - 1]) % 10 & 1 || Vt == (jt.s < 0 ? 8 : 7)), Ct < 1 || !xt[0])
          return xt.length = 0, kt ? (Ct -= jt.e + 1, xt[0] = Qe[(LOG_BASE - Ct % LOG_BASE) % LOG_BASE], jt.e = -Ct || 0) : xt[0] = jt.e = 0, jt;
        if (Xe == 0 ? (xt.length = wt, Ke = 1, wt--) : (xt.length = wt + 1, Ke = Qe[LOG_BASE - Xe], xt[wt] = ve > 0 ? mathfloor(ht / Qe[Pe - ve] % Qe[ve]) * Ke : 0), kt)
          for (; ; )
            if (wt == 0) {
              for (Xe = 1, ve = xt[0]; ve >= 10; ve /= 10, Xe++) ;
              for (ve = xt[0] += Ke, Ke = 1; ve >= 10; ve /= 10, Ke++) ;
              Xe != Ke && (jt.e++, xt[0] == BASE && (xt[0] = 1));
              break;
            } else {
              if (xt[wt] += Ke, xt[wt] != BASE) break;
              xt[wt--] = 0, Ke = 1;
            }
        for (Xe = xt.length; xt[--Xe] === 0; xt.pop()) ;
      }
      jt.e > Ee ? jt.c = jt.e = null : jt.e < le && (jt.c = [jt.e = 0]);
    }
    return jt;
  }
  function or(jt) {
    var Ct, Vt = jt.e;
    return Vt === null ? jt.toString() : (Ct = coeffToString(jt.c), Ct = Vt <= ge || Vt >= Ce ? toExponential(Ct, Vt) : toFixedPoint(Ct, Vt, "0"), jt.s < 0 ? "-" + Ct : Ct);
  }
  return ie.absoluteValue = ie.abs = function() {
    var jt = new Pt(this);
    return jt.s < 0 && (jt.s = 1), jt;
  }, ie.comparedTo = function(jt, Ct) {
    return compare(this, new Pt(jt, Ct));
  }, ie.decimalPlaces = ie.dp = function(jt, Ct) {
    var Vt, kt, Pe, Xe = this;
    if (jt != null)
      return intCheck(jt, 0, MAX), Ct == null ? Ct = ae : intCheck(Ct, 0, 8), Yt(new Pt(Xe), jt + Xe.e + 1, Ct);
    if (!(Vt = Xe.c)) return null;
    if (kt = ((Pe = Vt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Pe = Vt[Pe]) for (; Pe % 10 == 0; Pe /= 10, kt--) ;
    return kt < 0 && (kt = 0), kt;
  }, ie.dividedBy = ie.div = function(jt, Ct) {
    return z(this, new Pt(jt, Ct), se, ae);
  }, ie.dividedToIntegerBy = ie.idiv = function(jt, Ct) {
    return z(this, new Pt(jt, Ct), 0, 1);
  }, ie.exponentiatedBy = ie.pow = function(jt, Ct) {
    var Vt, kt, Pe, Xe, ve, Ke, ht, wt, vt, xt = this;
    if (jt = new Pt(jt), jt.c && !jt.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + or(jt));
    if (Ct != null && (Ct = new Pt(Ct)), Ke = jt.e > 14, !xt.c || !xt.c[0] || xt.c[0] == 1 && !xt.e && xt.c.length == 1 || !jt.c || !jt.c[0])
      return vt = new Pt(Math.pow(+or(xt), Ke ? jt.s * (2 - isOdd(jt)) : +or(jt))), Ct ? vt.mod(Ct) : vt;
    if (ht = jt.s < 0, Ct) {
      if (Ct.c ? !Ct.c[0] : !Ct.s) return new Pt(NaN);
      kt = !ht && xt.isInteger() && Ct.isInteger(), kt && (xt = xt.mod(Ct));
    } else {
      if (jt.e > 9 && (xt.e > 0 || xt.e < -1 || (xt.e == 0 ? xt.c[0] > 1 || Ke && xt.c[1] >= 24e7 : xt.c[0] < 8e13 || Ke && xt.c[0] <= 9999975e7)))
        return Xe = xt.s < 0 && isOdd(jt) ? -0 : 0, xt.e > -1 && (Xe = 1 / Xe), new Pt(ht ? 1 / Xe : Xe);
      $t && (Xe = mathceil($t / LOG_BASE + 2));
    }
    for (Ke ? (Vt = new Pt(0.5), ht && (jt.s = 1), wt = isOdd(jt)) : (Pe = Math.abs(+or(jt)), wt = Pe % 2), vt = new Pt(oe); ; ) {
      if (wt) {
        if (vt = vt.times(xt), !vt.c) break;
        Xe ? vt.c.length > Xe && (vt.c.length = Xe) : kt && (vt = vt.mod(Ct));
      }
      if (Pe) {
        if (Pe = mathfloor(Pe / 2), Pe === 0) break;
        wt = Pe % 2;
      } else if (jt = jt.times(Vt), Yt(jt, jt.e + 1, 1), jt.e > 14)
        wt = isOdd(jt);
      else {
        if (Pe = +or(jt), Pe === 0) break;
        wt = Pe % 2;
      }
      xt = xt.times(xt), Xe ? xt.c && xt.c.length > Xe && (xt.c.length = Xe) : kt && (xt = xt.mod(Ct));
    }
    return kt ? vt : (ht && (vt = oe.div(vt)), Ct ? vt.mod(Ct) : Xe ? Yt(vt, $t, ae, ve) : vt);
  }, ie.integerValue = function(jt) {
    var Ct = new Pt(this);
    return jt == null ? jt = ae : intCheck(jt, 0, 8), Yt(Ct, Ct.e + 1, jt);
  }, ie.isEqualTo = ie.eq = function(jt, Ct) {
    return compare(this, new Pt(jt, Ct)) === 0;
  }, ie.isFinite = function() {
    return !!this.c;
  }, ie.isGreaterThan = ie.gt = function(jt, Ct) {
    return compare(this, new Pt(jt, Ct)) > 0;
  }, ie.isGreaterThanOrEqualTo = ie.gte = function(jt, Ct) {
    return (Ct = compare(this, new Pt(jt, Ct))) === 1 || Ct === 0;
  }, ie.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, ie.isLessThan = ie.lt = function(jt, Ct) {
    return compare(this, new Pt(jt, Ct)) < 0;
  }, ie.isLessThanOrEqualTo = ie.lte = function(jt, Ct) {
    return (Ct = compare(this, new Pt(jt, Ct))) === -1 || Ct === 0;
  }, ie.isNaN = function() {
    return !this.s;
  }, ie.isNegative = function() {
    return this.s < 0;
  }, ie.isPositive = function() {
    return this.s > 0;
  }, ie.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, ie.minus = function(jt, Ct) {
    var Vt, kt, Pe, Xe, ve = this, Ke = ve.s;
    if (jt = new Pt(jt, Ct), Ct = jt.s, !Ke || !Ct) return new Pt(NaN);
    if (Ke != Ct)
      return jt.s = -Ct, ve.plus(jt);
    var ht = ve.e / LOG_BASE, wt = jt.e / LOG_BASE, vt = ve.c, xt = jt.c;
    if (!ht || !wt) {
      if (!vt || !xt) return vt ? (jt.s = -Ct, jt) : new Pt(xt ? ve : NaN);
      if (!vt[0] || !xt[0])
        return xt[0] ? (jt.s = -Ct, jt) : new Pt(vt[0] ? ve : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ae == 3 ? -0 : 0
        ));
    }
    if (ht = bitFloor(ht), wt = bitFloor(wt), vt = vt.slice(), Ke = ht - wt) {
      for ((Xe = Ke < 0) ? (Ke = -Ke, Pe = vt) : (wt = ht, Pe = xt), Pe.reverse(), Ct = Ke; Ct--; Pe.push(0)) ;
      Pe.reverse();
    } else
      for (kt = (Xe = (Ke = vt.length) < (Ct = xt.length)) ? Ke : Ct, Ke = Ct = 0; Ct < kt; Ct++)
        if (vt[Ct] != xt[Ct]) {
          Xe = vt[Ct] < xt[Ct];
          break;
        }
    if (Xe && (Pe = vt, vt = xt, xt = Pe, jt.s = -jt.s), Ct = (kt = xt.length) - (Vt = vt.length), Ct > 0) for (; Ct--; vt[Vt++] = 0) ;
    for (Ct = BASE - 1; kt > Ke; ) {
      if (vt[--kt] < xt[kt]) {
        for (Vt = kt; Vt && !vt[--Vt]; vt[Vt] = Ct) ;
        --vt[Vt], vt[kt] += BASE;
      }
      vt[kt] -= xt[kt];
    }
    for (; vt[0] == 0; vt.splice(0, 1), --wt) ;
    return vt[0] ? Zt(jt, vt, wt) : (jt.s = ae == 3 ? -1 : 1, jt.c = [jt.e = 0], jt);
  }, ie.modulo = ie.mod = function(jt, Ct) {
    var Vt, kt, Pe = this;
    return jt = new Pt(jt, Ct), !Pe.c || !jt.s || jt.c && !jt.c[0] ? new Pt(NaN) : !jt.c || Pe.c && !Pe.c[0] ? new Pt(Pe) : (Ve == 9 ? (kt = jt.s, jt.s = 1, Vt = z(Pe, jt, 0, 3), jt.s = kt, Vt.s *= kt) : Vt = z(Pe, jt, 0, Ve), jt = Pe.minus(Vt.times(jt)), !jt.c[0] && Ve == 1 && (jt.s = Pe.s), jt);
  }, ie.multipliedBy = ie.times = function(jt, Ct) {
    var Vt, kt, Pe, Xe, ve, Ke, ht, wt, vt, xt, Qe, Rt, bt, Ht, ar, yr = this, rr = yr.c, Kt = (jt = new Pt(jt, Ct)).c;
    if (!rr || !Kt || !rr[0] || !Kt[0])
      return !yr.s || !jt.s || rr && !rr[0] && !Kt || Kt && !Kt[0] && !rr ? jt.c = jt.e = jt.s = null : (jt.s *= yr.s, !rr || !Kt ? jt.c = jt.e = null : (jt.c = [0], jt.e = 0)), jt;
    for (kt = bitFloor(yr.e / LOG_BASE) + bitFloor(jt.e / LOG_BASE), jt.s *= yr.s, ht = rr.length, xt = Kt.length, ht < xt && (bt = rr, rr = Kt, Kt = bt, Pe = ht, ht = xt, xt = Pe), Pe = ht + xt, bt = []; Pe--; bt.push(0)) ;
    for (Ht = BASE, ar = SQRT_BASE, Pe = xt; --Pe >= 0; ) {
      for (Vt = 0, Qe = Kt[Pe] % ar, Rt = Kt[Pe] / ar | 0, ve = ht, Xe = Pe + ve; Xe > Pe; )
        wt = rr[--ve] % ar, vt = rr[ve] / ar | 0, Ke = Rt * wt + vt * Qe, wt = Qe * wt + Ke % ar * ar + bt[Xe] + Vt, Vt = (wt / Ht | 0) + (Ke / ar | 0) + Rt * vt, bt[Xe--] = wt % Ht;
      bt[Xe] = Vt;
    }
    return Vt ? ++kt : bt.splice(0, 1), Zt(jt, bt, kt);
  }, ie.negated = function() {
    var jt = new Pt(this);
    return jt.s = -jt.s || null, jt;
  }, ie.plus = function(jt, Ct) {
    var Vt, kt = this, Pe = kt.s;
    if (jt = new Pt(jt, Ct), Ct = jt.s, !Pe || !Ct) return new Pt(NaN);
    if (Pe != Ct)
      return jt.s = -Ct, kt.minus(jt);
    var Xe = kt.e / LOG_BASE, ve = jt.e / LOG_BASE, Ke = kt.c, ht = jt.c;
    if (!Xe || !ve) {
      if (!Ke || !ht) return new Pt(Pe / 0);
      if (!Ke[0] || !ht[0]) return ht[0] ? jt : new Pt(Ke[0] ? kt : Pe * 0);
    }
    if (Xe = bitFloor(Xe), ve = bitFloor(ve), Ke = Ke.slice(), Pe = Xe - ve) {
      for (Pe > 0 ? (ve = Xe, Vt = ht) : (Pe = -Pe, Vt = Ke), Vt.reverse(); Pe--; Vt.push(0)) ;
      Vt.reverse();
    }
    for (Pe = Ke.length, Ct = ht.length, Pe - Ct < 0 && (Vt = ht, ht = Ke, Ke = Vt, Ct = Pe), Pe = 0; Ct; )
      Pe = (Ke[--Ct] = Ke[Ct] + ht[Ct] + Pe) / BASE | 0, Ke[Ct] = BASE === Ke[Ct] ? 0 : Ke[Ct] % BASE;
    return Pe && (Ke = [Pe].concat(Ke), ++ve), Zt(jt, Ke, ve);
  }, ie.precision = ie.sd = function(jt, Ct) {
    var Vt, kt, Pe, Xe = this;
    if (jt != null && jt !== !!jt)
      return intCheck(jt, 1, MAX), Ct == null ? Ct = ae : intCheck(Ct, 0, 8), Yt(new Pt(Xe), jt, Ct);
    if (!(Vt = Xe.c)) return null;
    if (Pe = Vt.length - 1, kt = Pe * LOG_BASE + 1, Pe = Vt[Pe]) {
      for (; Pe % 10 == 0; Pe /= 10, kt--) ;
      for (Pe = Vt[0]; Pe >= 10; Pe /= 10, kt++) ;
    }
    return jt && Xe.e + 1 > kt && (kt = Xe.e + 1), kt;
  }, ie.shiftedBy = function(jt) {
    return intCheck(jt, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + jt);
  }, ie.squareRoot = ie.sqrt = function() {
    var jt, Ct, Vt, kt, Pe, Xe = this, ve = Xe.c, Ke = Xe.s, ht = Xe.e, wt = se + 4, vt = new Pt("0.5");
    if (Ke !== 1 || !ve || !ve[0])
      return new Pt(!Ke || Ke < 0 && (!ve || ve[0]) ? NaN : ve ? Xe : 1 / 0);
    if (Ke = Math.sqrt(+or(Xe)), Ke == 0 || Ke == 1 / 0 ? (Ct = coeffToString(ve), (Ct.length + ht) % 2 == 0 && (Ct += "0"), Ke = Math.sqrt(+Ct), ht = bitFloor((ht + 1) / 2) - (ht < 0 || ht % 2), Ke == 1 / 0 ? Ct = "5e" + ht : (Ct = Ke.toExponential(), Ct = Ct.slice(0, Ct.indexOf("e") + 1) + ht), Vt = new Pt(Ct)) : Vt = new Pt(Ke + ""), Vt.c[0]) {
      for (ht = Vt.e, Ke = ht + wt, Ke < 3 && (Ke = 0); ; )
        if (Pe = Vt, Vt = vt.times(Pe.plus(z(Xe, Pe, wt, 1))), coeffToString(Pe.c).slice(0, Ke) === (Ct = coeffToString(Vt.c)).slice(0, Ke))
          if (Vt.e < ht && --Ke, Ct = Ct.slice(Ke - 3, Ke + 1), Ct == "9999" || !kt && Ct == "4999") {
            if (!kt && (Yt(Pe, Pe.e + se + 2, 0), Pe.times(Pe).eq(Xe))) {
              Vt = Pe;
              break;
            }
            wt += 4, Ke += 4, kt = 1;
          } else {
            (!+Ct || !+Ct.slice(1) && Ct.charAt(0) == "5") && (Yt(Vt, Vt.e + se + 2, 1), jt = !Vt.times(Vt).eq(Xe));
            break;
          }
    }
    return Yt(Vt, Vt.e + se + 1, ae, jt);
  }, ie.toExponential = function(jt, Ct) {
    return jt != null && (intCheck(jt, 0, MAX), jt++), Lt(this, jt, Ct, 1);
  }, ie.toFixed = function(jt, Ct) {
    return jt != null && (intCheck(jt, 0, MAX), jt = jt + this.e + 1), Lt(this, jt, Ct);
  }, ie.toFormat = function(jt, Ct, Vt) {
    var kt, Pe = this;
    if (Vt == null)
      jt != null && Ct && typeof Ct == "object" ? (Vt = Ct, Ct = null) : jt && typeof jt == "object" ? (Vt = jt, jt = Ct = null) : Vt = Nt;
    else if (typeof Vt != "object")
      throw Error(bignumberError + "Argument not an object: " + Vt);
    if (kt = Pe.toFixed(jt, Ct), Pe.c) {
      var Xe, ve = kt.split("."), Ke = +Vt.groupSize, ht = +Vt.secondaryGroupSize, wt = Vt.groupSeparator || "", vt = ve[0], xt = ve[1], Qe = Pe.s < 0, Rt = Qe ? vt.slice(1) : vt, bt = Rt.length;
      if (ht && (Xe = Ke, Ke = ht, ht = Xe, bt -= Xe), Ke > 0 && bt > 0) {
        for (Xe = bt % Ke || Ke, vt = Rt.substr(0, Xe); Xe < bt; Xe += Ke) vt += wt + Rt.substr(Xe, Ke);
        ht > 0 && (vt += wt + Rt.slice(Xe)), Qe && (vt = "-" + vt);
      }
      kt = xt ? vt + (Vt.decimalSeparator || "") + ((ht = +Vt.fractionGroupSize) ? xt.replace(
        new RegExp("\\d{" + ht + "}\\B", "g"),
        "$&" + (Vt.fractionGroupSeparator || "")
      ) : xt) : vt;
    }
    return (Vt.prefix || "") + kt + (Vt.suffix || "");
  }, ie.toFraction = function(jt) {
    var Ct, Vt, kt, Pe, Xe, ve, Ke, ht, wt, vt, xt, Qe, Rt = this, bt = Rt.c;
    if (jt != null && (Ke = new Pt(jt), !Ke.isInteger() && (Ke.c || Ke.s !== 1) || Ke.lt(oe)))
      throw Error(bignumberError + "Argument " + (Ke.isInteger() ? "out of range: " : "not an integer: ") + or(Ke));
    if (!bt) return new Pt(Rt);
    for (Ct = new Pt(oe), wt = Vt = new Pt(oe), kt = ht = new Pt(oe), Qe = coeffToString(bt), Xe = Ct.e = Qe.length - Rt.e - 1, Ct.c[0] = POWS_TEN[(ve = Xe % LOG_BASE) < 0 ? LOG_BASE + ve : ve], jt = !jt || Ke.comparedTo(Ct) > 0 ? Xe > 0 ? Ct : wt : Ke, ve = Ee, Ee = 1 / 0, Ke = new Pt(Qe), ht.c[0] = 0; vt = z(Ke, Ct, 0, 1), Pe = Vt.plus(vt.times(kt)), Pe.comparedTo(jt) != 1; )
      Vt = kt, kt = Pe, wt = ht.plus(vt.times(Pe = wt)), ht = Pe, Ct = Ke.minus(vt.times(Pe = Ct)), Ke = Pe;
    return Pe = z(jt.minus(Vt), kt, 0, 1), ht = ht.plus(Pe.times(wt)), Vt = Vt.plus(Pe.times(kt)), ht.s = wt.s = Rt.s, Xe = Xe * 2, xt = z(wt, kt, Xe, ae).minus(Rt).abs().comparedTo(
      z(ht, Vt, Xe, ae).minus(Rt).abs()
    ) < 1 ? [wt, kt] : [ht, Vt], Ee = ve, xt;
  }, ie.toNumber = function() {
    return +or(this);
  }, ie.toPrecision = function(jt, Ct) {
    return jt != null && intCheck(jt, 1, MAX), Lt(this, jt, Ct, 2);
  }, ie.toString = function(jt) {
    var Ct, Vt = this, kt = Vt.s, Pe = Vt.e;
    return Pe === null ? kt ? (Ct = "Infinity", kt < 0 && (Ct = "-" + Ct)) : Ct = "NaN" : (jt == null ? Ct = Pe <= ge || Pe >= Ce ? toExponential(coeffToString(Vt.c), Pe) : toFixedPoint(coeffToString(Vt.c), Pe, "0") : jt === 10 && Wt ? (Vt = Yt(new Pt(Vt), se + Pe + 1, ae), Ct = toFixedPoint(coeffToString(Vt.c), Vt.e, "0")) : (intCheck(jt, 2, Dt.length, "Base"), Ct = Y(toFixedPoint(coeffToString(Vt.c), Pe, "0"), 10, jt, kt, !0)), kt < 0 && Vt.c[0] && (Ct = "-" + Ct)), Ct;
  }, ie.valueOf = ie.toJSON = function() {
    return or(this);
  }, ie._isBigNumber = !0, ie[Symbol.toStringTag] = "BigNumber", ie[Symbol.for("nodejs.util.inspect.custom")] = ie.valueOf, B != null && Pt.set(B), Pt;
}
function bitFloor(B) {
  var z = B | 0;
  return B > 0 || B === z ? z : z - 1;
}
function coeffToString(B) {
  for (var z, Y, ne = 1, ie = B.length, oe = B[0] + ""; ne < ie; ) {
    for (z = B[ne++] + "", Y = LOG_BASE - z.length; Y--; z = "0" + z) ;
    oe += z;
  }
  for (ie = oe.length; oe.charCodeAt(--ie) === 48; ) ;
  return oe.slice(0, ie + 1 || 1);
}
function compare(B, z) {
  var Y, ne, ie = B.c, oe = z.c, se = B.s, ae = z.s, ge = B.e, Ce = z.e;
  if (!se || !ae) return null;
  if (Y = ie && !ie[0], ne = oe && !oe[0], Y || ne) return Y ? ne ? 0 : -ae : se;
  if (se != ae) return se;
  if (Y = se < 0, ne = ge == Ce, !ie || !oe) return ne ? 0 : !ie ^ Y ? 1 : -1;
  if (!ne) return ge > Ce ^ Y ? 1 : -1;
  for (ae = (ge = ie.length) < (Ce = oe.length) ? ge : Ce, se = 0; se < ae; se++) if (ie[se] != oe[se]) return ie[se] > oe[se] ^ Y ? 1 : -1;
  return ge == Ce ? 0 : ge > Ce ^ Y ? 1 : -1;
}
function intCheck(B, z, Y, ne) {
  if (B < z || B > Y || B !== mathfloor(B))
    throw Error(bignumberError + (ne || "Argument") + (typeof B == "number" ? B < z || B > Y ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var z = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == z && B.c[z] % 2 != 0;
}
function toExponential(B, z) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (z < 0 ? "e" : "e+") + z;
}
function toFixedPoint(B, z, Y) {
  var ne, ie;
  if (z < 0) {
    for (ie = Y + "."; ++z; ie += Y) ;
    B = ie + B;
  } else if (ne = B.length, ++z > ne) {
    for (ie = Y, z -= ne; --z; ie += Y) ;
    B += ie;
  } else z < ne && (B = B.slice(0, z) + "." + B.slice(z));
  return B;
}
var BigNumber = clone();
function useBalance() {
  const { network: B, publicKey: z, format: Y, chain: ne } = useOrdConnect(), [ie, oe] = useState(null), [se, ae] = useState(!1);
  return { getBalance: useCallback(async () => {
    ae(!0);
    try {
      if (oe(null), !Y || !Y.payments || !z || !z.payments)
        throw new Error("No wallet is connected");
      const { address: Ce } = getAddressesFromPublicKey(
        z.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[Y.payments],
        ne
      )[0], Ee = await new JsonRpcDatasource({
        chain: ne,
        network: B
      }).getBalance({ address: Ce }), Je = Number(
        new BigNumber(Ee).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return ae(!1), Je;
    } catch (Ce) {
      throw oe(Ce.message), ae(!1), Ce;
    }
  }, [Y, B, z]), error: ie, loading: se };
}
async function signPsbt({
  address: B,
  wallet: z,
  network: Y,
  psbt: ne,
  options: ie
}) {
  var ge, Ce;
  if ((ge = ie == null ? void 0 : ie.signingIndexes) != null && ge.length && ((Ce = ie == null ? void 0 : ie.inputsToSign) != null && Ce.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const oe = (ie == null ? void 0 : ie.finalize) ?? !0, se = (ie == null ? void 0 : ie.extractTx) ?? !0, ae = () => ne.data.inputs.map((le, Ee) => Ee);
  if (z === Wallet.MAGICEDEN)
    return await signPsbt$1(ne, {
      network: Y,
      inputsToSign: (ie == null ? void 0 : ie.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae(),
          sigHash: ie == null ? void 0 : ie.sigHash
        }
      ],
      finalize: oe,
      extractTx: se
    });
  if (z === Wallet.UNISAT)
    return await signPsbt$2(ne, {
      finalize: oe,
      extractTx: se
    });
  if (z === Wallet.XVERSE)
    return await signPsbt$3(ne, {
      network: Y,
      inputsToSign: (ie == null ? void 0 : ie.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae(),
          // If signingIndexes is not provided, just sign everything
          sigHash: ie == null ? void 0 : ie.sigHash
        }
      ],
      finalize: oe,
      extractTx: se
    });
  if (z === Wallet.LEATHER)
    return await signPsbt$4(ne, {
      network: Y,
      finalize: oe,
      extractTx: se,
      allowedSighash: ie != null && ie.sigHash ? [ie == null ? void 0 : ie.sigHash] : [],
      signAtIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae()
      // If signingIndexes is not provided, just sign everything
    });
  if (z === Wallet.OKX)
    return await signPsbt$5(ne, {
      finalize: oe,
      extractTx: se,
      network: Y,
      inputsToSign: (ie == null ? void 0 : ie.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (ie == null ? void 0 : ie.signingIndexes) ?? ae(),
          // If signingIndexes is not provided, just sign everything
          sigHash: ie == null ? void 0 : ie.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: ie } = useOrdConnect(), [oe, se] = useState(null), [ae, ge] = useState(!1);
  return { send: useCallback(
    async (le, Ee, Je, Ve = !0) => {
      ge(!0);
      try {
        if (se(null), !Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const $t = new PSBTBuilder({
          address: Y.payments,
          feeRate: Je,
          network: z,
          chain: ie,
          publicKey: ne.payments,
          outputs: [
            {
              address: le,
              value: Ee
            }
          ]
        });
        await $t.prepare();
        const Nt = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: $t.toPSBT()
        });
        if (Ve) {
          const Wt = await new JsonRpcDatasource({ network: z, chain: ie }).relay({ hex: Nt.hex });
          return ge(!1), Wt;
        }
        return ge(!1), Nt.hex;
      } catch ($t) {
        return se($t.message), ge(!1), null;
      }
    },
    [Y, z, ne, B]
  ), error: oe, loading: ae };
}
function useSendV2() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: ie } = useOrdConnect(), [oe, se] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ge,
      satoshis: Ce,
      feeRate: le,
      relay: Ee = !0,
      rbf: Je = !1
    }) => {
      se(!0);
      try {
        if (!Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Ve = new PSBTBuilder({
          address: Y.payments,
          feeRate: le,
          network: z,
          chain: ie,
          publicKey: ne.payments,
          outputs: [
            {
              address: ge,
              value: Ce
            }
          ]
        });
        Ve.setRBF(Je), await Ve.prepare();
        const $t = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Ve.toPSBT()
        });
        if (Ee) {
          const Dt = await new JsonRpcDatasource({ network: z, chain: ie }).relay({ hex: $t.hex });
          return se(!1), {
            txId: Dt
          };
        }
        return se(!1), {
          signedPsbtHex: $t.hex
        };
      } catch (Ve) {
        return se(!1), {
          error: Ve.message
        };
      }
    },
    [Y, z, ne, B]
  ), isLoading: oe };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const z = B[3];
  if (z === 0 || 5 + z >= B.length || B[4 + z] !== 2) return !1;
  const Y = B[5 + z];
  return !(Y === 0 || 6 + z + Y !== B.length || B[4] & 128 || z > 1 && B[4] === 0 && !(B[5] & 128) || B[z + 6] & 128 || Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128));
}
bip66.check = check$d;
function decode$h(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const z = B[3];
  if (z === 0) throw new Error("R length is zero");
  if (5 + z >= B.length) throw new Error("R length is too long");
  if (B[4 + z] !== 2) throw new Error("Expected DER integer (2)");
  const Y = B[5 + z];
  if (Y === 0) throw new Error("S length is zero");
  if (6 + z + Y !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (z > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[z + 6] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + z),
    s: B.slice(6 + z)
  };
}
bip66.decode = decode$h;
function encode$i(B, z) {
  const Y = B.length, ne = z.length;
  if (Y === 0) throw new Error("R length is zero");
  if (ne === 0) throw new Error("S length is zero");
  if (Y > 33) throw new Error("R length is too long");
  if (ne > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (z[0] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (ne > 1 && z[0] === 0 && !(z[1] & 128))
    throw new Error("S value excessively padded");
  const ie = Buffer$D.allocUnsafe(6 + Y + ne);
  return ie[0] = 48, ie[1] = ie.length - 2, ie[2] = 2, ie[3] = B.length, B.copy(ie, 4), ie[4 + Y] = 2, ie[5 + Y] = z.length, z.copy(ie, 6 + Y), ie;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const z = OPS$7[B];
  REVERSE_OPS[z] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(B, z, Y) {
  const ne = encodingLength$2(z);
  return ne === 1 ? B.writeUInt8(z, Y) : ne === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, Y), B.writeUInt8(z, Y + 1)) : ne === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, Y), B.writeUInt16LE(z, Y + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, Y), B.writeUInt32LE(z, Y + 1)), ne;
}
push_data.encode = encode$h;
function decode$g(B, z) {
  const Y = B.readUInt8(z);
  let ne, ie;
  if (Y < ops_1.OPS.OP_PUSHDATA1)
    ne = Y, ie = 1;
  else if (Y === ops_1.OPS.OP_PUSHDATA1) {
    if (z + 2 > B.length) return null;
    ne = B.readUInt8(z + 1), ie = 2;
  } else if (Y === ops_1.OPS.OP_PUSHDATA2) {
    if (z + 3 > B.length) return null;
    ne = B.readUInt16LE(z + 1), ie = 3;
  } else {
    if (z + 5 > B.length) return null;
    if (Y !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    ne = B.readUInt32LE(z + 1), ie = 5;
  }
  return {
    opcode: Y,
    number: ne,
    size: ie
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(B, z, Y) {
  z = z || 4, Y = Y === void 0 ? !0 : Y;
  const ne = B.length;
  if (ne === 0) return 0;
  if (ne > z) throw new TypeError("Script number overflow");
  if (Y && !(B[ne - 1] & 127) && (ne <= 1 || !(B[ne - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (ne === 5) {
    const oe = B.readUInt32LE(0), se = B.readUInt8(4);
    return se & 128 ? -((se & -129) * 4294967296 + oe) : se * 4294967296 + oe;
  }
  let ie = 0;
  for (let oe = 0; oe < ne; ++oe)
    ie |= B[oe] << 8 * oe;
  return B[ne - 1] & 128 ? -(ie & ~(128 << 8 * (ne - 1))) : ie;
}
script_number.decode = decode$f;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$g(B) {
  let z = Math.abs(B);
  const Y = scriptNumSize(z), ne = Buffer$D.allocUnsafe(Y), ie = B < 0;
  for (let oe = 0; oe < Y; ++oe)
    ne.writeUInt8(z & 255, oe), z >>= 8;
  return ne[Y - 1] & 128 ? ne.writeUInt8(ie ? 128 : 0, Y - 1) : ie && (ne[Y - 1] |= 128), ne;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, z) {
  Error.captureStackTrace && Error.captureStackTrace(B, z);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, z, Y) {
  var ne = getValue(z);
  return "Expected " + tfJSON$1(B) + ", got" + (Y !== "" ? " " + Y : "") + (ne !== "" ? " " + ne : "");
}
function TfTypeError$1(B, z, Y) {
  Y = Y || getValueTypeName$1(z), this.message = tfErrorString(B, z, Y), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = z, this.__valueTypeName = Y;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, z, Y, ne, ie) {
  var oe = '" of type ';
  return z === "key" && (oe = '" with key type '), tfErrorString('property "' + tfJSON$1(Y) + oe + tfJSON$1(B), ne, ie);
}
function TfPropertyTypeError$1(B, z, Y, ne, ie) {
  B ? (ie = ie || getValueTypeName$1(ne), this.message = tfPropertyErrorString(B, Y, z, ne, ie)) : this.message = 'Unexpected property "' + z + '"', captureStackTrace(this, TfTypeError$1), this.__label = Y, this.__property = z, this.__type = B, this.__value = ne, this.__valueTypeName = ie;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, z) {
  return new TfTypeError$1(B, {}, z);
}
function tfSubError$1(B, z, Y) {
  return B instanceof TfPropertyTypeError$1 ? (z = z + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    z,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    z,
    Y,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, z = errors;
  function Y(Yt) {
    return Buffer$D.isBuffer(Yt);
  }
  function ne(Yt) {
    return typeof Yt == "string" && /^([0-9a-f]{2})+$/i.test(Yt);
  }
  function ie(Yt, or) {
    var jt = Yt.toJSON();
    function Ct(Vt) {
      if (!Yt(Vt)) return !1;
      if (Vt.length === or) return !0;
      throw z.tfCustomError(jt + "(Length: " + or + ")", jt + "(Length: " + Vt.length + ")");
    }
    return Ct.toJSON = function() {
      return jt;
    }, Ct;
  }
  var oe = ie.bind(null, B.Array), se = ie.bind(null, Y), ae = ie.bind(null, ne), ge = ie.bind(null, B.String);
  function Ce(Yt, or, jt) {
    jt = jt || B.Number;
    function Ct(Vt, kt) {
      return jt(Vt, kt) && Vt > Yt && Vt < or;
    }
    return Ct.toJSON = function() {
      return `${jt.toJSON()} between [${Yt}, ${or}]`;
    }, Ct;
  }
  var le = Math.pow(2, 53) - 1;
  function Ee(Yt) {
    return typeof Yt == "number" && isFinite(Yt);
  }
  function Je(Yt) {
    return Yt << 24 >> 24 === Yt;
  }
  function Ve(Yt) {
    return Yt << 16 >> 16 === Yt;
  }
  function $t(Yt) {
    return (Yt | 0) === Yt;
  }
  function Nt(Yt) {
    return typeof Yt == "number" && Yt >= -le && Yt <= le && Math.floor(Yt) === Yt;
  }
  function Dt(Yt) {
    return (Yt & 255) === Yt;
  }
  function Wt(Yt) {
    return (Yt & 65535) === Yt;
  }
  function Pt(Yt) {
    return Yt >>> 0 === Yt;
  }
  function Lt(Yt) {
    return typeof Yt == "number" && Yt >= 0 && Yt <= le && Math.floor(Yt) === Yt;
  }
  var qt = {
    ArrayN: oe,
    Buffer: Y,
    BufferN: se,
    Finite: Ee,
    Hex: ne,
    HexN: ae,
    Int8: Je,
    Int16: Ve,
    Int32: $t,
    Int53: Nt,
    Range: Ce,
    StringN: ge,
    UInt8: Dt,
    UInt16: Wt,
    UInt32: Pt,
    UInt53: Lt
  };
  for (var Zt in qt)
    qt[Zt].toJSON = (function(Yt) {
      return Yt;
    }).bind(null, Zt);
  return extra = qt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function B(z, Y) {
    z = compile(z), Y = Y || {};
    function ne(ie, oe) {
      return !NATIVE.Array(ie) || NATIVE.Nil(ie) || Y.minLength !== void 0 && ie.length < Y.minLength || Y.maxLength !== void 0 && ie.length > Y.maxLength || Y.length !== void 0 && ie.length !== Y.length ? !1 : ie.every(function(se, ae) {
        try {
          return typeforce$3(z, se, oe);
        } catch (ge) {
          throw tfSubError(ge, ae);
        }
      });
    }
    return ne.toJSON = function() {
      var ie = "[" + tfJSON(z) + "]";
      return Y.length !== void 0 ? ie += "{" + Y.length + "}" : (Y.minLength !== void 0 || Y.maxLength !== void 0) && (ie += "{" + (Y.minLength === void 0 ? 0 : Y.minLength) + "," + (Y.maxLength === void 0 ? 1 / 0 : Y.maxLength) + "}"), ie;
    }, ne;
  },
  maybe: function B(z) {
    z = compile(z);
    function Y(ne, ie) {
      return NATIVE.Nil(ne) || z(ne, ie, B);
    }
    return Y.toJSON = function() {
      return "?" + tfJSON(z);
    }, Y;
  },
  map: function B(z, Y) {
    z = compile(z), Y && (Y = compile(Y));
    function ne(ie, oe) {
      if (!NATIVE.Object(ie) || NATIVE.Nil(ie)) return !1;
      for (var se in ie) {
        try {
          Y && typeforce$3(Y, se, oe);
        } catch (ge) {
          throw tfSubError(ge, se, "key");
        }
        try {
          var ae = ie[se];
          typeforce$3(z, ae, oe);
        } catch (ge) {
          throw tfSubError(ge, se);
        }
      }
      return !0;
    }
    return Y ? ne.toJSON = function() {
      return "{" + tfJSON(Y) + ": " + tfJSON(z) + "}";
    } : ne.toJSON = function() {
      return "{" + tfJSON(z) + "}";
    }, ne;
  },
  object: function B(z) {
    var Y = {};
    for (var ne in z)
      Y[ne] = compile(z[ne]);
    function ie(oe, se) {
      if (!NATIVE.Object(oe) || NATIVE.Nil(oe)) return !1;
      var ae;
      try {
        for (ae in Y) {
          var ge = Y[ae], Ce = oe[ae];
          typeforce$3(ge, Ce, se);
        }
      } catch (le) {
        throw tfSubError(le, ae);
      }
      if (se) {
        for (ae in oe)
          if (!Y[ae])
            throw new TfPropertyTypeError(void 0, ae);
      }
      return !0;
    }
    return ie.toJSON = function() {
      return tfJSON(Y);
    }, ie;
  },
  anyOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ie) {
      return z.some(function(oe) {
        try {
          return typeforce$3(oe, ne, ie);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join("|");
    }, Y;
  },
  allOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ie) {
      return z.every(function(oe) {
        try {
          return typeforce$3(oe, ne, ie);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join(" & ");
    }, Y;
  },
  quacksLike: function B(z) {
    function Y(ne) {
      return z === getValueTypeName(ne);
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  },
  tuple: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, ie) {
      return NATIVE.Nil(ne) || NATIVE.Nil(ne.length) || ie && ne.length !== z.length ? !1 : z.every(function(oe, se) {
        try {
          return typeforce$3(oe, ne[se], ie);
        } catch (ae) {
          throw tfSubError(ae, se);
        }
      });
    }
    return Y.toJSON = function() {
      return "(" + z.map(tfJSON).join(", ") + ")";
    }, Y;
  },
  value: function B(z) {
    function Y(ne) {
      return ne === z;
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$3(B, z, Y, ne) {
  if (NATIVE.Function(B)) {
    if (B(z, Y)) return !0;
    throw new TfTypeError(ne || B, z);
  }
  return typeforce$3(compile(B), z, Y);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const z = dist$1;
  B.typeforce = typeforce_1;
  const Y = z.Buffer.alloc(32, 0), ne = z.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function ie(le, Ee) {
    return le.length !== Ee.length ? !1 : le.every((Je, Ve) => Je.equals(Ee[Ve]));
  }
  B.stacksEqual = ie;
  function oe(le) {
    if (!z.Buffer.isBuffer(le) || le.length < 33) return !1;
    const Ee = le[0], Je = le.slice(1, 33);
    if (Je.compare(Y) === 0 || Je.compare(ne) >= 0) return !1;
    if ((Ee === 2 || Ee === 3) && le.length === 33)
      return !0;
    const Ve = le.slice(33);
    return Ve.compare(Y) === 0 || Ve.compare(ne) >= 0 ? !1 : Ee === 4 && le.length === 65;
  }
  B.isPoint = oe;
  const se = 21 * 1e14;
  function ae(le) {
    return B.typeforce.UInt53(le) && le <= se;
  }
  B.Satoshi = ae, B.TAPLEAF_VERSION_MASK = 254;
  function ge(le) {
    return !le || !("output" in le) || !z.Buffer.isBuffer(le.output) ? !1 : le.version !== void 0 ? (le.version & B.TAPLEAF_VERSION_MASK) === le.version : !0;
  }
  B.isTapleaf = ge;
  function Ce(le) {
    return (0, B.Array)(le) ? le.length !== 2 ? !1 : le.every((Ee) => Ce(Ee)) : ge(le);
  }
  B.isTaptree = Ce, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, z = requireScript(), Y = types$4, { typeforce: ne } = Y, ie = Buffer$D.alloc(1, 0);
  function oe(Ce) {
    let le = 0;
    for (; Ce[le] === 0; ) ++le;
    return le === Ce.length ? ie : (Ce = Ce.slice(le), Ce[0] & 128 ? Buffer$D.concat([ie, Ce], 1 + Ce.length) : Ce);
  }
  function se(Ce) {
    Ce[0] === 0 && (Ce = Ce.slice(1));
    const le = Buffer$D.alloc(32, 0), Ee = Math.max(0, 32 - Ce.length);
    return Ce.copy(le, Ee), le;
  }
  function ae(Ce) {
    const le = Ce.readUInt8(Ce.length - 1);
    if (!(0, z.isDefinedHashType)(le))
      throw new Error("Invalid hashType " + le);
    const Ee = B.decode(Ce.slice(0, -1)), Je = se(Ee.r), Ve = se(Ee.s);
    return { signature: Buffer$D.concat([Je, Ve], 64), hashType: le };
  }
  script_signature.decode = ae;
  function ge(Ce, le) {
    if (ne(
      {
        signature: Y.BufferN(64),
        hashType: Y.UInt8
      },
      { signature: Ce, hashType: le }
    ), !(0, z.isDefinedHashType)(le))
      throw new Error("Invalid hashType " + le);
    const Ee = Buffer$D.allocUnsafe(1);
    Ee.writeUInt8(le, 0);
    const Je = oe(Ce.slice(0, 32)), Ve = oe(Ce.slice(32, 64));
    return Buffer$D.concat([B.encode(Je, Ve), Ee]);
  }
  return script_signature.encode = ge, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const z = bip66, Y = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return Y.OPS;
      }
    });
    const ne = push_data, ie = script_number, oe = requireScript_signature(), se = types$4, { typeforce: ae } = se, ge = Y.OPS.OP_RESERVED;
    function Ce(Ct) {
      return se.Number(Ct) && (Ct === Y.OPS.OP_0 || Ct >= Y.OPS.OP_1 && Ct <= Y.OPS.OP_16 || Ct === Y.OPS.OP_1NEGATE);
    }
    function le(Ct) {
      return se.Buffer(Ct) || Ce(Ct);
    }
    function Ee(Ct) {
      return se.Array(Ct) && Ct.every(le);
    }
    B.isPushOnly = Ee;
    function Je(Ct) {
      return Ct.length - Ct.filter(le).length;
    }
    B.countNonPushOnlyOPs = Je;
    function Ve(Ct) {
      if (Ct.length === 0) return Y.OPS.OP_0;
      if (Ct.length === 1) {
        if (Ct[0] >= 1 && Ct[0] <= 16) return ge + Ct[0];
        if (Ct[0] === 129) return Y.OPS.OP_1NEGATE;
      }
    }
    function $t(Ct) {
      return Buffer$D.isBuffer(Ct);
    }
    function Nt(Ct) {
      return se.Array(Ct);
    }
    function Dt(Ct) {
      return Buffer$D.isBuffer(Ct);
    }
    function Wt(Ct) {
      if ($t(Ct)) return Ct;
      ae(se.Array, Ct);
      const Vt = Ct.reduce((Xe, ve) => Dt(ve) ? ve.length === 1 && Ve(ve) !== void 0 ? Xe + 1 : Xe + ne.encodingLength(ve.length) + ve.length : Xe + 1, 0), kt = Buffer$D.allocUnsafe(Vt);
      let Pe = 0;
      if (Ct.forEach((Xe) => {
        if (Dt(Xe)) {
          const ve = Ve(Xe);
          if (ve !== void 0) {
            kt.writeUInt8(ve, Pe), Pe += 1;
            return;
          }
          Pe += ne.encode(kt, Xe.length, Pe), Xe.copy(kt, Pe), Pe += Xe.length;
        } else
          kt.writeUInt8(Xe, Pe), Pe += 1;
      }), Pe !== kt.length) throw new Error("Could not decode chunks");
      return kt;
    }
    B.compile = Wt;
    function Pt(Ct) {
      if (Nt(Ct)) return Ct;
      ae(se.Buffer, Ct);
      const Vt = [];
      let kt = 0;
      for (; kt < Ct.length; ) {
        const Pe = Ct[kt];
        if (Pe > Y.OPS.OP_0 && Pe <= Y.OPS.OP_PUSHDATA4) {
          const Xe = ne.decode(Ct, kt);
          if (Xe === null || (kt += Xe.size, kt + Xe.number > Ct.length)) return null;
          const ve = Ct.slice(kt, kt + Xe.number);
          kt += Xe.number;
          const Ke = Ve(ve);
          Ke !== void 0 ? Vt.push(Ke) : Vt.push(ve);
        } else
          Vt.push(Pe), kt += 1;
      }
      return Vt;
    }
    B.decompile = Pt;
    function Lt(Ct) {
      if ($t(Ct) && (Ct = Pt(Ct)), !Ct)
        throw new Error("Could not convert invalid chunks to ASM");
      return Ct.map((Vt) => {
        if (Dt(Vt)) {
          const kt = Ve(Vt);
          if (kt === void 0) return Vt.toString("hex");
          Vt = kt;
        }
        return Y.REVERSE_OPS[Vt];
      }).join(" ");
    }
    B.toASM = Lt;
    function qt(Ct) {
      return ae(se.String, Ct), Wt(
        Ct.split(" ").map((Vt) => Y.OPS[Vt] !== void 0 ? Y.OPS[Vt] : (ae(se.Hex, Vt), Buffer$D.from(Vt, "hex")))
      );
    }
    B.fromASM = qt;
    function Zt(Ct) {
      return Ct = Pt(Ct), ae(Ee, Ct), Ct.map((Vt) => Dt(Vt) ? Vt : Vt === Y.OPS.OP_0 ? Buffer$D.allocUnsafe(0) : ie.encode(Vt - ge));
    }
    B.toStack = Zt;
    function Yt(Ct) {
      return se.isPoint(Ct);
    }
    B.isCanonicalPubKey = Yt;
    function or(Ct) {
      const Vt = Ct & -129;
      return Vt > 0 && Vt < 4;
    }
    B.isDefinedHashType = or;
    function jt(Ct) {
      return !Buffer$D.isBuffer(Ct) || !or(Ct[Ct.length - 1]) ? !1 : z.check(Ct.slice(0, -1));
    }
    B.isCanonicalScriptSignature = jt, B.number = ie, B.signature = oe;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, z, Y) {
  Object.defineProperty(B, z, {
    configurable: !0,
    enumerable: !0,
    get() {
      const ne = Y.call(this);
      return this[z] = ne, ne;
    },
    set(ne) {
      Object.defineProperty(this, z, {
        configurable: !0,
        enumerable: !0,
        value: ne,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let z;
  return () => (z !== void 0 || (z = B()), z);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, z) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const ne = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(ne, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(ne, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), z.validate && B.output) {
    const ie = bscript$9.decompile(B.output);
    if (ie[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!ie.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, ne.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(ne, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, z) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {});
  function Y(ge) {
    return bscript$8.isCanonicalScriptSignature(ge) || (z.allowIncomplete && ge === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(Y)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const ie = { network: B.network || networks_1$6.bitcoin };
  let oe = [], se = !1;
  function ae(ge) {
    se || (se = !0, oe = bscript$8.decompile(ge), ie.m = oe[0] - OP_INT_BASE, ie.n = oe[oe.length - 2] - OP_INT_BASE, ie.pubkeys = oe.slice(1, -2));
  }
  if (lazy$5.prop(ie, "output", () => {
    if (B.m && ie.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + ie.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(ie, "m", () => {
    if (ie.output)
      return ae(ie.output), ie.m;
  }), lazy$5.prop(ie, "n", () => {
    if (ie.pubkeys)
      return ie.pubkeys.length;
  }), lazy$5.prop(ie, "pubkeys", () => {
    if (B.output)
      return ae(B.output), ie.pubkeys;
  }), lazy$5.prop(ie, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(ie, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(ie, "witness", () => {
    if (ie.input)
      return [];
  }), lazy$5.prop(ie, "name", () => {
    if (!(!ie.m || !ie.n))
      return `p2ms(${ie.m} of ${ie.n})`;
  }), z.validate) {
    if (B.output) {
      if (ae(B.output), !types_1$6.typeforce.Number(oe[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(oe[oe.length - 2]))
        throw new TypeError("Output is invalid");
      if (oe[oe.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (ie.m <= 0 || ie.n > 16 || ie.m > ie.n || ie.n !== oe.length - 3)
        throw new TypeError("Output is invalid");
      if (!ie.pubkeys.every((ge) => (0, types_1$6.isPoint)(ge)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== ie.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== ie.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, ie.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (ie.n = B.pubkeys.length, ie.n < ie.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < ie.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > ie.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (ie.signatures.length === 0 || !ie.signatures.every(Y))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, ie.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(ie, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, z) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$4.value(() => bscript$7.decompile(B.input)), ie = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(ie, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(ie, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(ie, "signature", () => {
    if (B.input)
      return Y()[0];
  }), lazy$4.prop(ie, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(ie, "witness", () => {
    if (ie.input)
      return [];
  }), z.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(ie.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(ie.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(ie.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (Y().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(ie.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(ie, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$p, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, z) => z)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let z of [idxL, idxR])
    z.push(z[B].map((Y) => Rho[Y]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, z) => B.map((Y) => shifts[z][Y])), shiftsR = /* @__PURE__ */ idxR.map((B, z) => B.map((Y) => shifts[z][Y])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(B, z, Y, ne) {
  return B === 0 ? z ^ Y ^ ne : B === 1 ? z & Y | ~z & ne : B === 2 ? (z | ~Y) ^ ne : B === 3 ? z & ne | Y & ~ne : z ^ (Y | ~ne);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: z, h1: Y, h2: ne, h3: ie, h4: oe } = this;
    return [z, Y, ne, ie, oe];
  }
  set(z, Y, ne, ie, oe) {
    this.h0 = z | 0, this.h1 = Y | 0, this.h2 = ne | 0, this.h3 = ie | 0, this.h4 = oe | 0;
  }
  process(z, Y) {
    for (let Ve = 0; Ve < 16; Ve++, Y += 4)
      R_BUF[Ve] = z.getUint32(Y, !0);
    let ne = this.h0 | 0, ie = ne, oe = this.h1 | 0, se = oe, ae = this.h2 | 0, ge = ae, Ce = this.h3 | 0, le = Ce, Ee = this.h4 | 0, Je = Ee;
    for (let Ve = 0; Ve < 5; Ve++) {
      const $t = 4 - Ve, Nt = Kl[Ve], Dt = Kr[Ve], Wt = idxL[Ve], Pt = idxR[Ve], Lt = shiftsL[Ve], qt = shiftsR[Ve];
      for (let Zt = 0; Zt < 16; Zt++) {
        const Yt = (0, utils_js_1$1.rotl)(ne + f(Ve, oe, ae, Ce) + R_BUF[Wt[Zt]] + Nt, Lt[Zt]) + Ee | 0;
        ne = Ee, Ee = Ce, Ce = (0, utils_js_1$1.rotl)(ae, 10) | 0, ae = oe, oe = Yt;
      }
      for (let Zt = 0; Zt < 16; Zt++) {
        const Yt = (0, utils_js_1$1.rotl)(ie + f($t, se, ge, le) + R_BUF[Pt[Zt]] + Dt, qt[Zt]) + Je | 0;
        ie = Je, Je = le, le = (0, utils_js_1$1.rotl)(ge, 10) | 0, ge = se, se = Yt;
      }
    }
    this.set(this.h1 + ae + le | 0, this.h2 + Ce + Je | 0, this.h3 + Ee + ie | 0, this.h4 + ne + se | 0, this.h0 + oe + ge | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$p, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: ie, E: oe } = this;
    return [z, Y, ne, ie, oe];
  }
  set(z, Y, ne, ie, oe) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = ie | 0, this.E = oe | 0;
  }
  process(z, Y) {
    for (let ge = 0; ge < 16; ge++, Y += 4)
      SHA1_W[ge] = z.getUint32(Y, !1);
    for (let ge = 16; ge < 80; ge++)
      SHA1_W[ge] = (0, utils_js_1.rotl)(SHA1_W[ge - 3] ^ SHA1_W[ge - 8] ^ SHA1_W[ge - 14] ^ SHA1_W[ge - 16], 1);
    let { A: ne, B: ie, C: oe, D: se, E: ae } = this;
    for (let ge = 0; ge < 80; ge++) {
      let Ce, le;
      ge < 20 ? (Ce = (0, _md_js_1.Chi)(ie, oe, se), le = 1518500249) : ge < 40 ? (Ce = ie ^ oe ^ se, le = 1859775393) : ge < 60 ? (Ce = (0, _md_js_1.Maj)(ie, oe, se), le = 2400959708) : (Ce = ie ^ oe ^ se, le = 3395469782);
      const Ee = (0, utils_js_1.rotl)(ne, 5) + Ce + ae + le + SHA1_W[ge] | 0;
      ae = se, se = oe, oe = (0, utils_js_1.rotl)(ie, 30), ie = ne, ne = Ee;
    }
    ne = ne + this.A | 0, ie = ie + this.B | 0, oe = oe + this.C | 0, se = se + this.D | 0, ae = ae + this.E | 0, this.set(ne, ie, oe, se, ae);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const z = ripemd160, Y = sha1, ne = sha256$4;
  function ie(le) {
    return Buffer$D.from((0, z.ripemd160)(Uint8Array.from(le)));
  }
  B.ripemd160 = ie;
  function oe(le) {
    return Buffer$D.from((0, Y.sha1)(Uint8Array.from(le)));
  }
  B.sha1 = oe;
  function se(le) {
    return Buffer$D.from((0, ne.sha256)(Uint8Array.from(le)));
  }
  B.sha256 = se;
  function ae(le) {
    return Buffer$D.from(
      (0, z.ripemd160)((0, ne.sha256)(Uint8Array.from(le)))
    );
  }
  B.hash160 = ae;
  function ge(le) {
    return Buffer$D.from(
      (0, ne.sha256)((0, ne.sha256)(Uint8Array.from(le)))
    );
  }
  B.hash256 = ge, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$D.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$D.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$D.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$D.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$D.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$D.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$D.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$D.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$D.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function Ce(le, Ee) {
    return se(Buffer$D.concat([B.TAGGED_HASH_PREFIXES[le], Ee]));
  }
  B.taggedHash = Ce;
})(crypto$1);
function base$1(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var z = new Uint8Array(256), Y = 0; Y < z.length; Y++)
    z[Y] = 255;
  for (var ne = 0; ne < B.length; ne++) {
    var ie = B.charAt(ne), oe = ie.charCodeAt(0);
    if (z[oe] !== 255)
      throw new TypeError(ie + " is ambiguous");
    z[oe] = ne;
  }
  var se = B.length, ae = B.charAt(0), ge = Math.log(se) / Math.log(256), Ce = Math.log(256) / Math.log(se);
  function le(Ve) {
    if (Ve instanceof Uint8Array || (ArrayBuffer.isView(Ve) ? Ve = new Uint8Array(Ve.buffer, Ve.byteOffset, Ve.byteLength) : Array.isArray(Ve) && (Ve = Uint8Array.from(Ve))), !(Ve instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ve.length === 0)
      return "";
    for (var $t = 0, Nt = 0, Dt = 0, Wt = Ve.length; Dt !== Wt && Ve[Dt] === 0; )
      Dt++, $t++;
    for (var Pt = (Wt - Dt) * Ce + 1 >>> 0, Lt = new Uint8Array(Pt); Dt !== Wt; ) {
      for (var qt = Ve[Dt], Zt = 0, Yt = Pt - 1; (qt !== 0 || Zt < Nt) && Yt !== -1; Yt--, Zt++)
        qt += 256 * Lt[Yt] >>> 0, Lt[Yt] = qt % se >>> 0, qt = qt / se >>> 0;
      if (qt !== 0)
        throw new Error("Non-zero carry");
      Nt = Zt, Dt++;
    }
    for (var or = Pt - Nt; or !== Pt && Lt[or] === 0; )
      or++;
    for (var jt = ae.repeat($t); or < Pt; ++or)
      jt += B.charAt(Lt[or]);
    return jt;
  }
  function Ee(Ve) {
    if (typeof Ve != "string")
      throw new TypeError("Expected String");
    if (Ve.length === 0)
      return new Uint8Array();
    for (var $t = 0, Nt = 0, Dt = 0; Ve[$t] === ae; )
      Nt++, $t++;
    for (var Wt = (Ve.length - $t) * ge + 1 >>> 0, Pt = new Uint8Array(Wt); Ve[$t]; ) {
      var Lt = z[Ve.charCodeAt($t)];
      if (Lt === 255)
        return;
      for (var qt = 0, Zt = Wt - 1; (Lt !== 0 || qt < Dt) && Zt !== -1; Zt--, qt++)
        Lt += se * Pt[Zt] >>> 0, Pt[Zt] = Lt % 256 >>> 0, Lt = Lt / 256 >>> 0;
      if (Lt !== 0)
        throw new Error("Non-zero carry");
      Dt = qt, $t++;
    }
    for (var Yt = Wt - Dt; Yt !== Wt && Pt[Yt] === 0; )
      Yt++;
    for (var or = new Uint8Array(Nt + (Wt - Yt)), jt = Nt; Yt !== Wt; )
      or[jt++] = Pt[Yt++];
    return or;
  }
  function Je(Ve) {
    var $t = Ee(Ve);
    if ($t)
      return $t;
    throw new Error("Non-base" + se + " character");
  }
  return {
    encode: le,
    decodeUnsafe: Ee,
    decode: Je
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(B) {
  function z(oe) {
    var se = Uint8Array.from(oe), ae = B(se), ge = se.length + 4, Ce = new Uint8Array(ge);
    return Ce.set(se, 0), Ce.set(ae.subarray(0, 4), se.length), base58.encode(Ce, ge);
  }
  function Y(oe) {
    var se = oe.slice(0, -4), ae = oe.slice(-4), ge = B(se);
    if (!(ae[0] ^ ge[0] | ae[1] ^ ge[1] | ae[2] ^ ge[2] | ae[3] ^ ge[3]))
      return se;
  }
  function ne(oe) {
    var se = base58.decodeUnsafe(oe);
    if (se)
      return Y(se);
  }
  function ie(oe) {
    var se = base58.decode(oe), ae = Y(se);
    if (!ae) throw new Error("Invalid checksum");
    return ae;
  }
  return {
    encode: z,
    decode: ie,
    decodeUnsafe: ne
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(B) {
  return sha256(sha256(B));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$3.value(() => {
    const se = Buffer$D.from(bs58check$1.decode(B.address)), ae = se.readUInt8(0), ge = se.slice(1);
    return { version: ae, hash: ge };
  }), ne = lazy$3.value(() => bscript$6.decompile(B.input)), ie = B.network || networks_1$4.bitcoin, oe = { name: "p2pkh", network: ie };
  if (lazy$3.prop(oe, "address", () => {
    if (!oe.hash) return;
    const se = Buffer$D.allocUnsafe(21);
    return se.writeUInt8(ie.pubKeyHash, 0), oe.hash.copy(se, 1), bs58check$1.encode(se);
  }), lazy$3.prop(oe, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return Y().hash;
    if (B.pubkey || oe.pubkey) return bcrypto$5.hash160(B.pubkey || oe.pubkey);
  }), lazy$3.prop(oe, "output", () => {
    if (oe.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        oe.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(oe, "pubkey", () => {
    if (B.input)
      return ne()[1];
  }), lazy$3.prop(oe, "signature", () => {
    if (B.input)
      return ne()[0];
  }), lazy$3.prop(oe, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(oe, "witness", () => {
    if (oe.input)
      return [];
  }), z.validate) {
    let se = Buffer$D.from([]);
    if (B.address) {
      if (Y().version !== ie.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (Y().hash.length !== 20) throw new TypeError("Invalid address");
      se = Y().hash;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ae = B.output.slice(3, 23);
      if (se.length > 0 && !se.equals(ae))
        throw new TypeError("Hash mismatch");
      se = ae;
    }
    if (B.pubkey) {
      const ae = bcrypto$5.hash160(B.pubkey);
      if (se.length > 0 && !se.equals(ae))
        throw new TypeError("Hash mismatch");
      se = ae;
    }
    if (B.input) {
      const ae = ne();
      if (ae.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ae[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ae[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(ae[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(ae[1]))
        throw new TypeError("Pubkey mismatch");
      const ge = bcrypto$5.hash160(ae[1]);
      if (se.length > 0 && !se.equals(ge))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(oe, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let Y = B.network;
  Y || (Y = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const ne = { network: Y }, ie = lazy$2.value(() => {
    const ae = Buffer$D.from(bs58check.decode(B.address)), ge = ae.readUInt8(0), Ce = ae.slice(1);
    return { version: ge, hash: Ce };
  }), oe = lazy$2.value(() => bscript$5.decompile(B.input)), se = lazy$2.value(() => {
    const ae = oe(), ge = ae[ae.length - 1];
    return {
      network: Y,
      output: ge === OPS$2.OP_FALSE ? Buffer$D.from([]) : ge,
      input: bscript$5.compile(ae.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(ne, "address", () => {
    if (!ne.hash) return;
    const ae = Buffer$D.allocUnsafe(21);
    return ae.writeUInt8(ne.network.scriptHash, 0), ne.hash.copy(ae, 1), bs58check.encode(ae);
  }), lazy$2.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return ie().hash;
    if (ne.redeem && ne.redeem.output) return bcrypto$4.hash160(ne.redeem.output);
  }), lazy$2.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, ne.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(ne, "redeem", () => {
    if (B.input)
      return se();
  }), lazy$2.prop(ne, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(ne, "witness", () => {
    if (ne.redeem && ne.redeem.witness) return ne.redeem.witness;
    if (ne.input) return [];
  }), lazy$2.prop(ne, "name", () => {
    const ae = ["p2sh"];
    return ne.redeem !== void 0 && ne.redeem.name !== void 0 && ae.push(ne.redeem.name), ae.join("-");
  }), z.validate) {
    let ae = Buffer$D.from([]);
    if (B.address) {
      if (ie().version !== Y.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (ie().hash.length !== 20) throw new TypeError("Invalid address");
      ae = ie().hash;
    }
    if (B.hash) {
      if (ae.length > 0 && !ae.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ae = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const Ce = B.output.slice(2, 22);
      if (ae.length > 0 && !ae.equals(Ce))
        throw new TypeError("Hash mismatch");
      ae = Ce;
    }
    const ge = (Ce) => {
      if (Ce.output) {
        const le = bscript$5.decompile(Ce.output);
        if (!le || le.length < 1)
          throw new TypeError("Redeem.output too short");
        if (Ce.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(le) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const Ee = bcrypto$4.hash160(Ce.output);
        if (ae.length > 0 && !ae.equals(Ee))
          throw new TypeError("Hash mismatch");
        ae = Ee;
      }
      if (Ce.input) {
        const le = Ce.input.length > 0, Ee = Ce.witness && Ce.witness.length > 0;
        if (!le && !Ee) throw new TypeError("Empty input");
        if (le && Ee)
          throw new TypeError("Input and witness provided");
        if (le) {
          const Je = bscript$5.decompile(Ce.input);
          if (!bscript$5.isPushOnly(Je))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const Ce = oe();
      if (!Ce || Ce.length < 1) throw new TypeError("Input too short");
      if (!Buffer$D.isBuffer(se().output))
        throw new TypeError("Input is invalid");
      ge(se());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== Y)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const Ce = se();
        if (B.redeem.output && !B.redeem.output.equals(Ce.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(Ce.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ge(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(ne, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET.length; B++) {
  const z = ALPHABET.charAt(B);
  ALPHABET_MAP[z] = B;
}
function polymodStep(B) {
  const z = B >> 25;
  return (B & 33554431) << 5 ^ -(z >> 0 & 1) & 996825010 ^ -(z >> 1 & 1) & 642813549 ^ -(z >> 2 & 1) & 513874426 ^ -(z >> 3 & 1) & 1027748829 ^ -(z >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let z = 1;
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    if (ne < 33 || ne > 126)
      return "Invalid prefix (" + B + ")";
    z = polymodStep(z) ^ ne >> 5;
  }
  z = polymodStep(z);
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    z = polymodStep(z) ^ ne & 31;
  }
  return z;
}
function convert$2(B, z, Y, ne) {
  let ie = 0, oe = 0;
  const se = (1 << Y) - 1, ae = [];
  for (let ge = 0; ge < B.length; ++ge)
    for (ie = ie << z | B[ge], oe += z; oe >= Y; )
      oe -= Y, ae.push(ie >> oe & se);
  if (ne)
    oe > 0 && ae.push(ie << Y - oe & se);
  else {
    if (oe >= z)
      return "Excess padding";
    if (ie << Y - oe & se)
      return "Non-zero padding";
  }
  return ae;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
}
function fromWords(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
  throw new Error(z);
}
function getLibraryFromEncoding(B) {
  let z;
  B === "bech32" ? z = 1 : z = 734539939;
  function Y(se, ae, ge) {
    if (ge = ge || 90, se.length + 7 + ae.length > ge)
      throw new TypeError("Exceeds length limit");
    se = se.toLowerCase();
    let Ce = prefixChk(se);
    if (typeof Ce == "string")
      throw new Error(Ce);
    let le = se + "1";
    for (let Ee = 0; Ee < ae.length; ++Ee) {
      const Je = ae[Ee];
      if (Je >> 5)
        throw new Error("Non 5-bit word");
      Ce = polymodStep(Ce) ^ Je, le += ALPHABET.charAt(Je);
    }
    for (let Ee = 0; Ee < 6; ++Ee)
      Ce = polymodStep(Ce);
    Ce ^= z;
    for (let Ee = 0; Ee < 6; ++Ee) {
      const Je = Ce >> (5 - Ee) * 5 & 31;
      le += ALPHABET.charAt(Je);
    }
    return le;
  }
  function ne(se, ae) {
    if (ae = ae || 90, se.length < 8)
      return se + " too short";
    if (se.length > ae)
      return "Exceeds length limit";
    const ge = se.toLowerCase(), Ce = se.toUpperCase();
    if (se !== ge && se !== Ce)
      return "Mixed-case string " + se;
    se = ge;
    const le = se.lastIndexOf("1");
    if (le === -1)
      return "No separator character for " + se;
    if (le === 0)
      return "Missing prefix for " + se;
    const Ee = se.slice(0, le), Je = se.slice(le + 1);
    if (Je.length < 6)
      return "Data too short";
    let Ve = prefixChk(Ee);
    if (typeof Ve == "string")
      return Ve;
    const $t = [];
    for (let Nt = 0; Nt < Je.length; ++Nt) {
      const Dt = Je.charAt(Nt), Wt = ALPHABET_MAP[Dt];
      if (Wt === void 0)
        return "Unknown character " + Dt;
      Ve = polymodStep(Ve) ^ Wt, !(Nt + 6 >= Je.length) && $t.push(Wt);
    }
    return Ve !== z ? "Invalid checksum for " + se : { prefix: Ee, words: $t };
  }
  function ie(se, ae) {
    const ge = ne(se, ae);
    if (typeof ge == "object")
      return ge;
  }
  function oe(se, ae) {
    const ge = ne(se, ae);
    if (typeof ge == "object")
      return ge;
    throw new Error(ge);
  }
  return {
    decodeUnsafe: ie,
    decode: oe,
    encode: Y,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$D.alloc(0);
function p2wpkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy$1.value(() => {
    const oe = bech32_1$1.bech32.decode(B.address), se = oe.words.shift(), ae = bech32_1$1.bech32.fromWords(oe.words);
    return {
      version: se,
      prefix: oe.prefix,
      data: Buffer$D.from(ae)
    };
  }), ne = B.network || networks_1$2.bitcoin, ie = { name: "p2wpkh", network: ne };
  if (lazy$1.prop(ie, "address", () => {
    if (!ie.hash) return;
    const oe = bech32_1$1.bech32.toWords(ie.hash);
    return oe.unshift(0), bech32_1$1.bech32.encode(ne.bech32, oe);
  }), lazy$1.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return Y().data;
    if (B.pubkey || ie.pubkey) return bcrypto$3.hash160(B.pubkey || ie.pubkey);
  }), lazy$1.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$4.compile([OPS$1.OP_0, ie.hash]);
  }), lazy$1.prop(ie, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(ie, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(ie, "input", () => {
    if (ie.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(ie, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), z.validate) {
    let oe = Buffer$D.from([]);
    if (B.address) {
      if (ne && ne.bech32 !== Y().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 20)
        throw new TypeError("Invalid address data");
      oe = Y().data;
    }
    if (B.hash) {
      if (oe.length > 0 && !oe.equals(B.hash))
        throw new TypeError("Hash mismatch");
      oe = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (oe.length > 0 && !oe.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      oe = B.output.slice(2);
    }
    if (B.pubkey) {
      const se = bcrypto$3.hash160(B.pubkey);
      if (oe.length > 0 && !oe.equals(se))
        throw new TypeError("Hash mismatch");
      if (oe = se, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const se = bcrypto$3.hash160(B.witness[1]);
      if (oe.length > 0 && !oe.equals(se))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ie, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$D.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$D.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy.value(() => {
    const se = bech32_1.bech32.decode(B.address), ae = se.words.shift(), ge = bech32_1.bech32.fromWords(se.words);
    return {
      version: ae,
      prefix: se.prefix,
      data: Buffer$D.from(ge)
    };
  }), ne = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let ie = B.network;
  ie || (ie = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const oe = { network: ie };
  if (lazy.prop(oe, "address", () => {
    if (!oe.hash) return;
    const se = bech32_1.bech32.toWords(oe.hash);
    return se.unshift(0), bech32_1.bech32.encode(ie.bech32, se);
  }), lazy.prop(oe, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return Y().data;
    if (oe.redeem && oe.redeem.output) return bcrypto$2.sha256(oe.redeem.output);
  }), lazy.prop(oe, "output", () => {
    if (oe.hash)
      return bscript$3.compile([OPS.OP_0, oe.hash]);
  }), lazy.prop(oe, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(oe, "input", () => {
    if (oe.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(oe, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const se = bscript$3.toStack(ne());
      return oe.redeem = Object.assign({ witness: se }, B.redeem), oe.redeem.input = EMPTY_BUFFER$1, [].concat(se, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(oe, "name", () => {
    const se = ["p2wsh"];
    return oe.redeem !== void 0 && oe.redeem.name !== void 0 && se.push(oe.redeem.name), se.join("-");
  }), z.validate) {
    let se = Buffer$D.from([]);
    if (B.address) {
      if (Y().prefix !== ie.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 32)
        throw new TypeError("Invalid address data");
      se = Y().data;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ae = B.output.slice(2);
      if (se.length > 0 && !se.equals(ae))
        throw new TypeError("Hash mismatch");
      se = ae;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== ie)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const ae = bscript$3.decompile(B.redeem.output);
        if (!ae || ae.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ae) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ge = bcrypto$2.sha256(B.redeem.output);
        if (se.length > 0 && !se.equals(ge))
          throw new TypeError("Hash mismatch");
        se = ge;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(ne()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && ne().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const ae = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(ae))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ae) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(oe, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (B) => Buffer$D.from(B, "hex");
function verifyEcc(B) {
  assert(typeof B.isXOnlyPoint == "function"), assert(
    B.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    B.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((z) => {
    const Y = B.xOnlyPointAddTweak(h(z.pubkey), h(z.tweak));
    z.result === null ? assert(Y === null) : (assert(Y !== null), assert(Y.parity === z.parity), assert(Buffer$D.from(Y.xOnlyPubkey).equals(h(z.result))));
  });
}
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports$1.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(B, z, Y) {
  if (checkUInt53$1(B), z || (z = Buffer.allocUnsafe(encodingLength$1(B))), !Buffer.isBuffer(z)) throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), encode$f.bytes = 1) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), encode$f.bytes = 3) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), encode$f.bytes = 5) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), encode$f.bytes = 9), z;
}
function decode$e(B, z) {
  if (!Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  var Y = B.readUInt8(z);
  if (Y < 253)
    return decode$e.bytes = 1, Y;
  if (Y === 253)
    return decode$e.bytes = 3, B.readUInt16LE(z + 1);
  if (Y === 254)
    return decode$e.bytes = 5, B.readUInt32LE(z + 1);
  decode$e.bytes = 9;
  var ne = B.readUInt32LE(z + 1), ie = B.readUInt32LE(z + 5), oe = ie * 4294967296 + ne;
  return checkUInt53$1(oe), oe;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint$1(ne + Y, 9007199254740991), ne + Y;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, z, Y) {
  return verifuint$1(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(B) {
  const z = Buffer$D.allocUnsafe(B.length);
  return B.copy(z), z;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(z) {
    return new BufferWriter(Buffer$D.alloc(z));
  }
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  writeUInt8(z) {
    this.offset = this.buffer.writeUInt8(z, this.offset);
  }
  writeInt32(z) {
    this.offset = this.buffer.writeInt32LE(z, this.offset);
  }
  writeUInt32(z) {
    this.offset = this.buffer.writeUInt32LE(z, this.offset);
  }
  writeUInt64(z) {
    this.offset = writeUInt64LE$1(this.buffer, z, this.offset);
  }
  writeVarInt(z) {
    varuint$7.encode(z, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(z) {
    if (this.buffer.length < this.offset + z.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += z.copy(this.buffer, this.offset);
  }
  writeVarSlice(z) {
    this.writeVarInt(z.length), this.writeSlice(z);
  }
  writeVector(z) {
    this.writeVarInt(z.length), z.forEach((Y) => this.writeVarSlice(Y));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  readUInt8() {
    const z = this.buffer.readUInt8(this.offset);
    return this.offset++, z;
  }
  readInt32() {
    const z = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt32() {
    const z = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt64() {
    const z = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, z;
  }
  readVarInt() {
    const z = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, z;
  }
  readSlice(z) {
    if (this.buffer.length < this.offset + z)
      throw new Error("Cannot read slice out of bounds");
    const Y = this.buffer.slice(this.offset, this.offset + z);
    return this.offset += z, Y;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const z = this.readVarInt(), Y = [];
    for (let ne = 0; ne < z; ne++) Y.push(this.readVarSlice());
    return Y;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const z = dist$1, Y = ecc_lib, ne = crypto$1, ie = bufferutils, oe = types$4;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const se = (Nt) => "left" in Nt && "right" in Nt;
  function ae(Nt, Dt) {
    if (Nt.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${Nt.length}, expected min 33.`
      );
    const Wt = (Nt.length - 33) / 32;
    let Pt = Dt;
    for (let Lt = 0; Lt < Wt; Lt++) {
      const qt = Nt.slice(33 + 32 * Lt, 65 + 32 * Lt);
      Pt.compare(qt) < 0 ? Pt = Ve(Pt, qt) : Pt = Ve(qt, Pt);
    }
    return Pt;
  }
  B.rootHashFromPath = ae;
  function ge(Nt) {
    if ((0, oe.isTapleaf)(Nt))
      return { hash: le(Nt) };
    const Dt = [ge(Nt[0]), ge(Nt[1])];
    Dt.sort((Lt, qt) => Lt.hash.compare(qt.hash));
    const [Wt, Pt] = Dt;
    return {
      hash: Ve(Wt.hash, Pt.hash),
      left: Wt,
      right: Pt
    };
  }
  B.toHashTree = ge;
  function Ce(Nt, Dt) {
    if (se(Nt)) {
      const Wt = Ce(Nt.left, Dt);
      if (Wt !== void 0) return [...Wt, Nt.right.hash];
      const Pt = Ce(Nt.right, Dt);
      if (Pt !== void 0) return [...Pt, Nt.left.hash];
    } else if (Nt.hash.equals(Dt))
      return [];
  }
  B.findScriptPath = Ce;
  function le(Nt) {
    const Dt = Nt.version || B.LEAF_VERSION_TAPSCRIPT;
    return ne.taggedHash(
      "TapLeaf",
      z.Buffer.concat([
        z.Buffer.from([Dt]),
        $t(Nt.output)
      ])
    );
  }
  B.tapleafHash = le;
  function Ee(Nt, Dt) {
    return ne.taggedHash(
      "TapTweak",
      z.Buffer.concat(Dt ? [Nt, Dt] : [Nt])
    );
  }
  B.tapTweakHash = Ee;
  function Je(Nt, Dt) {
    if (!z.Buffer.isBuffer(Nt) || Nt.length !== 32 || Dt && Dt.length !== 32) return null;
    const Wt = Ee(Nt, Dt), Pt = (0, Y.getEccLib)().xOnlyPointAddTweak(Nt, Wt);
    return !Pt || Pt.xOnlyPubkey === null ? null : {
      parity: Pt.parity,
      x: z.Buffer.from(Pt.xOnlyPubkey)
    };
  }
  B.tweakKey = Je;
  function Ve(Nt, Dt) {
    return ne.taggedHash("TapBranch", z.Buffer.concat([Nt, Dt]));
  }
  function $t(Nt) {
    const Dt = ie.varuint.encodingLength(Nt.length), Wt = z.Buffer.allocUnsafe(Dt);
    return ie.varuint.encode(Nt.length, Wt), z.Buffer.concat([Wt, Nt]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = dist$1, z = networks, Y = requireScript(), ne = types$4, ie = ecc_lib, oe = bip341, se = lazy$7, ae = dist, ge = requireAddress(), Ce = Y.OPS, le = 1, Ee = 80;
  function Je(Ve, $t) {
    if (!Ve.address && !Ve.output && !Ve.pubkey && !Ve.internalPubkey && !(Ve.witness && Ve.witness.length > 1))
      throw new TypeError("Not enough data");
    $t = Object.assign({ validate: !0 }, $t || {}), (0, ne.typeforce)(
      {
        address: ne.typeforce.maybe(ne.typeforce.String),
        input: ne.typeforce.maybe(ne.typeforce.BufferN(0)),
        network: ne.typeforce.maybe(ne.typeforce.Object),
        output: ne.typeforce.maybe(ne.typeforce.BufferN(34)),
        internalPubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        hash: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        pubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        signature: ne.typeforce.maybe(
          ne.typeforce.anyOf(
            ne.typeforce.BufferN(64),
            ne.typeforce.BufferN(65)
          )
        ),
        witness: ne.typeforce.maybe(
          ne.typeforce.arrayOf(ne.typeforce.Buffer)
        ),
        scriptTree: ne.typeforce.maybe(ne.isTaptree),
        redeem: ne.typeforce.maybe({
          output: ne.typeforce.maybe(ne.typeforce.Buffer),
          redeemVersion: ne.typeforce.maybe(ne.typeforce.Number),
          witness: ne.typeforce.maybe(
            ne.typeforce.arrayOf(ne.typeforce.Buffer)
          )
        }),
        redeemVersion: ne.typeforce.maybe(ne.typeforce.Number)
      },
      Ve
    );
    const Nt = se.value(() => (0, ge.fromBech32)(Ve.address)), Dt = se.value(() => {
      if (!(!Ve.witness || !Ve.witness.length))
        return Ve.witness.length >= 2 && Ve.witness[Ve.witness.length - 1][0] === Ee ? Ve.witness.slice(0, -1) : Ve.witness.slice();
    }), Wt = se.value(() => {
      if (Ve.scriptTree) return (0, oe.toHashTree)(Ve.scriptTree);
      if (Ve.hash) return { hash: Ve.hash };
    }), Pt = Ve.network || z.bitcoin, Lt = { name: "p2tr", network: Pt };
    if (se.prop(Lt, "address", () => {
      if (!Lt.pubkey) return;
      const qt = ae.bech32m.toWords(Lt.pubkey);
      return qt.unshift(le), ae.bech32m.encode(Pt.bech32, qt);
    }), se.prop(Lt, "hash", () => {
      const qt = Wt();
      if (qt) return qt.hash;
      const Zt = Dt();
      if (Zt && Zt.length > 1) {
        const Yt = Zt[Zt.length - 1], or = Yt[0] & ne.TAPLEAF_VERSION_MASK, jt = Zt[Zt.length - 2], Ct = (0, oe.tapleafHash)({
          output: jt,
          version: or
        });
        return (0, oe.rootHashFromPath)(Yt, Ct);
      }
      return null;
    }), se.prop(Lt, "output", () => {
      if (Lt.pubkey)
        return Y.compile([Ce.OP_1, Lt.pubkey]);
    }), se.prop(Lt, "redeemVersion", () => Ve.redeemVersion ? Ve.redeemVersion : Ve.redeem && Ve.redeem.redeemVersion !== void 0 && Ve.redeem.redeemVersion !== null ? Ve.redeem.redeemVersion : oe.LEAF_VERSION_TAPSCRIPT), se.prop(Lt, "redeem", () => {
      const qt = Dt();
      if (!(!qt || qt.length < 2))
        return {
          output: qt[qt.length - 2],
          witness: qt.slice(0, -2),
          redeemVersion: qt[qt.length - 1][0] & ne.TAPLEAF_VERSION_MASK
        };
    }), se.prop(Lt, "pubkey", () => {
      if (Ve.pubkey) return Ve.pubkey;
      if (Ve.output) return Ve.output.slice(2);
      if (Ve.address) return Nt().data;
      if (Lt.internalPubkey) {
        const qt = (0, oe.tweakKey)(Lt.internalPubkey, Lt.hash);
        if (qt) return qt.x;
      }
    }), se.prop(Lt, "internalPubkey", () => {
      if (Ve.internalPubkey) return Ve.internalPubkey;
      const qt = Dt();
      if (qt && qt.length > 1)
        return qt[qt.length - 1].slice(1, 33);
    }), se.prop(Lt, "signature", () => {
      if (Ve.signature) return Ve.signature;
      const qt = Dt();
      if (!(!qt || qt.length !== 1))
        return qt[0];
    }), se.prop(Lt, "witness", () => {
      if (Ve.witness) return Ve.witness;
      const qt = Wt();
      if (qt && Ve.redeem && Ve.redeem.output && Ve.internalPubkey) {
        const Zt = (0, oe.tapleafHash)({
          output: Ve.redeem.output,
          version: Lt.redeemVersion
        }), Yt = (0, oe.findScriptPath)(qt, Zt);
        if (!Yt) return;
        const or = (0, oe.tweakKey)(Ve.internalPubkey, qt.hash);
        if (!or) return;
        const jt = B.Buffer.concat(
          [
            B.Buffer.from([Lt.redeemVersion | or.parity]),
            Ve.internalPubkey
          ].concat(Yt)
        );
        return [Ve.redeem.output, jt];
      }
      if (Ve.signature) return [Ve.signature];
    }), $t.validate) {
      let qt = B.Buffer.from([]);
      if (Ve.address) {
        if (Pt && Pt.bech32 !== Nt().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (Nt().version !== le)
          throw new TypeError("Invalid address version");
        if (Nt().data.length !== 32)
          throw new TypeError("Invalid address data");
        qt = Nt().data;
      }
      if (Ve.pubkey) {
        if (qt.length > 0 && !qt.equals(Ve.pubkey))
          throw new TypeError("Pubkey mismatch");
        qt = Ve.pubkey;
      }
      if (Ve.output) {
        if (Ve.output.length !== 34 || Ve.output[0] !== Ce.OP_1 || Ve.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (qt.length > 0 && !qt.equals(Ve.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        qt = Ve.output.slice(2);
      }
      if (Ve.internalPubkey) {
        const or = (0, oe.tweakKey)(Ve.internalPubkey, Lt.hash);
        if (qt.length > 0 && !qt.equals(or.x))
          throw new TypeError("Pubkey mismatch");
        qt = or.x;
      }
      if (qt && qt.length && !(0, ie.getEccLib)().isXOnlyPoint(qt))
        throw new TypeError("Invalid pubkey for p2tr");
      const Zt = Wt();
      if (Ve.hash && Zt && !Ve.hash.equals(Zt.hash))
        throw new TypeError("Hash mismatch");
      if (Ve.redeem && Ve.redeem.output && Zt) {
        const or = (0, oe.tapleafHash)({
          output: Ve.redeem.output,
          version: Lt.redeemVersion
        });
        if (!(0, oe.findScriptPath)(Zt, or))
          throw new TypeError("Redeem script not in tree");
      }
      const Yt = Dt();
      if (Ve.redeem && Lt.redeem) {
        if (Ve.redeem.redeemVersion && Ve.redeem.redeemVersion !== Lt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Ve.redeem.output) {
          if (Y.decompile(Ve.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (Lt.redeem.output && !Ve.redeem.output.equals(Lt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Ve.redeem.witness && Lt.redeem.witness && !(0, ne.stacksEqual)(Ve.redeem.witness, Lt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Yt && Yt.length)
        if (Yt.length === 1) {
          if (Ve.signature && !Ve.signature.equals(Yt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const or = Yt[Yt.length - 1];
          if (or.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${or.length}, expected min 33.`
            );
          if ((or.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${or.length} is incorrect!`
            );
          const jt = (or.length - 33) / 32;
          if (jt > 128)
            throw new TypeError(
              `The script path is too long. Got ${jt}, expected max 128.`
            );
          const Ct = or.slice(1, 33);
          if (Ve.internalPubkey && !Ve.internalPubkey.equals(Ct))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, ie.getEccLib)().isXOnlyPoint(Ct))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Vt = or[0] & ne.TAPLEAF_VERSION_MASK, kt = Yt[Yt.length - 2], Pe = (0, oe.tapleafHash)({
            output: kt,
            version: Vt
          }), Xe = (0, oe.rootHashFromPath)(or, Pe), ve = (0, oe.tweakKey)(Ct, Xe);
          if (!ve)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (qt.length && !qt.equals(ve.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (ve.parity !== (or[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(Lt, Ve);
  }
  return p2tr.p2tr = Je, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const z = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return z.p2data;
      }
    });
    const Y = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return Y.p2ms;
      }
    });
    const ne = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return ne.p2pk;
      }
    });
    const ie = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return ie.p2pkh;
      }
    });
    const oe = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return oe.p2sh;
      }
    });
    const se = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return se.p2wpkh;
      }
    });
    const ae = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ae.p2wsh;
      }
    });
    const ge = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return ge.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks, z = requirePayments(), Y = requireScript(), ne = types$4, ie = dist, oe = bs58check$2, se = 40, ae = 2, ge = 16, Ce = 2, le = 80, Ee = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Je(Lt, qt) {
    const Zt = Lt.slice(2);
    if (Zt.length < ae || Zt.length > se)
      throw new TypeError("Invalid program length for segwit address");
    const Yt = Lt[0] - le;
    if (Yt < Ce || Yt > ge)
      throw new TypeError("Invalid version for segwit address");
    if (Lt[1] !== Zt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(Ee), Dt(Zt, Yt, qt.bech32);
  }
  function Ve(Lt) {
    const qt = Buffer$D.from(oe.decode(Lt));
    if (qt.length < 21) throw new TypeError(Lt + " is too short");
    if (qt.length > 21) throw new TypeError(Lt + " is too long");
    const Zt = qt.readUInt8(0), Yt = qt.slice(1);
    return { version: Zt, hash: Yt };
  }
  address.fromBase58Check = Ve;
  function $t(Lt) {
    let qt, Zt;
    try {
      qt = ie.bech32.decode(Lt);
    } catch {
    }
    if (qt) {
      if (Zt = qt.words[0], Zt !== 0) throw new TypeError(Lt + " uses wrong encoding");
    } else if (qt = ie.bech32m.decode(Lt), Zt = qt.words[0], Zt === 0) throw new TypeError(Lt + " uses wrong encoding");
    const Yt = ie.bech32.fromWords(qt.words.slice(1));
    return {
      version: Zt,
      prefix: qt.prefix,
      data: Buffer$D.from(Yt)
    };
  }
  address.fromBech32 = $t;
  function Nt(Lt, qt) {
    (0, ne.typeforce)(
      (0, ne.tuple)(ne.Hash160bit, ne.UInt8),
      arguments
    );
    const Zt = Buffer$D.allocUnsafe(21);
    return Zt.writeUInt8(qt, 0), Lt.copy(Zt, 1), oe.encode(Zt);
  }
  address.toBase58Check = Nt;
  function Dt(Lt, qt, Zt) {
    const Yt = ie.bech32.toWords(Lt);
    return Yt.unshift(qt), qt === 0 ? ie.bech32.encode(Zt, Yt) : ie.bech32m.encode(Zt, Yt);
  }
  address.toBech32 = Dt;
  function Wt(Lt, qt) {
    qt = qt || B.bitcoin;
    try {
      return z.p2pkh({ output: Lt, network: qt }).address;
    } catch {
    }
    try {
      return z.p2sh({ output: Lt, network: qt }).address;
    } catch {
    }
    try {
      return z.p2wpkh({ output: Lt, network: qt }).address;
    } catch {
    }
    try {
      return z.p2wsh({ output: Lt, network: qt }).address;
    } catch {
    }
    try {
      return z.p2tr({ output: Lt, network: qt }).address;
    } catch {
    }
    try {
      return Je(Lt, qt);
    } catch {
    }
    throw new Error(Y.toASM(Lt) + " has no matching Address");
  }
  address.fromOutputScript = Wt;
  function Pt(Lt, qt) {
    qt = qt || B.bitcoin;
    let Zt, Yt;
    try {
      Zt = Ve(Lt);
    } catch {
    }
    if (Zt) {
      if (Zt.version === qt.pubKeyHash)
        return z.p2pkh({ hash: Zt.hash }).output;
      if (Zt.version === qt.scriptHash)
        return z.p2sh({ hash: Zt.hash }).output;
    } else {
      try {
        Yt = $t(Lt);
      } catch {
      }
      if (Yt) {
        if (Yt.prefix !== qt.bech32)
          throw new Error(Lt + " has an invalid prefix");
        if (Yt.version === 0) {
          if (Yt.data.length === 20)
            return z.p2wpkh({ hash: Yt.data }).output;
          if (Yt.data.length === 32)
            return z.p2wsh({ hash: Yt.data }).output;
        } else if (Yt.version === 1) {
          if (Yt.data.length === 32)
            return z.p2tr({ pubkey: Yt.data }).output;
        } else if (Yt.version >= Ce && Yt.version <= ge && Yt.data.length >= ae && Yt.data.length <= se)
          return console.warn(Ee), Y.compile([
            Yt.version + le,
            Yt.data
          ]);
      }
    }
    throw new Error(Lt + " has no matching Script");
  }
  return address.toOutputScript = Pt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, z) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof z != "function")
    throw TypeError("Expected digest Function");
  let Y = B.length;
  const ne = B.concat();
  for (; Y > 1; ) {
    let ie = 0;
    for (let oe = 0; oe < Y; oe += 2, ++ie) {
      const se = ne[oe], ae = oe + 1 === Y ? se : ne[oe + 1], ge = Buffer$D.concat([se, ae]);
      ne[ie] = z(ge);
    }
    Y = ie;
  }
  return ne[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + z;
}
function vectorSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + B.reduce((Y, ne) => Y + varSliceSize(ne), 0);
}
const EMPTY_BUFFER = Buffer$D.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$D.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(z, Y) {
    const ne = new bufferutils_1$2.BufferReader(z), ie = new Transaction();
    ie.version = ne.readInt32();
    const oe = ne.readUInt8(), se = ne.readUInt8();
    let ae = !1;
    oe === Transaction.ADVANCED_TRANSACTION_MARKER && se === Transaction.ADVANCED_TRANSACTION_FLAG ? ae = !0 : ne.offset -= 2;
    const ge = ne.readVarInt();
    for (let le = 0; le < ge; ++le)
      ie.ins.push({
        hash: ne.readSlice(32),
        index: ne.readUInt32(),
        script: ne.readVarSlice(),
        sequence: ne.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const Ce = ne.readVarInt();
    for (let le = 0; le < Ce; ++le)
      ie.outs.push({
        value: ne.readUInt64(),
        script: ne.readVarSlice()
      });
    if (ae) {
      for (let le = 0; le < ge; ++le)
        ie.ins[le].witness = ne.readVector();
      if (!ie.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (ie.locktime = ne.readUInt32(), Y) return ie;
    if (ne.offset !== z.length)
      throw new Error("Transaction has unexpected data");
    return ie;
  }
  static fromHex(z) {
    return Transaction.fromBuffer(Buffer$D.from(z, "hex"), !1);
  }
  static isCoinbaseHash(z) {
    typeforce$1(types$1.Hash256bit, z);
    for (let Y = 0; Y < 32; ++Y)
      if (z[Y] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(z, Y, ne, ie) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(ne) && (ne = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: z,
      index: Y,
      script: ie || EMPTY_BUFFER,
      sequence: ne,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(z, Y) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: z,
      value: Y
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((z) => z.witness.length !== 0);
  }
  weight() {
    const z = this.byteLength(!1), Y = this.byteLength(!0);
    return z * 3 + Y;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(z = !0) {
    const Y = z && this.hasWitnesses();
    return (Y ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((ne, ie) => ne + 40 + varSliceSize(ie.script), 0) + this.outs.reduce((ne, ie) => ne + 8 + varSliceSize(ie.script), 0) + (Y ? this.ins.reduce((ne, ie) => ne + vectorSize(ie.witness), 0) : 0);
  }
  clone() {
    const z = new Transaction();
    return z.version = this.version, z.locktime = this.locktime, z.ins = this.ins.map((Y) => ({
      hash: Y.hash,
      index: Y.index,
      script: Y.script,
      sequence: Y.sequence,
      witness: Y.witness
    })), z.outs = this.outs.map((Y) => ({
      script: Y.script,
      value: Y.value
    })), z;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(z, Y, ne) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), z >= this.ins.length) return ONE;
    const ie = bscript$2.compile(
      bscript$2.decompile(Y).filter((ae) => ae !== script_1.OPS.OP_CODESEPARATOR)
    ), oe = this.clone();
    if ((ne & 31) === Transaction.SIGHASH_NONE)
      oe.outs = [], oe.ins.forEach((ae, ge) => {
        ge !== z && (ae.sequence = 0);
      });
    else if ((ne & 31) === Transaction.SIGHASH_SINGLE) {
      if (z >= this.outs.length) return ONE;
      oe.outs.length = z + 1;
      for (let ae = 0; ae < z; ae++)
        oe.outs[ae] = BLANK_OUTPUT;
      oe.ins.forEach((ae, ge) => {
        ge !== z && (ae.sequence = 0);
      });
    }
    ne & Transaction.SIGHASH_ANYONECANPAY ? (oe.ins = [oe.ins[z]], oe.ins[0].script = ie) : (oe.ins.forEach((ae) => {
      ae.script = EMPTY_BUFFER;
    }), oe.ins[z].script = ie);
    const se = Buffer$D.allocUnsafe(oe.byteLength(!1) + 4);
    return se.writeInt32LE(ne, se.length - 4), oe.__toBuffer(se, 0, !1), bcrypto$1.hash256(se);
  }
  hashForWitnessV1(z, Y, ne, ie, oe, se) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), ne.length !== this.ins.length || Y.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ae = ie === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : ie & Transaction.SIGHASH_OUTPUT_MASK, Ce = (ie & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, le = ae === Transaction.SIGHASH_NONE, Ee = ae === Transaction.SIGHASH_SINGLE;
    let Je = EMPTY_BUFFER, Ve = EMPTY_BUFFER, $t = EMPTY_BUFFER, Nt = EMPTY_BUFFER, Dt = EMPTY_BUFFER;
    if (!Ce) {
      let qt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Zt) => {
        qt.writeSlice(Zt.hash), qt.writeUInt32(Zt.index);
      }), Je = bcrypto$1.sha256(qt.end()), qt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), ne.forEach((Zt) => qt.writeUInt64(Zt)), Ve = bcrypto$1.sha256(qt.end()), qt = bufferutils_1$2.BufferWriter.withCapacity(
        Y.map(varSliceSize).reduce((Zt, Yt) => Zt + Yt)
      ), Y.forEach(
        (Zt) => qt.writeVarSlice(Zt)
      ), $t = bcrypto$1.sha256(qt.end()), qt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Zt) => qt.writeUInt32(Zt.sequence)), Nt = bcrypto$1.sha256(qt.end());
    }
    if (le || Ee) {
      if (Ee && z < this.outs.length) {
        const qt = this.outs[z], Zt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(qt.script)
        );
        Zt.writeUInt64(qt.value), Zt.writeVarSlice(qt.script), Dt = bcrypto$1.sha256(Zt.end());
      }
    } else {
      const qt = this.outs.map((Yt) => 8 + varSliceSize(Yt.script)).reduce((Yt, or) => Yt + or), Zt = bufferutils_1$2.BufferWriter.withCapacity(qt);
      this.outs.forEach((Yt) => {
        Zt.writeUInt64(Yt.value), Zt.writeVarSlice(Yt.script);
      }), Dt = bcrypto$1.sha256(Zt.end());
    }
    const Wt = (oe ? 2 : 0) + (se ? 1 : 0), Pt = 174 - (Ce ? 49 : 0) - (le ? 32 : 0) + (se ? 32 : 0) + (oe ? 37 : 0), Lt = bufferutils_1$2.BufferWriter.withCapacity(Pt);
    if (Lt.writeUInt8(ie), Lt.writeInt32(this.version), Lt.writeUInt32(this.locktime), Lt.writeSlice(Je), Lt.writeSlice(Ve), Lt.writeSlice($t), Lt.writeSlice(Nt), le || Ee || Lt.writeSlice(Dt), Lt.writeUInt8(Wt), Ce) {
      const qt = this.ins[z];
      Lt.writeSlice(qt.hash), Lt.writeUInt32(qt.index), Lt.writeUInt64(ne[z]), Lt.writeVarSlice(Y[z]), Lt.writeUInt32(qt.sequence);
    } else
      Lt.writeUInt32(z);
    if (se) {
      const qt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(se)
      );
      qt.writeVarSlice(se), Lt.writeSlice(bcrypto$1.sha256(qt.end()));
    }
    return Ee && Lt.writeSlice(Dt), oe && (Lt.writeSlice(oe), Lt.writeUInt8(0), Lt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$D.concat([Buffer$D.from([0]), Lt.end()])
    );
  }
  hashForWitnessV0(z, Y, ne, ie) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let oe = Buffer$D.from([]), se, ae = ZERO, ge = ZERO, Ce = ZERO;
    if (ie & Transaction.SIGHASH_ANYONECANPAY || (oe = Buffer$D.allocUnsafe(36 * this.ins.length), se = new bufferutils_1$2.BufferWriter(oe, 0), this.ins.forEach((Ee) => {
      se.writeSlice(Ee.hash), se.writeUInt32(Ee.index);
    }), ge = bcrypto$1.hash256(oe)), !(ie & Transaction.SIGHASH_ANYONECANPAY) && (ie & 31) !== Transaction.SIGHASH_SINGLE && (ie & 31) !== Transaction.SIGHASH_NONE && (oe = Buffer$D.allocUnsafe(4 * this.ins.length), se = new bufferutils_1$2.BufferWriter(oe, 0), this.ins.forEach((Ee) => {
      se.writeUInt32(Ee.sequence);
    }), Ce = bcrypto$1.hash256(oe)), (ie & 31) !== Transaction.SIGHASH_SINGLE && (ie & 31) !== Transaction.SIGHASH_NONE) {
      const Ee = this.outs.reduce((Je, Ve) => Je + 8 + varSliceSize(Ve.script), 0);
      oe = Buffer$D.allocUnsafe(Ee), se = new bufferutils_1$2.BufferWriter(oe, 0), this.outs.forEach((Je) => {
        se.writeUInt64(Je.value), se.writeVarSlice(Je.script);
      }), ae = bcrypto$1.hash256(oe);
    } else if ((ie & 31) === Transaction.SIGHASH_SINGLE && z < this.outs.length) {
      const Ee = this.outs[z];
      oe = Buffer$D.allocUnsafe(8 + varSliceSize(Ee.script)), se = new bufferutils_1$2.BufferWriter(oe, 0), se.writeUInt64(Ee.value), se.writeVarSlice(Ee.script), ae = bcrypto$1.hash256(oe);
    }
    oe = Buffer$D.allocUnsafe(156 + varSliceSize(Y)), se = new bufferutils_1$2.BufferWriter(oe, 0);
    const le = this.ins[z];
    return se.writeInt32(this.version), se.writeSlice(ge), se.writeSlice(Ce), se.writeSlice(le.hash), se.writeUInt32(le.index), se.writeVarSlice(Y), se.writeUInt64(ne), se.writeUInt32(le.sequence), se.writeSlice(ae), se.writeUInt32(this.locktime), se.writeUInt32(ie), bcrypto$1.hash256(oe);
  }
  getHash(z) {
    return z && this.isCoinbase() ? Buffer$D.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, z));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(z, Y) {
    return this.__toBuffer(z, Y, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[z].script = Y;
  }
  setWitness(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[z].witness = Y;
  }
  __toBuffer(z, Y, ne = !1) {
    z || (z = Buffer$D.allocUnsafe(this.byteLength(ne)));
    const ie = new bufferutils_1$2.BufferWriter(
      z,
      Y || 0
    );
    ie.writeInt32(this.version);
    const oe = ne && this.hasWitnesses();
    return oe && (ie.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), ie.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), ie.writeVarInt(this.ins.length), this.ins.forEach((se) => {
      ie.writeSlice(se.hash), ie.writeUInt32(se.index), ie.writeVarSlice(se.script), ie.writeUInt32(se.sequence);
    }), ie.writeVarInt(this.outs.length), this.outs.forEach((se) => {
      isOutput(se) ? ie.writeUInt64(se.value) : ie.writeSlice(se.valueBuffer), ie.writeVarSlice(se.script);
    }), oe && this.ins.forEach((se) => {
      ie.writeVector(se.witness);
    }), ie.writeUInt32(this.locktime), Y !== void 0 ? z.slice(Y, ie.offset) : z;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(z) {
    if (z.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const Y = new bufferutils_1$1.BufferReader(z), ne = new Block();
    if (ne.version = Y.readInt32(), ne.prevHash = Y.readSlice(32), ne.merkleRoot = Y.readSlice(32), ne.timestamp = Y.readUInt32(), ne.bits = Y.readUInt32(), ne.nonce = Y.readUInt32(), z.length === 80) return ne;
    const ie = () => {
      const ae = transaction_1$3.Transaction.fromBuffer(
        Y.buffer.slice(Y.offset),
        !0
      );
      return Y.offset += ae.byteLength(), ae;
    }, oe = Y.readVarInt();
    ne.transactions = [];
    for (let ae = 0; ae < oe; ++ae) {
      const ge = ie();
      ne.transactions.push(ge);
    }
    const se = ne.getWitnessCommit();
    return se && (ne.witnessCommit = se), ne;
  }
  static fromHex(z) {
    return Block.fromBuffer(Buffer$D.from(z, "hex"));
  }
  static calculateTarget(z) {
    const Y = ((z & 4278190080) >> 24) - 3, ne = z & 8388607, ie = Buffer$D.alloc(32, 0);
    return ie.writeUIntBE(ne, 29 - Y, 3), ie;
  }
  static calculateMerkleRoot(z, Y) {
    if (typeforce([{ getHash: types.Function }], z), z.length === 0) throw errorMerkleNoTxes;
    if (Y && !txesHaveWitnessCommit(z))
      throw errorWitnessNotSegwit;
    const ne = z.map(
      (oe) => oe.getHash(Y)
    ), ie = (0, merkle_1.fastMerkleRoot)(ne, bcrypto.hash256);
    return Y ? bcrypto.hash256(
      Buffer$D.concat([ie, z[0].ins[0].witness[0]])
    ) : ie;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const z = this.transactions[0].outs.filter(
      (ne) => ne.script.slice(0, 6).equals(Buffer$D.from("6a24aa21a9ed", "hex"))
    ).map((ne) => ne.script.slice(6, 38));
    if (z.length === 0) return null;
    const Y = z[z.length - 1];
    return Y instanceof Buffer$D && Y.length === 32 ? Y : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$D && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const z = this.byteLength(!1, !1), Y = this.byteLength(!1, !0);
    return z * 3 + Y;
  }
  byteLength(z, Y = !0) {
    return z || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((ne, ie) => ne + ie.byteLength(Y), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const z = /* @__PURE__ */ new Date(0);
    return z.setUTCSeconds(this.timestamp), z;
  }
  // TODO: buffer, offset compatibility
  toBuffer(z) {
    const Y = Buffer$D.allocUnsafe(this.byteLength(z)), ne = new bufferutils_1$1.BufferWriter(Y);
    return ne.writeInt32(this.version), ne.writeSlice(this.prevHash), ne.writeSlice(this.merkleRoot), ne.writeUInt32(this.timestamp), ne.writeUInt32(this.bits), ne.writeUInt32(this.nonce), z || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      Y,
      ne.offset
    ), ne.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((ie) => {
      const oe = ie.byteLength();
      ie.toBuffer(Y, ne.offset), ne.offset += oe;
    })), Y;
  }
  toHex(z) {
    return this.toBuffer(z).toString("hex");
  }
  checkTxRoots() {
    const z = this.hasWitnessCommit();
    return !z && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (z ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const z = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), Y = Block.calculateTarget(this.bits);
    return z.compare(Y) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const z = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(z) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const z = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(z) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (z) => typeof z == "object" && z.ins instanceof Array && z.ins.some(
      (Y) => typeof Y == "object" && Y.witness instanceof Array && Y.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(z) {
    z[z.UNSIGNED_TX = 0] = "UNSIGNED_TX", z[z.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(z) {
    z[z.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", z[z.WITNESS_UTXO = 1] = "WITNESS_UTXO", z[z.PARTIAL_SIG = 2] = "PARTIAL_SIG", z[z.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", z[z.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", z[z.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", z[z.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", z[z.POR_COMMITMENT = 9] = "POR_COMMITMENT", z[z.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", z[z.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", z[z.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", z[z.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", z[z.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(z) {
    z[z.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", z[z.TAP_TREE = 6] = "TAP_TREE", z[z.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (B) => [...Array(B).keys()];
function decode$d(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const z = B.key.slice(1), Y = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: z,
    path: "m"
  };
  for (const ne of range$2(B.value.length / 4 - 1)) {
    const ie = B.value.readUInt32LE(ne * 4 + 4), oe = !!(ie & 2147483648), se = ie & 2147483647;
    Y.path += "/" + se.toString(10) + (oe ? "'" : "");
  }
  return Y;
}
globalXpub$1.decode = decode$d;
function encode$e(B) {
  const z = Buffer$D.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), Y = Buffer$D.concat([z, B.extendedPubkey]), ne = B.path.split("/"), ie = Buffer$D.allocUnsafe(ne.length * 4);
  B.masterFingerprint.copy(ie, 0);
  let oe = 4;
  return ne.slice(1).forEach((se) => {
    const ae = se.slice(-1) === "'";
    let ge = 2147483647 & parseInt(ae ? se.slice(0, -1) : se, 10);
    ae && (ge += 2147483648), ie.writeUInt32LE(ge, oe), oe += 4;
  }), {
    key: Y,
    value: ie
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const z = B.extendedPubkey, Y = B.masterFingerprint, ne = B.path;
  return Buffer$D.isBuffer(z) && z.length === 78 && [2, 3].indexOf(z[45]) > -1 && Buffer$D.isBuffer(Y) && Y.length === 4 && typeof ne == "string" && !!ne.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, z, Y) {
  const ne = z.extendedPubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ie) => ie.extendedPubkey.equals(z.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(B) {
  return {
    key: Buffer$D.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(B) {
  return {
    key: Buffer$D.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$D.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, z) {
  return !!B && !!z && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(B) {
  return {
    key: Buffer$D.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$D.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, z) {
  return !!B && !!z && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(B) {
  return {
    key: Buffer$D.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$D.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, z) {
  return !!B && !!z && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(B) {
  const z = Buffer$D.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$D.concat([z, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$D.isBuffer(B.pubkey) && Buffer$D.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$D.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const z = B[3];
  if (z > 33 || z < 1 || B[3 + z + 1] !== 2) return !1;
  const Y = B[3 + z + 2];
  return !(Y > 33 || Y < 1 || B.length !== 3 + z + 2 + Y + 2);
}
function canAddToArray$2(B, z, Y) {
  const ne = z.pubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ie) => ie.pubkey.equals(z.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(B) {
  return {
    key: Buffer$D.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$D.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, z) {
  return !!B && !!z && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(B) {
  const z = Buffer$D.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), Y = Buffer$D.allocUnsafe(4);
  return Y.writeUInt32LE(B, 0), {
    key: z,
    value: Y
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, z) {
  return !!B && !!z && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(B) {
  return { key: Buffer$D.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$D.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, z) {
  return !!B && !!z && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const z = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== z)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const Y = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: Y, leafVersion: z };
}
tapLeafScript$1.decode = decode$5;
function encode$5(B) {
  const z = Buffer$D.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), Y = Buffer$D.from([B.leafVersion]);
  return {
    key: Buffer$D.concat([z, B.controlBlock]),
    value: Buffer$D.concat([B.script, Y])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$D.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$D.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, z, Y) {
  const ne = z.controlBlock.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((ie) => ie.controlBlock.equals(z.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(B) {
  return { key: Buffer$D.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$D.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, z) {
  return !!B && !!z && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const z = B.key.slice(1, 33), Y = B.key.slice(33);
  return {
    pubkey: z,
    leafHash: Y,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(B) {
  const z = Buffer$D.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$D.concat([z, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$D.isBuffer(B.pubkey) && Buffer$D.isBuffer(B.leafHash) && Buffer$D.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, z, Y) {
  const ne = z.pubkey.toString("hex") + z.leafHash.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter(
    (ie) => ie.pubkey.equals(z.pubkey) && ie.leafHash.equals(z.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(B, z, Y) {
  if (checkUInt53(B), z || (z = Buffer$D.allocUnsafe(encodingLength(B))), !Buffer$D.isBuffer(z))
    throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), Object.assign(encode$2, { bytes: 1 })) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), Object.assign(encode$2, { bytes: 3 })) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), Object.assign(encode$2, { bytes: 5 })) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), Object.assign(encode$2, { bytes: 9 })), z;
}
varint.encode = encode$2;
function decode$2(B, z) {
  if (!Buffer$D.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  const Y = B.readUInt8(z);
  if (Y < 253)
    return Object.assign(decode$2, { bytes: 1 }), Y;
  if (Y === 253)
    return Object.assign(decode$2, { bytes: 3 }), B.readUInt16LE(z + 1);
  if (Y === 254)
    return Object.assign(decode$2, { bytes: 5 }), B.readUInt32LE(z + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const ne = B.readUInt32LE(z + 1), oe = B.readUInt32LE(z + 5) * 4294967296 + ne;
    return checkUInt53(oe), oe;
  }
}
varint.decode = decode$2;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(B) {
  const z = B.map(keyValToBuffer);
  return z.push(Buffer$D.from([0])), Buffer$D.concat(z);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const z = B.key.length, Y = B.value.length, ne = varuint$6.encodingLength(z), ie = varuint$6.encodingLength(Y), oe = Buffer$D.allocUnsafe(
    ne + z + ie + Y
  );
  return varuint$6.encode(z, oe, 0), B.key.copy(oe, ne), varuint$6.encode(Y, oe, ne + z), B.value.copy(oe, ne + z + ie), oe;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint(ne + Y, 9007199254740991), ne + Y;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, z, Y) {
  return verifuint(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const z = tools_1$2.readUInt64LE(B.value, 0);
  let Y = 8;
  const ne = varuint$5.decode(B.value, Y);
  Y += varuint$5.encodingLength(ne);
  const ie = B.value.slice(Y);
  if (ie.length !== ne)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: ie,
    value: z
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(B) {
  const { script: z, value: Y } = B, ne = varuint$5.encodingLength(z.length), ie = Buffer$D.allocUnsafe(8 + ne + z.length);
  return tools_1$2.writeUInt64LE(ie, Y, 0), varuint$5.encode(z.length, ie, 8), z.copy(ie, 8 + ne), {
    key: Buffer$D.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: ie
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$D.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, z) {
  return !!B && !!z && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let z = 0;
  const Y = [];
  for (; z < B.value.length; ) {
    const ne = B.value[z++], ie = B.value[z++], oe = varuint$4.decode(B.value, z);
    z += varuint$4.encodingLength(oe), Y.push({
      depth: ne,
      leafVersion: ie,
      script: B.value.slice(z, z + oe)
    }), z += oe;
  }
  return { leaves: Y };
}
tapTree$1.decode = decode;
function encode(B) {
  const z = Buffer$D.from([typeFields_1$3.OutputTypes.TAP_TREE]), Y = [].concat(
    ...B.leaves.map((ne) => [
      Buffer$D.of(ne.depth, ne.leafVersion),
      varuint$4.encode(ne.script.length),
      ne.script
    ])
  );
  return {
    key: z,
    value: Buffer$D.concat(Y)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (z) => z.depth >= 0 && z.depth <= 128 && (z.leafVersion & 254) === z.leafVersion && Buffer$D.isBuffer(z.script)
  );
}
tapTree$1.check = check;
function canAdd(B, z) {
  return !!B && !!z && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, z = isValidDERKey) {
  function Y(ae) {
    if (ae.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ae.key.toString("hex")
      );
    const ge = ae.key.slice(1);
    if (!z(ge))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ae.key.toString("hex")
      );
    if (ae.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const Ce = {
      masterFingerprint: ae.value.slice(0, 4),
      pubkey: ge,
      path: "m"
    };
    for (const le of range$1(ae.value.length / 4 - 1)) {
      const Ee = ae.value.readUInt32LE(le * 4 + 4), Je = !!(Ee & 2147483648), Ve = Ee & 2147483647;
      Ce.path += "/" + Ve.toString(10) + (Je ? "'" : "");
    }
    return Ce;
  }
  function ne(ae) {
    const ge = Buffer$D.from([B]), Ce = Buffer$D.concat([ge, ae.pubkey]), le = ae.path.split("/"), Ee = Buffer$D.allocUnsafe(le.length * 4);
    ae.masterFingerprint.copy(Ee, 0);
    let Je = 4;
    return le.slice(1).forEach((Ve) => {
      const $t = Ve.slice(-1) === "'";
      let Nt = 2147483647 & parseInt($t ? Ve.slice(0, -1) : Ve, 10);
      $t && (Nt += 2147483648), Ee.writeUInt32LE(Nt, Je), Je += 4;
    }), {
      key: Ce,
      value: Ee
    };
  }
  const ie = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function oe(ae) {
    return Buffer$D.isBuffer(ae.pubkey) && Buffer$D.isBuffer(ae.masterFingerprint) && typeof ae.path == "string" && z(ae.pubkey) && ae.masterFingerprint.length === 4;
  }
  function se(ae, ge, Ce) {
    const le = ge.pubkey.toString("hex");
    return Ce.has(le) ? !1 : (Ce.add(le), ae.filter((Ee) => Ee.pubkey.equals(ge.pubkey)).length === 0);
  }
  return {
    decode: Y,
    encode: ne,
    check: oe,
    expected: ie,
    canAddToArray: se
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return z;
  function z(Y) {
    let ne;
    if (B.includes(Y.key[0]) && (ne = Y.key.slice(1), !(ne.length === 33 || ne.length === 65) || ![2, 3, 4].includes(ne[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Y.key.toString("hex")
      );
    return ne;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function z(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + se.key.toString("hex")
      );
    return se.value;
  }
  function Y(se) {
    return {
      key: Buffer$D.from([B]),
      value: se
    };
  }
  const ne = "Buffer";
  function ie(se) {
    return Buffer$D.isBuffer(se);
  }
  function oe(se, ae) {
    return !!se && !!ae && se.redeemScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ie,
    expected: ne,
    canAdd: oe
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const z = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function Y(se) {
    const ae = varuint$3.decode(se.value), ge = varuint$3.encodingLength(ae), Ce = z.decode({
      key: se.key,
      value: se.value.slice(ge + ae * 32)
    }), le = new Array(ae);
    for (let Ee = 0, Je = ge; Ee < ae; Ee++, Je += 32)
      le[Ee] = se.value.slice(Je, Je + 32);
    return Object.assign({}, Ce, { leafHashes: le });
  }
  function ne(se) {
    const ae = z.encode(se), ge = varuint$3.encodingLength(se.leafHashes.length), Ce = Buffer$D.allocUnsafe(ge);
    varuint$3.encode(se.leafHashes.length, Ce);
    const le = Buffer$D.concat([Ce, ...se.leafHashes, ae.value]);
    return Object.assign({}, ae, { value: le });
  }
  const ie = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function oe(se) {
    return Array.isArray(se.leafHashes) && se.leafHashes.every(
      (ae) => Buffer$D.isBuffer(ae) && ae.length === 32
    ) && z.check(se);
  }
  return {
    decode: Y,
    encode: ne,
    check: oe,
    expected: ie,
    canAddToArray: z.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function z(se) {
    if (se.key[0] !== B || se.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + se.key.toString("hex")
      );
    if (se.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return se.value;
  }
  function Y(se) {
    return { key: Buffer$D.from([B]), value: se };
  }
  const ne = "Buffer";
  function ie(se) {
    return Buffer$D.isBuffer(se) && se.length === 32;
  }
  function oe(se, ae) {
    return !!se && !!ae && se.tapInternalKey === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ie,
    expected: ne,
    canAdd: oe
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function z(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + se.key.toString("hex")
      );
    return se.value;
  }
  function Y(se) {
    return {
      key: Buffer$D.from([B]),
      value: se
    };
  }
  const ne = "Buffer";
  function ie(se) {
    return Buffer$D.isBuffer(se);
  }
  function oe(se, ae) {
    return !!se && !!ae && se.witnessScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: ie,
    expected: ne,
    canAdd: oe
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, z) {
  let Y = 0;
  function ne() {
    const Dt = varuint$2.decode(B, Y);
    Y += varuint$2.encodingLength(Dt);
    const Wt = B.slice(Y, Y + Dt);
    return Y += Dt, Wt;
  }
  function ie() {
    const Dt = B.readUInt32BE(Y);
    return Y += 4, Dt;
  }
  function oe() {
    const Dt = B.readUInt8(Y);
    return Y += 1, Dt;
  }
  function se() {
    const Dt = ne(), Wt = ne();
    return {
      key: Dt,
      value: Wt
    };
  }
  function ae() {
    if (Y >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const Dt = B.readUInt8(Y) === 0;
    return Dt && Y++, Dt;
  }
  if (ie() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (oe() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ge = [], Ce = {};
  for (; !ae(); ) {
    const Dt = se(), Wt = Dt.key.toString("hex");
    if (Ce[Wt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + Wt
      );
    Ce[Wt] = 1, ge.push(Dt);
  }
  const le = ge.filter(
    (Dt) => Dt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (le.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const Ee = z(le[0].value), { inputCount: Je, outputCount: Ve } = Ee.getInputOutputCounts(), $t = [], Nt = [];
  for (const Dt of tools_1$1.range(Je)) {
    const Wt = {}, Pt = [];
    for (; !ae(); ) {
      const Lt = se(), qt = Lt.key.toString("hex");
      if (Wt[qt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + Dt + " key " + qt
        );
      Wt[qt] = 1, Pt.push(Lt);
    }
    $t.push(Pt);
  }
  for (const Dt of tools_1$1.range(Ve)) {
    const Wt = {}, Pt = [];
    for (; !ae(); ) {
      const Lt = se(), qt = Lt.key.toString("hex");
      if (Wt[qt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + Dt + " key " + qt
        );
      Wt[qt] = 1, Pt.push(Lt);
    }
    Nt.push(Pt);
  }
  return psbtFromKeyVals(Ee, {
    globalMapKeyVals: ge,
    inputKeyVals: $t,
    outputKeyVals: Nt
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, z, Y) {
  if (!z.equals(Buffer$D.from([Y])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${z.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: z, inputKeyVals: Y, outputKeyVals: ne }) {
  const ie = {
    unsignedTx: B
  };
  let oe = 0;
  for (const le of z)
    switch (le.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          le.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), oe > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        oe++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        ie.globalXpub === void 0 && (ie.globalXpub = []), ie.globalXpub.push(convert$1.globals.globalXpub.decode(le));
        break;
      default:
        ie.unknownKeyVals || (ie.unknownKeyVals = []), ie.unknownKeyVals.push(le);
    }
  const se = Y.length, ae = ne.length, ge = [], Ce = [];
  for (const le of tools_1$1.range(se)) {
    const Ee = {};
    for (const Je of Y[le])
      switch (convert$1.inputs.checkPubkey(Je), Je.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), Ee.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          Ee.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Je);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), Ee.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          Ee.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Je);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          Ee.partialSig === void 0 && (Ee.partialSig = []), Ee.partialSig.push(convert$1.inputs.partialSig.decode(Je));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), Ee.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          Ee.sighashType = convert$1.inputs.sighashType.decode(Je);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.inputs.redeemScript.decode(Je);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.inputs.witnessScript.decode(Je);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Je)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), Ee.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Je);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), Ee.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Je
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), Ee.porCommitment = convert$1.inputs.porCommitment.decode(Je);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), Ee.tapKeySig = convert$1.inputs.tapKeySig.decode(Je);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          Ee.tapScriptSig === void 0 && (Ee.tapScriptSig = []), Ee.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Je));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          Ee.tapLeafScript === void 0 && (Ee.tapLeafScript = []), Ee.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Je));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Je)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Je);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Je.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), Ee.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Je);
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Je);
      }
    ge.push(Ee);
  }
  for (const le of tools_1$1.range(ae)) {
    const Ee = {};
    for (const Je of ne[le])
      switch (convert$1.outputs.checkPubkey(Je), Je.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.outputs.redeemScript.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.outputs.witnessScript.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Je)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Je.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), Ee.tapTree = convert$1.outputs.tapTree.decode(Je);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Je)
          );
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Je);
      }
    Ce.push(Ee);
  }
  return { globalMap: ie, inputs: ge, outputs: Ce };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: z, outputs: Y }) {
  const { globalKeyVals: ne, inputKeyVals: ie, outputKeyVals: oe } = psbtToKeyVals({
    globalMap: B,
    inputs: z,
    outputs: Y
  }), se = tools_1.keyValsToBuffer(ne), ae = (Ee) => Ee.length === 0 ? [Buffer$D.from([0])] : Ee.map(tools_1.keyValsToBuffer), ge = ae(ie), Ce = ae(oe), le = Buffer$D.allocUnsafe(5);
  return le.writeUIntBE(482972169471, 0, 5), Buffer$D.concat(
    [le, se].concat(ge, Ce)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, z) => B.key.compare(z.key);
function keyValsFromMap(B, z) {
  const Y = /* @__PURE__ */ new Set(), ne = Object.entries(B).reduce((oe, [se, ae]) => {
    if (se === "unknownKeyVals") return oe;
    const ge = z[se];
    if (ge === void 0) return oe;
    const Ce = (Array.isArray(ae) ? ae : [ae]).map(
      ge.encode
    );
    return Ce.map((Ee) => Ee.key.toString("hex")).forEach((Ee) => {
      if (Y.has(Ee))
        throw new Error("Serialize Error: Duplicate key: " + Ee);
      Y.add(Ee);
    }), oe.concat(Ce);
  }, []), ie = B.unknownKeyVals ? B.unknownKeyVals.filter((oe) => !Y.has(oe.key.toString("hex"))) : [];
  return ne.concat(ie).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: z, outputs: Y }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: z.map((ne) => keyValsFromMap(ne, convert.inputs)),
    outputKeyVals: Y.map((ne) => keyValsFromMap(ne, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function z(Y) {
    for (var ne in Y) B.hasOwnProperty(ne) || (B[ne] = Y[ne]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), z(fromBuffer), z(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const z = B[0], Y = parser_1$1.psbtToKeyVals(z), ne = B.slice(1);
  if (ne.length === 0) throw new Error("Combine: Nothing to combine");
  const ie = getTx(z);
  if (ie === void 0)
    throw new Error("Combine: Self missing transaction");
  const oe = getKeySet(Y.globalKeyVals), se = Y.inputKeyVals.map(getKeySet), ae = Y.outputKeyVals.map(getKeySet);
  for (const ge of ne) {
    const Ce = getTx(ge);
    if (Ce === void 0 || !Ce.toBuffer().equals(ie.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const le = parser_1$1.psbtToKeyVals(ge);
    getKeySet(le.globalKeyVals).forEach(
      keyPusher(
        oe,
        Y.globalKeyVals,
        le.globalKeyVals
      )
    ), le.inputKeyVals.map(getKeySet).forEach(
      ($t, Nt) => $t.forEach(
        keyPusher(
          se[Nt],
          Y.inputKeyVals[Nt],
          le.inputKeyVals[Nt]
        )
      )
    ), le.outputKeyVals.map(getKeySet).forEach(
      ($t, Nt) => $t.forEach(
        keyPusher(
          ae[Nt],
          Y.outputKeyVals[Nt],
          le.outputKeyVals[Nt]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(ie, {
    globalMapKeyVals: Y.globalKeyVals,
    inputKeyVals: Y.inputKeyVals,
    outputKeyVals: Y.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, z, Y) {
  return (ne) => {
    if (B.has(ne)) return;
    const ie = Y.filter((oe) => oe.key.toString("hex") === ne)[0];
    z.push(ie), B.add(ne);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const z = /* @__PURE__ */ new Set();
  return B.forEach((Y) => {
    const ne = Y.key.toString("hex");
    if (z.has(ne))
      throw new Error("Combine: KeyValue Map keys should be unique");
    z.add(ne);
  }), z;
}
var utils = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const z = converter;
  function Y(Ve, $t) {
    const Nt = Ve[$t];
    if (Nt === void 0) throw new Error(`No input #${$t}`);
    return Nt;
  }
  B.checkForInput = Y;
  function ne(Ve, $t) {
    const Nt = Ve[$t];
    if (Nt === void 0) throw new Error(`No output #${$t}`);
    return Nt;
  }
  B.checkForOutput = ne;
  function ie(Ve, $t, Nt) {
    if (Ve.key[0] < Nt)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if ($t && $t.filter((Dt) => Dt.key.equals(Ve.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Ve.key.toString("hex")}`);
  }
  B.checkHasKey = ie;
  function oe(Ve) {
    let $t = 0;
    return Object.keys(Ve).forEach((Nt) => {
      Number(isNaN(Number(Nt))) && $t++;
    }), $t;
  }
  B.getEnumLength = oe;
  function se(Ve, $t) {
    let Nt = !1;
    if ($t.nonWitnessUtxo || $t.witnessUtxo) {
      const Dt = !!$t.redeemScript, Wt = !!$t.witnessScript, Pt = !Dt || !!$t.finalScriptSig, Lt = !Wt || !!$t.finalScriptWitness, qt = !!$t.finalScriptSig || !!$t.finalScriptWitness;
      Nt = Pt && Lt && qt;
    }
    if (Nt === !1)
      throw new Error(
        `Input #${Ve} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = se;
  function ae(Ve, $t, Nt, Dt) {
    throw new Error(
      `Data for ${Ve} key ${$t} is incorrect: Expected ${Nt} and got ${JSON.stringify(Dt)}`
    );
  }
  function ge(Ve) {
    return ($t, Nt) => {
      for (const Dt of Object.keys($t)) {
        const Wt = $t[Dt], { canAdd: Pt, canAddToArray: Lt, check: qt, expected: Zt } = (
          // @ts-ignore
          z[Ve + "s"][Dt] || {}
        ), Yt = !!Lt;
        if (qt)
          if (Yt) {
            if (!Array.isArray(Wt) || // @ts-ignore
            Nt[Dt] && !Array.isArray(Nt[Dt]))
              throw new Error(`Key type ${Dt} must be an array`);
            Wt.every(qt) || ae(Ve, Dt, Zt, Wt);
            const or = Nt[Dt] || [], jt = /* @__PURE__ */ new Set();
            if (!Wt.every((Ct) => Lt(or, Ct, jt)))
              throw new Error("Can not add duplicate data to array");
            Nt[Dt] = or.concat(Wt);
          } else {
            if (qt(Wt) || ae(Ve, Dt, Zt, Wt), !Pt(Nt, Wt))
              throw new Error(`Can not add duplicate data to ${Ve}`);
            Nt[Dt] = Wt;
          }
      }
    };
  }
  B.updateGlobal = ge("global"), B.updateInput = ge("input"), B.updateOutput = ge("output");
  function Ce(Ve, $t) {
    const Nt = Ve.length - 1, Dt = Y(Ve, Nt);
    B.updateInput($t, Dt);
  }
  B.addInputAttributes = Ce;
  function le(Ve, $t) {
    const Nt = Ve.length - 1, Dt = ne(Ve, Nt);
    B.updateOutput($t, Dt);
  }
  B.addOutputAttributes = le;
  function Ee(Ve, $t) {
    if (!Buffer$D.isBuffer($t) || $t.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return $t.writeUInt32LE(Ve, 0), $t;
  }
  B.defaultVersionSetter = Ee;
  function Je(Ve, $t) {
    if (!Buffer$D.isBuffer($t) || $t.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return $t.writeUInt32LE(Ve, $t.length - 4), $t;
  }
  B.defaultLocktimeSetter = Je;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(z) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: z
    };
  }
  static fromBase64(z, Y) {
    const ne = Buffer$D.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y) {
    const ne = Buffer$D.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y) {
    const ne = parser_1.psbtFromBuffer(z, Y), ie = new this(ne.globalMap.unsignedTx);
    return Object.assign(ie, ne), ie;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(z) {
    return utils_1$1.updateGlobal(z, this.globalMap), this;
  }
  updateInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.updateInput(Y, ne), this;
  }
  updateOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.updateOutput(Y, ne), this;
  }
  addUnknownKeyValToGlobal(z) {
    return utils_1$1.checkHasKey(
      z,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addInput(z) {
    this.globalMap.unsignedTx.addInput(z), this.inputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.inputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (ie) => this.addUnknownKeyValToInput(ne, ie)
    ), utils_1$1.addInputAttributes(this.inputs, z), this;
  }
  addOutput(z) {
    this.globalMap.unsignedTx.addOutput(z), this.outputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.outputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (ie) => this.addUnknownKeyValToOutput(ne, ie)
    ), utils_1$1.addOutputAttributes(this.outputs, z), this;
  }
  clearFinalizedInput(z) {
    const Y = utils_1$1.checkForInput(this.inputs, z);
    utils_1$1.inputCheckUncleanFinalized(z, Y);
    for (const ne of Object.keys(Y))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(ne) || delete Y[ne];
    return this;
  }
  combine(...z) {
    const Y = combiner_1.combine([this].concat(z));
    return Object.assign(this, Y), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(B) {
  return (z) => {
    try {
      return B({ output: z }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let z = Buffer$D.allocUnsafe(0);
  function Y(se) {
    z = Buffer$D.concat([z, Buffer$D.from(se)]);
  }
  function ne(se) {
    const ae = z.length, ge = varuint$1.encodingLength(se);
    z = Buffer$D.concat([z, Buffer$D.allocUnsafe(ge)]), varuint$1.encode(se, z, ae);
  }
  function ie(se) {
    ne(se.length), Y(se);
  }
  function oe(se) {
    ne(se.length), se.forEach(ie);
  }
  return oe(B), z;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, z) {
  const Y = (0, crypto_1.hash160)(B), ne = B.slice(1, 33), ie = bscript$1.decompile(z);
  if (ie === null) throw new Error("Unknown script error");
  return ie.findIndex((oe) => typeof oe == "number" ? !1 : oe.equals(B) || oe.equals(Y) || oe.equals(ne));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, z) {
  return pubkeyPositionInScript(B, z) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, z) {
  return extractPartialSigs(B).some(
    (ne) => signatureBlocksAction(ne, bscript$1.signature.decode, z)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, z, Y) {
  const { hashType: ne } = z(B), ie = [];
  switch (ne & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && ie.push("addInput"), ne & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      ie.push("addOutput"), ie.push("setInputSequence");
      break;
  }
  return ie.indexOf(Y) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let z = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    z = getPsigsFromInputFinalScripts(B);
  } else
    z = B.partialSig;
  return z.map((Y) => Y.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const z = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], Y = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return z.concat(Y).filter((ne) => Buffer$D.isBuffer(ne) && bscript$1.isCanonicalScriptSignature(ne)).map((ne) => ({ signature: ne }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(B, z, Y) {
  const ne = findTapLeafToFinalize(
    z,
    B,
    Y
  );
  try {
    const oe = sortSignatures(z, ne).concat(ne.script).concat(ne.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(oe)
    };
  } catch (ie) {
    throw new Error(`Can not finalize taproot input #${B}: ${ie}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, z) {
  const Y = z ? Buffer$D.from([z]) : Buffer$D.from([]);
  return Buffer$D.concat([B, Y]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, z) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || z && (0, psbtutils_1$1.isP2TR)(z));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootInputFields(B, z, Y), checkIfTapLeafInTree(B, z, Y);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootOutputFields(B, z, Y), checkTaprootScriptPubkey(B, z);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, z) {
  if (!z.tapTree && !z.tapInternalKey) return;
  const Y = z.tapInternalKey || B.tapInternalKey, ne = z.tapTree || B.tapTree;
  if (Y) {
    const { script: ie } = B, oe = getTaprootScripPubkey(Y, ne);
    if (ie && !ie.equals(oe))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, z) {
  const Y = z && tapTreeFromList(z.leaves), { output: ne } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: Y
  });
  return ne;
}
function tweakInternalPubKey(B, z) {
  const Y = z.tapInternalKey, ne = Y && (0, bip341_1$1.tweakKey)(Y, z.tapMerkleRoot);
  if (!ne)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${Y && Y.toString("hex")}`
    );
  return ne.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, z) {
  return extractTaprootSigs(B).some(
    (ne) => (0, psbtutils_2.signatureBlocksAction)(ne, decodeSchnorrSignature, z)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const z = [];
  if (B.tapKeySig && z.push(B.tapKeySig), B.tapScriptSig && z.push(...B.tapScriptSig.map((Y) => Y.signature)), !z.length) {
    const Y = getTapKeySigFromWithness(B.finalScriptWitness);
    Y && z.push(Y);
  }
  return z;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const z = B.slice(2);
  if (z.length === 64 || z.length === 65) return z;
}
function _tapTreeToList(B, z = [], Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (z.push({
    depth: Y,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), z) : (B[0] && _tapTreeToList(B[0], z, Y + 1), B[1] && _tapTreeToList(B[1], z, Y + 1), z) : [];
}
function instertLeavesInTree(B) {
  let z;
  for (const Y of B)
    if (z = instertLeafInTree(Y, z), !z) throw new Error("No room left to insert tapleaf in tree");
  return z;
}
function instertLeafInTree(B, z, Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === Y)
    return z ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(z)) return;
  const ne = instertLeafInTree(B, z && z[0], Y + 1);
  if (ne) return [ne, z && z[1]];
  const ie = instertLeafInTree(B, z && z[1], Y + 1);
  if (ie) return [z && z[0], ie];
}
function checkMixedTaprootAndNonTaprootInputFields(B, z, Y) {
  const ne = isTaprootInput(B) && hasNonTaprootFields(z), ie = hasNonTaprootFields(B) && isTaprootInput(z), oe = B === z && isTaprootInput(z) && hasNonTaprootFields(z);
  if (ne || ie || oe)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, z, Y) {
  const ne = isTaprootOutput(B) && hasNonTaprootFields(z), ie = hasNonTaprootFields(B) && isTaprootOutput(z), oe = B === z && isTaprootOutput(z) && hasNonTaprootFields(z);
  if (ne || ie || oe)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, z, Y) {
  if (z.tapMerkleRoot) {
    const ne = (z.tapLeafScript || []).every(
      (oe) => isTapLeafInTree(oe, z.tapMerkleRoot)
    ), ie = (B.tapLeafScript || []).every(
      (oe) => isTapLeafInTree(oe, z.tapMerkleRoot)
    );
    if (!ne || !ie)
      throw new Error(
        `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(z.tapLeafScript || []).every(
    (ie) => isTapLeafInTree(ie, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, z) {
  if (!z) return !0;
  const Y = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    Y
  ).equals(z);
}
function sortSignatures(B, z) {
  const Y = (0, bip341_1$1.tapleafHash)({
    output: z.script,
    version: z.leafVersion
  });
  return (B.tapScriptSig || []).filter((ne) => ne.leafHash.equals(Y)).map((ne) => addPubkeyPositionInScript(z.script, ne)).sort((ne, ie) => ie.positionInScript - ne.positionInScript).map((ne) => ne.signature);
}
function addPubkeyPositionInScript(B, z) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        z.pubkey,
        B
      )
    },
    z
  );
}
function findTapLeafToFinalize(B, z, Y) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${z}. No tapleaf script signature provided.`
    );
  const ne = (B.tapLeafScript || []).sort((ie, oe) => ie.controlBlock.length - oe.controlBlock.length).find(
    (ie) => canFinalizeLeaf(ie, B.tapScriptSig, Y)
  );
  if (!ne)
    throw new Error(
      `Can not finalize taproot input #${z}. Signature for tapleaf script not found.`
    );
  return ne;
}
function canFinalizeLeaf(B, z, Y) {
  const ne = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!Y || Y.equals(ne)) && z.find((oe) => oe.leafHash.equals(ne)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(z, Y = {}) {
    const ne = Buffer$D.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y = {}) {
    const ne = Buffer$D.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y = {}) {
    const ne = bip174_1.Psbt.fromBuffer(z, transactionFromBuffer), ie = new Psbt(Y, ne);
    return checkTxForDupeIns(ie.__CACHE.__TX, ie.__CACHE), ie;
  }
  constructor(z = {}, Y = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = Y, this.opts = Object.assign({}, DEFAULT_OPTS, z), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const ne = (ie, oe, se, ae) => Object.defineProperty(ie, oe, {
      enumerable: se,
      writable: ae
    });
    ne(this, "__CACHE", !1, !0), ne(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(z) {
    this.setVersion(z);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(z) {
    this.setLocktime(z);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((z) => ({
      hash: (0, bufferutils_1.cloneBuffer)(z.hash),
      index: z.index,
      sequence: z.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((z) => {
      let Y;
      try {
        Y = (0, address_1.fromOutputScript)(
          z.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(z.script),
        value: z.value,
        address: Y
      };
    });
  }
  combine(...z) {
    return this.data.combine(...z.map((Y) => Y.data)), this;
  }
  clone() {
    const z = Psbt.fromBuffer(this.data.toBuffer());
    return z.opts = JSON.parse(JSON.stringify(this.opts)), z;
  }
  setMaximumFeeRate(z) {
    check32Bit(z), this.opts.maximumFeeRate = z;
  }
  setVersion(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const Y = this.__CACHE;
    return Y.__TX.version = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const Y = this.__CACHE;
    return Y.__TX.locktime = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(z, Y) {
    check32Bit(Y), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const ne = this.__CACHE;
    if (ne.__TX.ins.length <= z)
      throw new Error("Input index too high");
    return ne.__TX.ins[z].sequence = Y, ne.__EXTRACTED_TX = void 0, this;
  }
  addInputs(z) {
    return z.forEach((Y) => this.addInput(Y)), this;
  }
  addInput(z) {
    if (arguments.length > 1 || !z || z.hash === void 0 || z.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(z, z, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), z.witnessScript && checkInvalidP2WSH(z.witnessScript);
    const Y = this.__CACHE;
    this.data.addInput(z);
    const ne = Y.__TX.ins[Y.__TX.ins.length - 1];
    checkTxInputCache(Y, ne);
    const ie = this.data.inputs.length - 1, oe = this.data.inputs[ie];
    return oe.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, oe, ie), Y.__FEE = void 0, Y.__FEE_RATE = void 0, Y.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(z) {
    return z.forEach((Y) => this.addOutput(Y)), this;
  }
  addOutput(z) {
    if (arguments.length > 1 || !z || z.value === void 0 || z.address === void 0 && z.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: Y } = z;
    if (typeof Y == "string") {
      const { network: ie } = this.opts, oe = (0, address_1.toOutputScript)(Y, ie);
      z = Object.assign({}, z, { script: oe });
    }
    (0, bip371_1.checkTaprootOutputFields)(z, z, "addOutput");
    const ne = this.__CACHE;
    return this.data.addOutput(z), ne.__FEE = void 0, ne.__FEE_RATE = void 0, ne.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(z) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const Y = this.__CACHE;
    if (z || checkFees(this, Y, this.opts), Y.__EXTRACTED_TX) return Y.__EXTRACTED_TX;
    const ne = Y.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, ne, Y, !0), ne;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((z) => this.finalizeInput(z)), this;
  }
  finalizeInput(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ne) ? this._finalizeTaprootInput(
      z,
      ne,
      void 0,
      Y
    ) : this._finalizeInput(z, ne, Y);
  }
  finalizeTaprootInput(z, Y, ne = bip371_1.tapScriptFinalizer) {
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(ie))
      return this._finalizeTaprootInput(
        z,
        ie,
        Y,
        ne
      );
    throw new Error(`Cannot finalize input #${z}. Not Taproot.`);
  }
  _finalizeInput(z, Y, ne = getFinalScripts) {
    const { script: ie, isP2SH: oe, isP2WSH: se, isSegwit: ae } = getScriptFromInput(
      z,
      Y,
      this.__CACHE
    );
    if (!ie) throw new Error(`No script found for input #${z}`);
    checkPartialSigSighashes(Y);
    const { finalScriptSig: ge, finalScriptWitness: Ce } = ne(
      z,
      Y,
      ie,
      ae,
      oe,
      se
    );
    if (ge && this.data.updateInput(z, { finalScriptSig: ge }), Ce && this.data.updateInput(z, { finalScriptWitness: Ce }), !ge && !Ce)
      throw new Error(`Unknown error finalizing input #${z}`);
    return this.data.clearFinalizedInput(z), this;
  }
  _finalizeTaprootInput(z, Y, ne, ie = bip371_1.tapScriptFinalizer) {
    if (!Y.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${z}. Missing withness utxo.`
      );
    if (Y.tapKeySig) {
      const oe = payments.p2tr({
        output: Y.witnessUtxo.script,
        signature: Y.tapKeySig
      }), se = (0, psbtutils_1.witnessStackToScriptWitness)(
        oe.witness
      );
      this.data.updateInput(z, { finalScriptWitness: se });
    } else {
      const { finalScriptWitness: oe } = ie(
        z,
        Y,
        ne
      );
      this.data.updateInput(z, { finalScriptWitness: oe });
    }
    return this.data.clearFinalizedInput(z), this;
  }
  getInputType(z) {
    const Y = (0, utils_1.checkForInput)(this.data.inputs, z), ne = getScriptFromUtxo(z, Y, this.__CACHE), ie = getMeaningfulScript(
      ne,
      z,
      "input",
      Y.redeemScript || redeemFromFinalScriptSig(Y.finalScriptSig),
      Y.witnessScript || redeemFromFinalWitnessScript(Y.finalScriptWitness)
    ), oe = ie.type === "raw" ? "" : ie.type + "-", se = classifyScript(ie.meaningfulScript);
    return oe + se;
  }
  inputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return pubkeyInInput(Y, ne, z, this.__CACHE);
  }
  inputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z), ie = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(ie);
  }
  outputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z);
    return pubkeyInOutput(Y, ne, z, this.__CACHE);
  }
  outputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z), ie = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(ie);
  }
  validateSignaturesOfAllInputs(z) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (ne) => this.validateSignaturesOfInput(ne, z)
    ).reduce((ne, ie) => ie === !0 && ne, !0);
  }
  validateSignaturesOfInput(z, Y, ne) {
    const ie = this.data.inputs[z];
    return (0, bip371_1.isTaprootInput)(ie) ? this.validateSignaturesOfTaprootInput(
      z,
      Y,
      ne
    ) : this._validateSignaturesOfInput(z, Y, ne);
  }
  _validateSignaturesOfInput(z, Y, ne) {
    const ie = this.data.inputs[z], oe = (ie || {}).partialSig;
    if (!ie || !oe || oe.length < 1)
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    const se = ne ? oe.filter((Ee) => Ee.pubkey.equals(ne)) : oe;
    if (se.length < 1) throw new Error("No signatures for this pubkey");
    const ae = [];
    let ge, Ce, le;
    for (const Ee of se) {
      const Je = bscript.signature.decode(Ee.signature), { hash: Ve, script: $t } = le !== Je.hashType ? getHashForSig(
        z,
        Object.assign({}, ie, { sighashType: Je.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ge, script: Ce };
      le = Je.hashType, ge = Ve, Ce = $t, checkScriptForPubkey(Ee.pubkey, $t, "verify"), ae.push(Y(Ee.pubkey, Ve, Je.signature));
    }
    return ae.every((Ee) => Ee === !0);
  }
  validateSignaturesOfTaprootInput(z, Y, ne) {
    const ie = this.data.inputs[z], oe = (ie || {}).tapKeySig, se = (ie || {}).tapScriptSig;
    if (!ie && !oe && !(se && !se.length))
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    ne = ne && (0, bip371_1.toXOnly)(ne);
    const ae = ne ? getTaprootHashesForSig(
      z,
      ie,
      this.data.inputs,
      ne,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      z,
      ie,
      this.data.inputs,
      this.__CACHE
    );
    if (!ae.length) throw new Error("No signatures for this pubkey");
    const ge = ae.find((le) => !le.leafHash);
    let Ce = 0;
    if (oe && ge) {
      if (!Y(
        ge.pubkey,
        ge.hash,
        trimTaprootSig(oe)
      )) return !1;
      Ce++;
    }
    if (se)
      for (const le of se) {
        const Ee = ae.find((Je) => le.pubkey.equals(Je.pubkey));
        if (Ee) {
          if (!Y(
            le.pubkey,
            Ee.hash,
            trimTaprootSig(le.signature)
          )) return !1;
          Ce++;
        }
      }
    return Ce > 0;
  }
  signAllInputsHD(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!z || !z.publicKey || !z.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const ne = [];
    for (const ie of range(this.data.inputs.length))
      try {
        this.signInputHD(ie, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((ie) => ie === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ne, ie) => {
      if (!z || !z.publicKey || !z.fingerprint)
        return ie(new Error("Need HDSigner to sign input"));
      const oe = [], se = [];
      for (const ae of range(this.data.inputs.length))
        se.push(
          this.signInputHDAsync(ae, z, Y).then(
            () => {
              oe.push(!0);
            },
            () => {
              oe.push(!1);
            }
          )
        );
      return Promise.all(se).then(() => {
        if (oe.every((ae) => ae === !1))
          return ie(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInputHD(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!Y || !Y.publicKey || !Y.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(z, this.data.inputs, Y).forEach((oe) => this.signInput(z, oe, ne)), this;
  }
  signInputHDAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ie, oe) => {
      if (!Y || !Y.publicKey || !Y.fingerprint)
        return oe(new Error("Need HDSigner to sign input"));
      const ae = getSignersFromHD(z, this.data.inputs, Y).map(
        (ge) => this.signInputAsync(z, ge, ne)
      );
      return Promise.all(ae).then(() => {
        ie();
      }).catch(oe);
    });
  }
  signAllInputs(z, Y) {
    if (!z || !z.publicKey)
      throw new Error("Need Signer to sign input");
    const ne = [];
    for (const ie of range(this.data.inputs.length))
      try {
        this.signInput(ie, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((ie) => ie === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(z, Y) {
    return new Promise((ne, ie) => {
      if (!z || !z.publicKey)
        return ie(new Error("Need Signer to sign input"));
      const oe = [], se = [];
      for (const [ae] of this.data.inputs.entries())
        se.push(
          this.signInputAsync(ae, z, Y).then(
            () => {
              oe.push(!0);
            },
            () => {
              oe.push(!1);
            }
          )
        );
      return Promise.all(se).then(() => {
        if (oe.every((ae) => ae === !1))
          return ie(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInput(z, Y, ne) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ie) ? this._signTaprootInput(
      z,
      ie,
      Y,
      void 0,
      ne
    ) : this._signInput(z, Y, ne);
  }
  signTaprootInput(z, Y, ne, ie) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(oe))
      return this._signTaprootInput(
        z,
        oe,
        Y,
        ne,
        ie
      );
    throw new Error(`Input #${z} is not of type Taproot.`);
  }
  _signInput(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: ie, sighashType: oe } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    ), se = [
      {
        pubkey: Y.publicKey,
        signature: bscript.signature.encode(Y.sign(ie), oe)
      }
    ];
    return this.data.updateInput(z, { partialSig: se }), this;
  }
  _signTaprootInput(z, Y, ne, ie, oe = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const se = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      ie,
      oe
    ), ae = se.filter((Ce) => !Ce.leafHash).map(
      (Ce) => (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(Ce.hash),
        Y.sighashType
      )
    )[0], ge = se.filter((Ce) => !!Ce.leafHash).map((Ce) => ({
      pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(Ce.hash),
        Y.sighashType
      ),
      leafHash: Ce.leafHash
    }));
    return ae && this.data.updateInput(z, { tapKeySig: ae }), ge.length && this.data.updateInput(z, { tapScriptSig: ge }), this;
  }
  signInputAsync(z, Y, ne) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
      return (0, bip371_1.isTaprootInput)(ie) ? this._signTaprootInputAsync(
        z,
        ie,
        Y,
        void 0,
        ne
      ) : this._signInputAsync(z, Y, ne);
    });
  }
  signTaprootInputAsync(z, Y, ne, ie) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
      if ((0, bip371_1.isTaprootInput)(oe))
        return this._signTaprootInputAsync(
          z,
          oe,
          Y,
          ne,
          ie
        );
      throw new Error(`Input #${z} is not of type Taproot.`);
    });
  }
  _signInputAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: ie, sighashType: oe } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    );
    return Promise.resolve(Y.sign(ie)).then((se) => {
      const ae = [
        {
          pubkey: Y.publicKey,
          signature: bscript.signature.encode(se, oe)
        }
      ];
      this.data.updateInput(z, { partialSig: ae });
    });
  }
  async _signTaprootInputAsync(z, Y, ne, ie, oe = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const se = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      ie,
      oe
    ), ae = [], ge = se.filter((le) => !le.leafHash)[0];
    if (ge) {
      const le = Promise.resolve(
        ne.signSchnorr(ge.hash)
      ).then((Ee) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          Ee,
          Y.sighashType
        )
      }));
      ae.push(le);
    }
    const Ce = se.filter((le) => !!le.leafHash);
    if (Ce.length) {
      const le = Ce.map((Ee) => Promise.resolve(ne.signSchnorr(Ee.hash)).then(
        (Je) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Je,
              Y.sighashType
            ),
            leafHash: Ee.leafHash
          }
        ] })
      ));
      ae.push(...le);
    }
    return Promise.all(ae).then((le) => {
      le.forEach((Ee) => this.data.updateInput(z, Ee));
    });
  }
  checkTaprootHashesForSig(z, Y, ne, ie, oe) {
    if (typeof ne.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${z}.`
      );
    const se = getTaprootHashesForSig(
      z,
      Y,
      this.data.inputs,
      ne.publicKey,
      this.__CACHE,
      ie,
      oe
    );
    if (!se || !se.length)
      throw new Error(
        `Can not sign for input #${z} with the key ${ne.publicKey.toString(
          "hex"
        )}`
      );
    return se;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(z) {
    return this.data.updateGlobal(z), this;
  }
  updateInput(z, Y) {
    return Y.witnessScript && checkInvalidP2WSH(Y.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[z],
      Y,
      "updateInput"
    ), this.data.updateInput(z, Y), Y.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[z],
      z
    ), this;
  }
  updateOutput(z, Y) {
    const ne = this.data.outputs[z];
    return (0, bip371_1.checkTaprootOutputFields)(
      ne,
      Y,
      "updateOutput"
    ), this.data.updateOutput(z, Y), this;
  }
  addUnknownKeyValToGlobal(z) {
    return this.data.addUnknownKeyValToGlobal(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    return this.data.addUnknownKeyValToInput(z, Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    return this.data.addUnknownKeyValToOutput(z, Y), this;
  }
  clearFinalizedInput(z) {
    return this.data.clearFinalizedInput(z), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(z = Buffer$D.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(z), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(z) {
    if (z.hash === void 0 || z.index === void 0 || !Buffer$D.isBuffer(z.hash) && typeof z.hash != "string" || typeof z.index != "number")
      throw new Error("Error adding input.");
    const Y = typeof z.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$D.from(z.hash, "hex")) : z.hash;
    this.tx.addInput(Y, z.index, z.sequence);
  }
  addOutput(z) {
    if (z.script === void 0 || z.value === void 0 || !Buffer$D.isBuffer(z.script) || typeof z.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(z.script, z.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, z, Y) {
  switch (Y) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const ne = payments.p2ms({ output: z });
      return hasSigs(ne.m, B.partialSig, ne.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, z, Y) {
  if (!z) return !1;
  let ne;
  if (Y ? ne = Y.map((ie) => {
    const oe = compressPubkey(ie);
    return z.find((se) => se.pubkey.equals(oe));
  }).filter((ie) => !!ie) : ne = z, ne.length > B) throw new Error("Too many signatures");
  return ne.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (z) => !(!z.masterFingerprint.equals(B.fingerprint) || !B.derivePath(z.path).publicKey.equals(z.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, z, Y) {
  const ne = z.__FEE_RATE || B.getFeeRate(), ie = z.__EXTRACTED_TX.virtualSize(), oe = ne * ie;
  if (ne >= Y.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(oe / 1e8).toFixed(8)} in fees, which is ${ne} satoshi per byte for a transaction with a VSize of ${ie} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, z) {
  B.forEach((Y) => {
    if ((0, bip371_1.isTaprootInput)(Y) ? (0, bip371_1.checkTaprootInputForSigs)(Y, z) : (0, psbtutils_1.checkInputForSig)(Y, z))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: z, sighashType: Y } = B;
  z.forEach((ne) => {
    const { hashType: ie } = bscript.signature.decode(ne.signature);
    if (Y !== ie)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, z, Y) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, z))
    throw new Error(
      `Can not ${Y} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (Y) => Y.script && Y.script.length === 0 && Y.witness && Y.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, z) {
  B.ins.forEach((Y) => {
    checkTxInputCache(z, Y);
  });
}
function checkTxInputCache(B, z) {
  const Y = (0, bufferutils_1.reverseBuffer)(Buffer$D.from(z.hash)).toString("hex") + ":" + z.index;
  if (B.__TX_IN_CACHE[Y]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[Y] = 1;
}
function scriptCheckerFactory(B, z) {
  return (Y, ne, ie, oe) => {
    const se = B({
      redeem: { output: ie }
    }).output;
    if (!ne.equals(se))
      throw new Error(
        `${z} for ${oe} #${Y} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, z, Y, ne) {
  if (!Y.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${z}`);
  if (B === "__FEE_RATE" && ne.__FEE_RATE) return ne.__FEE_RATE;
  if (B === "__FEE" && ne.__FEE) return ne.__FEE;
  let ie, oe = !0;
  if (ne.__EXTRACTED_TX ? (ie = ne.__EXTRACTED_TX, oe = !1) : ie = ne.__TX.clone(), inputFinalizeGetAmts(Y, ie, ne, oe), B === "__FEE_RATE") return ne.__FEE_RATE;
  if (B === "__FEE") return ne.__FEE;
}
function getFinalScripts(B, z, Y, ne, ie, oe) {
  const se = classifyScript(Y);
  if (!canFinalize(z, Y, se))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    Y,
    se,
    z.partialSig,
    ne,
    ie,
    oe
  );
}
function prepareFinalScripts(B, z, Y, ne, ie, oe) {
  let se, ae;
  const ge = getPayment(B, z, Y), Ce = oe ? payments.p2wsh({ redeem: ge }) : null, le = ie ? payments.p2sh({ redeem: Ce || ge }) : null;
  return ne ? (Ce ? ae = (0, psbtutils_1.witnessStackToScriptWitness)(
    Ce.witness
  ) : ae = (0, psbtutils_1.witnessStackToScriptWitness)(
    ge.witness
  ), le && (se = le.input)) : le ? se = le.input : se = ge.input, {
    finalScriptSig: se,
    finalScriptWitness: ae
  };
}
function getHashAndSighashType(B, z, Y, ne, ie) {
  const oe = (0, utils_1.checkForInput)(B, z), { hash: se, sighashType: ae, script: ge } = getHashForSig(
    z,
    oe,
    ne,
    !1,
    ie
  );
  return checkScriptForPubkey(Y, ge, "sign"), {
    hash: se,
    sighashType: ae
  };
}
function getHashForSig(B, z, Y, ne, ie) {
  const oe = Y.__TX, se = z.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(se, ie);
  let ae, ge;
  if (z.nonWitnessUtxo) {
    const Ee = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), Je = oe.ins[B].hash, Ve = Ee.getHash();
    if (!Je.equals(Ve))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const $t = oe.ins[B].index;
    ge = Ee.outs[$t];
  } else if (z.witnessUtxo)
    ge = z.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: Ce, type: le } = getMeaningfulScript(
    ge.script,
    B,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(le) >= 0)
    ae = oe.hashForWitnessV0(
      B,
      Ce,
      ge.value,
      se
    );
  else if ((0, psbtutils_1.isP2WPKH)(Ce)) {
    const Ee = payments.p2pkh({
      hash: Ce.slice(2)
    }).output;
    ae = oe.hashForWitnessV0(
      B,
      Ee,
      ge.value,
      se
    );
  } else {
    if (z.nonWitnessUtxo === void 0 && Y.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${Ce.toString("hex")}`
      );
    !ne && Y.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ae = oe.hashForSignature(
      B,
      Ce,
      se
    );
  }
  return {
    script: Ce,
    sighashType: se,
    hash: ae
  };
}
function getAllTaprootHashesForSig(B, z, Y, ne) {
  const ie = [];
  if (z.tapInternalKey) {
    const se = getPrevoutTaprootKey(B, z, ne);
    se && ie.push(se);
  }
  if (z.tapScriptSig) {
    const se = z.tapScriptSig.map((ae) => ae.pubkey);
    ie.push(...se);
  }
  return ie.map(
    (se) => getTaprootHashesForSig(B, z, Y, se, ne)
  ).flat();
}
function getPrevoutTaprootKey(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return (0, psbtutils_1.isP2TR)(ne) ? ne.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, z, Y, ne, ie, oe, se) {
  const ae = ie.__TX, ge = z.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ge, se);
  const Ce = Y.map(
    ($t, Nt) => getScriptAndAmountFromUtxo(Nt, $t, ie)
  ), le = Ce.map(($t) => $t.script), Ee = Ce.map(($t) => $t.value), Je = [];
  if (z.tapInternalKey && !oe) {
    const $t = getPrevoutTaprootKey(B, z, ie) || Buffer$D.from([]);
    if ((0, bip371_1.toXOnly)(ne).equals($t)) {
      const Nt = ae.hashForWitnessV1(
        B,
        le,
        Ee,
        ge
      );
      Je.push({ pubkey: ne, hash: Nt });
    }
  }
  const Ve = (z.tapLeafScript || []).filter(($t) => (0, psbtutils_1.pubkeyInScript)(ne, $t.script)).map(($t) => {
    const Nt = (0, bip341_1.tapleafHash)({
      output: $t.script,
      version: $t.leafVersion
    });
    return Object.assign({ hash: Nt }, $t);
  }).filter(
    ($t) => !oe || oe.equals($t.hash)
  ).map(($t) => {
    const Nt = ae.hashForWitnessV1(
      B,
      le,
      Ee,
      ge,
      $t.hash
    );
    return {
      pubkey: ne,
      hash: Nt,
      leafHash: $t.hash
    };
  });
  return Je.concat(Ve);
}
function checkSighashTypeAllowed(B, z) {
  if (z && z.indexOf(B) < 0) {
    const Y = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${Y}`
    );
  }
}
function getPayment(B, z, Y) {
  let ne;
  switch (z) {
    case "multisig":
      const ie = getSortedSigs(B, Y);
      ne = payments.p2ms({
        output: B,
        signatures: ie
      });
      break;
    case "pubkey":
      ne = payments.p2pk({
        output: B,
        signature: Y[0].signature
      });
      break;
    case "pubkeyhash":
      ne = payments.p2pkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
    case "witnesspubkeyhash":
      ne = payments.p2wpkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
  }
  return ne;
}
function getScriptFromInput(B, z, Y) {
  const ne = Y.__TX, ie = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (ie.isP2SH = !!z.redeemScript, ie.isP2WSH = !!z.witnessScript, z.witnessScript)
    ie.script = z.witnessScript;
  else if (z.redeemScript)
    ie.script = z.redeemScript;
  else if (z.nonWitnessUtxo) {
    const oe = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), se = ne.ins[B].index;
    ie.script = oe.outs[se].script;
  } else z.witnessUtxo && (ie.script = z.witnessUtxo.script);
  return (z.witnessScript || (0, psbtutils_1.isP2WPKH)(ie.script)) && (ie.isSegwit = !0), ie;
}
function getSignersFromHD(B, z, Y) {
  const ne = (0, utils_1.checkForInput)(z, B);
  if (!ne.bip32Derivation || ne.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const ie = ne.bip32Derivation.map((se) => {
    if (se.masterFingerprint.equals(Y.fingerprint))
      return se;
  }).filter((se) => !!se);
  if (ie.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return ie.map((se) => {
    const ae = Y.derivePath(se.path);
    if (!se.pubkey.equals(ae.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ae;
  });
}
function getSortedSigs(B, z) {
  return payments.p2ms({ output: B }).pubkeys.map((ne) => (z.filter((ie) => ie.pubkey.equals(ne))[0] || {}).signature).filter((ne) => !!ne);
}
function scriptWitnessToWitnessStack(B) {
  let z = 0;
  function Y(se) {
    return z += se, B.slice(z - se, z);
  }
  function ne() {
    const se = varuint.decode(B, z);
    return z += varuint.decode.bytes, se;
  }
  function ie() {
    return Y(ne());
  }
  function oe() {
    const se = ne(), ae = [];
    for (let ge = 0; ge < se; ge++) ae.push(ie());
    return ae;
  }
  return oe();
}
function sighashTypeToString(B) {
  let z = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      z += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      z += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      z += "SIGHASH_NONE";
      break;
  }
  return z;
}
function addNonWitnessTxCache(B, z, Y) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[Y] = z.nonWitnessUtxo;
  const ne = transaction_1.Transaction.fromBuffer(z.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[Y] = ne;
  const ie = B, oe = Y;
  delete z.nonWitnessUtxo, Object.defineProperty(z, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const se = ie.__NON_WITNESS_UTXO_BUF_CACHE[oe], ae = ie.__NON_WITNESS_UTXO_TX_CACHE[oe];
      if (se !== void 0)
        return se;
      {
        const ge = ae.toBuffer();
        return ie.__NON_WITNESS_UTXO_BUF_CACHE[oe] = ge, ge;
      }
    },
    set(se) {
      ie.__NON_WITNESS_UTXO_BUF_CACHE[oe] = se;
    }
  });
}
function inputFinalizeGetAmts(B, z, Y, ne) {
  let ie = 0;
  B.forEach((ge, Ce) => {
    if (ne && ge.finalScriptSig && (z.ins[Ce].script = ge.finalScriptSig), ne && ge.finalScriptWitness && (z.ins[Ce].witness = scriptWitnessToWitnessStack(
      ge.finalScriptWitness
    )), ge.witnessUtxo)
      ie += ge.witnessUtxo.value;
    else if (ge.nonWitnessUtxo) {
      const le = nonWitnessUtxoTxFromCache(Y, ge, Ce), Ee = z.ins[Ce].index, Je = le.outs[Ee];
      ie += Je.value;
    }
  });
  const oe = z.outs.reduce((ge, Ce) => ge + Ce.value, 0), se = ie - oe;
  if (se < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ae = z.virtualSize();
  Y.__FEE = se, Y.__EXTRACTED_TX = z, Y.__FEE_RATE = Math.floor(se / ae);
}
function nonWitnessUtxoTxFromCache(B, z, Y) {
  const ne = B.__NON_WITNESS_UTXO_TX_CACHE;
  return ne[Y] || addNonWitnessTxCache(B, z, Y), ne[Y];
}
function getScriptFromUtxo(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return ne;
}
function getScriptAndAmountFromUtxo(B, z, Y) {
  if (z.witnessUtxo !== void 0)
    return {
      script: z.witnessUtxo.script,
      value: z.witnessUtxo.value
    };
  if (z.nonWitnessUtxo !== void 0) {
    const ie = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ).outs[Y.__TX.ins[B].index];
    return { script: ie.script, value: ie.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, z, Y, ne) {
  const ie = getScriptFromUtxo(Y, z, ne), { meaningfulScript: oe } = getMeaningfulScript(
    ie,
    Y,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, oe);
}
function pubkeyInOutput(B, z, Y, ne) {
  const ie = ne.__TX.outs[Y].script, { meaningfulScript: oe } = getMeaningfulScript(
    ie,
    Y,
    "output",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, oe);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const z = bscript.decompile(B);
  if (!z) return;
  const Y = z[z.length - 1];
  if (!(!Buffer$D.isBuffer(Y) || isPubkeyLike(Y) || isSigLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const z = scriptWitnessToWitnessStack(B), Y = z[z.length - 1];
  if (!(isPubkeyLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const z = B[64] & 1, Y = B.slice(0, 33);
    return Y[0] = 2 | z, Y;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, z, Y, ne, ie) {
  const oe = (0, psbtutils_1.isP2SHScript)(B), se = oe && ne && (0, psbtutils_1.isP2WSHScript)(ne), ae = (0, psbtutils_1.isP2WSHScript)(B);
  if (oe && ne === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ae || se) && ie === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ge;
  return se ? (ge = ie, checkRedeemScript(z, B, ne, Y), checkWitnessScript(z, ne, ie, Y), checkInvalidP2WSH(ge)) : ae ? (ge = ie, checkWitnessScript(z, B, ie, Y), checkInvalidP2WSH(ge)) : oe ? (ge = ne, checkRedeemScript(z, B, ne, Y)) : ge = B, {
    meaningfulScript: ge,
    type: se ? "p2sh-p2wsh" : oe ? "p2sh" : ae ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const z = requireAddress();
  B.address = z;
  const Y = crypto$1;
  B.crypto = Y;
  const ne = networks;
  B.networks = ne;
  const ie = requirePayments();
  B.payments = ie;
  const oe = requireScript();
  B.script = oe;
  var se = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return se.Block;
    }
  });
  var ae = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return ae.Psbt;
    }
  });
  var ge = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return ge.OPS;
    }
  });
  var Ce = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return Ce.Transaction;
    }
  });
  var le = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return le.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: B, publicKey: z, format: Y, wallet: ne } = useOrdConnect(), [ie, oe] = useState(null), [se, ae] = useState(!1);
  return { sign: useCallback(
    async (Ce, le, Ee) => {
      ae(!0);
      try {
        if (oe(null), !Y || !z || !ne)
          throw new Error("No wallet is connected");
        const Je = src$1.Psbt.fromBase64(le), Ve = await signPsbt({
          address: Ce,
          wallet: ne,
          network: B,
          psbt: Je,
          options: Ee
        });
        return ae(!1), Ve;
      } catch (Je) {
        throw oe(Je.message), ae(!1), Je;
      }
    },
    [Y, B, z, ne]
  ), error: ie, loading: se };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: B,
  wallet: z,
  address: Y,
  network: ne,
  format: ie
}) {
  if (z === Wallet.MAGICEDEN) {
    const { base64: oe } = await signMessage$1(B, Y, ne);
    return oe;
  }
  if (z === Wallet.UNISAT) {
    const { base64: oe } = await signMessage$2(B, "bip322-simple");
    return oe;
  }
  if (z === Wallet.XVERSE) {
    const { base64: oe } = await signMessage$3(B, Y, ne);
    return oe;
  }
  if (z === Wallet.LEATHER) {
    const oe = leatherPaymentTypeFromFormat(ie), { base64: se } = await signMessage$4(B, {
      paymentType: oe,
      network: ne
    });
    return se;
  }
  if (z === Wallet.OKX) {
    const { base64: oe } = await signMessage$5(B, "bip322-simple", ne);
    return oe;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: z,
    publicKey: Y,
    format: ne,
    address: ie
  } = useOrdConnect(), [oe, se] = useState(null), [ae, ge] = useState(!1);
  return { signMsg: useCallback(
    async (le, Ee) => {
      ge(!0);
      try {
        if (se(null), !ne || !Y || !z)
          throw new Error("No wallet is connected");
        if (ie.ordinals !== le && ie.payments !== le)
          throw new Error("Address supplied is not connected address");
        const Je = await signMessage({
          address: le,
          wallet: z,
          message: Ee,
          network: B,
          format: ie.ordinals === le ? ne.ordinals : ne.payments
        });
        return ge(!1), Je;
      } catch (Je) {
        throw se(Je.message), ge(!1), Je;
      }
    },
    [ne, B, Y, z, ie]
  ), error: oe, isLoading: ae };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
