(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as C$2 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletRequestCancelledByUserError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { createPortal } from "react-dom";
import { signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(A) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(A, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(A, 0);
  try {
    return cachedSetTimeout(A, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, A, 0);
    } catch {
      return cachedSetTimeout.call(this, A, 0);
    }
  }
}
function runClearTimeout(A) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(A);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(A);
  try {
    return cachedClearTimeout(A);
  } catch {
    try {
      return cachedClearTimeout.call(null, A);
    } catch {
      return cachedClearTimeout.call(this, A);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var A = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var B = queue.length; B; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < B; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, B = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(A);
  }
}
process.nextTick = function(A) {
  var B = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var L = 1; L < arguments.length; L++)
      B[L - 1] = arguments[L];
  queue.push(new Item(A, B)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(A, B) {
  this.fun = A, this.array = B;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {
}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(A) {
  return [];
};
process.binding = function(A) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(A) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports$1);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.fragment"), V = Object.prototype.hasOwnProperty, J = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, re = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ne(ie, pe, nt) {
    var oe, Ce = {}, at = null, it = null;
    nt !== void 0 && (at = "" + nt), pe.key !== void 0 && (at = "" + pe.key), pe.ref !== void 0 && (it = pe.ref);
    for (oe in pe) V.call(pe, oe) && !re.hasOwnProperty(oe) && (Ce[oe] = pe[oe]);
    if (ie && ie.defaultProps) for (oe in pe = ie.defaultProps, pe) Ce[oe] === void 0 && (Ce[oe] = pe[oe]);
    return { $$typeof: B, type: ie, key: at, ref: it, props: Ce, _owner: J.current };
  }
  return reactJsxRuntime_production_min.Fragment = L, reactJsxRuntime_production_min.jsx = ne, reactJsxRuntime_production_min.jsxs = ne, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.portal"), V = Symbol.for("react.fragment"), J = Symbol.for("react.strict_mode"), re = Symbol.for("react.profiler"), ne = Symbol.for("react.provider"), ie = Symbol.for("react.context"), pe = Symbol.for("react.forward_ref"), nt = Symbol.for("react.suspense"), oe = Symbol.for("react.suspense_list"), Ce = Symbol.for("react.memo"), at = Symbol.for("react.lazy"), it = Symbol.for("react.offscreen"), gt = Symbol.iterator, St = "@@iterator";
    function xt(jt) {
      if (jt === null || typeof jt != "object")
        return null;
      var nr = gt && jt[gt] || jt[St];
      return typeof nr == "function" ? nr : null;
    }
    var Mt = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function bt(jt) {
      {
        for (var nr = arguments.length, ar = new Array(nr > 1 ? nr - 1 : 0), lr = 1; lr < nr; lr++)
          ar[lr - 1] = arguments[lr];
        Tt("error", jt, ar);
      }
    }
    function Tt(jt, nr, ar) {
      {
        var lr = Mt.ReactDebugCurrentFrame, Sr = lr.getStackAddendum();
        Sr !== "" && (nr += "%s", ar = ar.concat([Sr]));
        var xr = ar.map(function(vr) {
          return String(vr);
        });
        xr.unshift("Warning: " + nr), Function.prototype.apply.call(console[jt], console, xr);
      }
    }
    var It = !1, qt = !1, Dt = !1, Xt = !1, Bt = !1, mt;
    mt = Symbol.for("react.module.reference");
    function Ot(jt) {
      return !!(typeof jt == "string" || typeof jt == "function" || jt === V || jt === re || Bt || jt === J || jt === nt || jt === oe || Xt || jt === it || It || qt || Dt || typeof jt == "object" && jt !== null && (jt.$$typeof === at || jt.$$typeof === Ce || jt.$$typeof === ne || jt.$$typeof === ie || jt.$$typeof === pe || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      jt.$$typeof === mt || jt.getModuleId !== void 0));
    }
    function wt(jt, nr, ar) {
      var lr = jt.displayName;
      if (lr)
        return lr;
      var Sr = nr.displayName || nr.name || "";
      return Sr !== "" ? ar + "(" + Sr + ")" : ar;
    }
    function ke(jt) {
      return jt.displayName || "Context";
    }
    function rt(jt) {
      if (jt == null)
        return null;
      if (typeof jt.tag == "number" && bt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof jt == "function")
        return jt.displayName || jt.name || null;
      if (typeof jt == "string")
        return jt;
      switch (jt) {
        case V:
          return "Fragment";
        case L:
          return "Portal";
        case re:
          return "Profiler";
        case J:
          return "StrictMode";
        case nt:
          return "Suspense";
        case oe:
          return "SuspenseList";
      }
      if (typeof jt == "object")
        switch (jt.$$typeof) {
          case ie:
            var nr = jt;
            return ke(nr) + ".Consumer";
          case ne:
            var ar = jt;
            return ke(ar._context) + ".Provider";
          case pe:
            return wt(jt, jt.render, "ForwardRef");
          case Ce:
            var lr = jt.displayName || null;
            return lr !== null ? lr : rt(jt.type) || "Memo";
          case at: {
            var Sr = jt, xr = Sr._payload, vr = Sr._init;
            try {
              return rt(vr(xr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ce = Object.assign, Oe = 0, ot, ut, ht, dt, st, yt, ct;
    function At() {
    }
    At.__reactDisabledLog = !0;
    function Kt() {
      {
        if (Oe === 0) {
          ot = console.log, ut = console.info, ht = console.warn, dt = console.error, st = console.group, yt = console.groupCollapsed, ct = console.groupEnd;
          var jt = {
            configurable: !0,
            enumerable: !0,
            value: At,
            writable: !0
          };
          Object.defineProperties(console, {
            info: jt,
            log: jt,
            warn: jt,
            error: jt,
            group: jt,
            groupCollapsed: jt,
            groupEnd: jt
          });
        }
        Oe++;
      }
    }
    function Zt() {
      {
        if (Oe--, Oe === 0) {
          var jt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ce({}, jt, {
              value: ot
            }),
            info: ce({}, jt, {
              value: ut
            }),
            warn: ce({}, jt, {
              value: ht
            }),
            error: ce({}, jt, {
              value: dt
            }),
            group: ce({}, jt, {
              value: st
            }),
            groupCollapsed: ce({}, jt, {
              value: yt
            }),
            groupEnd: ce({}, jt, {
              value: ct
            })
          });
        }
        Oe < 0 && bt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Ht = Mt.ReactCurrentDispatcher, Pt;
    function kt(jt, nr, ar) {
      {
        if (Pt === void 0)
          try {
            throw Error();
          } catch (Sr) {
            var lr = Sr.stack.trim().match(/\n( *(at )?)/);
            Pt = lr && lr[1] || "";
          }
        return `
` + Pt + jt;
      }
    }
    var Vt = !1, tr;
    {
      var Nt = typeof WeakMap == "function" ? WeakMap : Map;
      tr = new Nt();
    }
    function Ft(jt, nr) {
      if (!jt || Vt)
        return "";
      {
        var ar = tr.get(jt);
        if (ar !== void 0)
          return ar;
      }
      var lr;
      Vt = !0;
      var Sr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var xr;
      xr = Ht.current, Ht.current = null, Kt();
      try {
        if (nr) {
          var vr = function() {
            throw Error();
          };
          if (Object.defineProperty(vr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(vr, []);
            } catch (qr) {
              lr = qr;
            }
            Reflect.construct(jt, [], vr);
          } else {
            try {
              vr.call();
            } catch (qr) {
              lr = qr;
            }
            jt.call(vr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (qr) {
            lr = qr;
          }
          jt();
        }
      } catch (qr) {
        if (qr && lr && typeof qr.stack == "string") {
          for (var Rr = qr.stack.split(`
`), jr = lr.stack.split(`
`), Lr = Rr.length - 1, Hr = jr.length - 1; Lr >= 1 && Hr >= 0 && Rr[Lr] !== jr[Hr]; )
            Hr--;
          for (; Lr >= 1 && Hr >= 0; Lr--, Hr--)
            if (Rr[Lr] !== jr[Hr]) {
              if (Lr !== 1 || Hr !== 1)
                do
                  if (Lr--, Hr--, Hr < 0 || Rr[Lr] !== jr[Hr]) {
                    var Wr = `
` + Rr[Lr].replace(" at new ", " at ");
                    return jt.displayName && Wr.includes("<anonymous>") && (Wr = Wr.replace("<anonymous>", jt.displayName)), typeof jt == "function" && tr.set(jt, Wr), Wr;
                  }
                while (Lr >= 1 && Hr >= 0);
              break;
            }
        }
      } finally {
        Vt = !1, Ht.current = xr, Zt(), Error.prepareStackTrace = Sr;
      }
      var Vr = jt ? jt.displayName || jt.name : "", Gr = Vr ? kt(Vr) : "";
      return typeof jt == "function" && tr.set(jt, Gr), Gr;
    }
    function er(jt, nr, ar) {
      return Ft(jt, !1);
    }
    function fr(jt) {
      var nr = jt.prototype;
      return !!(nr && nr.isReactComponent);
    }
    function cr(jt, nr, ar) {
      if (jt == null)
        return "";
      if (typeof jt == "function")
        return Ft(jt, fr(jt));
      if (typeof jt == "string")
        return kt(jt);
      switch (jt) {
        case nt:
          return kt("Suspense");
        case oe:
          return kt("SuspenseList");
      }
      if (typeof jt == "object")
        switch (jt.$$typeof) {
          case pe:
            return er(jt.render);
          case Ce:
            return cr(jt.type, nr, ar);
          case at: {
            var lr = jt, Sr = lr._payload, xr = lr._init;
            try {
              return cr(xr(Sr), nr, ar);
            } catch {
            }
          }
        }
      return "";
    }
    var dr = Object.prototype.hasOwnProperty, br = {}, wr = Mt.ReactDebugCurrentFrame;
    function or(jt) {
      if (jt) {
        var nr = jt._owner, ar = cr(jt.type, jt._source, nr ? nr.type : null);
        wr.setExtraStackFrame(ar);
      } else
        wr.setExtraStackFrame(null);
    }
    function Nr(jt, nr, ar, lr, Sr) {
      {
        var xr = Function.call.bind(dr);
        for (var vr in jt)
          if (xr(jt, vr)) {
            var Rr = void 0;
            try {
              if (typeof jt[vr] != "function") {
                var jr = Error((lr || "React class") + ": " + ar + " type `" + vr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof jt[vr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw jr.name = "Invariant Violation", jr;
              }
              Rr = jt[vr](nr, vr, lr, ar, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Lr) {
              Rr = Lr;
            }
            Rr && !(Rr instanceof Error) && (or(Sr), bt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", lr || "React class", ar, vr, typeof Rr), or(null)), Rr instanceof Error && !(Rr.message in br) && (br[Rr.message] = !0, or(Sr), bt("Failed %s type: %s", ar, Rr.message), or(null));
          }
      }
    }
    var Br = Array.isArray;
    function Tr(jt) {
      return Br(jt);
    }
    function Mr(jt) {
      {
        var nr = typeof Symbol == "function" && Symbol.toStringTag, ar = nr && jt[Symbol.toStringTag] || jt.constructor.name || "Object";
        return ar;
      }
    }
    function _r(jt) {
      try {
        return kr(jt), !1;
      } catch {
        return !0;
      }
    }
    function kr(jt) {
      return "" + jt;
    }
    function Fr(jt) {
      if (_r(jt))
        return bt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Mr(jt)), kr(jt);
    }
    var Ar = Mt.ReactCurrentOwner, Cr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Dr, Rt;
    function vt(jt) {
      if (dr.call(jt, "ref")) {
        var nr = Object.getOwnPropertyDescriptor(jt, "ref").get;
        if (nr && nr.isReactWarning)
          return !1;
      }
      return jt.ref !== void 0;
    }
    function $t(jt) {
      if (dr.call(jt, "key")) {
        var nr = Object.getOwnPropertyDescriptor(jt, "key").get;
        if (nr && nr.isReactWarning)
          return !1;
      }
      return jt.key !== void 0;
    }
    function Ut(jt, nr) {
      typeof jt.ref == "string" && Ar.current;
    }
    function Yt(jt, nr) {
      {
        var ar = function() {
          Dr || (Dr = !0, bt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", nr));
        };
        ar.isReactWarning = !0, Object.defineProperty(jt, "key", {
          get: ar,
          configurable: !0
        });
      }
    }
    function rr(jt, nr) {
      {
        var ar = function() {
          Rt || (Rt = !0, bt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", nr));
        };
        ar.isReactWarning = !0, Object.defineProperty(jt, "ref", {
          get: ar,
          configurable: !0
        });
      }
    }
    var ir = function(jt, nr, ar, lr, Sr, xr, vr) {
      var Rr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: B,
        // Built-in properties that belong on the element
        type: jt,
        key: nr,
        ref: ar,
        props: vr,
        // Record the component responsible for creating this element.
        _owner: xr
      };
      return Rr._store = {}, Object.defineProperty(Rr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Rr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: lr
      }), Object.defineProperty(Rr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Sr
      }), Object.freeze && (Object.freeze(Rr.props), Object.freeze(Rr)), Rr;
    };
    function gr(jt, nr, ar, lr, Sr) {
      {
        var xr, vr = {}, Rr = null, jr = null;
        ar !== void 0 && (Fr(ar), Rr = "" + ar), $t(nr) && (Fr(nr.key), Rr = "" + nr.key), vt(nr) && (jr = nr.ref, Ut(nr, Sr));
        for (xr in nr)
          dr.call(nr, xr) && !Cr.hasOwnProperty(xr) && (vr[xr] = nr[xr]);
        if (jt && jt.defaultProps) {
          var Lr = jt.defaultProps;
          for (xr in Lr)
            vr[xr] === void 0 && (vr[xr] = Lr[xr]);
        }
        if (Rr || jr) {
          var Hr = typeof jt == "function" ? jt.displayName || jt.name || "Unknown" : jt;
          Rr && Yt(vr, Hr), jr && rr(vr, Hr);
        }
        return ir(jt, Rr, jr, Sr, lr, Ar.current, vr);
      }
    }
    var Ir = Mt.ReactCurrentOwner, yr = Mt.ReactDebugCurrentFrame;
    function Pr(jt) {
      if (jt) {
        var nr = jt._owner, ar = cr(jt.type, jt._source, nr ? nr.type : null);
        yr.setExtraStackFrame(ar);
      } else
        yr.setExtraStackFrame(null);
    }
    var $r;
    $r = !1;
    function Er(jt) {
      return typeof jt == "object" && jt !== null && jt.$$typeof === B;
    }
    function Or() {
      {
        if (Ir.current) {
          var jt = rt(Ir.current.type);
          if (jt)
            return `

Check the render method of \`` + jt + "`.";
        }
        return "";
      }
    }
    function Ur(jt) {
      return "";
    }
    var Gt = {};
    function Lt(jt) {
      {
        var nr = Or();
        if (!nr) {
          var ar = typeof jt == "string" ? jt : jt.displayName || jt.name;
          ar && (nr = `

Check the top-level render call using <` + ar + ">.");
        }
        return nr;
      }
    }
    function zt(jt, nr) {
      {
        if (!jt._store || jt._store.validated || jt.key != null)
          return;
        jt._store.validated = !0;
        var ar = Lt(nr);
        if (Gt[ar])
          return;
        Gt[ar] = !0;
        var lr = "";
        jt && jt._owner && jt._owner !== Ir.current && (lr = " It was passed a child from " + rt(jt._owner.type) + "."), Pr(jt), bt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ar, lr), Pr(null);
      }
    }
    function Et(jt, nr) {
      {
        if (typeof jt != "object")
          return;
        if (Tr(jt))
          for (var ar = 0; ar < jt.length; ar++) {
            var lr = jt[ar];
            Er(lr) && zt(lr, nr);
          }
        else if (Er(jt))
          jt._store && (jt._store.validated = !0);
        else if (jt) {
          var Sr = xt(jt);
          if (typeof Sr == "function" && Sr !== jt.entries)
            for (var xr = Sr.call(jt), vr; !(vr = xr.next()).done; )
              Er(vr.value) && zt(vr.value, nr);
        }
      }
    }
    function lt(jt) {
      {
        var nr = jt.type;
        if (nr == null || typeof nr == "string")
          return;
        var ar;
        if (typeof nr == "function")
          ar = nr.propTypes;
        else if (typeof nr == "object" && (nr.$$typeof === pe || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        nr.$$typeof === Ce))
          ar = nr.propTypes;
        else
          return;
        if (ar) {
          var lr = rt(nr);
          Nr(ar, jt.props, "prop", lr, jt);
        } else if (nr.PropTypes !== void 0 && !$r) {
          $r = !0;
          var Sr = rt(nr);
          bt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Sr || "Unknown");
        }
        typeof nr.getDefaultProps == "function" && !nr.getDefaultProps.isReactClassApproved && bt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function pt(jt) {
      {
        for (var nr = Object.keys(jt.props), ar = 0; ar < nr.length; ar++) {
          var lr = nr[ar];
          if (lr !== "children" && lr !== "key") {
            Pr(jt), bt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", lr), Pr(null);
            break;
          }
        }
        jt.ref !== null && (Pr(jt), bt("Invalid attribute `ref` supplied to `React.Fragment`."), Pr(null));
      }
    }
    var Ct = {};
    function Wt(jt, nr, ar, lr, Sr, xr) {
      {
        var vr = Ot(jt);
        if (!vr) {
          var Rr = "";
          (jt === void 0 || typeof jt == "object" && jt !== null && Object.keys(jt).length === 0) && (Rr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var jr = Ur();
          jr ? Rr += jr : Rr += Or();
          var Lr;
          jt === null ? Lr = "null" : Tr(jt) ? Lr = "array" : jt !== void 0 && jt.$$typeof === B ? (Lr = "<" + (rt(jt.type) || "Unknown") + " />", Rr = " Did you accidentally export a JSX literal instead of a component?") : Lr = typeof jt, bt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Lr, Rr);
        }
        var Hr = gr(jt, nr, ar, Sr, xr);
        if (Hr == null)
          return Hr;
        if (vr) {
          var Wr = nr.children;
          if (Wr !== void 0)
            if (lr)
              if (Tr(Wr)) {
                for (var Vr = 0; Vr < Wr.length; Vr++)
                  Et(Wr[Vr], jt);
                Object.freeze && Object.freeze(Wr);
              } else
                bt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Et(Wr, jt);
        }
        if (dr.call(nr, "key")) {
          var Gr = rt(jt), qr = Object.keys(nr).filter(function(Jr) {
            return Jr !== "key";
          }), Xr = qr.length > 0 ? "{key: someKey, " + qr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ct[Gr + Xr]) {
            var Yr = qr.length > 0 ? "{" + qr.join(": ..., ") + ": ...}" : "{}";
            bt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Xr, Gr, Yr, Gr), Ct[Gr + Xr] = !0;
          }
        }
        return jt === V ? pt(Hr) : lt(Hr), Hr;
      }
    }
    function Jt(jt, nr, ar) {
      return Wt(jt, nr, ar, !0);
    }
    function Qt(jt, nr, ar) {
      return Wt(jt, nr, ar, !1);
    }
    var ur = Qt, pr = Jt;
    reactJsxRuntime_development.Fragment = V, reactJsxRuntime_development.jsx = ur, reactJsxRuntime_development.jsxs = pr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [A, B] = useState(!1);
  return useEffect(() => {
    B(!0);
  }, []), A;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(A) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${A} even though environment is not a browser.`
  );
  const B = `${KEY_PREFIX}_${A}`;
  try {
    const L = window.localStorage.getItem(B);
    return L != null ? JSON.parse(L) : null;
  } catch (L) {
    return console.error(`Error retrieving ${B} from localStorage`, L), null;
  }
}
function setItemToLocalStorage(A, B) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${A} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${A}`;
  try {
    B ? window.localStorage.setItem(L, JSON.stringify(B)) : window.localStorage.removeItem(L);
  } catch (V) {
    console.error(`Error saving ${L} to localStorage`, V);
  }
}
function useLocalStorage(A, B, L = {}) {
  const { initializeWithValue: V = !0 } = L, J = useCallback(() => {
    const pe = getItemFromLocalStorage(A);
    return pe || (setItemToLocalStorage(A, B), B);
  }, [B, A]), [re, ne] = useState(() => V ? J() : B), ie = useCallback(
    (pe) => {
      setItemToLocalStorage(A, pe), ne(pe);
    },
    [A]
  );
  return useEffect(() => {
    ne(J());
  }, [A]), [re, ie];
}
var Network = /* @__PURE__ */ ((A) => (A.MAINNET = "mainnet", A.TESTNET = "testnet", A.SIGNET = "signet", A))(Network || {}), Wallet = /* @__PURE__ */ ((A) => (A.UNISAT = "unisat", A.XVERSE = "xverse", A.MAGICEDEN = "magiceden", A.LEATHER = "leather", A.OKX = "okx", A))(Wallet || {}), Chain = /* @__PURE__ */ ((A) => (A.BITCOIN = "bitcoin", A.FRACTAL_BITCOIN = "fractal-bitcoin", A))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: A,
  network: B,
  visibleWallets: L,
  chain: V = "bitcoin",
  ssr: J = !1
}) {
  if (!B)
    throw new Error("Network cannot be empty");
  if (!L || L.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [re, ne] = useState(B), [ie, pe] = useState(L), [nt, oe] = useState(V), [Ce, at] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [it, gt] = useLocalStorage(WALLET, null, {
    initializeWithValue: !J
  }), [St, xt] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [Mt, bt] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !J }
  ), [Tt, It] = useState(!1), qt = useCallback(() => It(!0), []), Dt = useCallback(() => It(!1), []), Xt = useCallback(() => {
    at(EMPTY_BIADDRESS_OBJECT), xt(EMPTY_BIADDRESS_OBJECT), bt(EMPTY_BIADDRESS_OBJECT), gt(null);
  }, [at, bt, xt, gt]), Bt = useMemo(
    () => ({
      address: Ce,
      updateAddress: at,
      publicKey: St,
      updatePublicKey: xt,
      network: re,
      updateNetwork: (mt) => {
        ne(it === "xverse" && mt === "testnet" ? "testnet4" : mt);
      },
      wallet: it,
      updateWallet: (mt) => {
        (re === "testnet" || re === "testnet4") && ne(mt === "xverse" ? "testnet4" : "testnet"), gt(mt);
      },
      isModalOpen: Tt,
      openModal: qt,
      closeModal: Dt,
      format: Mt,
      updateFormat: bt,
      disconnectWallet: Xt,
      chain: nt,
      updateChain: oe,
      visibleWallets: ie,
      updateVisibleWallets: pe
    }),
    [
      Ce,
      at,
      St,
      xt,
      re,
      ne,
      it,
      gt,
      Tt,
      qt,
      Dt,
      Mt,
      bt,
      Xt,
      nt,
      oe
    ]
  );
  return useEffect(() => {
    ne(B);
  }, [B]), useEffect(() => {
    nt !== V && (Xt(), oe(V));
  }, [V, nt, Xt]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: Bt, children: A });
}
function useOrdConnect() {
  const A = useContext(OrdConnectContext);
  if (console.log("+context", A), !A)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return A;
}
var build = { exports: {} };
(function(A, B) {
  (function(L, V) {
    A.exports = V(C__default);
  })(commonjsGlobal, function(L) {
    return function(V) {
      var J = {};
      function re(ne) {
        if (J[ne]) return J[ne].exports;
        var ie = J[ne] = { i: ne, l: !1, exports: {} };
        return V[ne].call(ie.exports, ie, ie.exports, re), ie.l = !0, ie.exports;
      }
      return re.m = V, re.c = J, re.d = function(ne, ie, pe) {
        re.o(ne, ie) || Object.defineProperty(ne, ie, { enumerable: !0, get: pe });
      }, re.r = function(ne) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(ne, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(ne, "__esModule", { value: !0 });
      }, re.t = function(ne, ie) {
        if (1 & ie && (ne = re(ne)), 8 & ie || 4 & ie && typeof ne == "object" && ne && ne.__esModule) return ne;
        var pe = /* @__PURE__ */ Object.create(null);
        if (re.r(pe), Object.defineProperty(pe, "default", { enumerable: !0, value: ne }), 2 & ie && typeof ne != "string") for (var nt in ne) re.d(pe, nt, (function(oe) {
          return ne[oe];
        }).bind(null, nt));
        return pe;
      }, re.n = function(ne) {
        var ie = ne && ne.__esModule ? function() {
          return ne.default;
        } : function() {
          return ne;
        };
        return re.d(ie, "a", ie), ie;
      }, re.o = function(ne, ie) {
        return Object.prototype.hasOwnProperty.call(ne, ie);
      }, re.p = "/", re(re.s = 1);
    }([function(V, J) {
      V.exports = L;
    }, function(V, J, re) {
      V.exports = re(2);
    }, function(V, J, re) {
      function ne(bt, Tt) {
        if (bt == null) return {};
        var It, qt, Dt = function(Bt, mt) {
          if (Bt == null) return {};
          var Ot, wt, ke = {}, rt = Object.keys(Bt);
          for (wt = 0; wt < rt.length; wt++) Ot = rt[wt], mt.indexOf(Ot) >= 0 || (ke[Ot] = Bt[Ot]);
          return ke;
        }(bt, Tt);
        if (Object.getOwnPropertySymbols) {
          var Xt = Object.getOwnPropertySymbols(bt);
          for (qt = 0; qt < Xt.length; qt++) It = Xt[qt], Tt.indexOf(It) >= 0 || Object.prototype.propertyIsEnumerable.call(bt, It) && (Dt[It] = bt[It]);
        }
        return Dt;
      }
      re.r(J);
      var ie = re(0), pe = re.n(ie), nt = function(bt) {
        for (var Tt = 0, It = 0; It < bt.length; It++)
          Tt = (Tt << 5) - Tt + bt.charCodeAt(It), Tt &= Tt;
        return Math.abs(Tt);
      }, oe = function(bt, Tt) {
        return Math.floor(bt / Math.pow(10, Tt) % 10);
      }, Ce = function(bt, Tt) {
        return !(oe(bt, Tt) % 2);
      }, at = function(bt, Tt, It) {
        var qt = bt % Tt;
        return It && oe(bt, It) % 2 === 0 ? -qt : qt;
      }, it = function(bt, Tt, It) {
        return Tt[bt % It];
      }, gt = function(bt) {
        var Tt = bt.name, It = bt.colors, qt = bt.title, Dt = bt.square, Xt = bt.size, Bt = ne(bt, ["name", "colors", "title", "square", "size"]), mt = function(wt, ke) {
          var rt = nt(wt), ce = ke && ke.length;
          return Array.from({ length: 3 }, function(Oe, ot) {
            return { color: it(rt + ot, ke, ce), translateX: at(rt * (ot + 1), 8, 1), translateY: at(rt * (ot + 1), 8, 2), scale: 1.2 + at(rt * (ot + 1), 4) / 10, rotate: at(rt * (ot + 1), 360, 1) };
          });
        }(Tt, It), Ot = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Xt, height: Xt }, Bt), qt && ie.createElement("title", null, Tt), ie.createElement("mask", { id: Ot, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: Dt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Ot, ")") }, ie.createElement("rect", { width: 80, height: 80, fill: mt[0].color }), ie.createElement("path", { filter: "url(#filter_".concat(Ot, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: mt[1].color, transform: "translate(" + mt[1].translateX + " " + mt[1].translateY + ") rotate(" + mt[1].rotate + " 40 40) scale(" + mt[2].scale + ")" }), ie.createElement("path", { filter: "url(#filter_".concat(Ot, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: mt[2].color, transform: "translate(" + mt[2].translateX + " " + mt[2].translateY + ") rotate(" + mt[2].rotate + " 40 40) scale(" + mt[2].scale + ")" })), ie.createElement("defs", null, ie.createElement("filter", { id: "filter_".concat(Ot), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, ie.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), ie.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), ie.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, St = { pixel: function(bt) {
        var Tt = bt.name, It = bt.colors, qt = bt.title, Dt = bt.square, Xt = bt.size, Bt = ne(bt, ["name", "colors", "title", "square", "size"]), mt = function(wt, ke) {
          var rt = nt(wt), ce = ke && ke.length;
          return Array.from({ length: 64 }, function(Oe, ot) {
            return it(rt % (ot + 1), ke, ce);
          });
        }(Tt, It), Ot = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Xt, height: Xt }, Bt), qt && ie.createElement("title", null, Tt), ie.createElement("mask", { id: Ot, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: Dt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Ot, ")") }, ie.createElement("rect", { width: 10, height: 10, fill: mt[0] }), ie.createElement("rect", { x: 20, width: 10, height: 10, fill: mt[1] }), ie.createElement("rect", { x: 40, width: 10, height: 10, fill: mt[2] }), ie.createElement("rect", { x: 60, width: 10, height: 10, fill: mt[3] }), ie.createElement("rect", { x: 10, width: 10, height: 10, fill: mt[4] }), ie.createElement("rect", { x: 30, width: 10, height: 10, fill: mt[5] }), ie.createElement("rect", { x: 50, width: 10, height: 10, fill: mt[6] }), ie.createElement("rect", { x: 70, width: 10, height: 10, fill: mt[7] }), ie.createElement("rect", { y: 10, width: 10, height: 10, fill: mt[8] }), ie.createElement("rect", { y: 20, width: 10, height: 10, fill: mt[9] }), ie.createElement("rect", { y: 30, width: 10, height: 10, fill: mt[10] }), ie.createElement("rect", { y: 40, width: 10, height: 10, fill: mt[11] }), ie.createElement("rect", { y: 50, width: 10, height: 10, fill: mt[12] }), ie.createElement("rect", { y: 60, width: 10, height: 10, fill: mt[13] }), ie.createElement("rect", { y: 70, width: 10, height: 10, fill: mt[14] }), ie.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: mt[15] }), ie.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: mt[16] }), ie.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: mt[17] }), ie.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: mt[18] }), ie.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: mt[19] }), ie.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: mt[20] }), ie.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: mt[21] }), ie.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: mt[22] }), ie.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: mt[23] }), ie.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: mt[24] }), ie.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: mt[25] }), ie.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: mt[26] }), ie.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: mt[27] }), ie.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: mt[28] }), ie.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: mt[29] }), ie.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: mt[30] }), ie.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: mt[31] }), ie.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: mt[32] }), ie.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: mt[33] }), ie.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: mt[34] }), ie.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: mt[35] }), ie.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: mt[36] }), ie.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: mt[37] }), ie.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: mt[38] }), ie.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: mt[39] }), ie.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: mt[40] }), ie.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: mt[41] }), ie.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: mt[42] }), ie.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: mt[43] }), ie.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: mt[44] }), ie.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: mt[45] }), ie.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: mt[46] }), ie.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: mt[47] }), ie.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: mt[48] }), ie.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: mt[49] }), ie.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: mt[50] }), ie.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: mt[51] }), ie.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: mt[52] }), ie.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: mt[53] }), ie.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: mt[54] }), ie.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: mt[55] }), ie.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: mt[56] }), ie.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: mt[57] }), ie.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: mt[58] }), ie.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: mt[59] }), ie.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: mt[60] }), ie.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: mt[61] }), ie.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: mt[62] }), ie.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: mt[63] })));
      }, bauhaus: function(bt) {
        var Tt = bt.name, It = bt.colors, qt = bt.title, Dt = bt.square, Xt = bt.size, Bt = ne(bt, ["name", "colors", "title", "square", "size"]), mt = function(wt, ke) {
          var rt = nt(wt), ce = ke && ke.length;
          return Array.from({ length: 4 }, function(Oe, ot) {
            return { color: it(rt + ot, ke, ce), translateX: at(rt * (ot + 1), 40 - (ot + 17), 1), translateY: at(rt * (ot + 1), 40 - (ot + 17), 2), rotate: at(rt * (ot + 1), 360), isSquare: Ce(rt, 2) };
          });
        }(Tt, It), Ot = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Xt, height: Xt }, Bt), qt && ie.createElement("title", null, Tt), ie.createElement("mask", { id: Ot, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: Dt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Ot, ")") }, ie.createElement("rect", { width: 80, height: 80, fill: mt[0].color }), ie.createElement("rect", { x: 10, y: 30, width: 80, height: mt[1].isSquare ? 80 : 10, fill: mt[1].color, transform: "translate(" + mt[1].translateX + " " + mt[1].translateY + ") rotate(" + mt[1].rotate + " 40 40)" }), ie.createElement("circle", { cx: 40, cy: 40, fill: mt[2].color, r: 16, transform: "translate(" + mt[2].translateX + " " + mt[2].translateY + ")" }), ie.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: mt[3].color, transform: "translate(" + mt[3].translateX + " " + mt[3].translateY + ") rotate(" + mt[3].rotate + " 40 40)" })));
      }, ring: function(bt) {
        var Tt = bt.name, It = bt.colors, qt = bt.title, Dt = bt.square, Xt = bt.size, Bt = ne(bt, ["name", "colors", "title", "square", "size"]), mt = function(wt, ke) {
          var rt = nt(ke), ce = wt && wt.length, Oe = Array.from({ length: 5 }, function(ut, ht) {
            return it(rt + ht, wt, ce);
          }), ot = [];
          return ot[0] = Oe[0], ot[1] = Oe[1], ot[2] = Oe[1], ot[3] = Oe[2], ot[4] = Oe[2], ot[5] = Oe[3], ot[6] = Oe[3], ot[7] = Oe[0], ot[8] = Oe[4], ot;
        }(It, Tt), Ot = pe.a.useId();
        return pe.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Xt, height: Xt }, Bt), qt && pe.a.createElement("title", null, Tt), pe.a.createElement("mask", { id: Ot, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, pe.a.createElement("rect", { width: 90, height: 90, rx: Dt ? void 0 : 180, fill: "#FFFFFF" })), pe.a.createElement("g", { mask: "url(#".concat(Ot, ")") }, pe.a.createElement("path", { d: "M0 0h90v45H0z", fill: mt[0] }), pe.a.createElement("path", { d: "M0 45h90v45H0z", fill: mt[1] }), pe.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: mt[2] }), pe.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: mt[3] }), pe.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: mt[4] }), pe.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: mt[5] }), pe.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: mt[6] }), pe.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: mt[7] }), pe.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: mt[8] })));
      }, beam: function(bt) {
        var Tt = bt.name, It = bt.colors, qt = bt.title, Dt = bt.square, Xt = bt.size, Bt = ne(bt, ["name", "colors", "title", "square", "size"]), mt = function(wt, ke) {
          var rt, ce = nt(wt), Oe = ke && ke.length, ot = it(ce, ke, Oe), ut = at(ce, 10, 1), ht = ut < 5 ? ut + 4 : ut, dt = at(ce, 10, 2), st = dt < 5 ? dt + 4 : dt;
          return { wrapperColor: ot, faceColor: (rt = ot, rt.slice(0, 1) === "#" && (rt = rt.slice(1)), (299 * parseInt(rt.substr(0, 2), 16) + 587 * parseInt(rt.substr(2, 2), 16) + 114 * parseInt(rt.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: it(ce + 13, ke, Oe), wrapperTranslateX: ht, wrapperTranslateY: st, wrapperRotate: at(ce, 360), wrapperScale: 1 + at(ce, 3) / 10, isMouthOpen: Ce(ce, 2), isCircle: Ce(ce, 1), eyeSpread: at(ce, 5), mouthSpread: at(ce, 3), faceRotate: at(ce, 10, 3), faceTranslateX: ht > 6 ? ht / 2 : at(ce, 8, 1), faceTranslateY: st > 6 ? st / 2 : at(ce, 7, 2) };
        }(Tt, It), Ot = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Xt, height: Xt }, Bt), qt && ie.createElement("title", null, Tt), ie.createElement("mask", { id: Ot, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, ie.createElement("rect", { width: 36, height: 36, rx: Dt ? void 0 : 72, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(Ot, ")") }, ie.createElement("rect", { width: 36, height: 36, fill: mt.backgroundColor }), ie.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + mt.wrapperTranslateX + " " + mt.wrapperTranslateY + ") rotate(" + mt.wrapperRotate + " 18 18) scale(" + mt.wrapperScale + ")", fill: mt.wrapperColor, rx: mt.isCircle ? 36 : 6 }), ie.createElement("g", { transform: "translate(" + mt.faceTranslateX + " " + mt.faceTranslateY + ") rotate(" + mt.faceRotate + " 18 18)" }, mt.isMouthOpen ? ie.createElement("path", { d: "M15 " + (19 + mt.mouthSpread) + "c2 1 4 1 6 0", stroke: mt.faceColor, fill: "none", strokeLinecap: "round" }) : ie.createElement("path", { d: "M13," + (19 + mt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: mt.faceColor }), ie.createElement("rect", { x: 14 - mt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: mt.faceColor }), ie.createElement("rect", { x: 20 + mt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: mt.faceColor }))));
      }, sunset: function(bt) {
        var Tt = bt.name, It = bt.colors, qt = bt.title, Dt = bt.square, Xt = bt.size, Bt = ne(bt, ["name", "colors", "title", "square", "size"]), mt = function(ke, rt) {
          var ce = nt(ke), Oe = rt && rt.length;
          return Array.from({ length: 4 }, function(ot, ut) {
            return it(ce + ut, rt, Oe);
          });
        }(Tt, It), Ot = Tt.replace(/\s/g, ""), wt = ie.useId();
        return ie.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Xt, height: Xt }, Bt), qt && ie.createElement("title", null, Tt), ie.createElement("mask", { id: wt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ie.createElement("rect", { width: 80, height: 80, rx: Dt ? void 0 : 160, fill: "#FFFFFF" })), ie.createElement("g", { mask: "url(#".concat(wt, ")") }, ie.createElement("path", { fill: "url(#gradient_paint0_linear_" + Ot + ")", d: "M0 0h80v40H0z" }), ie.createElement("path", { fill: "url(#gradient_paint1_linear_" + Ot + ")", d: "M0 40h80v40H0z" })), ie.createElement("defs", null, ie.createElement("linearGradient", { id: "gradient_paint0_linear_" + Ot, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, ie.createElement("stop", { stopColor: mt[0] }), ie.createElement("stop", { offset: 1, stopColor: mt[1] })), ie.createElement("linearGradient", { id: "gradient_paint1_linear_" + Ot, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, ie.createElement("stop", { stopColor: mt[2] }), ie.createElement("stop", { offset: 1, stopColor: mt[3] }))));
      }, marble: gt }, xt = { geometric: "beam", abstract: "bauhaus" }, Mt = function(bt) {
        var Tt = bt.variant, It = Tt === void 0 ? "marble" : Tt, qt = bt.colors, Dt = qt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : qt, Xt = bt.name, Bt = Xt === void 0 ? "Clara Barton" : Xt, mt = bt.title, Ot = mt !== void 0 && mt, wt = bt.size, ke = bt.square, rt = ke !== void 0 && ke, ce = ne(bt, ["variant", "colors", "name", "title", "size", "square"]), Oe = St[xt[It] || It] || gt;
        return pe.a.createElement(Oe, Object.assign({ colors: Dt, name: Bt, title: Ot, size: wt, square: rt }, ce));
      };
      J.default = Mt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
var i$7 = Object.defineProperty, d$5 = (A, B, L) => B in A ? i$7(A, B, { enumerable: !0, configurable: !0, writable: !0, value: L }) : A[B] = L, r$5 = (A, B, L) => (d$5(A, typeof B != "symbol" ? B + "" : B, L), L);
let o$7 = class {
  constructor() {
    r$5(this, "current", this.detect()), r$5(this, "handoffState", "pending"), r$5(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$b = new o$7(), l$5 = (A, B) => {
  s$b.isServer ? useEffect(A, B) : useLayoutEffect(A, B);
};
function s$a(A) {
  let B = useRef(A);
  return l$5(() => {
    B.current = A;
  }, [A]), B;
}
let o$6 = function(A) {
  let B = s$a(A);
  return C__default.useCallback((...L) => B.current(...L), [B]);
};
function t$7(A) {
  typeof queueMicrotask == "function" ? queueMicrotask(A) : Promise.resolve().then(A).catch((B) => setTimeout(() => {
    throw B;
  }));
}
function o$5() {
  let A = [], B = { addEventListener(L, V, J, re) {
    return L.addEventListener(V, J, re), B.add(() => L.removeEventListener(V, J, re));
  }, requestAnimationFrame(...L) {
    let V = requestAnimationFrame(...L);
    return B.add(() => cancelAnimationFrame(V));
  }, nextFrame(...L) {
    return B.requestAnimationFrame(() => B.requestAnimationFrame(...L));
  }, setTimeout(...L) {
    let V = setTimeout(...L);
    return B.add(() => clearTimeout(V));
  }, microTask(...L) {
    let V = { current: !0 };
    return t$7(() => {
      V.current && L[0]();
    }), B.add(() => {
      V.current = !1;
    });
  }, style(L, V, J) {
    let re = L.style.getPropertyValue(V);
    return Object.assign(L.style, { [V]: J }), this.add(() => {
      Object.assign(L.style, { [V]: re });
    });
  }, group(L) {
    let V = o$5();
    return L(V), this.add(() => V.dispose());
  }, add(L) {
    return A.push(L), () => {
      let V = A.indexOf(L);
      if (V >= 0) for (let J of A.splice(V, 1)) J();
    };
  }, dispose() {
    for (let L of A.splice(0)) L();
  } };
  return B;
}
function p$3() {
  let [A] = useState(o$5);
  return useEffect(() => () => A.dispose(), [A]), A;
}
function s$9() {
  let A = typeof document > "u";
  return "useSyncExternalStore" in C$2 ? ((B) => B.useSyncExternalStore)(C$2)(() => () => {
  }, () => !1, () => !A) : !1;
}
function l$4() {
  let A = s$9(), [B, L] = C$2.useState(s$b.isHandoffComplete);
  return B && s$b.isHandoffComplete === !1 && L(!1), C$2.useEffect(() => {
    B !== !0 && L(!0);
  }, [B]), C$2.useEffect(() => s$b.handoff(), []), A ? !1 : B;
}
var o$4;
let I$5 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let A = l$4(), [B, L] = C__default.useState(A ? () => s$b.nextId() : null);
  return l$5(() => {
    B === null && L(s$b.nextId());
  }, [B]), B != null ? "" + B : void 0;
};
function u$7(A, B, ...L) {
  if (A in B) {
    let J = B[A];
    return typeof J == "function" ? J(...L) : J;
  }
  let V = new Error(`Tried to handle "${A}" but there is no handler defined. Only defined handlers are: ${Object.keys(B).map((J) => `"${J}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(V, u$7), V;
}
function o$3(A) {
  return s$b.isServer ? null : A instanceof Node ? A.ownerDocument : A != null && A.hasOwnProperty("current") && A.current instanceof Node ? A.current.ownerDocument : document;
}
let c$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((A) => `${A}:not([tabindex='-1'])`).join(",");
var M$2 = ((A) => (A[A.First = 1] = "First", A[A.Previous = 2] = "Previous", A[A.Next = 4] = "Next", A[A.Last = 8] = "Last", A[A.WrapAround = 16] = "WrapAround", A[A.NoScroll = 32] = "NoScroll", A))(M$2 || {}), N$2 = ((A) => (A[A.Error = 0] = "Error", A[A.Overflow = 1] = "Overflow", A[A.Success = 2] = "Success", A[A.Underflow = 3] = "Underflow", A))(N$2 || {}), F$3 = ((A) => (A[A.Previous = -1] = "Previous", A[A.Next = 1] = "Next", A))(F$3 || {});
function f$7(A = document.body) {
  return A == null ? [] : Array.from(A.querySelectorAll(c$5)).sort((B, L) => Math.sign((B.tabIndex || Number.MAX_SAFE_INTEGER) - (L.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((A) => (A[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A))(T$2 || {});
function h$4(A, B = 0) {
  var L;
  return A === ((L = o$3(A)) == null ? void 0 : L.body) ? !1 : u$7(B, { 0() {
    return A.matches(c$5);
  }, 1() {
    let V = A;
    for (; V !== null; ) {
      if (V.matches(c$5)) return !0;
      V = V.parentElement;
    }
    return !1;
  } });
}
function D$3(A) {
  let B = o$3(A);
  o$5().nextFrame(() => {
    B && !h$4(B.activeElement, 0) && y$3(A);
  });
}
var w$2 = ((A) => (A[A.Keyboard = 0] = "Keyboard", A[A.Mouse = 1] = "Mouse", A))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (A) => {
  A.metaKey || A.altKey || A.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (A) => {
  A.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : A.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(A) {
  A == null || A.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(A) {
  var B, L;
  return (L = (B = A == null ? void 0 : A.matches) == null ? void 0 : B.call(A, S$5)) != null ? L : !1;
}
function I$4(A, B = (L) => L) {
  return A.slice().sort((L, V) => {
    let J = B(L), re = B(V);
    if (J === null || re === null) return 0;
    let ne = J.compareDocumentPosition(re);
    return ne & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : ne & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$2(A, B) {
  return O$1(f$7(), B, { relativeTo: A });
}
function O$1(A, B, { sorted: L = !0, relativeTo: V = null, skipElements: J = [] } = {}) {
  let re = Array.isArray(A) ? A.length > 0 ? A[0].ownerDocument : document : A.ownerDocument, ne = Array.isArray(A) ? L ? I$4(A) : A : f$7(A);
  J.length > 0 && ne.length > 1 && (ne = ne.filter((it) => !J.includes(it))), V = V ?? re.activeElement;
  let ie = (() => {
    if (B & 5) return 1;
    if (B & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), pe = (() => {
    if (B & 1) return 0;
    if (B & 2) return Math.max(0, ne.indexOf(V)) - 1;
    if (B & 4) return Math.max(0, ne.indexOf(V)) + 1;
    if (B & 8) return ne.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), nt = B & 32 ? { preventScroll: !0 } : {}, oe = 0, Ce = ne.length, at;
  do {
    if (oe >= Ce || oe + Ce <= 0) return 0;
    let it = pe + oe;
    if (B & 16) it = (it + Ce) % Ce;
    else {
      if (it < 0) return 3;
      if (it >= Ce) return 1;
    }
    at = ne[it], at == null || at.focus(nt), oe += ie;
  } while (at !== re.activeElement);
  return B & 6 && H(at) && at.select(), 2;
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$6() || i$6();
}
function d$4(A, B, L) {
  let V = s$a(B);
  useEffect(() => {
    function J(re) {
      V.current(re);
    }
    return document.addEventListener(A, J, L), () => document.removeEventListener(A, J, L);
  }, [A, L]);
}
function s$8(A, B, L) {
  let V = s$a(B);
  useEffect(() => {
    function J(re) {
      V.current(re);
    }
    return window.addEventListener(A, J, L), () => window.removeEventListener(A, J, L);
  }, [A, L]);
}
function y$2(A, B, L = !0) {
  let V = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      V.current = L;
    });
  }, [L]);
  function J(ne, ie) {
    if (!V.current || ne.defaultPrevented) return;
    let pe = ie(ne);
    if (pe === null || !pe.getRootNode().contains(pe) || !pe.isConnected) return;
    let nt = function oe(Ce) {
      return typeof Ce == "function" ? oe(Ce()) : Array.isArray(Ce) || Ce instanceof Set ? Ce : [Ce];
    }(A);
    for (let oe of nt) {
      if (oe === null) continue;
      let Ce = oe instanceof HTMLElement ? oe : oe.current;
      if (Ce != null && Ce.contains(pe) || ne.composed && ne.composedPath().includes(Ce)) return;
    }
    return !h$4(pe, T$2.Loose) && pe.tabIndex !== -1 && ne.preventDefault(), B(ne, pe);
  }
  let re = useRef(null);
  d$4("pointerdown", (ne) => {
    var ie, pe;
    V.current && (re.current = ((pe = (ie = ne.composedPath) == null ? void 0 : ie.call(ne)) == null ? void 0 : pe[0]) || ne.target);
  }, !0), d$4("mousedown", (ne) => {
    var ie, pe;
    V.current && (re.current = ((pe = (ie = ne.composedPath) == null ? void 0 : ie.call(ne)) == null ? void 0 : pe[0]) || ne.target);
  }, !0), d$4("click", (ne) => {
    n$3() || re.current && (J(ne, () => re.current), re.current = null);
  }, !0), d$4("touchend", (ne) => J(ne, () => ne.target instanceof HTMLElement ? ne.target : null), !0), s$8("blur", (ne) => J(ne, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...A) {
  return useMemo(() => o$3(...A), [...A]);
}
function i$5(A) {
  var B;
  if (A.type) return A.type;
  let L = (B = A.as) != null ? B : "button";
  if (typeof L == "string" && L.toLowerCase() === "button") return "button";
}
function T$1(A, B) {
  let [L, V] = useState(() => i$5(A));
  return l$5(() => {
    V(i$5(A));
  }, [A.type, A.as]), l$5(() => {
    L || B.current && B.current instanceof HTMLButtonElement && !B.current.hasAttribute("type") && V("button");
  }, [L, B]), L;
}
let u$6 = Symbol();
function T(A, B = !0) {
  return Object.assign(A, { [u$6]: B });
}
function y$1(...A) {
  let B = useRef(A);
  useEffect(() => {
    B.current = A;
  }, [A]);
  let L = o$6((V) => {
    for (let J of B.current) J != null && (typeof J == "function" ? J(V) : J.current = V);
  });
  return A.every((V) => V == null || (V == null ? void 0 : V[u$6])) ? void 0 : L;
}
function t$5(A) {
  return [A.screenX, A.screenY];
}
function u$5() {
  let A = useRef([-1, -1]);
  return { wasMoved(B) {
    let L = t$5(B);
    return A.current[0] === L[0] && A.current[1] === L[1] ? !1 : (A.current = L, !0);
  }, update(B) {
    A.current = t$5(B);
  } };
}
function F$2({ container: A, accept: B, walk: L, enabled: V = !0 }) {
  let J = useRef(B), re = useRef(L);
  useEffect(() => {
    J.current = B, re.current = L;
  }, [B, L]), l$5(() => {
    if (!A || !V) return;
    let ne = o$3(A);
    if (!ne) return;
    let ie = J.current, pe = re.current, nt = Object.assign((Ce) => ie(Ce), { acceptNode: ie }), oe = ne.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, nt, !1);
    for (; oe.nextNode(); ) pe(oe.currentNode);
  }, [A, V, J, re]);
}
function m$2(A, B) {
  let L = useRef([]), V = o$6(A);
  useEffect(() => {
    let J = [...L.current];
    for (let [re, ne] of B.entries()) if (L.current[re] !== ne) {
      let ie = V(B, J);
      return L.current = B, ie;
    }
  }, [V, ...B]);
}
function t$4(...A) {
  return Array.from(new Set(A.flatMap((B) => typeof B == "string" ? B.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((A) => (A[A.None = 0] = "None", A[A.RenderStrategy = 1] = "RenderStrategy", A[A.Static = 2] = "Static", A))(O || {}), v$1 = ((A) => (A[A.Unmount = 0] = "Unmount", A[A.Hidden = 1] = "Hidden", A))(v$1 || {});
function C$1({ ourProps: A, theirProps: B, slot: L, defaultTag: V, features: J, visible: re = !0, name: ne, mergeRefs: ie }) {
  ie = ie ?? k$1;
  let pe = R$1(B, A);
  if (re) return m$1(pe, L, V, ne, ie);
  let nt = J ?? 0;
  if (nt & 2) {
    let { static: oe = !1, ...Ce } = pe;
    if (oe) return m$1(Ce, L, V, ne, ie);
  }
  if (nt & 1) {
    let { unmount: oe = !0, ...Ce } = pe;
    return u$7(oe ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...Ce, hidden: !0, style: { display: "none" } }, L, V, ne, ie);
    } });
  }
  return m$1(pe, L, V, ne, ie);
}
function m$1(A, B = {}, L, V, J) {
  let { as: re = L, children: ne, refName: ie = "ref", ...pe } = F$1(A, ["unmount", "static"]), nt = A.ref !== void 0 ? { [ie]: A.ref } : {}, oe = typeof ne == "function" ? ne(B) : ne;
  "className" in pe && pe.className && typeof pe.className == "function" && (pe.className = pe.className(B));
  let Ce = {};
  if (B) {
    let at = !1, it = [];
    for (let [gt, St] of Object.entries(B)) typeof St == "boolean" && (at = !0), St === !0 && it.push(gt);
    at && (Ce["data-headlessui-state"] = it.join(" "));
  }
  if (re === Fragment && Object.keys(x$2(pe)).length > 0) {
    if (!isValidElement(oe) || Array.isArray(oe) && oe.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${V} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(pe).map((St) => `  - ${St}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((St) => `  - ${St}`).join(`
`)].join(`
`));
    let at = oe.props, it = typeof (at == null ? void 0 : at.className) == "function" ? (...St) => t$4(at == null ? void 0 : at.className(...St), pe.className) : t$4(at == null ? void 0 : at.className, pe.className), gt = it ? { className: it } : {};
    return cloneElement(oe, Object.assign({}, R$1(oe.props, x$2(F$1(pe, ["ref"]))), Ce, nt, { ref: J(oe.ref, nt.ref) }, gt));
  }
  return createElement(re, Object.assign({}, F$1(pe, ["ref"]), re !== Fragment && nt, re !== Fragment && Ce), oe);
}
function k$1(...A) {
  return A.every((B) => B == null) ? void 0 : (B) => {
    for (let L of A) L != null && (typeof L == "function" ? L(B) : L.current = B);
  };
}
function R$1(...A) {
  if (A.length === 0) return {};
  if (A.length === 1) return A[0];
  let B = {}, L = {};
  for (let V of A) for (let J in V) J.startsWith("on") && typeof V[J] == "function" ? (L[J] != null || (L[J] = []), L[J].push(V[J])) : B[J] = V[J];
  if (B.disabled || B["aria-disabled"]) return Object.assign(B, Object.fromEntries(Object.keys(L).map((V) => [V, void 0])));
  for (let V in L) Object.assign(B, { [V](J, ...re) {
    let ne = L[V];
    for (let ie of ne) {
      if ((J instanceof Event || (J == null ? void 0 : J.nativeEvent) instanceof Event) && J.defaultPrevented) return;
      ie(J, ...re);
    }
  } });
  return B;
}
function U$3(A) {
  var B;
  return Object.assign(forwardRef(A), { displayName: (B = A.displayName) != null ? B : A.name });
}
function x$2(A) {
  let B = Object.assign({}, A);
  for (let L in B) B[L] === void 0 && delete B[L];
  return B;
}
function F$1(A, B = []) {
  let L = Object.assign({}, A);
  for (let V of B) V in L && delete L[V];
  return L;
}
let p$2 = "div";
var s$7 = ((A) => (A[A.None = 1] = "None", A[A.Focusable = 2] = "Focusable", A[A.Hidden = 4] = "Hidden", A))(s$7 || {});
function l$3(A, B) {
  var L;
  let { features: V = 1, ...J } = A, re = { ref: B, "aria-hidden": (V & 2) === 2 ? !0 : (L = J["aria-hidden"]) != null ? L : void 0, hidden: (V & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(V & 4) === 4 && (V & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: re, theirProps: J, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let u$4 = U$3(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((A) => (A[A.Open = 1] = "Open", A[A.Closed = 2] = "Closed", A[A.Closing = 4] = "Closing", A[A.Opening = 8] = "Opening", A))(d$3 || {});
function u$3() {
  return useContext(n$1);
}
function s$6({ value: A, children: B }) {
  return C__default.createElement(n$1.Provider, { value: A }, B);
}
function t$3(A) {
  function B() {
    document.readyState !== "loading" && (A(), document.removeEventListener("DOMContentLoaded", B));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", B), B());
}
let t$2 = [];
t$3(() => {
  function A(B) {
    B.target instanceof HTMLElement && B.target !== document.body && t$2[0] !== B.target && (t$2.unshift(B.target), t$2 = t$2.filter((L) => L != null && L.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", A, { capture: !0 }), window.addEventListener("mousedown", A, { capture: !0 }), window.addEventListener("focus", A, { capture: !0 }), document.body.addEventListener("click", A, { capture: !0 }), document.body.addEventListener("mousedown", A, { capture: !0 }), document.body.addEventListener("focus", A, { capture: !0 });
});
function r$4(A) {
  let B = A.parentElement, L = null;
  for (; B && !(B instanceof HTMLFieldSetElement); ) B instanceof HTMLLegendElement && (L = B), B = B.parentElement;
  let V = (B == null ? void 0 : B.getAttribute("disabled")) === "";
  return V && i$4(L) ? !1 : V;
}
function i$4(A) {
  if (!A) return !1;
  let B = A.previousElementSibling;
  for (; B !== null; ) {
    if (B instanceof HTMLLegendElement) return !1;
    B = B.previousElementSibling;
  }
  return !0;
}
function u$2(A) {
  throw new Error("Unexpected object: " + A);
}
var c$4 = ((A) => (A[A.First = 0] = "First", A[A.Previous = 1] = "Previous", A[A.Next = 2] = "Next", A[A.Last = 3] = "Last", A[A.Specific = 4] = "Specific", A[A.Nothing = 5] = "Nothing", A))(c$4 || {});
function f$6(A, B) {
  let L = B.resolveItems();
  if (L.length <= 0) return null;
  let V = B.resolveActiveIndex(), J = V ?? -1;
  switch (A.focus) {
    case 0: {
      for (let re = 0; re < L.length; ++re) if (!B.resolveDisabled(L[re], re, L)) return re;
      return V;
    }
    case 1: {
      for (let re = J - 1; re >= 0; --re) if (!B.resolveDisabled(L[re], re, L)) return re;
      return V;
    }
    case 2: {
      for (let re = J + 1; re < L.length; ++re) if (!B.resolveDisabled(L[re], re, L)) return re;
      return V;
    }
    case 3: {
      for (let re = L.length - 1; re >= 0; --re) if (!B.resolveDisabled(L[re], re, L)) return re;
      return V;
    }
    case 4: {
      for (let re = 0; re < L.length; ++re) if (B.resolveId(L[re], re, L) === A.id) return re;
      return V;
    }
    case 5:
      return null;
    default:
      u$2(A);
  }
}
var o$2 = ((A) => (A.Space = " ", A.Enter = "Enter", A.Escape = "Escape", A.Backspace = "Backspace", A.Delete = "Delete", A.ArrowLeft = "ArrowLeft", A.ArrowUp = "ArrowUp", A.ArrowRight = "ArrowRight", A.ArrowDown = "ArrowDown", A.Home = "Home", A.End = "End", A.PageUp = "PageUp", A.PageDown = "PageDown", A.Tab = "Tab", A))(o$2 || {});
function E(A, B, L, V) {
  let J = s$a(L);
  useEffect(() => {
    A = A ?? window;
    function re(ne) {
      J.current(ne);
    }
    return A.addEventListener(B, re, V), () => A.removeEventListener(B, re, V);
  }, [A, B, V]);
}
function f$5() {
  let A = useRef(!1);
  return l$5(() => (A.current = !0, () => {
    A.current = !1;
  }), []), A;
}
function c$3(A) {
  let B = o$6(A), L = useRef(!1);
  useEffect(() => (L.current = !1, () => {
    L.current = !0, t$7(() => {
      L.current && B();
    });
  }), [B]);
}
var s$5 = ((A) => (A[A.Forwards = 0] = "Forwards", A[A.Backwards = 1] = "Backwards", A))(s$5 || {});
function n() {
  let A = useRef(0);
  return s$8("keydown", (B) => {
    B.key === "Tab" && (A.current = B.shiftKey ? 1 : 0);
  }, !0), A;
}
function P(A) {
  if (!A) return /* @__PURE__ */ new Set();
  if (typeof A == "function") return new Set(A());
  let B = /* @__PURE__ */ new Set();
  for (let L of A.current) L.current instanceof HTMLElement && B.add(L.current);
  return B;
}
let X = "div";
var _$1 = ((A) => (A[A.None = 1] = "None", A[A.InitialFocus = 2] = "InitialFocus", A[A.TabLock = 4] = "TabLock", A[A.FocusLock = 8] = "FocusLock", A[A.RestoreFocus = 16] = "RestoreFocus", A[A.All = 30] = "All", A))(_$1 || {});
function z(A, B) {
  let L = useRef(null), V = y$1(L, B), { initialFocus: J, containers: re, features: ne = 30, ...ie } = A;
  l$4() || (ne = 1);
  let pe = n$2(L);
  Y({ ownerDocument: pe }, !!(ne & 16));
  let nt = Z({ ownerDocument: pe, container: L, initialFocus: J }, !!(ne & 2));
  $({ ownerDocument: pe, container: L, containers: re, previousActiveElement: nt }, !!(ne & 8));
  let oe = n(), Ce = o$6((St) => {
    let xt = L.current;
    xt && ((Mt) => Mt())(() => {
      u$7(oe.current, { [s$5.Forwards]: () => {
        O$1(xt, M$2.First, { skipElements: [St.relatedTarget] });
      }, [s$5.Backwards]: () => {
        O$1(xt, M$2.Last, { skipElements: [St.relatedTarget] });
      } });
    });
  }), at = p$3(), it = useRef(!1), gt = { ref: V, onKeyDown(St) {
    St.key == "Tab" && (it.current = !0, at.requestAnimationFrame(() => {
      it.current = !1;
    }));
  }, onBlur(St) {
    let xt = P(re);
    L.current instanceof HTMLElement && xt.add(L.current);
    let Mt = St.relatedTarget;
    Mt instanceof HTMLElement && Mt.dataset.headlessuiFocusGuard !== "true" && (S$4(xt, Mt) || (it.current ? O$1(L.current, u$7(oe.current, { [s$5.Forwards]: () => M$2.Next, [s$5.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: St.target }) : St.target instanceof HTMLElement && y$3(St.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(ne & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ce, features: s$7.Focusable }), C$1({ ourProps: gt, theirProps: ie, defaultTag: X, name: "FocusTrap" }), !!(ne & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ce, features: s$7.Focusable }));
}
let D$2 = U$3(z), de$1 = Object.assign(D$2, { features: _$1 });
function Q(A = !0) {
  let B = useRef(t$2.slice());
  return m$2(([L], [V]) => {
    V === !0 && L === !1 && t$7(() => {
      B.current.splice(0);
    }), V === !1 && L === !0 && (B.current = t$2.slice());
  }, [A, t$2, B]), o$6(() => {
    var L;
    return (L = B.current.find((V) => V != null && V.isConnected)) != null ? L : null;
  });
}
function Y({ ownerDocument: A }, B) {
  let L = Q(B);
  m$2(() => {
    B || (A == null ? void 0 : A.activeElement) === (A == null ? void 0 : A.body) && y$3(L());
  }, [B]), c$3(() => {
    B && y$3(L());
  });
}
function Z({ ownerDocument: A, container: B, initialFocus: L }, V) {
  let J = useRef(null), re = f$5();
  return m$2(() => {
    if (!V) return;
    let ne = B.current;
    ne && t$7(() => {
      if (!re.current) return;
      let ie = A == null ? void 0 : A.activeElement;
      if (L != null && L.current) {
        if ((L == null ? void 0 : L.current) === ie) {
          J.current = ie;
          return;
        }
      } else if (ne.contains(ie)) {
        J.current = ie;
        return;
      }
      L != null && L.current ? y$3(L.current) : O$1(ne, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), J.current = A == null ? void 0 : A.activeElement;
    });
  }, [V]), J;
}
function $({ ownerDocument: A, container: B, containers: L, previousActiveElement: V }, J) {
  let re = f$5();
  E(A == null ? void 0 : A.defaultView, "focus", (ne) => {
    if (!J || !re.current) return;
    let ie = P(L);
    B.current instanceof HTMLElement && ie.add(B.current);
    let pe = V.current;
    if (!pe) return;
    let nt = ne.target;
    nt && nt instanceof HTMLElement ? S$4(ie, nt) ? (V.current = nt, y$3(nt)) : (ne.preventDefault(), ne.stopPropagation(), y$3(pe)) : y$3(V.current);
  }, !0);
}
function S$4(A, B) {
  for (let L of A) if (L.contains(B)) return !0;
  return !1;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function l$2(A) {
  return C__default.createElement(e.Provider, { value: A.force }, A.children);
}
function F(A) {
  let B = a$5(), L = useContext(_), V = n$2(A), [J, re] = useState(() => {
    if (!B && L !== null || s$b.isServer) return null;
    let ne = V == null ? void 0 : V.getElementById("headlessui-portal-root");
    if (ne) return ne;
    if (V === null) return null;
    let ie = V.createElement("div");
    return ie.setAttribute("id", "headlessui-portal-root"), V.body.appendChild(ie);
  });
  return useEffect(() => {
    J !== null && (V != null && V.body.contains(J) || V == null || V.body.appendChild(J));
  }, [J, V]), useEffect(() => {
    B || L !== null && re(L.current);
  }, [L, re, B]), J;
}
let U$2 = Fragment;
function N$1(A, B) {
  let L = A, V = useRef(null), J = y$1(T((oe) => {
    V.current = oe;
  }), B), re = n$2(V), ne = F(V), [ie] = useState(() => {
    var oe;
    return s$b.isServer ? null : (oe = re == null ? void 0 : re.createElement("div")) != null ? oe : null;
  }), pe = useContext(f$4), nt = l$4();
  return l$5(() => {
    !ne || !ie || ne.contains(ie) || (ie.setAttribute("data-headlessui-portal", ""), ne.appendChild(ie));
  }, [ne, ie]), l$5(() => {
    if (ie && pe) return pe.register(ie);
  }, [pe, ie]), c$3(() => {
    var oe;
    !ne || !ie || (ie instanceof Node && ne.contains(ie) && ne.removeChild(ie), ne.childNodes.length <= 0 && ((oe = ne.parentElement) == null || oe.removeChild(ne)));
  }), nt ? !ne || !ie ? null : createPortal(C$1({ ourProps: { ref: J }, theirProps: L, defaultTag: U$2, name: "Portal" }), ie) : null;
}
let S$3 = Fragment, _ = createContext(null);
function j(A, B) {
  let { target: L, ...V } = A, J = { ref: y$1(B) };
  return C__default.createElement(_.Provider, { value: L }, C$1({ ourProps: J, theirProps: V, defaultTag: S$3, name: "Popover.Group" }));
}
let f$4 = createContext(null);
function ee() {
  let A = useContext(f$4), B = useRef([]), L = o$6((re) => (B.current.push(re), A && A.register(re), () => V(re))), V = o$6((re) => {
    let ne = B.current.indexOf(re);
    ne !== -1 && B.current.splice(ne, 1), A && A.unregister(re);
  }), J = useMemo(() => ({ register: L, unregister: V, portals: B }), [L, V, B]);
  return [B, useMemo(() => function({ children: re }) {
    return C__default.createElement(f$4.Provider, { value: J }, re);
  }, [J])];
}
let D$1 = U$3(N$1), I$3 = U$3(j), te = Object.assign(D$1, { Group: I$3 });
function i$3(A, B) {
  return A === B && (A !== 0 || 1 / A === 1 / B) || A !== A && B !== B;
}
const d$2 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$3, useLayoutEffect: f$3, useDebugValue: p$1 } = C$2;
function y(A, B, L) {
  const V = B(), [{ inst: J }, re] = u$1({ inst: { value: V, getSnapshot: B } });
  return f$3(() => {
    J.value = V, J.getSnapshot = B, r$3(J) && re({ inst: J });
  }, [A, V, B]), h$3(() => (r$3(J) && re({ inst: J }), A(() => {
    r$3(J) && re({ inst: J });
  })), [A]), p$1(V), V;
}
function r$3(A) {
  const B = A.getSnapshot, L = A.value;
  try {
    const V = B();
    return !d$2(L, V);
  } catch {
    return !0;
  }
}
function t$1(A, B, L) {
  return B();
}
const r$2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$4 = !r$2, c$2 = s$4 ? t$1 : y, a$4 = "useSyncExternalStore" in C$2 ? ((A) => A.useSyncExternalStore)(C$2) : c$2;
function S$2(A) {
  return a$4(A.subscribe, A.getSnapshot, A.getSnapshot);
}
function a$3(A, B) {
  let L = A(), V = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return L;
  }, subscribe(J) {
    return V.add(J), () => V.delete(J);
  }, dispatch(J, ...re) {
    let ne = B[J].call(L, ...re);
    ne && (L = ne, V.forEach((ie) => ie()));
  } };
}
function c$1() {
  let A;
  return { before({ doc: B }) {
    var L;
    let V = B.documentElement;
    A = ((L = B.defaultView) != null ? L : window).innerWidth - V.clientWidth;
  }, after({ doc: B, d: L }) {
    let V = B.documentElement, J = V.clientWidth - V.offsetWidth, re = A - J;
    L.style(V, "paddingRight", `${re}px`);
  } };
}
function d$1() {
  return t$6() ? { before({ doc: A, d: B, meta: L }) {
    function V(J) {
      return L.containers.flatMap((re) => re()).some((re) => re.contains(J));
    }
    B.microTask(() => {
      var J;
      if (window.getComputedStyle(A.documentElement).scrollBehavior !== "auto") {
        let ie = o$5();
        ie.style(A.documentElement, "scrollBehavior", "auto"), B.add(() => B.microTask(() => ie.dispose()));
      }
      let re = (J = window.scrollY) != null ? J : window.pageYOffset, ne = null;
      B.addEventListener(A, "click", (ie) => {
        if (ie.target instanceof HTMLElement) try {
          let pe = ie.target.closest("a");
          if (!pe) return;
          let { hash: nt } = new URL(pe.href), oe = A.querySelector(nt);
          oe && !V(oe) && (ne = oe);
        } catch {
        }
      }, !0), B.addEventListener(A, "touchstart", (ie) => {
        if (ie.target instanceof HTMLElement) if (V(ie.target)) {
          let pe = ie.target;
          for (; pe.parentElement && V(pe.parentElement); ) pe = pe.parentElement;
          B.style(pe, "overscrollBehavior", "contain");
        } else B.style(ie.target, "touchAction", "none");
      }), B.addEventListener(A, "touchmove", (ie) => {
        if (ie.target instanceof HTMLElement) if (V(ie.target)) {
          let pe = ie.target;
          for (; pe.parentElement && pe.dataset.headlessuiPortal !== "" && !(pe.scrollHeight > pe.clientHeight || pe.scrollWidth > pe.clientWidth); ) pe = pe.parentElement;
          pe.dataset.headlessuiPortal === "" && ie.preventDefault();
        } else ie.preventDefault();
      }, { passive: !1 }), B.add(() => {
        var ie;
        let pe = (ie = window.scrollY) != null ? ie : window.pageYOffset;
        re !== pe && window.scrollTo(0, re), ne && ne.isConnected && (ne.scrollIntoView({ block: "nearest" }), ne = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: A, d: B }) {
    B.style(A.documentElement, "overflow", "hidden");
  } };
}
function m(A) {
  let B = {};
  for (let L of A) Object.assign(B, L(B));
  return B;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(A, B) {
  var L;
  let V = (L = this.get(A)) != null ? L : { doc: A, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return V.count++, V.meta.add(B), this.set(A, V), this;
}, POP(A, B) {
  let L = this.get(A);
  return L && (L.count--, L.meta.delete(B)), this;
}, SCROLL_PREVENT({ doc: A, d: B, meta: L }) {
  let V = { doc: A, d: B, meta: m(L) }, J = [d$1(), c$1(), l$1()];
  J.forEach(({ before: re }) => re == null ? void 0 : re(V)), J.forEach(({ after: re }) => re == null ? void 0 : re(V));
}, SCROLL_ALLOW({ d: A }) {
  A.dispose();
}, TEARDOWN({ doc: A }) {
  this.delete(A);
} });
a$2.subscribe(() => {
  let A = a$2.getSnapshot(), B = /* @__PURE__ */ new Map();
  for (let [L] of A) B.set(L, L.documentElement.style.overflow);
  for (let L of A.values()) {
    let V = B.get(L.doc) === "hidden", J = L.count !== 0;
    (J && !V || !J && V) && a$2.dispatch(L.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", L), L.count === 0 && a$2.dispatch("TEARDOWN", L);
  }
});
function p(A, B, L) {
  let V = S$2(a$2), J = A ? V.get(A) : void 0, re = J ? J.count > 0 : !1;
  return l$5(() => {
    if (!(!A || !B)) return a$2.dispatch("PUSH", A, L), () => a$2.dispatch("POP", A, L);
  }, [B, A]), re;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(A, B = !0) {
  l$5(() => {
    var L;
    if (!B) return;
    let V = typeof A == "function" ? A() : A.current;
    if (!V) return;
    function J() {
      var ne;
      if (!V) return;
      let ie = (ne = t.get(V)) != null ? ne : 1;
      if (ie === 1 ? t.delete(V) : t.set(V, ie - 1), ie !== 1) return;
      let pe = u.get(V);
      pe && (pe["aria-hidden"] === null ? V.removeAttribute("aria-hidden") : V.setAttribute("aria-hidden", pe["aria-hidden"]), V.inert = pe.inert, u.delete(V));
    }
    let re = (L = t.get(V)) != null ? L : 0;
    return t.set(V, re + 1), re !== 0 || (u.set(V, { "aria-hidden": V.getAttribute("aria-hidden"), inert: V.inert }), V.setAttribute("aria-hidden", "true"), V.inert = !0), J;
  }, [A, B]);
}
function N({ defaultContainers: A = [], portals: B, mainTreeNodeRef: L } = {}) {
  var V;
  let J = useRef((V = L == null ? void 0 : L.current) != null ? V : null), re = n$2(J), ne = o$6(() => {
    var ie, pe, nt;
    let oe = [];
    for (let Ce of A) Ce !== null && (Ce instanceof HTMLElement ? oe.push(Ce) : "current" in Ce && Ce.current instanceof HTMLElement && oe.push(Ce.current));
    if (B != null && B.current) for (let Ce of B.current) oe.push(Ce);
    for (let Ce of (ie = re == null ? void 0 : re.querySelectorAll("html > *, body > *")) != null ? ie : []) Ce !== document.body && Ce !== document.head && Ce instanceof HTMLElement && Ce.id !== "headlessui-portal-root" && (Ce.contains(J.current) || Ce.contains((nt = (pe = J.current) == null ? void 0 : pe.getRootNode()) == null ? void 0 : nt.host) || oe.some((at) => Ce.contains(at)) || oe.push(Ce));
    return oe;
  });
  return { resolveContainers: ne, contains: o$6((ie) => ne().some((pe) => pe.contains(ie))), mainTreeNodeRef: J, MainTreeNode: useMemo(() => function() {
    return L != null ? null : C__default.createElement(u$4, { features: s$7.Hidden, ref: J });
  }, [J, L]) };
}
let a$1 = createContext(() => {
});
a$1.displayName = "StackContext";
var s$3 = ((A) => (A[A.Add = 0] = "Add", A[A.Remove = 1] = "Remove", A))(s$3 || {});
function x$1() {
  return useContext(a$1);
}
function b$2({ children: A, onUpdate: B, type: L, element: V, enabled: J }) {
  let re = x$1(), ne = o$6((...ie) => {
    B == null || B(...ie), re(...ie);
  });
  return l$5(() => {
    let ie = J === void 0 || J === !0;
    return ie && ne(0, L, V), () => {
      ie && ne(1, L, V);
    };
  }, [ne, L, V, J]), C__default.createElement(a$1.Provider, { value: ne }, A);
}
let d = createContext(null);
function f$2() {
  let A = useContext(d);
  if (A === null) {
    let B = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(B, f$2), B;
  }
  return A;
}
function w$1() {
  let [A, B] = useState([]);
  return [A.length > 0 ? A.join(" ") : void 0, useMemo(() => function(L) {
    let V = o$6((re) => (B((ne) => [...ne, re]), () => B((ne) => {
      let ie = ne.slice(), pe = ie.indexOf(re);
      return pe !== -1 && ie.splice(pe, 1), ie;
    }))), J = useMemo(() => ({ register: V, slot: L.slot, name: L.name, props: L.props }), [V, L.slot, L.name, L.props]);
    return C__default.createElement(d.Provider, { value: J }, L.children);
  }, [B])];
}
let I$2 = "p";
function S$1(A, B) {
  let L = I$5(), { id: V = `headlessui-description-${L}`, ...J } = A, re = f$2(), ne = y$1(B);
  l$5(() => re.register(V), [V, re.register]);
  let ie = { ref: ne, ...re.props, id: V };
  return C$1({ ourProps: ie, theirProps: J, slot: re.slot || {}, defaultTag: I$2, name: re.name || "Description" });
}
let h$2 = U$3(S$1), G$1 = Object.assign(h$2, {});
var Me$1 = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(Me$1 || {}), we = ((A) => (A[A.SetTitleId = 0] = "SetTitleId", A))(we || {});
let He$1 = { 0(A, B) {
  return A.titleId === B.id ? A : { ...A, titleId: B.id };
} }, I$1 = createContext(null);
I$1.displayName = "DialogContext";
function b$1(A) {
  let B = useContext(I$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, b$1), L;
  }
  return B;
}
function Be(A, B, L = () => [document.body]) {
  p(A, B, (V) => {
    var J;
    return { containers: [...(J = V.containers) != null ? J : [], L] };
  });
}
function Ge(A, B) {
  return u$7(B.type, He$1, A, B);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(A, B) {
  let L = I$5(), { id: V = `headlessui-dialog-${L}`, open: J, onClose: re, initialFocus: ne, role: ie = "dialog", __demoMode: pe = !1, ...nt } = A, [oe, Ce] = useState(0), at = useRef(!1);
  ie = function() {
    return ie === "dialog" || ie === "alertdialog" ? ie : (at.current || (at.current = !0, console.warn(`Invalid role [${ie}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let it = u$3();
  J === void 0 && it !== null && (J = (it & d$3.Open) === d$3.Open);
  let gt = useRef(null), St = y$1(gt, B), xt = n$2(gt), Mt = A.hasOwnProperty("open") || it !== null, bt = A.hasOwnProperty("onClose");
  if (!Mt && !bt) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!Mt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!bt) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof J != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${J}`);
  if (typeof re != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${re}`);
  let Tt = J ? 0 : 1, [It, qt] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), Dt = o$6(() => re(!1)), Xt = o$6((Nt) => qt({ type: 0, id: Nt })), Bt = l$4() ? pe ? !1 : Tt === 0 : !1, mt = oe > 1, Ot = useContext(I$1) !== null, [wt, ke] = ee(), rt = { get current() {
    var Nt;
    return (Nt = It.panelRef.current) != null ? Nt : gt.current;
  } }, { resolveContainers: ce, mainTreeNodeRef: Oe, MainTreeNode: ot } = N({ portals: wt, defaultContainers: [rt] }), ut = mt ? "parent" : "leaf", ht = it !== null ? (it & d$3.Closing) === d$3.Closing : !1, dt = Ot || ht ? !1 : Bt, st = useCallback(() => {
    var Nt, Ft;
    return (Ft = Array.from((Nt = xt == null ? void 0 : xt.querySelectorAll("body > *")) != null ? Nt : []).find((er) => er.id === "headlessui-portal-root" ? !1 : er.contains(Oe.current) && er instanceof HTMLElement)) != null ? Ft : null;
  }, [Oe]);
  b$3(st, dt);
  let yt = mt ? !0 : Bt, ct = useCallback(() => {
    var Nt, Ft;
    return (Ft = Array.from((Nt = xt == null ? void 0 : xt.querySelectorAll("[data-headlessui-portal]")) != null ? Nt : []).find((er) => er.contains(Oe.current) && er instanceof HTMLElement)) != null ? Ft : null;
  }, [Oe]);
  b$3(ct, yt), y$2(ce, (Nt) => {
    Nt.preventDefault(), Dt();
  }, !(!Bt || mt));
  let Kt = !(mt || Tt !== 0);
  E(xt == null ? void 0 : xt.defaultView, "keydown", (Nt) => {
    Kt && (Nt.defaultPrevented || Nt.key === o$2.Escape && (Nt.preventDefault(), Nt.stopPropagation(), Dt()));
  }), Be(xt, !(ht || Tt !== 0 || Ot), ce), useEffect(() => {
    if (Tt !== 0 || !gt.current) return;
    let Nt = new ResizeObserver((Ft) => {
      for (let er of Ft) {
        let fr = er.target.getBoundingClientRect();
        fr.x === 0 && fr.y === 0 && fr.width === 0 && fr.height === 0 && Dt();
      }
    });
    return Nt.observe(gt.current), () => Nt.disconnect();
  }, [Tt, gt, Dt]);
  let [Ht, Pt] = w$1(), kt = useMemo(() => [{ dialogState: Tt, close: Dt, setTitleId: Xt }, It], [Tt, It, Dt, Xt]), Vt = useMemo(() => ({ open: Tt === 0 }), [Tt]), tr = { ref: St, id: V, role: ie, "aria-modal": Tt === 0 ? !0 : void 0, "aria-labelledby": It.titleId, "aria-describedby": Ht };
  return C__default.createElement(b$2, { type: "Dialog", enabled: Tt === 0, element: gt, onUpdate: o$6((Nt, Ft) => {
    Ft === "Dialog" && u$7(Nt, { [s$3.Add]: () => Ce((er) => er + 1), [s$3.Remove]: () => Ce((er) => er - 1) });
  }) }, C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$1.Provider, { value: kt }, C__default.createElement(te.Group, { target: gt }, C__default.createElement(l$2, { force: !1 }, C__default.createElement(Pt, { slot: Vt, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: ne, containers: ce, features: Bt ? u$7(ut, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(ke, null, C$1({ ourProps: tr, theirProps: nt, slot: Vt, defaultTag: Ne$1, features: Ue, visible: Tt === 0, name: "Dialog" }))))))))), C__default.createElement(ot, null));
}
let $e = "div";
function Ye(A, B) {
  let L = I$5(), { id: V = `headlessui-dialog-overlay-${L}`, ...J } = A, [{ dialogState: re, close: ne }] = b$1("Dialog.Overlay"), ie = y$1(B), pe = o$6((oe) => {
    if (oe.target === oe.currentTarget) {
      if (r$4(oe.currentTarget)) return oe.preventDefault();
      oe.preventDefault(), oe.stopPropagation(), ne();
    }
  }), nt = useMemo(() => ({ open: re === 0 }), [re]);
  return C$1({ ourProps: { ref: ie, id: V, "aria-hidden": !0, onClick: pe }, theirProps: J, slot: nt, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(A, B) {
  let L = I$5(), { id: V = `headlessui-dialog-backdrop-${L}`, ...J } = A, [{ dialogState: re }, ne] = b$1("Dialog.Backdrop"), ie = y$1(B);
  useEffect(() => {
    if (ne.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [ne.panelRef]);
  let pe = useMemo(() => ({ open: re === 0 }), [re]);
  return C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C$1({ ourProps: { ref: ie, id: V, "aria-hidden": !0 }, theirProps: J, slot: pe, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(A, B) {
  let L = I$5(), { id: V = `headlessui-dialog-panel-${L}`, ...J } = A, [{ dialogState: re }, ne] = b$1("Dialog.Panel"), ie = y$1(B, ne.panelRef), pe = useMemo(() => ({ open: re === 0 }), [re]), nt = o$6((oe) => {
    oe.stopPropagation();
  });
  return C$1({ ourProps: { ref: ie, id: V, onClick: nt }, theirProps: J, slot: pe, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(A, B) {
  let L = I$5(), { id: V = `headlessui-dialog-title-${L}`, ...J } = A, [{ dialogState: re, setTitleId: ne }] = b$1("Dialog.Title"), ie = y$1(B);
  useEffect(() => (ne(V), () => ne(null)), [V, ne]);
  let pe = useMemo(() => ({ open: re === 0 }), [re]);
  return C$1({ ourProps: { ref: ie, id: V }, theirProps: J, slot: pe, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G$1 }), a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(A) {
  var B, L;
  let V = (B = A.innerText) != null ? B : "", J = A.cloneNode(!0);
  if (!(J instanceof HTMLElement)) return V;
  let re = !1;
  for (let ie of J.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ie.remove(), re = !0;
  let ne = re ? (L = J.innerText) != null ? L : "" : V;
  return a.test(ne) && (ne = ne.replace(a, "")), ne;
}
function g$3(A) {
  let B = A.getAttribute("aria-label");
  if (typeof B == "string") return B.trim();
  let L = A.getAttribute("aria-labelledby");
  if (L) {
    let V = L.split(" ").map((J) => {
      let re = document.getElementById(J);
      if (re) {
        let ne = re.getAttribute("aria-label");
        return typeof ne == "string" ? ne.trim() : o$1(re).trim();
      }
      return null;
    }).filter(Boolean);
    if (V.length > 0) return V.join(", ");
  }
  return o$1(A).trim();
}
function s$2(A) {
  let B = useRef(""), L = useRef("");
  return o$6(() => {
    let V = A.current;
    if (!V) return "";
    let J = V.innerText;
    if (B.current === J) return L.current;
    let re = g$3(V).trim().toLowerCase();
    return B.current = J, L.current = re, re;
  });
}
var me = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(me || {}), de = ((A) => (A[A.Pointer = 0] = "Pointer", A[A.Other = 1] = "Other", A))(de || {}), fe = ((A) => (A[A.OpenMenu = 0] = "OpenMenu", A[A.CloseMenu = 1] = "CloseMenu", A[A.GoToItem = 2] = "GoToItem", A[A.Search = 3] = "Search", A[A.ClearSearch = 4] = "ClearSearch", A[A.RegisterItem = 5] = "RegisterItem", A[A.UnregisterItem = 6] = "UnregisterItem", A))(fe || {});
function w(A, B = (L) => L) {
  let L = A.activeItemIndex !== null ? A.items[A.activeItemIndex] : null, V = I$4(B(A.items.slice()), (re) => re.dataRef.current.domRef.current), J = L ? V.indexOf(L) : null;
  return J === -1 && (J = null), { items: V, activeItemIndex: J };
}
let Te = { 1(A) {
  return A.menuState === 1 ? A : { ...A, activeItemIndex: null, menuState: 1 };
}, 0(A) {
  return A.menuState === 0 ? A : { ...A, __demoMode: !1, menuState: 0 };
}, 2: (A, B) => {
  var L;
  let V = w(A), J = f$6(B, { resolveItems: () => V.items, resolveActiveIndex: () => V.activeItemIndex, resolveId: (re) => re.id, resolveDisabled: (re) => re.dataRef.current.disabled });
  return { ...A, ...V, searchQuery: "", activeItemIndex: J, activationTrigger: (L = B.trigger) != null ? L : 1 };
}, 3: (A, B) => {
  let L = A.searchQuery !== "" ? 0 : 1, V = A.searchQuery + B.value.toLowerCase(), J = (A.activeItemIndex !== null ? A.items.slice(A.activeItemIndex + L).concat(A.items.slice(0, A.activeItemIndex + L)) : A.items).find((ne) => {
    var ie;
    return ((ie = ne.dataRef.current.textValue) == null ? void 0 : ie.startsWith(V)) && !ne.dataRef.current.disabled;
  }), re = J ? A.items.indexOf(J) : -1;
  return re === -1 || re === A.activeItemIndex ? { ...A, searchQuery: V } : { ...A, searchQuery: V, activeItemIndex: re, activationTrigger: 1 };
}, 4(A) {
  return A.searchQuery === "" ? A : { ...A, searchQuery: "", searchActiveItemIndex: null };
}, 5: (A, B) => {
  let L = w(A, (V) => [...V, { id: B.id, dataRef: B.dataRef }]);
  return { ...A, ...L };
}, 6: (A, B) => {
  let L = w(A, (V) => {
    let J = V.findIndex((re) => re.id === B.id);
    return J !== -1 && V.splice(J, 1), V;
  });
  return { ...A, ...L, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C(A) {
  let B = useContext(U$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, C), L;
  }
  return B;
}
function ye$1(A, B) {
  return u$7(B.type, Te, A, B);
}
let Ie = Fragment;
function Me(A, B) {
  let { __demoMode: L = !1, ...V } = A, J = useReducer(ye$1, { __demoMode: L, menuState: L ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: re, itemsRef: ne, buttonRef: ie }, pe] = J, nt = y$1(B);
  y$2([ie, ne], (it, gt) => {
    var St;
    pe({ type: 1 }), h$4(gt, T$2.Loose) || (it.preventDefault(), (St = ie.current) == null || St.focus());
  }, re === 0);
  let oe = o$6(() => {
    pe({ type: 1 });
  }), Ce = useMemo(() => ({ open: re === 0, close: oe }), [re, oe]), at = { ref: nt };
  return C__default.createElement(U$1.Provider, { value: J }, C__default.createElement(s$6, { value: u$7(re, { 0: d$3.Open, 1: d$3.Closed }) }, C$1({ ourProps: at, theirProps: V, slot: Ce, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(A, B) {
  var L;
  let V = I$5(), { id: J = `headlessui-menu-button-${V}`, ...re } = A, [ne, ie] = C("Menu.Button"), pe = y$1(ne.buttonRef, B), nt = p$3(), oe = o$6((St) => {
    switch (St.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        St.preventDefault(), St.stopPropagation(), ie({ type: 0 }), nt.nextFrame(() => ie({ type: 2, focus: c$4.First }));
        break;
      case o$2.ArrowUp:
        St.preventDefault(), St.stopPropagation(), ie({ type: 0 }), nt.nextFrame(() => ie({ type: 2, focus: c$4.Last }));
        break;
    }
  }), Ce = o$6((St) => {
    switch (St.key) {
      case o$2.Space:
        St.preventDefault();
        break;
    }
  }), at = o$6((St) => {
    if (r$4(St.currentTarget)) return St.preventDefault();
    A.disabled || (ne.menuState === 0 ? (ie({ type: 1 }), nt.nextFrame(() => {
      var xt;
      return (xt = ne.buttonRef.current) == null ? void 0 : xt.focus({ preventScroll: !0 });
    })) : (St.preventDefault(), ie({ type: 0 })));
  }), it = useMemo(() => ({ open: ne.menuState === 0 }), [ne]), gt = { ref: pe, id: J, type: T$1(A, ne.buttonRef), "aria-haspopup": "menu", "aria-controls": (L = ne.itemsRef.current) == null ? void 0 : L.id, "aria-expanded": ne.menuState === 0, onKeyDown: oe, onKeyUp: Ce, onClick: at };
  return C$1({ ourProps: gt, theirProps: re, slot: it, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O.RenderStrategy | O.Static;
function Ee(A, B) {
  var L, V;
  let J = I$5(), { id: re = `headlessui-menu-items-${J}`, ...ne } = A, [ie, pe] = C("Menu.Items"), nt = y$1(ie.itemsRef, B), oe = n$2(ie.itemsRef), Ce = p$3(), at = u$3(), it = at !== null ? (at & d$3.Open) === d$3.Open : ie.menuState === 0;
  useEffect(() => {
    let bt = ie.itemsRef.current;
    bt && ie.menuState === 0 && bt !== (oe == null ? void 0 : oe.activeElement) && bt.focus({ preventScroll: !0 });
  }, [ie.menuState, ie.itemsRef, oe]), F$2({ container: ie.itemsRef.current, enabled: ie.menuState === 0, accept(bt) {
    return bt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : bt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(bt) {
    bt.setAttribute("role", "none");
  } });
  let gt = o$6((bt) => {
    var Tt, It;
    switch (Ce.dispose(), bt.key) {
      case o$2.Space:
        if (ie.searchQuery !== "") return bt.preventDefault(), bt.stopPropagation(), pe({ type: 3, value: bt.key });
      case o$2.Enter:
        if (bt.preventDefault(), bt.stopPropagation(), pe({ type: 1 }), ie.activeItemIndex !== null) {
          let { dataRef: qt } = ie.items[ie.activeItemIndex];
          (It = (Tt = qt.current) == null ? void 0 : Tt.domRef.current) == null || It.click();
        }
        D$3(ie.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return bt.preventDefault(), bt.stopPropagation(), pe({ type: 2, focus: c$4.Next });
      case o$2.ArrowUp:
        return bt.preventDefault(), bt.stopPropagation(), pe({ type: 2, focus: c$4.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return bt.preventDefault(), bt.stopPropagation(), pe({ type: 2, focus: c$4.First });
      case o$2.End:
      case o$2.PageDown:
        return bt.preventDefault(), bt.stopPropagation(), pe({ type: 2, focus: c$4.Last });
      case o$2.Escape:
        bt.preventDefault(), bt.stopPropagation(), pe({ type: 1 }), o$5().nextFrame(() => {
          var qt;
          return (qt = ie.buttonRef.current) == null ? void 0 : qt.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        bt.preventDefault(), bt.stopPropagation(), pe({ type: 1 }), o$5().nextFrame(() => {
          _$2(ie.buttonRef.current, bt.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        bt.key.length === 1 && (pe({ type: 3, value: bt.key }), Ce.setTimeout(() => pe({ type: 4 }), 350));
        break;
    }
  }), St = o$6((bt) => {
    switch (bt.key) {
      case o$2.Space:
        bt.preventDefault();
        break;
    }
  }), xt = useMemo(() => ({ open: ie.menuState === 0 }), [ie]), Mt = { "aria-activedescendant": ie.activeItemIndex === null || (L = ie.items[ie.activeItemIndex]) == null ? void 0 : L.id, "aria-labelledby": (V = ie.buttonRef.current) == null ? void 0 : V.id, id: re, onKeyDown: gt, onKeyUp: St, role: "menu", tabIndex: 0, ref: nt };
  return C$1({ ourProps: Mt, theirProps: ne, slot: xt, defaultTag: Ae, features: be, visible: it, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(A, B) {
  let L = I$5(), { id: V = `headlessui-menu-item-${L}`, disabled: J = !1, ...re } = A, [ne, ie] = C("Menu.Item"), pe = ne.activeItemIndex !== null ? ne.items[ne.activeItemIndex].id === V : !1, nt = useRef(null), oe = y$1(B, nt);
  l$5(() => {
    if (ne.__demoMode || ne.menuState !== 0 || !pe || ne.activationTrigger === 0) return;
    let qt = o$5();
    return qt.requestAnimationFrame(() => {
      var Dt, Xt;
      (Xt = (Dt = nt.current) == null ? void 0 : Dt.scrollIntoView) == null || Xt.call(Dt, { block: "nearest" });
    }), qt.dispose;
  }, [ne.__demoMode, nt, pe, ne.menuState, ne.activationTrigger, ne.activeItemIndex]);
  let Ce = s$2(nt), at = useRef({ disabled: J, domRef: nt, get textValue() {
    return Ce();
  } });
  l$5(() => {
    at.current.disabled = J;
  }, [at, J]), l$5(() => (ie({ type: 5, id: V, dataRef: at }), () => ie({ type: 6, id: V })), [at, V]);
  let it = o$6(() => {
    ie({ type: 1 });
  }), gt = o$6((qt) => {
    if (J) return qt.preventDefault();
    ie({ type: 1 }), D$3(ne.buttonRef.current);
  }), St = o$6(() => {
    if (J) return ie({ type: 2, focus: c$4.Nothing });
    ie({ type: 2, focus: c$4.Specific, id: V });
  }), xt = u$5(), Mt = o$6((qt) => xt.update(qt)), bt = o$6((qt) => {
    xt.wasMoved(qt) && (J || pe || ie({ type: 2, focus: c$4.Specific, id: V, trigger: 0 }));
  }), Tt = o$6((qt) => {
    xt.wasMoved(qt) && (J || pe && ie({ type: 2, focus: c$4.Nothing }));
  }), It = useMemo(() => ({ active: pe, disabled: J, close: it }), [pe, J, it]);
  return C$1({ ourProps: { id: V, ref: oe, role: "menuitem", tabIndex: J === !0 ? void 0 : -1, "aria-disabled": J === !0 ? !0 : void 0, disabled: void 0, onClick: gt, onFocus: St, onPointerEnter: Mt, onMouseEnter: Mt, onPointerMove: bt, onMouseMove: bt, onPointerLeave: Tt, onMouseLeave: Tt }, theirProps: re, slot: It, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c(A = 0) {
  let [B, L] = useState(A), V = f$5(), J = useCallback((pe) => {
    V.current && L((nt) => nt | pe);
  }, [B, V]), re = useCallback((pe) => !!(B & pe), [B]), ne = useCallback((pe) => {
    V.current && L((nt) => nt & ~pe);
  }, [L, V]), ie = useCallback((pe) => {
    V.current && L((nt) => nt ^ pe);
  }, [L]);
  return { flags: B, addFlag: J, hasFlag: re, removeFlag: ne, toggleFlag: ie };
}
function l(A) {
  let B = { called: !1 };
  return (...L) => {
    if (!B.called) return B.called = !0, A(...L);
  };
}
function g$2(A, ...B) {
  A && B.length > 0 && A.classList.add(...B);
}
function v(A, ...B) {
  A && B.length > 0 && A.classList.remove(...B);
}
function b(A, B) {
  let L = o$5();
  if (!A) return L.dispose;
  let { transitionDuration: V, transitionDelay: J } = getComputedStyle(A), [re, ne] = [V, J].map((pe) => {
    let [nt = 0] = pe.split(",").filter(Boolean).map((oe) => oe.includes("ms") ? parseFloat(oe) : parseFloat(oe) * 1e3).sort((oe, Ce) => Ce - oe);
    return nt;
  }), ie = re + ne;
  if (ie !== 0) {
    L.group((nt) => {
      nt.setTimeout(() => {
        B(), nt.dispose();
      }, ie), nt.addEventListener(A, "transitionrun", (oe) => {
        oe.target === oe.currentTarget && nt.dispose();
      });
    });
    let pe = L.addEventListener(A, "transitionend", (nt) => {
      nt.target === nt.currentTarget && (B(), pe());
    });
  } else B();
  return L.add(() => B()), L.dispose;
}
function M$1(A, B, L, V) {
  let J = L ? "enter" : "leave", re = o$5(), ne = V !== void 0 ? l(V) : () => {
  };
  J === "enter" && (A.removeAttribute("hidden"), A.style.display = "");
  let ie = u$7(J, { enter: () => B.enter, leave: () => B.leave }), pe = u$7(J, { enter: () => B.enterTo, leave: () => B.leaveTo }), nt = u$7(J, { enter: () => B.enterFrom, leave: () => B.leaveFrom });
  return v(A, ...B.base, ...B.enter, ...B.enterTo, ...B.enterFrom, ...B.leave, ...B.leaveFrom, ...B.leaveTo, ...B.entered), g$2(A, ...B.base, ...ie, ...nt), re.nextFrame(() => {
    v(A, ...B.base, ...ie, ...nt), g$2(A, ...B.base, ...ie, ...pe), b(A, () => (v(A, ...B.base, ...ie), g$2(A, ...B.base, ...B.entered), ne()));
  }), re.dispose;
}
function D({ immediate: A, container: B, direction: L, classes: V, onStart: J, onStop: re }) {
  let ne = f$5(), ie = p$3(), pe = s$a(L);
  l$5(() => {
    A && (pe.current = "enter");
  }, [A]), l$5(() => {
    let nt = o$5();
    ie.add(nt.dispose);
    let oe = B.current;
    if (oe && pe.current !== "idle" && ne.current) return nt.dispose(), J.current(pe.current), nt.add(M$1(oe, V.current, pe.current === "enter", () => {
      nt.dispose(), re.current(pe.current);
    })), nt.dispose;
  }, [L]);
}
function S(A = "") {
  return A.split(/\s+/).filter((B) => B.length > 1);
}
let I = createContext(null);
I.displayName = "TransitionContext";
var Se = ((A) => (A.Visible = "visible", A.Hidden = "hidden", A))(Se || {});
function ye() {
  let A = useContext(I);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
function xe() {
  let A = useContext(M);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(A) {
  return "children" in A ? U(A.children) : A.current.filter(({ el: B }) => B.current !== null).filter(({ state: B }) => B === "visible").length > 0;
}
function se(A, B) {
  let L = s$a(A), V = useRef([]), J = f$5(), re = p$3(), ne = o$6((it, gt = v$1.Hidden) => {
    let St = V.current.findIndex(({ el: xt }) => xt === it);
    St !== -1 && (u$7(gt, { [v$1.Unmount]() {
      V.current.splice(St, 1);
    }, [v$1.Hidden]() {
      V.current[St].state = "hidden";
    } }), re.microTask(() => {
      var xt;
      !U(V) && J.current && ((xt = L.current) == null || xt.call(L));
    }));
  }), ie = o$6((it) => {
    let gt = V.current.find(({ el: St }) => St === it);
    return gt ? gt.state !== "visible" && (gt.state = "visible") : V.current.push({ el: it, state: "visible" }), () => ne(it, v$1.Unmount);
  }), pe = useRef([]), nt = useRef(Promise.resolve()), oe = useRef({ enter: [], leave: [], idle: [] }), Ce = o$6((it, gt, St) => {
    pe.current.splice(0), B && (B.chains.current[gt] = B.chains.current[gt].filter(([xt]) => xt !== it)), B == null || B.chains.current[gt].push([it, new Promise((xt) => {
      pe.current.push(xt);
    })]), B == null || B.chains.current[gt].push([it, new Promise((xt) => {
      Promise.all(oe.current[gt].map(([Mt, bt]) => bt)).then(() => xt());
    })]), gt === "enter" ? nt.current = nt.current.then(() => B == null ? void 0 : B.wait.current).then(() => St(gt)) : St(gt);
  }), at = o$6((it, gt, St) => {
    Promise.all(oe.current[gt].splice(0).map(([xt, Mt]) => Mt)).then(() => {
      var xt;
      (xt = pe.current.shift()) == null || xt();
    }).then(() => St(gt));
  });
  return useMemo(() => ({ children: V, register: ie, unregister: ne, onStart: Ce, onStop: at, wait: nt, chains: oe }), [ie, ne, V, Ce, at, oe, nt]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(A) {
  var B;
  let L = {};
  for (let V of Pe) L[V] = (B = A[V]) != null ? B : Ne;
  return L;
}
function Re(A) {
  let B = useRef(ae(A));
  return useEffect(() => {
    B.current = ae(A);
  }, [A]), B;
}
let De = "div", le = O.RenderStrategy;
function He(A, B) {
  var L, V;
  let { beforeEnter: J, afterEnter: re, beforeLeave: ne, afterLeave: ie, enter: pe, enterFrom: nt, enterTo: oe, entered: Ce, leave: at, leaveFrom: it, leaveTo: gt, ...St } = A, xt = useRef(null), Mt = y$1(xt, B), bt = (L = St.unmount) == null || L ? v$1.Unmount : v$1.Hidden, { show: Tt, appear: It, initial: qt } = ye(), [Dt, Xt] = useState(Tt ? "visible" : "hidden"), Bt = xe(), { register: mt, unregister: Ot } = Bt;
  useEffect(() => mt(xt), [mt, xt]), useEffect(() => {
    if (bt === v$1.Hidden && xt.current) {
      if (Tt && Dt !== "visible") {
        Xt("visible");
        return;
      }
      return u$7(Dt, { hidden: () => Ot(xt), visible: () => mt(xt) });
    }
  }, [Dt, xt, mt, Ot, Tt, bt]);
  let wt = s$a({ base: S(St.className), enter: S(pe), enterFrom: S(nt), enterTo: S(oe), entered: S(Ce), leave: S(at), leaveFrom: S(it), leaveTo: S(gt) }), ke = Re({ beforeEnter: J, afterEnter: re, beforeLeave: ne, afterLeave: ie }), rt = l$4();
  useEffect(() => {
    if (rt && Dt === "visible" && xt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [xt, Dt, rt]);
  let ce = qt && !It, Oe = It && Tt && qt, ot = !rt || ce ? "idle" : Tt ? "enter" : "leave", ut = c(0), ht = o$6((Kt) => u$7(Kt, { enter: () => {
    ut.addFlag(d$3.Opening), ke.current.beforeEnter();
  }, leave: () => {
    ut.addFlag(d$3.Closing), ke.current.beforeLeave();
  }, idle: () => {
  } })), dt = o$6((Kt) => u$7(Kt, { enter: () => {
    ut.removeFlag(d$3.Opening), ke.current.afterEnter();
  }, leave: () => {
    ut.removeFlag(d$3.Closing), ke.current.afterLeave();
  }, idle: () => {
  } })), st = se(() => {
    Xt("hidden"), Ot(xt);
  }, Bt), yt = useRef(!1);
  D({ immediate: Oe, container: xt, classes: wt, direction: ot, onStart: s$a((Kt) => {
    yt.current = !0, st.onStart(xt, Kt, ht);
  }), onStop: s$a((Kt) => {
    yt.current = !1, st.onStop(xt, Kt, dt), Kt === "leave" && !U(st) && (Xt("hidden"), Ot(xt));
  }) });
  let ct = St, At = { ref: Mt };
  return Oe ? ct = { ...ct, className: t$4(St.className, ...wt.current.enter, ...wt.current.enterFrom) } : yt.current && (ct.className = t$4(St.className, (V = xt.current) == null ? void 0 : V.className), ct.className === "" && delete ct.className), C__default.createElement(M.Provider, { value: st }, C__default.createElement(s$6, { value: u$7(Dt, { visible: d$3.Open, hidden: d$3.Closed }) | ut.flags }, C$1({ ourProps: At, theirProps: ct, defaultTag: De, features: le, visible: Dt === "visible", name: "Transition.Child" })));
}
function Fe(A, B) {
  let { show: L, appear: V = !1, unmount: J = !0, ...re } = A, ne = useRef(null), ie = y$1(ne, B);
  l$4();
  let pe = u$3();
  if (L === void 0 && pe !== null && (L = (pe & d$3.Open) === d$3.Open), ![!0, !1].includes(L)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [nt, oe] = useState(L ? "visible" : "hidden"), Ce = se(() => {
    oe("hidden");
  }), [at, it] = useState(!0), gt = useRef([L]);
  l$5(() => {
    at !== !1 && gt.current[gt.current.length - 1] !== L && (gt.current.push(L), it(!1));
  }, [gt, L]);
  let St = useMemo(() => ({ show: L, appear: V, initial: at }), [L, V, at]);
  useEffect(() => {
    if (L) oe("visible");
    else if (!U(Ce)) oe("hidden");
    else {
      let Tt = ne.current;
      if (!Tt) return;
      let It = Tt.getBoundingClientRect();
      It.x === 0 && It.y === 0 && It.width === 0 && It.height === 0 && oe("hidden");
    }
  }, [L, Ce]);
  let xt = { unmount: J }, Mt = o$6(() => {
    var Tt;
    at && it(!1), (Tt = A.beforeEnter) == null || Tt.call(A);
  }), bt = o$6(() => {
    var Tt;
    at && it(!1), (Tt = A.beforeLeave) == null || Tt.call(A);
  });
  return C__default.createElement(M.Provider, { value: Ce }, C__default.createElement(I.Provider, { value: St }, C$1({ ourProps: { ...xt, as: Fragment, children: C__default.createElement(ue, { ref: ie, ...xt, ...re, beforeEnter: Mt, beforeLeave: bt }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: nt === "visible", name: "Transition" })));
}
function _e(A, B) {
  let L = useContext(I) !== null, V = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !L && V ? C__default.createElement(q, { ref: B, ...A }) : C__default.createElement(ue, { ref: B, ...A }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(A, B = 4, L = 5) {
  if (A.length <= B + L)
    return A;
  const V = A.slice(0, B), J = A.slice(A.length - L);
  return `${V}...${J}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: A,
  network: B,
  onViewProfile: L,
  onChangeWallet: V,
  onDisconnectWallet: J,
  renderAvatar: re
}) {
  const { wallet: ne } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    qe$1,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: ie }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            re ? re(A, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: A,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[ne],
                alt: `${ne} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(A) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[B] ?? B })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${ie ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => L == null ? void 0 : L(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(A) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => V == null ? void 0 : V(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => J == null ? void 0 : J(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: A,
  disabled: B
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: A,
      disabled: B,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var V = L === B ? 0 : 4 - L % 4;
  return [L, V];
}
function byteLength$1(A) {
  var B = getLens$1(A), L = B[0], V = B[1];
  return (L + V) * 3 / 4 - V;
}
function _byteLength$1(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray$1(A) {
  var B, L = getLens$1(A), V = L[0], J = L[1], re = new Arr$1(_byteLength$1(A, V, J)), ne = 0, ie = J > 0 ? V - 4 : V, pe;
  for (pe = 0; pe < ie; pe += 4)
    B = revLookup$1[A.charCodeAt(pe)] << 18 | revLookup$1[A.charCodeAt(pe + 1)] << 12 | revLookup$1[A.charCodeAt(pe + 2)] << 6 | revLookup$1[A.charCodeAt(pe + 3)], re[ne++] = B >> 16 & 255, re[ne++] = B >> 8 & 255, re[ne++] = B & 255;
  return J === 2 && (B = revLookup$1[A.charCodeAt(pe)] << 2 | revLookup$1[A.charCodeAt(pe + 1)] >> 4, re[ne++] = B & 255), J === 1 && (B = revLookup$1[A.charCodeAt(pe)] << 10 | revLookup$1[A.charCodeAt(pe + 1)] << 4 | revLookup$1[A.charCodeAt(pe + 2)] >> 2, re[ne++] = B >> 8 & 255, re[ne++] = B & 255), re;
}
function tripletToBase64$1(A) {
  return lookup$1[A >> 18 & 63] + lookup$1[A >> 12 & 63] + lookup$1[A >> 6 & 63] + lookup$1[A & 63];
}
function encodeChunk$1(A, B, L) {
  for (var V, J = [], re = B; re < L; re += 3)
    V = (A[re] << 16 & 16711680) + (A[re + 1] << 8 & 65280) + (A[re + 2] & 255), J.push(tripletToBase64$1(V));
  return J.join("");
}
function fromByteArray$1(A) {
  for (var B, L = A.length, V = L % 3, J = [], re = 16383, ne = 0, ie = L - V; ne < ie; ne += re)
    J.push(encodeChunk$1(A, ne, ne + re > ie ? ie : ne + re));
  return V === 1 ? (B = A[L - 1], J.push(
    lookup$1[B >> 2] + lookup$1[B << 4 & 63] + "=="
  )) : V === 2 && (B = (A[L - 2] << 8) + A[L - 1], J.push(
    lookup$1[B >> 10] + lookup$1[B >> 4 & 63] + lookup$1[B << 2 & 63] + "="
  )), J.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(A, B, L, V, J) {
  var re, ne, ie = J * 8 - V - 1, pe = (1 << ie) - 1, nt = pe >> 1, oe = -7, Ce = L ? J - 1 : 0, at = L ? -1 : 1, it = A[B + Ce];
  for (Ce += at, re = it & (1 << -oe) - 1, it >>= -oe, oe += ie; oe > 0; re = re * 256 + A[B + Ce], Ce += at, oe -= 8)
    ;
  for (ne = re & (1 << -oe) - 1, re >>= -oe, oe += V; oe > 0; ne = ne * 256 + A[B + Ce], Ce += at, oe -= 8)
    ;
  if (re === 0)
    re = 1 - nt;
  else {
    if (re === pe)
      return ne ? NaN : (it ? -1 : 1) * (1 / 0);
    ne = ne + Math.pow(2, V), re = re - nt;
  }
  return (it ? -1 : 1) * ne * Math.pow(2, re - V);
};
ieee754.write = function(A, B, L, V, J, re) {
  var ne, ie, pe, nt = re * 8 - J - 1, oe = (1 << nt) - 1, Ce = oe >> 1, at = J === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, it = V ? 0 : re - 1, gt = V ? 1 : -1, St = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
  for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (ie = isNaN(B) ? 1 : 0, ne = oe) : (ne = Math.floor(Math.log(B) / Math.LN2), B * (pe = Math.pow(2, -ne)) < 1 && (ne--, pe *= 2), ne + Ce >= 1 ? B += at / pe : B += at * Math.pow(2, 1 - Ce), B * pe >= 2 && (ne++, pe /= 2), ne + Ce >= oe ? (ie = 0, ne = oe) : ne + Ce >= 1 ? (ie = (B * pe - 1) * Math.pow(2, J), ne = ne + Ce) : (ie = B * Math.pow(2, Ce - 1) * Math.pow(2, J), ne = 0)); J >= 8; A[L + it] = ie & 255, it += gt, ie /= 256, J -= 8)
    ;
  for (ne = ne << J | ie, nt += J; nt > 0; A[L + it] = ne & 255, it += gt, ne /= 256, nt -= 8)
    ;
  A[L + it - gt] |= St * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(A) {
  const B = base64Js$1, L = ieee754, V = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  A.Buffer = oe, A.SlowBuffer = qt, A.INSPECT_MAX_BYTES = 50;
  const J = 2147483647;
  A.kMaxLength = J;
  const { Uint8Array: re, ArrayBuffer: ne, SharedArrayBuffer: ie } = globalThis;
  oe.TYPED_ARRAY_SUPPORT = pe(), !oe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function pe() {
    try {
      const Rt = new re(1), vt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(vt, re.prototype), Object.setPrototypeOf(Rt, vt), Rt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(oe.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (oe.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(oe.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (oe.isBuffer(this))
        return this.byteOffset;
    }
  });
  function nt(Rt) {
    if (Rt > J)
      throw new RangeError('The value "' + Rt + '" is invalid for option "size"');
    const vt = new re(Rt);
    return Object.setPrototypeOf(vt, oe.prototype), vt;
  }
  function oe(Rt, vt, $t) {
    if (typeof Rt == "number") {
      if (typeof vt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return gt(Rt);
    }
    return Ce(Rt, vt, $t);
  }
  oe.poolSize = 8192;
  function Ce(Rt, vt, $t) {
    if (typeof Rt == "string")
      return St(Rt, vt);
    if (ne.isView(Rt))
      return Mt(Rt);
    if (Rt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Rt
      );
    if (kr(Rt, ne) || Rt && kr(Rt.buffer, ne) || typeof ie < "u" && (kr(Rt, ie) || Rt && kr(Rt.buffer, ie)))
      return bt(Rt, vt, $t);
    if (typeof Rt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ut = Rt.valueOf && Rt.valueOf();
    if (Ut != null && Ut !== Rt)
      return oe.from(Ut, vt, $t);
    const Yt = Tt(Rt);
    if (Yt) return Yt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Rt[Symbol.toPrimitive] == "function")
      return oe.from(Rt[Symbol.toPrimitive]("string"), vt, $t);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Rt
    );
  }
  oe.from = function(Rt, vt, $t) {
    return Ce(Rt, vt, $t);
  }, Object.setPrototypeOf(oe.prototype, re.prototype), Object.setPrototypeOf(oe, re);
  function at(Rt) {
    if (typeof Rt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Rt < 0)
      throw new RangeError('The value "' + Rt + '" is invalid for option "size"');
  }
  function it(Rt, vt, $t) {
    return at(Rt), Rt <= 0 ? nt(Rt) : vt !== void 0 ? typeof $t == "string" ? nt(Rt).fill(vt, $t) : nt(Rt).fill(vt) : nt(Rt);
  }
  oe.alloc = function(Rt, vt, $t) {
    return it(Rt, vt, $t);
  };
  function gt(Rt) {
    return at(Rt), nt(Rt < 0 ? 0 : It(Rt) | 0);
  }
  oe.allocUnsafe = function(Rt) {
    return gt(Rt);
  }, oe.allocUnsafeSlow = function(Rt) {
    return gt(Rt);
  };
  function St(Rt, vt) {
    if ((typeof vt != "string" || vt === "") && (vt = "utf8"), !oe.isEncoding(vt))
      throw new TypeError("Unknown encoding: " + vt);
    const $t = Dt(Rt, vt) | 0;
    let Ut = nt($t);
    const Yt = Ut.write(Rt, vt);
    return Yt !== $t && (Ut = Ut.slice(0, Yt)), Ut;
  }
  function xt(Rt) {
    const vt = Rt.length < 0 ? 0 : It(Rt.length) | 0, $t = nt(vt);
    for (let Ut = 0; Ut < vt; Ut += 1)
      $t[Ut] = Rt[Ut] & 255;
    return $t;
  }
  function Mt(Rt) {
    if (kr(Rt, re)) {
      const vt = new re(Rt);
      return bt(vt.buffer, vt.byteOffset, vt.byteLength);
    }
    return xt(Rt);
  }
  function bt(Rt, vt, $t) {
    if (vt < 0 || Rt.byteLength < vt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Rt.byteLength < vt + ($t || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ut;
    return vt === void 0 && $t === void 0 ? Ut = new re(Rt) : $t === void 0 ? Ut = new re(Rt, vt) : Ut = new re(Rt, vt, $t), Object.setPrototypeOf(Ut, oe.prototype), Ut;
  }
  function Tt(Rt) {
    if (oe.isBuffer(Rt)) {
      const vt = It(Rt.length) | 0, $t = nt(vt);
      return $t.length === 0 || Rt.copy($t, 0, 0, vt), $t;
    }
    if (Rt.length !== void 0)
      return typeof Rt.length != "number" || Fr(Rt.length) ? nt(0) : xt(Rt);
    if (Rt.type === "Buffer" && Array.isArray(Rt.data))
      return xt(Rt.data);
  }
  function It(Rt) {
    if (Rt >= J)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + J.toString(16) + " bytes");
    return Rt | 0;
  }
  function qt(Rt) {
    return +Rt != Rt && (Rt = 0), oe.alloc(+Rt);
  }
  oe.isBuffer = function(vt) {
    return vt != null && vt._isBuffer === !0 && vt !== oe.prototype;
  }, oe.compare = function(vt, $t) {
    if (kr(vt, re) && (vt = oe.from(vt, vt.offset, vt.byteLength)), kr($t, re) && ($t = oe.from($t, $t.offset, $t.byteLength)), !oe.isBuffer(vt) || !oe.isBuffer($t))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (vt === $t) return 0;
    let Ut = vt.length, Yt = $t.length;
    for (let rr = 0, ir = Math.min(Ut, Yt); rr < ir; ++rr)
      if (vt[rr] !== $t[rr]) {
        Ut = vt[rr], Yt = $t[rr];
        break;
      }
    return Ut < Yt ? -1 : Yt < Ut ? 1 : 0;
  }, oe.isEncoding = function(vt) {
    switch (String(vt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, oe.concat = function(vt, $t) {
    if (!Array.isArray(vt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (vt.length === 0)
      return oe.alloc(0);
    let Ut;
    if ($t === void 0)
      for ($t = 0, Ut = 0; Ut < vt.length; ++Ut)
        $t += vt[Ut].length;
    const Yt = oe.allocUnsafe($t);
    let rr = 0;
    for (Ut = 0; Ut < vt.length; ++Ut) {
      let ir = vt[Ut];
      if (kr(ir, re))
        rr + ir.length > Yt.length ? (oe.isBuffer(ir) || (ir = oe.from(ir)), ir.copy(Yt, rr)) : re.prototype.set.call(
          Yt,
          ir,
          rr
        );
      else if (oe.isBuffer(ir))
        ir.copy(Yt, rr);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      rr += ir.length;
    }
    return Yt;
  };
  function Dt(Rt, vt) {
    if (oe.isBuffer(Rt))
      return Rt.length;
    if (ne.isView(Rt) || kr(Rt, ne))
      return Rt.byteLength;
    if (typeof Rt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Rt
      );
    const $t = Rt.length, Ut = arguments.length > 2 && arguments[2] === !0;
    if (!Ut && $t === 0) return 0;
    let Yt = !1;
    for (; ; )
      switch (vt) {
        case "ascii":
        case "latin1":
        case "binary":
          return $t;
        case "utf8":
        case "utf-8":
          return Nr(Rt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return $t * 2;
        case "hex":
          return $t >>> 1;
        case "base64":
          return Mr(Rt).length;
        default:
          if (Yt)
            return Ut ? -1 : Nr(Rt).length;
          vt = ("" + vt).toLowerCase(), Yt = !0;
      }
  }
  oe.byteLength = Dt;
  function Xt(Rt, vt, $t) {
    let Ut = !1;
    if ((vt === void 0 || vt < 0) && (vt = 0), vt > this.length || (($t === void 0 || $t > this.length) && ($t = this.length), $t <= 0) || ($t >>>= 0, vt >>>= 0, $t <= vt))
      return "";
    for (Rt || (Rt = "utf8"); ; )
      switch (Rt) {
        case "hex":
          return ct(this, vt, $t);
        case "utf8":
        case "utf-8":
          return ut(this, vt, $t);
        case "ascii":
          return st(this, vt, $t);
        case "latin1":
        case "binary":
          return yt(this, vt, $t);
        case "base64":
          return ot(this, vt, $t);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return At(this, vt, $t);
        default:
          if (Ut) throw new TypeError("Unknown encoding: " + Rt);
          Rt = (Rt + "").toLowerCase(), Ut = !0;
      }
  }
  oe.prototype._isBuffer = !0;
  function Bt(Rt, vt, $t) {
    const Ut = Rt[vt];
    Rt[vt] = Rt[$t], Rt[$t] = Ut;
  }
  oe.prototype.swap16 = function() {
    const vt = this.length;
    if (vt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let $t = 0; $t < vt; $t += 2)
      Bt(this, $t, $t + 1);
    return this;
  }, oe.prototype.swap32 = function() {
    const vt = this.length;
    if (vt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let $t = 0; $t < vt; $t += 4)
      Bt(this, $t, $t + 3), Bt(this, $t + 1, $t + 2);
    return this;
  }, oe.prototype.swap64 = function() {
    const vt = this.length;
    if (vt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let $t = 0; $t < vt; $t += 8)
      Bt(this, $t, $t + 7), Bt(this, $t + 1, $t + 6), Bt(this, $t + 2, $t + 5), Bt(this, $t + 3, $t + 4);
    return this;
  }, oe.prototype.toString = function() {
    const vt = this.length;
    return vt === 0 ? "" : arguments.length === 0 ? ut(this, 0, vt) : Xt.apply(this, arguments);
  }, oe.prototype.toLocaleString = oe.prototype.toString, oe.prototype.equals = function(vt) {
    if (!oe.isBuffer(vt)) throw new TypeError("Argument must be a Buffer");
    return this === vt ? !0 : oe.compare(this, vt) === 0;
  }, oe.prototype.inspect = function() {
    let vt = "";
    const $t = A.INSPECT_MAX_BYTES;
    return vt = this.toString("hex", 0, $t).replace(/(.{2})/g, "$1 ").trim(), this.length > $t && (vt += " ... "), "<Buffer " + vt + ">";
  }, V && (oe.prototype[V] = oe.prototype.inspect), oe.prototype.compare = function(vt, $t, Ut, Yt, rr) {
    if (kr(vt, re) && (vt = oe.from(vt, vt.offset, vt.byteLength)), !oe.isBuffer(vt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof vt
      );
    if ($t === void 0 && ($t = 0), Ut === void 0 && (Ut = vt ? vt.length : 0), Yt === void 0 && (Yt = 0), rr === void 0 && (rr = this.length), $t < 0 || Ut > vt.length || Yt < 0 || rr > this.length)
      throw new RangeError("out of range index");
    if (Yt >= rr && $t >= Ut)
      return 0;
    if (Yt >= rr)
      return -1;
    if ($t >= Ut)
      return 1;
    if ($t >>>= 0, Ut >>>= 0, Yt >>>= 0, rr >>>= 0, this === vt) return 0;
    let ir = rr - Yt, gr = Ut - $t;
    const Ir = Math.min(ir, gr), yr = this.slice(Yt, rr), Pr = vt.slice($t, Ut);
    for (let $r = 0; $r < Ir; ++$r)
      if (yr[$r] !== Pr[$r]) {
        ir = yr[$r], gr = Pr[$r];
        break;
      }
    return ir < gr ? -1 : gr < ir ? 1 : 0;
  };
  function mt(Rt, vt, $t, Ut, Yt) {
    if (Rt.length === 0) return -1;
    if (typeof $t == "string" ? (Ut = $t, $t = 0) : $t > 2147483647 ? $t = 2147483647 : $t < -2147483648 && ($t = -2147483648), $t = +$t, Fr($t) && ($t = Yt ? 0 : Rt.length - 1), $t < 0 && ($t = Rt.length + $t), $t >= Rt.length) {
      if (Yt) return -1;
      $t = Rt.length - 1;
    } else if ($t < 0)
      if (Yt) $t = 0;
      else return -1;
    if (typeof vt == "string" && (vt = oe.from(vt, Ut)), oe.isBuffer(vt))
      return vt.length === 0 ? -1 : Ot(Rt, vt, $t, Ut, Yt);
    if (typeof vt == "number")
      return vt = vt & 255, typeof re.prototype.indexOf == "function" ? Yt ? re.prototype.indexOf.call(Rt, vt, $t) : re.prototype.lastIndexOf.call(Rt, vt, $t) : Ot(Rt, [vt], $t, Ut, Yt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ot(Rt, vt, $t, Ut, Yt) {
    let rr = 1, ir = Rt.length, gr = vt.length;
    if (Ut !== void 0 && (Ut = String(Ut).toLowerCase(), Ut === "ucs2" || Ut === "ucs-2" || Ut === "utf16le" || Ut === "utf-16le")) {
      if (Rt.length < 2 || vt.length < 2)
        return -1;
      rr = 2, ir /= 2, gr /= 2, $t /= 2;
    }
    function Ir(Pr, $r) {
      return rr === 1 ? Pr[$r] : Pr.readUInt16BE($r * rr);
    }
    let yr;
    if (Yt) {
      let Pr = -1;
      for (yr = $t; yr < ir; yr++)
        if (Ir(Rt, yr) === Ir(vt, Pr === -1 ? 0 : yr - Pr)) {
          if (Pr === -1 && (Pr = yr), yr - Pr + 1 === gr) return Pr * rr;
        } else
          Pr !== -1 && (yr -= yr - Pr), Pr = -1;
    } else
      for ($t + gr > ir && ($t = ir - gr), yr = $t; yr >= 0; yr--) {
        let Pr = !0;
        for (let $r = 0; $r < gr; $r++)
          if (Ir(Rt, yr + $r) !== Ir(vt, $r)) {
            Pr = !1;
            break;
          }
        if (Pr) return yr;
      }
    return -1;
  }
  oe.prototype.includes = function(vt, $t, Ut) {
    return this.indexOf(vt, $t, Ut) !== -1;
  }, oe.prototype.indexOf = function(vt, $t, Ut) {
    return mt(this, vt, $t, Ut, !0);
  }, oe.prototype.lastIndexOf = function(vt, $t, Ut) {
    return mt(this, vt, $t, Ut, !1);
  };
  function wt(Rt, vt, $t, Ut) {
    $t = Number($t) || 0;
    const Yt = Rt.length - $t;
    Ut ? (Ut = Number(Ut), Ut > Yt && (Ut = Yt)) : Ut = Yt;
    const rr = vt.length;
    Ut > rr / 2 && (Ut = rr / 2);
    let ir;
    for (ir = 0; ir < Ut; ++ir) {
      const gr = parseInt(vt.substr(ir * 2, 2), 16);
      if (Fr(gr)) return ir;
      Rt[$t + ir] = gr;
    }
    return ir;
  }
  function ke(Rt, vt, $t, Ut) {
    return _r(Nr(vt, Rt.length - $t), Rt, $t, Ut);
  }
  function rt(Rt, vt, $t, Ut) {
    return _r(Br(vt), Rt, $t, Ut);
  }
  function ce(Rt, vt, $t, Ut) {
    return _r(Mr(vt), Rt, $t, Ut);
  }
  function Oe(Rt, vt, $t, Ut) {
    return _r(Tr(vt, Rt.length - $t), Rt, $t, Ut);
  }
  oe.prototype.write = function(vt, $t, Ut, Yt) {
    if ($t === void 0)
      Yt = "utf8", Ut = this.length, $t = 0;
    else if (Ut === void 0 && typeof $t == "string")
      Yt = $t, Ut = this.length, $t = 0;
    else if (isFinite($t))
      $t = $t >>> 0, isFinite(Ut) ? (Ut = Ut >>> 0, Yt === void 0 && (Yt = "utf8")) : (Yt = Ut, Ut = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const rr = this.length - $t;
    if ((Ut === void 0 || Ut > rr) && (Ut = rr), vt.length > 0 && (Ut < 0 || $t < 0) || $t > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Yt || (Yt = "utf8");
    let ir = !1;
    for (; ; )
      switch (Yt) {
        case "hex":
          return wt(this, vt, $t, Ut);
        case "utf8":
        case "utf-8":
          return ke(this, vt, $t, Ut);
        case "ascii":
        case "latin1":
        case "binary":
          return rt(this, vt, $t, Ut);
        case "base64":
          return ce(this, vt, $t, Ut);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Oe(this, vt, $t, Ut);
        default:
          if (ir) throw new TypeError("Unknown encoding: " + Yt);
          Yt = ("" + Yt).toLowerCase(), ir = !0;
      }
  }, oe.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ot(Rt, vt, $t) {
    return vt === 0 && $t === Rt.length ? B.fromByteArray(Rt) : B.fromByteArray(Rt.slice(vt, $t));
  }
  function ut(Rt, vt, $t) {
    $t = Math.min(Rt.length, $t);
    const Ut = [];
    let Yt = vt;
    for (; Yt < $t; ) {
      const rr = Rt[Yt];
      let ir = null, gr = rr > 239 ? 4 : rr > 223 ? 3 : rr > 191 ? 2 : 1;
      if (Yt + gr <= $t) {
        let Ir, yr, Pr, $r;
        switch (gr) {
          case 1:
            rr < 128 && (ir = rr);
            break;
          case 2:
            Ir = Rt[Yt + 1], (Ir & 192) === 128 && ($r = (rr & 31) << 6 | Ir & 63, $r > 127 && (ir = $r));
            break;
          case 3:
            Ir = Rt[Yt + 1], yr = Rt[Yt + 2], (Ir & 192) === 128 && (yr & 192) === 128 && ($r = (rr & 15) << 12 | (Ir & 63) << 6 | yr & 63, $r > 2047 && ($r < 55296 || $r > 57343) && (ir = $r));
            break;
          case 4:
            Ir = Rt[Yt + 1], yr = Rt[Yt + 2], Pr = Rt[Yt + 3], (Ir & 192) === 128 && (yr & 192) === 128 && (Pr & 192) === 128 && ($r = (rr & 15) << 18 | (Ir & 63) << 12 | (yr & 63) << 6 | Pr & 63, $r > 65535 && $r < 1114112 && (ir = $r));
        }
      }
      ir === null ? (ir = 65533, gr = 1) : ir > 65535 && (ir -= 65536, Ut.push(ir >>> 10 & 1023 | 55296), ir = 56320 | ir & 1023), Ut.push(ir), Yt += gr;
    }
    return dt(Ut);
  }
  const ht = 4096;
  function dt(Rt) {
    const vt = Rt.length;
    if (vt <= ht)
      return String.fromCharCode.apply(String, Rt);
    let $t = "", Ut = 0;
    for (; Ut < vt; )
      $t += String.fromCharCode.apply(
        String,
        Rt.slice(Ut, Ut += ht)
      );
    return $t;
  }
  function st(Rt, vt, $t) {
    let Ut = "";
    $t = Math.min(Rt.length, $t);
    for (let Yt = vt; Yt < $t; ++Yt)
      Ut += String.fromCharCode(Rt[Yt] & 127);
    return Ut;
  }
  function yt(Rt, vt, $t) {
    let Ut = "";
    $t = Math.min(Rt.length, $t);
    for (let Yt = vt; Yt < $t; ++Yt)
      Ut += String.fromCharCode(Rt[Yt]);
    return Ut;
  }
  function ct(Rt, vt, $t) {
    const Ut = Rt.length;
    (!vt || vt < 0) && (vt = 0), (!$t || $t < 0 || $t > Ut) && ($t = Ut);
    let Yt = "";
    for (let rr = vt; rr < $t; ++rr)
      Yt += Ar[Rt[rr]];
    return Yt;
  }
  function At(Rt, vt, $t) {
    const Ut = Rt.slice(vt, $t);
    let Yt = "";
    for (let rr = 0; rr < Ut.length - 1; rr += 2)
      Yt += String.fromCharCode(Ut[rr] + Ut[rr + 1] * 256);
    return Yt;
  }
  oe.prototype.slice = function(vt, $t) {
    const Ut = this.length;
    vt = ~~vt, $t = $t === void 0 ? Ut : ~~$t, vt < 0 ? (vt += Ut, vt < 0 && (vt = 0)) : vt > Ut && (vt = Ut), $t < 0 ? ($t += Ut, $t < 0 && ($t = 0)) : $t > Ut && ($t = Ut), $t < vt && ($t = vt);
    const Yt = this.subarray(vt, $t);
    return Object.setPrototypeOf(Yt, oe.prototype), Yt;
  };
  function Kt(Rt, vt, $t) {
    if (Rt % 1 !== 0 || Rt < 0) throw new RangeError("offset is not uint");
    if (Rt + vt > $t) throw new RangeError("Trying to access beyond buffer length");
  }
  oe.prototype.readUintLE = oe.prototype.readUIntLE = function(vt, $t, Ut) {
    vt = vt >>> 0, $t = $t >>> 0, Ut || Kt(vt, $t, this.length);
    let Yt = this[vt], rr = 1, ir = 0;
    for (; ++ir < $t && (rr *= 256); )
      Yt += this[vt + ir] * rr;
    return Yt;
  }, oe.prototype.readUintBE = oe.prototype.readUIntBE = function(vt, $t, Ut) {
    vt = vt >>> 0, $t = $t >>> 0, Ut || Kt(vt, $t, this.length);
    let Yt = this[vt + --$t], rr = 1;
    for (; $t > 0 && (rr *= 256); )
      Yt += this[vt + --$t] * rr;
    return Yt;
  }, oe.prototype.readUint8 = oe.prototype.readUInt8 = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 1, this.length), this[vt];
  }, oe.prototype.readUint16LE = oe.prototype.readUInt16LE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 2, this.length), this[vt] | this[vt + 1] << 8;
  }, oe.prototype.readUint16BE = oe.prototype.readUInt16BE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 2, this.length), this[vt] << 8 | this[vt + 1];
  }, oe.prototype.readUint32LE = oe.prototype.readUInt32LE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 4, this.length), (this[vt] | this[vt + 1] << 8 | this[vt + 2] << 16) + this[vt + 3] * 16777216;
  }, oe.prototype.readUint32BE = oe.prototype.readUInt32BE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 4, this.length), this[vt] * 16777216 + (this[vt + 1] << 16 | this[vt + 2] << 8 | this[vt + 3]);
  }, oe.prototype.readBigUInt64LE = Cr(function(vt) {
    vt = vt >>> 0, dr(vt, "offset");
    const $t = this[vt], Ut = this[vt + 7];
    ($t === void 0 || Ut === void 0) && br(vt, this.length - 8);
    const Yt = $t + this[++vt] * 2 ** 8 + this[++vt] * 2 ** 16 + this[++vt] * 2 ** 24, rr = this[++vt] + this[++vt] * 2 ** 8 + this[++vt] * 2 ** 16 + Ut * 2 ** 24;
    return BigInt(Yt) + (BigInt(rr) << BigInt(32));
  }), oe.prototype.readBigUInt64BE = Cr(function(vt) {
    vt = vt >>> 0, dr(vt, "offset");
    const $t = this[vt], Ut = this[vt + 7];
    ($t === void 0 || Ut === void 0) && br(vt, this.length - 8);
    const Yt = $t * 2 ** 24 + this[++vt] * 2 ** 16 + this[++vt] * 2 ** 8 + this[++vt], rr = this[++vt] * 2 ** 24 + this[++vt] * 2 ** 16 + this[++vt] * 2 ** 8 + Ut;
    return (BigInt(Yt) << BigInt(32)) + BigInt(rr);
  }), oe.prototype.readIntLE = function(vt, $t, Ut) {
    vt = vt >>> 0, $t = $t >>> 0, Ut || Kt(vt, $t, this.length);
    let Yt = this[vt], rr = 1, ir = 0;
    for (; ++ir < $t && (rr *= 256); )
      Yt += this[vt + ir] * rr;
    return rr *= 128, Yt >= rr && (Yt -= Math.pow(2, 8 * $t)), Yt;
  }, oe.prototype.readIntBE = function(vt, $t, Ut) {
    vt = vt >>> 0, $t = $t >>> 0, Ut || Kt(vt, $t, this.length);
    let Yt = $t, rr = 1, ir = this[vt + --Yt];
    for (; Yt > 0 && (rr *= 256); )
      ir += this[vt + --Yt] * rr;
    return rr *= 128, ir >= rr && (ir -= Math.pow(2, 8 * $t)), ir;
  }, oe.prototype.readInt8 = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 1, this.length), this[vt] & 128 ? (255 - this[vt] + 1) * -1 : this[vt];
  }, oe.prototype.readInt16LE = function(vt, $t) {
    vt = vt >>> 0, $t || Kt(vt, 2, this.length);
    const Ut = this[vt] | this[vt + 1] << 8;
    return Ut & 32768 ? Ut | 4294901760 : Ut;
  }, oe.prototype.readInt16BE = function(vt, $t) {
    vt = vt >>> 0, $t || Kt(vt, 2, this.length);
    const Ut = this[vt + 1] | this[vt] << 8;
    return Ut & 32768 ? Ut | 4294901760 : Ut;
  }, oe.prototype.readInt32LE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 4, this.length), this[vt] | this[vt + 1] << 8 | this[vt + 2] << 16 | this[vt + 3] << 24;
  }, oe.prototype.readInt32BE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 4, this.length), this[vt] << 24 | this[vt + 1] << 16 | this[vt + 2] << 8 | this[vt + 3];
  }, oe.prototype.readBigInt64LE = Cr(function(vt) {
    vt = vt >>> 0, dr(vt, "offset");
    const $t = this[vt], Ut = this[vt + 7];
    ($t === void 0 || Ut === void 0) && br(vt, this.length - 8);
    const Yt = this[vt + 4] + this[vt + 5] * 2 ** 8 + this[vt + 6] * 2 ** 16 + (Ut << 24);
    return (BigInt(Yt) << BigInt(32)) + BigInt($t + this[++vt] * 2 ** 8 + this[++vt] * 2 ** 16 + this[++vt] * 2 ** 24);
  }), oe.prototype.readBigInt64BE = Cr(function(vt) {
    vt = vt >>> 0, dr(vt, "offset");
    const $t = this[vt], Ut = this[vt + 7];
    ($t === void 0 || Ut === void 0) && br(vt, this.length - 8);
    const Yt = ($t << 24) + // Overflow
    this[++vt] * 2 ** 16 + this[++vt] * 2 ** 8 + this[++vt];
    return (BigInt(Yt) << BigInt(32)) + BigInt(this[++vt] * 2 ** 24 + this[++vt] * 2 ** 16 + this[++vt] * 2 ** 8 + Ut);
  }), oe.prototype.readFloatLE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 4, this.length), L.read(this, vt, !0, 23, 4);
  }, oe.prototype.readFloatBE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 4, this.length), L.read(this, vt, !1, 23, 4);
  }, oe.prototype.readDoubleLE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 8, this.length), L.read(this, vt, !0, 52, 8);
  }, oe.prototype.readDoubleBE = function(vt, $t) {
    return vt = vt >>> 0, $t || Kt(vt, 8, this.length), L.read(this, vt, !1, 52, 8);
  };
  function Zt(Rt, vt, $t, Ut, Yt, rr) {
    if (!oe.isBuffer(Rt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (vt > Yt || vt < rr) throw new RangeError('"value" argument is out of bounds');
    if ($t + Ut > Rt.length) throw new RangeError("Index out of range");
  }
  oe.prototype.writeUintLE = oe.prototype.writeUIntLE = function(vt, $t, Ut, Yt) {
    if (vt = +vt, $t = $t >>> 0, Ut = Ut >>> 0, !Yt) {
      const gr = Math.pow(2, 8 * Ut) - 1;
      Zt(this, vt, $t, Ut, gr, 0);
    }
    let rr = 1, ir = 0;
    for (this[$t] = vt & 255; ++ir < Ut && (rr *= 256); )
      this[$t + ir] = vt / rr & 255;
    return $t + Ut;
  }, oe.prototype.writeUintBE = oe.prototype.writeUIntBE = function(vt, $t, Ut, Yt) {
    if (vt = +vt, $t = $t >>> 0, Ut = Ut >>> 0, !Yt) {
      const gr = Math.pow(2, 8 * Ut) - 1;
      Zt(this, vt, $t, Ut, gr, 0);
    }
    let rr = Ut - 1, ir = 1;
    for (this[$t + rr] = vt & 255; --rr >= 0 && (ir *= 256); )
      this[$t + rr] = vt / ir & 255;
    return $t + Ut;
  }, oe.prototype.writeUint8 = oe.prototype.writeUInt8 = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 1, 255, 0), this[$t] = vt & 255, $t + 1;
  }, oe.prototype.writeUint16LE = oe.prototype.writeUInt16LE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 2, 65535, 0), this[$t] = vt & 255, this[$t + 1] = vt >>> 8, $t + 2;
  }, oe.prototype.writeUint16BE = oe.prototype.writeUInt16BE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 2, 65535, 0), this[$t] = vt >>> 8, this[$t + 1] = vt & 255, $t + 2;
  }, oe.prototype.writeUint32LE = oe.prototype.writeUInt32LE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 4, 4294967295, 0), this[$t + 3] = vt >>> 24, this[$t + 2] = vt >>> 16, this[$t + 1] = vt >>> 8, this[$t] = vt & 255, $t + 4;
  }, oe.prototype.writeUint32BE = oe.prototype.writeUInt32BE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 4, 4294967295, 0), this[$t] = vt >>> 24, this[$t + 1] = vt >>> 16, this[$t + 2] = vt >>> 8, this[$t + 3] = vt & 255, $t + 4;
  };
  function Ht(Rt, vt, $t, Ut, Yt) {
    cr(vt, Ut, Yt, Rt, $t, 7);
    let rr = Number(vt & BigInt(4294967295));
    Rt[$t++] = rr, rr = rr >> 8, Rt[$t++] = rr, rr = rr >> 8, Rt[$t++] = rr, rr = rr >> 8, Rt[$t++] = rr;
    let ir = Number(vt >> BigInt(32) & BigInt(4294967295));
    return Rt[$t++] = ir, ir = ir >> 8, Rt[$t++] = ir, ir = ir >> 8, Rt[$t++] = ir, ir = ir >> 8, Rt[$t++] = ir, $t;
  }
  function Pt(Rt, vt, $t, Ut, Yt) {
    cr(vt, Ut, Yt, Rt, $t, 7);
    let rr = Number(vt & BigInt(4294967295));
    Rt[$t + 7] = rr, rr = rr >> 8, Rt[$t + 6] = rr, rr = rr >> 8, Rt[$t + 5] = rr, rr = rr >> 8, Rt[$t + 4] = rr;
    let ir = Number(vt >> BigInt(32) & BigInt(4294967295));
    return Rt[$t + 3] = ir, ir = ir >> 8, Rt[$t + 2] = ir, ir = ir >> 8, Rt[$t + 1] = ir, ir = ir >> 8, Rt[$t] = ir, $t + 8;
  }
  oe.prototype.writeBigUInt64LE = Cr(function(vt, $t = 0) {
    return Ht(this, vt, $t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeBigUInt64BE = Cr(function(vt, $t = 0) {
    return Pt(this, vt, $t, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeIntLE = function(vt, $t, Ut, Yt) {
    if (vt = +vt, $t = $t >>> 0, !Yt) {
      const Ir = Math.pow(2, 8 * Ut - 1);
      Zt(this, vt, $t, Ut, Ir - 1, -Ir);
    }
    let rr = 0, ir = 1, gr = 0;
    for (this[$t] = vt & 255; ++rr < Ut && (ir *= 256); )
      vt < 0 && gr === 0 && this[$t + rr - 1] !== 0 && (gr = 1), this[$t + rr] = (vt / ir >> 0) - gr & 255;
    return $t + Ut;
  }, oe.prototype.writeIntBE = function(vt, $t, Ut, Yt) {
    if (vt = +vt, $t = $t >>> 0, !Yt) {
      const Ir = Math.pow(2, 8 * Ut - 1);
      Zt(this, vt, $t, Ut, Ir - 1, -Ir);
    }
    let rr = Ut - 1, ir = 1, gr = 0;
    for (this[$t + rr] = vt & 255; --rr >= 0 && (ir *= 256); )
      vt < 0 && gr === 0 && this[$t + rr + 1] !== 0 && (gr = 1), this[$t + rr] = (vt / ir >> 0) - gr & 255;
    return $t + Ut;
  }, oe.prototype.writeInt8 = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 1, 127, -128), vt < 0 && (vt = 255 + vt + 1), this[$t] = vt & 255, $t + 1;
  }, oe.prototype.writeInt16LE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 2, 32767, -32768), this[$t] = vt & 255, this[$t + 1] = vt >>> 8, $t + 2;
  }, oe.prototype.writeInt16BE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 2, 32767, -32768), this[$t] = vt >>> 8, this[$t + 1] = vt & 255, $t + 2;
  }, oe.prototype.writeInt32LE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 4, 2147483647, -2147483648), this[$t] = vt & 255, this[$t + 1] = vt >>> 8, this[$t + 2] = vt >>> 16, this[$t + 3] = vt >>> 24, $t + 4;
  }, oe.prototype.writeInt32BE = function(vt, $t, Ut) {
    return vt = +vt, $t = $t >>> 0, Ut || Zt(this, vt, $t, 4, 2147483647, -2147483648), vt < 0 && (vt = 4294967295 + vt + 1), this[$t] = vt >>> 24, this[$t + 1] = vt >>> 16, this[$t + 2] = vt >>> 8, this[$t + 3] = vt & 255, $t + 4;
  }, oe.prototype.writeBigInt64LE = Cr(function(vt, $t = 0) {
    return Ht(this, vt, $t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), oe.prototype.writeBigInt64BE = Cr(function(vt, $t = 0) {
    return Pt(this, vt, $t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function kt(Rt, vt, $t, Ut, Yt, rr) {
    if ($t + Ut > Rt.length) throw new RangeError("Index out of range");
    if ($t < 0) throw new RangeError("Index out of range");
  }
  function Vt(Rt, vt, $t, Ut, Yt) {
    return vt = +vt, $t = $t >>> 0, Yt || kt(Rt, vt, $t, 4), L.write(Rt, vt, $t, Ut, 23, 4), $t + 4;
  }
  oe.prototype.writeFloatLE = function(vt, $t, Ut) {
    return Vt(this, vt, $t, !0, Ut);
  }, oe.prototype.writeFloatBE = function(vt, $t, Ut) {
    return Vt(this, vt, $t, !1, Ut);
  };
  function tr(Rt, vt, $t, Ut, Yt) {
    return vt = +vt, $t = $t >>> 0, Yt || kt(Rt, vt, $t, 8), L.write(Rt, vt, $t, Ut, 52, 8), $t + 8;
  }
  oe.prototype.writeDoubleLE = function(vt, $t, Ut) {
    return tr(this, vt, $t, !0, Ut);
  }, oe.prototype.writeDoubleBE = function(vt, $t, Ut) {
    return tr(this, vt, $t, !1, Ut);
  }, oe.prototype.copy = function(vt, $t, Ut, Yt) {
    if (!oe.isBuffer(vt)) throw new TypeError("argument should be a Buffer");
    if (Ut || (Ut = 0), !Yt && Yt !== 0 && (Yt = this.length), $t >= vt.length && ($t = vt.length), $t || ($t = 0), Yt > 0 && Yt < Ut && (Yt = Ut), Yt === Ut || vt.length === 0 || this.length === 0) return 0;
    if ($t < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ut < 0 || Ut >= this.length) throw new RangeError("Index out of range");
    if (Yt < 0) throw new RangeError("sourceEnd out of bounds");
    Yt > this.length && (Yt = this.length), vt.length - $t < Yt - Ut && (Yt = vt.length - $t + Ut);
    const rr = Yt - Ut;
    return this === vt && typeof re.prototype.copyWithin == "function" ? this.copyWithin($t, Ut, Yt) : re.prototype.set.call(
      vt,
      this.subarray(Ut, Yt),
      $t
    ), rr;
  }, oe.prototype.fill = function(vt, $t, Ut, Yt) {
    if (typeof vt == "string") {
      if (typeof $t == "string" ? (Yt = $t, $t = 0, Ut = this.length) : typeof Ut == "string" && (Yt = Ut, Ut = this.length), Yt !== void 0 && typeof Yt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Yt == "string" && !oe.isEncoding(Yt))
        throw new TypeError("Unknown encoding: " + Yt);
      if (vt.length === 1) {
        const ir = vt.charCodeAt(0);
        (Yt === "utf8" && ir < 128 || Yt === "latin1") && (vt = ir);
      }
    } else typeof vt == "number" ? vt = vt & 255 : typeof vt == "boolean" && (vt = Number(vt));
    if ($t < 0 || this.length < $t || this.length < Ut)
      throw new RangeError("Out of range index");
    if (Ut <= $t)
      return this;
    $t = $t >>> 0, Ut = Ut === void 0 ? this.length : Ut >>> 0, vt || (vt = 0);
    let rr;
    if (typeof vt == "number")
      for (rr = $t; rr < Ut; ++rr)
        this[rr] = vt;
    else {
      const ir = oe.isBuffer(vt) ? vt : oe.from(vt, Yt), gr = ir.length;
      if (gr === 0)
        throw new TypeError('The value "' + vt + '" is invalid for argument "value"');
      for (rr = 0; rr < Ut - $t; ++rr)
        this[rr + $t] = ir[rr % gr];
    }
    return this;
  };
  const Nt = {};
  function Ft(Rt, vt, $t) {
    Nt[Rt] = class extends $t {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: vt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Rt}]`, this.stack, delete this.name;
      }
      get code() {
        return Rt;
      }
      set code(Yt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Yt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Rt}]: ${this.message}`;
      }
    };
  }
  Ft(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Rt) {
      return Rt ? `${Rt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Ft(
    "ERR_INVALID_ARG_TYPE",
    function(Rt, vt) {
      return `The "${Rt}" argument must be of type number. Received type ${typeof vt}`;
    },
    TypeError
  ), Ft(
    "ERR_OUT_OF_RANGE",
    function(Rt, vt, $t) {
      let Ut = `The value of "${Rt}" is out of range.`, Yt = $t;
      return Number.isInteger($t) && Math.abs($t) > 2 ** 32 ? Yt = er(String($t)) : typeof $t == "bigint" && (Yt = String($t), ($t > BigInt(2) ** BigInt(32) || $t < -(BigInt(2) ** BigInt(32))) && (Yt = er(Yt)), Yt += "n"), Ut += ` It must be ${vt}. Received ${Yt}`, Ut;
    },
    RangeError
  );
  function er(Rt) {
    let vt = "", $t = Rt.length;
    const Ut = Rt[0] === "-" ? 1 : 0;
    for (; $t >= Ut + 4; $t -= 3)
      vt = `_${Rt.slice($t - 3, $t)}${vt}`;
    return `${Rt.slice(0, $t)}${vt}`;
  }
  function fr(Rt, vt, $t) {
    dr(vt, "offset"), (Rt[vt] === void 0 || Rt[vt + $t] === void 0) && br(vt, Rt.length - ($t + 1));
  }
  function cr(Rt, vt, $t, Ut, Yt, rr) {
    if (Rt > $t || Rt < vt) {
      const ir = typeof vt == "bigint" ? "n" : "";
      let gr;
      throw vt === 0 || vt === BigInt(0) ? gr = `>= 0${ir} and < 2${ir} ** ${(rr + 1) * 8}${ir}` : gr = `>= -(2${ir} ** ${(rr + 1) * 8 - 1}${ir}) and < 2 ** ${(rr + 1) * 8 - 1}${ir}`, new Nt.ERR_OUT_OF_RANGE("value", gr, Rt);
    }
    fr(Ut, Yt, rr);
  }
  function dr(Rt, vt) {
    if (typeof Rt != "number")
      throw new Nt.ERR_INVALID_ARG_TYPE(vt, "number", Rt);
  }
  function br(Rt, vt, $t) {
    throw Math.floor(Rt) !== Rt ? (dr(Rt, $t), new Nt.ERR_OUT_OF_RANGE("offset", "an integer", Rt)) : vt < 0 ? new Nt.ERR_BUFFER_OUT_OF_BOUNDS() : new Nt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${vt}`,
      Rt
    );
  }
  const wr = /[^+/0-9A-Za-z-_]/g;
  function or(Rt) {
    if (Rt = Rt.split("=")[0], Rt = Rt.trim().replace(wr, ""), Rt.length < 2) return "";
    for (; Rt.length % 4 !== 0; )
      Rt = Rt + "=";
    return Rt;
  }
  function Nr(Rt, vt) {
    vt = vt || 1 / 0;
    let $t;
    const Ut = Rt.length;
    let Yt = null;
    const rr = [];
    for (let ir = 0; ir < Ut; ++ir) {
      if ($t = Rt.charCodeAt(ir), $t > 55295 && $t < 57344) {
        if (!Yt) {
          if ($t > 56319) {
            (vt -= 3) > -1 && rr.push(239, 191, 189);
            continue;
          } else if (ir + 1 === Ut) {
            (vt -= 3) > -1 && rr.push(239, 191, 189);
            continue;
          }
          Yt = $t;
          continue;
        }
        if ($t < 56320) {
          (vt -= 3) > -1 && rr.push(239, 191, 189), Yt = $t;
          continue;
        }
        $t = (Yt - 55296 << 10 | $t - 56320) + 65536;
      } else Yt && (vt -= 3) > -1 && rr.push(239, 191, 189);
      if (Yt = null, $t < 128) {
        if ((vt -= 1) < 0) break;
        rr.push($t);
      } else if ($t < 2048) {
        if ((vt -= 2) < 0) break;
        rr.push(
          $t >> 6 | 192,
          $t & 63 | 128
        );
      } else if ($t < 65536) {
        if ((vt -= 3) < 0) break;
        rr.push(
          $t >> 12 | 224,
          $t >> 6 & 63 | 128,
          $t & 63 | 128
        );
      } else if ($t < 1114112) {
        if ((vt -= 4) < 0) break;
        rr.push(
          $t >> 18 | 240,
          $t >> 12 & 63 | 128,
          $t >> 6 & 63 | 128,
          $t & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return rr;
  }
  function Br(Rt) {
    const vt = [];
    for (let $t = 0; $t < Rt.length; ++$t)
      vt.push(Rt.charCodeAt($t) & 255);
    return vt;
  }
  function Tr(Rt, vt) {
    let $t, Ut, Yt;
    const rr = [];
    for (let ir = 0; ir < Rt.length && !((vt -= 2) < 0); ++ir)
      $t = Rt.charCodeAt(ir), Ut = $t >> 8, Yt = $t % 256, rr.push(Yt), rr.push(Ut);
    return rr;
  }
  function Mr(Rt) {
    return B.toByteArray(or(Rt));
  }
  function _r(Rt, vt, $t, Ut) {
    let Yt;
    for (Yt = 0; Yt < Ut && !(Yt + $t >= vt.length || Yt >= Rt.length); ++Yt)
      vt[Yt + $t] = Rt[Yt];
    return Yt;
  }
  function kr(Rt, vt) {
    return Rt instanceof vt || Rt != null && Rt.constructor != null && Rt.constructor.name != null && Rt.constructor.name === vt.name;
  }
  function Fr(Rt) {
    return Rt !== Rt;
  }
  const Ar = function() {
    const Rt = "0123456789abcdef", vt = new Array(256);
    for (let $t = 0; $t < 16; ++$t) {
      const Ut = $t * 16;
      for (let Yt = 0; Yt < 16; ++Yt)
        vt[Ut + Yt] = Rt[$t] + Rt[Yt];
    }
    return vt;
  }();
  function Cr(Rt) {
    return typeof BigInt > "u" ? Dr : Rt;
  }
  function Dr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$E = buffer$1.Buffer;
var store2;
function getGlobalMessage(A) {
  return store2 == null ? void 0 : store2.get(A);
}
var store3;
function getSchemaMessage(A) {
  return store3 == null ? void 0 : store3.get(A);
}
var store4;
function getSpecificMessage(A, B) {
  var L;
  return (L = store4 == null ? void 0 : store4.get(A)) == null ? void 0 : L.get(B);
}
function _stringify(A) {
  var L, V;
  const B = typeof A;
  return B === "string" ? `"${A}"` : B === "number" || B === "bigint" || B === "boolean" ? `${A}` : B === "object" || B === "function" ? (A && ((V = (L = Object.getPrototypeOf(A)) == null ? void 0 : L.constructor) == null ? void 0 : V.name)) ?? "null" : B;
}
function _addIssue(A, B, L, V, J) {
  const re = J && "input" in J ? J.input : L.value, ne = (J == null ? void 0 : J.expected) ?? A.expects ?? null, ie = (J == null ? void 0 : J.received) ?? _stringify(re), pe = {
    kind: A.kind,
    type: A.type,
    input: re,
    expected: ne,
    received: ie,
    message: `Invalid ${B}: ${ne ? `Expected ${ne} but r` : "R"}eceived ${ie}`,
    requirement: A.requirement,
    path: J == null ? void 0 : J.path,
    issues: J == null ? void 0 : J.issues,
    lang: V.lang,
    abortEarly: V.abortEarly,
    abortPipeEarly: V.abortPipeEarly
  }, nt = A.kind === "schema", oe = (J == null ? void 0 : J.message) ?? A.message ?? getSpecificMessage(A.reference, pe.lang) ?? (nt ? getSchemaMessage(pe.lang) : null) ?? V.message ?? getGlobalMessage(pe.lang);
  oe && (pe.message = typeof oe == "function" ? (
    // @ts-expect-error
    oe(pe)
  ) : oe), nt && (L.typed = !1), L.issues ? L.issues.push(pe) : L.issues = [pe];
}
function _isValidObjectKey(A, B) {
  return Object.hasOwn(A, B) && B !== "__proto__" && B !== "prototype" && B !== "constructor";
}
function _joinExpects(A, B) {
  const L = [...new Set(A)];
  return L.length > 1 ? `(${L.join(` ${B} `)})` : L[0] ?? "never";
}
function check$e(A, B) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: A,
    message: B,
    _run(L, V) {
      return L.typed && !this.requirement(L.value) && _addIssue(this, "input", L, V), L;
    }
  };
}
function maxLength(A, B) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${A}`,
    requirement: A,
    message: B,
    _run(L, V) {
      return L.typed && L.value.length > this.requirement && _addIssue(this, "length", L, V, {
        received: `${L.value.length}`
      }), L;
    }
  };
}
function minLength(A, B) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${A}`,
    requirement: A,
    message: B,
    _run(L, V) {
      return L.typed && L.value.length < this.requirement && _addIssue(this, "length", L, V, {
        received: `${L.value.length}`
      }), L;
    }
  };
}
function getDefault(A, B, L) {
  return typeof A.default == "function" ? (
    // @ts-expect-error
    A.default(B, L)
  ) : (
    // @ts-expect-error
    A.default
  );
}
function array(A, B) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: A,
    message: B,
    _run(L, V) {
      var re;
      const J = L.value;
      if (Array.isArray(J)) {
        L.typed = !0, L.value = [];
        for (let ne = 0; ne < J.length; ne++) {
          const ie = J[ne], pe = this.item._run({ typed: !1, value: ie }, V);
          if (pe.issues) {
            const nt = {
              type: "array",
              origin: "value",
              input: J,
              key: ne,
              value: ie
            };
            for (const oe of pe.issues)
              oe.path ? oe.path.unshift(nt) : oe.path = [nt], (re = L.issues) == null || re.push(oe);
            if (L.issues || (L.issues = pe.issues), V.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          pe.typed || (L.typed = !1), L.value.push(pe.value);
        }
      } else
        _addIssue(this, "type", L, V);
      return L;
    }
  };
}
function boolean(A) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "boolean" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function enum_(A, B) {
  const L = Object.entries(A).filter(([V]) => isNaN(+V)).map(([, V]) => V);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(L.map(_stringify), "|"),
    async: !1,
    enum: A,
    options: L,
    message: B,
    _run(V, J) {
      return this.options.includes(V.value) ? V.typed = !0 : _addIssue(this, "type", V, J), V;
    }
  };
}
function literal(A, B) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(A),
    async: !1,
    literal: A,
    message: B,
    _run(L, V) {
      return L.value === this.literal ? L.typed = !0 : _addIssue(this, "type", L, V), L;
    }
  };
}
function looseObject(A, B) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, V) {
      var re;
      const J = L.value;
      if (J && typeof J == "object") {
        L.typed = !0, L.value = {};
        for (const ne in this.entries) {
          const ie = J[ne], pe = this.entries[ne]._run(
            { typed: !1, value: ie },
            V
          );
          if (pe.issues) {
            const nt = {
              type: "object",
              origin: "value",
              input: J,
              key: ne,
              value: ie
            };
            for (const oe of pe.issues)
              oe.path ? oe.path.unshift(nt) : oe.path = [nt], (re = L.issues) == null || re.push(oe);
            if (L.issues || (L.issues = pe.issues), V.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          pe.typed || (L.typed = !1), (pe.value !== void 0 || ne in J) && (L.value[ne] = pe.value);
        }
        if (!L.issues || !V.abortEarly)
          for (const ne in J)
            _isValidObjectKey(J, ne) && !(ne in this.entries) && (L.value[ne] = J[ne]);
      } else
        _addIssue(this, "type", L, V);
      return L;
    }
  };
}
function nonOptional(A, B) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: A,
    message: B,
    _run(L, V) {
      return L.value === void 0 ? (_addIssue(this, "type", L, V), L) : this.wrapped._run(L, V);
    }
  };
}
function null_(A) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === null ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function nullish(A, ...B) {
  const L = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${A.expects} | null | undefined)`,
    async: !1,
    wrapped: A,
    _run(V, J) {
      return (V.value === null || V.value === void 0) && ("default" in this && (V.value = getDefault(
        this,
        V,
        J
      )), V.value === null || V.value === void 0) ? (V.typed = !0, V) : this.wrapped._run(V, J);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function number(A) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "number" && !isNaN(B.value) ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function object(A, B) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, V) {
      var re;
      const J = L.value;
      if (J && typeof J == "object") {
        L.typed = !0, L.value = {};
        for (const ne in this.entries) {
          const ie = J[ne], pe = this.entries[ne]._run(
            { typed: !1, value: ie },
            V
          );
          if (pe.issues) {
            const nt = {
              type: "object",
              origin: "value",
              input: J,
              key: ne,
              value: ie
            };
            for (const oe of pe.issues)
              oe.path ? oe.path.unshift(nt) : oe.path = [nt], (re = L.issues) == null || re.push(oe);
            if (L.issues || (L.issues = pe.issues), V.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          pe.typed || (L.typed = !1), (pe.value !== void 0 || ne in J) && (L.value[ne] = pe.value);
        }
      } else
        _addIssue(this, "type", L, V);
      return L;
    }
  };
}
function optional(A, ...B) {
  const L = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${A.expects} | undefined)`,
    async: !1,
    wrapped: A,
    _run(V, J) {
      return V.value === void 0 && ("default" in this && (V.value = getDefault(
        this,
        V,
        J
      )), V.value === void 0) ? (V.typed = !0, V) : this.wrapped._run(V, J);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function picklist(A, B) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(A.map(_stringify), "|"),
    async: !1,
    options: A,
    message: B,
    _run(L, V) {
      return this.options.includes(L.value) ? L.typed = !0 : _addIssue(this, "type", L, V), L;
    }
  };
}
function record(A, B, L) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: A,
    value: B,
    message: L,
    _run(V, J) {
      var ne, ie;
      const re = V.value;
      if (re && typeof re == "object") {
        V.typed = !0, V.value = {};
        for (const pe in re)
          if (_isValidObjectKey(re, pe)) {
            const nt = re[pe], oe = this.key._run(
              { typed: !1, value: pe },
              J
            );
            if (oe.issues) {
              const at = {
                type: "object",
                origin: "key",
                input: re,
                key: pe,
                value: nt
              };
              for (const it of oe.issues)
                it.path = [at], (ne = V.issues) == null || ne.push(it);
              if (V.issues || (V.issues = oe.issues), J.abortEarly) {
                V.typed = !1;
                break;
              }
            }
            const Ce = this.value._run(
              { typed: !1, value: nt },
              J
            );
            if (Ce.issues) {
              const at = {
                type: "object",
                origin: "value",
                input: re,
                key: pe,
                value: nt
              };
              for (const it of Ce.issues)
                it.path ? it.path.unshift(at) : it.path = [at], (ie = V.issues) == null || ie.push(it);
              if (V.issues || (V.issues = Ce.issues), J.abortEarly) {
                V.typed = !1;
                break;
              }
            }
            (!oe.typed || !Ce.typed) && (V.typed = !1), oe.typed && (V.value[oe.value] = Ce.value);
          }
      } else
        _addIssue(this, "type", V, J);
      return V;
    }
  };
}
function string(A) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "string" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function _subIssues(A) {
  let B;
  if (A)
    for (const L of A)
      B ? B.push(...L.issues) : B = L.issues;
  return B;
}
function union(A, B) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      A.map((L) => L.expects),
      "|"
    ),
    async: !1,
    options: A,
    message: B,
    _run(L, V) {
      let J, re, ne;
      for (const ie of this.options) {
        const pe = ie._run(
          { typed: !1, value: L.value },
          V
        );
        if (pe.typed)
          if (pe.issues)
            re ? re.push(pe) : re = [pe];
          else {
            J = pe;
            break;
          }
        else
          ne ? ne.push(pe) : ne = [pe];
      }
      if (J)
        return J;
      if (re) {
        if (re.length === 1)
          return re[0];
        _addIssue(this, "type", L, V, {
          issues: _subIssues(re)
        }), L.typed = !0;
      } else {
        if ((ne == null ? void 0 : ne.length) === 1)
          return ne[0];
        _addIssue(this, "type", L, V, {
          issues: _subIssues(ne)
        });
      }
      return L;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(A) {
      return A.typed = !0, A;
    }
  };
}
function variant(A, B, L) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: A,
    options: B,
    message: L,
    _run(V, J) {
      const re = V.value;
      if (re && typeof re == "object") {
        let ne, ie = 0, pe = this.key, nt = [];
        const oe = (Ce, at) => {
          for (const it of Ce.options) {
            if (it.type === "variant")
              oe(it, new Set(at).add(it.key));
            else {
              let gt = !0, St = 0;
              for (const xt of at) {
                if (it.entries[xt]._run(
                  // @ts-expect-error
                  { typed: !1, value: re[xt] },
                  J
                ).issues) {
                  gt = !1, pe !== xt && (ie < St || ie === St && xt in re && !(pe in re)) && (ie = St, pe = xt, nt = []), pe === xt && nt.push(
                    it.entries[xt].expects
                  );
                  break;
                }
                St++;
              }
              if (gt) {
                const xt = it._run(
                  { typed: !1, value: re },
                  J
                );
                (!ne || !ne.typed && xt.typed) && (ne = xt);
              }
            }
            if (ne && !ne.issues)
              break;
          }
        };
        if (oe(this, /* @__PURE__ */ new Set([this.key])), ne)
          return ne;
        _addIssue(this, "type", V, J, {
          // @ts-expect-error
          input: re[pe],
          expected: _joinExpects(nt, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: re,
              key: pe,
              // @ts-expect-error
              value: re[pe]
            }
          ]
        });
      } else
        _addIssue(this, "type", V, J);
      return V;
    }
  };
}
function omit(A, B) {
  const L = {
    ...A.entries
  };
  for (const V of B)
    delete L[V];
  return { ...A, entries: L };
}
function pipe(...A) {
  return {
    ...A[0],
    pipe: A,
    _run(B, L) {
      for (const V of A)
        if (V.kind !== "metadata") {
          if (B.issues && (V.kind === "schema" || V.kind === "transformation")) {
            B.typed = !1;
            break;
          }
          (!B.issues || !L.abortEarly && !L.abortPipeEarly) && (B = V._run(B, L));
        }
      return B;
    }
  };
}
function unwrap(A) {
  return A.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var V = L === B ? 0 : 4 - L % 4;
  return [L, V];
}
function byteLength(A) {
  var B = getLens(A), L = B[0], V = B[1];
  return (L + V) * 3 / 4 - V;
}
function _byteLength(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray(A) {
  var B, L = getLens(A), V = L[0], J = L[1], re = new Arr(_byteLength(A, V, J)), ne = 0, ie = J > 0 ? V - 4 : V, pe;
  for (pe = 0; pe < ie; pe += 4)
    B = revLookup[A.charCodeAt(pe)] << 18 | revLookup[A.charCodeAt(pe + 1)] << 12 | revLookup[A.charCodeAt(pe + 2)] << 6 | revLookup[A.charCodeAt(pe + 3)], re[ne++] = B >> 16 & 255, re[ne++] = B >> 8 & 255, re[ne++] = B & 255;
  return J === 2 && (B = revLookup[A.charCodeAt(pe)] << 2 | revLookup[A.charCodeAt(pe + 1)] >> 4, re[ne++] = B & 255), J === 1 && (B = revLookup[A.charCodeAt(pe)] << 10 | revLookup[A.charCodeAt(pe + 1)] << 4 | revLookup[A.charCodeAt(pe + 2)] >> 2, re[ne++] = B >> 8 & 255, re[ne++] = B & 255), re;
}
function tripletToBase64(A) {
  return lookup[A >> 18 & 63] + lookup[A >> 12 & 63] + lookup[A >> 6 & 63] + lookup[A & 63];
}
function encodeChunk(A, B, L) {
  for (var V, J = [], re = B; re < L; re += 3)
    V = (A[re] << 16 & 16711680) + (A[re + 1] << 8 & 65280) + (A[re + 2] & 255), J.push(tripletToBase64(V));
  return J.join("");
}
function fromByteArray(A) {
  for (var B, L = A.length, V = L % 3, J = [], re = 16383, ne = 0, ie = L - V; ne < ie; ne += re)
    J.push(encodeChunk(A, ne, ne + re > ie ? ie : ne + re));
  return V === 1 ? (B = A[L - 1], J.push(
    lookup[B >> 2] + lookup[B << 4 & 63] + "=="
  )) : V === 2 && (B = (A[L - 2] << 8) + A[L - 1], J.push(
    lookup[B >> 10] + lookup[B >> 4 & 63] + lookup[B << 2 & 63] + "="
  )), J.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(A) {
  return `${A}${"=".repeat(4 - (A.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(A) {
  return A.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(A) {
  return pad(A).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(A) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(A)));
}
base64Url.encode = encode$j;
function decode$j(A) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(A))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(A) {
  if (!Number.isSafeInteger(A) || A < 0)
    throw new Error("positive integer expected, got " + A);
}
function isBytes(A) {
  return A instanceof Uint8Array || ArrayBuffer.isView(A) && A.constructor.name === "Uint8Array";
}
function abytes(A, ...B) {
  if (!isBytes(A))
    throw new Error("Uint8Array expected");
  if (B.length > 0 && !B.includes(A.length))
    throw new Error("Uint8Array expected of length " + B + ", got length=" + A.length);
}
function ahash(A) {
  if (typeof A != "function" || typeof A.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(A.outputLen), anumber(A.blockLen);
}
function aexists(A, B = !0) {
  if (A.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (B && A.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(A, B) {
  abytes(A);
  const L = B.outputLen;
  if (A.length < L)
    throw new Error("digestInto() expects output buffer of length at least " + L);
}
var utils$p = {}, crypto$4 = {};
Object.defineProperty(crypto$4, "__esModule", { value: !0 });
crypto$4.crypto = void 0;
crypto$4.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(A) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.Hash = A.nextTick = A.byteSwapIfBE = A.isLE = void 0, A.isBytes = V, A.u8 = J, A.u32 = re, A.createView = ne, A.rotr = ie, A.rotl = pe, A.byteSwap = nt, A.byteSwap32 = oe, A.bytesToHex = at, A.hexToBytes = St, A.asyncLoop = Mt, A.utf8ToBytes = bt, A.toBytes = Tt, A.concatBytes = It, A.checkOpts = Dt, A.wrapConstructor = Xt, A.wrapConstructorWithOpts = Bt, A.wrapXOFConstructorWithOpts = mt, A.randomBytes = Ot;
  const B = crypto$4, L = _assert;
  function V(wt) {
    return wt instanceof Uint8Array || ArrayBuffer.isView(wt) && wt.constructor.name === "Uint8Array";
  }
  function J(wt) {
    return new Uint8Array(wt.buffer, wt.byteOffset, wt.byteLength);
  }
  function re(wt) {
    return new Uint32Array(wt.buffer, wt.byteOffset, Math.floor(wt.byteLength / 4));
  }
  function ne(wt) {
    return new DataView(wt.buffer, wt.byteOffset, wt.byteLength);
  }
  function ie(wt, ke) {
    return wt << 32 - ke | wt >>> ke;
  }
  function pe(wt, ke) {
    return wt << ke | wt >>> 32 - ke >>> 0;
  }
  A.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function nt(wt) {
    return wt << 24 & 4278190080 | wt << 8 & 16711680 | wt >>> 8 & 65280 | wt >>> 24 & 255;
  }
  A.byteSwapIfBE = A.isLE ? (wt) => wt : (wt) => nt(wt);
  function oe(wt) {
    for (let ke = 0; ke < wt.length; ke++)
      wt[ke] = nt(wt[ke]);
  }
  const Ce = /* @__PURE__ */ Array.from({ length: 256 }, (wt, ke) => ke.toString(16).padStart(2, "0"));
  function at(wt) {
    (0, L.abytes)(wt);
    let ke = "";
    for (let rt = 0; rt < wt.length; rt++)
      ke += Ce[wt[rt]];
    return ke;
  }
  const it = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function gt(wt) {
    if (wt >= it._0 && wt <= it._9)
      return wt - it._0;
    if (wt >= it.A && wt <= it.F)
      return wt - (it.A - 10);
    if (wt >= it.a && wt <= it.f)
      return wt - (it.a - 10);
  }
  function St(wt) {
    if (typeof wt != "string")
      throw new Error("hex string expected, got " + typeof wt);
    const ke = wt.length, rt = ke / 2;
    if (ke % 2)
      throw new Error("hex string expected, got unpadded hex of length " + ke);
    const ce = new Uint8Array(rt);
    for (let Oe = 0, ot = 0; Oe < rt; Oe++, ot += 2) {
      const ut = gt(wt.charCodeAt(ot)), ht = gt(wt.charCodeAt(ot + 1));
      if (ut === void 0 || ht === void 0) {
        const dt = wt[ot] + wt[ot + 1];
        throw new Error('hex string expected, got non-hex character "' + dt + '" at index ' + ot);
      }
      ce[Oe] = ut * 16 + ht;
    }
    return ce;
  }
  const xt = async () => {
  };
  A.nextTick = xt;
  async function Mt(wt, ke, rt) {
    let ce = Date.now();
    for (let Oe = 0; Oe < wt; Oe++) {
      rt(Oe);
      const ot = Date.now() - ce;
      ot >= 0 && ot < ke || (await (0, A.nextTick)(), ce += ot);
    }
  }
  function bt(wt) {
    if (typeof wt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof wt);
    return new Uint8Array(new TextEncoder().encode(wt));
  }
  function Tt(wt) {
    return typeof wt == "string" && (wt = bt(wt)), (0, L.abytes)(wt), wt;
  }
  function It(...wt) {
    let ke = 0;
    for (let ce = 0; ce < wt.length; ce++) {
      const Oe = wt[ce];
      (0, L.abytes)(Oe), ke += Oe.length;
    }
    const rt = new Uint8Array(ke);
    for (let ce = 0, Oe = 0; ce < wt.length; ce++) {
      const ot = wt[ce];
      rt.set(ot, Oe), Oe += ot.length;
    }
    return rt;
  }
  class qt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  A.Hash = qt;
  function Dt(wt, ke) {
    if (ke !== void 0 && {}.toString.call(ke) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(wt, ke);
  }
  function Xt(wt) {
    const ke = (ce) => wt().update(Tt(ce)).digest(), rt = wt();
    return ke.outputLen = rt.outputLen, ke.blockLen = rt.blockLen, ke.create = () => wt(), ke;
  }
  function Bt(wt) {
    const ke = (ce, Oe) => wt(Oe).update(Tt(ce)).digest(), rt = wt({});
    return ke.outputLen = rt.outputLen, ke.blockLen = rt.blockLen, ke.create = (ce) => wt(ce), ke;
  }
  function mt(wt) {
    const ke = (ce, Oe) => wt(Oe).update(Tt(ce)).digest(), rt = wt({});
    return ke.outputLen = rt.outputLen, ke.blockLen = rt.blockLen, ke.create = (ce) => wt(ce), ke;
  }
  function Ot(wt = 32) {
    if (B.crypto && typeof B.crypto.getRandomValues == "function")
      return B.crypto.getRandomValues(new Uint8Array(wt));
    if (B.crypto && typeof B.crypto.randomBytes == "function")
      return B.crypto.randomBytes(wt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$p);
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.hmac = A.HMAC = void 0;
  const B = _assert, L = utils$p;
  class V extends L.Hash {
    constructor(ne, ie) {
      super(), this.finished = !1, this.destroyed = !1, (0, B.ahash)(ne);
      const pe = (0, L.toBytes)(ie);
      if (this.iHash = ne.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const nt = this.blockLen, oe = new Uint8Array(nt);
      oe.set(pe.length > nt ? ne.create().update(pe).digest() : pe);
      for (let Ce = 0; Ce < oe.length; Ce++)
        oe[Ce] ^= 54;
      this.iHash.update(oe), this.oHash = ne.create();
      for (let Ce = 0; Ce < oe.length; Ce++)
        oe[Ce] ^= 106;
      this.oHash.update(oe), oe.fill(0);
    }
    update(ne) {
      return (0, B.aexists)(this), this.iHash.update(ne), this;
    }
    digestInto(ne) {
      (0, B.aexists)(this), (0, B.abytes)(ne, this.outputLen), this.finished = !0, this.iHash.digestInto(ne), this.oHash.update(ne), this.oHash.digestInto(ne), this.destroy();
    }
    digest() {
      const ne = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(ne), ne;
    }
    _cloneInto(ne) {
      ne || (ne = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ie, iHash: pe, finished: nt, destroyed: oe, blockLen: Ce, outputLen: at } = this;
      return ne = ne, ne.finished = nt, ne.destroyed = oe, ne.blockLen = Ce, ne.outputLen = at, ne.oHash = ie._cloneInto(ne.oHash), ne.iHash = pe._cloneInto(ne.iHash), ne;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  A.HMAC = V;
  const J = (re, ne, ie) => new V(re, ne).update(ie).digest();
  A.hmac = J, A.hmac.create = (re, ne) => new V(re, ne);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$p;
function setBigUint64(A, B, L, V) {
  if (typeof A.setBigUint64 == "function")
    return A.setBigUint64(B, L, V);
  const J = BigInt(32), re = BigInt(4294967295), ne = Number(L >> J & re), ie = Number(L & re), pe = V ? 4 : 0, nt = V ? 0 : 4;
  A.setUint32(B + pe, ne, V), A.setUint32(B + nt, ie, V);
}
function Chi(A, B, L) {
  return A & B ^ ~A & L;
}
function Maj(A, B, L) {
  return A & B ^ A & L ^ B & L;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(B, L, V, J) {
    super(), this.blockLen = B, this.outputLen = L, this.padOffset = V, this.isLE = J, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(B), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(B) {
    (0, _assert_js_1.aexists)(this);
    const { view: L, buffer: V, blockLen: J } = this;
    B = (0, utils_js_1$3.toBytes)(B);
    const re = B.length;
    for (let ne = 0; ne < re; ) {
      const ie = Math.min(J - this.pos, re - ne);
      if (ie === J) {
        const pe = (0, utils_js_1$3.createView)(B);
        for (; J <= re - ne; ne += J)
          this.process(pe, ne);
        continue;
      }
      V.set(B.subarray(ne, ne + ie), this.pos), this.pos += ie, ne += ie, this.pos === J && (this.process(L, 0), this.pos = 0);
    }
    return this.length += B.length, this.roundClean(), this;
  }
  digestInto(B) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(B, this), this.finished = !0;
    const { buffer: L, view: V, blockLen: J, isLE: re } = this;
    let { pos: ne } = this;
    L[ne++] = 128, this.buffer.subarray(ne).fill(0), this.padOffset > J - ne && (this.process(V, 0), ne = 0);
    for (let Ce = ne; Ce < J; Ce++)
      L[Ce] = 0;
    setBigUint64(V, J - 8, BigInt(this.length * 8), re), this.process(V, 0);
    const ie = (0, utils_js_1$3.createView)(B), pe = this.outputLen;
    if (pe % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const nt = pe / 4, oe = this.get();
    if (nt > oe.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ce = 0; Ce < nt; Ce++)
      ie.setUint32(4 * Ce, oe[Ce], re);
  }
  digest() {
    const { buffer: B, outputLen: L } = this;
    this.digestInto(B);
    const V = B.slice(0, L);
    return this.destroy(), V;
  }
  _cloneInto(B) {
    B || (B = new this.constructor()), B.set(...this.get());
    const { blockLen: L, buffer: V, length: J, finished: re, destroyed: ne, pos: ie } = this;
    return B.length = J, B.pos = ie, B.finished = re, B.destroyed = ne, J % L && B.buffer.set(V), B;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$p, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
let SHA256$2 = class extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: B, B: L, C: V, D: J, E: re, F: ne, G: ie, H: pe } = this;
    return [B, L, V, J, re, ne, ie, pe];
  }
  // prettier-ignore
  set(B, L, V, J, re, ne, ie, pe) {
    this.A = B | 0, this.B = L | 0, this.C = V | 0, this.D = J | 0, this.E = re | 0, this.F = ne | 0, this.G = ie | 0, this.H = pe | 0;
  }
  process(B, L) {
    for (let Ce = 0; Ce < 16; Ce++, L += 4)
      SHA256_W[Ce] = B.getUint32(L, !1);
    for (let Ce = 16; Ce < 64; Ce++) {
      const at = SHA256_W[Ce - 15], it = SHA256_W[Ce - 2], gt = (0, utils_js_1$2.rotr)(at, 7) ^ (0, utils_js_1$2.rotr)(at, 18) ^ at >>> 3, St = (0, utils_js_1$2.rotr)(it, 17) ^ (0, utils_js_1$2.rotr)(it, 19) ^ it >>> 10;
      SHA256_W[Ce] = St + SHA256_W[Ce - 7] + gt + SHA256_W[Ce - 16] | 0;
    }
    let { A: V, B: J, C: re, D: ne, E: ie, F: pe, G: nt, H: oe } = this;
    for (let Ce = 0; Ce < 64; Ce++) {
      const at = (0, utils_js_1$2.rotr)(ie, 6) ^ (0, utils_js_1$2.rotr)(ie, 11) ^ (0, utils_js_1$2.rotr)(ie, 25), it = oe + at + (0, _md_js_1$2.Chi)(ie, pe, nt) + SHA256_K[Ce] + SHA256_W[Ce] | 0, St = ((0, utils_js_1$2.rotr)(V, 2) ^ (0, utils_js_1$2.rotr)(V, 13) ^ (0, utils_js_1$2.rotr)(V, 22)) + (0, _md_js_1$2.Maj)(V, J, re) | 0;
      oe = nt, nt = pe, pe = ie, ie = ne + it | 0, ne = re, re = J, J = V, V = it + St | 0;
    }
    V = V + this.A | 0, J = J + this.B | 0, re = re + this.C | 0, ne = ne + this.D | 0, ie = ie + this.E | 0, pe = pe + this.F | 0, nt = nt + this.G | 0, oe = oe + this.H | 0, this.set(V, J, re, ne, ie, pe, nt, oe);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
sha256$4.SHA256 = SHA256$2;
let SHA224$1 = class extends SHA256$2 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256$2());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224$1());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$2 = { exports: {} }, dist$1 = {};
(function(A) {
  Object.defineProperties(A, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  var B = {}, L = {};
  L.byteLength = oe, L.toByteArray = at, L.fromByteArray = St;
  for (var V = [], J = [], re = typeof Uint8Array < "u" ? Uint8Array : Array, ne = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ie = 0, pe = ne.length; ie < pe; ++ie)
    V[ie] = ne[ie], J[ne.charCodeAt(ie)] = ie;
  J[45] = 62, J[95] = 63;
  function nt(bt) {
    var Tt = bt.length;
    if (Tt % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var It = bt.indexOf("=");
    It === -1 && (It = Tt);
    var qt = It === Tt ? 0 : 4 - It % 4;
    return [It, qt];
  }
  function oe(bt) {
    var Tt = nt(bt), It = Tt[0], qt = Tt[1];
    return (It + qt) * 3 / 4 - qt;
  }
  function Ce(bt, Tt, It) {
    return (Tt + It) * 3 / 4 - It;
  }
  function at(bt) {
    var Tt, It = nt(bt), qt = It[0], Dt = It[1], Xt = new re(Ce(bt, qt, Dt)), Bt = 0, mt = Dt > 0 ? qt - 4 : qt, Ot;
    for (Ot = 0; Ot < mt; Ot += 4)
      Tt = J[bt.charCodeAt(Ot)] << 18 | J[bt.charCodeAt(Ot + 1)] << 12 | J[bt.charCodeAt(Ot + 2)] << 6 | J[bt.charCodeAt(Ot + 3)], Xt[Bt++] = Tt >> 16 & 255, Xt[Bt++] = Tt >> 8 & 255, Xt[Bt++] = Tt & 255;
    return Dt === 2 && (Tt = J[bt.charCodeAt(Ot)] << 2 | J[bt.charCodeAt(Ot + 1)] >> 4, Xt[Bt++] = Tt & 255), Dt === 1 && (Tt = J[bt.charCodeAt(Ot)] << 10 | J[bt.charCodeAt(Ot + 1)] << 4 | J[bt.charCodeAt(Ot + 2)] >> 2, Xt[Bt++] = Tt >> 8 & 255, Xt[Bt++] = Tt & 255), Xt;
  }
  function it(bt) {
    return V[bt >> 18 & 63] + V[bt >> 12 & 63] + V[bt >> 6 & 63] + V[bt & 63];
  }
  function gt(bt, Tt, It) {
    for (var qt, Dt = [], Xt = Tt; Xt < It; Xt += 3)
      qt = (bt[Xt] << 16 & 16711680) + (bt[Xt + 1] << 8 & 65280) + (bt[Xt + 2] & 255), Dt.push(it(qt));
    return Dt.join("");
  }
  function St(bt) {
    for (var Tt, It = bt.length, qt = It % 3, Dt = [], Xt = 16383, Bt = 0, mt = It - qt; Bt < mt; Bt += Xt)
      Dt.push(gt(bt, Bt, Bt + Xt > mt ? mt : Bt + Xt));
    return qt === 1 ? (Tt = bt[It - 1], Dt.push(
      V[Tt >> 2] + V[Tt << 4 & 63] + "=="
    )) : qt === 2 && (Tt = (bt[It - 2] << 8) + bt[It - 1], Dt.push(
      V[Tt >> 10] + V[Tt >> 4 & 63] + V[Tt << 2 & 63] + "="
    )), Dt.join("");
  }
  var xt = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  xt.read = function(bt, Tt, It, qt, Dt) {
    var Xt, Bt, mt = Dt * 8 - qt - 1, Ot = (1 << mt) - 1, wt = Ot >> 1, ke = -7, rt = It ? Dt - 1 : 0, ce = It ? -1 : 1, Oe = bt[Tt + rt];
    for (rt += ce, Xt = Oe & (1 << -ke) - 1, Oe >>= -ke, ke += mt; ke > 0; Xt = Xt * 256 + bt[Tt + rt], rt += ce, ke -= 8)
      ;
    for (Bt = Xt & (1 << -ke) - 1, Xt >>= -ke, ke += qt; ke > 0; Bt = Bt * 256 + bt[Tt + rt], rt += ce, ke -= 8)
      ;
    if (Xt === 0)
      Xt = 1 - wt;
    else {
      if (Xt === Ot)
        return Bt ? NaN : (Oe ? -1 : 1) * (1 / 0);
      Bt = Bt + Math.pow(2, qt), Xt = Xt - wt;
    }
    return (Oe ? -1 : 1) * Bt * Math.pow(2, Xt - qt);
  }, xt.write = function(bt, Tt, It, qt, Dt, Xt) {
    var Bt, mt, Ot, wt = Xt * 8 - Dt - 1, ke = (1 << wt) - 1, rt = ke >> 1, ce = Dt === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Oe = qt ? 0 : Xt - 1, ot = qt ? 1 : -1, ut = Tt < 0 || Tt === 0 && 1 / Tt < 0 ? 1 : 0;
    for (Tt = Math.abs(Tt), isNaN(Tt) || Tt === 1 / 0 ? (mt = isNaN(Tt) ? 1 : 0, Bt = ke) : (Bt = Math.floor(Math.log(Tt) / Math.LN2), Tt * (Ot = Math.pow(2, -Bt)) < 1 && (Bt--, Ot *= 2), Bt + rt >= 1 ? Tt += ce / Ot : Tt += ce * Math.pow(2, 1 - rt), Tt * Ot >= 2 && (Bt++, Ot /= 2), Bt + rt >= ke ? (mt = 0, Bt = ke) : Bt + rt >= 1 ? (mt = (Tt * Ot - 1) * Math.pow(2, Dt), Bt = Bt + rt) : (mt = Tt * Math.pow(2, rt - 1) * Math.pow(2, Dt), Bt = 0)); Dt >= 8; bt[It + Oe] = mt & 255, Oe += ot, mt /= 256, Dt -= 8)
      ;
    for (Bt = Bt << Dt | mt, wt += Dt; wt > 0; bt[It + Oe] = Bt & 255, Oe += ot, Bt /= 256, wt -= 8)
      ;
    bt[It + Oe - ot] |= ut * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(bt) {
    const Tt = L, It = xt, qt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    bt.Buffer = ke, bt.SlowBuffer = At, bt.INSPECT_MAX_BYTES = 50;
    const Dt = 2147483647;
    bt.kMaxLength = Dt;
    const { Uint8Array: Xt, ArrayBuffer: Bt, SharedArrayBuffer: mt } = globalThis;
    ke.TYPED_ARRAY_SUPPORT = Ot(), !ke.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function Ot() {
      try {
        const Et = new Xt(1), lt = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(lt, Xt.prototype), Object.setPrototypeOf(Et, lt), Et.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(ke.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (ke.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(ke.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (ke.isBuffer(this))
          return this.byteOffset;
      }
    });
    function wt(Et) {
      if (Et > Dt)
        throw new RangeError('The value "' + Et + '" is invalid for option "size"');
      const lt = new Xt(Et);
      return Object.setPrototypeOf(lt, ke.prototype), lt;
    }
    function ke(Et, lt, pt) {
      if (typeof Et == "number") {
        if (typeof lt == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return ot(Et);
      }
      return rt(Et, lt, pt);
    }
    ke.poolSize = 8192;
    function rt(Et, lt, pt) {
      if (typeof Et == "string")
        return ut(Et, lt);
      if (Bt.isView(Et))
        return dt(Et);
      if (Et == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Et
        );
      if (Or(Et, Bt) || Et && Or(Et.buffer, Bt) || typeof mt < "u" && (Or(Et, mt) || Et && Or(Et.buffer, mt)))
        return st(Et, lt, pt);
      if (typeof Et == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const Ct = Et.valueOf && Et.valueOf();
      if (Ct != null && Ct !== Et)
        return ke.from(Ct, lt, pt);
      const Wt = yt(Et);
      if (Wt) return Wt;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Et[Symbol.toPrimitive] == "function")
        return ke.from(Et[Symbol.toPrimitive]("string"), lt, pt);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Et
      );
    }
    ke.from = function(Et, lt, pt) {
      return rt(Et, lt, pt);
    }, Object.setPrototypeOf(ke.prototype, Xt.prototype), Object.setPrototypeOf(ke, Xt);
    function ce(Et) {
      if (typeof Et != "number")
        throw new TypeError('"size" argument must be of type number');
      if (Et < 0)
        throw new RangeError('The value "' + Et + '" is invalid for option "size"');
    }
    function Oe(Et, lt, pt) {
      return ce(Et), Et <= 0 ? wt(Et) : lt !== void 0 ? typeof pt == "string" ? wt(Et).fill(lt, pt) : wt(Et).fill(lt) : wt(Et);
    }
    ke.alloc = function(Et, lt, pt) {
      return Oe(Et, lt, pt);
    };
    function ot(Et) {
      return ce(Et), wt(Et < 0 ? 0 : ct(Et) | 0);
    }
    ke.allocUnsafe = function(Et) {
      return ot(Et);
    }, ke.allocUnsafeSlow = function(Et) {
      return ot(Et);
    };
    function ut(Et, lt) {
      if ((typeof lt != "string" || lt === "") && (lt = "utf8"), !ke.isEncoding(lt))
        throw new TypeError("Unknown encoding: " + lt);
      const pt = Kt(Et, lt) | 0;
      let Ct = wt(pt);
      const Wt = Ct.write(Et, lt);
      return Wt !== pt && (Ct = Ct.slice(0, Wt)), Ct;
    }
    function ht(Et) {
      const lt = Et.length < 0 ? 0 : ct(Et.length) | 0, pt = wt(lt);
      for (let Ct = 0; Ct < lt; Ct += 1)
        pt[Ct] = Et[Ct] & 255;
      return pt;
    }
    function dt(Et) {
      if (Or(Et, Xt)) {
        const lt = new Xt(Et);
        return st(lt.buffer, lt.byteOffset, lt.byteLength);
      }
      return ht(Et);
    }
    function st(Et, lt, pt) {
      if (lt < 0 || Et.byteLength < lt)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (Et.byteLength < lt + (pt || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let Ct;
      return lt === void 0 && pt === void 0 ? Ct = new Xt(Et) : pt === void 0 ? Ct = new Xt(Et, lt) : Ct = new Xt(Et, lt, pt), Object.setPrototypeOf(Ct, ke.prototype), Ct;
    }
    function yt(Et) {
      if (ke.isBuffer(Et)) {
        const lt = ct(Et.length) | 0, pt = wt(lt);
        return pt.length === 0 || Et.copy(pt, 0, 0, lt), pt;
      }
      if (Et.length !== void 0)
        return typeof Et.length != "number" || Ur(Et.length) ? wt(0) : ht(Et);
      if (Et.type === "Buffer" && Array.isArray(Et.data))
        return ht(Et.data);
    }
    function ct(Et) {
      if (Et >= Dt)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Dt.toString(16) + " bytes");
      return Et | 0;
    }
    function At(Et) {
      return +Et != Et && (Et = 0), ke.alloc(+Et);
    }
    ke.isBuffer = function(lt) {
      return lt != null && lt._isBuffer === !0 && lt !== ke.prototype;
    }, ke.compare = function(lt, pt) {
      if (Or(lt, Xt) && (lt = ke.from(lt, lt.offset, lt.byteLength)), Or(pt, Xt) && (pt = ke.from(pt, pt.offset, pt.byteLength)), !ke.isBuffer(lt) || !ke.isBuffer(pt))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (lt === pt) return 0;
      let Ct = lt.length, Wt = pt.length;
      for (let Jt = 0, Qt = Math.min(Ct, Wt); Jt < Qt; ++Jt)
        if (lt[Jt] !== pt[Jt]) {
          Ct = lt[Jt], Wt = pt[Jt];
          break;
        }
      return Ct < Wt ? -1 : Wt < Ct ? 1 : 0;
    }, ke.isEncoding = function(lt) {
      switch (String(lt).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, ke.concat = function(lt, pt) {
      if (!Array.isArray(lt))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (lt.length === 0)
        return ke.alloc(0);
      let Ct;
      if (pt === void 0)
        for (pt = 0, Ct = 0; Ct < lt.length; ++Ct)
          pt += lt[Ct].length;
      const Wt = ke.allocUnsafe(pt);
      let Jt = 0;
      for (Ct = 0; Ct < lt.length; ++Ct) {
        let Qt = lt[Ct];
        if (Or(Qt, Xt))
          Jt + Qt.length > Wt.length ? (ke.isBuffer(Qt) || (Qt = ke.from(Qt)), Qt.copy(Wt, Jt)) : Xt.prototype.set.call(
            Wt,
            Qt,
            Jt
          );
        else if (ke.isBuffer(Qt))
          Qt.copy(Wt, Jt);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Jt += Qt.length;
      }
      return Wt;
    };
    function Kt(Et, lt) {
      if (ke.isBuffer(Et))
        return Et.length;
      if (Bt.isView(Et) || Or(Et, Bt))
        return Et.byteLength;
      if (typeof Et != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Et
        );
      const pt = Et.length, Ct = arguments.length > 2 && arguments[2] === !0;
      if (!Ct && pt === 0) return 0;
      let Wt = !1;
      for (; ; )
        switch (lt) {
          case "ascii":
          case "latin1":
          case "binary":
            return pt;
          case "utf8":
          case "utf-8":
            return Ir(Et).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return pt * 2;
          case "hex":
            return pt >>> 1;
          case "base64":
            return $r(Et).length;
          default:
            if (Wt)
              return Ct ? -1 : Ir(Et).length;
            lt = ("" + lt).toLowerCase(), Wt = !0;
        }
    }
    ke.byteLength = Kt;
    function Zt(Et, lt, pt) {
      let Ct = !1;
      if ((lt === void 0 || lt < 0) && (lt = 0), lt > this.length || ((pt === void 0 || pt > this.length) && (pt = this.length), pt <= 0) || (pt >>>= 0, lt >>>= 0, pt <= lt))
        return "";
      for (Et || (Et = "utf8"); ; )
        switch (Et) {
          case "hex":
            return Nr(this, lt, pt);
          case "utf8":
          case "utf-8":
            return cr(this, lt, pt);
          case "ascii":
            return wr(this, lt, pt);
          case "latin1":
          case "binary":
            return or(this, lt, pt);
          case "base64":
            return fr(this, lt, pt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Br(this, lt, pt);
          default:
            if (Ct) throw new TypeError("Unknown encoding: " + Et);
            Et = (Et + "").toLowerCase(), Ct = !0;
        }
    }
    ke.prototype._isBuffer = !0;
    function Ht(Et, lt, pt) {
      const Ct = Et[lt];
      Et[lt] = Et[pt], Et[pt] = Ct;
    }
    ke.prototype.swap16 = function() {
      const lt = this.length;
      if (lt % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let pt = 0; pt < lt; pt += 2)
        Ht(this, pt, pt + 1);
      return this;
    }, ke.prototype.swap32 = function() {
      const lt = this.length;
      if (lt % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let pt = 0; pt < lt; pt += 4)
        Ht(this, pt, pt + 3), Ht(this, pt + 1, pt + 2);
      return this;
    }, ke.prototype.swap64 = function() {
      const lt = this.length;
      if (lt % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let pt = 0; pt < lt; pt += 8)
        Ht(this, pt, pt + 7), Ht(this, pt + 1, pt + 6), Ht(this, pt + 2, pt + 5), Ht(this, pt + 3, pt + 4);
      return this;
    }, ke.prototype.toString = function() {
      const lt = this.length;
      return lt === 0 ? "" : arguments.length === 0 ? cr(this, 0, lt) : Zt.apply(this, arguments);
    }, ke.prototype.toLocaleString = ke.prototype.toString, ke.prototype.equals = function(lt) {
      if (!ke.isBuffer(lt)) throw new TypeError("Argument must be a Buffer");
      return this === lt ? !0 : ke.compare(this, lt) === 0;
    }, ke.prototype.inspect = function() {
      let lt = "";
      const pt = bt.INSPECT_MAX_BYTES;
      return lt = this.toString("hex", 0, pt).replace(/(.{2})/g, "$1 ").trim(), this.length > pt && (lt += " ... "), "<Buffer " + lt + ">";
    }, qt && (ke.prototype[qt] = ke.prototype.inspect), ke.prototype.compare = function(lt, pt, Ct, Wt, Jt) {
      if (Or(lt, Xt) && (lt = ke.from(lt, lt.offset, lt.byteLength)), !ke.isBuffer(lt))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof lt
        );
      if (pt === void 0 && (pt = 0), Ct === void 0 && (Ct = lt ? lt.length : 0), Wt === void 0 && (Wt = 0), Jt === void 0 && (Jt = this.length), pt < 0 || Ct > lt.length || Wt < 0 || Jt > this.length)
        throw new RangeError("out of range index");
      if (Wt >= Jt && pt >= Ct)
        return 0;
      if (Wt >= Jt)
        return -1;
      if (pt >= Ct)
        return 1;
      if (pt >>>= 0, Ct >>>= 0, Wt >>>= 0, Jt >>>= 0, this === lt) return 0;
      let Qt = Jt - Wt, ur = Ct - pt;
      const pr = Math.min(Qt, ur), jt = this.slice(Wt, Jt), nr = lt.slice(pt, Ct);
      for (let ar = 0; ar < pr; ++ar)
        if (jt[ar] !== nr[ar]) {
          Qt = jt[ar], ur = nr[ar];
          break;
        }
      return Qt < ur ? -1 : ur < Qt ? 1 : 0;
    };
    function Pt(Et, lt, pt, Ct, Wt) {
      if (Et.length === 0) return -1;
      if (typeof pt == "string" ? (Ct = pt, pt = 0) : pt > 2147483647 ? pt = 2147483647 : pt < -2147483648 && (pt = -2147483648), pt = +pt, Ur(pt) && (pt = Wt ? 0 : Et.length - 1), pt < 0 && (pt = Et.length + pt), pt >= Et.length) {
        if (Wt) return -1;
        pt = Et.length - 1;
      } else if (pt < 0)
        if (Wt) pt = 0;
        else return -1;
      if (typeof lt == "string" && (lt = ke.from(lt, Ct)), ke.isBuffer(lt))
        return lt.length === 0 ? -1 : kt(Et, lt, pt, Ct, Wt);
      if (typeof lt == "number")
        return lt = lt & 255, typeof Xt.prototype.indexOf == "function" ? Wt ? Xt.prototype.indexOf.call(Et, lt, pt) : Xt.prototype.lastIndexOf.call(Et, lt, pt) : kt(Et, [lt], pt, Ct, Wt);
      throw new TypeError("val must be string, number or Buffer");
    }
    function kt(Et, lt, pt, Ct, Wt) {
      let Jt = 1, Qt = Et.length, ur = lt.length;
      if (Ct !== void 0 && (Ct = String(Ct).toLowerCase(), Ct === "ucs2" || Ct === "ucs-2" || Ct === "utf16le" || Ct === "utf-16le")) {
        if (Et.length < 2 || lt.length < 2)
          return -1;
        Jt = 2, Qt /= 2, ur /= 2, pt /= 2;
      }
      function pr(nr, ar) {
        return Jt === 1 ? nr[ar] : nr.readUInt16BE(ar * Jt);
      }
      let jt;
      if (Wt) {
        let nr = -1;
        for (jt = pt; jt < Qt; jt++)
          if (pr(Et, jt) === pr(lt, nr === -1 ? 0 : jt - nr)) {
            if (nr === -1 && (nr = jt), jt - nr + 1 === ur) return nr * Jt;
          } else
            nr !== -1 && (jt -= jt - nr), nr = -1;
      } else
        for (pt + ur > Qt && (pt = Qt - ur), jt = pt; jt >= 0; jt--) {
          let nr = !0;
          for (let ar = 0; ar < ur; ar++)
            if (pr(Et, jt + ar) !== pr(lt, ar)) {
              nr = !1;
              break;
            }
          if (nr) return jt;
        }
      return -1;
    }
    ke.prototype.includes = function(lt, pt, Ct) {
      return this.indexOf(lt, pt, Ct) !== -1;
    }, ke.prototype.indexOf = function(lt, pt, Ct) {
      return Pt(this, lt, pt, Ct, !0);
    }, ke.prototype.lastIndexOf = function(lt, pt, Ct) {
      return Pt(this, lt, pt, Ct, !1);
    };
    function Vt(Et, lt, pt, Ct) {
      pt = Number(pt) || 0;
      const Wt = Et.length - pt;
      Ct ? (Ct = Number(Ct), Ct > Wt && (Ct = Wt)) : Ct = Wt;
      const Jt = lt.length;
      Ct > Jt / 2 && (Ct = Jt / 2);
      let Qt;
      for (Qt = 0; Qt < Ct; ++Qt) {
        const ur = parseInt(lt.substr(Qt * 2, 2), 16);
        if (Ur(ur)) return Qt;
        Et[pt + Qt] = ur;
      }
      return Qt;
    }
    function tr(Et, lt, pt, Ct) {
      return Er(Ir(lt, Et.length - pt), Et, pt, Ct);
    }
    function Nt(Et, lt, pt, Ct) {
      return Er(yr(lt), Et, pt, Ct);
    }
    function Ft(Et, lt, pt, Ct) {
      return Er($r(lt), Et, pt, Ct);
    }
    function er(Et, lt, pt, Ct) {
      return Er(Pr(lt, Et.length - pt), Et, pt, Ct);
    }
    ke.prototype.write = function(lt, pt, Ct, Wt) {
      if (pt === void 0)
        Wt = "utf8", Ct = this.length, pt = 0;
      else if (Ct === void 0 && typeof pt == "string")
        Wt = pt, Ct = this.length, pt = 0;
      else if (isFinite(pt))
        pt = pt >>> 0, isFinite(Ct) ? (Ct = Ct >>> 0, Wt === void 0 && (Wt = "utf8")) : (Wt = Ct, Ct = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const Jt = this.length - pt;
      if ((Ct === void 0 || Ct > Jt) && (Ct = Jt), lt.length > 0 && (Ct < 0 || pt < 0) || pt > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      Wt || (Wt = "utf8");
      let Qt = !1;
      for (; ; )
        switch (Wt) {
          case "hex":
            return Vt(this, lt, pt, Ct);
          case "utf8":
          case "utf-8":
            return tr(this, lt, pt, Ct);
          case "ascii":
          case "latin1":
          case "binary":
            return Nt(this, lt, pt, Ct);
          case "base64":
            return Ft(this, lt, pt, Ct);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return er(this, lt, pt, Ct);
          default:
            if (Qt) throw new TypeError("Unknown encoding: " + Wt);
            Wt = ("" + Wt).toLowerCase(), Qt = !0;
        }
    }, ke.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function fr(Et, lt, pt) {
      return lt === 0 && pt === Et.length ? Tt.fromByteArray(Et) : Tt.fromByteArray(Et.slice(lt, pt));
    }
    function cr(Et, lt, pt) {
      pt = Math.min(Et.length, pt);
      const Ct = [];
      let Wt = lt;
      for (; Wt < pt; ) {
        const Jt = Et[Wt];
        let Qt = null, ur = Jt > 239 ? 4 : Jt > 223 ? 3 : Jt > 191 ? 2 : 1;
        if (Wt + ur <= pt) {
          let pr, jt, nr, ar;
          switch (ur) {
            case 1:
              Jt < 128 && (Qt = Jt);
              break;
            case 2:
              pr = Et[Wt + 1], (pr & 192) === 128 && (ar = (Jt & 31) << 6 | pr & 63, ar > 127 && (Qt = ar));
              break;
            case 3:
              pr = Et[Wt + 1], jt = Et[Wt + 2], (pr & 192) === 128 && (jt & 192) === 128 && (ar = (Jt & 15) << 12 | (pr & 63) << 6 | jt & 63, ar > 2047 && (ar < 55296 || ar > 57343) && (Qt = ar));
              break;
            case 4:
              pr = Et[Wt + 1], jt = Et[Wt + 2], nr = Et[Wt + 3], (pr & 192) === 128 && (jt & 192) === 128 && (nr & 192) === 128 && (ar = (Jt & 15) << 18 | (pr & 63) << 12 | (jt & 63) << 6 | nr & 63, ar > 65535 && ar < 1114112 && (Qt = ar));
          }
        }
        Qt === null ? (Qt = 65533, ur = 1) : Qt > 65535 && (Qt -= 65536, Ct.push(Qt >>> 10 & 1023 | 55296), Qt = 56320 | Qt & 1023), Ct.push(Qt), Wt += ur;
      }
      return br(Ct);
    }
    const dr = 4096;
    function br(Et) {
      const lt = Et.length;
      if (lt <= dr)
        return String.fromCharCode.apply(String, Et);
      let pt = "", Ct = 0;
      for (; Ct < lt; )
        pt += String.fromCharCode.apply(
          String,
          Et.slice(Ct, Ct += dr)
        );
      return pt;
    }
    function wr(Et, lt, pt) {
      let Ct = "";
      pt = Math.min(Et.length, pt);
      for (let Wt = lt; Wt < pt; ++Wt)
        Ct += String.fromCharCode(Et[Wt] & 127);
      return Ct;
    }
    function or(Et, lt, pt) {
      let Ct = "";
      pt = Math.min(Et.length, pt);
      for (let Wt = lt; Wt < pt; ++Wt)
        Ct += String.fromCharCode(Et[Wt]);
      return Ct;
    }
    function Nr(Et, lt, pt) {
      const Ct = Et.length;
      (!lt || lt < 0) && (lt = 0), (!pt || pt < 0 || pt > Ct) && (pt = Ct);
      let Wt = "";
      for (let Jt = lt; Jt < pt; ++Jt)
        Wt += Gt[Et[Jt]];
      return Wt;
    }
    function Br(Et, lt, pt) {
      const Ct = Et.slice(lt, pt);
      let Wt = "";
      for (let Jt = 0; Jt < Ct.length - 1; Jt += 2)
        Wt += String.fromCharCode(Ct[Jt] + Ct[Jt + 1] * 256);
      return Wt;
    }
    ke.prototype.slice = function(lt, pt) {
      const Ct = this.length;
      lt = ~~lt, pt = pt === void 0 ? Ct : ~~pt, lt < 0 ? (lt += Ct, lt < 0 && (lt = 0)) : lt > Ct && (lt = Ct), pt < 0 ? (pt += Ct, pt < 0 && (pt = 0)) : pt > Ct && (pt = Ct), pt < lt && (pt = lt);
      const Wt = this.subarray(lt, pt);
      return Object.setPrototypeOf(Wt, ke.prototype), Wt;
    };
    function Tr(Et, lt, pt) {
      if (Et % 1 !== 0 || Et < 0) throw new RangeError("offset is not uint");
      if (Et + lt > pt) throw new RangeError("Trying to access beyond buffer length");
    }
    ke.prototype.readUintLE = ke.prototype.readUIntLE = function(lt, pt, Ct) {
      lt = lt >>> 0, pt = pt >>> 0, Ct || Tr(lt, pt, this.length);
      let Wt = this[lt], Jt = 1, Qt = 0;
      for (; ++Qt < pt && (Jt *= 256); )
        Wt += this[lt + Qt] * Jt;
      return Wt;
    }, ke.prototype.readUintBE = ke.prototype.readUIntBE = function(lt, pt, Ct) {
      lt = lt >>> 0, pt = pt >>> 0, Ct || Tr(lt, pt, this.length);
      let Wt = this[lt + --pt], Jt = 1;
      for (; pt > 0 && (Jt *= 256); )
        Wt += this[lt + --pt] * Jt;
      return Wt;
    }, ke.prototype.readUint8 = ke.prototype.readUInt8 = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 1, this.length), this[lt];
    }, ke.prototype.readUint16LE = ke.prototype.readUInt16LE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 2, this.length), this[lt] | this[lt + 1] << 8;
    }, ke.prototype.readUint16BE = ke.prototype.readUInt16BE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 2, this.length), this[lt] << 8 | this[lt + 1];
    }, ke.prototype.readUint32LE = ke.prototype.readUInt32LE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 4, this.length), (this[lt] | this[lt + 1] << 8 | this[lt + 2] << 16) + this[lt + 3] * 16777216;
    }, ke.prototype.readUint32BE = ke.prototype.readUInt32BE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 4, this.length), this[lt] * 16777216 + (this[lt + 1] << 16 | this[lt + 2] << 8 | this[lt + 3]);
    }, ke.prototype.readBigUInt64LE = Lt(function(lt) {
      lt = lt >>> 0, Yt(lt, "offset");
      const pt = this[lt], Ct = this[lt + 7];
      (pt === void 0 || Ct === void 0) && rr(lt, this.length - 8);
      const Wt = pt + this[++lt] * 2 ** 8 + this[++lt] * 2 ** 16 + this[++lt] * 2 ** 24, Jt = this[++lt] + this[++lt] * 2 ** 8 + this[++lt] * 2 ** 16 + Ct * 2 ** 24;
      return BigInt(Wt) + (BigInt(Jt) << BigInt(32));
    }), ke.prototype.readBigUInt64BE = Lt(function(lt) {
      lt = lt >>> 0, Yt(lt, "offset");
      const pt = this[lt], Ct = this[lt + 7];
      (pt === void 0 || Ct === void 0) && rr(lt, this.length - 8);
      const Wt = pt * 2 ** 24 + this[++lt] * 2 ** 16 + this[++lt] * 2 ** 8 + this[++lt], Jt = this[++lt] * 2 ** 24 + this[++lt] * 2 ** 16 + this[++lt] * 2 ** 8 + Ct;
      return (BigInt(Wt) << BigInt(32)) + BigInt(Jt);
    }), ke.prototype.readIntLE = function(lt, pt, Ct) {
      lt = lt >>> 0, pt = pt >>> 0, Ct || Tr(lt, pt, this.length);
      let Wt = this[lt], Jt = 1, Qt = 0;
      for (; ++Qt < pt && (Jt *= 256); )
        Wt += this[lt + Qt] * Jt;
      return Jt *= 128, Wt >= Jt && (Wt -= Math.pow(2, 8 * pt)), Wt;
    }, ke.prototype.readIntBE = function(lt, pt, Ct) {
      lt = lt >>> 0, pt = pt >>> 0, Ct || Tr(lt, pt, this.length);
      let Wt = pt, Jt = 1, Qt = this[lt + --Wt];
      for (; Wt > 0 && (Jt *= 256); )
        Qt += this[lt + --Wt] * Jt;
      return Jt *= 128, Qt >= Jt && (Qt -= Math.pow(2, 8 * pt)), Qt;
    }, ke.prototype.readInt8 = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 1, this.length), this[lt] & 128 ? (255 - this[lt] + 1) * -1 : this[lt];
    }, ke.prototype.readInt16LE = function(lt, pt) {
      lt = lt >>> 0, pt || Tr(lt, 2, this.length);
      const Ct = this[lt] | this[lt + 1] << 8;
      return Ct & 32768 ? Ct | 4294901760 : Ct;
    }, ke.prototype.readInt16BE = function(lt, pt) {
      lt = lt >>> 0, pt || Tr(lt, 2, this.length);
      const Ct = this[lt + 1] | this[lt] << 8;
      return Ct & 32768 ? Ct | 4294901760 : Ct;
    }, ke.prototype.readInt32LE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 4, this.length), this[lt] | this[lt + 1] << 8 | this[lt + 2] << 16 | this[lt + 3] << 24;
    }, ke.prototype.readInt32BE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 4, this.length), this[lt] << 24 | this[lt + 1] << 16 | this[lt + 2] << 8 | this[lt + 3];
    }, ke.prototype.readBigInt64LE = Lt(function(lt) {
      lt = lt >>> 0, Yt(lt, "offset");
      const pt = this[lt], Ct = this[lt + 7];
      (pt === void 0 || Ct === void 0) && rr(lt, this.length - 8);
      const Wt = this[lt + 4] + this[lt + 5] * 2 ** 8 + this[lt + 6] * 2 ** 16 + (Ct << 24);
      return (BigInt(Wt) << BigInt(32)) + BigInt(pt + this[++lt] * 2 ** 8 + this[++lt] * 2 ** 16 + this[++lt] * 2 ** 24);
    }), ke.prototype.readBigInt64BE = Lt(function(lt) {
      lt = lt >>> 0, Yt(lt, "offset");
      const pt = this[lt], Ct = this[lt + 7];
      (pt === void 0 || Ct === void 0) && rr(lt, this.length - 8);
      const Wt = (pt << 24) + // Overflow
      this[++lt] * 2 ** 16 + this[++lt] * 2 ** 8 + this[++lt];
      return (BigInt(Wt) << BigInt(32)) + BigInt(this[++lt] * 2 ** 24 + this[++lt] * 2 ** 16 + this[++lt] * 2 ** 8 + Ct);
    }), ke.prototype.readFloatLE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 4, this.length), It.read(this, lt, !0, 23, 4);
    }, ke.prototype.readFloatBE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 4, this.length), It.read(this, lt, !1, 23, 4);
    }, ke.prototype.readDoubleLE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 8, this.length), It.read(this, lt, !0, 52, 8);
    }, ke.prototype.readDoubleBE = function(lt, pt) {
      return lt = lt >>> 0, pt || Tr(lt, 8, this.length), It.read(this, lt, !1, 52, 8);
    };
    function Mr(Et, lt, pt, Ct, Wt, Jt) {
      if (!ke.isBuffer(Et)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (lt > Wt || lt < Jt) throw new RangeError('"value" argument is out of bounds');
      if (pt + Ct > Et.length) throw new RangeError("Index out of range");
    }
    ke.prototype.writeUintLE = ke.prototype.writeUIntLE = function(lt, pt, Ct, Wt) {
      if (lt = +lt, pt = pt >>> 0, Ct = Ct >>> 0, !Wt) {
        const ur = Math.pow(2, 8 * Ct) - 1;
        Mr(this, lt, pt, Ct, ur, 0);
      }
      let Jt = 1, Qt = 0;
      for (this[pt] = lt & 255; ++Qt < Ct && (Jt *= 256); )
        this[pt + Qt] = lt / Jt & 255;
      return pt + Ct;
    }, ke.prototype.writeUintBE = ke.prototype.writeUIntBE = function(lt, pt, Ct, Wt) {
      if (lt = +lt, pt = pt >>> 0, Ct = Ct >>> 0, !Wt) {
        const ur = Math.pow(2, 8 * Ct) - 1;
        Mr(this, lt, pt, Ct, ur, 0);
      }
      let Jt = Ct - 1, Qt = 1;
      for (this[pt + Jt] = lt & 255; --Jt >= 0 && (Qt *= 256); )
        this[pt + Jt] = lt / Qt & 255;
      return pt + Ct;
    }, ke.prototype.writeUint8 = ke.prototype.writeUInt8 = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 1, 255, 0), this[pt] = lt & 255, pt + 1;
    }, ke.prototype.writeUint16LE = ke.prototype.writeUInt16LE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 2, 65535, 0), this[pt] = lt & 255, this[pt + 1] = lt >>> 8, pt + 2;
    }, ke.prototype.writeUint16BE = ke.prototype.writeUInt16BE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 2, 65535, 0), this[pt] = lt >>> 8, this[pt + 1] = lt & 255, pt + 2;
    }, ke.prototype.writeUint32LE = ke.prototype.writeUInt32LE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 4, 4294967295, 0), this[pt + 3] = lt >>> 24, this[pt + 2] = lt >>> 16, this[pt + 1] = lt >>> 8, this[pt] = lt & 255, pt + 4;
    }, ke.prototype.writeUint32BE = ke.prototype.writeUInt32BE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 4, 4294967295, 0), this[pt] = lt >>> 24, this[pt + 1] = lt >>> 16, this[pt + 2] = lt >>> 8, this[pt + 3] = lt & 255, pt + 4;
    };
    function _r(Et, lt, pt, Ct, Wt) {
      Ut(lt, Ct, Wt, Et, pt, 7);
      let Jt = Number(lt & BigInt(4294967295));
      Et[pt++] = Jt, Jt = Jt >> 8, Et[pt++] = Jt, Jt = Jt >> 8, Et[pt++] = Jt, Jt = Jt >> 8, Et[pt++] = Jt;
      let Qt = Number(lt >> BigInt(32) & BigInt(4294967295));
      return Et[pt++] = Qt, Qt = Qt >> 8, Et[pt++] = Qt, Qt = Qt >> 8, Et[pt++] = Qt, Qt = Qt >> 8, Et[pt++] = Qt, pt;
    }
    function kr(Et, lt, pt, Ct, Wt) {
      Ut(lt, Ct, Wt, Et, pt, 7);
      let Jt = Number(lt & BigInt(4294967295));
      Et[pt + 7] = Jt, Jt = Jt >> 8, Et[pt + 6] = Jt, Jt = Jt >> 8, Et[pt + 5] = Jt, Jt = Jt >> 8, Et[pt + 4] = Jt;
      let Qt = Number(lt >> BigInt(32) & BigInt(4294967295));
      return Et[pt + 3] = Qt, Qt = Qt >> 8, Et[pt + 2] = Qt, Qt = Qt >> 8, Et[pt + 1] = Qt, Qt = Qt >> 8, Et[pt] = Qt, pt + 8;
    }
    ke.prototype.writeBigUInt64LE = Lt(function(lt, pt = 0) {
      return _r(this, lt, pt, BigInt(0), BigInt("0xffffffffffffffff"));
    }), ke.prototype.writeBigUInt64BE = Lt(function(lt, pt = 0) {
      return kr(this, lt, pt, BigInt(0), BigInt("0xffffffffffffffff"));
    }), ke.prototype.writeIntLE = function(lt, pt, Ct, Wt) {
      if (lt = +lt, pt = pt >>> 0, !Wt) {
        const pr = Math.pow(2, 8 * Ct - 1);
        Mr(this, lt, pt, Ct, pr - 1, -pr);
      }
      let Jt = 0, Qt = 1, ur = 0;
      for (this[pt] = lt & 255; ++Jt < Ct && (Qt *= 256); )
        lt < 0 && ur === 0 && this[pt + Jt - 1] !== 0 && (ur = 1), this[pt + Jt] = (lt / Qt >> 0) - ur & 255;
      return pt + Ct;
    }, ke.prototype.writeIntBE = function(lt, pt, Ct, Wt) {
      if (lt = +lt, pt = pt >>> 0, !Wt) {
        const pr = Math.pow(2, 8 * Ct - 1);
        Mr(this, lt, pt, Ct, pr - 1, -pr);
      }
      let Jt = Ct - 1, Qt = 1, ur = 0;
      for (this[pt + Jt] = lt & 255; --Jt >= 0 && (Qt *= 256); )
        lt < 0 && ur === 0 && this[pt + Jt + 1] !== 0 && (ur = 1), this[pt + Jt] = (lt / Qt >> 0) - ur & 255;
      return pt + Ct;
    }, ke.prototype.writeInt8 = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 1, 127, -128), lt < 0 && (lt = 255 + lt + 1), this[pt] = lt & 255, pt + 1;
    }, ke.prototype.writeInt16LE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 2, 32767, -32768), this[pt] = lt & 255, this[pt + 1] = lt >>> 8, pt + 2;
    }, ke.prototype.writeInt16BE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 2, 32767, -32768), this[pt] = lt >>> 8, this[pt + 1] = lt & 255, pt + 2;
    }, ke.prototype.writeInt32LE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 4, 2147483647, -2147483648), this[pt] = lt & 255, this[pt + 1] = lt >>> 8, this[pt + 2] = lt >>> 16, this[pt + 3] = lt >>> 24, pt + 4;
    }, ke.prototype.writeInt32BE = function(lt, pt, Ct) {
      return lt = +lt, pt = pt >>> 0, Ct || Mr(this, lt, pt, 4, 2147483647, -2147483648), lt < 0 && (lt = 4294967295 + lt + 1), this[pt] = lt >>> 24, this[pt + 1] = lt >>> 16, this[pt + 2] = lt >>> 8, this[pt + 3] = lt & 255, pt + 4;
    }, ke.prototype.writeBigInt64LE = Lt(function(lt, pt = 0) {
      return _r(this, lt, pt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), ke.prototype.writeBigInt64BE = Lt(function(lt, pt = 0) {
      return kr(this, lt, pt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Fr(Et, lt, pt, Ct, Wt, Jt) {
      if (pt + Ct > Et.length) throw new RangeError("Index out of range");
      if (pt < 0) throw new RangeError("Index out of range");
    }
    function Ar(Et, lt, pt, Ct, Wt) {
      return lt = +lt, pt = pt >>> 0, Wt || Fr(Et, lt, pt, 4), It.write(Et, lt, pt, Ct, 23, 4), pt + 4;
    }
    ke.prototype.writeFloatLE = function(lt, pt, Ct) {
      return Ar(this, lt, pt, !0, Ct);
    }, ke.prototype.writeFloatBE = function(lt, pt, Ct) {
      return Ar(this, lt, pt, !1, Ct);
    };
    function Cr(Et, lt, pt, Ct, Wt) {
      return lt = +lt, pt = pt >>> 0, Wt || Fr(Et, lt, pt, 8), It.write(Et, lt, pt, Ct, 52, 8), pt + 8;
    }
    ke.prototype.writeDoubleLE = function(lt, pt, Ct) {
      return Cr(this, lt, pt, !0, Ct);
    }, ke.prototype.writeDoubleBE = function(lt, pt, Ct) {
      return Cr(this, lt, pt, !1, Ct);
    }, ke.prototype.copy = function(lt, pt, Ct, Wt) {
      if (!ke.isBuffer(lt)) throw new TypeError("argument should be a Buffer");
      if (Ct || (Ct = 0), !Wt && Wt !== 0 && (Wt = this.length), pt >= lt.length && (pt = lt.length), pt || (pt = 0), Wt > 0 && Wt < Ct && (Wt = Ct), Wt === Ct || lt.length === 0 || this.length === 0) return 0;
      if (pt < 0)
        throw new RangeError("targetStart out of bounds");
      if (Ct < 0 || Ct >= this.length) throw new RangeError("Index out of range");
      if (Wt < 0) throw new RangeError("sourceEnd out of bounds");
      Wt > this.length && (Wt = this.length), lt.length - pt < Wt - Ct && (Wt = lt.length - pt + Ct);
      const Jt = Wt - Ct;
      return this === lt && typeof Xt.prototype.copyWithin == "function" ? this.copyWithin(pt, Ct, Wt) : Xt.prototype.set.call(
        lt,
        this.subarray(Ct, Wt),
        pt
      ), Jt;
    }, ke.prototype.fill = function(lt, pt, Ct, Wt) {
      if (typeof lt == "string") {
        if (typeof pt == "string" ? (Wt = pt, pt = 0, Ct = this.length) : typeof Ct == "string" && (Wt = Ct, Ct = this.length), Wt !== void 0 && typeof Wt != "string")
          throw new TypeError("encoding must be a string");
        if (typeof Wt == "string" && !ke.isEncoding(Wt))
          throw new TypeError("Unknown encoding: " + Wt);
        if (lt.length === 1) {
          const Qt = lt.charCodeAt(0);
          (Wt === "utf8" && Qt < 128 || Wt === "latin1") && (lt = Qt);
        }
      } else typeof lt == "number" ? lt = lt & 255 : typeof lt == "boolean" && (lt = Number(lt));
      if (pt < 0 || this.length < pt || this.length < Ct)
        throw new RangeError("Out of range index");
      if (Ct <= pt)
        return this;
      pt = pt >>> 0, Ct = Ct === void 0 ? this.length : Ct >>> 0, lt || (lt = 0);
      let Jt;
      if (typeof lt == "number")
        for (Jt = pt; Jt < Ct; ++Jt)
          this[Jt] = lt;
      else {
        const Qt = ke.isBuffer(lt) ? lt : ke.from(lt, Wt), ur = Qt.length;
        if (ur === 0)
          throw new TypeError('The value "' + lt + '" is invalid for argument "value"');
        for (Jt = 0; Jt < Ct - pt; ++Jt)
          this[Jt + pt] = Qt[Jt % ur];
      }
      return this;
    };
    const Dr = {};
    function Rt(Et, lt, pt) {
      Dr[Et] = class extends pt {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: lt.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${Et}]`, this.stack, delete this.name;
        }
        get code() {
          return Et;
        }
        set code(Wt) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: Wt,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${Et}]: ${this.message}`;
        }
      };
    }
    Rt(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(Et) {
        return Et ? `${Et} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Rt(
      "ERR_INVALID_ARG_TYPE",
      function(Et, lt) {
        return `The "${Et}" argument must be of type number. Received type ${typeof lt}`;
      },
      TypeError
    ), Rt(
      "ERR_OUT_OF_RANGE",
      function(Et, lt, pt) {
        let Ct = `The value of "${Et}" is out of range.`, Wt = pt;
        return Number.isInteger(pt) && Math.abs(pt) > 2 ** 32 ? Wt = vt(String(pt)) : typeof pt == "bigint" && (Wt = String(pt), (pt > BigInt(2) ** BigInt(32) || pt < -(BigInt(2) ** BigInt(32))) && (Wt = vt(Wt)), Wt += "n"), Ct += ` It must be ${lt}. Received ${Wt}`, Ct;
      },
      RangeError
    );
    function vt(Et) {
      let lt = "", pt = Et.length;
      const Ct = Et[0] === "-" ? 1 : 0;
      for (; pt >= Ct + 4; pt -= 3)
        lt = `_${Et.slice(pt - 3, pt)}${lt}`;
      return `${Et.slice(0, pt)}${lt}`;
    }
    function $t(Et, lt, pt) {
      Yt(lt, "offset"), (Et[lt] === void 0 || Et[lt + pt] === void 0) && rr(lt, Et.length - (pt + 1));
    }
    function Ut(Et, lt, pt, Ct, Wt, Jt) {
      if (Et > pt || Et < lt) {
        const Qt = typeof lt == "bigint" ? "n" : "";
        let ur;
        throw lt === 0 || lt === BigInt(0) ? ur = `>= 0${Qt} and < 2${Qt} ** ${(Jt + 1) * 8}${Qt}` : ur = `>= -(2${Qt} ** ${(Jt + 1) * 8 - 1}${Qt}) and < 2 ** ${(Jt + 1) * 8 - 1}${Qt}`, new Dr.ERR_OUT_OF_RANGE("value", ur, Et);
      }
      $t(Ct, Wt, Jt);
    }
    function Yt(Et, lt) {
      if (typeof Et != "number")
        throw new Dr.ERR_INVALID_ARG_TYPE(lt, "number", Et);
    }
    function rr(Et, lt, pt) {
      throw Math.floor(Et) !== Et ? (Yt(Et, pt), new Dr.ERR_OUT_OF_RANGE("offset", "an integer", Et)) : lt < 0 ? new Dr.ERR_BUFFER_OUT_OF_BOUNDS() : new Dr.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${lt}`,
        Et
      );
    }
    const ir = /[^+/0-9A-Za-z-_]/g;
    function gr(Et) {
      if (Et = Et.split("=")[0], Et = Et.trim().replace(ir, ""), Et.length < 2) return "";
      for (; Et.length % 4 !== 0; )
        Et = Et + "=";
      return Et;
    }
    function Ir(Et, lt) {
      lt = lt || 1 / 0;
      let pt;
      const Ct = Et.length;
      let Wt = null;
      const Jt = [];
      for (let Qt = 0; Qt < Ct; ++Qt) {
        if (pt = Et.charCodeAt(Qt), pt > 55295 && pt < 57344) {
          if (!Wt) {
            if (pt > 56319) {
              (lt -= 3) > -1 && Jt.push(239, 191, 189);
              continue;
            } else if (Qt + 1 === Ct) {
              (lt -= 3) > -1 && Jt.push(239, 191, 189);
              continue;
            }
            Wt = pt;
            continue;
          }
          if (pt < 56320) {
            (lt -= 3) > -1 && Jt.push(239, 191, 189), Wt = pt;
            continue;
          }
          pt = (Wt - 55296 << 10 | pt - 56320) + 65536;
        } else Wt && (lt -= 3) > -1 && Jt.push(239, 191, 189);
        if (Wt = null, pt < 128) {
          if ((lt -= 1) < 0) break;
          Jt.push(pt);
        } else if (pt < 2048) {
          if ((lt -= 2) < 0) break;
          Jt.push(
            pt >> 6 | 192,
            pt & 63 | 128
          );
        } else if (pt < 65536) {
          if ((lt -= 3) < 0) break;
          Jt.push(
            pt >> 12 | 224,
            pt >> 6 & 63 | 128,
            pt & 63 | 128
          );
        } else if (pt < 1114112) {
          if ((lt -= 4) < 0) break;
          Jt.push(
            pt >> 18 | 240,
            pt >> 12 & 63 | 128,
            pt >> 6 & 63 | 128,
            pt & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Jt;
    }
    function yr(Et) {
      const lt = [];
      for (let pt = 0; pt < Et.length; ++pt)
        lt.push(Et.charCodeAt(pt) & 255);
      return lt;
    }
    function Pr(Et, lt) {
      let pt, Ct, Wt;
      const Jt = [];
      for (let Qt = 0; Qt < Et.length && !((lt -= 2) < 0); ++Qt)
        pt = Et.charCodeAt(Qt), Ct = pt >> 8, Wt = pt % 256, Jt.push(Wt), Jt.push(Ct);
      return Jt;
    }
    function $r(Et) {
      return Tt.toByteArray(gr(Et));
    }
    function Er(Et, lt, pt, Ct) {
      let Wt;
      for (Wt = 0; Wt < Ct && !(Wt + pt >= lt.length || Wt >= Et.length); ++Wt)
        lt[Wt + pt] = Et[Wt];
      return Wt;
    }
    function Or(Et, lt) {
      return Et instanceof lt || Et != null && Et.constructor != null && Et.constructor.name != null && Et.constructor.name === lt.name;
    }
    function Ur(Et) {
      return Et !== Et;
    }
    const Gt = function() {
      const Et = "0123456789abcdef", lt = new Array(256);
      for (let pt = 0; pt < 16; ++pt) {
        const Ct = pt * 16;
        for (let Wt = 0; Wt < 16; ++Wt)
          lt[Ct + Wt] = Et[pt] + Et[Wt];
      }
      return lt;
    }();
    function Lt(Et) {
      return typeof BigInt > "u" ? zt : Et;
    }
    function zt() {
      throw new Error("BigInt not supported");
    }
  })(B);
  const Mt = B.Buffer;
  A.Blob = B.Blob, A.BlobOptions = B.BlobOptions, A.Buffer = B.Buffer, A.File = B.File, A.FileOptions = B.FileOptions, A.INSPECT_MAX_BYTES = B.INSPECT_MAX_BYTES, A.SlowBuffer = B.SlowBuffer, A.TranscodeEncoding = B.TranscodeEncoding, A.atob = B.atob, A.btoa = B.btoa, A.constants = B.constants, A.default = Mt, A.isAscii = B.isAscii, A.isUtf8 = B.isUtf8, A.kMaxLength = B.kMaxLength, A.kStringMaxLength = B.kStringMaxLength, A.resolveObjectURL = B.resolveObjectURL, A.transcode = B.transcode;
})(dist$1);
const Buffer$D = /* @__PURE__ */ getDefaultExportFromCjs(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(A, B) {
  var L = dist$1, V = L.Buffer;
  function J(ne, ie) {
    for (var pe in ne)
      ie[pe] = ne[pe];
  }
  V.from && V.alloc && V.allocUnsafe && V.allocUnsafeSlow ? A.exports = L : (J(L, B), B.Buffer = re);
  function re(ne, ie, pe) {
    return V(ne, ie, pe);
  }
  re.prototype = Object.create(V.prototype), J(V, re), re.from = function(ne, ie, pe) {
    if (typeof ne == "number")
      throw new TypeError("Argument must not be a number");
    return V(ne, ie, pe);
  }, re.alloc = function(ne, ie, pe) {
    if (typeof ne != "number")
      throw new TypeError("Argument must be a number");
    var nt = V(ne);
    return ie !== void 0 ? typeof pe == "string" ? nt.fill(ie, pe) : nt.fill(ie) : nt.fill(0), nt;
  }, re.allocUnsafe = function(ne) {
    if (typeof ne != "number")
      throw new TypeError("Argument must be a number");
    return V(ne);
  }, re.allocUnsafeSlow = function(ne) {
    if (typeof ne != "number")
      throw new TypeError("Argument must be a number");
    return L.SlowBuffer(ne);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$C = safeBufferExports$1.Buffer, crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(A, B) {
  if (A > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var L = Buffer$C.allocUnsafe(A);
  if (A > 0)
    if (A > MAX_BYTES)
      for (var V = 0; V < A; V += MAX_BYTES)
        crypto$3.getRandomValues(L.slice(V, V + MAX_BYTES));
    else
      crypto$3.getRandomValues(L);
  return typeof B == "function" ? process$1.nextTick(function() {
    B(null, L);
  }) : L;
}
var browserExports = browser$b.exports, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(B, L) {
  L && (B.super_ = L, B.prototype = Object.create(L.prototype, {
    constructor: {
      value: B,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(B, L) {
  if (L) {
    B.super_ = L;
    var V = function() {
    };
    V.prototype = L.prototype, B.prototype = new V(), B.prototype.constructor = B;
  }
};
var inherits_browserExports = inherits_browser.exports, readableBrowser$1 = { exports: {} }, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(B, L, V) {
  return Function.prototype.apply.call(B, L, V);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(B) {
  return Object.getOwnPropertyNames(B).concat(Object.getOwnPropertySymbols(B));
} : ReflectOwnKeys = function(B) {
  return Object.getOwnPropertyNames(B);
};
function ProcessEmitWarning(A) {
  console && console.warn && console.warn(A);
}
var NumberIsNaN = Number.isNaN || function(B) {
  return B !== B;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once$1;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(A) {
  if (typeof A != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof A);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(A) {
    if (typeof A != "number" || A < 0 || NumberIsNaN(A))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + A + ".");
    defaultMaxListeners = A;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(B) {
  if (typeof B != "number" || B < 0 || NumberIsNaN(B))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + B + ".");
  return this._maxListeners = B, this;
};
function _getMaxListeners(A) {
  return A._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : A._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(B) {
  for (var L = [], V = 1; V < arguments.length; V++) L.push(arguments[V]);
  var J = B === "error", re = this._events;
  if (re !== void 0)
    J = J && re.error === void 0;
  else if (!J)
    return !1;
  if (J) {
    var ne;
    if (L.length > 0 && (ne = L[0]), ne instanceof Error)
      throw ne;
    var ie = new Error("Unhandled error." + (ne ? " (" + ne.message + ")" : ""));
    throw ie.context = ne, ie;
  }
  var pe = re[B];
  if (pe === void 0)
    return !1;
  if (typeof pe == "function")
    ReflectApply(pe, this, L);
  else
    for (var nt = pe.length, oe = arrayClone(pe, nt), V = 0; V < nt; ++V)
      ReflectApply(oe[V], this, L);
  return !0;
};
function _addListener(A, B, L, V) {
  var J, re, ne;
  if (checkListener(L), re = A._events, re === void 0 ? (re = A._events = /* @__PURE__ */ Object.create(null), A._eventsCount = 0) : (re.newListener !== void 0 && (A.emit(
    "newListener",
    B,
    L.listener ? L.listener : L
  ), re = A._events), ne = re[B]), ne === void 0)
    ne = re[B] = L, ++A._eventsCount;
  else if (typeof ne == "function" ? ne = re[B] = V ? [L, ne] : [ne, L] : V ? ne.unshift(L) : ne.push(L), J = _getMaxListeners(A), J > 0 && ne.length > J && !ne.warned) {
    ne.warned = !0;
    var ie = new Error("Possible EventEmitter memory leak detected. " + ne.length + " " + String(B) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    ie.name = "MaxListenersExceededWarning", ie.emitter = A, ie.type = B, ie.count = ne.length, ProcessEmitWarning(ie);
  }
  return A;
}
EventEmitter.prototype.addListener = function(B, L) {
  return _addListener(this, B, L, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(B, L) {
  return _addListener(this, B, L, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(A, B, L) {
  var V = { fired: !1, wrapFn: void 0, target: A, type: B, listener: L }, J = onceWrapper.bind(V);
  return J.listener = L, V.wrapFn = J, J;
}
EventEmitter.prototype.once = function(B, L) {
  return checkListener(L), this.on(B, _onceWrap(this, B, L)), this;
};
EventEmitter.prototype.prependOnceListener = function(B, L) {
  return checkListener(L), this.prependListener(B, _onceWrap(this, B, L)), this;
};
EventEmitter.prototype.removeListener = function(B, L) {
  var V, J, re, ne, ie;
  if (checkListener(L), J = this._events, J === void 0)
    return this;
  if (V = J[B], V === void 0)
    return this;
  if (V === L || V.listener === L)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete J[B], J.removeListener && this.emit("removeListener", B, V.listener || L));
  else if (typeof V != "function") {
    for (re = -1, ne = V.length - 1; ne >= 0; ne--)
      if (V[ne] === L || V[ne].listener === L) {
        ie = V[ne].listener, re = ne;
        break;
      }
    if (re < 0)
      return this;
    re === 0 ? V.shift() : spliceOne(V, re), V.length === 1 && (J[B] = V[0]), J.removeListener !== void 0 && this.emit("removeListener", B, ie || L);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(B) {
  var L, V, J;
  if (V = this._events, V === void 0)
    return this;
  if (V.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : V[B] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete V[B]), this;
  if (arguments.length === 0) {
    var re = Object.keys(V), ne;
    for (J = 0; J < re.length; ++J)
      ne = re[J], ne !== "removeListener" && this.removeAllListeners(ne);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (L = V[B], typeof L == "function")
    this.removeListener(B, L);
  else if (L !== void 0)
    for (J = L.length - 1; J >= 0; J--)
      this.removeListener(B, L[J]);
  return this;
};
function _listeners(A, B, L) {
  var V = A._events;
  if (V === void 0)
    return [];
  var J = V[B];
  return J === void 0 ? [] : typeof J == "function" ? L ? [J.listener || J] : [J] : L ? unwrapListeners(J) : arrayClone(J, J.length);
}
EventEmitter.prototype.listeners = function(B) {
  return _listeners(this, B, !0);
};
EventEmitter.prototype.rawListeners = function(B) {
  return _listeners(this, B, !1);
};
EventEmitter.listenerCount = function(A, B) {
  return typeof A.listenerCount == "function" ? A.listenerCount(B) : listenerCount.call(A, B);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(A) {
  var B = this._events;
  if (B !== void 0) {
    var L = B[A];
    if (typeof L == "function")
      return 1;
    if (L !== void 0)
      return L.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(A, B) {
  for (var L = new Array(B), V = 0; V < B; ++V)
    L[V] = A[V];
  return L;
}
function spliceOne(A, B) {
  for (; B + 1 < A.length; B++)
    A[B] = A[B + 1];
  A.pop();
}
function unwrapListeners(A) {
  for (var B = new Array(A.length), L = 0; L < B.length; ++L)
    B[L] = A[L].listener || A[L];
  return B;
}
function once$1(A, B) {
  return new Promise(function(L, V) {
    function J(ne) {
      A.removeListener(B, re), V(ne);
    }
    function re() {
      typeof A.removeListener == "function" && A.removeListener("error", J), L([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(A, B, re, { once: !0 }), B !== "error" && addErrorHandlerIfEventEmitter(A, J, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(A, B, L) {
  typeof A.on == "function" && eventTargetAgnosticAddListener(A, "error", B, L);
}
function eventTargetAgnosticAddListener(A, B, L, V) {
  if (typeof A.on == "function")
    V.once ? A.once(B, L) : A.on(B, L);
  else if (typeof A.addEventListener == "function")
    A.addEventListener(B, function J(re) {
      V.once && A.removeEventListener(B, J), L(re);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof A);
}
var eventsExports = events.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var util$3 = {}, types$5 = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var B = {}, L = Symbol("test"), V = Object(L);
  if (typeof L == "string" || Object.prototype.toString.call(L) !== "[object Symbol]" || Object.prototype.toString.call(V) !== "[object Symbol]")
    return !1;
  var J = 42;
  B[L] = J;
  for (var re in B)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0)
    return !1;
  var ne = Object.getOwnPropertySymbols(B);
  if (ne.length !== 1 || ne[0] !== L || !Object.prototype.propertyIsEnumerable.call(B, L))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var ie = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(B, L)
    );
    if (ie.value !== J || ie.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$2 = shams$1, shams = function() {
  return hasSymbols$2() && !!Symbol.toStringTag;
}, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range$3 = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(B) {
  return B !== B;
}, $isNaN = _isNaN, sign$2 = function(B) {
  return $isNaN(B) || B === 0 ? B : B < 0 ? -1 : 1;
}, gOPD$3 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$3;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, hasSymbols$1, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$1;
  hasRequiredHasSymbols = 1;
  var A = typeof Symbol < "u" && Symbol, B = shams$1;
  return hasSymbols$1 = function() {
    return typeof A != "function" || typeof Symbol != "function" || typeof A("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : B();
  }, hasSymbols$1;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var A = esObjectAtoms;
  return Object_getPrototypeOf = A.getPrototypeOf || null, Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$3 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(B, L) {
  for (var V = [], J = 0; J < B.length; J += 1)
    V[J] = B[J];
  for (var re = 0; re < L.length; re += 1)
    V[re + B.length] = L[re];
  return V;
}, slicy = function(B, L) {
  for (var V = [], J = L, re = 0; J < B.length; J += 1, re += 1)
    V[re] = B[J];
  return V;
}, joiny = function(A, B) {
  for (var L = "", V = 0; V < A.length; V += 1)
    L += A[V], V + 1 < A.length && (L += B);
  return L;
}, implementation$1 = function(B) {
  var L = this;
  if (typeof L != "function" || toStr$3.apply(L) !== funcType)
    throw new TypeError(ERROR_MESSAGE + L);
  for (var V = slicy(arguments, 1), J, re = function() {
    if (this instanceof J) {
      var oe = L.apply(
        this,
        concatty(V, arguments)
      );
      return Object(oe) === oe ? oe : this;
    }
    return L.apply(
      B,
      concatty(V, arguments)
    );
  }, ne = max$1(0, L.length - V.length), ie = [], pe = 0; pe < ne; pe++)
    ie[pe] = "$" + pe;
  if (J = Function("binder", "return function (" + joiny(ie, ",") + "){ return binder.apply(this,arguments); }")(re), L.prototype) {
    var nt = function() {
    };
    nt.prototype = L.prototype, J.prototype = new nt(), nt.prototype = null;
  }
  return J;
}, implementation = implementation$1, functionBind = Function.prototype.bind || implementation, functionCall = Function.prototype.call, functionApply = Function.prototype.apply, reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$4 = functionBind, $apply$2 = functionApply, $call$2 = functionCall, $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$4.call($call$2, $apply$2), bind$3 = functionBind, $TypeError$4 = type, $call$1 = functionCall, $actualApply = actualApply$1, callBindApplyHelpers = function(B) {
  if (B.length < 1 || typeof B[0] != "function")
    throw new $TypeError$4("a function is required");
  return $actualApply(bind$3, $call$1, B);
}, get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var A = callBindApplyHelpers, B = gopd$1, L;
  try {
    L = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (ne) {
    if (!ne || typeof ne != "object" || !("code" in ne) || ne.code !== "ERR_PROTO_ACCESS")
      throw ne;
  }
  var V = !!L && B && B(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), J = Object, re = J.getPrototypeOf;
  return get = V && typeof V.get == "function" ? A([V.get]) : typeof re == "function" ? (
    /** @type {import('./get')} */
    function(ie) {
      return re(ie == null ? ie : J(ie));
    }
  ) : !1, get;
}
var getProto$2, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$2;
  hasRequiredGetProto = 1;
  var A = requireReflect_getPrototypeOf(), B = requireObject_getPrototypeOf(), L = requireGet();
  return getProto$2 = A ? function(J) {
    return A(J);
  } : B ? function(J) {
    if (!J || typeof J != "object" && typeof J != "function")
      throw new TypeError("getProto: not an object");
    return B(J);
  } : L ? function(J) {
    return L(J);
  } : null, getProto$2;
}
var call = Function.prototype.call, $hasOwn = Object.prototype.hasOwnProperty, bind$2 = functionBind, hasown = bind$2.call(call, $hasOwn), undefined$1, $Object = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range$3, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$3 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(A) {
  try {
    return $Function('"use strict"; return (' + A + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$3();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols = requireHasSymbols()(), getProto$1 = requireGetProto(), $ObjectGPO = requireObject_getPrototypeOf(), $ReflectGPO = requireReflect_getPrototypeOf(), $apply$1 = functionApply, $call = functionCall, needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$1 ? undefined$1 : getProto$1(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(getProto$1([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols || !getProto$1 ? undefined$1 : getProto$1((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols && getProto$1 ? getProto$1(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$3,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$1)
  try {
    null.error;
  } catch (A) {
    var errorProto = getProto$1(getProto$1(A));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function A(B) {
  var L;
  if (B === "%AsyncFunction%")
    L = getEvalledConstructor("async function () {}");
  else if (B === "%GeneratorFunction%")
    L = getEvalledConstructor("function* () {}");
  else if (B === "%AsyncGeneratorFunction%")
    L = getEvalledConstructor("async function* () {}");
  else if (B === "%AsyncGenerator%") {
    var V = A("%AsyncGeneratorFunction%");
    V && (L = V.prototype);
  } else if (B === "%AsyncIteratorPrototype%") {
    var J = A("%AsyncGenerator%");
    J && getProto$1 && (L = getProto$1(J.prototype));
  }
  return INTRINSICS[B] = L, L;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = hasown, $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(B) {
  var L = $strSlice(B, 0, 1), V = $strSlice(B, -1);
  if (L === "%" && V !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if (V === "%" && L !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var J = [];
  return $replace(B, rePropName, function(re, ne, ie, pe) {
    J[J.length] = ie ? $replace(pe, reEscapeChar, "$1") : ne || re;
  }), J;
}, getBaseIntrinsic = function(B, L) {
  var V = B, J;
  if (hasOwn$1(LEGACY_ALIASES, V) && (J = LEGACY_ALIASES[V], V = "%" + J[0] + "%"), hasOwn$1(INTRINSICS, V)) {
    var re = INTRINSICS[V];
    if (re === needsEval && (re = doEval(V)), typeof re > "u" && !L)
      throw new $TypeError$3("intrinsic " + B + " exists, but is not available. Please file an issue!");
    return {
      alias: J,
      name: V,
      value: re
    };
  }
  throw new $SyntaxError$1("intrinsic " + B + " does not exist!");
}, getIntrinsic = function(B, L) {
  if (typeof B != "string" || B.length === 0)
    throw new $TypeError$3("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof L != "boolean")
    throw new $TypeError$3('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, B) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var V = stringToPath(B), J = V.length > 0 ? V[0] : "", re = getBaseIntrinsic("%" + J + "%", L), ne = re.name, ie = re.value, pe = !1, nt = re.alias;
  nt && (J = nt[0], $spliceApply(V, $concat([0, 1], nt)));
  for (var oe = 1, Ce = !0; oe < V.length; oe += 1) {
    var at = V[oe], it = $strSlice(at, 0, 1), gt = $strSlice(at, -1);
    if ((it === '"' || it === "'" || it === "`" || gt === '"' || gt === "'" || gt === "`") && it !== gt)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((at === "constructor" || !Ce) && (pe = !0), J += "." + at, ne = "%" + J + "%", hasOwn$1(INTRINSICS, ne))
      ie = INTRINSICS[ne];
    else if (ie != null) {
      if (!(at in ie)) {
        if (!L)
          throw new $TypeError$3("base intrinsic for " + B + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && oe + 1 >= V.length) {
        var St = $gOPD(ie, at);
        Ce = !!St, Ce && "get" in St && !("originalValue" in St.get) ? ie = St.get : ie = ie[at];
      } else
        Ce = hasOwn$1(ie, at), ie = ie[at];
      Ce && !pe && (INTRINSICS[ne] = ie);
    }
  }
  return ie;
}, GetIntrinsic$1 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$1 = callBindBasic([GetIntrinsic$1("%String.prototype.indexOf%")]), callBound$5 = function(B, L) {
  var V = (
    /** @type {Parameters<typeof callBindBasic>[0][0]} */
    GetIntrinsic$1(B, !!L)
  );
  return typeof V == "function" && $indexOf$1(B, ".prototype.") > -1 ? callBindBasic([V]) : V;
}, hasToStringTag$4 = shams(), callBound$4 = callBound$5, $toString$2 = callBound$4("Object.prototype.toString"), isStandardArguments = function(B) {
  return hasToStringTag$4 && B && typeof B == "object" && Symbol.toStringTag in B ? !1 : $toString$2(B) === "[object Arguments]";
}, isLegacyArguments = function(B) {
  return isStandardArguments(B) ? !0 : B !== null && typeof B == "object" && "length" in B && typeof B.length == "number" && B.length >= 0 && $toString$2(B) !== "[object Array]" && "callee" in B && $toString$2(B.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$3 = callBound$5, hasToStringTag$3 = shams(), hasOwn = hasown, gOPD$2 = gopd$1, fn;
if (hasToStringTag$3) {
  var $exec$1 = callBound$3("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(B) {
    if (!B || typeof B != "object")
      return !1;
    var L = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD$2(
        /** @type {{ lastIndex?: unknown }} */
        B,
        "lastIndex"
      )
    ), V = L && hasOwn(L, "value");
    if (!V)
      return !1;
    try {
      $exec$1(
        B,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (J) {
      return J === isRegexMarker;
    }
  };
} else {
  var $toString$1 = callBound$3("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(B) {
    return !B || typeof B != "object" && typeof B != "function" ? !1 : $toString$1(B) === regexClass;
  };
}
var isRegex$1 = fn, callBound$2 = callBound$5, isRegex = isRegex$1, $exec = callBound$2("RegExp.prototype.exec"), $TypeError$2 = type, safeRegexTest$1 = function(B) {
  if (!isRegex(B))
    throw new $TypeError$2("`regex` must be a RegExp");
  return function(V) {
    return $exec(B, V) !== null;
  };
}, callBound$1 = callBound$5, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag$2 = shams(), getProto = requireGetProto(), toStr$2 = callBound$1("Object.prototype.toString"), fnToStr$1 = callBound$1("Function.prototype.toString"), getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(B) {
  if (typeof B != "function")
    return !1;
  if (isFnRegex(fnToStr$1(B)))
    return !0;
  if (!hasToStringTag$2) {
    var L = toStr$2(B);
    return L === "[object GeneratorFunction]";
  }
  if (!getProto)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var V = getGeneratorFunc();
    GeneratorFunction = V ? (
      /** @type {GeneratorFunctionConstructor} */
      getProto(V)
    ) : !1;
  }
  return getProto(B) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (A) {
    A !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(B) {
  try {
    var L = fnToStr.call(B);
    return constructorRegex.test(L);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(B) {
  try {
    return isES6ClassFn(B) ? !1 : (fnToStr.call(B), !0);
  } catch {
    return !1;
  }
}, toStr$1 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$1.call(all) === toStr$1.call(document.all) && (isDDA = function(B) {
    if ((isIE68 || !B) && (typeof B > "u" || typeof B == "object"))
      try {
        var L = toStr$1.call(B);
        return (L === ddaClass || L === ddaClass2 || L === ddaClass3 || L === objectClass) && B("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(B) {
  if (isDDA(B))
    return !0;
  if (!B || typeof B != "function" && typeof B != "object")
    return !1;
  try {
    reflectApply(B, null, badArrayLike);
  } catch (L) {
    if (L !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(B) && tryFunctionObject(B);
} : function(B) {
  if (isDDA(B))
    return !0;
  if (!B || typeof B != "function" && typeof B != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(B);
  if (isES6ClassFn(B))
    return !1;
  var L = toStr$1.call(B);
  return L !== fnClass && L !== genClass && !/^\[object HTML/.test(L) ? !1 : tryFunctionObject(B);
}, isCallable = isCallable$1, toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(B, L, V) {
  for (var J = 0, re = B.length; J < re; J++)
    hasOwnProperty.call(B, J) && (V == null ? L(B[J], J, B) : L.call(V, B[J], J, B));
}, forEachString = function(B, L, V) {
  for (var J = 0, re = B.length; J < re; J++)
    V == null ? L(B.charAt(J), J, B) : L.call(V, B.charAt(J), J, B);
}, forEachObject = function(B, L, V) {
  for (var J in B)
    hasOwnProperty.call(B, J) && (V == null ? L(B[J], J, B) : L.call(V, B[J], J, B));
};
function isArray$1(A) {
  return toStr.call(A) === "[object Array]";
}
var forEach$1 = function(B, L, V) {
  if (!isCallable(L))
    throw new TypeError("iterator must be a function");
  var J;
  arguments.length >= 3 && (J = V), isArray$1(B) ? forEachArray(B, L, J) : typeof B == "string" ? forEachString(B, L, J) : forEachObject(B, L, J);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var B = [], L = 0; L < possibleNames.length; L++)
    typeof g$1[possibleNames[L]] == "function" && (B[B.length] = possibleNames[L]);
  return B;
}, callBind$1 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$1 = type, gopd = gopd$1, defineDataProperty = function(B, L, V) {
  if (!B || typeof B != "object" && typeof B != "function")
    throw new $TypeError$1("`obj` must be an object or a function`");
  if (typeof L != "string" && typeof L != "symbol")
    throw new $TypeError$1("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$1("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$1("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$1("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$1("`loose`, if provided, must be a boolean");
  var J = arguments.length > 3 ? arguments[3] : null, re = arguments.length > 4 ? arguments[4] : null, ne = arguments.length > 5 ? arguments[5] : null, ie = arguments.length > 6 ? arguments[6] : !1, pe = !!gopd && gopd(B, L);
  if ($defineProperty$1)
    $defineProperty$1(B, L, {
      configurable: ne === null && pe ? pe.configurable : !ne,
      enumerable: J === null && pe ? pe.enumerable : !J,
      value: V,
      writable: re === null && pe ? pe.writable : !re
    });
  else if (ie || !J && !re && !ne)
    B[L] = V;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError = type, $floor = GetIntrinsic("%Math.floor%"), setFunctionLength = function(B, L) {
  if (typeof B != "function")
    throw new $TypeError("`fn` is not a function");
  if (typeof L != "number" || L < 0 || L > 4294967295 || $floor(L) !== L)
    throw new $TypeError("`length` must be a positive 32-bit integer");
  var V = arguments.length > 2 && !!arguments[2], J = !0, re = !0;
  if ("length" in B && gOPD$1) {
    var ne = gOPD$1(B, "length");
    ne && !ne.configurable && (J = !1), ne && !ne.writable && (re = !1);
  }
  return (J || re || !V) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    B,
    "length",
    L,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    B,
    "length",
    L
  )), B;
}, bind = functionBind, $apply = functionApply, actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
(function(A) {
  var B = setFunctionLength, L = esDefineProperty, V = callBindApplyHelpers, J = applyBind;
  A.exports = function(ne) {
    var ie = V(arguments), pe = ne.length - (arguments.length - 1);
    return B(
      ie,
      1 + (pe > 0 ? pe : 0),
      !0
    );
  }, L ? L(A.exports, "apply", { value: J }) : A.exports.apply = J;
})(callBind$1);
var callBindExports = callBind$1.exports, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind = callBindExports, callBound = callBound$5, gOPD = gopd$1, $toString = callBound("Object.prototype.toString"), hasToStringTag = shams(), g = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound("String.prototype.slice"), getPrototypeOf = Object.getPrototypeOf, $indexOf = callBound("Array.prototype.indexOf", !0) || function(B, L) {
  for (var V = 0; V < B.length; V += 1)
    if (B[V] === L)
      return V;
  return -1;
}, cache = { __proto__: null };
hasToStringTag && gOPD && getPrototypeOf ? forEach(typedArrays, function(A) {
  var B = new g[A]();
  if (Symbol.toStringTag in B) {
    var L = getPrototypeOf(B), V = gOPD(L, Symbol.toStringTag);
    if (!V) {
      var J = getPrototypeOf(L);
      V = gOPD(J, Symbol.toStringTag);
    }
    cache["$" + A] = callBind(V.get);
  }
}) : forEach(typedArrays, function(A) {
  var B = new g[A](), L = B.slice || B.set;
  L && (cache["$" + A] = callBind(L));
});
var tryTypedArrays = function(B) {
  var L = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function(V, J) {
      if (!L)
        try {
          "$" + V(B) === J && (L = $slice(J, 1));
        } catch {
        }
    }
  ), L;
}, trySlices = function(B) {
  var L = !1;
  return forEach(
    // eslint-disable-next-line no-extra-parens
    /** @type {Record<`\$${TypedArrayName}`, Getter>} */
    /** @type {any} */
    cache,
    /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
    function(V, J) {
      if (!L)
        try {
          V(B), L = $slice(J, 1);
        } catch {
        }
    }
  ), L;
}, whichTypedArray$1 = function(B) {
  if (!B || typeof B != "object")
    return !1;
  if (!hasToStringTag) {
    var L = $slice($toString(B), 8, -1);
    return $indexOf(typedArrays, L) > -1 ? L : L !== "Object" ? !1 : trySlices(B);
  }
  return gOPD ? tryTypedArrays(B) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray = function(B) {
  return !!whichTypedArray(B);
};
(function(A) {
  var B = isArguments, L = isGeneratorFunction, V = whichTypedArray$1, J = isTypedArray;
  function re(or) {
    return or.call.bind(or);
  }
  var ne = typeof BigInt < "u", ie = typeof Symbol < "u", pe = re(Object.prototype.toString), nt = re(Number.prototype.valueOf), oe = re(String.prototype.valueOf), Ce = re(Boolean.prototype.valueOf);
  if (ne)
    var at = re(BigInt.prototype.valueOf);
  if (ie)
    var it = re(Symbol.prototype.valueOf);
  function gt(or, Nr) {
    if (typeof or != "object")
      return !1;
    try {
      return Nr(or), !0;
    } catch {
      return !1;
    }
  }
  A.isArgumentsObject = B, A.isGeneratorFunction = L, A.isTypedArray = J;
  function St(or) {
    return typeof Promise < "u" && or instanceof Promise || or !== null && typeof or == "object" && typeof or.then == "function" && typeof or.catch == "function";
  }
  A.isPromise = St;
  function xt(or) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(or) : J(or) || At(or);
  }
  A.isArrayBufferView = xt;
  function Mt(or) {
    return V(or) === "Uint8Array";
  }
  A.isUint8Array = Mt;
  function bt(or) {
    return V(or) === "Uint8ClampedArray";
  }
  A.isUint8ClampedArray = bt;
  function Tt(or) {
    return V(or) === "Uint16Array";
  }
  A.isUint16Array = Tt;
  function It(or) {
    return V(or) === "Uint32Array";
  }
  A.isUint32Array = It;
  function qt(or) {
    return V(or) === "Int8Array";
  }
  A.isInt8Array = qt;
  function Dt(or) {
    return V(or) === "Int16Array";
  }
  A.isInt16Array = Dt;
  function Xt(or) {
    return V(or) === "Int32Array";
  }
  A.isInt32Array = Xt;
  function Bt(or) {
    return V(or) === "Float32Array";
  }
  A.isFloat32Array = Bt;
  function mt(or) {
    return V(or) === "Float64Array";
  }
  A.isFloat64Array = mt;
  function Ot(or) {
    return V(or) === "BigInt64Array";
  }
  A.isBigInt64Array = Ot;
  function wt(or) {
    return V(or) === "BigUint64Array";
  }
  A.isBigUint64Array = wt;
  function ke(or) {
    return pe(or) === "[object Map]";
  }
  ke.working = typeof Map < "u" && ke(/* @__PURE__ */ new Map());
  function rt(or) {
    return typeof Map > "u" ? !1 : ke.working ? ke(or) : or instanceof Map;
  }
  A.isMap = rt;
  function ce(or) {
    return pe(or) === "[object Set]";
  }
  ce.working = typeof Set < "u" && ce(/* @__PURE__ */ new Set());
  function Oe(or) {
    return typeof Set > "u" ? !1 : ce.working ? ce(or) : or instanceof Set;
  }
  A.isSet = Oe;
  function ot(or) {
    return pe(or) === "[object WeakMap]";
  }
  ot.working = typeof WeakMap < "u" && ot(/* @__PURE__ */ new WeakMap());
  function ut(or) {
    return typeof WeakMap > "u" ? !1 : ot.working ? ot(or) : or instanceof WeakMap;
  }
  A.isWeakMap = ut;
  function ht(or) {
    return pe(or) === "[object WeakSet]";
  }
  ht.working = typeof WeakSet < "u" && ht(/* @__PURE__ */ new WeakSet());
  function dt(or) {
    return ht(or);
  }
  A.isWeakSet = dt;
  function st(or) {
    return pe(or) === "[object ArrayBuffer]";
  }
  st.working = typeof ArrayBuffer < "u" && st(new ArrayBuffer());
  function yt(or) {
    return typeof ArrayBuffer > "u" ? !1 : st.working ? st(or) : or instanceof ArrayBuffer;
  }
  A.isArrayBuffer = yt;
  function ct(or) {
    return pe(or) === "[object DataView]";
  }
  ct.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && ct(new DataView(new ArrayBuffer(1), 0, 1));
  function At(or) {
    return typeof DataView > "u" ? !1 : ct.working ? ct(or) : or instanceof DataView;
  }
  A.isDataView = At;
  var Kt = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function Zt(or) {
    return pe(or) === "[object SharedArrayBuffer]";
  }
  function Ht(or) {
    return typeof Kt > "u" ? !1 : (typeof Zt.working > "u" && (Zt.working = Zt(new Kt())), Zt.working ? Zt(or) : or instanceof Kt);
  }
  A.isSharedArrayBuffer = Ht;
  function Pt(or) {
    return pe(or) === "[object AsyncFunction]";
  }
  A.isAsyncFunction = Pt;
  function kt(or) {
    return pe(or) === "[object Map Iterator]";
  }
  A.isMapIterator = kt;
  function Vt(or) {
    return pe(or) === "[object Set Iterator]";
  }
  A.isSetIterator = Vt;
  function tr(or) {
    return pe(or) === "[object Generator]";
  }
  A.isGeneratorObject = tr;
  function Nt(or) {
    return pe(or) === "[object WebAssembly.Module]";
  }
  A.isWebAssemblyCompiledModule = Nt;
  function Ft(or) {
    return gt(or, nt);
  }
  A.isNumberObject = Ft;
  function er(or) {
    return gt(or, oe);
  }
  A.isStringObject = er;
  function fr(or) {
    return gt(or, Ce);
  }
  A.isBooleanObject = fr;
  function cr(or) {
    return ne && gt(or, at);
  }
  A.isBigIntObject = cr;
  function dr(or) {
    return ie && gt(or, it);
  }
  A.isSymbolObject = dr;
  function br(or) {
    return Ft(or) || er(or) || fr(or) || cr(or) || dr(or);
  }
  A.isBoxedPrimitive = br;
  function wr(or) {
    return typeof Uint8Array < "u" && (yt(or) || Ht(or));
  }
  A.isAnyArrayBuffer = wr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(or) {
    Object.defineProperty(A, or, {
      enumerable: !1,
      value: function() {
        throw new Error(or + " is not supported in userland");
      }
    });
  });
})(types$5);
var isBufferBrowser = function(B) {
  return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
};
(function(A) {
  var B = Object.getOwnPropertyDescriptors || function(At) {
    for (var Kt = Object.keys(At), Zt = {}, Ht = 0; Ht < Kt.length; Ht++)
      Zt[Kt[Ht]] = Object.getOwnPropertyDescriptor(At, Kt[Ht]);
    return Zt;
  }, L = /%[sdj%]/g;
  A.format = function(ct) {
    if (!qt(ct)) {
      for (var At = [], Kt = 0; Kt < arguments.length; Kt++)
        At.push(ne(arguments[Kt]));
      return At.join(" ");
    }
    for (var Kt = 1, Zt = arguments, Ht = Zt.length, Pt = String(ct).replace(L, function(Vt) {
      if (Vt === "%%") return "%";
      if (Kt >= Ht) return Vt;
      switch (Vt) {
        case "%s":
          return String(Zt[Kt++]);
        case "%d":
          return Number(Zt[Kt++]);
        case "%j":
          try {
            return JSON.stringify(Zt[Kt++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Vt;
      }
    }), kt = Zt[Kt]; Kt < Ht; kt = Zt[++Kt])
      bt(kt) || !mt(kt) ? Pt += " " + kt : Pt += " " + ne(kt);
    return Pt;
  }, A.deprecate = function(ct, At) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return ct;
    if (typeof process$1 > "u")
      return function() {
        return A.deprecate(ct, At).apply(this, arguments);
      };
    var Kt = !1;
    function Zt() {
      if (!Kt) {
        if (process$1.throwDeprecation)
          throw new Error(At);
        process$1.traceDeprecation ? console.trace(At) : console.error(At), Kt = !0;
      }
      return ct.apply(this, arguments);
    }
    return Zt;
  };
  var V = {}, J = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var re = process$1.env.NODE_DEBUG;
    re = re.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), J = new RegExp("^" + re + "$", "i");
  }
  A.debuglog = function(ct) {
    if (ct = ct.toUpperCase(), !V[ct])
      if (J.test(ct)) {
        var At = process$1.pid;
        V[ct] = function() {
          var Kt = A.format.apply(A, arguments);
          console.error("%s %d: %s", ct, At, Kt);
        };
      } else
        V[ct] = function() {
        };
    return V[ct];
  };
  function ne(ct, At) {
    var Kt = {
      seen: [],
      stylize: pe
    };
    return arguments.length >= 3 && (Kt.depth = arguments[2]), arguments.length >= 4 && (Kt.colors = arguments[3]), Mt(At) ? Kt.showHidden = At : At && A._extend(Kt, At), Xt(Kt.showHidden) && (Kt.showHidden = !1), Xt(Kt.depth) && (Kt.depth = 2), Xt(Kt.colors) && (Kt.colors = !1), Xt(Kt.customInspect) && (Kt.customInspect = !0), Kt.colors && (Kt.stylize = ie), oe(Kt, ct, Kt.depth);
  }
  A.inspect = ne, ne.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, ne.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function ie(ct, At) {
    var Kt = ne.styles[At];
    return Kt ? "\x1B[" + ne.colors[Kt][0] + "m" + ct + "\x1B[" + ne.colors[Kt][1] + "m" : ct;
  }
  function pe(ct, At) {
    return ct;
  }
  function nt(ct) {
    var At = {};
    return ct.forEach(function(Kt, Zt) {
      At[Kt] = !0;
    }), At;
  }
  function oe(ct, At, Kt) {
    if (ct.customInspect && At && ke(At.inspect) && // Filter out the util module, it's inspect function is special
    At.inspect !== A.inspect && // Also filter out any prototype objects using the circular check.
    !(At.constructor && At.constructor.prototype === At)) {
      var Zt = At.inspect(Kt, ct);
      return qt(Zt) || (Zt = oe(ct, Zt, Kt)), Zt;
    }
    var Ht = Ce(ct, At);
    if (Ht)
      return Ht;
    var Pt = Object.keys(At), kt = nt(Pt);
    if (ct.showHidden && (Pt = Object.getOwnPropertyNames(At)), wt(At) && (Pt.indexOf("message") >= 0 || Pt.indexOf("description") >= 0))
      return at(At);
    if (Pt.length === 0) {
      if (ke(At)) {
        var Vt = At.name ? ": " + At.name : "";
        return ct.stylize("[Function" + Vt + "]", "special");
      }
      if (Bt(At))
        return ct.stylize(RegExp.prototype.toString.call(At), "regexp");
      if (Ot(At))
        return ct.stylize(Date.prototype.toString.call(At), "date");
      if (wt(At))
        return at(At);
    }
    var tr = "", Nt = !1, Ft = ["{", "}"];
    if (xt(At) && (Nt = !0, Ft = ["[", "]"]), ke(At)) {
      var er = At.name ? ": " + At.name : "";
      tr = " [Function" + er + "]";
    }
    if (Bt(At) && (tr = " " + RegExp.prototype.toString.call(At)), Ot(At) && (tr = " " + Date.prototype.toUTCString.call(At)), wt(At) && (tr = " " + at(At)), Pt.length === 0 && (!Nt || At.length == 0))
      return Ft[0] + tr + Ft[1];
    if (Kt < 0)
      return Bt(At) ? ct.stylize(RegExp.prototype.toString.call(At), "regexp") : ct.stylize("[Object]", "special");
    ct.seen.push(At);
    var fr;
    return Nt ? fr = it(ct, At, Kt, kt, Pt) : fr = Pt.map(function(cr) {
      return gt(ct, At, Kt, kt, cr, Nt);
    }), ct.seen.pop(), St(fr, tr, Ft);
  }
  function Ce(ct, At) {
    if (Xt(At))
      return ct.stylize("undefined", "undefined");
    if (qt(At)) {
      var Kt = "'" + JSON.stringify(At).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ct.stylize(Kt, "string");
    }
    if (It(At))
      return ct.stylize("" + At, "number");
    if (Mt(At))
      return ct.stylize("" + At, "boolean");
    if (bt(At))
      return ct.stylize("null", "null");
  }
  function at(ct) {
    return "[" + Error.prototype.toString.call(ct) + "]";
  }
  function it(ct, At, Kt, Zt, Ht) {
    for (var Pt = [], kt = 0, Vt = At.length; kt < Vt; ++kt)
      ht(At, String(kt)) ? Pt.push(gt(
        ct,
        At,
        Kt,
        Zt,
        String(kt),
        !0
      )) : Pt.push("");
    return Ht.forEach(function(tr) {
      tr.match(/^\d+$/) || Pt.push(gt(
        ct,
        At,
        Kt,
        Zt,
        tr,
        !0
      ));
    }), Pt;
  }
  function gt(ct, At, Kt, Zt, Ht, Pt) {
    var kt, Vt, tr;
    if (tr = Object.getOwnPropertyDescriptor(At, Ht) || { value: At[Ht] }, tr.get ? tr.set ? Vt = ct.stylize("[Getter/Setter]", "special") : Vt = ct.stylize("[Getter]", "special") : tr.set && (Vt = ct.stylize("[Setter]", "special")), ht(Zt, Ht) || (kt = "[" + Ht + "]"), Vt || (ct.seen.indexOf(tr.value) < 0 ? (bt(Kt) ? Vt = oe(ct, tr.value, null) : Vt = oe(ct, tr.value, Kt - 1), Vt.indexOf(`
`) > -1 && (Pt ? Vt = Vt.split(`
`).map(function(Nt) {
      return "  " + Nt;
    }).join(`
`).slice(2) : Vt = `
` + Vt.split(`
`).map(function(Nt) {
      return "   " + Nt;
    }).join(`
`))) : Vt = ct.stylize("[Circular]", "special")), Xt(kt)) {
      if (Pt && Ht.match(/^\d+$/))
        return Vt;
      kt = JSON.stringify("" + Ht), kt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (kt = kt.slice(1, -1), kt = ct.stylize(kt, "name")) : (kt = kt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), kt = ct.stylize(kt, "string"));
    }
    return kt + ": " + Vt;
  }
  function St(ct, At, Kt) {
    var Zt = ct.reduce(function(Ht, Pt) {
      return Pt.indexOf(`
`) >= 0, Ht + Pt.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return Zt > 60 ? Kt[0] + (At === "" ? "" : At + `
 `) + " " + ct.join(`,
  `) + " " + Kt[1] : Kt[0] + At + " " + ct.join(", ") + " " + Kt[1];
  }
  A.types = types$5;
  function xt(ct) {
    return Array.isArray(ct);
  }
  A.isArray = xt;
  function Mt(ct) {
    return typeof ct == "boolean";
  }
  A.isBoolean = Mt;
  function bt(ct) {
    return ct === null;
  }
  A.isNull = bt;
  function Tt(ct) {
    return ct == null;
  }
  A.isNullOrUndefined = Tt;
  function It(ct) {
    return typeof ct == "number";
  }
  A.isNumber = It;
  function qt(ct) {
    return typeof ct == "string";
  }
  A.isString = qt;
  function Dt(ct) {
    return typeof ct == "symbol";
  }
  A.isSymbol = Dt;
  function Xt(ct) {
    return ct === void 0;
  }
  A.isUndefined = Xt;
  function Bt(ct) {
    return mt(ct) && ce(ct) === "[object RegExp]";
  }
  A.isRegExp = Bt, A.types.isRegExp = Bt;
  function mt(ct) {
    return typeof ct == "object" && ct !== null;
  }
  A.isObject = mt;
  function Ot(ct) {
    return mt(ct) && ce(ct) === "[object Date]";
  }
  A.isDate = Ot, A.types.isDate = Ot;
  function wt(ct) {
    return mt(ct) && (ce(ct) === "[object Error]" || ct instanceof Error);
  }
  A.isError = wt, A.types.isNativeError = wt;
  function ke(ct) {
    return typeof ct == "function";
  }
  A.isFunction = ke;
  function rt(ct) {
    return ct === null || typeof ct == "boolean" || typeof ct == "number" || typeof ct == "string" || typeof ct == "symbol" || // ES6 symbol
    typeof ct > "u";
  }
  A.isPrimitive = rt, A.isBuffer = isBufferBrowser;
  function ce(ct) {
    return Object.prototype.toString.call(ct);
  }
  function Oe(ct) {
    return ct < 10 ? "0" + ct.toString(10) : ct.toString(10);
  }
  var ot = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function ut() {
    var ct = /* @__PURE__ */ new Date(), At = [
      Oe(ct.getHours()),
      Oe(ct.getMinutes()),
      Oe(ct.getSeconds())
    ].join(":");
    return [ct.getDate(), ot[ct.getMonth()], At].join(" ");
  }
  A.log = function() {
    console.log("%s - %s", ut(), A.format.apply(A, arguments));
  }, A.inherits = inherits_browserExports, A._extend = function(ct, At) {
    if (!At || !mt(At)) return ct;
    for (var Kt = Object.keys(At), Zt = Kt.length; Zt--; )
      ct[Kt[Zt]] = At[Kt[Zt]];
    return ct;
  };
  function ht(ct, At) {
    return Object.prototype.hasOwnProperty.call(ct, At);
  }
  var dt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  A.promisify = function(At) {
    if (typeof At != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (dt && At[dt]) {
      var Kt = At[dt];
      if (typeof Kt != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(Kt, dt, {
        value: Kt,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Kt;
    }
    function Kt() {
      for (var Zt, Ht, Pt = new Promise(function(tr, Nt) {
        Zt = tr, Ht = Nt;
      }), kt = [], Vt = 0; Vt < arguments.length; Vt++)
        kt.push(arguments[Vt]);
      kt.push(function(tr, Nt) {
        tr ? Ht(tr) : Zt(Nt);
      });
      try {
        At.apply(this, kt);
      } catch (tr) {
        Ht(tr);
      }
      return Pt;
    }
    return Object.setPrototypeOf(Kt, Object.getPrototypeOf(At)), dt && Object.defineProperty(Kt, dt, {
      value: Kt,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      Kt,
      B(At)
    );
  }, A.promisify.custom = dt;
  function st(ct, At) {
    if (!ct) {
      var Kt = new Error("Promise was rejected with a falsy value");
      Kt.reason = ct, ct = Kt;
    }
    return At(ct);
  }
  function yt(ct) {
    if (typeof ct != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function At() {
      for (var Kt = [], Zt = 0; Zt < arguments.length; Zt++)
        Kt.push(arguments[Zt]);
      var Ht = Kt.pop();
      if (typeof Ht != "function")
        throw new TypeError("The last argument must be of type Function");
      var Pt = this, kt = function() {
        return Ht.apply(Pt, arguments);
      };
      ct.apply(this, Kt).then(
        function(Vt) {
          process$1.nextTick(kt.bind(null, null, Vt));
        },
        function(Vt) {
          process$1.nextTick(st.bind(null, Vt, kt));
        }
      );
    }
    return Object.setPrototypeOf(At, Object.getPrototypeOf(ct)), Object.defineProperties(
      At,
      B(ct)
    ), At;
  }
  A.callbackify = yt;
})(util$3);
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function A(gt, St) {
    var xt = Object.keys(gt);
    if (Object.getOwnPropertySymbols) {
      var Mt = Object.getOwnPropertySymbols(gt);
      St && (Mt = Mt.filter(function(bt) {
        return Object.getOwnPropertyDescriptor(gt, bt).enumerable;
      })), xt.push.apply(xt, Mt);
    }
    return xt;
  }
  function B(gt) {
    for (var St = 1; St < arguments.length; St++) {
      var xt = arguments[St] != null ? arguments[St] : {};
      St % 2 ? A(Object(xt), !0).forEach(function(Mt) {
        L(gt, Mt, xt[Mt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(gt, Object.getOwnPropertyDescriptors(xt)) : A(Object(xt)).forEach(function(Mt) {
        Object.defineProperty(gt, Mt, Object.getOwnPropertyDescriptor(xt, Mt));
      });
    }
    return gt;
  }
  function L(gt, St, xt) {
    return St = ne(St), St in gt ? Object.defineProperty(gt, St, { value: xt, enumerable: !0, configurable: !0, writable: !0 }) : gt[St] = xt, gt;
  }
  function V(gt, St) {
    if (!(gt instanceof St))
      throw new TypeError("Cannot call a class as a function");
  }
  function J(gt, St) {
    for (var xt = 0; xt < St.length; xt++) {
      var Mt = St[xt];
      Mt.enumerable = Mt.enumerable || !1, Mt.configurable = !0, "value" in Mt && (Mt.writable = !0), Object.defineProperty(gt, ne(Mt.key), Mt);
    }
  }
  function re(gt, St, xt) {
    return St && J(gt.prototype, St), Object.defineProperty(gt, "prototype", { writable: !1 }), gt;
  }
  function ne(gt) {
    var St = ie(gt, "string");
    return typeof St == "symbol" ? St : String(St);
  }
  function ie(gt, St) {
    if (typeof gt != "object" || gt === null) return gt;
    var xt = gt[Symbol.toPrimitive];
    if (xt !== void 0) {
      var Mt = xt.call(gt, St);
      if (typeof Mt != "object") return Mt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(gt);
  }
  var pe = dist$1, nt = pe.Buffer, oe = util$3, Ce = oe.inspect, at = Ce && Ce.custom || "inspect";
  function it(gt, St, xt) {
    nt.prototype.copy.call(gt, St, xt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function gt() {
      V(this, gt), this.head = null, this.tail = null, this.length = 0;
    }
    return re(gt, [{
      key: "push",
      value: function(xt) {
        var Mt = {
          data: xt,
          next: null
        };
        this.length > 0 ? this.tail.next = Mt : this.head = Mt, this.tail = Mt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(xt) {
        var Mt = {
          data: xt,
          next: this.head
        };
        this.length === 0 && (this.tail = Mt), this.head = Mt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var xt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, xt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(xt) {
        if (this.length === 0) return "";
        for (var Mt = this.head, bt = "" + Mt.data; Mt = Mt.next; ) bt += xt + Mt.data;
        return bt;
      }
    }, {
      key: "concat",
      value: function(xt) {
        if (this.length === 0) return nt.alloc(0);
        for (var Mt = nt.allocUnsafe(xt >>> 0), bt = this.head, Tt = 0; bt; )
          it(bt.data, Mt, Tt), Tt += bt.data.length, bt = bt.next;
        return Mt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(xt, Mt) {
        var bt;
        return xt < this.head.data.length ? (bt = this.head.data.slice(0, xt), this.head.data = this.head.data.slice(xt)) : xt === this.head.data.length ? bt = this.shift() : bt = Mt ? this._getString(xt) : this._getBuffer(xt), bt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(xt) {
        var Mt = this.head, bt = 1, Tt = Mt.data;
        for (xt -= Tt.length; Mt = Mt.next; ) {
          var It = Mt.data, qt = xt > It.length ? It.length : xt;
          if (qt === It.length ? Tt += It : Tt += It.slice(0, xt), xt -= qt, xt === 0) {
            qt === It.length ? (++bt, Mt.next ? this.head = Mt.next : this.head = this.tail = null) : (this.head = Mt, Mt.data = It.slice(qt));
            break;
          }
          ++bt;
        }
        return this.length -= bt, Tt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(xt) {
        var Mt = nt.allocUnsafe(xt), bt = this.head, Tt = 1;
        for (bt.data.copy(Mt), xt -= bt.data.length; bt = bt.next; ) {
          var It = bt.data, qt = xt > It.length ? It.length : xt;
          if (It.copy(Mt, Mt.length - xt, 0, qt), xt -= qt, xt === 0) {
            qt === It.length ? (++Tt, bt.next ? this.head = bt.next : this.head = this.tail = null) : (this.head = bt, bt.data = It.slice(qt));
            break;
          }
          ++Tt;
        }
        return this.length -= Tt, Mt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: at,
      value: function(xt, Mt) {
        return Ce(this, B(B({}, Mt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), gt;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  function A(ne, ie) {
    var pe = this, nt = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
    return nt || oe ? (ie ? ie(ne) : ne && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(J, this, ne)) : process$1.nextTick(J, this, ne)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(ne || null, function(Ce) {
      !ie && Ce ? pe._writableState ? pe._writableState.errorEmitted ? process$1.nextTick(L, pe) : (pe._writableState.errorEmitted = !0, process$1.nextTick(B, pe, Ce)) : process$1.nextTick(B, pe, Ce) : ie ? (process$1.nextTick(L, pe), ie(Ce)) : process$1.nextTick(L, pe);
    }), this);
  }
  function B(ne, ie) {
    J(ne, ie), L(ne);
  }
  function L(ne) {
    ne._writableState && !ne._writableState.emitClose || ne._readableState && !ne._readableState.emitClose || ne.emit("close");
  }
  function V() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function J(ne, ie) {
    ne.emit("error", ie);
  }
  function re(ne, ie) {
    var pe = ne._readableState, nt = ne._writableState;
    pe && pe.autoDestroy || nt && nt.autoDestroy ? ne.destroy(ie) : ne.emit("error", ie);
  }
  return destroy_1$1 = {
    destroy: A,
    undestroy: V,
    errorOrDestroy: re
  }, destroy_1$1;
}
var errorsBrowser = {};
function _inheritsLoose(A, B) {
  A.prototype = Object.create(B.prototype), A.prototype.constructor = A, A.__proto__ = B;
}
var codes = {};
function createErrorType(A, B, L) {
  L || (L = Error);
  function V(re, ne, ie) {
    return typeof B == "string" ? B : B(re, ne, ie);
  }
  var J = /* @__PURE__ */ function(re) {
    _inheritsLoose(ne, re);
    function ne(ie, pe, nt) {
      return re.call(this, V(ie, pe, nt)) || this;
    }
    return ne;
  }(L);
  J.prototype.name = L.name, J.prototype.code = A, codes[A] = J;
}
function oneOf(A, B) {
  if (Array.isArray(A)) {
    var L = A.length;
    return A = A.map(function(V) {
      return String(V);
    }), L > 2 ? "one of ".concat(B, " ").concat(A.slice(0, L - 1).join(", "), ", or ") + A[L - 1] : L === 2 ? "one of ".concat(B, " ").concat(A[0], " or ").concat(A[1]) : "of ".concat(B, " ").concat(A[0]);
  } else
    return "of ".concat(B, " ").concat(String(A));
}
function startsWith(A, B, L) {
  return A.substr(0, B.length) === B;
}
function endsWith(A, B, L) {
  return (L === void 0 || L > A.length) && (L = A.length), A.substring(L - B.length, L) === B;
}
function includes(A, B, L) {
  return typeof L != "number" && (L = 0), L + B.length > A.length ? !1 : A.indexOf(B, L) !== -1;
}
createErrorType("ERR_INVALID_OPT_VALUE", function(A, B) {
  return 'The value "' + B + '" is invalid for option "' + A + '"';
}, TypeError);
createErrorType("ERR_INVALID_ARG_TYPE", function(A, B, L) {
  var V;
  typeof B == "string" && startsWith(B, "not ") ? (V = "must not be", B = B.replace(/^not /, "")) : V = "must be";
  var J;
  if (endsWith(A, " argument"))
    J = "The ".concat(A, " ").concat(V, " ").concat(oneOf(B, "type"));
  else {
    var re = includes(A, ".") ? "property" : "argument";
    J = 'The "'.concat(A, '" ').concat(re, " ").concat(V, " ").concat(oneOf(B, "type"));
  }
  return J += ". Received type ".concat(typeof L), J;
}, TypeError);
createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(A) {
  return "The " + A + " method is not implemented";
});
createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
createErrorType("ERR_STREAM_DESTROYED", function(A) {
  return "Cannot call " + A + " after a stream was destroyed";
});
createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
createErrorType("ERR_UNKNOWN_ENCODING", function(A) {
  return "Unknown encoding: " + A;
}, TypeError);
createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
errorsBrowser.codes = codes;
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var A = errorsBrowser.codes.ERR_INVALID_OPT_VALUE;
  function B(V, J, re) {
    return V.highWaterMark != null ? V.highWaterMark : J ? V[re] : null;
  }
  function L(V, J, re, ne) {
    var ie = B(J, ne, re);
    if (ie != null) {
      if (!(isFinite(ie) && Math.floor(ie) === ie) || ie < 0) {
        var pe = ne ? re : "highWaterMark";
        throw new A(pe, ie);
      }
      return Math.floor(ie);
    }
    return V.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: L
  }, state;
}
var browser$a = deprecate;
function deprecate(A, B) {
  if (config("noDeprecation"))
    return A;
  var L = !1;
  function V() {
    if (!L) {
      if (config("throwDeprecation"))
        throw new Error(B);
      config("traceDeprecation") ? console.trace(B) : console.warn(B), L = !0;
    }
    return A.apply(this, arguments);
  }
  return V;
}
function config(A) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var B = commonjsGlobal.localStorage[A];
  return B == null ? !1 : String(B).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Bt;
  function A(Ht) {
    var Pt = this;
    this.next = null, this.entry = null, this.finish = function() {
      Zt(Pt, Ht);
    };
  }
  var B;
  Bt.WritableState = Dt;
  var L = {
    deprecate: browser$a
  }, V = requireStreamBrowser(), J = dist$1.Buffer, re = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ne(Ht) {
    return J.from(Ht);
  }
  function ie(Ht) {
    return J.isBuffer(Ht) || Ht instanceof re;
  }
  var pe = requireDestroy(), nt = requireState(), oe = nt.getHighWaterMark, Ce = errorsBrowser.codes, at = Ce.ERR_INVALID_ARG_TYPE, it = Ce.ERR_METHOD_NOT_IMPLEMENTED, gt = Ce.ERR_MULTIPLE_CALLBACK, St = Ce.ERR_STREAM_CANNOT_PIPE, xt = Ce.ERR_STREAM_DESTROYED, Mt = Ce.ERR_STREAM_NULL_VALUES, bt = Ce.ERR_STREAM_WRITE_AFTER_END, Tt = Ce.ERR_UNKNOWN_ENCODING, It = pe.errorOrDestroy;
  inherits_browserExports(Bt, V);
  function qt() {
  }
  function Dt(Ht, Pt, kt) {
    B = B || require_stream_duplex$1(), Ht = Ht || {}, typeof kt != "boolean" && (kt = Pt instanceof B), this.objectMode = !!Ht.objectMode, kt && (this.objectMode = this.objectMode || !!Ht.writableObjectMode), this.highWaterMark = oe(this, Ht, "writableHighWaterMark", kt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Vt = Ht.decodeStrings === !1;
    this.decodeStrings = !Vt, this.defaultEncoding = Ht.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(tr) {
      ot(Pt, tr);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Ht.emitClose !== !1, this.autoDestroy = !!Ht.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
  }
  Dt.prototype.getBuffer = function() {
    for (var Pt = this.bufferedRequest, kt = []; Pt; )
      kt.push(Pt), Pt = Pt.next;
    return kt;
  }, function() {
    try {
      Object.defineProperty(Dt.prototype, "buffer", {
        get: L.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Xt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Xt = Function.prototype[Symbol.hasInstance], Object.defineProperty(Bt, Symbol.hasInstance, {
    value: function(Pt) {
      return Xt.call(this, Pt) ? !0 : this !== Bt ? !1 : Pt && Pt._writableState instanceof Dt;
    }
  })) : Xt = function(Pt) {
    return Pt instanceof this;
  };
  function Bt(Ht) {
    B = B || require_stream_duplex$1();
    var Pt = this instanceof B;
    if (!Pt && !Xt.call(Bt, this)) return new Bt(Ht);
    this._writableState = new Dt(Ht, this, Pt), this.writable = !0, Ht && (typeof Ht.write == "function" && (this._write = Ht.write), typeof Ht.writev == "function" && (this._writev = Ht.writev), typeof Ht.destroy == "function" && (this._destroy = Ht.destroy), typeof Ht.final == "function" && (this._final = Ht.final)), V.call(this);
  }
  Bt.prototype.pipe = function() {
    It(this, new St());
  };
  function mt(Ht, Pt) {
    var kt = new bt();
    It(Ht, kt), process$1.nextTick(Pt, kt);
  }
  function Ot(Ht, Pt, kt, Vt) {
    var tr;
    return kt === null ? tr = new Mt() : typeof kt != "string" && !Pt.objectMode && (tr = new at("chunk", ["string", "Buffer"], kt)), tr ? (It(Ht, tr), process$1.nextTick(Vt, tr), !1) : !0;
  }
  Bt.prototype.write = function(Ht, Pt, kt) {
    var Vt = this._writableState, tr = !1, Nt = !Vt.objectMode && ie(Ht);
    return Nt && !J.isBuffer(Ht) && (Ht = ne(Ht)), typeof Pt == "function" && (kt = Pt, Pt = null), Nt ? Pt = "buffer" : Pt || (Pt = Vt.defaultEncoding), typeof kt != "function" && (kt = qt), Vt.ending ? mt(this, kt) : (Nt || Ot(this, Vt, Ht, kt)) && (Vt.pendingcb++, tr = ke(this, Vt, Nt, Ht, Pt, kt)), tr;
  }, Bt.prototype.cork = function() {
    this._writableState.corked++;
  }, Bt.prototype.uncork = function() {
    var Ht = this._writableState;
    Ht.corked && (Ht.corked--, !Ht.writing && !Ht.corked && !Ht.bufferProcessing && Ht.bufferedRequest && dt(this, Ht));
  }, Bt.prototype.setDefaultEncoding = function(Pt) {
    if (typeof Pt == "string" && (Pt = Pt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Pt + "").toLowerCase()) > -1)) throw new Tt(Pt);
    return this._writableState.defaultEncoding = Pt, this;
  }, Object.defineProperty(Bt.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function wt(Ht, Pt, kt) {
    return !Ht.objectMode && Ht.decodeStrings !== !1 && typeof Pt == "string" && (Pt = J.from(Pt, kt)), Pt;
  }
  Object.defineProperty(Bt.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ke(Ht, Pt, kt, Vt, tr, Nt) {
    if (!kt) {
      var Ft = wt(Pt, Vt, tr);
      Vt !== Ft && (kt = !0, tr = "buffer", Vt = Ft);
    }
    var er = Pt.objectMode ? 1 : Vt.length;
    Pt.length += er;
    var fr = Pt.length < Pt.highWaterMark;
    if (fr || (Pt.needDrain = !0), Pt.writing || Pt.corked) {
      var cr = Pt.lastBufferedRequest;
      Pt.lastBufferedRequest = {
        chunk: Vt,
        encoding: tr,
        isBuf: kt,
        callback: Nt,
        next: null
      }, cr ? cr.next = Pt.lastBufferedRequest : Pt.bufferedRequest = Pt.lastBufferedRequest, Pt.bufferedRequestCount += 1;
    } else
      rt(Ht, Pt, !1, er, Vt, tr, Nt);
    return fr;
  }
  function rt(Ht, Pt, kt, Vt, tr, Nt, Ft) {
    Pt.writelen = Vt, Pt.writecb = Ft, Pt.writing = !0, Pt.sync = !0, Pt.destroyed ? Pt.onwrite(new xt("write")) : kt ? Ht._writev(tr, Pt.onwrite) : Ht._write(tr, Nt, Pt.onwrite), Pt.sync = !1;
  }
  function ce(Ht, Pt, kt, Vt, tr) {
    --Pt.pendingcb, kt ? (process$1.nextTick(tr, Vt), process$1.nextTick(At, Ht, Pt), Ht._writableState.errorEmitted = !0, It(Ht, Vt)) : (tr(Vt), Ht._writableState.errorEmitted = !0, It(Ht, Vt), At(Ht, Pt));
  }
  function Oe(Ht) {
    Ht.writing = !1, Ht.writecb = null, Ht.length -= Ht.writelen, Ht.writelen = 0;
  }
  function ot(Ht, Pt) {
    var kt = Ht._writableState, Vt = kt.sync, tr = kt.writecb;
    if (typeof tr != "function") throw new gt();
    if (Oe(kt), Pt) ce(Ht, kt, Vt, Pt, tr);
    else {
      var Nt = st(kt) || Ht.destroyed;
      !Nt && !kt.corked && !kt.bufferProcessing && kt.bufferedRequest && dt(Ht, kt), Vt ? process$1.nextTick(ut, Ht, kt, Nt, tr) : ut(Ht, kt, Nt, tr);
    }
  }
  function ut(Ht, Pt, kt, Vt) {
    kt || ht(Ht, Pt), Pt.pendingcb--, Vt(), At(Ht, Pt);
  }
  function ht(Ht, Pt) {
    Pt.length === 0 && Pt.needDrain && (Pt.needDrain = !1, Ht.emit("drain"));
  }
  function dt(Ht, Pt) {
    Pt.bufferProcessing = !0;
    var kt = Pt.bufferedRequest;
    if (Ht._writev && kt && kt.next) {
      var Vt = Pt.bufferedRequestCount, tr = new Array(Vt), Nt = Pt.corkedRequestsFree;
      Nt.entry = kt;
      for (var Ft = 0, er = !0; kt; )
        tr[Ft] = kt, kt.isBuf || (er = !1), kt = kt.next, Ft += 1;
      tr.allBuffers = er, rt(Ht, Pt, !0, Pt.length, tr, "", Nt.finish), Pt.pendingcb++, Pt.lastBufferedRequest = null, Nt.next ? (Pt.corkedRequestsFree = Nt.next, Nt.next = null) : Pt.corkedRequestsFree = new A(Pt), Pt.bufferedRequestCount = 0;
    } else {
      for (; kt; ) {
        var fr = kt.chunk, cr = kt.encoding, dr = kt.callback, br = Pt.objectMode ? 1 : fr.length;
        if (rt(Ht, Pt, !1, br, fr, cr, dr), kt = kt.next, Pt.bufferedRequestCount--, Pt.writing)
          break;
      }
      kt === null && (Pt.lastBufferedRequest = null);
    }
    Pt.bufferedRequest = kt, Pt.bufferProcessing = !1;
  }
  Bt.prototype._write = function(Ht, Pt, kt) {
    kt(new it("_write()"));
  }, Bt.prototype._writev = null, Bt.prototype.end = function(Ht, Pt, kt) {
    var Vt = this._writableState;
    return typeof Ht == "function" ? (kt = Ht, Ht = null, Pt = null) : typeof Pt == "function" && (kt = Pt, Pt = null), Ht != null && this.write(Ht, Pt), Vt.corked && (Vt.corked = 1, this.uncork()), Vt.ending || Kt(this, Vt, kt), this;
  }, Object.defineProperty(Bt.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function st(Ht) {
    return Ht.ending && Ht.length === 0 && Ht.bufferedRequest === null && !Ht.finished && !Ht.writing;
  }
  function yt(Ht, Pt) {
    Ht._final(function(kt) {
      Pt.pendingcb--, kt && It(Ht, kt), Pt.prefinished = !0, Ht.emit("prefinish"), At(Ht, Pt);
    });
  }
  function ct(Ht, Pt) {
    !Pt.prefinished && !Pt.finalCalled && (typeof Ht._final == "function" && !Pt.destroyed ? (Pt.pendingcb++, Pt.finalCalled = !0, process$1.nextTick(yt, Ht, Pt)) : (Pt.prefinished = !0, Ht.emit("prefinish")));
  }
  function At(Ht, Pt) {
    var kt = st(Pt);
    if (kt && (ct(Ht, Pt), Pt.pendingcb === 0 && (Pt.finished = !0, Ht.emit("finish"), Pt.autoDestroy))) {
      var Vt = Ht._readableState;
      (!Vt || Vt.autoDestroy && Vt.endEmitted) && Ht.destroy();
    }
    return kt;
  }
  function Kt(Ht, Pt, kt) {
    Pt.ending = !0, At(Ht, Pt), kt && (Pt.finished ? process$1.nextTick(kt) : Ht.once("finish", kt)), Pt.ended = !0, Ht.writable = !1;
  }
  function Zt(Ht, Pt, kt) {
    var Vt = Ht.entry;
    for (Ht.entry = null; Vt; ) {
      var tr = Vt.callback;
      Pt.pendingcb--, tr(kt), Vt = Vt.next;
    }
    Pt.corkedRequestsFree.next = Ht;
  }
  return Object.defineProperty(Bt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Pt) {
      this._writableState && (this._writableState.destroyed = Pt);
    }
  }), Bt.prototype.destroy = pe.destroy, Bt.prototype._undestroy = pe.undestroy, Bt.prototype._destroy = function(Ht, Pt) {
    Pt(Ht);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var A = Object.keys || function(nt) {
    var oe = [];
    for (var Ce in nt) oe.push(Ce);
    return oe;
  };
  _stream_duplex$1 = ne;
  var B = require_stream_readable$1(), L = require_stream_writable$1();
  inherits_browserExports(ne, B);
  for (var V = A(L.prototype), J = 0; J < V.length; J++) {
    var re = V[J];
    ne.prototype[re] || (ne.prototype[re] = L.prototype[re]);
  }
  function ne(nt) {
    if (!(this instanceof ne)) return new ne(nt);
    B.call(this, nt), L.call(this, nt), this.allowHalfOpen = !0, nt && (nt.readable === !1 && (this.readable = !1), nt.writable === !1 && (this.writable = !1), nt.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ie)));
  }
  Object.defineProperty(ne.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(ne.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(ne.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ie() {
    this._writableState.ended || process$1.nextTick(pe, this);
  }
  function pe(nt) {
    nt.end();
  }
  return Object.defineProperty(ne.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(oe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = oe, this._writableState.destroyed = oe);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, Buffer$B = safeBufferExports$1.Buffer, isEncoding = Buffer$B.isEncoding || function(A) {
  switch (A = "" + A, A && A.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(A) {
  if (!A) return "utf8";
  for (var B; ; )
    switch (A) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return A;
      default:
        if (B) return;
        A = ("" + A).toLowerCase(), B = !0;
    }
}
function normalizeEncoding(A) {
  var B = _normalizeEncoding(A);
  if (typeof B != "string" && (Buffer$B.isEncoding === isEncoding || !isEncoding(A))) throw new Error("Unknown encoding: " + A);
  return B || A;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(A) {
  this.encoding = normalizeEncoding(A);
  var B;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, B = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, B = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, B = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$B.allocUnsafe(B);
}
StringDecoder$1.prototype.write = function(A) {
  if (A.length === 0) return "";
  var B, L;
  if (this.lastNeed) {
    if (B = this.fillLast(A), B === void 0) return "";
    L = this.lastNeed, this.lastNeed = 0;
  } else
    L = 0;
  return L < A.length ? B ? B + this.text(A, L) : this.text(A, L) : B || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(A) {
  if (this.lastNeed <= A.length)
    return A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, A.length), this.lastNeed -= A.length;
};
function utf8CheckByte(A) {
  return A <= 127 ? 0 : A >> 5 === 6 ? 2 : A >> 4 === 14 ? 3 : A >> 3 === 30 ? 4 : A >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(A, B, L) {
  var V = B.length - 1;
  if (V < L) return 0;
  var J = utf8CheckByte(B[V]);
  return J >= 0 ? (J > 0 && (A.lastNeed = J - 1), J) : --V < L || J === -2 ? 0 : (J = utf8CheckByte(B[V]), J >= 0 ? (J > 0 && (A.lastNeed = J - 2), J) : --V < L || J === -2 ? 0 : (J = utf8CheckByte(B[V]), J >= 0 ? (J > 0 && (J === 2 ? J = 0 : A.lastNeed = J - 3), J) : 0));
}
function utf8CheckExtraBytes(A, B, L) {
  if ((B[0] & 192) !== 128)
    return A.lastNeed = 0, "�";
  if (A.lastNeed > 1 && B.length > 1) {
    if ((B[1] & 192) !== 128)
      return A.lastNeed = 1, "�";
    if (A.lastNeed > 2 && B.length > 2 && (B[2] & 192) !== 128)
      return A.lastNeed = 2, "�";
  }
}
function utf8FillLast(A) {
  var B = this.lastTotal - this.lastNeed, L = utf8CheckExtraBytes(this, A);
  if (L !== void 0) return L;
  if (this.lastNeed <= A.length)
    return A.copy(this.lastChar, B, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  A.copy(this.lastChar, B, 0, A.length), this.lastNeed -= A.length;
}
function utf8Text(A, B) {
  var L = utf8CheckIncomplete(this, A, B);
  if (!this.lastNeed) return A.toString("utf8", B);
  this.lastTotal = L;
  var V = A.length - (L - this.lastNeed);
  return A.copy(this.lastChar, 0, V), A.toString("utf8", B, V);
}
function utf8End(A) {
  var B = A && A.length ? this.write(A) : "";
  return this.lastNeed ? B + "�" : B;
}
function utf16Text(A, B) {
  if ((A.length - B) % 2 === 0) {
    var L = A.toString("utf16le", B);
    if (L) {
      var V = L.charCodeAt(L.length - 1);
      if (V >= 55296 && V <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = A[A.length - 2], this.lastChar[1] = A[A.length - 1], L.slice(0, -1);
    }
    return L;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = A[A.length - 1], A.toString("utf16le", B, A.length - 1);
}
function utf16End(A) {
  var B = A && A.length ? this.write(A) : "";
  if (this.lastNeed) {
    var L = this.lastTotal - this.lastNeed;
    return B + this.lastChar.toString("utf16le", 0, L);
  }
  return B;
}
function base64Text(A, B) {
  var L = (A.length - B) % 3;
  return L === 0 ? A.toString("base64", B) : (this.lastNeed = 3 - L, this.lastTotal = 3, L === 1 ? this.lastChar[0] = A[A.length - 1] : (this.lastChar[0] = A[A.length - 2], this.lastChar[1] = A[A.length - 1]), A.toString("base64", B, A.length - L));
}
function base64End(A) {
  var B = A && A.length ? this.write(A) : "";
  return this.lastNeed ? B + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : B;
}
function simpleWrite(A) {
  return A.toString(this.encoding);
}
function simpleEnd(A) {
  return A && A.length ? this.write(A) : "";
}
var ERR_STREAM_PREMATURE_CLOSE = errorsBrowser.codes.ERR_STREAM_PREMATURE_CLOSE;
function once(A) {
  var B = !1;
  return function() {
    if (!B) {
      B = !0;
      for (var L = arguments.length, V = new Array(L), J = 0; J < L; J++)
        V[J] = arguments[J];
      A.apply(this, V);
    }
  };
}
function noop() {
}
function isRequest(A) {
  return A.setHeader && typeof A.abort == "function";
}
function eos(A, B, L) {
  if (typeof B == "function") return eos(A, null, B);
  B || (B = {}), L = once(L || noop);
  var V = B.readable || B.readable !== !1 && A.readable, J = B.writable || B.writable !== !1 && A.writable, re = function() {
    A.writable || ie();
  }, ne = A._writableState && A._writableState.finished, ie = function() {
    J = !1, ne = !0, V || L.call(A);
  }, pe = A._readableState && A._readableState.endEmitted, nt = function() {
    V = !1, pe = !0, J || L.call(A);
  }, oe = function(gt) {
    L.call(A, gt);
  }, Ce = function() {
    var gt;
    if (V && !pe)
      return (!A._readableState || !A._readableState.ended) && (gt = new ERR_STREAM_PREMATURE_CLOSE()), L.call(A, gt);
    if (J && !ne)
      return (!A._writableState || !A._writableState.ended) && (gt = new ERR_STREAM_PREMATURE_CLOSE()), L.call(A, gt);
  }, at = function() {
    A.req.on("finish", ie);
  };
  return isRequest(A) ? (A.on("complete", ie), A.on("abort", Ce), A.req ? at() : A.on("request", at)) : J && !A._writableState && (A.on("end", re), A.on("close", re)), A.on("end", nt), A.on("finish", ie), B.error !== !1 && A.on("error", oe), A.on("close", Ce), function() {
    A.removeListener("complete", ie), A.removeListener("abort", Ce), A.removeListener("request", at), A.req && A.req.removeListener("finish", ie), A.removeListener("end", re), A.removeListener("close", re), A.removeListener("finish", ie), A.removeListener("end", nt), A.removeListener("error", oe), A.removeListener("close", Ce);
  };
}
var endOfStream = eos, async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var A;
  function B(Tt, It, qt) {
    return It = L(It), It in Tt ? Object.defineProperty(Tt, It, { value: qt, enumerable: !0, configurable: !0, writable: !0 }) : Tt[It] = qt, Tt;
  }
  function L(Tt) {
    var It = V(Tt, "string");
    return typeof It == "symbol" ? It : String(It);
  }
  function V(Tt, It) {
    if (typeof Tt != "object" || Tt === null) return Tt;
    var qt = Tt[Symbol.toPrimitive];
    if (qt !== void 0) {
      var Dt = qt.call(Tt, It);
      if (typeof Dt != "object") return Dt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (It === "string" ? String : Number)(Tt);
  }
  var J = endOfStream, re = Symbol("lastResolve"), ne = Symbol("lastReject"), ie = Symbol("error"), pe = Symbol("ended"), nt = Symbol("lastPromise"), oe = Symbol("handlePromise"), Ce = Symbol("stream");
  function at(Tt, It) {
    return {
      value: Tt,
      done: It
    };
  }
  function it(Tt) {
    var It = Tt[re];
    if (It !== null) {
      var qt = Tt[Ce].read();
      qt !== null && (Tt[nt] = null, Tt[re] = null, Tt[ne] = null, It(at(qt, !1)));
    }
  }
  function gt(Tt) {
    process$1.nextTick(it, Tt);
  }
  function St(Tt, It) {
    return function(qt, Dt) {
      Tt.then(function() {
        if (It[pe]) {
          qt(at(void 0, !0));
          return;
        }
        It[oe](qt, Dt);
      }, Dt);
    };
  }
  var xt = Object.getPrototypeOf(function() {
  }), Mt = Object.setPrototypeOf((A = {
    get stream() {
      return this[Ce];
    },
    next: function() {
      var It = this, qt = this[ie];
      if (qt !== null)
        return Promise.reject(qt);
      if (this[pe])
        return Promise.resolve(at(void 0, !0));
      if (this[Ce].destroyed)
        return new Promise(function(mt, Ot) {
          process$1.nextTick(function() {
            It[ie] ? Ot(It[ie]) : mt(at(void 0, !0));
          });
        });
      var Dt = this[nt], Xt;
      if (Dt)
        Xt = new Promise(St(Dt, this));
      else {
        var Bt = this[Ce].read();
        if (Bt !== null)
          return Promise.resolve(at(Bt, !1));
        Xt = new Promise(this[oe]);
      }
      return this[nt] = Xt, Xt;
    }
  }, B(A, Symbol.asyncIterator, function() {
    return this;
  }), B(A, "return", function() {
    var It = this;
    return new Promise(function(qt, Dt) {
      It[Ce].destroy(null, function(Xt) {
        if (Xt) {
          Dt(Xt);
          return;
        }
        qt(at(void 0, !0));
      });
    });
  }), A), xt), bt = function(It) {
    var qt, Dt = Object.create(Mt, (qt = {}, B(qt, Ce, {
      value: It,
      writable: !0
    }), B(qt, re, {
      value: null,
      writable: !0
    }), B(qt, ne, {
      value: null,
      writable: !0
    }), B(qt, ie, {
      value: null,
      writable: !0
    }), B(qt, pe, {
      value: It._readableState.endEmitted,
      writable: !0
    }), B(qt, oe, {
      value: function(Bt, mt) {
        var Ot = Dt[Ce].read();
        Ot ? (Dt[nt] = null, Dt[re] = null, Dt[ne] = null, Bt(at(Ot, !1))) : (Dt[re] = Bt, Dt[ne] = mt);
      },
      writable: !0
    }), qt));
    return Dt[nt] = null, J(It, function(Xt) {
      if (Xt && Xt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Bt = Dt[ne];
        Bt !== null && (Dt[nt] = null, Dt[re] = null, Dt[ne] = null, Bt(Xt)), Dt[ie] = Xt;
        return;
      }
      var mt = Dt[re];
      mt !== null && (Dt[nt] = null, Dt[re] = null, Dt[ne] = null, mt(at(void 0, !0))), Dt[pe] = !0;
    }), It.on("readable", gt.bind(null, Dt)), Dt;
  };
  return async_iterator = bt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = mt;
  var A;
  mt.ReadableState = Bt, eventsExports.EventEmitter;
  var B = function(Ft, er) {
    return Ft.listeners(er).length;
  }, L = requireStreamBrowser(), V = dist$1.Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function re(Nt) {
    return V.from(Nt);
  }
  function ne(Nt) {
    return V.isBuffer(Nt) || Nt instanceof J;
  }
  var ie = util$3, pe;
  ie && ie.debuglog ? pe = ie.debuglog("stream") : pe = function() {
  };
  var nt = requireBuffer_list(), oe = requireDestroy(), Ce = requireState(), at = Ce.getHighWaterMark, it = errorsBrowser.codes, gt = it.ERR_INVALID_ARG_TYPE, St = it.ERR_STREAM_PUSH_AFTER_EOF, xt = it.ERR_METHOD_NOT_IMPLEMENTED, Mt = it.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, bt, Tt, It;
  inherits_browserExports(mt, L);
  var qt = oe.errorOrDestroy, Dt = ["error", "close", "destroy", "pause", "resume"];
  function Xt(Nt, Ft, er) {
    if (typeof Nt.prependListener == "function") return Nt.prependListener(Ft, er);
    !Nt._events || !Nt._events[Ft] ? Nt.on(Ft, er) : Array.isArray(Nt._events[Ft]) ? Nt._events[Ft].unshift(er) : Nt._events[Ft] = [er, Nt._events[Ft]];
  }
  function Bt(Nt, Ft, er) {
    A = A || require_stream_duplex$1(), Nt = Nt || {}, typeof er != "boolean" && (er = Ft instanceof A), this.objectMode = !!Nt.objectMode, er && (this.objectMode = this.objectMode || !!Nt.readableObjectMode), this.highWaterMark = at(this, Nt, "readableHighWaterMark", er), this.buffer = new nt(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Nt.emitClose !== !1, this.autoDestroy = !!Nt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Nt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Nt.encoding && (bt || (bt = string_decoder.StringDecoder), this.decoder = new bt(Nt.encoding), this.encoding = Nt.encoding);
  }
  function mt(Nt) {
    if (A = A || require_stream_duplex$1(), !(this instanceof mt)) return new mt(Nt);
    var Ft = this instanceof A;
    this._readableState = new Bt(Nt, this, Ft), this.readable = !0, Nt && (typeof Nt.read == "function" && (this._read = Nt.read), typeof Nt.destroy == "function" && (this._destroy = Nt.destroy)), L.call(this);
  }
  Object.defineProperty(mt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ft) {
      this._readableState && (this._readableState.destroyed = Ft);
    }
  }), mt.prototype.destroy = oe.destroy, mt.prototype._undestroy = oe.undestroy, mt.prototype._destroy = function(Nt, Ft) {
    Ft(Nt);
  }, mt.prototype.push = function(Nt, Ft) {
    var er = this._readableState, fr;
    return er.objectMode ? fr = !0 : typeof Nt == "string" && (Ft = Ft || er.defaultEncoding, Ft !== er.encoding && (Nt = V.from(Nt, Ft), Ft = ""), fr = !0), Ot(this, Nt, Ft, !1, fr);
  }, mt.prototype.unshift = function(Nt) {
    return Ot(this, Nt, null, !0, !1);
  };
  function Ot(Nt, Ft, er, fr, cr) {
    pe("readableAddChunk", Ft);
    var dr = Nt._readableState;
    if (Ft === null)
      dr.reading = !1, ot(Nt, dr);
    else {
      var br;
      if (cr || (br = ke(dr, Ft)), br)
        qt(Nt, br);
      else if (dr.objectMode || Ft && Ft.length > 0)
        if (typeof Ft != "string" && !dr.objectMode && Object.getPrototypeOf(Ft) !== V.prototype && (Ft = re(Ft)), fr)
          dr.endEmitted ? qt(Nt, new Mt()) : wt(Nt, dr, Ft, !0);
        else if (dr.ended)
          qt(Nt, new St());
        else {
          if (dr.destroyed)
            return !1;
          dr.reading = !1, dr.decoder && !er ? (Ft = dr.decoder.write(Ft), dr.objectMode || Ft.length !== 0 ? wt(Nt, dr, Ft, !1) : dt(Nt, dr)) : wt(Nt, dr, Ft, !1);
        }
      else fr || (dr.reading = !1, dt(Nt, dr));
    }
    return !dr.ended && (dr.length < dr.highWaterMark || dr.length === 0);
  }
  function wt(Nt, Ft, er, fr) {
    Ft.flowing && Ft.length === 0 && !Ft.sync ? (Ft.awaitDrain = 0, Nt.emit("data", er)) : (Ft.length += Ft.objectMode ? 1 : er.length, fr ? Ft.buffer.unshift(er) : Ft.buffer.push(er), Ft.needReadable && ut(Nt)), dt(Nt, Ft);
  }
  function ke(Nt, Ft) {
    var er;
    return !ne(Ft) && typeof Ft != "string" && Ft !== void 0 && !Nt.objectMode && (er = new gt("chunk", ["string", "Buffer", "Uint8Array"], Ft)), er;
  }
  mt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, mt.prototype.setEncoding = function(Nt) {
    bt || (bt = string_decoder.StringDecoder);
    var Ft = new bt(Nt);
    this._readableState.decoder = Ft, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var er = this._readableState.buffer.head, fr = ""; er !== null; )
      fr += Ft.write(er.data), er = er.next;
    return this._readableState.buffer.clear(), fr !== "" && this._readableState.buffer.push(fr), this._readableState.length = fr.length, this;
  };
  var rt = 1073741824;
  function ce(Nt) {
    return Nt >= rt ? Nt = rt : (Nt--, Nt |= Nt >>> 1, Nt |= Nt >>> 2, Nt |= Nt >>> 4, Nt |= Nt >>> 8, Nt |= Nt >>> 16, Nt++), Nt;
  }
  function Oe(Nt, Ft) {
    return Nt <= 0 || Ft.length === 0 && Ft.ended ? 0 : Ft.objectMode ? 1 : Nt !== Nt ? Ft.flowing && Ft.length ? Ft.buffer.head.data.length : Ft.length : (Nt > Ft.highWaterMark && (Ft.highWaterMark = ce(Nt)), Nt <= Ft.length ? Nt : Ft.ended ? Ft.length : (Ft.needReadable = !0, 0));
  }
  mt.prototype.read = function(Nt) {
    pe("read", Nt), Nt = parseInt(Nt, 10);
    var Ft = this._readableState, er = Nt;
    if (Nt !== 0 && (Ft.emittedReadable = !1), Nt === 0 && Ft.needReadable && ((Ft.highWaterMark !== 0 ? Ft.length >= Ft.highWaterMark : Ft.length > 0) || Ft.ended))
      return pe("read: emitReadable", Ft.length, Ft.ended), Ft.length === 0 && Ft.ended ? kt(this) : ut(this), null;
    if (Nt = Oe(Nt, Ft), Nt === 0 && Ft.ended)
      return Ft.length === 0 && kt(this), null;
    var fr = Ft.needReadable;
    pe("need readable", fr), (Ft.length === 0 || Ft.length - Nt < Ft.highWaterMark) && (fr = !0, pe("length less than watermark", fr)), Ft.ended || Ft.reading ? (fr = !1, pe("reading or ended", fr)) : fr && (pe("do read"), Ft.reading = !0, Ft.sync = !0, Ft.length === 0 && (Ft.needReadable = !0), this._read(Ft.highWaterMark), Ft.sync = !1, Ft.reading || (Nt = Oe(er, Ft)));
    var cr;
    return Nt > 0 ? cr = Pt(Nt, Ft) : cr = null, cr === null ? (Ft.needReadable = Ft.length <= Ft.highWaterMark, Nt = 0) : (Ft.length -= Nt, Ft.awaitDrain = 0), Ft.length === 0 && (Ft.ended || (Ft.needReadable = !0), er !== Nt && Ft.ended && kt(this)), cr !== null && this.emit("data", cr), cr;
  };
  function ot(Nt, Ft) {
    if (pe("onEofChunk"), !Ft.ended) {
      if (Ft.decoder) {
        var er = Ft.decoder.end();
        er && er.length && (Ft.buffer.push(er), Ft.length += Ft.objectMode ? 1 : er.length);
      }
      Ft.ended = !0, Ft.sync ? ut(Nt) : (Ft.needReadable = !1, Ft.emittedReadable || (Ft.emittedReadable = !0, ht(Nt)));
    }
  }
  function ut(Nt) {
    var Ft = Nt._readableState;
    pe("emitReadable", Ft.needReadable, Ft.emittedReadable), Ft.needReadable = !1, Ft.emittedReadable || (pe("emitReadable", Ft.flowing), Ft.emittedReadable = !0, process$1.nextTick(ht, Nt));
  }
  function ht(Nt) {
    var Ft = Nt._readableState;
    pe("emitReadable_", Ft.destroyed, Ft.length, Ft.ended), !Ft.destroyed && (Ft.length || Ft.ended) && (Nt.emit("readable"), Ft.emittedReadable = !1), Ft.needReadable = !Ft.flowing && !Ft.ended && Ft.length <= Ft.highWaterMark, Ht(Nt);
  }
  function dt(Nt, Ft) {
    Ft.readingMore || (Ft.readingMore = !0, process$1.nextTick(st, Nt, Ft));
  }
  function st(Nt, Ft) {
    for (; !Ft.reading && !Ft.ended && (Ft.length < Ft.highWaterMark || Ft.flowing && Ft.length === 0); ) {
      var er = Ft.length;
      if (pe("maybeReadMore read 0"), Nt.read(0), er === Ft.length)
        break;
    }
    Ft.readingMore = !1;
  }
  mt.prototype._read = function(Nt) {
    qt(this, new xt("_read()"));
  }, mt.prototype.pipe = function(Nt, Ft) {
    var er = this, fr = this._readableState;
    switch (fr.pipesCount) {
      case 0:
        fr.pipes = Nt;
        break;
      case 1:
        fr.pipes = [fr.pipes, Nt];
        break;
      default:
        fr.pipes.push(Nt);
        break;
    }
    fr.pipesCount += 1, pe("pipe count=%d opts=%j", fr.pipesCount, Ft);
    var cr = (!Ft || Ft.end !== !1) && Nt !== process$1.stdout && Nt !== process$1.stderr, dr = cr ? wr : Fr;
    fr.endEmitted ? process$1.nextTick(dr) : er.once("end", dr), Nt.on("unpipe", br);
    function br(Ar, Cr) {
      pe("onunpipe"), Ar === er && Cr && Cr.hasUnpiped === !1 && (Cr.hasUnpiped = !0, Br());
    }
    function wr() {
      pe("onend"), Nt.end();
    }
    var or = yt(er);
    Nt.on("drain", or);
    var Nr = !1;
    function Br() {
      pe("cleanup"), Nt.removeListener("close", _r), Nt.removeListener("finish", kr), Nt.removeListener("drain", or), Nt.removeListener("error", Mr), Nt.removeListener("unpipe", br), er.removeListener("end", wr), er.removeListener("end", Fr), er.removeListener("data", Tr), Nr = !0, fr.awaitDrain && (!Nt._writableState || Nt._writableState.needDrain) && or();
    }
    er.on("data", Tr);
    function Tr(Ar) {
      pe("ondata");
      var Cr = Nt.write(Ar);
      pe("dest.write", Cr), Cr === !1 && ((fr.pipesCount === 1 && fr.pipes === Nt || fr.pipesCount > 1 && tr(fr.pipes, Nt) !== -1) && !Nr && (pe("false write response, pause", fr.awaitDrain), fr.awaitDrain++), er.pause());
    }
    function Mr(Ar) {
      pe("onerror", Ar), Fr(), Nt.removeListener("error", Mr), B(Nt, "error") === 0 && qt(Nt, Ar);
    }
    Xt(Nt, "error", Mr);
    function _r() {
      Nt.removeListener("finish", kr), Fr();
    }
    Nt.once("close", _r);
    function kr() {
      pe("onfinish"), Nt.removeListener("close", _r), Fr();
    }
    Nt.once("finish", kr);
    function Fr() {
      pe("unpipe"), er.unpipe(Nt);
    }
    return Nt.emit("pipe", er), fr.flowing || (pe("pipe resume"), er.resume()), Nt;
  };
  function yt(Nt) {
    return function() {
      var er = Nt._readableState;
      pe("pipeOnDrain", er.awaitDrain), er.awaitDrain && er.awaitDrain--, er.awaitDrain === 0 && B(Nt, "data") && (er.flowing = !0, Ht(Nt));
    };
  }
  mt.prototype.unpipe = function(Nt) {
    var Ft = this._readableState, er = {
      hasUnpiped: !1
    };
    if (Ft.pipesCount === 0) return this;
    if (Ft.pipesCount === 1)
      return Nt && Nt !== Ft.pipes ? this : (Nt || (Nt = Ft.pipes), Ft.pipes = null, Ft.pipesCount = 0, Ft.flowing = !1, Nt && Nt.emit("unpipe", this, er), this);
    if (!Nt) {
      var fr = Ft.pipes, cr = Ft.pipesCount;
      Ft.pipes = null, Ft.pipesCount = 0, Ft.flowing = !1;
      for (var dr = 0; dr < cr; dr++) fr[dr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var br = tr(Ft.pipes, Nt);
    return br === -1 ? this : (Ft.pipes.splice(br, 1), Ft.pipesCount -= 1, Ft.pipesCount === 1 && (Ft.pipes = Ft.pipes[0]), Nt.emit("unpipe", this, er), this);
  }, mt.prototype.on = function(Nt, Ft) {
    var er = L.prototype.on.call(this, Nt, Ft), fr = this._readableState;
    return Nt === "data" ? (fr.readableListening = this.listenerCount("readable") > 0, fr.flowing !== !1 && this.resume()) : Nt === "readable" && !fr.endEmitted && !fr.readableListening && (fr.readableListening = fr.needReadable = !0, fr.flowing = !1, fr.emittedReadable = !1, pe("on readable", fr.length, fr.reading), fr.length ? ut(this) : fr.reading || process$1.nextTick(At, this)), er;
  }, mt.prototype.addListener = mt.prototype.on, mt.prototype.removeListener = function(Nt, Ft) {
    var er = L.prototype.removeListener.call(this, Nt, Ft);
    return Nt === "readable" && process$1.nextTick(ct, this), er;
  }, mt.prototype.removeAllListeners = function(Nt) {
    var Ft = L.prototype.removeAllListeners.apply(this, arguments);
    return (Nt === "readable" || Nt === void 0) && process$1.nextTick(ct, this), Ft;
  };
  function ct(Nt) {
    var Ft = Nt._readableState;
    Ft.readableListening = Nt.listenerCount("readable") > 0, Ft.resumeScheduled && !Ft.paused ? Ft.flowing = !0 : Nt.listenerCount("data") > 0 && Nt.resume();
  }
  function At(Nt) {
    pe("readable nexttick read 0"), Nt.read(0);
  }
  mt.prototype.resume = function() {
    var Nt = this._readableState;
    return Nt.flowing || (pe("resume"), Nt.flowing = !Nt.readableListening, Kt(this, Nt)), Nt.paused = !1, this;
  };
  function Kt(Nt, Ft) {
    Ft.resumeScheduled || (Ft.resumeScheduled = !0, process$1.nextTick(Zt, Nt, Ft));
  }
  function Zt(Nt, Ft) {
    pe("resume", Ft.reading), Ft.reading || Nt.read(0), Ft.resumeScheduled = !1, Nt.emit("resume"), Ht(Nt), Ft.flowing && !Ft.reading && Nt.read(0);
  }
  mt.prototype.pause = function() {
    return pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (pe("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Ht(Nt) {
    var Ft = Nt._readableState;
    for (pe("flow", Ft.flowing); Ft.flowing && Nt.read() !== null; ) ;
  }
  mt.prototype.wrap = function(Nt) {
    var Ft = this, er = this._readableState, fr = !1;
    Nt.on("end", function() {
      if (pe("wrapped end"), er.decoder && !er.ended) {
        var br = er.decoder.end();
        br && br.length && Ft.push(br);
      }
      Ft.push(null);
    }), Nt.on("data", function(br) {
      if (pe("wrapped data"), er.decoder && (br = er.decoder.write(br)), !(er.objectMode && br == null) && !(!er.objectMode && (!br || !br.length))) {
        var wr = Ft.push(br);
        wr || (fr = !0, Nt.pause());
      }
    });
    for (var cr in Nt)
      this[cr] === void 0 && typeof Nt[cr] == "function" && (this[cr] = /* @__PURE__ */ function(wr) {
        return function() {
          return Nt[wr].apply(Nt, arguments);
        };
      }(cr));
    for (var dr = 0; dr < Dt.length; dr++)
      Nt.on(Dt[dr], this.emit.bind(this, Dt[dr]));
    return this._read = function(br) {
      pe("wrapped _read", br), fr && (fr = !1, Nt.resume());
    }, this;
  }, typeof Symbol == "function" && (mt.prototype[Symbol.asyncIterator] = function() {
    return Tt === void 0 && (Tt = requireAsync_iterator()), Tt(this);
  }), Object.defineProperty(mt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(mt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(mt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Ft) {
      this._readableState && (this._readableState.flowing = Ft);
    }
  }), mt._fromList = Pt, Object.defineProperty(mt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Pt(Nt, Ft) {
    if (Ft.length === 0) return null;
    var er;
    return Ft.objectMode ? er = Ft.buffer.shift() : !Nt || Nt >= Ft.length ? (Ft.decoder ? er = Ft.buffer.join("") : Ft.buffer.length === 1 ? er = Ft.buffer.first() : er = Ft.buffer.concat(Ft.length), Ft.buffer.clear()) : er = Ft.buffer.consume(Nt, Ft.decoder), er;
  }
  function kt(Nt) {
    var Ft = Nt._readableState;
    pe("endReadable", Ft.endEmitted), Ft.endEmitted || (Ft.ended = !0, process$1.nextTick(Vt, Ft, Nt));
  }
  function Vt(Nt, Ft) {
    if (pe("endReadableNT", Nt.endEmitted, Nt.length), !Nt.endEmitted && Nt.length === 0 && (Nt.endEmitted = !0, Ft.readable = !1, Ft.emit("end"), Nt.autoDestroy)) {
      var er = Ft._writableState;
      (!er || er.autoDestroy && er.finished) && Ft.destroy();
    }
  }
  typeof Symbol == "function" && (mt.from = function(Nt, Ft) {
    return It === void 0 && (It = requireFromBrowser()), It(mt, Nt, Ft);
  });
  function tr(Nt, Ft) {
    for (var er = 0, fr = Nt.length; er < fr; er++)
      if (Nt[er] === Ft) return er;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = ie;
  var A = errorsBrowser.codes, B = A.ERR_METHOD_NOT_IMPLEMENTED, L = A.ERR_MULTIPLE_CALLBACK, V = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, J = A.ERR_TRANSFORM_WITH_LENGTH_0, re = require_stream_duplex$1();
  inherits_browserExports(ie, re);
  function ne(oe, Ce) {
    var at = this._transformState;
    at.transforming = !1;
    var it = at.writecb;
    if (it === null)
      return this.emit("error", new L());
    at.writechunk = null, at.writecb = null, Ce != null && this.push(Ce), it(oe);
    var gt = this._readableState;
    gt.reading = !1, (gt.needReadable || gt.length < gt.highWaterMark) && this._read(gt.highWaterMark);
  }
  function ie(oe) {
    if (!(this instanceof ie)) return new ie(oe);
    re.call(this, oe), this._transformState = {
      afterTransform: ne.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, oe && (typeof oe.transform == "function" && (this._transform = oe.transform), typeof oe.flush == "function" && (this._flush = oe.flush)), this.on("prefinish", pe);
  }
  function pe() {
    var oe = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Ce, at) {
      nt(oe, Ce, at);
    }) : nt(this, null, null);
  }
  ie.prototype.push = function(oe, Ce) {
    return this._transformState.needTransform = !1, re.prototype.push.call(this, oe, Ce);
  }, ie.prototype._transform = function(oe, Ce, at) {
    at(new B("_transform()"));
  }, ie.prototype._write = function(oe, Ce, at) {
    var it = this._transformState;
    if (it.writecb = at, it.writechunk = oe, it.writeencoding = Ce, !it.transforming) {
      var gt = this._readableState;
      (it.needTransform || gt.needReadable || gt.length < gt.highWaterMark) && this._read(gt.highWaterMark);
    }
  }, ie.prototype._read = function(oe) {
    var Ce = this._transformState;
    Ce.writechunk !== null && !Ce.transforming ? (Ce.transforming = !0, this._transform(Ce.writechunk, Ce.writeencoding, Ce.afterTransform)) : Ce.needTransform = !0;
  }, ie.prototype._destroy = function(oe, Ce) {
    re.prototype._destroy.call(this, oe, function(at) {
      Ce(at);
    });
  };
  function nt(oe, Ce, at) {
    if (Ce) return oe.emit("error", Ce);
    if (at != null && oe.push(at), oe._writableState.length) throw new J();
    if (oe._transformState.transforming) throw new V();
    return oe.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1 = PassThrough$1, Transform$8 = require_stream_transform();
inherits_browserExports(PassThrough$1, Transform$8);
function PassThrough$1(A) {
  if (!(this instanceof PassThrough$1)) return new PassThrough$1(A);
  Transform$8.call(this, A);
}
PassThrough$1.prototype._transform = function(A, B, L) {
  L(null, A);
};
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var A;
  function B(at) {
    var it = !1;
    return function() {
      it || (it = !0, at.apply(void 0, arguments));
    };
  }
  var L = errorsBrowser.codes, V = L.ERR_MISSING_ARGS, J = L.ERR_STREAM_DESTROYED;
  function re(at) {
    if (at) throw at;
  }
  function ne(at) {
    return at.setHeader && typeof at.abort == "function";
  }
  function ie(at, it, gt, St) {
    St = B(St);
    var xt = !1;
    at.on("close", function() {
      xt = !0;
    }), A === void 0 && (A = endOfStream), A(at, {
      readable: it,
      writable: gt
    }, function(bt) {
      if (bt) return St(bt);
      xt = !0, St();
    });
    var Mt = !1;
    return function(bt) {
      if (!xt && !Mt) {
        if (Mt = !0, ne(at)) return at.abort();
        if (typeof at.destroy == "function") return at.destroy();
        St(bt || new J("pipe"));
      }
    };
  }
  function pe(at) {
    at();
  }
  function nt(at, it) {
    return at.pipe(it);
  }
  function oe(at) {
    return !at.length || typeof at[at.length - 1] != "function" ? re : at.pop();
  }
  function Ce() {
    for (var at = arguments.length, it = new Array(at), gt = 0; gt < at; gt++)
      it[gt] = arguments[gt];
    var St = oe(it);
    if (Array.isArray(it[0]) && (it = it[0]), it.length < 2)
      throw new V("streams");
    var xt, Mt = it.map(function(bt, Tt) {
      var It = Tt < it.length - 1, qt = Tt > 0;
      return ie(bt, It, qt, function(Dt) {
        xt || (xt = Dt), Dt && Mt.forEach(pe), !It && (Mt.forEach(pe), St(xt));
      });
    });
    return it.reduce(nt);
  }
  return pipeline_1 = Ce, pipeline_1;
}
(function(A, B) {
  B = A.exports = require_stream_readable$1(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable$1(), B.Duplex = require_stream_duplex$1(), B.Transform = require_stream_transform(), B.PassThrough = _stream_passthrough$1, B.finished = endOfStream, B.pipeline = requirePipeline();
})(readableBrowser$1, readableBrowser$1.exports);
var readableBrowserExports$1 = readableBrowser$1.exports, Buffer$A = safeBufferExports$1.Buffer, Transform$7 = readableBrowserExports$1.Transform, inherits$q = inherits_browserExports;
function throwIfNotStringOrBuffer(A, B) {
  if (!Buffer$A.isBuffer(A) && typeof A != "string")
    throw new TypeError(B + " must be a string or a buffer");
}
function HashBase$2(A) {
  Transform$7.call(this), this._block = Buffer$A.allocUnsafe(A), this._blockSize = A, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$q(HashBase$2, Transform$7);
HashBase$2.prototype._transform = function(A, B, L) {
  var V = null;
  try {
    this.update(A, B);
  } catch (J) {
    V = J;
  }
  L(V);
};
HashBase$2.prototype._flush = function(A) {
  var B = null;
  try {
    this.push(this.digest());
  } catch (L) {
    B = L;
  }
  A(B);
};
HashBase$2.prototype.update = function(A, B) {
  if (throwIfNotStringOrBuffer(A, "Data"), this._finalized) throw new Error("Digest already called");
  Buffer$A.isBuffer(A) || (A = Buffer$A.from(A, B));
  for (var L = this._block, V = 0; this._blockOffset + A.length - V >= this._blockSize; ) {
    for (var J = this._blockOffset; J < this._blockSize; ) L[J++] = A[V++];
    this._update(), this._blockOffset = 0;
  }
  for (; V < A.length; ) L[this._blockOffset++] = A[V++];
  for (var re = 0, ne = A.length * 8; ne > 0; ++re)
    this._length[re] += ne, ne = this._length[re] / 4294967296 | 0, ne > 0 && (this._length[re] -= 4294967296 * ne);
  return this;
};
HashBase$2.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$2.prototype.digest = function(A) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var B = this._digest();
  A !== void 0 && (B = B.toString(A)), this._block.fill(0), this._blockOffset = 0;
  for (var L = 0; L < 4; ++L) this._length[L] = 0;
  return B;
};
HashBase$2.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$2, inherits$p = inherits_browserExports, HashBase$1 = hashBase, Buffer$z = safeBufferExports$1.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$p(MD5$3, HashBase$1);
MD5$3.prototype._update = function() {
  for (var A = ARRAY16$1, B = 0; B < 16; ++B) A[B] = this._block.readInt32LE(B * 4);
  var L = this._a, V = this._b, J = this._c, re = this._d;
  L = fnF(L, V, J, re, A[0], 3614090360, 7), re = fnF(re, L, V, J, A[1], 3905402710, 12), J = fnF(J, re, L, V, A[2], 606105819, 17), V = fnF(V, J, re, L, A[3], 3250441966, 22), L = fnF(L, V, J, re, A[4], 4118548399, 7), re = fnF(re, L, V, J, A[5], 1200080426, 12), J = fnF(J, re, L, V, A[6], 2821735955, 17), V = fnF(V, J, re, L, A[7], 4249261313, 22), L = fnF(L, V, J, re, A[8], 1770035416, 7), re = fnF(re, L, V, J, A[9], 2336552879, 12), J = fnF(J, re, L, V, A[10], 4294925233, 17), V = fnF(V, J, re, L, A[11], 2304563134, 22), L = fnF(L, V, J, re, A[12], 1804603682, 7), re = fnF(re, L, V, J, A[13], 4254626195, 12), J = fnF(J, re, L, V, A[14], 2792965006, 17), V = fnF(V, J, re, L, A[15], 1236535329, 22), L = fnG(L, V, J, re, A[1], 4129170786, 5), re = fnG(re, L, V, J, A[6], 3225465664, 9), J = fnG(J, re, L, V, A[11], 643717713, 14), V = fnG(V, J, re, L, A[0], 3921069994, 20), L = fnG(L, V, J, re, A[5], 3593408605, 5), re = fnG(re, L, V, J, A[10], 38016083, 9), J = fnG(J, re, L, V, A[15], 3634488961, 14), V = fnG(V, J, re, L, A[4], 3889429448, 20), L = fnG(L, V, J, re, A[9], 568446438, 5), re = fnG(re, L, V, J, A[14], 3275163606, 9), J = fnG(J, re, L, V, A[3], 4107603335, 14), V = fnG(V, J, re, L, A[8], 1163531501, 20), L = fnG(L, V, J, re, A[13], 2850285829, 5), re = fnG(re, L, V, J, A[2], 4243563512, 9), J = fnG(J, re, L, V, A[7], 1735328473, 14), V = fnG(V, J, re, L, A[12], 2368359562, 20), L = fnH(L, V, J, re, A[5], 4294588738, 4), re = fnH(re, L, V, J, A[8], 2272392833, 11), J = fnH(J, re, L, V, A[11], 1839030562, 16), V = fnH(V, J, re, L, A[14], 4259657740, 23), L = fnH(L, V, J, re, A[1], 2763975236, 4), re = fnH(re, L, V, J, A[4], 1272893353, 11), J = fnH(J, re, L, V, A[7], 4139469664, 16), V = fnH(V, J, re, L, A[10], 3200236656, 23), L = fnH(L, V, J, re, A[13], 681279174, 4), re = fnH(re, L, V, J, A[0], 3936430074, 11), J = fnH(J, re, L, V, A[3], 3572445317, 16), V = fnH(V, J, re, L, A[6], 76029189, 23), L = fnH(L, V, J, re, A[9], 3654602809, 4), re = fnH(re, L, V, J, A[12], 3873151461, 11), J = fnH(J, re, L, V, A[15], 530742520, 16), V = fnH(V, J, re, L, A[2], 3299628645, 23), L = fnI(L, V, J, re, A[0], 4096336452, 6), re = fnI(re, L, V, J, A[7], 1126891415, 10), J = fnI(J, re, L, V, A[14], 2878612391, 15), V = fnI(V, J, re, L, A[5], 4237533241, 21), L = fnI(L, V, J, re, A[12], 1700485571, 6), re = fnI(re, L, V, J, A[3], 2399980690, 10), J = fnI(J, re, L, V, A[10], 4293915773, 15), V = fnI(V, J, re, L, A[1], 2240044497, 21), L = fnI(L, V, J, re, A[8], 1873313359, 6), re = fnI(re, L, V, J, A[15], 4264355552, 10), J = fnI(J, re, L, V, A[6], 2734768916, 15), V = fnI(V, J, re, L, A[13], 1309151649, 21), L = fnI(L, V, J, re, A[4], 4149444226, 6), re = fnI(re, L, V, J, A[11], 3174756917, 10), J = fnI(J, re, L, V, A[2], 718787259, 15), V = fnI(V, J, re, L, A[9], 3951481745, 21), this._a = this._a + L | 0, this._b = this._b + V | 0, this._c = this._c + J | 0, this._d = this._d + re | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var A = Buffer$z.allocUnsafe(16);
  return A.writeInt32LE(this._a, 0), A.writeInt32LE(this._b, 4), A.writeInt32LE(this._c, 8), A.writeInt32LE(this._d, 12), A;
};
function rotl$1(A, B) {
  return A << B | A >>> 32 - B;
}
function fnF(A, B, L, V, J, re, ne) {
  return rotl$1(A + (B & L | ~B & V) + J + re | 0, ne) + B | 0;
}
function fnG(A, B, L, V, J, re, ne) {
  return rotl$1(A + (B & V | L & ~V) + J + re | 0, ne) + B | 0;
}
function fnH(A, B, L, V, J, re, ne) {
  return rotl$1(A + (B ^ L ^ V) + J + re | 0, ne) + B | 0;
}
function fnI(A, B, L, V, J, re, ne) {
  return rotl$1(A + (L ^ (B | ~V)) + J + re | 0, ne) + B | 0;
}
var md5_js = MD5$3, Buffer$y = dist$1.Buffer, inherits$o = inherits_browserExports, HashBase = hashBase, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$5() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$o(RIPEMD160$5, HashBase);
RIPEMD160$5.prototype._update = function() {
  for (var A = ARRAY16, B = 0; B < 16; ++B) A[B] = this._block.readInt32LE(B * 4);
  for (var L = this._a | 0, V = this._b | 0, J = this._c | 0, re = this._d | 0, ne = this._e | 0, ie = this._a | 0, pe = this._b | 0, nt = this._c | 0, oe = this._d | 0, Ce = this._e | 0, at = 0; at < 80; at += 1) {
    var it, gt;
    at < 16 ? (it = fn1(L, V, J, re, ne, A[zl[at]], hl[0], sl[at]), gt = fn5(ie, pe, nt, oe, Ce, A[zr[at]], hr[0], sr[at])) : at < 32 ? (it = fn2(L, V, J, re, ne, A[zl[at]], hl[1], sl[at]), gt = fn4(ie, pe, nt, oe, Ce, A[zr[at]], hr[1], sr[at])) : at < 48 ? (it = fn3(L, V, J, re, ne, A[zl[at]], hl[2], sl[at]), gt = fn3(ie, pe, nt, oe, Ce, A[zr[at]], hr[2], sr[at])) : at < 64 ? (it = fn4(L, V, J, re, ne, A[zl[at]], hl[3], sl[at]), gt = fn2(ie, pe, nt, oe, Ce, A[zr[at]], hr[3], sr[at])) : (it = fn5(L, V, J, re, ne, A[zl[at]], hl[4], sl[at]), gt = fn1(ie, pe, nt, oe, Ce, A[zr[at]], hr[4], sr[at])), L = ne, ne = re, re = rotl(J, 10), J = V, V = it, ie = Ce, Ce = oe, oe = rotl(nt, 10), nt = pe, pe = gt;
  }
  var St = this._b + J + oe | 0;
  this._b = this._c + re + Ce | 0, this._c = this._d + ne + ie | 0, this._d = this._e + L + pe | 0, this._e = this._a + V + nt | 0, this._a = St;
};
RIPEMD160$5.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var A = Buffer$y.alloc ? Buffer$y.alloc(20) : new Buffer$y(20);
  return A.writeInt32LE(this._a, 0), A.writeInt32LE(this._b, 4), A.writeInt32LE(this._c, 8), A.writeInt32LE(this._d, 12), A.writeInt32LE(this._e, 16), A;
};
function rotl(A, B) {
  return A << B | A >>> 32 - B;
}
function fn1(A, B, L, V, J, re, ne, ie) {
  return rotl(A + (B ^ L ^ V) + re + ne | 0, ie) + J | 0;
}
function fn2(A, B, L, V, J, re, ne, ie) {
  return rotl(A + (B & L | ~B & V) + re + ne | 0, ie) + J | 0;
}
function fn3(A, B, L, V, J, re, ne, ie) {
  return rotl(A + ((B | ~L) ^ V) + re + ne | 0, ie) + J | 0;
}
function fn4(A, B, L, V, J, re, ne, ie) {
  return rotl(A + (B & V | L & ~V) + re + ne | 0, ie) + J | 0;
}
function fn5(A, B, L, V, J, re, ne, ie) {
  return rotl(A + (B ^ (L | ~V)) + re + ne | 0, ie) + J | 0;
}
var ripemd160$1 = RIPEMD160$5, sha_js = { exports: {} }, Buffer$x = safeBufferExports$1.Buffer;
function Hash$7(A, B) {
  this._block = Buffer$x.alloc(A), this._finalSize = B, this._blockSize = A, this._len = 0;
}
Hash$7.prototype.update = function(A, B) {
  typeof A == "string" && (B = B || "utf8", A = Buffer$x.from(A, B));
  for (var L = this._block, V = this._blockSize, J = A.length, re = this._len, ne = 0; ne < J; ) {
    for (var ie = re % V, pe = Math.min(J - ne, V - ie), nt = 0; nt < pe; nt++)
      L[ie + nt] = A[ne + nt];
    re += pe, ne += pe, re % V === 0 && this._update(L);
  }
  return this._len += J, this;
};
Hash$7.prototype.digest = function(A) {
  var B = this._len % this._blockSize;
  this._block[B] = 128, this._block.fill(0, B + 1), B >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var L = this._len * 8;
  if (L <= 4294967295)
    this._block.writeUInt32BE(L, this._blockSize - 4);
  else {
    var V = (L & 4294967295) >>> 0, J = (L - V) / 4294967296;
    this._block.writeUInt32BE(J, this._blockSize - 8), this._block.writeUInt32BE(V, this._blockSize - 4);
  }
  this._update(this._block);
  var re = this._hash();
  return A ? re.toString(A) : re;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$3 = Hash$7, inherits$n = inherits_browserExports, Hash$6 = hash$3, Buffer$w = safeBufferExports$1.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$n(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(A) {
  return A << 5 | A >>> 27;
}
function rotl30$1(A) {
  return A << 30 | A >>> 2;
}
function ft$1(A, B, L, V) {
  return A === 0 ? B & L | ~B & V : A === 2 ? B & L | B & V | L & V : B ^ L ^ V;
}
Sha.prototype._update = function(A) {
  for (var B = this._w, L = this._a | 0, V = this._b | 0, J = this._c | 0, re = this._d | 0, ne = this._e | 0, ie = 0; ie < 16; ++ie) B[ie] = A.readInt32BE(ie * 4);
  for (; ie < 80; ++ie) B[ie] = B[ie - 3] ^ B[ie - 8] ^ B[ie - 14] ^ B[ie - 16];
  for (var pe = 0; pe < 80; ++pe) {
    var nt = ~~(pe / 20), oe = rotl5$1(L) + ft$1(nt, V, J, re) + ne + B[pe] + K$4[nt] | 0;
    ne = re, re = J, J = rotl30$1(V), V = L, L = oe;
  }
  this._a = L + this._a | 0, this._b = V + this._b | 0, this._c = J + this._c | 0, this._d = re + this._d | 0, this._e = ne + this._e | 0;
};
Sha.prototype._hash = function() {
  var A = Buffer$w.allocUnsafe(20);
  return A.writeInt32BE(this._a | 0, 0), A.writeInt32BE(this._b | 0, 4), A.writeInt32BE(this._c | 0, 8), A.writeInt32BE(this._d | 0, 12), A.writeInt32BE(this._e | 0, 16), A;
};
var sha$4 = Sha, inherits$m = inherits_browserExports, Hash$5 = hash$3, Buffer$v = safeBufferExports$1.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$m(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(A) {
  return A << 1 | A >>> 31;
}
function rotl5(A) {
  return A << 5 | A >>> 27;
}
function rotl30(A) {
  return A << 30 | A >>> 2;
}
function ft(A, B, L, V) {
  return A === 0 ? B & L | ~B & V : A === 2 ? B & L | B & V | L & V : B ^ L ^ V;
}
Sha1.prototype._update = function(A) {
  for (var B = this._w, L = this._a | 0, V = this._b | 0, J = this._c | 0, re = this._d | 0, ne = this._e | 0, ie = 0; ie < 16; ++ie) B[ie] = A.readInt32BE(ie * 4);
  for (; ie < 80; ++ie) B[ie] = rotl1(B[ie - 3] ^ B[ie - 8] ^ B[ie - 14] ^ B[ie - 16]);
  for (var pe = 0; pe < 80; ++pe) {
    var nt = ~~(pe / 20), oe = rotl5(L) + ft(nt, V, J, re) + ne + B[pe] + K$3[nt] | 0;
    ne = re, re = J, J = rotl30(V), V = L, L = oe;
  }
  this._a = L + this._a | 0, this._b = V + this._b | 0, this._c = J + this._c | 0, this._d = re + this._d | 0, this._e = ne + this._e | 0;
};
Sha1.prototype._hash = function() {
  var A = Buffer$v.allocUnsafe(20);
  return A.writeInt32BE(this._a | 0, 0), A.writeInt32BE(this._b | 0, 4), A.writeInt32BE(this._c | 0, 8), A.writeInt32BE(this._d | 0, 12), A.writeInt32BE(this._e | 0, 16), A;
};
var sha1$1 = Sha1, inherits$l = inherits_browserExports, Hash$4 = hash$3, Buffer$u = safeBufferExports$1.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$l(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(A, B, L) {
  return L ^ A & (B ^ L);
}
function maj$1(A, B, L) {
  return A & B | L & (A | B);
}
function sigma0$1(A) {
  return (A >>> 2 | A << 30) ^ (A >>> 13 | A << 19) ^ (A >>> 22 | A << 10);
}
function sigma1$1(A) {
  return (A >>> 6 | A << 26) ^ (A >>> 11 | A << 21) ^ (A >>> 25 | A << 7);
}
function gamma0(A) {
  return (A >>> 7 | A << 25) ^ (A >>> 18 | A << 14) ^ A >>> 3;
}
function gamma1(A) {
  return (A >>> 17 | A << 15) ^ (A >>> 19 | A << 13) ^ A >>> 10;
}
Sha256$1.prototype._update = function(A) {
  for (var B = this._w, L = this._a | 0, V = this._b | 0, J = this._c | 0, re = this._d | 0, ne = this._e | 0, ie = this._f | 0, pe = this._g | 0, nt = this._h | 0, oe = 0; oe < 16; ++oe) B[oe] = A.readInt32BE(oe * 4);
  for (; oe < 64; ++oe) B[oe] = gamma1(B[oe - 2]) + B[oe - 7] + gamma0(B[oe - 15]) + B[oe - 16] | 0;
  for (var Ce = 0; Ce < 64; ++Ce) {
    var at = nt + sigma1$1(ne) + ch(ne, ie, pe) + K$2[Ce] + B[Ce] | 0, it = sigma0$1(L) + maj$1(L, V, J) | 0;
    nt = pe, pe = ie, ie = ne, ne = re + at | 0, re = J, J = V, V = L, L = at + it | 0;
  }
  this._a = L + this._a | 0, this._b = V + this._b | 0, this._c = J + this._c | 0, this._d = re + this._d | 0, this._e = ne + this._e | 0, this._f = ie + this._f | 0, this._g = pe + this._g | 0, this._h = nt + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var A = Buffer$u.allocUnsafe(32);
  return A.writeInt32BE(this._a, 0), A.writeInt32BE(this._b, 4), A.writeInt32BE(this._c, 8), A.writeInt32BE(this._d, 12), A.writeInt32BE(this._e, 16), A.writeInt32BE(this._f, 20), A.writeInt32BE(this._g, 24), A.writeInt32BE(this._h, 28), A;
};
var sha256$3 = Sha256$1, inherits$k = inherits_browserExports, Sha256 = sha256$3, Hash$3 = hash$3, Buffer$t = safeBufferExports$1.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$k(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var A = Buffer$t.allocUnsafe(28);
  return A.writeInt32BE(this._a, 0), A.writeInt32BE(this._b, 4), A.writeInt32BE(this._c, 8), A.writeInt32BE(this._d, 12), A.writeInt32BE(this._e, 16), A.writeInt32BE(this._f, 20), A.writeInt32BE(this._g, 24), A;
};
var sha224$1 = Sha224, inherits$j = inherits_browserExports, Hash$2 = hash$3, Buffer$s = safeBufferExports$1.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$j(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(A, B, L) {
  return L ^ A & (B ^ L);
}
function maj(A, B, L) {
  return A & B | L & (A | B);
}
function sigma0(A, B) {
  return (A >>> 28 | B << 4) ^ (B >>> 2 | A << 30) ^ (B >>> 7 | A << 25);
}
function sigma1(A, B) {
  return (A >>> 14 | B << 18) ^ (A >>> 18 | B << 14) ^ (B >>> 9 | A << 23);
}
function Gamma0(A, B) {
  return (A >>> 1 | B << 31) ^ (A >>> 8 | B << 24) ^ A >>> 7;
}
function Gamma0l(A, B) {
  return (A >>> 1 | B << 31) ^ (A >>> 8 | B << 24) ^ (A >>> 7 | B << 25);
}
function Gamma1(A, B) {
  return (A >>> 19 | B << 13) ^ (B >>> 29 | A << 3) ^ A >>> 6;
}
function Gamma1l(A, B) {
  return (A >>> 19 | B << 13) ^ (B >>> 29 | A << 3) ^ (A >>> 6 | B << 26);
}
function getCarry(A, B) {
  return A >>> 0 < B >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(A) {
  for (var B = this._w, L = this._ah | 0, V = this._bh | 0, J = this._ch | 0, re = this._dh | 0, ne = this._eh | 0, ie = this._fh | 0, pe = this._gh | 0, nt = this._hh | 0, oe = this._al | 0, Ce = this._bl | 0, at = this._cl | 0, it = this._dl | 0, gt = this._el | 0, St = this._fl | 0, xt = this._gl | 0, Mt = this._hl | 0, bt = 0; bt < 32; bt += 2)
    B[bt] = A.readInt32BE(bt * 4), B[bt + 1] = A.readInt32BE(bt * 4 + 4);
  for (; bt < 160; bt += 2) {
    var Tt = B[bt - 30], It = B[bt - 15 * 2 + 1], qt = Gamma0(Tt, It), Dt = Gamma0l(It, Tt);
    Tt = B[bt - 2 * 2], It = B[bt - 2 * 2 + 1];
    var Xt = Gamma1(Tt, It), Bt = Gamma1l(It, Tt), mt = B[bt - 7 * 2], Ot = B[bt - 7 * 2 + 1], wt = B[bt - 16 * 2], ke = B[bt - 16 * 2 + 1], rt = Dt + Ot | 0, ce = qt + mt + getCarry(rt, Dt) | 0;
    rt = rt + Bt | 0, ce = ce + Xt + getCarry(rt, Bt) | 0, rt = rt + ke | 0, ce = ce + wt + getCarry(rt, ke) | 0, B[bt] = ce, B[bt + 1] = rt;
  }
  for (var Oe = 0; Oe < 160; Oe += 2) {
    ce = B[Oe], rt = B[Oe + 1];
    var ot = maj(L, V, J), ut = maj(oe, Ce, at), ht = sigma0(L, oe), dt = sigma0(oe, L), st = sigma1(ne, gt), yt = sigma1(gt, ne), ct = K$1[Oe], At = K$1[Oe + 1], Kt = Ch(ne, ie, pe), Zt = Ch(gt, St, xt), Ht = Mt + yt | 0, Pt = nt + st + getCarry(Ht, Mt) | 0;
    Ht = Ht + Zt | 0, Pt = Pt + Kt + getCarry(Ht, Zt) | 0, Ht = Ht + At | 0, Pt = Pt + ct + getCarry(Ht, At) | 0, Ht = Ht + rt | 0, Pt = Pt + ce + getCarry(Ht, rt) | 0;
    var kt = dt + ut | 0, Vt = ht + ot + getCarry(kt, dt) | 0;
    nt = pe, Mt = xt, pe = ie, xt = St, ie = ne, St = gt, gt = it + Ht | 0, ne = re + Pt + getCarry(gt, it) | 0, re = J, it = at, J = V, at = Ce, V = L, Ce = oe, oe = Ht + kt | 0, L = Pt + Vt + getCarry(oe, Ht) | 0;
  }
  this._al = this._al + oe | 0, this._bl = this._bl + Ce | 0, this._cl = this._cl + at | 0, this._dl = this._dl + it | 0, this._el = this._el + gt | 0, this._fl = this._fl + St | 0, this._gl = this._gl + xt | 0, this._hl = this._hl + Mt | 0, this._ah = this._ah + L + getCarry(this._al, oe) | 0, this._bh = this._bh + V + getCarry(this._bl, Ce) | 0, this._ch = this._ch + J + getCarry(this._cl, at) | 0, this._dh = this._dh + re + getCarry(this._dl, it) | 0, this._eh = this._eh + ne + getCarry(this._el, gt) | 0, this._fh = this._fh + ie + getCarry(this._fl, St) | 0, this._gh = this._gh + pe + getCarry(this._gl, xt) | 0, this._hh = this._hh + nt + getCarry(this._hl, Mt) | 0;
};
Sha512.prototype._hash = function() {
  var A = Buffer$s.allocUnsafe(64);
  function B(L, V, J) {
    A.writeInt32BE(L, J), A.writeInt32BE(V, J + 4);
  }
  return B(this._ah, this._al, 0), B(this._bh, this._bl, 8), B(this._ch, this._cl, 16), B(this._dh, this._dl, 24), B(this._eh, this._el, 32), B(this._fh, this._fl, 40), B(this._gh, this._gl, 48), B(this._hh, this._hl, 56), A;
};
var sha512$1 = Sha512, inherits$i = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$3, Buffer$r = safeBufferExports$1.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$i(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var A = Buffer$r.allocUnsafe(48);
  function B(L, V, J) {
    A.writeInt32BE(L, J), A.writeInt32BE(V, J + 4);
  }
  return B(this._ah, this._al, 0), B(this._bh, this._bl, 8), B(this._ch, this._cl, 16), B(this._dh, this._dl, 24), B(this._eh, this._el, 32), B(this._fh, this._fl, 40), A;
};
var sha384$1 = Sha384, exports = sha_js.exports = function(B) {
  B = B.toLowerCase();
  var L = exports[B];
  if (!L) throw new Error(B + " is not supported (we accept pull requests)");
  return new L();
};
exports.sha = sha$4;
exports.sha1 = sha1$1;
exports.sha224 = sha224$1;
exports.sha256 = sha256$3;
exports.sha384 = sha384$1;
exports.sha512 = sha512$1;
var sha_jsExports = sha_js.exports, streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$h = inherits_browserExports;
inherits$h(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = _stream_passthrough$1;
Stream.finished = endOfStream;
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(A, B) {
  var L = this;
  function V(oe) {
    A.writable && A.write(oe) === !1 && L.pause && L.pause();
  }
  L.on("data", V);
  function J() {
    L.readable && L.resume && L.resume();
  }
  A.on("drain", J), !A._isStdio && (!B || B.end !== !1) && (L.on("end", ne), L.on("close", ie));
  var re = !1;
  function ne() {
    re || (re = !0, A.end());
  }
  function ie() {
    re || (re = !0, typeof A.destroy == "function" && A.destroy());
  }
  function pe(oe) {
    if (nt(), EE.listenerCount(this, "error") === 0)
      throw oe;
  }
  L.on("error", pe), A.on("error", pe);
  function nt() {
    L.removeListener("data", V), A.removeListener("drain", J), L.removeListener("end", ne), L.removeListener("close", ie), L.removeListener("error", pe), A.removeListener("error", pe), L.removeListener("end", nt), L.removeListener("close", nt), A.removeListener("close", nt);
  }
  return L.on("end", nt), L.on("close", nt), A.on("close", nt), A.emit("pipe", L), A;
};
var Buffer$q = safeBufferExports$1.Buffer, Transform$6 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$g = inherits_browserExports;
function CipherBase$1(A) {
  Transform$6.call(this), this.hashMode = typeof A == "string", this.hashMode ? this[A] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$g(CipherBase$1, Transform$6);
var useUint8Array = typeof Uint8Array < "u", useArrayBuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$q.prototype instanceof Uint8Array || Buffer$q.TYPED_ARRAY_SUPPORT);
function toBuffer$4(A, B) {
  if (A instanceof Buffer$q)
    return A;
  if (typeof A == "string")
    return Buffer$q.from(A, B);
  if (useArrayBuffer && ArrayBuffer.isView(A)) {
    if (A.byteLength === 0)
      return Buffer$q.alloc(0);
    var L = Buffer$q.from(A.buffer, A.byteOffset, A.byteLength);
    if (L.byteLength === A.byteLength)
      return L;
  }
  if (useUint8Array && A instanceof Uint8Array || Buffer$q.isBuffer(A) && A.constructor && typeof A.constructor.isBuffer == "function" && A.constructor.isBuffer(A))
    return Buffer$q.from(A);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
CipherBase$1.prototype.update = function(A, B, L) {
  var V = toBuffer$4(A, B), J = this._update(V);
  return this.hashMode ? this : (L && (J = this._toString(J, L)), J);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(A, B, L) {
  var V;
  try {
    this.hashMode ? this._update(A) : this.push(this._update(A));
  } catch (J) {
    V = J;
  } finally {
    L(V);
  }
};
CipherBase$1.prototype._flush = function(A) {
  var B;
  try {
    this.push(this.__final());
  } catch (L) {
    B = L;
  }
  A(B);
};
CipherBase$1.prototype._finalOrDigest = function(A) {
  var B = this.__final() || Buffer$q.alloc(0);
  return A && (B = this._toString(B, A, !0)), B;
};
CipherBase$1.prototype._toString = function(A, B, L) {
  if (this._decoder || (this._decoder = new StringDecoder(B), this._encoding = B), this._encoding !== B)
    throw new Error("can’t switch encodings");
  var V = this._decoder.write(A);
  return L && (V += this._decoder.end()), V;
};
var cipherBase = CipherBase$1, inherits$f = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$4 = ripemd160$1, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(A) {
  Base$5.call(this, "digest"), this._hash = A;
}
inherits$f(Hash, Base$5);
Hash.prototype._update = function(A) {
  this._hash.update(A);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(B) {
  return B = B.toLowerCase(), B === "md5" ? new MD5$2() : B === "rmd160" || B === "ripemd160" ? new RIPEMD160$4() : new Hash(sha$3(B));
}, inherits$e = inherits_browserExports, Buffer$p = safeBufferExports$1.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$p.alloc(128), blocksize = 64;
function Hmac$3(A, B) {
  Base$4.call(this, "digest"), typeof B == "string" && (B = Buffer$p.from(B)), this._alg = A, this._key = B, B.length > blocksize ? B = A(B) : B.length < blocksize && (B = Buffer$p.concat([B, ZEROS$2], blocksize));
  for (var L = this._ipad = Buffer$p.allocUnsafe(blocksize), V = this._opad = Buffer$p.allocUnsafe(blocksize), J = 0; J < blocksize; J++)
    L[J] = B[J] ^ 54, V[J] = B[J] ^ 92;
  this._hash = [L];
}
inherits$e(Hmac$3, Base$4);
Hmac$3.prototype._update = function(A) {
  this._hash.push(A);
};
Hmac$3.prototype._final = function() {
  var A = this._alg(Buffer$p.concat(this._hash));
  return this._alg(Buffer$p.concat([this._opad, A]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$2 = function(A) {
  return new MD5$1().update(A).digest();
}, inherits$d = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$o = safeBufferExports$1.Buffer, md5$1 = md5$2, RIPEMD160$3 = ripemd160$1, sha$2 = sha_jsExports, ZEROS$1 = Buffer$o.alloc(128);
function Hmac$2(A, B) {
  Base$3.call(this, "digest"), typeof B == "string" && (B = Buffer$o.from(B));
  var L = A === "sha512" || A === "sha384" ? 128 : 64;
  if (this._alg = A, this._key = B, B.length > L) {
    var V = A === "rmd160" ? new RIPEMD160$3() : sha$2(A);
    B = V.update(B).digest();
  } else B.length < L && (B = Buffer$o.concat([B, ZEROS$1], L));
  for (var J = this._ipad = Buffer$o.allocUnsafe(L), re = this._opad = Buffer$o.allocUnsafe(L), ne = 0; ne < L; ne++)
    J[ne] = B[ne] ^ 54, re[ne] = B[ne] ^ 92;
  this._hash = A === "rmd160" ? new RIPEMD160$3() : sha$2(A), this._hash.update(J);
}
inherits$d(Hmac$2, Base$3);
Hmac$2.prototype._update = function(A) {
  this._hash.update(A);
};
Hmac$2.prototype._final = function() {
  var A = this._hash.digest(), B = this._alg === "rmd160" ? new RIPEMD160$3() : sha$2(this._alg);
  return B.update(this._opad).update(A).digest();
};
var browser$8 = function(B, L) {
  return B = B.toLowerCase(), B === "rmd160" || B === "ripemd160" ? new Hmac$2("rmd160", L) : B === "md5" ? new Legacy(md5$1, L) : new Hmac$2(B, L);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(A, B) {
  if (typeof A != "number")
    throw new TypeError("Iterations not a number");
  if (A < 0)
    throw new TypeError("Bad iterations");
  if (typeof B != "number")
    throw new TypeError("Key length not a number");
  if (B < 0 || B > MAX_ALLOC || B !== B)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, Buffer$n = safeBufferExports$1.Buffer, toBuffer$3 = function(A, B, L) {
  if (Buffer$n.isBuffer(A))
    return A;
  if (typeof A == "string")
    return Buffer$n.from(A, B);
  if (ArrayBuffer.isView(A))
    return Buffer$n.from(A.buffer);
  throw new TypeError(L + " must be a string, a Buffer, a typed array or a DataView");
}, md5 = md5$2, RIPEMD160$2 = ripemd160$1, sha$1 = sha_jsExports, Buffer$m = safeBufferExports$1.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$2 = toBuffer$3, ZEROS = Buffer$m.alloc(128), sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac$1(A, B, L) {
  var V = getDigest(A), J = A === "sha512" || A === "sha384" ? 128 : 64;
  B.length > J ? B = V(B) : B.length < J && (B = Buffer$m.concat([B, ZEROS], J));
  for (var re = Buffer$m.allocUnsafe(J + sizes[A]), ne = Buffer$m.allocUnsafe(J + sizes[A]), ie = 0; ie < J; ie++)
    re[ie] = B[ie] ^ 54, ne[ie] = B[ie] ^ 92;
  var pe = Buffer$m.allocUnsafe(J + L + 4);
  re.copy(pe, 0, 0, J), this.ipad1 = pe, this.ipad2 = re, this.opad = ne, this.alg = A, this.blocksize = J, this.hash = V, this.size = sizes[A];
}
Hmac$1.prototype.run = function(A, B) {
  A.copy(B, this.blocksize);
  var L = this.hash(B);
  return L.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function getDigest(A) {
  function B(V) {
    return sha$1(A).update(V).digest();
  }
  function L(V) {
    return new RIPEMD160$2().update(V).digest();
  }
  return A === "rmd160" || A === "ripemd160" ? L : A === "md5" ? md5 : B;
}
function pbkdf2(A, B, L, V, J) {
  checkParameters$1(L, V), A = toBuffer$2(A, defaultEncoding$1, "Password"), B = toBuffer$2(B, defaultEncoding$1, "Salt"), J = J || "sha1";
  var re = new Hmac$1(J, A, B.length), ne = Buffer$m.allocUnsafe(V), ie = Buffer$m.allocUnsafe(B.length + 4);
  B.copy(ie, 0, 0, B.length);
  for (var pe = 0, nt = sizes[J], oe = Math.ceil(V / nt), Ce = 1; Ce <= oe; Ce++) {
    ie.writeUInt32BE(Ce, B.length);
    for (var at = re.run(ie, re.ipad1), it = at, gt = 1; gt < L; gt++) {
      it = re.run(it, re.ipad2);
      for (var St = 0; St < nt; St++) at[St] ^= it[St];
    }
    at.copy(ne, pe), pe += nt;
  }
  return ne;
}
var syncBrowser = pbkdf2, Buffer$l = safeBufferExports$1.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer$1 = toBuffer$3, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [];
function checkNative(A) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[A] !== void 0)
    return checks[A];
  ZERO_BUF = ZERO_BUF || Buffer$l.alloc(8);
  var B = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, A).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return checks[A] = B, B;
}
var nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(A, B, L, V, J) {
  return subtle.importKey(
    "raw",
    A,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(re) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: B,
      iterations: L,
      hash: {
        name: J
      }
    }, re, V << 3);
  }).then(function(re) {
    return Buffer$l.from(re);
  });
}
function resolvePromise(A, B) {
  A.then(function(L) {
    getNextTick()(function() {
      B(null, L);
    });
  }, function(L) {
    getNextTick()(function() {
      B(L);
    });
  });
}
var async = function(A, B, L, V, J, re) {
  typeof J == "function" && (re = J, J = void 0), J = J || "sha1";
  var ne = toBrowser[J.toLowerCase()];
  if (!ne || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var ie;
      try {
        ie = sync(A, B, L, V, J);
      } catch (pe) {
        return re(pe);
      }
      re(null, ie);
    });
    return;
  }
  if (checkParameters(L, V), A = toBuffer$1(A, defaultEncoding, "Password"), B = toBuffer$1(B, defaultEncoding, "Salt"), typeof re != "function") throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(ne).then(function(ie) {
    return ie ? browserPbkdf2(A, B, L, V, ne) : sync(A, B, L, V, J);
  }), re);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$o = {};
utils$o.readUInt32BE = function(B, L) {
  var V = B[0 + L] << 24 | B[1 + L] << 16 | B[2 + L] << 8 | B[3 + L];
  return V >>> 0;
};
utils$o.writeUInt32BE = function(B, L, V) {
  B[0 + V] = L >>> 24, B[1 + V] = L >>> 16 & 255, B[2 + V] = L >>> 8 & 255, B[3 + V] = L & 255;
};
utils$o.ip = function(B, L, V, J) {
  for (var re = 0, ne = 0, ie = 6; ie >= 0; ie -= 2) {
    for (var pe = 0; pe <= 24; pe += 8)
      re <<= 1, re |= L >>> pe + ie & 1;
    for (var pe = 0; pe <= 24; pe += 8)
      re <<= 1, re |= B >>> pe + ie & 1;
  }
  for (var ie = 6; ie >= 0; ie -= 2) {
    for (var pe = 1; pe <= 25; pe += 8)
      ne <<= 1, ne |= L >>> pe + ie & 1;
    for (var pe = 1; pe <= 25; pe += 8)
      ne <<= 1, ne |= B >>> pe + ie & 1;
  }
  V[J + 0] = re >>> 0, V[J + 1] = ne >>> 0;
};
utils$o.rip = function(B, L, V, J) {
  for (var re = 0, ne = 0, ie = 0; ie < 4; ie++)
    for (var pe = 24; pe >= 0; pe -= 8)
      re <<= 1, re |= L >>> pe + ie & 1, re <<= 1, re |= B >>> pe + ie & 1;
  for (var ie = 4; ie < 8; ie++)
    for (var pe = 24; pe >= 0; pe -= 8)
      ne <<= 1, ne |= L >>> pe + ie & 1, ne <<= 1, ne |= B >>> pe + ie & 1;
  V[J + 0] = re >>> 0, V[J + 1] = ne >>> 0;
};
utils$o.pc1 = function(B, L, V, J) {
  for (var re = 0, ne = 0, ie = 7; ie >= 5; ie--) {
    for (var pe = 0; pe <= 24; pe += 8)
      re <<= 1, re |= L >> pe + ie & 1;
    for (var pe = 0; pe <= 24; pe += 8)
      re <<= 1, re |= B >> pe + ie & 1;
  }
  for (var pe = 0; pe <= 24; pe += 8)
    re <<= 1, re |= L >> pe + ie & 1;
  for (var ie = 1; ie <= 3; ie++) {
    for (var pe = 0; pe <= 24; pe += 8)
      ne <<= 1, ne |= L >> pe + ie & 1;
    for (var pe = 0; pe <= 24; pe += 8)
      ne <<= 1, ne |= B >> pe + ie & 1;
  }
  for (var pe = 0; pe <= 24; pe += 8)
    ne <<= 1, ne |= B >> pe + ie & 1;
  V[J + 0] = re >>> 0, V[J + 1] = ne >>> 0;
};
utils$o.r28shl = function(B, L) {
  return B << L & 268435455 | B >>> 28 - L;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$o.pc2 = function(B, L, V, J) {
  for (var re = 0, ne = 0, ie = pc2table.length >>> 1, pe = 0; pe < ie; pe++)
    re <<= 1, re |= B >>> pc2table[pe] & 1;
  for (var pe = ie; pe < pc2table.length; pe++)
    ne <<= 1, ne |= L >>> pc2table[pe] & 1;
  V[J + 0] = re >>> 0, V[J + 1] = ne >>> 0;
};
utils$o.expand = function(B, L, V) {
  var J = 0, re = 0;
  J = (B & 1) << 5 | B >>> 27;
  for (var ne = 23; ne >= 15; ne -= 4)
    J <<= 6, J |= B >>> ne & 63;
  for (var ne = 11; ne >= 3; ne -= 4)
    re |= B >>> ne & 63, re <<= 6;
  re |= (B & 31) << 1 | B >>> 31, L[V + 0] = J >>> 0, L[V + 1] = re >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$o.substitute = function(B, L) {
  for (var V = 0, J = 0; J < 4; J++) {
    var re = B >>> 18 - J * 6 & 63, ne = sTable[J * 64 + re];
    V <<= 4, V |= ne;
  }
  for (var J = 0; J < 4; J++) {
    var re = L >>> 18 - J * 6 & 63, ne = sTable[4 * 64 + J * 64 + re];
    V <<= 4, V |= ne;
  }
  return V >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$o.permute = function(B) {
  for (var L = 0, V = 0; V < permuteTable.length; V++)
    L <<= 1, L |= B >>> permuteTable[V] & 1;
  return L >>> 0;
};
utils$o.padSplit = function(B, L, V) {
  for (var J = B.toString(2); J.length < L; )
    J = "0" + J;
  for (var re = [], ne = 0; ne < L; ne += V)
    re.push(J.slice(ne, ne + V));
  return re.join(" ");
};
var minimalisticAssert = assert$j;
function assert$j(A, B) {
  if (!A)
    throw new Error(B || "Assertion failed");
}
assert$j.equal = function(B, L, V) {
  if (B != L)
    throw new Error(V || "Assertion failed: " + B + " != " + L);
};
var assert$i = minimalisticAssert;
function Cipher$3(A) {
  this.options = A, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = A.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(B) {
  return B.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(B) : this._updateEncrypt(B);
};
Cipher$3.prototype._buffer = function(B, L) {
  for (var V = Math.min(this.buffer.length - this.bufferOff, B.length - L), J = 0; J < V; J++)
    this.buffer[this.bufferOff + J] = B[L + J];
  return this.bufferOff += V, V;
};
Cipher$3.prototype._flushBuffer = function(B, L) {
  return this._update(this.buffer, 0, B, L), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(B) {
  var L = 0, V = 0, J = (this.bufferOff + B.length) / this.blockSize | 0, re = new Array(J * this.blockSize);
  this.bufferOff !== 0 && (L += this._buffer(B, L), this.bufferOff === this.buffer.length && (V += this._flushBuffer(re, V)));
  for (var ne = B.length - (B.length - L) % this.blockSize; L < ne; L += this.blockSize)
    this._update(B, L, re, V), V += this.blockSize;
  for (; L < B.length; L++, this.bufferOff++)
    this.buffer[this.bufferOff] = B[L];
  return re;
};
Cipher$3.prototype._updateDecrypt = function(B) {
  for (var L = 0, V = 0, J = Math.ceil((this.bufferOff + B.length) / this.blockSize) - 1, re = new Array(J * this.blockSize); J > 0; J--)
    L += this._buffer(B, L), V += this._flushBuffer(re, V);
  return L += this._buffer(B, L), re;
};
Cipher$3.prototype.final = function(B) {
  var L;
  B && (L = this.update(B));
  var V;
  return this.type === "encrypt" ? V = this._finalEncrypt() : V = this._finalDecrypt(), L ? L.concat(V) : V;
};
Cipher$3.prototype._pad = function(B, L) {
  if (L === 0)
    return !1;
  for (; L < B.length; )
    B[L++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var B = new Array(this.blockSize);
  return this._update(this.buffer, 0, B, 0), B;
};
Cipher$3.prototype._unpad = function(B) {
  return B;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$i.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var B = new Array(this.blockSize);
  return this._flushBuffer(B, 0), this._unpad(B);
};
var assert$h = minimalisticAssert, inherits$c = inherits_browserExports, utils$n = utils$o, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(A) {
  Cipher$2.call(this, A);
  var B = new DESState();
  this._desState = B, this.deriveKeys(B, A.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(B) {
  return new DES$3(B);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(B, L) {
  B.keys = new Array(16 * 2), assert$h.equal(L.length, this.blockSize, "Invalid key length");
  var V = utils$n.readUInt32BE(L, 0), J = utils$n.readUInt32BE(L, 4);
  utils$n.pc1(V, J, B.tmp, 0), V = B.tmp[0], J = B.tmp[1];
  for (var re = 0; re < B.keys.length; re += 2) {
    var ne = shiftTable[re >>> 1];
    V = utils$n.r28shl(V, ne), J = utils$n.r28shl(J, ne), utils$n.pc2(V, J, B.keys, re);
  }
};
DES$3.prototype._update = function(B, L, V, J) {
  var re = this._desState, ne = utils$n.readUInt32BE(B, L), ie = utils$n.readUInt32BE(B, L + 4);
  utils$n.ip(ne, ie, re.tmp, 0), ne = re.tmp[0], ie = re.tmp[1], this.type === "encrypt" ? this._encrypt(re, ne, ie, re.tmp, 0) : this._decrypt(re, ne, ie, re.tmp, 0), ne = re.tmp[0], ie = re.tmp[1], utils$n.writeUInt32BE(V, ne, J), utils$n.writeUInt32BE(V, ie, J + 4);
};
DES$3.prototype._pad = function(B, L) {
  if (this.padding === !1)
    return !1;
  for (var V = B.length - L, J = L; J < B.length; J++)
    B[J] = V;
  return !0;
};
DES$3.prototype._unpad = function(B) {
  if (this.padding === !1)
    return B;
  for (var L = B[B.length - 1], V = B.length - L; V < B.length; V++)
    assert$h.equal(B[V], L);
  return B.slice(0, B.length - L);
};
DES$3.prototype._encrypt = function(B, L, V, J, re) {
  for (var ne = L, ie = V, pe = 0; pe < B.keys.length; pe += 2) {
    var nt = B.keys[pe], oe = B.keys[pe + 1];
    utils$n.expand(ie, B.tmp, 0), nt ^= B.tmp[0], oe ^= B.tmp[1];
    var Ce = utils$n.substitute(nt, oe), at = utils$n.permute(Ce), it = ie;
    ie = (ne ^ at) >>> 0, ne = it;
  }
  utils$n.rip(ie, ne, J, re);
};
DES$3.prototype._decrypt = function(B, L, V, J, re) {
  for (var ne = V, ie = L, pe = B.keys.length - 2; pe >= 0; pe -= 2) {
    var nt = B.keys[pe], oe = B.keys[pe + 1];
    utils$n.expand(ne, B.tmp, 0), nt ^= B.tmp[0], oe ^= B.tmp[1];
    var Ce = utils$n.substitute(nt, oe), at = utils$n.permute(Ce), it = ne;
    ne = (ie ^ at) >>> 0, ie = it;
  }
  utils$n.rip(ne, ie, J, re);
};
var cbc$1 = {}, assert$g = minimalisticAssert, inherits$b = inherits_browserExports, proto = {};
function CBCState(A) {
  assert$g.equal(A.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var B = 0; B < this.iv.length; B++)
    this.iv[B] = A[B];
}
function instantiate(A) {
  function B(re) {
    A.call(this, re), this._cbcInit();
  }
  inherits$b(B, A);
  for (var L = Object.keys(proto), V = 0; V < L.length; V++) {
    var J = L[V];
    B.prototype[J] = proto[J];
  }
  return B.create = function(ne) {
    return new B(ne);
  }, B;
}
cbc$1.instantiate = instantiate;
proto._cbcInit = function() {
  var B = new CBCState(this.options.iv);
  this._cbcState = B;
};
proto._update = function(B, L, V, J) {
  var re = this._cbcState, ne = this.constructor.super_.prototype, ie = re.iv;
  if (this.type === "encrypt") {
    for (var pe = 0; pe < this.blockSize; pe++)
      ie[pe] ^= B[L + pe];
    ne._update.call(this, ie, 0, V, J);
    for (var pe = 0; pe < this.blockSize; pe++)
      ie[pe] = V[J + pe];
  } else {
    ne._update.call(this, B, L, V, J);
    for (var pe = 0; pe < this.blockSize; pe++)
      V[J + pe] ^= ie[pe];
    for (var pe = 0; pe < this.blockSize; pe++)
      ie[pe] = B[L + pe];
  }
};
var assert$f = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(A, B) {
  assert$f.equal(B.length, 24, "Invalid key length");
  var L = B.slice(0, 8), V = B.slice(8, 16), J = B.slice(16, 24);
  A === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: L }),
    DES$2.create({ type: "decrypt", key: V }),
    DES$2.create({ type: "encrypt", key: J })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: J }),
    DES$2.create({ type: "encrypt", key: V }),
    DES$2.create({ type: "decrypt", key: L })
  ];
}
function EDE(A) {
  Cipher$1.call(this, A);
  var B = new EDEState(this.type, this.options.key);
  this._edeState = B;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(B) {
  return new EDE(B);
};
EDE.prototype._update = function(B, L, V, J) {
  var re = this._edeState;
  re.ciphers[0]._update(B, L, V, J), re.ciphers[1]._update(V, J, V, J), re.ciphers[2]._update(V, J, V, J);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$o;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$k = safeBufferExports$1.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(A) {
  CipherBase.call(this);
  var B = A.mode.toLowerCase(), L = modes$3[B], V;
  A.decrypt ? V = "decrypt" : V = "encrypt";
  var J = A.key;
  Buffer$k.isBuffer(J) || (J = Buffer$k.from(J)), (B === "des-ede" || B === "des-ede-cbc") && (J = Buffer$k.concat([J, J.slice(0, 8)]));
  var re = A.iv;
  Buffer$k.isBuffer(re) || (re = Buffer$k.from(re)), this._des = L.create({
    key: J,
    iv: re,
    type: V
  });
}
DES$1.prototype._update = function(A) {
  return Buffer$k.from(this._des.update(A));
};
DES$1.prototype._final = function() {
  return Buffer$k.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(A, B) {
  return A._cipher.encryptBlock(B);
};
ecb.decrypt = function(A, B) {
  return A._cipher.decryptBlock(B);
};
var cbc = {}, bufferXor = function(B, L) {
  for (var V = Math.min(B.length, L.length), J = new Buffer$D(V), re = 0; re < V; ++re)
    J[re] = B[re] ^ L[re];
  return J;
}, xor$7 = bufferXor;
cbc.encrypt = function(A, B) {
  var L = xor$7(B, A._prev);
  return A._prev = A._cipher.encryptBlock(L), A._prev;
};
cbc.decrypt = function(A, B) {
  var L = A._prev;
  A._prev = B;
  var V = A._cipher.decryptBlock(B);
  return xor$7(V, L);
};
var cfb = {}, Buffer$j = safeBufferExports$1.Buffer, xor$6 = bufferXor;
function encryptStart(A, B, L) {
  var V = B.length, J = xor$6(B, A._cache);
  return A._cache = A._cache.slice(V), A._prev = Buffer$j.concat([A._prev, L ? B : J]), J;
}
cfb.encrypt = function(A, B, L) {
  for (var V = Buffer$j.allocUnsafe(0), J; B.length; )
    if (A._cache.length === 0 && (A._cache = A._cipher.encryptBlock(A._prev), A._prev = Buffer$j.allocUnsafe(0)), A._cache.length <= B.length)
      J = A._cache.length, V = Buffer$j.concat([V, encryptStart(A, B.slice(0, J), L)]), B = B.slice(J);
    else {
      V = Buffer$j.concat([V, encryptStart(A, B, L)]);
      break;
    }
  return V;
};
var cfb8 = {}, Buffer$i = safeBufferExports$1.Buffer;
function encryptByte$1(A, B, L) {
  var V = A._cipher.encryptBlock(A._prev), J = V[0] ^ B;
  return A._prev = Buffer$i.concat([
    A._prev.slice(1),
    Buffer$i.from([L ? B : J])
  ]), J;
}
cfb8.encrypt = function(A, B, L) {
  for (var V = B.length, J = Buffer$i.allocUnsafe(V), re = -1; ++re < V; )
    J[re] = encryptByte$1(A, B[re], L);
  return J;
};
var cfb1 = {}, Buffer$h = safeBufferExports$1.Buffer;
function encryptByte(A, B, L) {
  for (var V, J = -1, re = 8, ne = 0, ie, pe; ++J < re; )
    V = A._cipher.encryptBlock(A._prev), ie = B & 1 << 7 - J ? 128 : 0, pe = V[0] ^ ie, ne += (pe & 128) >> J % 8, A._prev = shiftIn(A._prev, L ? ie : pe);
  return ne;
}
function shiftIn(A, B) {
  var L = A.length, V = -1, J = Buffer$h.allocUnsafe(A.length);
  for (A = Buffer$h.concat([A, Buffer$h.from([B])]); ++V < L; )
    J[V] = A[V] << 1 | A[V + 1] >> 7;
  return J;
}
cfb1.encrypt = function(A, B, L) {
  for (var V = B.length, J = Buffer$h.allocUnsafe(V), re = -1; ++re < V; )
    J[re] = encryptByte(A, B[re], L);
  return J;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(A) {
  return A._prev = A._cipher.encryptBlock(A._prev), A._prev;
}
ofb.encrypt = function(A, B) {
  for (; A._cache.length < B.length; )
    A._cache = Buffer$D.concat([A._cache, getBlock$1(A)]);
  var L = A._cache.slice(0, B.length);
  return A._cache = A._cache.slice(B.length), xor$5(B, L);
};
var ctr = {};
function incr32$2(A) {
  for (var B = A.length, L; B--; )
    if (L = A.readUInt8(B), L === 255)
      A.writeUInt8(0, B);
    else {
      L++, A.writeUInt8(L, B);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$g = safeBufferExports$1.Buffer, incr32$1 = incr32_1;
function getBlock(A) {
  var B = A._cipher.encryptBlockRaw(A._prev);
  return incr32$1(A._prev), B;
}
var blockSize = 16;
ctr.encrypt = function(A, B) {
  var L = Math.ceil(B.length / blockSize), V = A._cache.length;
  A._cache = Buffer$g.concat([
    A._cache,
    Buffer$g.allocUnsafe(L * blockSize)
  ]);
  for (var J = 0; J < L; J++) {
    var re = getBlock(A), ne = V + J * blockSize;
    A._cache.writeUInt32BE(re[0], ne + 0), A._cache.writeUInt32BE(re[1], ne + 4), A._cache.writeUInt32BE(re[2], ne + 8), A._cache.writeUInt32BE(re[3], ne + 12);
  }
  var ie = A._cache.slice(0, B.length);
  return A._cache = A._cache.slice(B.length), xor$4(B, ie);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$f = safeBufferExports$1.Buffer;
function asUInt32Array(A) {
  Buffer$f.isBuffer(A) || (A = Buffer$f.from(A));
  for (var B = A.length / 4 | 0, L = new Array(B), V = 0; V < B; V++)
    L[V] = A.readUInt32BE(V * 4);
  return L;
}
function scrubVec(A) {
  for (var B = 0; B < A.length; A++)
    A[B] = 0;
}
function cryptBlock(A, B, L, V, J) {
  for (var re = L[0], ne = L[1], ie = L[2], pe = L[3], nt = A[0] ^ B[0], oe = A[1] ^ B[1], Ce = A[2] ^ B[2], at = A[3] ^ B[3], it, gt, St, xt, Mt = 4, bt = 1; bt < J; bt++)
    it = re[nt >>> 24] ^ ne[oe >>> 16 & 255] ^ ie[Ce >>> 8 & 255] ^ pe[at & 255] ^ B[Mt++], gt = re[oe >>> 24] ^ ne[Ce >>> 16 & 255] ^ ie[at >>> 8 & 255] ^ pe[nt & 255] ^ B[Mt++], St = re[Ce >>> 24] ^ ne[at >>> 16 & 255] ^ ie[nt >>> 8 & 255] ^ pe[oe & 255] ^ B[Mt++], xt = re[at >>> 24] ^ ne[nt >>> 16 & 255] ^ ie[oe >>> 8 & 255] ^ pe[Ce & 255] ^ B[Mt++], nt = it, oe = gt, Ce = St, at = xt;
  return it = (V[nt >>> 24] << 24 | V[oe >>> 16 & 255] << 16 | V[Ce >>> 8 & 255] << 8 | V[at & 255]) ^ B[Mt++], gt = (V[oe >>> 24] << 24 | V[Ce >>> 16 & 255] << 16 | V[at >>> 8 & 255] << 8 | V[nt & 255]) ^ B[Mt++], St = (V[Ce >>> 24] << 24 | V[at >>> 16 & 255] << 16 | V[nt >>> 8 & 255] << 8 | V[oe & 255]) ^ B[Mt++], xt = (V[at >>> 24] << 24 | V[nt >>> 16 & 255] << 16 | V[oe >>> 8 & 255] << 8 | V[Ce & 255]) ^ B[Mt++], it = it >>> 0, gt = gt >>> 0, St = St >>> 0, xt = xt >>> 0, [it, gt, St, xt];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var A = new Array(256), B = 0; B < 256; B++)
    B < 128 ? A[B] = B << 1 : A[B] = B << 1 ^ 283;
  for (var L = [], V = [], J = [[], [], [], []], re = [[], [], [], []], ne = 0, ie = 0, pe = 0; pe < 256; ++pe) {
    var nt = ie ^ ie << 1 ^ ie << 2 ^ ie << 3 ^ ie << 4;
    nt = nt >>> 8 ^ nt & 255 ^ 99, L[ne] = nt, V[nt] = ne;
    var oe = A[ne], Ce = A[oe], at = A[Ce], it = A[nt] * 257 ^ nt * 16843008;
    J[0][ne] = it << 24 | it >>> 8, J[1][ne] = it << 16 | it >>> 16, J[2][ne] = it << 8 | it >>> 24, J[3][ne] = it, it = at * 16843009 ^ Ce * 65537 ^ oe * 257 ^ ne * 16843008, re[0][nt] = it << 24 | it >>> 8, re[1][nt] = it << 16 | it >>> 16, re[2][nt] = it << 8 | it >>> 24, re[3][nt] = it, ne === 0 ? ne = ie = 1 : (ne = oe ^ A[A[A[at ^ oe]]], ie ^= A[A[ie]]);
  }
  return {
    SBOX: L,
    INV_SBOX: V,
    SUB_MIX: J,
    INV_SUB_MIX: re
  };
}();
function AES(A) {
  this._key = asUInt32Array(A), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var A = this._key, B = A.length, L = B + 6, V = (L + 1) * 4, J = [], re = 0; re < B; re++)
    J[re] = A[re];
  for (re = B; re < V; re++) {
    var ne = J[re - 1];
    re % B === 0 ? (ne = ne << 8 | ne >>> 24, ne = G.SBOX[ne >>> 24] << 24 | G.SBOX[ne >>> 16 & 255] << 16 | G.SBOX[ne >>> 8 & 255] << 8 | G.SBOX[ne & 255], ne ^= RCON[re / B | 0] << 24) : B > 6 && re % B === 4 && (ne = G.SBOX[ne >>> 24] << 24 | G.SBOX[ne >>> 16 & 255] << 16 | G.SBOX[ne >>> 8 & 255] << 8 | G.SBOX[ne & 255]), J[re] = J[re - B] ^ ne;
  }
  for (var ie = [], pe = 0; pe < V; pe++) {
    var nt = V - pe, oe = J[nt - (pe % 4 ? 0 : 4)];
    pe < 4 || nt <= 4 ? ie[pe] = oe : ie[pe] = G.INV_SUB_MIX[0][G.SBOX[oe >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[oe >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[oe >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[oe & 255]];
  }
  this._nRounds = L, this._keySchedule = J, this._invKeySchedule = ie;
};
AES.prototype.encryptBlockRaw = function(A) {
  return A = asUInt32Array(A), cryptBlock(A, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(A) {
  var B = this.encryptBlockRaw(A), L = Buffer$f.allocUnsafe(16);
  return L.writeUInt32BE(B[0], 0), L.writeUInt32BE(B[1], 4), L.writeUInt32BE(B[2], 8), L.writeUInt32BE(B[3], 12), L;
};
AES.prototype.decryptBlock = function(A) {
  A = asUInt32Array(A);
  var B = A[1];
  A[1] = A[3], A[3] = B;
  var L = cryptBlock(A, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), V = Buffer$f.allocUnsafe(16);
  return V.writeUInt32BE(L[0], 0), V.writeUInt32BE(L[3], 4), V.writeUInt32BE(L[2], 8), V.writeUInt32BE(L[1], 12), V;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$e = safeBufferExports$1.Buffer, ZEROES = Buffer$e.alloc(16, 0);
function toArray$1(A) {
  return [
    A.readUInt32BE(0),
    A.readUInt32BE(4),
    A.readUInt32BE(8),
    A.readUInt32BE(12)
  ];
}
function fromArray(A) {
  var B = Buffer$e.allocUnsafe(16);
  return B.writeUInt32BE(A[0] >>> 0, 0), B.writeUInt32BE(A[1] >>> 0, 4), B.writeUInt32BE(A[2] >>> 0, 8), B.writeUInt32BE(A[3] >>> 0, 12), B;
}
function GHASH$1(A) {
  this.h = A, this.state = Buffer$e.alloc(16, 0), this.cache = Buffer$e.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(A) {
  for (var B = -1; ++B < A.length; )
    this.state[B] ^= A[B];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var A = toArray$1(this.h), B = [0, 0, 0, 0], L, V, J, re = -1; ++re < 128; ) {
    for (V = (this.state[~~(re / 8)] & 1 << 7 - re % 8) !== 0, V && (B[0] ^= A[0], B[1] ^= A[1], B[2] ^= A[2], B[3] ^= A[3]), J = (A[3] & 1) !== 0, L = 3; L > 0; L--)
      A[L] = A[L] >>> 1 | (A[L - 1] & 1) << 31;
    A[0] = A[0] >>> 1, J && (A[0] = A[0] ^ 225 << 24);
  }
  this.state = fromArray(B);
};
GHASH$1.prototype.update = function(A) {
  this.cache = Buffer$e.concat([this.cache, A]);
  for (var B; this.cache.length >= 16; )
    B = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(B);
};
GHASH$1.prototype.final = function(A, B) {
  return this.cache.length && this.ghash(Buffer$e.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, A, 0, B])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$d = safeBufferExports$1.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(A, B) {
  var L = 0;
  A.length !== B.length && L++;
  for (var V = Math.min(A.length, B.length), J = 0; J < V; ++J)
    L += A[J] ^ B[J];
  return L;
}
function calcIv(A, B, L) {
  if (B.length === 12)
    return A._finID = Buffer$d.concat([B, Buffer$d.from([0, 0, 0, 1])]), Buffer$d.concat([B, Buffer$d.from([0, 0, 0, 2])]);
  var V = new GHASH(L), J = B.length, re = J % 16;
  V.update(B), re && (re = 16 - re, V.update(Buffer$d.alloc(re, 0))), V.update(Buffer$d.alloc(8, 0));
  var ne = J * 8, ie = Buffer$d.alloc(8);
  ie.writeUIntBE(ne, 0, 8), V.update(ie), A._finID = V.state;
  var pe = Buffer$d.from(A._finID);
  return incr32(pe), pe;
}
function StreamCipher$3(A, B, L, V) {
  Transform$5.call(this);
  var J = Buffer$d.alloc(4, 0);
  this._cipher = new aes$4.AES(B);
  var re = this._cipher.encryptBlock(J);
  this._ghash = new GHASH(re), L = calcIv(this, L, re), this._prev = Buffer$d.from(L), this._cache = Buffer$d.allocUnsafe(0), this._secCache = Buffer$d.allocUnsafe(0), this._decrypt = V, this._alen = 0, this._len = 0, this._mode = A, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(A) {
  if (!this._called && this._alen) {
    var B = 16 - this._alen % 16;
    B < 16 && (B = Buffer$d.alloc(B, 0), this._ghash.update(B));
  }
  this._called = !0;
  var L = this._mode.encrypt(this, A);
  return this._decrypt ? this._ghash.update(A) : this._ghash.update(L), this._len += A.length, L;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var A = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(A, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = A, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$d.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(B) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = B;
};
StreamCipher$3.prototype.setAAD = function(B) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(B), this._alen += B.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$c = safeBufferExports$1.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(A, B, L, V) {
  Transform$4.call(this), this._cipher = new aes$3.AES(B), this._prev = Buffer$c.from(L), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = V, this._mode = A;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(A) {
  return this._mode.encrypt(this, A, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$b = safeBufferExports$1.Buffer, MD5 = md5_js;
function EVP_BytesToKey(A, B, L, V) {
  if (Buffer$b.isBuffer(A) || (A = Buffer$b.from(A, "binary")), B && (Buffer$b.isBuffer(B) || (B = Buffer$b.from(B, "binary")), B.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var J = L / 8, re = Buffer$b.alloc(J), ne = Buffer$b.alloc(V || 0), ie = Buffer$b.alloc(0); J > 0 || V > 0; ) {
    var pe = new MD5();
    pe.update(ie), pe.update(A), B && pe.update(B), ie = pe.digest();
    var nt = 0;
    if (J > 0) {
      var oe = re.length - J;
      nt = Math.min(J, ie.length), ie.copy(re, oe, 0, nt), J -= nt;
    }
    if (nt < ie.length && V > 0) {
      var Ce = ne.length - V, at = Math.min(V, ie.length - nt);
      ie.copy(ne, Ce, nt, nt + at), V -= at;
    }
  }
  return ie.fill(0), { key: re, iv: ne };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$a = safeBufferExports$1.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(A, B, L) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(B), this._prev = Buffer$a.from(L), this._mode = A, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(A) {
  this._cache.add(A);
  for (var B, L, V = []; B = this._cache.get(); )
    L = this._mode.encrypt(this, B), V.push(L);
  return Buffer$a.concat(V);
};
var PADDING = Buffer$a.alloc(16, 16);
Cipher.prototype._final = function() {
  var A = this._cache.flush();
  if (this._autopadding)
    return A = this._mode.encrypt(this, A), this._cipher.scrub(), A;
  if (!A.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(A) {
  return this._autopadding = !!A, this;
};
function Splitter$1() {
  this.cache = Buffer$a.allocUnsafe(0);
}
Splitter$1.prototype.add = function(A) {
  this.cache = Buffer$a.concat([this.cache, A]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var A = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), A;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var A = 16 - this.cache.length, B = Buffer$a.allocUnsafe(A), L = -1; ++L < A; )
    B.writeUInt8(A, L);
  return Buffer$a.concat([this.cache, B]);
};
function createCipheriv$1(A, B, L) {
  var V = MODES$1[A.toLowerCase()];
  if (!V) throw new TypeError("invalid suite type");
  if (typeof B == "string" && (B = Buffer$a.from(B)), B.length !== V.key / 8) throw new TypeError("invalid key length " + B.length);
  if (typeof L == "string" && (L = Buffer$a.from(L)), V.mode !== "GCM" && L.length !== V.iv) throw new TypeError("invalid iv length " + L.length);
  return V.type === "stream" ? new StreamCipher$1(V.module, B, L) : V.type === "auth" ? new AuthCipher$1(V.module, B, L) : new Cipher(V.module, B, L);
}
function createCipher$1(A, B) {
  var L = MODES$1[A.toLowerCase()];
  if (!L) throw new TypeError("invalid suite type");
  var V = ebtk$2(B, !1, L.key, L.iv);
  return createCipheriv$1(A, V.key, V.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$9 = safeBufferExports$1.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(A, B, L) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(B), this._prev = Buffer$9.from(L), this._mode = A, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(A) {
  this._cache.add(A);
  for (var B, L, V = []; B = this._cache.get(this._autopadding); )
    L = this._mode.decrypt(this, B), V.push(L);
  return Buffer$9.concat(V);
};
Decipher.prototype._final = function() {
  var A = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, A));
  if (A)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(A) {
  return this._autopadding = !!A, this;
};
function Splitter() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter.prototype.add = function(A) {
  this.cache = Buffer$9.concat([this.cache, A]);
};
Splitter.prototype.get = function(A) {
  var B;
  if (A) {
    if (this.cache.length > 16)
      return B = this.cache.slice(0, 16), this.cache = this.cache.slice(16), B;
  } else if (this.cache.length >= 16)
    return B = this.cache.slice(0, 16), this.cache = this.cache.slice(16), B;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(A) {
  var B = A[15];
  if (B < 1 || B > 16)
    throw new Error("unable to decrypt data");
  for (var L = -1; ++L < B; )
    if (A[L + (16 - B)] !== B)
      throw new Error("unable to decrypt data");
  if (B !== 16)
    return A.slice(0, 16 - B);
}
function createDecipheriv$1(A, B, L) {
  var V = MODES[A.toLowerCase()];
  if (!V) throw new TypeError("invalid suite type");
  if (typeof L == "string" && (L = Buffer$9.from(L)), V.mode !== "GCM" && L.length !== V.iv) throw new TypeError("invalid iv length " + L.length);
  if (typeof B == "string" && (B = Buffer$9.from(B)), B.length !== V.key / 8) throw new TypeError("invalid key length " + B.length);
  return V.type === "stream" ? new StreamCipher(V.module, B, L, !0) : V.type === "auth" ? new AuthCipher(V.module, B, L, !0) : new Decipher(V.module, B, L);
}
function createDecipher$1(A, B) {
  var L = MODES[A.toLowerCase()];
  if (!L) throw new TypeError("invalid suite type");
  var V = ebtk$1(B, !1, L.key, L.iv);
  return createDecipheriv$1(A, V.key, V.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(A) {
  A["des-ecb"] = {
    key: 8,
    iv: 0
  }, A["des-cbc"] = A.des = {
    key: 8,
    iv: 8
  }, A["des-ede3-cbc"] = A.des3 = {
    key: 24,
    iv: 8
  }, A["des-ede3"] = {
    key: 24,
    iv: 0
  }, A["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, A["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(A, B) {
  A = A.toLowerCase();
  var L, V;
  if (aesModes[A])
    L = aesModes[A].key, V = aesModes[A].iv;
  else if (desModes[A])
    L = desModes[A].key * 8, V = desModes[A].iv;
  else
    throw new TypeError("invalid suite type");
  var J = ebtk(B, !1, L, V);
  return createCipheriv(A, J.key, J.iv);
}
function createDecipher(A, B) {
  A = A.toLowerCase();
  var L, V;
  if (aesModes[A])
    L = aesModes[A].key, V = aesModes[A].iv;
  else if (desModes[A])
    L = desModes[A].key * 8, V = desModes[A].iv;
  else
    throw new TypeError("invalid suite type");
  var J = ebtk(B, !1, L, V);
  return createDecipheriv(A, J.key, J.iv);
}
function createCipheriv(A, B, L) {
  if (A = A.toLowerCase(), aesModes[A]) return aes.createCipheriv(A, B, L);
  if (desModes[A]) return new DES({ key: B, iv: L, mode: A });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(A, B, L) {
  if (A = A.toLowerCase(), aesModes[A]) return aes.createDecipheriv(A, B, L);
  if (desModes[A]) return new DES({ key: B, iv: L, mode: A, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
(function(A) {
  (function(B, L) {
    function V(wt, ke) {
      if (!wt) throw new Error(ke || "Assertion failed");
    }
    function J(wt, ke) {
      wt.super_ = ke;
      var rt = function() {
      };
      rt.prototype = ke.prototype, wt.prototype = new rt(), wt.prototype.constructor = wt;
    }
    function re(wt, ke, rt) {
      if (re.isBN(wt))
        return wt;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, wt !== null && ((ke === "le" || ke === "be") && (rt = ke, ke = 10), this._init(wt || 0, ke || 10, rt || "be"));
    }
    typeof B == "object" ? B.exports = re : L.BN = re, re.BN = re, re.wordSize = 26;
    var ne;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? ne = window.Buffer : ne = dist$1.Buffer;
    } catch {
    }
    re.isBN = function(ke) {
      return ke instanceof re ? !0 : ke !== null && typeof ke == "object" && ke.constructor.wordSize === re.wordSize && Array.isArray(ke.words);
    }, re.max = function(ke, rt) {
      return ke.cmp(rt) > 0 ? ke : rt;
    }, re.min = function(ke, rt) {
      return ke.cmp(rt) < 0 ? ke : rt;
    }, re.prototype._init = function(ke, rt, ce) {
      if (typeof ke == "number")
        return this._initNumber(ke, rt, ce);
      if (typeof ke == "object")
        return this._initArray(ke, rt, ce);
      rt === "hex" && (rt = 16), V(rt === (rt | 0) && rt >= 2 && rt <= 36), ke = ke.toString().replace(/\s+/g, "");
      var Oe = 0;
      ke[0] === "-" && (Oe++, this.negative = 1), Oe < ke.length && (rt === 16 ? this._parseHex(ke, Oe, ce) : (this._parseBase(ke, rt, Oe), ce === "le" && this._initArray(this.toArray(), rt, ce)));
    }, re.prototype._initNumber = function(ke, rt, ce) {
      ke < 0 && (this.negative = 1, ke = -ke), ke < 67108864 ? (this.words = [ke & 67108863], this.length = 1) : ke < 4503599627370496 ? (this.words = [
        ke & 67108863,
        ke / 67108864 & 67108863
      ], this.length = 2) : (V(ke < 9007199254740992), this.words = [
        ke & 67108863,
        ke / 67108864 & 67108863,
        1
      ], this.length = 3), ce === "le" && this._initArray(this.toArray(), rt, ce);
    }, re.prototype._initArray = function(ke, rt, ce) {
      if (V(typeof ke.length == "number"), ke.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ke.length / 3), this.words = new Array(this.length);
      for (var Oe = 0; Oe < this.length; Oe++)
        this.words[Oe] = 0;
      var ot, ut, ht = 0;
      if (ce === "be")
        for (Oe = ke.length - 1, ot = 0; Oe >= 0; Oe -= 3)
          ut = ke[Oe] | ke[Oe - 1] << 8 | ke[Oe - 2] << 16, this.words[ot] |= ut << ht & 67108863, this.words[ot + 1] = ut >>> 26 - ht & 67108863, ht += 24, ht >= 26 && (ht -= 26, ot++);
      else if (ce === "le")
        for (Oe = 0, ot = 0; Oe < ke.length; Oe += 3)
          ut = ke[Oe] | ke[Oe + 1] << 8 | ke[Oe + 2] << 16, this.words[ot] |= ut << ht & 67108863, this.words[ot + 1] = ut >>> 26 - ht & 67108863, ht += 24, ht >= 26 && (ht -= 26, ot++);
      return this.strip();
    };
    function ie(wt, ke) {
      var rt = wt.charCodeAt(ke);
      return rt >= 65 && rt <= 70 ? rt - 55 : rt >= 97 && rt <= 102 ? rt - 87 : rt - 48 & 15;
    }
    function pe(wt, ke, rt) {
      var ce = ie(wt, rt);
      return rt - 1 >= ke && (ce |= ie(wt, rt - 1) << 4), ce;
    }
    re.prototype._parseHex = function(ke, rt, ce) {
      this.length = Math.ceil((ke.length - rt) / 6), this.words = new Array(this.length);
      for (var Oe = 0; Oe < this.length; Oe++)
        this.words[Oe] = 0;
      var ot = 0, ut = 0, ht;
      if (ce === "be")
        for (Oe = ke.length - 1; Oe >= rt; Oe -= 2)
          ht = pe(ke, rt, Oe) << ot, this.words[ut] |= ht & 67108863, ot >= 18 ? (ot -= 18, ut += 1, this.words[ut] |= ht >>> 26) : ot += 8;
      else {
        var dt = ke.length - rt;
        for (Oe = dt % 2 === 0 ? rt + 1 : rt; Oe < ke.length; Oe += 2)
          ht = pe(ke, rt, Oe) << ot, this.words[ut] |= ht & 67108863, ot >= 18 ? (ot -= 18, ut += 1, this.words[ut] |= ht >>> 26) : ot += 8;
      }
      this.strip();
    };
    function nt(wt, ke, rt, ce) {
      for (var Oe = 0, ot = Math.min(wt.length, rt), ut = ke; ut < ot; ut++) {
        var ht = wt.charCodeAt(ut) - 48;
        Oe *= ce, ht >= 49 ? Oe += ht - 49 + 10 : ht >= 17 ? Oe += ht - 17 + 10 : Oe += ht;
      }
      return Oe;
    }
    re.prototype._parseBase = function(ke, rt, ce) {
      this.words = [0], this.length = 1;
      for (var Oe = 0, ot = 1; ot <= 67108863; ot *= rt)
        Oe++;
      Oe--, ot = ot / rt | 0;
      for (var ut = ke.length - ce, ht = ut % Oe, dt = Math.min(ut, ut - ht) + ce, st = 0, yt = ce; yt < dt; yt += Oe)
        st = nt(ke, yt, yt + Oe, rt), this.imuln(ot), this.words[0] + st < 67108864 ? this.words[0] += st : this._iaddn(st);
      if (ht !== 0) {
        var ct = 1;
        for (st = nt(ke, yt, ke.length, rt), yt = 0; yt < ht; yt++)
          ct *= rt;
        this.imuln(ct), this.words[0] + st < 67108864 ? this.words[0] += st : this._iaddn(st);
      }
      this.strip();
    }, re.prototype.copy = function(ke) {
      ke.words = new Array(this.length);
      for (var rt = 0; rt < this.length; rt++)
        ke.words[rt] = this.words[rt];
      ke.length = this.length, ke.negative = this.negative, ke.red = this.red;
    }, re.prototype.clone = function() {
      var ke = new re(null);
      return this.copy(ke), ke;
    }, re.prototype._expand = function(ke) {
      for (; this.length < ke; )
        this.words[this.length++] = 0;
      return this;
    }, re.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, re.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, re.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var oe = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Ce = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], at = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    re.prototype.toString = function(ke, rt) {
      ke = ke || 10, rt = rt | 0 || 1;
      var ce;
      if (ke === 16 || ke === "hex") {
        ce = "";
        for (var Oe = 0, ot = 0, ut = 0; ut < this.length; ut++) {
          var ht = this.words[ut], dt = ((ht << Oe | ot) & 16777215).toString(16);
          ot = ht >>> 24 - Oe & 16777215, Oe += 2, Oe >= 26 && (Oe -= 26, ut--), ot !== 0 || ut !== this.length - 1 ? ce = oe[6 - dt.length] + dt + ce : ce = dt + ce;
        }
        for (ot !== 0 && (ce = ot.toString(16) + ce); ce.length % rt !== 0; )
          ce = "0" + ce;
        return this.negative !== 0 && (ce = "-" + ce), ce;
      }
      if (ke === (ke | 0) && ke >= 2 && ke <= 36) {
        var st = Ce[ke], yt = at[ke];
        ce = "";
        var ct = this.clone();
        for (ct.negative = 0; !ct.isZero(); ) {
          var At = ct.modn(yt).toString(ke);
          ct = ct.idivn(yt), ct.isZero() ? ce = At + ce : ce = oe[st - At.length] + At + ce;
        }
        for (this.isZero() && (ce = "0" + ce); ce.length % rt !== 0; )
          ce = "0" + ce;
        return this.negative !== 0 && (ce = "-" + ce), ce;
      }
      V(!1, "Base should be between 2 and 36");
    }, re.prototype.toNumber = function() {
      var ke = this.words[0];
      return this.length === 2 ? ke += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ke += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && V(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ke : ke;
    }, re.prototype.toJSON = function() {
      return this.toString(16);
    }, re.prototype.toBuffer = function(ke, rt) {
      return V(typeof ne < "u"), this.toArrayLike(ne, ke, rt);
    }, re.prototype.toArray = function(ke, rt) {
      return this.toArrayLike(Array, ke, rt);
    }, re.prototype.toArrayLike = function(ke, rt, ce) {
      var Oe = this.byteLength(), ot = ce || Math.max(1, Oe);
      V(Oe <= ot, "byte array longer than desired length"), V(ot > 0, "Requested array length <= 0"), this.strip();
      var ut = rt === "le", ht = new ke(ot), dt, st, yt = this.clone();
      if (ut) {
        for (st = 0; !yt.isZero(); st++)
          dt = yt.andln(255), yt.iushrn(8), ht[st] = dt;
        for (; st < ot; st++)
          ht[st] = 0;
      } else {
        for (st = 0; st < ot - Oe; st++)
          ht[st] = 0;
        for (st = 0; !yt.isZero(); st++)
          dt = yt.andln(255), yt.iushrn(8), ht[ot - st - 1] = dt;
      }
      return ht;
    }, Math.clz32 ? re.prototype._countBits = function(ke) {
      return 32 - Math.clz32(ke);
    } : re.prototype._countBits = function(ke) {
      var rt = ke, ce = 0;
      return rt >= 4096 && (ce += 13, rt >>>= 13), rt >= 64 && (ce += 7, rt >>>= 7), rt >= 8 && (ce += 4, rt >>>= 4), rt >= 2 && (ce += 2, rt >>>= 2), ce + rt;
    }, re.prototype._zeroBits = function(ke) {
      if (ke === 0) return 26;
      var rt = ke, ce = 0;
      return rt & 8191 || (ce += 13, rt >>>= 13), rt & 127 || (ce += 7, rt >>>= 7), rt & 15 || (ce += 4, rt >>>= 4), rt & 3 || (ce += 2, rt >>>= 2), rt & 1 || ce++, ce;
    }, re.prototype.bitLength = function() {
      var ke = this.words[this.length - 1], rt = this._countBits(ke);
      return (this.length - 1) * 26 + rt;
    };
    function it(wt) {
      for (var ke = new Array(wt.bitLength()), rt = 0; rt < ke.length; rt++) {
        var ce = rt / 26 | 0, Oe = rt % 26;
        ke[rt] = (wt.words[ce] & 1 << Oe) >>> Oe;
      }
      return ke;
    }
    re.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ke = 0, rt = 0; rt < this.length; rt++) {
        var ce = this._zeroBits(this.words[rt]);
        if (ke += ce, ce !== 26) break;
      }
      return ke;
    }, re.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, re.prototype.toTwos = function(ke) {
      return this.negative !== 0 ? this.abs().inotn(ke).iaddn(1) : this.clone();
    }, re.prototype.fromTwos = function(ke) {
      return this.testn(ke - 1) ? this.notn(ke).iaddn(1).ineg() : this.clone();
    }, re.prototype.isNeg = function() {
      return this.negative !== 0;
    }, re.prototype.neg = function() {
      return this.clone().ineg();
    }, re.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, re.prototype.iuor = function(ke) {
      for (; this.length < ke.length; )
        this.words[this.length++] = 0;
      for (var rt = 0; rt < ke.length; rt++)
        this.words[rt] = this.words[rt] | ke.words[rt];
      return this.strip();
    }, re.prototype.ior = function(ke) {
      return V((this.negative | ke.negative) === 0), this.iuor(ke);
    }, re.prototype.or = function(ke) {
      return this.length > ke.length ? this.clone().ior(ke) : ke.clone().ior(this);
    }, re.prototype.uor = function(ke) {
      return this.length > ke.length ? this.clone().iuor(ke) : ke.clone().iuor(this);
    }, re.prototype.iuand = function(ke) {
      var rt;
      this.length > ke.length ? rt = ke : rt = this;
      for (var ce = 0; ce < rt.length; ce++)
        this.words[ce] = this.words[ce] & ke.words[ce];
      return this.length = rt.length, this.strip();
    }, re.prototype.iand = function(ke) {
      return V((this.negative | ke.negative) === 0), this.iuand(ke);
    }, re.prototype.and = function(ke) {
      return this.length > ke.length ? this.clone().iand(ke) : ke.clone().iand(this);
    }, re.prototype.uand = function(ke) {
      return this.length > ke.length ? this.clone().iuand(ke) : ke.clone().iuand(this);
    }, re.prototype.iuxor = function(ke) {
      var rt, ce;
      this.length > ke.length ? (rt = this, ce = ke) : (rt = ke, ce = this);
      for (var Oe = 0; Oe < ce.length; Oe++)
        this.words[Oe] = rt.words[Oe] ^ ce.words[Oe];
      if (this !== rt)
        for (; Oe < rt.length; Oe++)
          this.words[Oe] = rt.words[Oe];
      return this.length = rt.length, this.strip();
    }, re.prototype.ixor = function(ke) {
      return V((this.negative | ke.negative) === 0), this.iuxor(ke);
    }, re.prototype.xor = function(ke) {
      return this.length > ke.length ? this.clone().ixor(ke) : ke.clone().ixor(this);
    }, re.prototype.uxor = function(ke) {
      return this.length > ke.length ? this.clone().iuxor(ke) : ke.clone().iuxor(this);
    }, re.prototype.inotn = function(ke) {
      V(typeof ke == "number" && ke >= 0);
      var rt = Math.ceil(ke / 26) | 0, ce = ke % 26;
      this._expand(rt), ce > 0 && rt--;
      for (var Oe = 0; Oe < rt; Oe++)
        this.words[Oe] = ~this.words[Oe] & 67108863;
      return ce > 0 && (this.words[Oe] = ~this.words[Oe] & 67108863 >> 26 - ce), this.strip();
    }, re.prototype.notn = function(ke) {
      return this.clone().inotn(ke);
    }, re.prototype.setn = function(ke, rt) {
      V(typeof ke == "number" && ke >= 0);
      var ce = ke / 26 | 0, Oe = ke % 26;
      return this._expand(ce + 1), rt ? this.words[ce] = this.words[ce] | 1 << Oe : this.words[ce] = this.words[ce] & ~(1 << Oe), this.strip();
    }, re.prototype.iadd = function(ke) {
      var rt;
      if (this.negative !== 0 && ke.negative === 0)
        return this.negative = 0, rt = this.isub(ke), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ke.negative !== 0)
        return ke.negative = 0, rt = this.isub(ke), ke.negative = 1, rt._normSign();
      var ce, Oe;
      this.length > ke.length ? (ce = this, Oe = ke) : (ce = ke, Oe = this);
      for (var ot = 0, ut = 0; ut < Oe.length; ut++)
        rt = (ce.words[ut] | 0) + (Oe.words[ut] | 0) + ot, this.words[ut] = rt & 67108863, ot = rt >>> 26;
      for (; ot !== 0 && ut < ce.length; ut++)
        rt = (ce.words[ut] | 0) + ot, this.words[ut] = rt & 67108863, ot = rt >>> 26;
      if (this.length = ce.length, ot !== 0)
        this.words[this.length] = ot, this.length++;
      else if (ce !== this)
        for (; ut < ce.length; ut++)
          this.words[ut] = ce.words[ut];
      return this;
    }, re.prototype.add = function(ke) {
      var rt;
      return ke.negative !== 0 && this.negative === 0 ? (ke.negative = 0, rt = this.sub(ke), ke.negative ^= 1, rt) : ke.negative === 0 && this.negative !== 0 ? (this.negative = 0, rt = ke.sub(this), this.negative = 1, rt) : this.length > ke.length ? this.clone().iadd(ke) : ke.clone().iadd(this);
    }, re.prototype.isub = function(ke) {
      if (ke.negative !== 0) {
        ke.negative = 0;
        var rt = this.iadd(ke);
        return ke.negative = 1, rt._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ke), this.negative = 1, this._normSign();
      var ce = this.cmp(ke);
      if (ce === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var Oe, ot;
      ce > 0 ? (Oe = this, ot = ke) : (Oe = ke, ot = this);
      for (var ut = 0, ht = 0; ht < ot.length; ht++)
        rt = (Oe.words[ht] | 0) - (ot.words[ht] | 0) + ut, ut = rt >> 26, this.words[ht] = rt & 67108863;
      for (; ut !== 0 && ht < Oe.length; ht++)
        rt = (Oe.words[ht] | 0) + ut, ut = rt >> 26, this.words[ht] = rt & 67108863;
      if (ut === 0 && ht < Oe.length && Oe !== this)
        for (; ht < Oe.length; ht++)
          this.words[ht] = Oe.words[ht];
      return this.length = Math.max(this.length, ht), Oe !== this && (this.negative = 1), this.strip();
    }, re.prototype.sub = function(ke) {
      return this.clone().isub(ke);
    };
    function gt(wt, ke, rt) {
      rt.negative = ke.negative ^ wt.negative;
      var ce = wt.length + ke.length | 0;
      rt.length = ce, ce = ce - 1 | 0;
      var Oe = wt.words[0] | 0, ot = ke.words[0] | 0, ut = Oe * ot, ht = ut & 67108863, dt = ut / 67108864 | 0;
      rt.words[0] = ht;
      for (var st = 1; st < ce; st++) {
        for (var yt = dt >>> 26, ct = dt & 67108863, At = Math.min(st, ke.length - 1), Kt = Math.max(0, st - wt.length + 1); Kt <= At; Kt++) {
          var Zt = st - Kt | 0;
          Oe = wt.words[Zt] | 0, ot = ke.words[Kt] | 0, ut = Oe * ot + ct, yt += ut / 67108864 | 0, ct = ut & 67108863;
        }
        rt.words[st] = ct | 0, dt = yt | 0;
      }
      return dt !== 0 ? rt.words[st] = dt | 0 : rt.length--, rt.strip();
    }
    var St = function(ke, rt, ce) {
      var Oe = ke.words, ot = rt.words, ut = ce.words, ht = 0, dt, st, yt, ct = Oe[0] | 0, At = ct & 8191, Kt = ct >>> 13, Zt = Oe[1] | 0, Ht = Zt & 8191, Pt = Zt >>> 13, kt = Oe[2] | 0, Vt = kt & 8191, tr = kt >>> 13, Nt = Oe[3] | 0, Ft = Nt & 8191, er = Nt >>> 13, fr = Oe[4] | 0, cr = fr & 8191, dr = fr >>> 13, br = Oe[5] | 0, wr = br & 8191, or = br >>> 13, Nr = Oe[6] | 0, Br = Nr & 8191, Tr = Nr >>> 13, Mr = Oe[7] | 0, _r = Mr & 8191, kr = Mr >>> 13, Fr = Oe[8] | 0, Ar = Fr & 8191, Cr = Fr >>> 13, Dr = Oe[9] | 0, Rt = Dr & 8191, vt = Dr >>> 13, $t = ot[0] | 0, Ut = $t & 8191, Yt = $t >>> 13, rr = ot[1] | 0, ir = rr & 8191, gr = rr >>> 13, Ir = ot[2] | 0, yr = Ir & 8191, Pr = Ir >>> 13, $r = ot[3] | 0, Er = $r & 8191, Or = $r >>> 13, Ur = ot[4] | 0, Gt = Ur & 8191, Lt = Ur >>> 13, zt = ot[5] | 0, Et = zt & 8191, lt = zt >>> 13, pt = ot[6] | 0, Ct = pt & 8191, Wt = pt >>> 13, Jt = ot[7] | 0, Qt = Jt & 8191, ur = Jt >>> 13, pr = ot[8] | 0, jt = pr & 8191, nr = pr >>> 13, ar = ot[9] | 0, lr = ar & 8191, Sr = ar >>> 13;
      ce.negative = ke.negative ^ rt.negative, ce.length = 19, dt = Math.imul(At, Ut), st = Math.imul(At, Yt), st = st + Math.imul(Kt, Ut) | 0, yt = Math.imul(Kt, Yt);
      var xr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (xr >>> 26) | 0, xr &= 67108863, dt = Math.imul(Ht, Ut), st = Math.imul(Ht, Yt), st = st + Math.imul(Pt, Ut) | 0, yt = Math.imul(Pt, Yt), dt = dt + Math.imul(At, ir) | 0, st = st + Math.imul(At, gr) | 0, st = st + Math.imul(Kt, ir) | 0, yt = yt + Math.imul(Kt, gr) | 0;
      var vr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (vr >>> 26) | 0, vr &= 67108863, dt = Math.imul(Vt, Ut), st = Math.imul(Vt, Yt), st = st + Math.imul(tr, Ut) | 0, yt = Math.imul(tr, Yt), dt = dt + Math.imul(Ht, ir) | 0, st = st + Math.imul(Ht, gr) | 0, st = st + Math.imul(Pt, ir) | 0, yt = yt + Math.imul(Pt, gr) | 0, dt = dt + Math.imul(At, yr) | 0, st = st + Math.imul(At, Pr) | 0, st = st + Math.imul(Kt, yr) | 0, yt = yt + Math.imul(Kt, Pr) | 0;
      var Rr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, dt = Math.imul(Ft, Ut), st = Math.imul(Ft, Yt), st = st + Math.imul(er, Ut) | 0, yt = Math.imul(er, Yt), dt = dt + Math.imul(Vt, ir) | 0, st = st + Math.imul(Vt, gr) | 0, st = st + Math.imul(tr, ir) | 0, yt = yt + Math.imul(tr, gr) | 0, dt = dt + Math.imul(Ht, yr) | 0, st = st + Math.imul(Ht, Pr) | 0, st = st + Math.imul(Pt, yr) | 0, yt = yt + Math.imul(Pt, Pr) | 0, dt = dt + Math.imul(At, Er) | 0, st = st + Math.imul(At, Or) | 0, st = st + Math.imul(Kt, Er) | 0, yt = yt + Math.imul(Kt, Or) | 0;
      var jr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, dt = Math.imul(cr, Ut), st = Math.imul(cr, Yt), st = st + Math.imul(dr, Ut) | 0, yt = Math.imul(dr, Yt), dt = dt + Math.imul(Ft, ir) | 0, st = st + Math.imul(Ft, gr) | 0, st = st + Math.imul(er, ir) | 0, yt = yt + Math.imul(er, gr) | 0, dt = dt + Math.imul(Vt, yr) | 0, st = st + Math.imul(Vt, Pr) | 0, st = st + Math.imul(tr, yr) | 0, yt = yt + Math.imul(tr, Pr) | 0, dt = dt + Math.imul(Ht, Er) | 0, st = st + Math.imul(Ht, Or) | 0, st = st + Math.imul(Pt, Er) | 0, yt = yt + Math.imul(Pt, Or) | 0, dt = dt + Math.imul(At, Gt) | 0, st = st + Math.imul(At, Lt) | 0, st = st + Math.imul(Kt, Gt) | 0, yt = yt + Math.imul(Kt, Lt) | 0;
      var Lr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, dt = Math.imul(wr, Ut), st = Math.imul(wr, Yt), st = st + Math.imul(or, Ut) | 0, yt = Math.imul(or, Yt), dt = dt + Math.imul(cr, ir) | 0, st = st + Math.imul(cr, gr) | 0, st = st + Math.imul(dr, ir) | 0, yt = yt + Math.imul(dr, gr) | 0, dt = dt + Math.imul(Ft, yr) | 0, st = st + Math.imul(Ft, Pr) | 0, st = st + Math.imul(er, yr) | 0, yt = yt + Math.imul(er, Pr) | 0, dt = dt + Math.imul(Vt, Er) | 0, st = st + Math.imul(Vt, Or) | 0, st = st + Math.imul(tr, Er) | 0, yt = yt + Math.imul(tr, Or) | 0, dt = dt + Math.imul(Ht, Gt) | 0, st = st + Math.imul(Ht, Lt) | 0, st = st + Math.imul(Pt, Gt) | 0, yt = yt + Math.imul(Pt, Lt) | 0, dt = dt + Math.imul(At, Et) | 0, st = st + Math.imul(At, lt) | 0, st = st + Math.imul(Kt, Et) | 0, yt = yt + Math.imul(Kt, lt) | 0;
      var Hr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, dt = Math.imul(Br, Ut), st = Math.imul(Br, Yt), st = st + Math.imul(Tr, Ut) | 0, yt = Math.imul(Tr, Yt), dt = dt + Math.imul(wr, ir) | 0, st = st + Math.imul(wr, gr) | 0, st = st + Math.imul(or, ir) | 0, yt = yt + Math.imul(or, gr) | 0, dt = dt + Math.imul(cr, yr) | 0, st = st + Math.imul(cr, Pr) | 0, st = st + Math.imul(dr, yr) | 0, yt = yt + Math.imul(dr, Pr) | 0, dt = dt + Math.imul(Ft, Er) | 0, st = st + Math.imul(Ft, Or) | 0, st = st + Math.imul(er, Er) | 0, yt = yt + Math.imul(er, Or) | 0, dt = dt + Math.imul(Vt, Gt) | 0, st = st + Math.imul(Vt, Lt) | 0, st = st + Math.imul(tr, Gt) | 0, yt = yt + Math.imul(tr, Lt) | 0, dt = dt + Math.imul(Ht, Et) | 0, st = st + Math.imul(Ht, lt) | 0, st = st + Math.imul(Pt, Et) | 0, yt = yt + Math.imul(Pt, lt) | 0, dt = dt + Math.imul(At, Ct) | 0, st = st + Math.imul(At, Wt) | 0, st = st + Math.imul(Kt, Ct) | 0, yt = yt + Math.imul(Kt, Wt) | 0;
      var Wr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, dt = Math.imul(_r, Ut), st = Math.imul(_r, Yt), st = st + Math.imul(kr, Ut) | 0, yt = Math.imul(kr, Yt), dt = dt + Math.imul(Br, ir) | 0, st = st + Math.imul(Br, gr) | 0, st = st + Math.imul(Tr, ir) | 0, yt = yt + Math.imul(Tr, gr) | 0, dt = dt + Math.imul(wr, yr) | 0, st = st + Math.imul(wr, Pr) | 0, st = st + Math.imul(or, yr) | 0, yt = yt + Math.imul(or, Pr) | 0, dt = dt + Math.imul(cr, Er) | 0, st = st + Math.imul(cr, Or) | 0, st = st + Math.imul(dr, Er) | 0, yt = yt + Math.imul(dr, Or) | 0, dt = dt + Math.imul(Ft, Gt) | 0, st = st + Math.imul(Ft, Lt) | 0, st = st + Math.imul(er, Gt) | 0, yt = yt + Math.imul(er, Lt) | 0, dt = dt + Math.imul(Vt, Et) | 0, st = st + Math.imul(Vt, lt) | 0, st = st + Math.imul(tr, Et) | 0, yt = yt + Math.imul(tr, lt) | 0, dt = dt + Math.imul(Ht, Ct) | 0, st = st + Math.imul(Ht, Wt) | 0, st = st + Math.imul(Pt, Ct) | 0, yt = yt + Math.imul(Pt, Wt) | 0, dt = dt + Math.imul(At, Qt) | 0, st = st + Math.imul(At, ur) | 0, st = st + Math.imul(Kt, Qt) | 0, yt = yt + Math.imul(Kt, ur) | 0;
      var Vr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, dt = Math.imul(Ar, Ut), st = Math.imul(Ar, Yt), st = st + Math.imul(Cr, Ut) | 0, yt = Math.imul(Cr, Yt), dt = dt + Math.imul(_r, ir) | 0, st = st + Math.imul(_r, gr) | 0, st = st + Math.imul(kr, ir) | 0, yt = yt + Math.imul(kr, gr) | 0, dt = dt + Math.imul(Br, yr) | 0, st = st + Math.imul(Br, Pr) | 0, st = st + Math.imul(Tr, yr) | 0, yt = yt + Math.imul(Tr, Pr) | 0, dt = dt + Math.imul(wr, Er) | 0, st = st + Math.imul(wr, Or) | 0, st = st + Math.imul(or, Er) | 0, yt = yt + Math.imul(or, Or) | 0, dt = dt + Math.imul(cr, Gt) | 0, st = st + Math.imul(cr, Lt) | 0, st = st + Math.imul(dr, Gt) | 0, yt = yt + Math.imul(dr, Lt) | 0, dt = dt + Math.imul(Ft, Et) | 0, st = st + Math.imul(Ft, lt) | 0, st = st + Math.imul(er, Et) | 0, yt = yt + Math.imul(er, lt) | 0, dt = dt + Math.imul(Vt, Ct) | 0, st = st + Math.imul(Vt, Wt) | 0, st = st + Math.imul(tr, Ct) | 0, yt = yt + Math.imul(tr, Wt) | 0, dt = dt + Math.imul(Ht, Qt) | 0, st = st + Math.imul(Ht, ur) | 0, st = st + Math.imul(Pt, Qt) | 0, yt = yt + Math.imul(Pt, ur) | 0, dt = dt + Math.imul(At, jt) | 0, st = st + Math.imul(At, nr) | 0, st = st + Math.imul(Kt, jt) | 0, yt = yt + Math.imul(Kt, nr) | 0;
      var Gr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, dt = Math.imul(Rt, Ut), st = Math.imul(Rt, Yt), st = st + Math.imul(vt, Ut) | 0, yt = Math.imul(vt, Yt), dt = dt + Math.imul(Ar, ir) | 0, st = st + Math.imul(Ar, gr) | 0, st = st + Math.imul(Cr, ir) | 0, yt = yt + Math.imul(Cr, gr) | 0, dt = dt + Math.imul(_r, yr) | 0, st = st + Math.imul(_r, Pr) | 0, st = st + Math.imul(kr, yr) | 0, yt = yt + Math.imul(kr, Pr) | 0, dt = dt + Math.imul(Br, Er) | 0, st = st + Math.imul(Br, Or) | 0, st = st + Math.imul(Tr, Er) | 0, yt = yt + Math.imul(Tr, Or) | 0, dt = dt + Math.imul(wr, Gt) | 0, st = st + Math.imul(wr, Lt) | 0, st = st + Math.imul(or, Gt) | 0, yt = yt + Math.imul(or, Lt) | 0, dt = dt + Math.imul(cr, Et) | 0, st = st + Math.imul(cr, lt) | 0, st = st + Math.imul(dr, Et) | 0, yt = yt + Math.imul(dr, lt) | 0, dt = dt + Math.imul(Ft, Ct) | 0, st = st + Math.imul(Ft, Wt) | 0, st = st + Math.imul(er, Ct) | 0, yt = yt + Math.imul(er, Wt) | 0, dt = dt + Math.imul(Vt, Qt) | 0, st = st + Math.imul(Vt, ur) | 0, st = st + Math.imul(tr, Qt) | 0, yt = yt + Math.imul(tr, ur) | 0, dt = dt + Math.imul(Ht, jt) | 0, st = st + Math.imul(Ht, nr) | 0, st = st + Math.imul(Pt, jt) | 0, yt = yt + Math.imul(Pt, nr) | 0, dt = dt + Math.imul(At, lr) | 0, st = st + Math.imul(At, Sr) | 0, st = st + Math.imul(Kt, lr) | 0, yt = yt + Math.imul(Kt, Sr) | 0;
      var qr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, dt = Math.imul(Rt, ir), st = Math.imul(Rt, gr), st = st + Math.imul(vt, ir) | 0, yt = Math.imul(vt, gr), dt = dt + Math.imul(Ar, yr) | 0, st = st + Math.imul(Ar, Pr) | 0, st = st + Math.imul(Cr, yr) | 0, yt = yt + Math.imul(Cr, Pr) | 0, dt = dt + Math.imul(_r, Er) | 0, st = st + Math.imul(_r, Or) | 0, st = st + Math.imul(kr, Er) | 0, yt = yt + Math.imul(kr, Or) | 0, dt = dt + Math.imul(Br, Gt) | 0, st = st + Math.imul(Br, Lt) | 0, st = st + Math.imul(Tr, Gt) | 0, yt = yt + Math.imul(Tr, Lt) | 0, dt = dt + Math.imul(wr, Et) | 0, st = st + Math.imul(wr, lt) | 0, st = st + Math.imul(or, Et) | 0, yt = yt + Math.imul(or, lt) | 0, dt = dt + Math.imul(cr, Ct) | 0, st = st + Math.imul(cr, Wt) | 0, st = st + Math.imul(dr, Ct) | 0, yt = yt + Math.imul(dr, Wt) | 0, dt = dt + Math.imul(Ft, Qt) | 0, st = st + Math.imul(Ft, ur) | 0, st = st + Math.imul(er, Qt) | 0, yt = yt + Math.imul(er, ur) | 0, dt = dt + Math.imul(Vt, jt) | 0, st = st + Math.imul(Vt, nr) | 0, st = st + Math.imul(tr, jt) | 0, yt = yt + Math.imul(tr, nr) | 0, dt = dt + Math.imul(Ht, lr) | 0, st = st + Math.imul(Ht, Sr) | 0, st = st + Math.imul(Pt, lr) | 0, yt = yt + Math.imul(Pt, Sr) | 0;
      var Xr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, dt = Math.imul(Rt, yr), st = Math.imul(Rt, Pr), st = st + Math.imul(vt, yr) | 0, yt = Math.imul(vt, Pr), dt = dt + Math.imul(Ar, Er) | 0, st = st + Math.imul(Ar, Or) | 0, st = st + Math.imul(Cr, Er) | 0, yt = yt + Math.imul(Cr, Or) | 0, dt = dt + Math.imul(_r, Gt) | 0, st = st + Math.imul(_r, Lt) | 0, st = st + Math.imul(kr, Gt) | 0, yt = yt + Math.imul(kr, Lt) | 0, dt = dt + Math.imul(Br, Et) | 0, st = st + Math.imul(Br, lt) | 0, st = st + Math.imul(Tr, Et) | 0, yt = yt + Math.imul(Tr, lt) | 0, dt = dt + Math.imul(wr, Ct) | 0, st = st + Math.imul(wr, Wt) | 0, st = st + Math.imul(or, Ct) | 0, yt = yt + Math.imul(or, Wt) | 0, dt = dt + Math.imul(cr, Qt) | 0, st = st + Math.imul(cr, ur) | 0, st = st + Math.imul(dr, Qt) | 0, yt = yt + Math.imul(dr, ur) | 0, dt = dt + Math.imul(Ft, jt) | 0, st = st + Math.imul(Ft, nr) | 0, st = st + Math.imul(er, jt) | 0, yt = yt + Math.imul(er, nr) | 0, dt = dt + Math.imul(Vt, lr) | 0, st = st + Math.imul(Vt, Sr) | 0, st = st + Math.imul(tr, lr) | 0, yt = yt + Math.imul(tr, Sr) | 0;
      var Yr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, dt = Math.imul(Rt, Er), st = Math.imul(Rt, Or), st = st + Math.imul(vt, Er) | 0, yt = Math.imul(vt, Or), dt = dt + Math.imul(Ar, Gt) | 0, st = st + Math.imul(Ar, Lt) | 0, st = st + Math.imul(Cr, Gt) | 0, yt = yt + Math.imul(Cr, Lt) | 0, dt = dt + Math.imul(_r, Et) | 0, st = st + Math.imul(_r, lt) | 0, st = st + Math.imul(kr, Et) | 0, yt = yt + Math.imul(kr, lt) | 0, dt = dt + Math.imul(Br, Ct) | 0, st = st + Math.imul(Br, Wt) | 0, st = st + Math.imul(Tr, Ct) | 0, yt = yt + Math.imul(Tr, Wt) | 0, dt = dt + Math.imul(wr, Qt) | 0, st = st + Math.imul(wr, ur) | 0, st = st + Math.imul(or, Qt) | 0, yt = yt + Math.imul(or, ur) | 0, dt = dt + Math.imul(cr, jt) | 0, st = st + Math.imul(cr, nr) | 0, st = st + Math.imul(dr, jt) | 0, yt = yt + Math.imul(dr, nr) | 0, dt = dt + Math.imul(Ft, lr) | 0, st = st + Math.imul(Ft, Sr) | 0, st = st + Math.imul(er, lr) | 0, yt = yt + Math.imul(er, Sr) | 0;
      var Jr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, dt = Math.imul(Rt, Gt), st = Math.imul(Rt, Lt), st = st + Math.imul(vt, Gt) | 0, yt = Math.imul(vt, Lt), dt = dt + Math.imul(Ar, Et) | 0, st = st + Math.imul(Ar, lt) | 0, st = st + Math.imul(Cr, Et) | 0, yt = yt + Math.imul(Cr, lt) | 0, dt = dt + Math.imul(_r, Ct) | 0, st = st + Math.imul(_r, Wt) | 0, st = st + Math.imul(kr, Ct) | 0, yt = yt + Math.imul(kr, Wt) | 0, dt = dt + Math.imul(Br, Qt) | 0, st = st + Math.imul(Br, ur) | 0, st = st + Math.imul(Tr, Qt) | 0, yt = yt + Math.imul(Tr, ur) | 0, dt = dt + Math.imul(wr, jt) | 0, st = st + Math.imul(wr, nr) | 0, st = st + Math.imul(or, jt) | 0, yt = yt + Math.imul(or, nr) | 0, dt = dt + Math.imul(cr, lr) | 0, st = st + Math.imul(cr, Sr) | 0, st = st + Math.imul(dr, lr) | 0, yt = yt + Math.imul(dr, Sr) | 0;
      var Qr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, dt = Math.imul(Rt, Et), st = Math.imul(Rt, lt), st = st + Math.imul(vt, Et) | 0, yt = Math.imul(vt, lt), dt = dt + Math.imul(Ar, Ct) | 0, st = st + Math.imul(Ar, Wt) | 0, st = st + Math.imul(Cr, Ct) | 0, yt = yt + Math.imul(Cr, Wt) | 0, dt = dt + Math.imul(_r, Qt) | 0, st = st + Math.imul(_r, ur) | 0, st = st + Math.imul(kr, Qt) | 0, yt = yt + Math.imul(kr, ur) | 0, dt = dt + Math.imul(Br, jt) | 0, st = st + Math.imul(Br, nr) | 0, st = st + Math.imul(Tr, jt) | 0, yt = yt + Math.imul(Tr, nr) | 0, dt = dt + Math.imul(wr, lr) | 0, st = st + Math.imul(wr, Sr) | 0, st = st + Math.imul(or, lr) | 0, yt = yt + Math.imul(or, Sr) | 0;
      var Zr = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, dt = Math.imul(Rt, Ct), st = Math.imul(Rt, Wt), st = st + Math.imul(vt, Ct) | 0, yt = Math.imul(vt, Wt), dt = dt + Math.imul(Ar, Qt) | 0, st = st + Math.imul(Ar, ur) | 0, st = st + Math.imul(Cr, Qt) | 0, yt = yt + Math.imul(Cr, ur) | 0, dt = dt + Math.imul(_r, jt) | 0, st = st + Math.imul(_r, nr) | 0, st = st + Math.imul(kr, jt) | 0, yt = yt + Math.imul(kr, nr) | 0, dt = dt + Math.imul(Br, lr) | 0, st = st + Math.imul(Br, Sr) | 0, st = st + Math.imul(Tr, lr) | 0, yt = yt + Math.imul(Tr, Sr) | 0;
      var en = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, dt = Math.imul(Rt, Qt), st = Math.imul(Rt, ur), st = st + Math.imul(vt, Qt) | 0, yt = Math.imul(vt, ur), dt = dt + Math.imul(Ar, jt) | 0, st = st + Math.imul(Ar, nr) | 0, st = st + Math.imul(Cr, jt) | 0, yt = yt + Math.imul(Cr, nr) | 0, dt = dt + Math.imul(_r, lr) | 0, st = st + Math.imul(_r, Sr) | 0, st = st + Math.imul(kr, lr) | 0, yt = yt + Math.imul(kr, Sr) | 0;
      var tn = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, dt = Math.imul(Rt, jt), st = Math.imul(Rt, nr), st = st + Math.imul(vt, jt) | 0, yt = Math.imul(vt, nr), dt = dt + Math.imul(Ar, lr) | 0, st = st + Math.imul(Ar, Sr) | 0, st = st + Math.imul(Cr, lr) | 0, yt = yt + Math.imul(Cr, Sr) | 0;
      var rn = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      ht = (yt + (st >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, dt = Math.imul(Rt, lr), st = Math.imul(Rt, Sr), st = st + Math.imul(vt, lr) | 0, yt = Math.imul(vt, Sr);
      var nn = (ht + dt | 0) + ((st & 8191) << 13) | 0;
      return ht = (yt + (st >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, ut[0] = xr, ut[1] = vr, ut[2] = Rr, ut[3] = jr, ut[4] = Lr, ut[5] = Hr, ut[6] = Wr, ut[7] = Vr, ut[8] = Gr, ut[9] = qr, ut[10] = Xr, ut[11] = Yr, ut[12] = Jr, ut[13] = Qr, ut[14] = Zr, ut[15] = en, ut[16] = tn, ut[17] = rn, ut[18] = nn, ht !== 0 && (ut[19] = ht, ce.length++), ce;
    };
    Math.imul || (St = gt);
    function xt(wt, ke, rt) {
      rt.negative = ke.negative ^ wt.negative, rt.length = wt.length + ke.length;
      for (var ce = 0, Oe = 0, ot = 0; ot < rt.length - 1; ot++) {
        var ut = Oe;
        Oe = 0;
        for (var ht = ce & 67108863, dt = Math.min(ot, ke.length - 1), st = Math.max(0, ot - wt.length + 1); st <= dt; st++) {
          var yt = ot - st, ct = wt.words[yt] | 0, At = ke.words[st] | 0, Kt = ct * At, Zt = Kt & 67108863;
          ut = ut + (Kt / 67108864 | 0) | 0, Zt = Zt + ht | 0, ht = Zt & 67108863, ut = ut + (Zt >>> 26) | 0, Oe += ut >>> 26, ut &= 67108863;
        }
        rt.words[ot] = ht, ce = ut, ut = Oe;
      }
      return ce !== 0 ? rt.words[ot] = ce : rt.length--, rt.strip();
    }
    function Mt(wt, ke, rt) {
      var ce = new bt();
      return ce.mulp(wt, ke, rt);
    }
    re.prototype.mulTo = function(ke, rt) {
      var ce, Oe = this.length + ke.length;
      return this.length === 10 && ke.length === 10 ? ce = St(this, ke, rt) : Oe < 63 ? ce = gt(this, ke, rt) : Oe < 1024 ? ce = xt(this, ke, rt) : ce = Mt(this, ke, rt), ce;
    };
    function bt(wt, ke) {
      this.x = wt, this.y = ke;
    }
    bt.prototype.makeRBT = function(ke) {
      for (var rt = new Array(ke), ce = re.prototype._countBits(ke) - 1, Oe = 0; Oe < ke; Oe++)
        rt[Oe] = this.revBin(Oe, ce, ke);
      return rt;
    }, bt.prototype.revBin = function(ke, rt, ce) {
      if (ke === 0 || ke === ce - 1) return ke;
      for (var Oe = 0, ot = 0; ot < rt; ot++)
        Oe |= (ke & 1) << rt - ot - 1, ke >>= 1;
      return Oe;
    }, bt.prototype.permute = function(ke, rt, ce, Oe, ot, ut) {
      for (var ht = 0; ht < ut; ht++)
        Oe[ht] = rt[ke[ht]], ot[ht] = ce[ke[ht]];
    }, bt.prototype.transform = function(ke, rt, ce, Oe, ot, ut) {
      this.permute(ut, ke, rt, ce, Oe, ot);
      for (var ht = 1; ht < ot; ht <<= 1)
        for (var dt = ht << 1, st = Math.cos(2 * Math.PI / dt), yt = Math.sin(2 * Math.PI / dt), ct = 0; ct < ot; ct += dt)
          for (var At = st, Kt = yt, Zt = 0; Zt < ht; Zt++) {
            var Ht = ce[ct + Zt], Pt = Oe[ct + Zt], kt = ce[ct + Zt + ht], Vt = Oe[ct + Zt + ht], tr = At * kt - Kt * Vt;
            Vt = At * Vt + Kt * kt, kt = tr, ce[ct + Zt] = Ht + kt, Oe[ct + Zt] = Pt + Vt, ce[ct + Zt + ht] = Ht - kt, Oe[ct + Zt + ht] = Pt - Vt, Zt !== dt && (tr = st * At - yt * Kt, Kt = st * Kt + yt * At, At = tr);
          }
    }, bt.prototype.guessLen13b = function(ke, rt) {
      var ce = Math.max(rt, ke) | 1, Oe = ce & 1, ot = 0;
      for (ce = ce / 2 | 0; ce; ce = ce >>> 1)
        ot++;
      return 1 << ot + 1 + Oe;
    }, bt.prototype.conjugate = function(ke, rt, ce) {
      if (!(ce <= 1))
        for (var Oe = 0; Oe < ce / 2; Oe++) {
          var ot = ke[Oe];
          ke[Oe] = ke[ce - Oe - 1], ke[ce - Oe - 1] = ot, ot = rt[Oe], rt[Oe] = -rt[ce - Oe - 1], rt[ce - Oe - 1] = -ot;
        }
    }, bt.prototype.normalize13b = function(ke, rt) {
      for (var ce = 0, Oe = 0; Oe < rt / 2; Oe++) {
        var ot = Math.round(ke[2 * Oe + 1] / rt) * 8192 + Math.round(ke[2 * Oe] / rt) + ce;
        ke[Oe] = ot & 67108863, ot < 67108864 ? ce = 0 : ce = ot / 67108864 | 0;
      }
      return ke;
    }, bt.prototype.convert13b = function(ke, rt, ce, Oe) {
      for (var ot = 0, ut = 0; ut < rt; ut++)
        ot = ot + (ke[ut] | 0), ce[2 * ut] = ot & 8191, ot = ot >>> 13, ce[2 * ut + 1] = ot & 8191, ot = ot >>> 13;
      for (ut = 2 * rt; ut < Oe; ++ut)
        ce[ut] = 0;
      V(ot === 0), V((ot & -8192) === 0);
    }, bt.prototype.stub = function(ke) {
      for (var rt = new Array(ke), ce = 0; ce < ke; ce++)
        rt[ce] = 0;
      return rt;
    }, bt.prototype.mulp = function(ke, rt, ce) {
      var Oe = 2 * this.guessLen13b(ke.length, rt.length), ot = this.makeRBT(Oe), ut = this.stub(Oe), ht = new Array(Oe), dt = new Array(Oe), st = new Array(Oe), yt = new Array(Oe), ct = new Array(Oe), At = new Array(Oe), Kt = ce.words;
      Kt.length = Oe, this.convert13b(ke.words, ke.length, ht, Oe), this.convert13b(rt.words, rt.length, yt, Oe), this.transform(ht, ut, dt, st, Oe, ot), this.transform(yt, ut, ct, At, Oe, ot);
      for (var Zt = 0; Zt < Oe; Zt++) {
        var Ht = dt[Zt] * ct[Zt] - st[Zt] * At[Zt];
        st[Zt] = dt[Zt] * At[Zt] + st[Zt] * ct[Zt], dt[Zt] = Ht;
      }
      return this.conjugate(dt, st, Oe), this.transform(dt, st, Kt, ut, Oe, ot), this.conjugate(Kt, ut, Oe), this.normalize13b(Kt, Oe), ce.negative = ke.negative ^ rt.negative, ce.length = ke.length + rt.length, ce.strip();
    }, re.prototype.mul = function(ke) {
      var rt = new re(null);
      return rt.words = new Array(this.length + ke.length), this.mulTo(ke, rt);
    }, re.prototype.mulf = function(ke) {
      var rt = new re(null);
      return rt.words = new Array(this.length + ke.length), Mt(this, ke, rt);
    }, re.prototype.imul = function(ke) {
      return this.clone().mulTo(ke, this);
    }, re.prototype.imuln = function(ke) {
      V(typeof ke == "number"), V(ke < 67108864);
      for (var rt = 0, ce = 0; ce < this.length; ce++) {
        var Oe = (this.words[ce] | 0) * ke, ot = (Oe & 67108863) + (rt & 67108863);
        rt >>= 26, rt += Oe / 67108864 | 0, rt += ot >>> 26, this.words[ce] = ot & 67108863;
      }
      return rt !== 0 && (this.words[ce] = rt, this.length++), this;
    }, re.prototype.muln = function(ke) {
      return this.clone().imuln(ke);
    }, re.prototype.sqr = function() {
      return this.mul(this);
    }, re.prototype.isqr = function() {
      return this.imul(this.clone());
    }, re.prototype.pow = function(ke) {
      var rt = it(ke);
      if (rt.length === 0) return new re(1);
      for (var ce = this, Oe = 0; Oe < rt.length && rt[Oe] === 0; Oe++, ce = ce.sqr())
        ;
      if (++Oe < rt.length)
        for (var ot = ce.sqr(); Oe < rt.length; Oe++, ot = ot.sqr())
          rt[Oe] !== 0 && (ce = ce.mul(ot));
      return ce;
    }, re.prototype.iushln = function(ke) {
      V(typeof ke == "number" && ke >= 0);
      var rt = ke % 26, ce = (ke - rt) / 26, Oe = 67108863 >>> 26 - rt << 26 - rt, ot;
      if (rt !== 0) {
        var ut = 0;
        for (ot = 0; ot < this.length; ot++) {
          var ht = this.words[ot] & Oe, dt = (this.words[ot] | 0) - ht << rt;
          this.words[ot] = dt | ut, ut = ht >>> 26 - rt;
        }
        ut && (this.words[ot] = ut, this.length++);
      }
      if (ce !== 0) {
        for (ot = this.length - 1; ot >= 0; ot--)
          this.words[ot + ce] = this.words[ot];
        for (ot = 0; ot < ce; ot++)
          this.words[ot] = 0;
        this.length += ce;
      }
      return this.strip();
    }, re.prototype.ishln = function(ke) {
      return V(this.negative === 0), this.iushln(ke);
    }, re.prototype.iushrn = function(ke, rt, ce) {
      V(typeof ke == "number" && ke >= 0);
      var Oe;
      rt ? Oe = (rt - rt % 26) / 26 : Oe = 0;
      var ot = ke % 26, ut = Math.min((ke - ot) / 26, this.length), ht = 67108863 ^ 67108863 >>> ot << ot, dt = ce;
      if (Oe -= ut, Oe = Math.max(0, Oe), dt) {
        for (var st = 0; st < ut; st++)
          dt.words[st] = this.words[st];
        dt.length = ut;
      }
      if (ut !== 0) if (this.length > ut)
        for (this.length -= ut, st = 0; st < this.length; st++)
          this.words[st] = this.words[st + ut];
      else
        this.words[0] = 0, this.length = 1;
      var yt = 0;
      for (st = this.length - 1; st >= 0 && (yt !== 0 || st >= Oe); st--) {
        var ct = this.words[st] | 0;
        this.words[st] = yt << 26 - ot | ct >>> ot, yt = ct & ht;
      }
      return dt && yt !== 0 && (dt.words[dt.length++] = yt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, re.prototype.ishrn = function(ke, rt, ce) {
      return V(this.negative === 0), this.iushrn(ke, rt, ce);
    }, re.prototype.shln = function(ke) {
      return this.clone().ishln(ke);
    }, re.prototype.ushln = function(ke) {
      return this.clone().iushln(ke);
    }, re.prototype.shrn = function(ke) {
      return this.clone().ishrn(ke);
    }, re.prototype.ushrn = function(ke) {
      return this.clone().iushrn(ke);
    }, re.prototype.testn = function(ke) {
      V(typeof ke == "number" && ke >= 0);
      var rt = ke % 26, ce = (ke - rt) / 26, Oe = 1 << rt;
      if (this.length <= ce) return !1;
      var ot = this.words[ce];
      return !!(ot & Oe);
    }, re.prototype.imaskn = function(ke) {
      V(typeof ke == "number" && ke >= 0);
      var rt = ke % 26, ce = (ke - rt) / 26;
      if (V(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ce)
        return this;
      if (rt !== 0 && ce++, this.length = Math.min(ce, this.length), rt !== 0) {
        var Oe = 67108863 ^ 67108863 >>> rt << rt;
        this.words[this.length - 1] &= Oe;
      }
      return this.strip();
    }, re.prototype.maskn = function(ke) {
      return this.clone().imaskn(ke);
    }, re.prototype.iaddn = function(ke) {
      return V(typeof ke == "number"), V(ke < 67108864), ke < 0 ? this.isubn(-ke) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < ke ? (this.words[0] = ke - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ke), this.negative = 1, this) : this._iaddn(ke);
    }, re.prototype._iaddn = function(ke) {
      this.words[0] += ke;
      for (var rt = 0; rt < this.length && this.words[rt] >= 67108864; rt++)
        this.words[rt] -= 67108864, rt === this.length - 1 ? this.words[rt + 1] = 1 : this.words[rt + 1]++;
      return this.length = Math.max(this.length, rt + 1), this;
    }, re.prototype.isubn = function(ke) {
      if (V(typeof ke == "number"), V(ke < 67108864), ke < 0) return this.iaddn(-ke);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ke), this.negative = 1, this;
      if (this.words[0] -= ke, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var rt = 0; rt < this.length && this.words[rt] < 0; rt++)
          this.words[rt] += 67108864, this.words[rt + 1] -= 1;
      return this.strip();
    }, re.prototype.addn = function(ke) {
      return this.clone().iaddn(ke);
    }, re.prototype.subn = function(ke) {
      return this.clone().isubn(ke);
    }, re.prototype.iabs = function() {
      return this.negative = 0, this;
    }, re.prototype.abs = function() {
      return this.clone().iabs();
    }, re.prototype._ishlnsubmul = function(ke, rt, ce) {
      var Oe = ke.length + ce, ot;
      this._expand(Oe);
      var ut, ht = 0;
      for (ot = 0; ot < ke.length; ot++) {
        ut = (this.words[ot + ce] | 0) + ht;
        var dt = (ke.words[ot] | 0) * rt;
        ut -= dt & 67108863, ht = (ut >> 26) - (dt / 67108864 | 0), this.words[ot + ce] = ut & 67108863;
      }
      for (; ot < this.length - ce; ot++)
        ut = (this.words[ot + ce] | 0) + ht, ht = ut >> 26, this.words[ot + ce] = ut & 67108863;
      if (ht === 0) return this.strip();
      for (V(ht === -1), ht = 0, ot = 0; ot < this.length; ot++)
        ut = -(this.words[ot] | 0) + ht, ht = ut >> 26, this.words[ot] = ut & 67108863;
      return this.negative = 1, this.strip();
    }, re.prototype._wordDiv = function(ke, rt) {
      var ce = this.length - ke.length, Oe = this.clone(), ot = ke, ut = ot.words[ot.length - 1] | 0, ht = this._countBits(ut);
      ce = 26 - ht, ce !== 0 && (ot = ot.ushln(ce), Oe.iushln(ce), ut = ot.words[ot.length - 1] | 0);
      var dt = Oe.length - ot.length, st;
      if (rt !== "mod") {
        st = new re(null), st.length = dt + 1, st.words = new Array(st.length);
        for (var yt = 0; yt < st.length; yt++)
          st.words[yt] = 0;
      }
      var ct = Oe.clone()._ishlnsubmul(ot, 1, dt);
      ct.negative === 0 && (Oe = ct, st && (st.words[dt] = 1));
      for (var At = dt - 1; At >= 0; At--) {
        var Kt = (Oe.words[ot.length + At] | 0) * 67108864 + (Oe.words[ot.length + At - 1] | 0);
        for (Kt = Math.min(Kt / ut | 0, 67108863), Oe._ishlnsubmul(ot, Kt, At); Oe.negative !== 0; )
          Kt--, Oe.negative = 0, Oe._ishlnsubmul(ot, 1, At), Oe.isZero() || (Oe.negative ^= 1);
        st && (st.words[At] = Kt);
      }
      return st && st.strip(), Oe.strip(), rt !== "div" && ce !== 0 && Oe.iushrn(ce), {
        div: st || null,
        mod: Oe
      };
    }, re.prototype.divmod = function(ke, rt, ce) {
      if (V(!ke.isZero()), this.isZero())
        return {
          div: new re(0),
          mod: new re(0)
        };
      var Oe, ot, ut;
      return this.negative !== 0 && ke.negative === 0 ? (ut = this.neg().divmod(ke, rt), rt !== "mod" && (Oe = ut.div.neg()), rt !== "div" && (ot = ut.mod.neg(), ce && ot.negative !== 0 && ot.iadd(ke)), {
        div: Oe,
        mod: ot
      }) : this.negative === 0 && ke.negative !== 0 ? (ut = this.divmod(ke.neg(), rt), rt !== "mod" && (Oe = ut.div.neg()), {
        div: Oe,
        mod: ut.mod
      }) : this.negative & ke.negative ? (ut = this.neg().divmod(ke.neg(), rt), rt !== "div" && (ot = ut.mod.neg(), ce && ot.negative !== 0 && ot.isub(ke)), {
        div: ut.div,
        mod: ot
      }) : ke.length > this.length || this.cmp(ke) < 0 ? {
        div: new re(0),
        mod: this
      } : ke.length === 1 ? rt === "div" ? {
        div: this.divn(ke.words[0]),
        mod: null
      } : rt === "mod" ? {
        div: null,
        mod: new re(this.modn(ke.words[0]))
      } : {
        div: this.divn(ke.words[0]),
        mod: new re(this.modn(ke.words[0]))
      } : this._wordDiv(ke, rt);
    }, re.prototype.div = function(ke) {
      return this.divmod(ke, "div", !1).div;
    }, re.prototype.mod = function(ke) {
      return this.divmod(ke, "mod", !1).mod;
    }, re.prototype.umod = function(ke) {
      return this.divmod(ke, "mod", !0).mod;
    }, re.prototype.divRound = function(ke) {
      var rt = this.divmod(ke);
      if (rt.mod.isZero()) return rt.div;
      var ce = rt.div.negative !== 0 ? rt.mod.isub(ke) : rt.mod, Oe = ke.ushrn(1), ot = ke.andln(1), ut = ce.cmp(Oe);
      return ut < 0 || ot === 1 && ut === 0 ? rt.div : rt.div.negative !== 0 ? rt.div.isubn(1) : rt.div.iaddn(1);
    }, re.prototype.modn = function(ke) {
      V(ke <= 67108863);
      for (var rt = (1 << 26) % ke, ce = 0, Oe = this.length - 1; Oe >= 0; Oe--)
        ce = (rt * ce + (this.words[Oe] | 0)) % ke;
      return ce;
    }, re.prototype.idivn = function(ke) {
      V(ke <= 67108863);
      for (var rt = 0, ce = this.length - 1; ce >= 0; ce--) {
        var Oe = (this.words[ce] | 0) + rt * 67108864;
        this.words[ce] = Oe / ke | 0, rt = Oe % ke;
      }
      return this.strip();
    }, re.prototype.divn = function(ke) {
      return this.clone().idivn(ke);
    }, re.prototype.egcd = function(ke) {
      V(ke.negative === 0), V(!ke.isZero());
      var rt = this, ce = ke.clone();
      rt.negative !== 0 ? rt = rt.umod(ke) : rt = rt.clone();
      for (var Oe = new re(1), ot = new re(0), ut = new re(0), ht = new re(1), dt = 0; rt.isEven() && ce.isEven(); )
        rt.iushrn(1), ce.iushrn(1), ++dt;
      for (var st = ce.clone(), yt = rt.clone(); !rt.isZero(); ) {
        for (var ct = 0, At = 1; !(rt.words[0] & At) && ct < 26; ++ct, At <<= 1) ;
        if (ct > 0)
          for (rt.iushrn(ct); ct-- > 0; )
            (Oe.isOdd() || ot.isOdd()) && (Oe.iadd(st), ot.isub(yt)), Oe.iushrn(1), ot.iushrn(1);
        for (var Kt = 0, Zt = 1; !(ce.words[0] & Zt) && Kt < 26; ++Kt, Zt <<= 1) ;
        if (Kt > 0)
          for (ce.iushrn(Kt); Kt-- > 0; )
            (ut.isOdd() || ht.isOdd()) && (ut.iadd(st), ht.isub(yt)), ut.iushrn(1), ht.iushrn(1);
        rt.cmp(ce) >= 0 ? (rt.isub(ce), Oe.isub(ut), ot.isub(ht)) : (ce.isub(rt), ut.isub(Oe), ht.isub(ot));
      }
      return {
        a: ut,
        b: ht,
        gcd: ce.iushln(dt)
      };
    }, re.prototype._invmp = function(ke) {
      V(ke.negative === 0), V(!ke.isZero());
      var rt = this, ce = ke.clone();
      rt.negative !== 0 ? rt = rt.umod(ke) : rt = rt.clone();
      for (var Oe = new re(1), ot = new re(0), ut = ce.clone(); rt.cmpn(1) > 0 && ce.cmpn(1) > 0; ) {
        for (var ht = 0, dt = 1; !(rt.words[0] & dt) && ht < 26; ++ht, dt <<= 1) ;
        if (ht > 0)
          for (rt.iushrn(ht); ht-- > 0; )
            Oe.isOdd() && Oe.iadd(ut), Oe.iushrn(1);
        for (var st = 0, yt = 1; !(ce.words[0] & yt) && st < 26; ++st, yt <<= 1) ;
        if (st > 0)
          for (ce.iushrn(st); st-- > 0; )
            ot.isOdd() && ot.iadd(ut), ot.iushrn(1);
        rt.cmp(ce) >= 0 ? (rt.isub(ce), Oe.isub(ot)) : (ce.isub(rt), ot.isub(Oe));
      }
      var ct;
      return rt.cmpn(1) === 0 ? ct = Oe : ct = ot, ct.cmpn(0) < 0 && ct.iadd(ke), ct;
    }, re.prototype.gcd = function(ke) {
      if (this.isZero()) return ke.abs();
      if (ke.isZero()) return this.abs();
      var rt = this.clone(), ce = ke.clone();
      rt.negative = 0, ce.negative = 0;
      for (var Oe = 0; rt.isEven() && ce.isEven(); Oe++)
        rt.iushrn(1), ce.iushrn(1);
      do {
        for (; rt.isEven(); )
          rt.iushrn(1);
        for (; ce.isEven(); )
          ce.iushrn(1);
        var ot = rt.cmp(ce);
        if (ot < 0) {
          var ut = rt;
          rt = ce, ce = ut;
        } else if (ot === 0 || ce.cmpn(1) === 0)
          break;
        rt.isub(ce);
      } while (!0);
      return ce.iushln(Oe);
    }, re.prototype.invm = function(ke) {
      return this.egcd(ke).a.umod(ke);
    }, re.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, re.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, re.prototype.andln = function(ke) {
      return this.words[0] & ke;
    }, re.prototype.bincn = function(ke) {
      V(typeof ke == "number");
      var rt = ke % 26, ce = (ke - rt) / 26, Oe = 1 << rt;
      if (this.length <= ce)
        return this._expand(ce + 1), this.words[ce] |= Oe, this;
      for (var ot = Oe, ut = ce; ot !== 0 && ut < this.length; ut++) {
        var ht = this.words[ut] | 0;
        ht += ot, ot = ht >>> 26, ht &= 67108863, this.words[ut] = ht;
      }
      return ot !== 0 && (this.words[ut] = ot, this.length++), this;
    }, re.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, re.prototype.cmpn = function(ke) {
      var rt = ke < 0;
      if (this.negative !== 0 && !rt) return -1;
      if (this.negative === 0 && rt) return 1;
      this.strip();
      var ce;
      if (this.length > 1)
        ce = 1;
      else {
        rt && (ke = -ke), V(ke <= 67108863, "Number is too big");
        var Oe = this.words[0] | 0;
        ce = Oe === ke ? 0 : Oe < ke ? -1 : 1;
      }
      return this.negative !== 0 ? -ce | 0 : ce;
    }, re.prototype.cmp = function(ke) {
      if (this.negative !== 0 && ke.negative === 0) return -1;
      if (this.negative === 0 && ke.negative !== 0) return 1;
      var rt = this.ucmp(ke);
      return this.negative !== 0 ? -rt | 0 : rt;
    }, re.prototype.ucmp = function(ke) {
      if (this.length > ke.length) return 1;
      if (this.length < ke.length) return -1;
      for (var rt = 0, ce = this.length - 1; ce >= 0; ce--) {
        var Oe = this.words[ce] | 0, ot = ke.words[ce] | 0;
        if (Oe !== ot) {
          Oe < ot ? rt = -1 : Oe > ot && (rt = 1);
          break;
        }
      }
      return rt;
    }, re.prototype.gtn = function(ke) {
      return this.cmpn(ke) === 1;
    }, re.prototype.gt = function(ke) {
      return this.cmp(ke) === 1;
    }, re.prototype.gten = function(ke) {
      return this.cmpn(ke) >= 0;
    }, re.prototype.gte = function(ke) {
      return this.cmp(ke) >= 0;
    }, re.prototype.ltn = function(ke) {
      return this.cmpn(ke) === -1;
    }, re.prototype.lt = function(ke) {
      return this.cmp(ke) === -1;
    }, re.prototype.lten = function(ke) {
      return this.cmpn(ke) <= 0;
    }, re.prototype.lte = function(ke) {
      return this.cmp(ke) <= 0;
    }, re.prototype.eqn = function(ke) {
      return this.cmpn(ke) === 0;
    }, re.prototype.eq = function(ke) {
      return this.cmp(ke) === 0;
    }, re.red = function(ke) {
      return new mt(ke);
    }, re.prototype.toRed = function(ke) {
      return V(!this.red, "Already a number in reduction context"), V(this.negative === 0, "red works only with positives"), ke.convertTo(this)._forceRed(ke);
    }, re.prototype.fromRed = function() {
      return V(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, re.prototype._forceRed = function(ke) {
      return this.red = ke, this;
    }, re.prototype.forceRed = function(ke) {
      return V(!this.red, "Already a number in reduction context"), this._forceRed(ke);
    }, re.prototype.redAdd = function(ke) {
      return V(this.red, "redAdd works only with red numbers"), this.red.add(this, ke);
    }, re.prototype.redIAdd = function(ke) {
      return V(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ke);
    }, re.prototype.redSub = function(ke) {
      return V(this.red, "redSub works only with red numbers"), this.red.sub(this, ke);
    }, re.prototype.redISub = function(ke) {
      return V(this.red, "redISub works only with red numbers"), this.red.isub(this, ke);
    }, re.prototype.redShl = function(ke) {
      return V(this.red, "redShl works only with red numbers"), this.red.shl(this, ke);
    }, re.prototype.redMul = function(ke) {
      return V(this.red, "redMul works only with red numbers"), this.red._verify2(this, ke), this.red.mul(this, ke);
    }, re.prototype.redIMul = function(ke) {
      return V(this.red, "redMul works only with red numbers"), this.red._verify2(this, ke), this.red.imul(this, ke);
    }, re.prototype.redSqr = function() {
      return V(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, re.prototype.redISqr = function() {
      return V(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, re.prototype.redSqrt = function() {
      return V(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, re.prototype.redInvm = function() {
      return V(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, re.prototype.redNeg = function() {
      return V(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, re.prototype.redPow = function(ke) {
      return V(this.red && !ke.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ke);
    };
    var Tt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function It(wt, ke) {
      this.name = wt, this.p = new re(ke, 16), this.n = this.p.bitLength(), this.k = new re(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    It.prototype._tmp = function() {
      var ke = new re(null);
      return ke.words = new Array(Math.ceil(this.n / 13)), ke;
    }, It.prototype.ireduce = function(ke) {
      var rt = ke, ce;
      do
        this.split(rt, this.tmp), rt = this.imulK(rt), rt = rt.iadd(this.tmp), ce = rt.bitLength();
      while (ce > this.n);
      var Oe = ce < this.n ? -1 : rt.ucmp(this.p);
      return Oe === 0 ? (rt.words[0] = 0, rt.length = 1) : Oe > 0 ? rt.isub(this.p) : rt.strip !== void 0 ? rt.strip() : rt._strip(), rt;
    }, It.prototype.split = function(ke, rt) {
      ke.iushrn(this.n, 0, rt);
    }, It.prototype.imulK = function(ke) {
      return ke.imul(this.k);
    };
    function qt() {
      It.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    J(qt, It), qt.prototype.split = function(ke, rt) {
      for (var ce = 4194303, Oe = Math.min(ke.length, 9), ot = 0; ot < Oe; ot++)
        rt.words[ot] = ke.words[ot];
      if (rt.length = Oe, ke.length <= 9) {
        ke.words[0] = 0, ke.length = 1;
        return;
      }
      var ut = ke.words[9];
      for (rt.words[rt.length++] = ut & ce, ot = 10; ot < ke.length; ot++) {
        var ht = ke.words[ot] | 0;
        ke.words[ot - 10] = (ht & ce) << 4 | ut >>> 22, ut = ht;
      }
      ut >>>= 22, ke.words[ot - 10] = ut, ut === 0 && ke.length > 10 ? ke.length -= 10 : ke.length -= 9;
    }, qt.prototype.imulK = function(ke) {
      ke.words[ke.length] = 0, ke.words[ke.length + 1] = 0, ke.length += 2;
      for (var rt = 0, ce = 0; ce < ke.length; ce++) {
        var Oe = ke.words[ce] | 0;
        rt += Oe * 977, ke.words[ce] = rt & 67108863, rt = Oe * 64 + (rt / 67108864 | 0);
      }
      return ke.words[ke.length - 1] === 0 && (ke.length--, ke.words[ke.length - 1] === 0 && ke.length--), ke;
    };
    function Dt() {
      It.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    J(Dt, It);
    function Xt() {
      It.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    J(Xt, It);
    function Bt() {
      It.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    J(Bt, It), Bt.prototype.imulK = function(ke) {
      for (var rt = 0, ce = 0; ce < ke.length; ce++) {
        var Oe = (ke.words[ce] | 0) * 19 + rt, ot = Oe & 67108863;
        Oe >>>= 26, ke.words[ce] = ot, rt = Oe;
      }
      return rt !== 0 && (ke.words[ke.length++] = rt), ke;
    }, re._prime = function(ke) {
      if (Tt[ke]) return Tt[ke];
      var rt;
      if (ke === "k256")
        rt = new qt();
      else if (ke === "p224")
        rt = new Dt();
      else if (ke === "p192")
        rt = new Xt();
      else if (ke === "p25519")
        rt = new Bt();
      else
        throw new Error("Unknown prime " + ke);
      return Tt[ke] = rt, rt;
    };
    function mt(wt) {
      if (typeof wt == "string") {
        var ke = re._prime(wt);
        this.m = ke.p, this.prime = ke;
      } else
        V(wt.gtn(1), "modulus must be greater than 1"), this.m = wt, this.prime = null;
    }
    mt.prototype._verify1 = function(ke) {
      V(ke.negative === 0, "red works only with positives"), V(ke.red, "red works only with red numbers");
    }, mt.prototype._verify2 = function(ke, rt) {
      V((ke.negative | rt.negative) === 0, "red works only with positives"), V(
        ke.red && ke.red === rt.red,
        "red works only with red numbers"
      );
    }, mt.prototype.imod = function(ke) {
      return this.prime ? this.prime.ireduce(ke)._forceRed(this) : ke.umod(this.m)._forceRed(this);
    }, mt.prototype.neg = function(ke) {
      return ke.isZero() ? ke.clone() : this.m.sub(ke)._forceRed(this);
    }, mt.prototype.add = function(ke, rt) {
      this._verify2(ke, rt);
      var ce = ke.add(rt);
      return ce.cmp(this.m) >= 0 && ce.isub(this.m), ce._forceRed(this);
    }, mt.prototype.iadd = function(ke, rt) {
      this._verify2(ke, rt);
      var ce = ke.iadd(rt);
      return ce.cmp(this.m) >= 0 && ce.isub(this.m), ce;
    }, mt.prototype.sub = function(ke, rt) {
      this._verify2(ke, rt);
      var ce = ke.sub(rt);
      return ce.cmpn(0) < 0 && ce.iadd(this.m), ce._forceRed(this);
    }, mt.prototype.isub = function(ke, rt) {
      this._verify2(ke, rt);
      var ce = ke.isub(rt);
      return ce.cmpn(0) < 0 && ce.iadd(this.m), ce;
    }, mt.prototype.shl = function(ke, rt) {
      return this._verify1(ke), this.imod(ke.ushln(rt));
    }, mt.prototype.imul = function(ke, rt) {
      return this._verify2(ke, rt), this.imod(ke.imul(rt));
    }, mt.prototype.mul = function(ke, rt) {
      return this._verify2(ke, rt), this.imod(ke.mul(rt));
    }, mt.prototype.isqr = function(ke) {
      return this.imul(ke, ke.clone());
    }, mt.prototype.sqr = function(ke) {
      return this.mul(ke, ke);
    }, mt.prototype.sqrt = function(ke) {
      if (ke.isZero()) return ke.clone();
      var rt = this.m.andln(3);
      if (V(rt % 2 === 1), rt === 3) {
        var ce = this.m.add(new re(1)).iushrn(2);
        return this.pow(ke, ce);
      }
      for (var Oe = this.m.subn(1), ot = 0; !Oe.isZero() && Oe.andln(1) === 0; )
        ot++, Oe.iushrn(1);
      V(!Oe.isZero());
      var ut = new re(1).toRed(this), ht = ut.redNeg(), dt = this.m.subn(1).iushrn(1), st = this.m.bitLength();
      for (st = new re(2 * st * st).toRed(this); this.pow(st, dt).cmp(ht) !== 0; )
        st.redIAdd(ht);
      for (var yt = this.pow(st, Oe), ct = this.pow(ke, Oe.addn(1).iushrn(1)), At = this.pow(ke, Oe), Kt = ot; At.cmp(ut) !== 0; ) {
        for (var Zt = At, Ht = 0; Zt.cmp(ut) !== 0; Ht++)
          Zt = Zt.redSqr();
        V(Ht < Kt);
        var Pt = this.pow(yt, new re(1).iushln(Kt - Ht - 1));
        ct = ct.redMul(Pt), yt = Pt.redSqr(), At = At.redMul(yt), Kt = Ht;
      }
      return ct;
    }, mt.prototype.invm = function(ke) {
      var rt = ke._invmp(this.m);
      return rt.negative !== 0 ? (rt.negative = 0, this.imod(rt).redNeg()) : this.imod(rt);
    }, mt.prototype.pow = function(ke, rt) {
      if (rt.isZero()) return new re(1).toRed(this);
      if (rt.cmpn(1) === 0) return ke.clone();
      var ce = 4, Oe = new Array(1 << ce);
      Oe[0] = new re(1).toRed(this), Oe[1] = ke;
      for (var ot = 2; ot < Oe.length; ot++)
        Oe[ot] = this.mul(Oe[ot - 1], ke);
      var ut = Oe[0], ht = 0, dt = 0, st = rt.bitLength() % 26;
      for (st === 0 && (st = 26), ot = rt.length - 1; ot >= 0; ot--) {
        for (var yt = rt.words[ot], ct = st - 1; ct >= 0; ct--) {
          var At = yt >> ct & 1;
          if (ut !== Oe[0] && (ut = this.sqr(ut)), At === 0 && ht === 0) {
            dt = 0;
            continue;
          }
          ht <<= 1, ht |= At, dt++, !(dt !== ce && (ot !== 0 || ct !== 0)) && (ut = this.mul(ut, Oe[ht]), dt = 0, ht = 0);
        }
        st = 26;
      }
      return ut;
    }, mt.prototype.convertTo = function(ke) {
      var rt = ke.umod(this.m);
      return rt === ke ? rt.clone() : rt;
    }, mt.prototype.convertFrom = function(ke) {
      var rt = ke.clone();
      return rt.red = null, rt;
    }, re.mont = function(ke) {
      return new Ot(ke);
    };
    function Ot(wt) {
      mt.call(this, wt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new re(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    J(Ot, mt), Ot.prototype.convertTo = function(ke) {
      return this.imod(ke.ushln(this.shift));
    }, Ot.prototype.convertFrom = function(ke) {
      var rt = this.imod(ke.mul(this.rinv));
      return rt.red = null, rt;
    }, Ot.prototype.imul = function(ke, rt) {
      if (ke.isZero() || rt.isZero())
        return ke.words[0] = 0, ke.length = 1, ke;
      var ce = ke.imul(rt), Oe = ce.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = ce.isub(Oe).iushrn(this.shift), ut = ot;
      return ot.cmp(this.m) >= 0 ? ut = ot.isub(this.m) : ot.cmpn(0) < 0 && (ut = ot.iadd(this.m)), ut._forceRed(this);
    }, Ot.prototype.mul = function(ke, rt) {
      if (ke.isZero() || rt.isZero()) return new re(0)._forceRed(this);
      var ce = ke.mul(rt), Oe = ce.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ot = ce.isub(Oe).iushrn(this.shift), ut = ot;
      return ot.cmp(this.m) >= 0 ? ut = ot.isub(this.m) : ot.cmpn(0) < 0 && (ut = ot.iadd(this.m)), ut._forceRed(this);
    }, Ot.prototype.invm = function(ke) {
      var rt = this.imod(ke._invmp(this.m).mul(this.r2));
      return rt._forceRed(this);
    };
  })(A, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var A;
  brorand.exports = function(J) {
    return A || (A = new B(null)), A.generate(J);
  };
  function B(V) {
    this.rand = V;
  }
  if (brorand.exports.Rand = B, B.prototype.generate = function(J) {
    return this._rand(J);
  }, B.prototype._rand = function(J) {
    if (this.rand.getBytes)
      return this.rand.getBytes(J);
    for (var re = new Uint8Array(J), ne = 0; ne < re.length; ne++)
      re[ne] = this.rand.getByte();
    return re;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? B.prototype._rand = function(J) {
      var re = new Uint8Array(J);
      return self.crypto.getRandomValues(re), re;
    } : self.msCrypto && self.msCrypto.getRandomValues ? B.prototype._rand = function(J) {
      var re = new Uint8Array(J);
      return self.msCrypto.getRandomValues(re), re;
    } : typeof window == "object" && (B.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var L = requireCryptoBrowserify();
      if (typeof L.randomBytes != "function")
        throw new Error("Not supported");
      B.prototype._rand = function(J) {
        return L.randomBytes(J);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var A = bnExports$1, B = requireBrorand();
  function L(V) {
    this.rand = V || new B.Rand();
  }
  return mr = L, L.create = function(J) {
    return new L(J);
  }, L.prototype._randbelow = function(J) {
    var re = J.bitLength(), ne = Math.ceil(re / 8);
    do
      var ie = new A(this.rand.generate(ne));
    while (ie.cmp(J) >= 0);
    return ie;
  }, L.prototype._randrange = function(J, re) {
    var ne = re.sub(J);
    return J.add(this._randbelow(ne));
  }, L.prototype.test = function(J, re, ne) {
    var ie = J.bitLength(), pe = A.mont(J), nt = new A(1).toRed(pe);
    re || (re = Math.max(1, ie / 48 | 0));
    for (var oe = J.subn(1), Ce = 0; !oe.testn(Ce); Ce++)
      ;
    for (var at = J.shrn(Ce), it = oe.toRed(pe), gt = !0; re > 0; re--) {
      var St = this._randrange(new A(2), oe);
      ne && ne(St);
      var xt = St.toRed(pe).redPow(at);
      if (!(xt.cmp(nt) === 0 || xt.cmp(it) === 0)) {
        for (var Mt = 1; Mt < Ce; Mt++) {
          if (xt = xt.redSqr(), xt.cmp(nt) === 0)
            return !1;
          if (xt.cmp(it) === 0)
            break;
        }
        if (Mt === Ce)
          return !1;
      }
    }
    return gt;
  }, L.prototype.getDivisor = function(J, re) {
    var ne = J.bitLength(), ie = A.mont(J), pe = new A(1).toRed(ie);
    re || (re = Math.max(1, ne / 48 | 0));
    for (var nt = J.subn(1), oe = 0; !nt.testn(oe); oe++)
      ;
    for (var Ce = J.shrn(oe), at = nt.toRed(ie); re > 0; re--) {
      var it = this._randrange(new A(2), nt), gt = J.gcd(it);
      if (gt.cmpn(1) !== 0)
        return gt;
      var St = it.toRed(ie).redPow(Ce);
      if (!(St.cmp(pe) === 0 || St.cmp(at) === 0)) {
        for (var xt = 1; xt < oe; xt++) {
          if (St = St.redSqr(), St.cmp(pe) === 0)
            return St.fromRed().subn(1).gcd(J);
          if (St.cmp(at) === 0)
            break;
        }
        if (xt === oe)
          return St = St.redSqr(), St.fromRed().subn(1).gcd(J);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var A = browserExports;
  generatePrime = xt, xt.simpleSieve = gt, xt.fermatTest = St;
  var B = bnExports$1, L = new B(24), V = requireMr(), J = new V(), re = new B(1), ne = new B(2), ie = new B(5);
  new B(16), new B(8);
  var pe = new B(10), nt = new B(3);
  new B(7);
  var oe = new B(11), Ce = new B(4);
  new B(12);
  var at = null;
  function it() {
    if (at !== null)
      return at;
    var Mt = 1048576, bt = [];
    bt[0] = 2;
    for (var Tt = 1, It = 3; It < Mt; It += 2) {
      for (var qt = Math.ceil(Math.sqrt(It)), Dt = 0; Dt < Tt && bt[Dt] <= qt && It % bt[Dt] !== 0; Dt++)
        ;
      Tt !== Dt && bt[Dt] <= qt || (bt[Tt++] = It);
    }
    return at = bt, bt;
  }
  function gt(Mt) {
    for (var bt = it(), Tt = 0; Tt < bt.length; Tt++)
      if (Mt.modn(bt[Tt]) === 0)
        return Mt.cmpn(bt[Tt]) === 0;
    return !0;
  }
  function St(Mt) {
    var bt = B.mont(Mt);
    return ne.toRed(bt).redPow(Mt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function xt(Mt, bt) {
    if (Mt < 16)
      return bt === 2 || bt === 5 ? new B([140, 123]) : new B([140, 39]);
    bt = new B(bt);
    for (var Tt, It; ; ) {
      for (Tt = new B(A(Math.ceil(Mt / 8))); Tt.bitLength() > Mt; )
        Tt.ishrn(1);
      if (Tt.isEven() && Tt.iadd(re), Tt.testn(1) || Tt.iadd(ne), bt.cmp(ne)) {
        if (!bt.cmp(ie))
          for (; Tt.mod(pe).cmp(nt); )
            Tt.iadd(Ce);
      } else for (; Tt.mod(L).cmp(oe); )
        Tt.iadd(Ce);
      if (It = Tt.shrn(1), gt(It) && gt(Tt) && St(It) && St(Tt) && J.test(It) && J.test(Tt))
        return Tt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var A = bnExports$1, B = requireMr(), L = new B(), V = new A(24), J = new A(11), re = new A(10), ne = new A(3), ie = new A(7), pe = requireGeneratePrime(), nt = browserExports;
  dh = gt;
  function oe(xt, Mt) {
    return Mt = Mt || "utf8", Buffer$D.isBuffer(xt) || (xt = new Buffer$D(xt, Mt)), this._pub = new A(xt), this;
  }
  function Ce(xt, Mt) {
    return Mt = Mt || "utf8", Buffer$D.isBuffer(xt) || (xt = new Buffer$D(xt, Mt)), this._priv = new A(xt), this;
  }
  var at = {};
  function it(xt, Mt) {
    var bt = Mt.toString("hex"), Tt = [bt, xt.toString(16)].join("_");
    if (Tt in at)
      return at[Tt];
    var It = 0;
    if (xt.isEven() || !pe.simpleSieve || !pe.fermatTest(xt) || !L.test(xt))
      return It += 1, bt === "02" || bt === "05" ? It += 8 : It += 4, at[Tt] = It, It;
    L.test(xt.shrn(1)) || (It += 2);
    var qt;
    switch (bt) {
      case "02":
        xt.mod(V).cmp(J) && (It += 8);
        break;
      case "05":
        qt = xt.mod(re), qt.cmp(ne) && qt.cmp(ie) && (It += 8);
        break;
      default:
        It += 4;
    }
    return at[Tt] = It, It;
  }
  function gt(xt, Mt, bt) {
    this.setGenerator(Mt), this.__prime = new A(xt), this._prime = A.mont(this.__prime), this._primeLen = xt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, bt ? (this.setPublicKey = oe, this.setPrivateKey = Ce) : this._primeCode = 8;
  }
  Object.defineProperty(gt.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = it(this.__prime, this.__gen)), this._primeCode;
    }
  }), gt.prototype.generateKeys = function() {
    return this._priv || (this._priv = new A(nt(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, gt.prototype.computeSecret = function(xt) {
    xt = new A(xt), xt = xt.toRed(this._prime);
    var Mt = xt.redPow(this._priv).fromRed(), bt = new Buffer$D(Mt.toArray()), Tt = this.getPrime();
    if (bt.length < Tt.length) {
      var It = new Buffer$D(Tt.length - bt.length);
      It.fill(0), bt = Buffer$D.concat([It, bt]);
    }
    return bt;
  }, gt.prototype.getPublicKey = function(Mt) {
    return St(this._pub, Mt);
  }, gt.prototype.getPrivateKey = function(Mt) {
    return St(this._priv, Mt);
  }, gt.prototype.getPrime = function(xt) {
    return St(this.__prime, xt);
  }, gt.prototype.getGenerator = function(xt) {
    return St(this._gen, xt);
  }, gt.prototype.setGenerator = function(xt, Mt) {
    return Mt = Mt || "utf8", Buffer$D.isBuffer(xt) || (xt = new Buffer$D(xt, Mt)), this.__gen = xt, this._gen = new A(xt), this;
  };
  function St(xt, Mt) {
    var bt = new Buffer$D(xt.toArray());
    return Mt ? bt.toString(Mt) : bt;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var A = requireGeneratePrime(), B = require$$1$1, L = requireDh();
  function V(ne) {
    var ie = new Buffer$D(B[ne].prime, "hex"), pe = new Buffer$D(B[ne].gen, "hex");
    return new L(ie, pe);
  }
  var J = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function re(ne, ie, pe, nt) {
    return Buffer$D.isBuffer(ie) || J[ie] === void 0 ? re(ne, "binary", ie, pe) : (ie = ie || "binary", nt = nt || "binary", pe = pe || new Buffer$D([2]), Buffer$D.isBuffer(pe) || (pe = new Buffer$D(pe, nt)), typeof ne == "number" ? new L(A(ne, pe), pe, !0) : (Buffer$D.isBuffer(ne) || (ne = new Buffer$D(ne, ie)), new L(ne, pe, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = V, browser$4.createDiffieHellman = browser$4.DiffieHellman = re, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1;
function nextTick(A, B, L, V) {
  if (typeof A != "function")
    throw new TypeError('"callback" argument must be a function');
  var J = arguments.length, re, ne;
  switch (J) {
    case 0:
    case 1:
      return process$1.nextTick(A);
    case 2:
      return process$1.nextTick(function() {
        A.call(null, B);
      });
    case 3:
      return process$1.nextTick(function() {
        A.call(null, B, L);
      });
    case 4:
      return process$1.nextTick(function() {
        A.call(null, B, L, V);
      });
    default:
      for (re = new Array(J - 1), ne = 0; ne < re.length; )
        re[ne++] = arguments[ne];
      return process$1.nextTick(function() {
        A.apply(null, re);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(A) {
  return toString.call(A) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, safeBuffer$1 = { exports: {} };
(function(A, B) {
  var L = dist$1, V = L.Buffer;
  function J(ne, ie) {
    for (var pe in ne)
      ie[pe] = ne[pe];
  }
  V.from && V.alloc && V.allocUnsafe && V.allocUnsafeSlow ? A.exports = L : (J(L, B), B.Buffer = re);
  function re(ne, ie, pe) {
    return V(ne, ie, pe);
  }
  J(V, re), re.from = function(ne, ie, pe) {
    if (typeof ne == "number")
      throw new TypeError("Argument must not be a number");
    return V(ne, ie, pe);
  }, re.alloc = function(ne, ie, pe) {
    if (typeof ne != "number")
      throw new TypeError("Argument must be a number");
    var nt = V(ne);
    return ie !== void 0 ? typeof pe == "string" ? nt.fill(ie, pe) : nt.fill(ie) : nt.fill(0), nt;
  }, re.allocUnsafe = function(ne) {
    if (typeof ne != "number")
      throw new TypeError("Argument must be a number");
    return V(ne);
  }, re.allocUnsafeSlow = function(ne) {
    if (typeof ne != "number")
      throw new TypeError("Argument must be a number");
    return L.SlowBuffer(ne);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, util$2 = {};
function isArray(A) {
  return Array.isArray ? Array.isArray(A) : objectToString(A) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(A) {
  return typeof A == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(A) {
  return A === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(A) {
  return A == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber(A) {
  return typeof A == "number";
}
util$2.isNumber = isNumber;
function isString(A) {
  return typeof A == "string";
}
util$2.isString = isString;
function isSymbol(A) {
  return typeof A == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(A) {
  return A === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(A) {
  return objectToString(A) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject(A) {
  return typeof A == "object" && A !== null;
}
util$2.isObject = isObject;
function isDate(A) {
  return objectToString(A) === "[object Date]";
}
util$2.isDate = isDate;
function isError(A) {
  return objectToString(A) === "[object Error]" || A instanceof Error;
}
util$2.isError = isError;
function isFunction(A) {
  return typeof A == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(A) {
  return A === null || typeof A == "boolean" || typeof A == "number" || typeof A == "string" || typeof A == "symbol" || // ES6 symbol
  typeof A > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = dist$1.Buffer.isBuffer;
function objectToString(A) {
  return Object.prototype.toString.call(A);
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(A) {
    function B(re, ne) {
      if (!(re instanceof ne))
        throw new TypeError("Cannot call a class as a function");
    }
    var L = safeBufferExports.Buffer, V = util$3;
    function J(re, ne, ie) {
      re.copy(ne, ie);
    }
    A.exports = function() {
      function re() {
        B(this, re), this.head = null, this.tail = null, this.length = 0;
      }
      return re.prototype.push = function(ie) {
        var pe = { data: ie, next: null };
        this.length > 0 ? this.tail.next = pe : this.head = pe, this.tail = pe, ++this.length;
      }, re.prototype.unshift = function(ie) {
        var pe = { data: ie, next: this.head };
        this.length === 0 && (this.tail = pe), this.head = pe, ++this.length;
      }, re.prototype.shift = function() {
        if (this.length !== 0) {
          var ie = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ie;
        }
      }, re.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, re.prototype.join = function(ie) {
        if (this.length === 0) return "";
        for (var pe = this.head, nt = "" + pe.data; pe = pe.next; )
          nt += ie + pe.data;
        return nt;
      }, re.prototype.concat = function(ie) {
        if (this.length === 0) return L.alloc(0);
        for (var pe = L.allocUnsafe(ie >>> 0), nt = this.head, oe = 0; nt; )
          J(nt.data, pe, oe), oe += nt.data.length, nt = nt.next;
        return pe;
      }, re;
    }(), V && V.inspect && V.inspect.custom && (A.exports.prototype[V.inspect.custom] = function() {
      var re = V.inspect({ length: this.length });
      return this.constructor.name + " " + re;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(A, B) {
  var L = this, V = this._readableState && this._readableState.destroyed, J = this._writableState && this._writableState.destroyed;
  return V || J ? (B ? B(A) : A && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, A)) : pna.nextTick(emitErrorNT, this, A)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(A || null, function(re) {
    !B && re ? L._writableState ? L._writableState.errorEmitted || (L._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, L, re)) : pna.nextTick(emitErrorNT, L, re) : B && B(re);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(A, B) {
  A.emit("error", B);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var A = processNextickArgsExports;
  _stream_writable = St;
  function B(ut) {
    var ht = this;
    this.next = null, this.entry = null, this.finish = function() {
      ot(ht, ut);
    };
  }
  var L = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : A.nextTick, V;
  St.WritableState = it;
  var J = Object.create(util$2);
  J.inherits = inherits_browserExports;
  var re = {
    deprecate: browser$a
  }, ne = streamBrowser, ie = safeBufferExports.Buffer, pe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function nt(ut) {
    return ie.from(ut);
  }
  function oe(ut) {
    return ie.isBuffer(ut) || ut instanceof pe;
  }
  var Ce = destroy_1;
  J.inherits(St, ne);
  function at() {
  }
  function it(ut, ht) {
    V = V || require_stream_duplex(), ut = ut || {};
    var dt = ht instanceof V;
    this.objectMode = !!ut.objectMode, dt && (this.objectMode = this.objectMode || !!ut.writableObjectMode);
    var st = ut.highWaterMark, yt = ut.writableHighWaterMark, ct = this.objectMode ? 16 : 16 * 1024;
    st || st === 0 ? this.highWaterMark = st : dt && (yt || yt === 0) ? this.highWaterMark = yt : this.highWaterMark = ct, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var At = ut.decodeStrings === !1;
    this.decodeStrings = !At, this.defaultEncoding = ut.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Kt) {
      Xt(ht, Kt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  it.prototype.getBuffer = function() {
    for (var ht = this.bufferedRequest, dt = []; ht; )
      dt.push(ht), ht = ht.next;
    return dt;
  }, function() {
    try {
      Object.defineProperty(it.prototype, "buffer", {
        get: re.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var gt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (gt = Function.prototype[Symbol.hasInstance], Object.defineProperty(St, Symbol.hasInstance, {
    value: function(ut) {
      return gt.call(this, ut) ? !0 : this !== St ? !1 : ut && ut._writableState instanceof it;
    }
  })) : gt = function(ut) {
    return ut instanceof this;
  };
  function St(ut) {
    if (V = V || require_stream_duplex(), !gt.call(St, this) && !(this instanceof V))
      return new St(ut);
    this._writableState = new it(ut, this), this.writable = !0, ut && (typeof ut.write == "function" && (this._write = ut.write), typeof ut.writev == "function" && (this._writev = ut.writev), typeof ut.destroy == "function" && (this._destroy = ut.destroy), typeof ut.final == "function" && (this._final = ut.final)), ne.call(this);
  }
  St.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function xt(ut, ht) {
    var dt = new Error("write after end");
    ut.emit("error", dt), A.nextTick(ht, dt);
  }
  function Mt(ut, ht, dt, st) {
    var yt = !0, ct = !1;
    return dt === null ? ct = new TypeError("May not write null values to stream") : typeof dt != "string" && dt !== void 0 && !ht.objectMode && (ct = new TypeError("Invalid non-string/buffer chunk")), ct && (ut.emit("error", ct), A.nextTick(st, ct), yt = !1), yt;
  }
  St.prototype.write = function(ut, ht, dt) {
    var st = this._writableState, yt = !1, ct = !st.objectMode && oe(ut);
    return ct && !ie.isBuffer(ut) && (ut = nt(ut)), typeof ht == "function" && (dt = ht, ht = null), ct ? ht = "buffer" : ht || (ht = st.defaultEncoding), typeof dt != "function" && (dt = at), st.ended ? xt(this, dt) : (ct || Mt(this, st, ut, dt)) && (st.pendingcb++, yt = Tt(this, st, ct, ut, ht, dt)), yt;
  }, St.prototype.cork = function() {
    var ut = this._writableState;
    ut.corked++;
  }, St.prototype.uncork = function() {
    var ut = this._writableState;
    ut.corked && (ut.corked--, !ut.writing && !ut.corked && !ut.bufferProcessing && ut.bufferedRequest && Ot(this, ut));
  }, St.prototype.setDefaultEncoding = function(ht) {
    if (typeof ht == "string" && (ht = ht.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ht + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ht);
    return this._writableState.defaultEncoding = ht, this;
  };
  function bt(ut, ht, dt) {
    return !ut.objectMode && ut.decodeStrings !== !1 && typeof ht == "string" && (ht = ie.from(ht, dt)), ht;
  }
  Object.defineProperty(St.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Tt(ut, ht, dt, st, yt, ct) {
    if (!dt) {
      var At = bt(ht, st, yt);
      st !== At && (dt = !0, yt = "buffer", st = At);
    }
    var Kt = ht.objectMode ? 1 : st.length;
    ht.length += Kt;
    var Zt = ht.length < ht.highWaterMark;
    if (Zt || (ht.needDrain = !0), ht.writing || ht.corked) {
      var Ht = ht.lastBufferedRequest;
      ht.lastBufferedRequest = {
        chunk: st,
        encoding: yt,
        isBuf: dt,
        callback: ct,
        next: null
      }, Ht ? Ht.next = ht.lastBufferedRequest : ht.bufferedRequest = ht.lastBufferedRequest, ht.bufferedRequestCount += 1;
    } else
      It(ut, ht, !1, Kt, st, yt, ct);
    return Zt;
  }
  function It(ut, ht, dt, st, yt, ct, At) {
    ht.writelen = st, ht.writecb = At, ht.writing = !0, ht.sync = !0, dt ? ut._writev(yt, ht.onwrite) : ut._write(yt, ct, ht.onwrite), ht.sync = !1;
  }
  function qt(ut, ht, dt, st, yt) {
    --ht.pendingcb, dt ? (A.nextTick(yt, st), A.nextTick(ce, ut, ht), ut._writableState.errorEmitted = !0, ut.emit("error", st)) : (yt(st), ut._writableState.errorEmitted = !0, ut.emit("error", st), ce(ut, ht));
  }
  function Dt(ut) {
    ut.writing = !1, ut.writecb = null, ut.length -= ut.writelen, ut.writelen = 0;
  }
  function Xt(ut, ht) {
    var dt = ut._writableState, st = dt.sync, yt = dt.writecb;
    if (Dt(dt), ht) qt(ut, dt, st, ht, yt);
    else {
      var ct = wt(dt);
      !ct && !dt.corked && !dt.bufferProcessing && dt.bufferedRequest && Ot(ut, dt), st ? L(Bt, ut, dt, ct, yt) : Bt(ut, dt, ct, yt);
    }
  }
  function Bt(ut, ht, dt, st) {
    dt || mt(ut, ht), ht.pendingcb--, st(), ce(ut, ht);
  }
  function mt(ut, ht) {
    ht.length === 0 && ht.needDrain && (ht.needDrain = !1, ut.emit("drain"));
  }
  function Ot(ut, ht) {
    ht.bufferProcessing = !0;
    var dt = ht.bufferedRequest;
    if (ut._writev && dt && dt.next) {
      var st = ht.bufferedRequestCount, yt = new Array(st), ct = ht.corkedRequestsFree;
      ct.entry = dt;
      for (var At = 0, Kt = !0; dt; )
        yt[At] = dt, dt.isBuf || (Kt = !1), dt = dt.next, At += 1;
      yt.allBuffers = Kt, It(ut, ht, !0, ht.length, yt, "", ct.finish), ht.pendingcb++, ht.lastBufferedRequest = null, ct.next ? (ht.corkedRequestsFree = ct.next, ct.next = null) : ht.corkedRequestsFree = new B(ht), ht.bufferedRequestCount = 0;
    } else {
      for (; dt; ) {
        var Zt = dt.chunk, Ht = dt.encoding, Pt = dt.callback, kt = ht.objectMode ? 1 : Zt.length;
        if (It(ut, ht, !1, kt, Zt, Ht, Pt), dt = dt.next, ht.bufferedRequestCount--, ht.writing)
          break;
      }
      dt === null && (ht.lastBufferedRequest = null);
    }
    ht.bufferedRequest = dt, ht.bufferProcessing = !1;
  }
  St.prototype._write = function(ut, ht, dt) {
    dt(new Error("_write() is not implemented"));
  }, St.prototype._writev = null, St.prototype.end = function(ut, ht, dt) {
    var st = this._writableState;
    typeof ut == "function" ? (dt = ut, ut = null, ht = null) : typeof ht == "function" && (dt = ht, ht = null), ut != null && this.write(ut, ht), st.corked && (st.corked = 1, this.uncork()), st.ending || Oe(this, st, dt);
  };
  function wt(ut) {
    return ut.ending && ut.length === 0 && ut.bufferedRequest === null && !ut.finished && !ut.writing;
  }
  function ke(ut, ht) {
    ut._final(function(dt) {
      ht.pendingcb--, dt && ut.emit("error", dt), ht.prefinished = !0, ut.emit("prefinish"), ce(ut, ht);
    });
  }
  function rt(ut, ht) {
    !ht.prefinished && !ht.finalCalled && (typeof ut._final == "function" ? (ht.pendingcb++, ht.finalCalled = !0, A.nextTick(ke, ut, ht)) : (ht.prefinished = !0, ut.emit("prefinish")));
  }
  function ce(ut, ht) {
    var dt = wt(ht);
    return dt && (rt(ut, ht), ht.pendingcb === 0 && (ht.finished = !0, ut.emit("finish"))), dt;
  }
  function Oe(ut, ht, dt) {
    ht.ending = !0, ce(ut, ht), dt && (ht.finished ? A.nextTick(dt) : ut.once("finish", dt)), ht.ended = !0, ut.writable = !1;
  }
  function ot(ut, ht, dt) {
    var st = ut.entry;
    for (ut.entry = null; st; ) {
      var yt = st.callback;
      ht.pendingcb--, yt(dt), st = st.next;
    }
    ht.corkedRequestsFree.next = ut;
  }
  return Object.defineProperty(St.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ut) {
      this._writableState && (this._writableState.destroyed = ut);
    }
  }), St.prototype.destroy = Ce.destroy, St.prototype._undestroy = Ce.undestroy, St.prototype._destroy = function(ut, ht) {
    this.end(), ht(ut);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var A = processNextickArgsExports, B = Object.keys || function(Ce) {
    var at = [];
    for (var it in Ce)
      at.push(it);
    return at;
  };
  _stream_duplex = pe;
  var L = Object.create(util$2);
  L.inherits = inherits_browserExports;
  var V = require_stream_readable(), J = require_stream_writable();
  L.inherits(pe, V);
  for (var re = B(J.prototype), ne = 0; ne < re.length; ne++) {
    var ie = re[ne];
    pe.prototype[ie] || (pe.prototype[ie] = J.prototype[ie]);
  }
  function pe(Ce) {
    if (!(this instanceof pe)) return new pe(Ce);
    V.call(this, Ce), J.call(this, Ce), Ce && Ce.readable === !1 && (this.readable = !1), Ce && Ce.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Ce && Ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", nt);
  }
  Object.defineProperty(pe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function nt() {
    this.allowHalfOpen || this._writableState.ended || A.nextTick(oe, this);
  }
  function oe(Ce) {
    Ce.end();
  }
  return Object.defineProperty(pe.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ce) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ce, this._writableState.destroyed = Ce);
    }
  }), pe.prototype._destroy = function(Ce, at) {
    this.push(null), this.end(), A.nextTick(at, Ce);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var A = processNextickArgsExports;
  _stream_readable = bt;
  var B = isarray, L;
  bt.ReadableState = Mt, eventsExports.EventEmitter;
  var V = function(Pt, kt) {
    return Pt.listeners(kt).length;
  }, J = streamBrowser, re = safeBufferExports.Buffer, ne = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ie(Pt) {
    return re.from(Pt);
  }
  function pe(Pt) {
    return re.isBuffer(Pt) || Pt instanceof ne;
  }
  var nt = Object.create(util$2);
  nt.inherits = inherits_browserExports;
  var oe = util$3, Ce = void 0;
  oe && oe.debuglog ? Ce = oe.debuglog("stream") : Ce = function() {
  };
  var at = requireBufferList(), it = destroy_1, gt;
  nt.inherits(bt, J);
  var St = ["error", "close", "destroy", "pause", "resume"];
  function xt(Pt, kt, Vt) {
    if (typeof Pt.prependListener == "function") return Pt.prependListener(kt, Vt);
    !Pt._events || !Pt._events[kt] ? Pt.on(kt, Vt) : B(Pt._events[kt]) ? Pt._events[kt].unshift(Vt) : Pt._events[kt] = [Vt, Pt._events[kt]];
  }
  function Mt(Pt, kt) {
    L = L || require_stream_duplex(), Pt = Pt || {};
    var Vt = kt instanceof L;
    this.objectMode = !!Pt.objectMode, Vt && (this.objectMode = this.objectMode || !!Pt.readableObjectMode);
    var tr = Pt.highWaterMark, Nt = Pt.readableHighWaterMark, Ft = this.objectMode ? 16 : 16 * 1024;
    tr || tr === 0 ? this.highWaterMark = tr : Vt && (Nt || Nt === 0) ? this.highWaterMark = Nt : this.highWaterMark = Ft, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new at(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Pt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Pt.encoding && (gt || (gt = string_decoder.StringDecoder), this.decoder = new gt(Pt.encoding), this.encoding = Pt.encoding);
  }
  function bt(Pt) {
    if (L = L || require_stream_duplex(), !(this instanceof bt)) return new bt(Pt);
    this._readableState = new Mt(Pt, this), this.readable = !0, Pt && (typeof Pt.read == "function" && (this._read = Pt.read), typeof Pt.destroy == "function" && (this._destroy = Pt.destroy)), J.call(this);
  }
  Object.defineProperty(bt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Pt) {
      this._readableState && (this._readableState.destroyed = Pt);
    }
  }), bt.prototype.destroy = it.destroy, bt.prototype._undestroy = it.undestroy, bt.prototype._destroy = function(Pt, kt) {
    this.push(null), kt(Pt);
  }, bt.prototype.push = function(Pt, kt) {
    var Vt = this._readableState, tr;
    return Vt.objectMode ? tr = !0 : typeof Pt == "string" && (kt = kt || Vt.defaultEncoding, kt !== Vt.encoding && (Pt = re.from(Pt, kt), kt = ""), tr = !0), Tt(this, Pt, kt, !1, tr);
  }, bt.prototype.unshift = function(Pt) {
    return Tt(this, Pt, null, !0, !1);
  };
  function Tt(Pt, kt, Vt, tr, Nt) {
    var Ft = Pt._readableState;
    if (kt === null)
      Ft.reading = !1, Ot(Pt, Ft);
    else {
      var er;
      Nt || (er = qt(Ft, kt)), er ? Pt.emit("error", er) : Ft.objectMode || kt && kt.length > 0 ? (typeof kt != "string" && !Ft.objectMode && Object.getPrototypeOf(kt) !== re.prototype && (kt = ie(kt)), tr ? Ft.endEmitted ? Pt.emit("error", new Error("stream.unshift() after end event")) : It(Pt, Ft, kt, !0) : Ft.ended ? Pt.emit("error", new Error("stream.push() after EOF")) : (Ft.reading = !1, Ft.decoder && !Vt ? (kt = Ft.decoder.write(kt), Ft.objectMode || kt.length !== 0 ? It(Pt, Ft, kt, !1) : rt(Pt, Ft)) : It(Pt, Ft, kt, !1))) : tr || (Ft.reading = !1);
    }
    return Dt(Ft);
  }
  function It(Pt, kt, Vt, tr) {
    kt.flowing && kt.length === 0 && !kt.sync ? (Pt.emit("data", Vt), Pt.read(0)) : (kt.length += kt.objectMode ? 1 : Vt.length, tr ? kt.buffer.unshift(Vt) : kt.buffer.push(Vt), kt.needReadable && wt(Pt)), rt(Pt, kt);
  }
  function qt(Pt, kt) {
    var Vt;
    return !pe(kt) && typeof kt != "string" && kt !== void 0 && !Pt.objectMode && (Vt = new TypeError("Invalid non-string/buffer chunk")), Vt;
  }
  function Dt(Pt) {
    return !Pt.ended && (Pt.needReadable || Pt.length < Pt.highWaterMark || Pt.length === 0);
  }
  bt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, bt.prototype.setEncoding = function(Pt) {
    return gt || (gt = string_decoder.StringDecoder), this._readableState.decoder = new gt(Pt), this._readableState.encoding = Pt, this;
  };
  var Xt = 8388608;
  function Bt(Pt) {
    return Pt >= Xt ? Pt = Xt : (Pt--, Pt |= Pt >>> 1, Pt |= Pt >>> 2, Pt |= Pt >>> 4, Pt |= Pt >>> 8, Pt |= Pt >>> 16, Pt++), Pt;
  }
  function mt(Pt, kt) {
    return Pt <= 0 || kt.length === 0 && kt.ended ? 0 : kt.objectMode ? 1 : Pt !== Pt ? kt.flowing && kt.length ? kt.buffer.head.data.length : kt.length : (Pt > kt.highWaterMark && (kt.highWaterMark = Bt(Pt)), Pt <= kt.length ? Pt : kt.ended ? kt.length : (kt.needReadable = !0, 0));
  }
  bt.prototype.read = function(Pt) {
    Ce("read", Pt), Pt = parseInt(Pt, 10);
    var kt = this._readableState, Vt = Pt;
    if (Pt !== 0 && (kt.emittedReadable = !1), Pt === 0 && kt.needReadable && (kt.length >= kt.highWaterMark || kt.ended))
      return Ce("read: emitReadable", kt.length, kt.ended), kt.length === 0 && kt.ended ? Kt(this) : wt(this), null;
    if (Pt = mt(Pt, kt), Pt === 0 && kt.ended)
      return kt.length === 0 && Kt(this), null;
    var tr = kt.needReadable;
    Ce("need readable", tr), (kt.length === 0 || kt.length - Pt < kt.highWaterMark) && (tr = !0, Ce("length less than watermark", tr)), kt.ended || kt.reading ? (tr = !1, Ce("reading or ended", tr)) : tr && (Ce("do read"), kt.reading = !0, kt.sync = !0, kt.length === 0 && (kt.needReadable = !0), this._read(kt.highWaterMark), kt.sync = !1, kt.reading || (Pt = mt(Vt, kt)));
    var Nt;
    return Pt > 0 ? Nt = st(Pt, kt) : Nt = null, Nt === null ? (kt.needReadable = !0, Pt = 0) : kt.length -= Pt, kt.length === 0 && (kt.ended || (kt.needReadable = !0), Vt !== Pt && kt.ended && Kt(this)), Nt !== null && this.emit("data", Nt), Nt;
  };
  function Ot(Pt, kt) {
    if (!kt.ended) {
      if (kt.decoder) {
        var Vt = kt.decoder.end();
        Vt && Vt.length && (kt.buffer.push(Vt), kt.length += kt.objectMode ? 1 : Vt.length);
      }
      kt.ended = !0, wt(Pt);
    }
  }
  function wt(Pt) {
    var kt = Pt._readableState;
    kt.needReadable = !1, kt.emittedReadable || (Ce("emitReadable", kt.flowing), kt.emittedReadable = !0, kt.sync ? A.nextTick(ke, Pt) : ke(Pt));
  }
  function ke(Pt) {
    Ce("emit readable"), Pt.emit("readable"), dt(Pt);
  }
  function rt(Pt, kt) {
    kt.readingMore || (kt.readingMore = !0, A.nextTick(ce, Pt, kt));
  }
  function ce(Pt, kt) {
    for (var Vt = kt.length; !kt.reading && !kt.flowing && !kt.ended && kt.length < kt.highWaterMark && (Ce("maybeReadMore read 0"), Pt.read(0), Vt !== kt.length); )
      Vt = kt.length;
    kt.readingMore = !1;
  }
  bt.prototype._read = function(Pt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, bt.prototype.pipe = function(Pt, kt) {
    var Vt = this, tr = this._readableState;
    switch (tr.pipesCount) {
      case 0:
        tr.pipes = Pt;
        break;
      case 1:
        tr.pipes = [tr.pipes, Pt];
        break;
      default:
        tr.pipes.push(Pt);
        break;
    }
    tr.pipesCount += 1, Ce("pipe count=%d opts=%j", tr.pipesCount, kt);
    var Nt = (!kt || kt.end !== !1) && Pt !== process$1.stdout && Pt !== process$1.stderr, Ft = Nt ? fr : Mr;
    tr.endEmitted ? A.nextTick(Ft) : Vt.once("end", Ft), Pt.on("unpipe", er);
    function er(_r, kr) {
      Ce("onunpipe"), _r === Vt && kr && kr.hasUnpiped === !1 && (kr.hasUnpiped = !0, br());
    }
    function fr() {
      Ce("onend"), Pt.end();
    }
    var cr = Oe(Vt);
    Pt.on("drain", cr);
    var dr = !1;
    function br() {
      Ce("cleanup"), Pt.removeListener("close", Br), Pt.removeListener("finish", Tr), Pt.removeListener("drain", cr), Pt.removeListener("error", Nr), Pt.removeListener("unpipe", er), Vt.removeListener("end", fr), Vt.removeListener("end", Mr), Vt.removeListener("data", or), dr = !0, tr.awaitDrain && (!Pt._writableState || Pt._writableState.needDrain) && cr();
    }
    var wr = !1;
    Vt.on("data", or);
    function or(_r) {
      Ce("ondata"), wr = !1;
      var kr = Pt.write(_r);
      kr === !1 && !wr && ((tr.pipesCount === 1 && tr.pipes === Pt || tr.pipesCount > 1 && Ht(tr.pipes, Pt) !== -1) && !dr && (Ce("false write response, pause", tr.awaitDrain), tr.awaitDrain++, wr = !0), Vt.pause());
    }
    function Nr(_r) {
      Ce("onerror", _r), Mr(), Pt.removeListener("error", Nr), V(Pt, "error") === 0 && Pt.emit("error", _r);
    }
    xt(Pt, "error", Nr);
    function Br() {
      Pt.removeListener("finish", Tr), Mr();
    }
    Pt.once("close", Br);
    function Tr() {
      Ce("onfinish"), Pt.removeListener("close", Br), Mr();
    }
    Pt.once("finish", Tr);
    function Mr() {
      Ce("unpipe"), Vt.unpipe(Pt);
    }
    return Pt.emit("pipe", Vt), tr.flowing || (Ce("pipe resume"), Vt.resume()), Pt;
  };
  function Oe(Pt) {
    return function() {
      var kt = Pt._readableState;
      Ce("pipeOnDrain", kt.awaitDrain), kt.awaitDrain && kt.awaitDrain--, kt.awaitDrain === 0 && V(Pt, "data") && (kt.flowing = !0, dt(Pt));
    };
  }
  bt.prototype.unpipe = function(Pt) {
    var kt = this._readableState, Vt = { hasUnpiped: !1 };
    if (kt.pipesCount === 0) return this;
    if (kt.pipesCount === 1)
      return Pt && Pt !== kt.pipes ? this : (Pt || (Pt = kt.pipes), kt.pipes = null, kt.pipesCount = 0, kt.flowing = !1, Pt && Pt.emit("unpipe", this, Vt), this);
    if (!Pt) {
      var tr = kt.pipes, Nt = kt.pipesCount;
      kt.pipes = null, kt.pipesCount = 0, kt.flowing = !1;
      for (var Ft = 0; Ft < Nt; Ft++)
        tr[Ft].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var er = Ht(kt.pipes, Pt);
    return er === -1 ? this : (kt.pipes.splice(er, 1), kt.pipesCount -= 1, kt.pipesCount === 1 && (kt.pipes = kt.pipes[0]), Pt.emit("unpipe", this, Vt), this);
  }, bt.prototype.on = function(Pt, kt) {
    var Vt = J.prototype.on.call(this, Pt, kt);
    if (Pt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Pt === "readable") {
      var tr = this._readableState;
      !tr.endEmitted && !tr.readableListening && (tr.readableListening = tr.needReadable = !0, tr.emittedReadable = !1, tr.reading ? tr.length && wt(this) : A.nextTick(ot, this));
    }
    return Vt;
  }, bt.prototype.addListener = bt.prototype.on;
  function ot(Pt) {
    Ce("readable nexttick read 0"), Pt.read(0);
  }
  bt.prototype.resume = function() {
    var Pt = this._readableState;
    return Pt.flowing || (Ce("resume"), Pt.flowing = !0, ut(this, Pt)), this;
  };
  function ut(Pt, kt) {
    kt.resumeScheduled || (kt.resumeScheduled = !0, A.nextTick(ht, Pt, kt));
  }
  function ht(Pt, kt) {
    kt.reading || (Ce("resume read 0"), Pt.read(0)), kt.resumeScheduled = !1, kt.awaitDrain = 0, Pt.emit("resume"), dt(Pt), kt.flowing && !kt.reading && Pt.read(0);
  }
  bt.prototype.pause = function() {
    return Ce("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ce("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function dt(Pt) {
    var kt = Pt._readableState;
    for (Ce("flow", kt.flowing); kt.flowing && Pt.read() !== null; )
      ;
  }
  bt.prototype.wrap = function(Pt) {
    var kt = this, Vt = this._readableState, tr = !1;
    Pt.on("end", function() {
      if (Ce("wrapped end"), Vt.decoder && !Vt.ended) {
        var er = Vt.decoder.end();
        er && er.length && kt.push(er);
      }
      kt.push(null);
    }), Pt.on("data", function(er) {
      if (Ce("wrapped data"), Vt.decoder && (er = Vt.decoder.write(er)), !(Vt.objectMode && er == null) && !(!Vt.objectMode && (!er || !er.length))) {
        var fr = kt.push(er);
        fr || (tr = !0, Pt.pause());
      }
    });
    for (var Nt in Pt)
      this[Nt] === void 0 && typeof Pt[Nt] == "function" && (this[Nt] = /* @__PURE__ */ function(er) {
        return function() {
          return Pt[er].apply(Pt, arguments);
        };
      }(Nt));
    for (var Ft = 0; Ft < St.length; Ft++)
      Pt.on(St[Ft], this.emit.bind(this, St[Ft]));
    return this._read = function(er) {
      Ce("wrapped _read", er), tr && (tr = !1, Pt.resume());
    }, this;
  }, Object.defineProperty(bt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), bt._fromList = st;
  function st(Pt, kt) {
    if (kt.length === 0) return null;
    var Vt;
    return kt.objectMode ? Vt = kt.buffer.shift() : !Pt || Pt >= kt.length ? (kt.decoder ? Vt = kt.buffer.join("") : kt.buffer.length === 1 ? Vt = kt.buffer.head.data : Vt = kt.buffer.concat(kt.length), kt.buffer.clear()) : Vt = yt(Pt, kt.buffer, kt.decoder), Vt;
  }
  function yt(Pt, kt, Vt) {
    var tr;
    return Pt < kt.head.data.length ? (tr = kt.head.data.slice(0, Pt), kt.head.data = kt.head.data.slice(Pt)) : Pt === kt.head.data.length ? tr = kt.shift() : tr = Vt ? ct(Pt, kt) : At(Pt, kt), tr;
  }
  function ct(Pt, kt) {
    var Vt = kt.head, tr = 1, Nt = Vt.data;
    for (Pt -= Nt.length; Vt = Vt.next; ) {
      var Ft = Vt.data, er = Pt > Ft.length ? Ft.length : Pt;
      if (er === Ft.length ? Nt += Ft : Nt += Ft.slice(0, Pt), Pt -= er, Pt === 0) {
        er === Ft.length ? (++tr, Vt.next ? kt.head = Vt.next : kt.head = kt.tail = null) : (kt.head = Vt, Vt.data = Ft.slice(er));
        break;
      }
      ++tr;
    }
    return kt.length -= tr, Nt;
  }
  function At(Pt, kt) {
    var Vt = re.allocUnsafe(Pt), tr = kt.head, Nt = 1;
    for (tr.data.copy(Vt), Pt -= tr.data.length; tr = tr.next; ) {
      var Ft = tr.data, er = Pt > Ft.length ? Ft.length : Pt;
      if (Ft.copy(Vt, Vt.length - Pt, 0, er), Pt -= er, Pt === 0) {
        er === Ft.length ? (++Nt, tr.next ? kt.head = tr.next : kt.head = kt.tail = null) : (kt.head = tr, tr.data = Ft.slice(er));
        break;
      }
      ++Nt;
    }
    return kt.length -= Nt, Vt;
  }
  function Kt(Pt) {
    var kt = Pt._readableState;
    if (kt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    kt.endEmitted || (kt.ended = !0, A.nextTick(Zt, kt, Pt));
  }
  function Zt(Pt, kt) {
    !Pt.endEmitted && Pt.length === 0 && (Pt.endEmitted = !0, kt.readable = !1, kt.emit("end"));
  }
  function Ht(Pt, kt) {
    for (var Vt = 0, tr = Pt.length; Vt < tr; Vt++)
      if (Pt[Vt] === kt) return Vt;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(A, B) {
  var L = this._transformState;
  L.transforming = !1;
  var V = L.writecb;
  if (!V)
    return this.emit("error", new Error("write callback called multiple times"));
  L.writechunk = null, L.writecb = null, B != null && this.push(B), V(A);
  var J = this._readableState;
  J.reading = !1, (J.needReadable || J.length < J.highWaterMark) && this._read(J.highWaterMark);
}
function Transform$1(A) {
  if (!(this instanceof Transform$1)) return new Transform$1(A);
  Duplex.call(this, A), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, A && (typeof A.transform == "function" && (this._transform = A.transform), typeof A.flush == "function" && (this._flush = A.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var A = this;
  typeof this._flush == "function" ? this._flush(function(B, L) {
    done(A, B, L);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(A, B) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, A, B);
};
Transform$1.prototype._transform = function(A, B, L) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(A, B, L) {
  var V = this._transformState;
  if (V.writecb = L, V.writechunk = A, V.writeencoding = B, !V.transforming) {
    var J = this._readableState;
    (V.needTransform || J.needReadable || J.length < J.highWaterMark) && this._read(J.highWaterMark);
  }
};
Transform$1.prototype._read = function(A) {
  var B = this._transformState;
  B.writechunk !== null && B.writecb && !B.transforming ? (B.transforming = !0, this._transform(B.writechunk, B.writeencoding, B.afterTransform)) : B.needTransform = !0;
};
Transform$1.prototype._destroy = function(A, B) {
  var L = this;
  Duplex.prototype._destroy.call(this, A, function(V) {
    B(V), L.emit("close");
  });
};
function done(A, B, L) {
  if (B) return A.emit("error", B);
  if (L != null && A.push(L), A._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (A._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return A.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(A) {
  if (!(this instanceof PassThrough)) return new PassThrough(A);
  Transform.call(this, A);
}
PassThrough.prototype._transform = function(A, B, L) {
  L(null, A);
};
(function(A, B) {
  B = A.exports = require_stream_readable(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable(), B.Duplex = require_stream_duplex(), B.Transform = _stream_transform, B.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn = { exports: {} };
bn.exports;
(function(A) {
  (function(B, L) {
    function V(rt, ce) {
      if (!rt) throw new Error(ce || "Assertion failed");
    }
    function J(rt, ce) {
      rt.super_ = ce;
      var Oe = function() {
      };
      Oe.prototype = ce.prototype, rt.prototype = new Oe(), rt.prototype.constructor = rt;
    }
    function re(rt, ce, Oe) {
      if (re.isBN(rt))
        return rt;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, rt !== null && ((ce === "le" || ce === "be") && (Oe = ce, ce = 10), this._init(rt || 0, ce || 10, Oe || "be"));
    }
    typeof B == "object" ? B.exports = re : L.BN = re, re.BN = re, re.wordSize = 26;
    var ne;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? ne = window.Buffer : ne = dist$1.Buffer;
    } catch {
    }
    re.isBN = function(ce) {
      return ce instanceof re ? !0 : ce !== null && typeof ce == "object" && ce.constructor.wordSize === re.wordSize && Array.isArray(ce.words);
    }, re.max = function(ce, Oe) {
      return ce.cmp(Oe) > 0 ? ce : Oe;
    }, re.min = function(ce, Oe) {
      return ce.cmp(Oe) < 0 ? ce : Oe;
    }, re.prototype._init = function(ce, Oe, ot) {
      if (typeof ce == "number")
        return this._initNumber(ce, Oe, ot);
      if (typeof ce == "object")
        return this._initArray(ce, Oe, ot);
      Oe === "hex" && (Oe = 16), V(Oe === (Oe | 0) && Oe >= 2 && Oe <= 36), ce = ce.toString().replace(/\s+/g, "");
      var ut = 0;
      ce[0] === "-" && (ut++, this.negative = 1), ut < ce.length && (Oe === 16 ? this._parseHex(ce, ut, ot) : (this._parseBase(ce, Oe, ut), ot === "le" && this._initArray(this.toArray(), Oe, ot)));
    }, re.prototype._initNumber = function(ce, Oe, ot) {
      ce < 0 && (this.negative = 1, ce = -ce), ce < 67108864 ? (this.words = [ce & 67108863], this.length = 1) : ce < 4503599627370496 ? (this.words = [
        ce & 67108863,
        ce / 67108864 & 67108863
      ], this.length = 2) : (V(ce < 9007199254740992), this.words = [
        ce & 67108863,
        ce / 67108864 & 67108863,
        1
      ], this.length = 3), ot === "le" && this._initArray(this.toArray(), Oe, ot);
    }, re.prototype._initArray = function(ce, Oe, ot) {
      if (V(typeof ce.length == "number"), ce.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(ce.length / 3), this.words = new Array(this.length);
      for (var ut = 0; ut < this.length; ut++)
        this.words[ut] = 0;
      var ht, dt, st = 0;
      if (ot === "be")
        for (ut = ce.length - 1, ht = 0; ut >= 0; ut -= 3)
          dt = ce[ut] | ce[ut - 1] << 8 | ce[ut - 2] << 16, this.words[ht] |= dt << st & 67108863, this.words[ht + 1] = dt >>> 26 - st & 67108863, st += 24, st >= 26 && (st -= 26, ht++);
      else if (ot === "le")
        for (ut = 0, ht = 0; ut < ce.length; ut += 3)
          dt = ce[ut] | ce[ut + 1] << 8 | ce[ut + 2] << 16, this.words[ht] |= dt << st & 67108863, this.words[ht + 1] = dt >>> 26 - st & 67108863, st += 24, st >= 26 && (st -= 26, ht++);
      return this._strip();
    };
    function ie(rt, ce) {
      var Oe = rt.charCodeAt(ce);
      if (Oe >= 48 && Oe <= 57)
        return Oe - 48;
      if (Oe >= 65 && Oe <= 70)
        return Oe - 55;
      if (Oe >= 97 && Oe <= 102)
        return Oe - 87;
      V(!1, "Invalid character in " + rt);
    }
    function pe(rt, ce, Oe) {
      var ot = ie(rt, Oe);
      return Oe - 1 >= ce && (ot |= ie(rt, Oe - 1) << 4), ot;
    }
    re.prototype._parseHex = function(ce, Oe, ot) {
      this.length = Math.ceil((ce.length - Oe) / 6), this.words = new Array(this.length);
      for (var ut = 0; ut < this.length; ut++)
        this.words[ut] = 0;
      var ht = 0, dt = 0, st;
      if (ot === "be")
        for (ut = ce.length - 1; ut >= Oe; ut -= 2)
          st = pe(ce, Oe, ut) << ht, this.words[dt] |= st & 67108863, ht >= 18 ? (ht -= 18, dt += 1, this.words[dt] |= st >>> 26) : ht += 8;
      else {
        var yt = ce.length - Oe;
        for (ut = yt % 2 === 0 ? Oe + 1 : Oe; ut < ce.length; ut += 2)
          st = pe(ce, Oe, ut) << ht, this.words[dt] |= st & 67108863, ht >= 18 ? (ht -= 18, dt += 1, this.words[dt] |= st >>> 26) : ht += 8;
      }
      this._strip();
    };
    function nt(rt, ce, Oe, ot) {
      for (var ut = 0, ht = 0, dt = Math.min(rt.length, Oe), st = ce; st < dt; st++) {
        var yt = rt.charCodeAt(st) - 48;
        ut *= ot, yt >= 49 ? ht = yt - 49 + 10 : yt >= 17 ? ht = yt - 17 + 10 : ht = yt, V(yt >= 0 && ht < ot, "Invalid character"), ut += ht;
      }
      return ut;
    }
    re.prototype._parseBase = function(ce, Oe, ot) {
      this.words = [0], this.length = 1;
      for (var ut = 0, ht = 1; ht <= 67108863; ht *= Oe)
        ut++;
      ut--, ht = ht / Oe | 0;
      for (var dt = ce.length - ot, st = dt % ut, yt = Math.min(dt, dt - st) + ot, ct = 0, At = ot; At < yt; At += ut)
        ct = nt(ce, At, At + ut, Oe), this.imuln(ht), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
      if (st !== 0) {
        var Kt = 1;
        for (ct = nt(ce, At, ce.length, Oe), At = 0; At < st; At++)
          Kt *= Oe;
        this.imuln(Kt), this.words[0] + ct < 67108864 ? this.words[0] += ct : this._iaddn(ct);
      }
      this._strip();
    }, re.prototype.copy = function(ce) {
      ce.words = new Array(this.length);
      for (var Oe = 0; Oe < this.length; Oe++)
        ce.words[Oe] = this.words[Oe];
      ce.length = this.length, ce.negative = this.negative, ce.red = this.red;
    };
    function oe(rt, ce) {
      rt.words = ce.words, rt.length = ce.length, rt.negative = ce.negative, rt.red = ce.red;
    }
    if (re.prototype._move = function(ce) {
      oe(ce, this);
    }, re.prototype.clone = function() {
      var ce = new re(null);
      return this.copy(ce), ce;
    }, re.prototype._expand = function(ce) {
      for (; this.length < ce; )
        this.words[this.length++] = 0;
      return this;
    }, re.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, re.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        re.prototype[Symbol.for("nodejs.util.inspect.custom")] = Ce;
      } catch {
        re.prototype.inspect = Ce;
      }
    else
      re.prototype.inspect = Ce;
    function Ce() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var at = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], it = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], gt = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    re.prototype.toString = function(ce, Oe) {
      ce = ce || 10, Oe = Oe | 0 || 1;
      var ot;
      if (ce === 16 || ce === "hex") {
        ot = "";
        for (var ut = 0, ht = 0, dt = 0; dt < this.length; dt++) {
          var st = this.words[dt], yt = ((st << ut | ht) & 16777215).toString(16);
          ht = st >>> 24 - ut & 16777215, ut += 2, ut >= 26 && (ut -= 26, dt--), ht !== 0 || dt !== this.length - 1 ? ot = at[6 - yt.length] + yt + ot : ot = yt + ot;
        }
        for (ht !== 0 && (ot = ht.toString(16) + ot); ot.length % Oe !== 0; )
          ot = "0" + ot;
        return this.negative !== 0 && (ot = "-" + ot), ot;
      }
      if (ce === (ce | 0) && ce >= 2 && ce <= 36) {
        var ct = it[ce], At = gt[ce];
        ot = "";
        var Kt = this.clone();
        for (Kt.negative = 0; !Kt.isZero(); ) {
          var Zt = Kt.modrn(At).toString(ce);
          Kt = Kt.idivn(At), Kt.isZero() ? ot = Zt + ot : ot = at[ct - Zt.length] + Zt + ot;
        }
        for (this.isZero() && (ot = "0" + ot); ot.length % Oe !== 0; )
          ot = "0" + ot;
        return this.negative !== 0 && (ot = "-" + ot), ot;
      }
      V(!1, "Base should be between 2 and 36");
    }, re.prototype.toNumber = function() {
      var ce = this.words[0];
      return this.length === 2 ? ce += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ce += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && V(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ce : ce;
    }, re.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, ne && (re.prototype.toBuffer = function(ce, Oe) {
      return this.toArrayLike(ne, ce, Oe);
    }), re.prototype.toArray = function(ce, Oe) {
      return this.toArrayLike(Array, ce, Oe);
    };
    var St = function(ce, Oe) {
      return ce.allocUnsafe ? ce.allocUnsafe(Oe) : new ce(Oe);
    };
    re.prototype.toArrayLike = function(ce, Oe, ot) {
      this._strip();
      var ut = this.byteLength(), ht = ot || Math.max(1, ut);
      V(ut <= ht, "byte array longer than desired length"), V(ht > 0, "Requested array length <= 0");
      var dt = St(ce, ht), st = Oe === "le" ? "LE" : "BE";
      return this["_toArrayLike" + st](dt, ut), dt;
    }, re.prototype._toArrayLikeLE = function(ce, Oe) {
      for (var ot = 0, ut = 0, ht = 0, dt = 0; ht < this.length; ht++) {
        var st = this.words[ht] << dt | ut;
        ce[ot++] = st & 255, ot < ce.length && (ce[ot++] = st >> 8 & 255), ot < ce.length && (ce[ot++] = st >> 16 & 255), dt === 6 ? (ot < ce.length && (ce[ot++] = st >> 24 & 255), ut = 0, dt = 0) : (ut = st >>> 24, dt += 2);
      }
      if (ot < ce.length)
        for (ce[ot++] = ut; ot < ce.length; )
          ce[ot++] = 0;
    }, re.prototype._toArrayLikeBE = function(ce, Oe) {
      for (var ot = ce.length - 1, ut = 0, ht = 0, dt = 0; ht < this.length; ht++) {
        var st = this.words[ht] << dt | ut;
        ce[ot--] = st & 255, ot >= 0 && (ce[ot--] = st >> 8 & 255), ot >= 0 && (ce[ot--] = st >> 16 & 255), dt === 6 ? (ot >= 0 && (ce[ot--] = st >> 24 & 255), ut = 0, dt = 0) : (ut = st >>> 24, dt += 2);
      }
      if (ot >= 0)
        for (ce[ot--] = ut; ot >= 0; )
          ce[ot--] = 0;
    }, Math.clz32 ? re.prototype._countBits = function(ce) {
      return 32 - Math.clz32(ce);
    } : re.prototype._countBits = function(ce) {
      var Oe = ce, ot = 0;
      return Oe >= 4096 && (ot += 13, Oe >>>= 13), Oe >= 64 && (ot += 7, Oe >>>= 7), Oe >= 8 && (ot += 4, Oe >>>= 4), Oe >= 2 && (ot += 2, Oe >>>= 2), ot + Oe;
    }, re.prototype._zeroBits = function(ce) {
      if (ce === 0) return 26;
      var Oe = ce, ot = 0;
      return Oe & 8191 || (ot += 13, Oe >>>= 13), Oe & 127 || (ot += 7, Oe >>>= 7), Oe & 15 || (ot += 4, Oe >>>= 4), Oe & 3 || (ot += 2, Oe >>>= 2), Oe & 1 || ot++, ot;
    }, re.prototype.bitLength = function() {
      var ce = this.words[this.length - 1], Oe = this._countBits(ce);
      return (this.length - 1) * 26 + Oe;
    };
    function xt(rt) {
      for (var ce = new Array(rt.bitLength()), Oe = 0; Oe < ce.length; Oe++) {
        var ot = Oe / 26 | 0, ut = Oe % 26;
        ce[Oe] = rt.words[ot] >>> ut & 1;
      }
      return ce;
    }
    re.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var ce = 0, Oe = 0; Oe < this.length; Oe++) {
        var ot = this._zeroBits(this.words[Oe]);
        if (ce += ot, ot !== 26) break;
      }
      return ce;
    }, re.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, re.prototype.toTwos = function(ce) {
      return this.negative !== 0 ? this.abs().inotn(ce).iaddn(1) : this.clone();
    }, re.prototype.fromTwos = function(ce) {
      return this.testn(ce - 1) ? this.notn(ce).iaddn(1).ineg() : this.clone();
    }, re.prototype.isNeg = function() {
      return this.negative !== 0;
    }, re.prototype.neg = function() {
      return this.clone().ineg();
    }, re.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, re.prototype.iuor = function(ce) {
      for (; this.length < ce.length; )
        this.words[this.length++] = 0;
      for (var Oe = 0; Oe < ce.length; Oe++)
        this.words[Oe] = this.words[Oe] | ce.words[Oe];
      return this._strip();
    }, re.prototype.ior = function(ce) {
      return V((this.negative | ce.negative) === 0), this.iuor(ce);
    }, re.prototype.or = function(ce) {
      return this.length > ce.length ? this.clone().ior(ce) : ce.clone().ior(this);
    }, re.prototype.uor = function(ce) {
      return this.length > ce.length ? this.clone().iuor(ce) : ce.clone().iuor(this);
    }, re.prototype.iuand = function(ce) {
      var Oe;
      this.length > ce.length ? Oe = ce : Oe = this;
      for (var ot = 0; ot < Oe.length; ot++)
        this.words[ot] = this.words[ot] & ce.words[ot];
      return this.length = Oe.length, this._strip();
    }, re.prototype.iand = function(ce) {
      return V((this.negative | ce.negative) === 0), this.iuand(ce);
    }, re.prototype.and = function(ce) {
      return this.length > ce.length ? this.clone().iand(ce) : ce.clone().iand(this);
    }, re.prototype.uand = function(ce) {
      return this.length > ce.length ? this.clone().iuand(ce) : ce.clone().iuand(this);
    }, re.prototype.iuxor = function(ce) {
      var Oe, ot;
      this.length > ce.length ? (Oe = this, ot = ce) : (Oe = ce, ot = this);
      for (var ut = 0; ut < ot.length; ut++)
        this.words[ut] = Oe.words[ut] ^ ot.words[ut];
      if (this !== Oe)
        for (; ut < Oe.length; ut++)
          this.words[ut] = Oe.words[ut];
      return this.length = Oe.length, this._strip();
    }, re.prototype.ixor = function(ce) {
      return V((this.negative | ce.negative) === 0), this.iuxor(ce);
    }, re.prototype.xor = function(ce) {
      return this.length > ce.length ? this.clone().ixor(ce) : ce.clone().ixor(this);
    }, re.prototype.uxor = function(ce) {
      return this.length > ce.length ? this.clone().iuxor(ce) : ce.clone().iuxor(this);
    }, re.prototype.inotn = function(ce) {
      V(typeof ce == "number" && ce >= 0);
      var Oe = Math.ceil(ce / 26) | 0, ot = ce % 26;
      this._expand(Oe), ot > 0 && Oe--;
      for (var ut = 0; ut < Oe; ut++)
        this.words[ut] = ~this.words[ut] & 67108863;
      return ot > 0 && (this.words[ut] = ~this.words[ut] & 67108863 >> 26 - ot), this._strip();
    }, re.prototype.notn = function(ce) {
      return this.clone().inotn(ce);
    }, re.prototype.setn = function(ce, Oe) {
      V(typeof ce == "number" && ce >= 0);
      var ot = ce / 26 | 0, ut = ce % 26;
      return this._expand(ot + 1), Oe ? this.words[ot] = this.words[ot] | 1 << ut : this.words[ot] = this.words[ot] & ~(1 << ut), this._strip();
    }, re.prototype.iadd = function(ce) {
      var Oe;
      if (this.negative !== 0 && ce.negative === 0)
        return this.negative = 0, Oe = this.isub(ce), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && ce.negative !== 0)
        return ce.negative = 0, Oe = this.isub(ce), ce.negative = 1, Oe._normSign();
      var ot, ut;
      this.length > ce.length ? (ot = this, ut = ce) : (ot = ce, ut = this);
      for (var ht = 0, dt = 0; dt < ut.length; dt++)
        Oe = (ot.words[dt] | 0) + (ut.words[dt] | 0) + ht, this.words[dt] = Oe & 67108863, ht = Oe >>> 26;
      for (; ht !== 0 && dt < ot.length; dt++)
        Oe = (ot.words[dt] | 0) + ht, this.words[dt] = Oe & 67108863, ht = Oe >>> 26;
      if (this.length = ot.length, ht !== 0)
        this.words[this.length] = ht, this.length++;
      else if (ot !== this)
        for (; dt < ot.length; dt++)
          this.words[dt] = ot.words[dt];
      return this;
    }, re.prototype.add = function(ce) {
      var Oe;
      return ce.negative !== 0 && this.negative === 0 ? (ce.negative = 0, Oe = this.sub(ce), ce.negative ^= 1, Oe) : ce.negative === 0 && this.negative !== 0 ? (this.negative = 0, Oe = ce.sub(this), this.negative = 1, Oe) : this.length > ce.length ? this.clone().iadd(ce) : ce.clone().iadd(this);
    }, re.prototype.isub = function(ce) {
      if (ce.negative !== 0) {
        ce.negative = 0;
        var Oe = this.iadd(ce);
        return ce.negative = 1, Oe._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(ce), this.negative = 1, this._normSign();
      var ot = this.cmp(ce);
      if (ot === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var ut, ht;
      ot > 0 ? (ut = this, ht = ce) : (ut = ce, ht = this);
      for (var dt = 0, st = 0; st < ht.length; st++)
        Oe = (ut.words[st] | 0) - (ht.words[st] | 0) + dt, dt = Oe >> 26, this.words[st] = Oe & 67108863;
      for (; dt !== 0 && st < ut.length; st++)
        Oe = (ut.words[st] | 0) + dt, dt = Oe >> 26, this.words[st] = Oe & 67108863;
      if (dt === 0 && st < ut.length && ut !== this)
        for (; st < ut.length; st++)
          this.words[st] = ut.words[st];
      return this.length = Math.max(this.length, st), ut !== this && (this.negative = 1), this._strip();
    }, re.prototype.sub = function(ce) {
      return this.clone().isub(ce);
    };
    function Mt(rt, ce, Oe) {
      Oe.negative = ce.negative ^ rt.negative;
      var ot = rt.length + ce.length | 0;
      Oe.length = ot, ot = ot - 1 | 0;
      var ut = rt.words[0] | 0, ht = ce.words[0] | 0, dt = ut * ht, st = dt & 67108863, yt = dt / 67108864 | 0;
      Oe.words[0] = st;
      for (var ct = 1; ct < ot; ct++) {
        for (var At = yt >>> 26, Kt = yt & 67108863, Zt = Math.min(ct, ce.length - 1), Ht = Math.max(0, ct - rt.length + 1); Ht <= Zt; Ht++) {
          var Pt = ct - Ht | 0;
          ut = rt.words[Pt] | 0, ht = ce.words[Ht] | 0, dt = ut * ht + Kt, At += dt / 67108864 | 0, Kt = dt & 67108863;
        }
        Oe.words[ct] = Kt | 0, yt = At | 0;
      }
      return yt !== 0 ? Oe.words[ct] = yt | 0 : Oe.length--, Oe._strip();
    }
    var bt = function(ce, Oe, ot) {
      var ut = ce.words, ht = Oe.words, dt = ot.words, st = 0, yt, ct, At, Kt = ut[0] | 0, Zt = Kt & 8191, Ht = Kt >>> 13, Pt = ut[1] | 0, kt = Pt & 8191, Vt = Pt >>> 13, tr = ut[2] | 0, Nt = tr & 8191, Ft = tr >>> 13, er = ut[3] | 0, fr = er & 8191, cr = er >>> 13, dr = ut[4] | 0, br = dr & 8191, wr = dr >>> 13, or = ut[5] | 0, Nr = or & 8191, Br = or >>> 13, Tr = ut[6] | 0, Mr = Tr & 8191, _r = Tr >>> 13, kr = ut[7] | 0, Fr = kr & 8191, Ar = kr >>> 13, Cr = ut[8] | 0, Dr = Cr & 8191, Rt = Cr >>> 13, vt = ut[9] | 0, $t = vt & 8191, Ut = vt >>> 13, Yt = ht[0] | 0, rr = Yt & 8191, ir = Yt >>> 13, gr = ht[1] | 0, Ir = gr & 8191, yr = gr >>> 13, Pr = ht[2] | 0, $r = Pr & 8191, Er = Pr >>> 13, Or = ht[3] | 0, Ur = Or & 8191, Gt = Or >>> 13, Lt = ht[4] | 0, zt = Lt & 8191, Et = Lt >>> 13, lt = ht[5] | 0, pt = lt & 8191, Ct = lt >>> 13, Wt = ht[6] | 0, Jt = Wt & 8191, Qt = Wt >>> 13, ur = ht[7] | 0, pr = ur & 8191, jt = ur >>> 13, nr = ht[8] | 0, ar = nr & 8191, lr = nr >>> 13, Sr = ht[9] | 0, xr = Sr & 8191, vr = Sr >>> 13;
      ot.negative = ce.negative ^ Oe.negative, ot.length = 19, yt = Math.imul(Zt, rr), ct = Math.imul(Zt, ir), ct = ct + Math.imul(Ht, rr) | 0, At = Math.imul(Ht, ir);
      var Rr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Rr >>> 26) | 0, Rr &= 67108863, yt = Math.imul(kt, rr), ct = Math.imul(kt, ir), ct = ct + Math.imul(Vt, rr) | 0, At = Math.imul(Vt, ir), yt = yt + Math.imul(Zt, Ir) | 0, ct = ct + Math.imul(Zt, yr) | 0, ct = ct + Math.imul(Ht, Ir) | 0, At = At + Math.imul(Ht, yr) | 0;
      var jr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, yt = Math.imul(Nt, rr), ct = Math.imul(Nt, ir), ct = ct + Math.imul(Ft, rr) | 0, At = Math.imul(Ft, ir), yt = yt + Math.imul(kt, Ir) | 0, ct = ct + Math.imul(kt, yr) | 0, ct = ct + Math.imul(Vt, Ir) | 0, At = At + Math.imul(Vt, yr) | 0, yt = yt + Math.imul(Zt, $r) | 0, ct = ct + Math.imul(Zt, Er) | 0, ct = ct + Math.imul(Ht, $r) | 0, At = At + Math.imul(Ht, Er) | 0;
      var Lr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, yt = Math.imul(fr, rr), ct = Math.imul(fr, ir), ct = ct + Math.imul(cr, rr) | 0, At = Math.imul(cr, ir), yt = yt + Math.imul(Nt, Ir) | 0, ct = ct + Math.imul(Nt, yr) | 0, ct = ct + Math.imul(Ft, Ir) | 0, At = At + Math.imul(Ft, yr) | 0, yt = yt + Math.imul(kt, $r) | 0, ct = ct + Math.imul(kt, Er) | 0, ct = ct + Math.imul(Vt, $r) | 0, At = At + Math.imul(Vt, Er) | 0, yt = yt + Math.imul(Zt, Ur) | 0, ct = ct + Math.imul(Zt, Gt) | 0, ct = ct + Math.imul(Ht, Ur) | 0, At = At + Math.imul(Ht, Gt) | 0;
      var Hr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, yt = Math.imul(br, rr), ct = Math.imul(br, ir), ct = ct + Math.imul(wr, rr) | 0, At = Math.imul(wr, ir), yt = yt + Math.imul(fr, Ir) | 0, ct = ct + Math.imul(fr, yr) | 0, ct = ct + Math.imul(cr, Ir) | 0, At = At + Math.imul(cr, yr) | 0, yt = yt + Math.imul(Nt, $r) | 0, ct = ct + Math.imul(Nt, Er) | 0, ct = ct + Math.imul(Ft, $r) | 0, At = At + Math.imul(Ft, Er) | 0, yt = yt + Math.imul(kt, Ur) | 0, ct = ct + Math.imul(kt, Gt) | 0, ct = ct + Math.imul(Vt, Ur) | 0, At = At + Math.imul(Vt, Gt) | 0, yt = yt + Math.imul(Zt, zt) | 0, ct = ct + Math.imul(Zt, Et) | 0, ct = ct + Math.imul(Ht, zt) | 0, At = At + Math.imul(Ht, Et) | 0;
      var Wr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, yt = Math.imul(Nr, rr), ct = Math.imul(Nr, ir), ct = ct + Math.imul(Br, rr) | 0, At = Math.imul(Br, ir), yt = yt + Math.imul(br, Ir) | 0, ct = ct + Math.imul(br, yr) | 0, ct = ct + Math.imul(wr, Ir) | 0, At = At + Math.imul(wr, yr) | 0, yt = yt + Math.imul(fr, $r) | 0, ct = ct + Math.imul(fr, Er) | 0, ct = ct + Math.imul(cr, $r) | 0, At = At + Math.imul(cr, Er) | 0, yt = yt + Math.imul(Nt, Ur) | 0, ct = ct + Math.imul(Nt, Gt) | 0, ct = ct + Math.imul(Ft, Ur) | 0, At = At + Math.imul(Ft, Gt) | 0, yt = yt + Math.imul(kt, zt) | 0, ct = ct + Math.imul(kt, Et) | 0, ct = ct + Math.imul(Vt, zt) | 0, At = At + Math.imul(Vt, Et) | 0, yt = yt + Math.imul(Zt, pt) | 0, ct = ct + Math.imul(Zt, Ct) | 0, ct = ct + Math.imul(Ht, pt) | 0, At = At + Math.imul(Ht, Ct) | 0;
      var Vr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, yt = Math.imul(Mr, rr), ct = Math.imul(Mr, ir), ct = ct + Math.imul(_r, rr) | 0, At = Math.imul(_r, ir), yt = yt + Math.imul(Nr, Ir) | 0, ct = ct + Math.imul(Nr, yr) | 0, ct = ct + Math.imul(Br, Ir) | 0, At = At + Math.imul(Br, yr) | 0, yt = yt + Math.imul(br, $r) | 0, ct = ct + Math.imul(br, Er) | 0, ct = ct + Math.imul(wr, $r) | 0, At = At + Math.imul(wr, Er) | 0, yt = yt + Math.imul(fr, Ur) | 0, ct = ct + Math.imul(fr, Gt) | 0, ct = ct + Math.imul(cr, Ur) | 0, At = At + Math.imul(cr, Gt) | 0, yt = yt + Math.imul(Nt, zt) | 0, ct = ct + Math.imul(Nt, Et) | 0, ct = ct + Math.imul(Ft, zt) | 0, At = At + Math.imul(Ft, Et) | 0, yt = yt + Math.imul(kt, pt) | 0, ct = ct + Math.imul(kt, Ct) | 0, ct = ct + Math.imul(Vt, pt) | 0, At = At + Math.imul(Vt, Ct) | 0, yt = yt + Math.imul(Zt, Jt) | 0, ct = ct + Math.imul(Zt, Qt) | 0, ct = ct + Math.imul(Ht, Jt) | 0, At = At + Math.imul(Ht, Qt) | 0;
      var Gr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, yt = Math.imul(Fr, rr), ct = Math.imul(Fr, ir), ct = ct + Math.imul(Ar, rr) | 0, At = Math.imul(Ar, ir), yt = yt + Math.imul(Mr, Ir) | 0, ct = ct + Math.imul(Mr, yr) | 0, ct = ct + Math.imul(_r, Ir) | 0, At = At + Math.imul(_r, yr) | 0, yt = yt + Math.imul(Nr, $r) | 0, ct = ct + Math.imul(Nr, Er) | 0, ct = ct + Math.imul(Br, $r) | 0, At = At + Math.imul(Br, Er) | 0, yt = yt + Math.imul(br, Ur) | 0, ct = ct + Math.imul(br, Gt) | 0, ct = ct + Math.imul(wr, Ur) | 0, At = At + Math.imul(wr, Gt) | 0, yt = yt + Math.imul(fr, zt) | 0, ct = ct + Math.imul(fr, Et) | 0, ct = ct + Math.imul(cr, zt) | 0, At = At + Math.imul(cr, Et) | 0, yt = yt + Math.imul(Nt, pt) | 0, ct = ct + Math.imul(Nt, Ct) | 0, ct = ct + Math.imul(Ft, pt) | 0, At = At + Math.imul(Ft, Ct) | 0, yt = yt + Math.imul(kt, Jt) | 0, ct = ct + Math.imul(kt, Qt) | 0, ct = ct + Math.imul(Vt, Jt) | 0, At = At + Math.imul(Vt, Qt) | 0, yt = yt + Math.imul(Zt, pr) | 0, ct = ct + Math.imul(Zt, jt) | 0, ct = ct + Math.imul(Ht, pr) | 0, At = At + Math.imul(Ht, jt) | 0;
      var qr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, yt = Math.imul(Dr, rr), ct = Math.imul(Dr, ir), ct = ct + Math.imul(Rt, rr) | 0, At = Math.imul(Rt, ir), yt = yt + Math.imul(Fr, Ir) | 0, ct = ct + Math.imul(Fr, yr) | 0, ct = ct + Math.imul(Ar, Ir) | 0, At = At + Math.imul(Ar, yr) | 0, yt = yt + Math.imul(Mr, $r) | 0, ct = ct + Math.imul(Mr, Er) | 0, ct = ct + Math.imul(_r, $r) | 0, At = At + Math.imul(_r, Er) | 0, yt = yt + Math.imul(Nr, Ur) | 0, ct = ct + Math.imul(Nr, Gt) | 0, ct = ct + Math.imul(Br, Ur) | 0, At = At + Math.imul(Br, Gt) | 0, yt = yt + Math.imul(br, zt) | 0, ct = ct + Math.imul(br, Et) | 0, ct = ct + Math.imul(wr, zt) | 0, At = At + Math.imul(wr, Et) | 0, yt = yt + Math.imul(fr, pt) | 0, ct = ct + Math.imul(fr, Ct) | 0, ct = ct + Math.imul(cr, pt) | 0, At = At + Math.imul(cr, Ct) | 0, yt = yt + Math.imul(Nt, Jt) | 0, ct = ct + Math.imul(Nt, Qt) | 0, ct = ct + Math.imul(Ft, Jt) | 0, At = At + Math.imul(Ft, Qt) | 0, yt = yt + Math.imul(kt, pr) | 0, ct = ct + Math.imul(kt, jt) | 0, ct = ct + Math.imul(Vt, pr) | 0, At = At + Math.imul(Vt, jt) | 0, yt = yt + Math.imul(Zt, ar) | 0, ct = ct + Math.imul(Zt, lr) | 0, ct = ct + Math.imul(Ht, ar) | 0, At = At + Math.imul(Ht, lr) | 0;
      var Xr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, yt = Math.imul($t, rr), ct = Math.imul($t, ir), ct = ct + Math.imul(Ut, rr) | 0, At = Math.imul(Ut, ir), yt = yt + Math.imul(Dr, Ir) | 0, ct = ct + Math.imul(Dr, yr) | 0, ct = ct + Math.imul(Rt, Ir) | 0, At = At + Math.imul(Rt, yr) | 0, yt = yt + Math.imul(Fr, $r) | 0, ct = ct + Math.imul(Fr, Er) | 0, ct = ct + Math.imul(Ar, $r) | 0, At = At + Math.imul(Ar, Er) | 0, yt = yt + Math.imul(Mr, Ur) | 0, ct = ct + Math.imul(Mr, Gt) | 0, ct = ct + Math.imul(_r, Ur) | 0, At = At + Math.imul(_r, Gt) | 0, yt = yt + Math.imul(Nr, zt) | 0, ct = ct + Math.imul(Nr, Et) | 0, ct = ct + Math.imul(Br, zt) | 0, At = At + Math.imul(Br, Et) | 0, yt = yt + Math.imul(br, pt) | 0, ct = ct + Math.imul(br, Ct) | 0, ct = ct + Math.imul(wr, pt) | 0, At = At + Math.imul(wr, Ct) | 0, yt = yt + Math.imul(fr, Jt) | 0, ct = ct + Math.imul(fr, Qt) | 0, ct = ct + Math.imul(cr, Jt) | 0, At = At + Math.imul(cr, Qt) | 0, yt = yt + Math.imul(Nt, pr) | 0, ct = ct + Math.imul(Nt, jt) | 0, ct = ct + Math.imul(Ft, pr) | 0, At = At + Math.imul(Ft, jt) | 0, yt = yt + Math.imul(kt, ar) | 0, ct = ct + Math.imul(kt, lr) | 0, ct = ct + Math.imul(Vt, ar) | 0, At = At + Math.imul(Vt, lr) | 0, yt = yt + Math.imul(Zt, xr) | 0, ct = ct + Math.imul(Zt, vr) | 0, ct = ct + Math.imul(Ht, xr) | 0, At = At + Math.imul(Ht, vr) | 0;
      var Yr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, yt = Math.imul($t, Ir), ct = Math.imul($t, yr), ct = ct + Math.imul(Ut, Ir) | 0, At = Math.imul(Ut, yr), yt = yt + Math.imul(Dr, $r) | 0, ct = ct + Math.imul(Dr, Er) | 0, ct = ct + Math.imul(Rt, $r) | 0, At = At + Math.imul(Rt, Er) | 0, yt = yt + Math.imul(Fr, Ur) | 0, ct = ct + Math.imul(Fr, Gt) | 0, ct = ct + Math.imul(Ar, Ur) | 0, At = At + Math.imul(Ar, Gt) | 0, yt = yt + Math.imul(Mr, zt) | 0, ct = ct + Math.imul(Mr, Et) | 0, ct = ct + Math.imul(_r, zt) | 0, At = At + Math.imul(_r, Et) | 0, yt = yt + Math.imul(Nr, pt) | 0, ct = ct + Math.imul(Nr, Ct) | 0, ct = ct + Math.imul(Br, pt) | 0, At = At + Math.imul(Br, Ct) | 0, yt = yt + Math.imul(br, Jt) | 0, ct = ct + Math.imul(br, Qt) | 0, ct = ct + Math.imul(wr, Jt) | 0, At = At + Math.imul(wr, Qt) | 0, yt = yt + Math.imul(fr, pr) | 0, ct = ct + Math.imul(fr, jt) | 0, ct = ct + Math.imul(cr, pr) | 0, At = At + Math.imul(cr, jt) | 0, yt = yt + Math.imul(Nt, ar) | 0, ct = ct + Math.imul(Nt, lr) | 0, ct = ct + Math.imul(Ft, ar) | 0, At = At + Math.imul(Ft, lr) | 0, yt = yt + Math.imul(kt, xr) | 0, ct = ct + Math.imul(kt, vr) | 0, ct = ct + Math.imul(Vt, xr) | 0, At = At + Math.imul(Vt, vr) | 0;
      var Jr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, yt = Math.imul($t, $r), ct = Math.imul($t, Er), ct = ct + Math.imul(Ut, $r) | 0, At = Math.imul(Ut, Er), yt = yt + Math.imul(Dr, Ur) | 0, ct = ct + Math.imul(Dr, Gt) | 0, ct = ct + Math.imul(Rt, Ur) | 0, At = At + Math.imul(Rt, Gt) | 0, yt = yt + Math.imul(Fr, zt) | 0, ct = ct + Math.imul(Fr, Et) | 0, ct = ct + Math.imul(Ar, zt) | 0, At = At + Math.imul(Ar, Et) | 0, yt = yt + Math.imul(Mr, pt) | 0, ct = ct + Math.imul(Mr, Ct) | 0, ct = ct + Math.imul(_r, pt) | 0, At = At + Math.imul(_r, Ct) | 0, yt = yt + Math.imul(Nr, Jt) | 0, ct = ct + Math.imul(Nr, Qt) | 0, ct = ct + Math.imul(Br, Jt) | 0, At = At + Math.imul(Br, Qt) | 0, yt = yt + Math.imul(br, pr) | 0, ct = ct + Math.imul(br, jt) | 0, ct = ct + Math.imul(wr, pr) | 0, At = At + Math.imul(wr, jt) | 0, yt = yt + Math.imul(fr, ar) | 0, ct = ct + Math.imul(fr, lr) | 0, ct = ct + Math.imul(cr, ar) | 0, At = At + Math.imul(cr, lr) | 0, yt = yt + Math.imul(Nt, xr) | 0, ct = ct + Math.imul(Nt, vr) | 0, ct = ct + Math.imul(Ft, xr) | 0, At = At + Math.imul(Ft, vr) | 0;
      var Qr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, yt = Math.imul($t, Ur), ct = Math.imul($t, Gt), ct = ct + Math.imul(Ut, Ur) | 0, At = Math.imul(Ut, Gt), yt = yt + Math.imul(Dr, zt) | 0, ct = ct + Math.imul(Dr, Et) | 0, ct = ct + Math.imul(Rt, zt) | 0, At = At + Math.imul(Rt, Et) | 0, yt = yt + Math.imul(Fr, pt) | 0, ct = ct + Math.imul(Fr, Ct) | 0, ct = ct + Math.imul(Ar, pt) | 0, At = At + Math.imul(Ar, Ct) | 0, yt = yt + Math.imul(Mr, Jt) | 0, ct = ct + Math.imul(Mr, Qt) | 0, ct = ct + Math.imul(_r, Jt) | 0, At = At + Math.imul(_r, Qt) | 0, yt = yt + Math.imul(Nr, pr) | 0, ct = ct + Math.imul(Nr, jt) | 0, ct = ct + Math.imul(Br, pr) | 0, At = At + Math.imul(Br, jt) | 0, yt = yt + Math.imul(br, ar) | 0, ct = ct + Math.imul(br, lr) | 0, ct = ct + Math.imul(wr, ar) | 0, At = At + Math.imul(wr, lr) | 0, yt = yt + Math.imul(fr, xr) | 0, ct = ct + Math.imul(fr, vr) | 0, ct = ct + Math.imul(cr, xr) | 0, At = At + Math.imul(cr, vr) | 0;
      var Zr = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, yt = Math.imul($t, zt), ct = Math.imul($t, Et), ct = ct + Math.imul(Ut, zt) | 0, At = Math.imul(Ut, Et), yt = yt + Math.imul(Dr, pt) | 0, ct = ct + Math.imul(Dr, Ct) | 0, ct = ct + Math.imul(Rt, pt) | 0, At = At + Math.imul(Rt, Ct) | 0, yt = yt + Math.imul(Fr, Jt) | 0, ct = ct + Math.imul(Fr, Qt) | 0, ct = ct + Math.imul(Ar, Jt) | 0, At = At + Math.imul(Ar, Qt) | 0, yt = yt + Math.imul(Mr, pr) | 0, ct = ct + Math.imul(Mr, jt) | 0, ct = ct + Math.imul(_r, pr) | 0, At = At + Math.imul(_r, jt) | 0, yt = yt + Math.imul(Nr, ar) | 0, ct = ct + Math.imul(Nr, lr) | 0, ct = ct + Math.imul(Br, ar) | 0, At = At + Math.imul(Br, lr) | 0, yt = yt + Math.imul(br, xr) | 0, ct = ct + Math.imul(br, vr) | 0, ct = ct + Math.imul(wr, xr) | 0, At = At + Math.imul(wr, vr) | 0;
      var en = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, yt = Math.imul($t, pt), ct = Math.imul($t, Ct), ct = ct + Math.imul(Ut, pt) | 0, At = Math.imul(Ut, Ct), yt = yt + Math.imul(Dr, Jt) | 0, ct = ct + Math.imul(Dr, Qt) | 0, ct = ct + Math.imul(Rt, Jt) | 0, At = At + Math.imul(Rt, Qt) | 0, yt = yt + Math.imul(Fr, pr) | 0, ct = ct + Math.imul(Fr, jt) | 0, ct = ct + Math.imul(Ar, pr) | 0, At = At + Math.imul(Ar, jt) | 0, yt = yt + Math.imul(Mr, ar) | 0, ct = ct + Math.imul(Mr, lr) | 0, ct = ct + Math.imul(_r, ar) | 0, At = At + Math.imul(_r, lr) | 0, yt = yt + Math.imul(Nr, xr) | 0, ct = ct + Math.imul(Nr, vr) | 0, ct = ct + Math.imul(Br, xr) | 0, At = At + Math.imul(Br, vr) | 0;
      var tn = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, yt = Math.imul($t, Jt), ct = Math.imul($t, Qt), ct = ct + Math.imul(Ut, Jt) | 0, At = Math.imul(Ut, Qt), yt = yt + Math.imul(Dr, pr) | 0, ct = ct + Math.imul(Dr, jt) | 0, ct = ct + Math.imul(Rt, pr) | 0, At = At + Math.imul(Rt, jt) | 0, yt = yt + Math.imul(Fr, ar) | 0, ct = ct + Math.imul(Fr, lr) | 0, ct = ct + Math.imul(Ar, ar) | 0, At = At + Math.imul(Ar, lr) | 0, yt = yt + Math.imul(Mr, xr) | 0, ct = ct + Math.imul(Mr, vr) | 0, ct = ct + Math.imul(_r, xr) | 0, At = At + Math.imul(_r, vr) | 0;
      var rn = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (rn >>> 26) | 0, rn &= 67108863, yt = Math.imul($t, pr), ct = Math.imul($t, jt), ct = ct + Math.imul(Ut, pr) | 0, At = Math.imul(Ut, jt), yt = yt + Math.imul(Dr, ar) | 0, ct = ct + Math.imul(Dr, lr) | 0, ct = ct + Math.imul(Rt, ar) | 0, At = At + Math.imul(Rt, lr) | 0, yt = yt + Math.imul(Fr, xr) | 0, ct = ct + Math.imul(Fr, vr) | 0, ct = ct + Math.imul(Ar, xr) | 0, At = At + Math.imul(Ar, vr) | 0;
      var nn = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, yt = Math.imul($t, ar), ct = Math.imul($t, lr), ct = ct + Math.imul(Ut, ar) | 0, At = Math.imul(Ut, lr), yt = yt + Math.imul(Dr, xr) | 0, ct = ct + Math.imul(Dr, vr) | 0, ct = ct + Math.imul(Rt, xr) | 0, At = At + Math.imul(Rt, vr) | 0;
      var sn = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      st = (At + (ct >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, yt = Math.imul($t, xr), ct = Math.imul($t, vr), ct = ct + Math.imul(Ut, xr) | 0, At = Math.imul(Ut, vr);
      var on = (st + yt | 0) + ((ct & 8191) << 13) | 0;
      return st = (At + (ct >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, dt[0] = Rr, dt[1] = jr, dt[2] = Lr, dt[3] = Hr, dt[4] = Wr, dt[5] = Vr, dt[6] = Gr, dt[7] = qr, dt[8] = Xr, dt[9] = Yr, dt[10] = Jr, dt[11] = Qr, dt[12] = Zr, dt[13] = en, dt[14] = tn, dt[15] = rn, dt[16] = nn, dt[17] = sn, dt[18] = on, st !== 0 && (dt[19] = st, ot.length++), ot;
    };
    Math.imul || (bt = Mt);
    function Tt(rt, ce, Oe) {
      Oe.negative = ce.negative ^ rt.negative, Oe.length = rt.length + ce.length;
      for (var ot = 0, ut = 0, ht = 0; ht < Oe.length - 1; ht++) {
        var dt = ut;
        ut = 0;
        for (var st = ot & 67108863, yt = Math.min(ht, ce.length - 1), ct = Math.max(0, ht - rt.length + 1); ct <= yt; ct++) {
          var At = ht - ct, Kt = rt.words[At] | 0, Zt = ce.words[ct] | 0, Ht = Kt * Zt, Pt = Ht & 67108863;
          dt = dt + (Ht / 67108864 | 0) | 0, Pt = Pt + st | 0, st = Pt & 67108863, dt = dt + (Pt >>> 26) | 0, ut += dt >>> 26, dt &= 67108863;
        }
        Oe.words[ht] = st, ot = dt, dt = ut;
      }
      return ot !== 0 ? Oe.words[ht] = ot : Oe.length--, Oe._strip();
    }
    function It(rt, ce, Oe) {
      return Tt(rt, ce, Oe);
    }
    re.prototype.mulTo = function(ce, Oe) {
      var ot, ut = this.length + ce.length;
      return this.length === 10 && ce.length === 10 ? ot = bt(this, ce, Oe) : ut < 63 ? ot = Mt(this, ce, Oe) : ut < 1024 ? ot = Tt(this, ce, Oe) : ot = It(this, ce, Oe), ot;
    }, re.prototype.mul = function(ce) {
      var Oe = new re(null);
      return Oe.words = new Array(this.length + ce.length), this.mulTo(ce, Oe);
    }, re.prototype.mulf = function(ce) {
      var Oe = new re(null);
      return Oe.words = new Array(this.length + ce.length), It(this, ce, Oe);
    }, re.prototype.imul = function(ce) {
      return this.clone().mulTo(ce, this);
    }, re.prototype.imuln = function(ce) {
      var Oe = ce < 0;
      Oe && (ce = -ce), V(typeof ce == "number"), V(ce < 67108864);
      for (var ot = 0, ut = 0; ut < this.length; ut++) {
        var ht = (this.words[ut] | 0) * ce, dt = (ht & 67108863) + (ot & 67108863);
        ot >>= 26, ot += ht / 67108864 | 0, ot += dt >>> 26, this.words[ut] = dt & 67108863;
      }
      return ot !== 0 && (this.words[ut] = ot, this.length++), Oe ? this.ineg() : this;
    }, re.prototype.muln = function(ce) {
      return this.clone().imuln(ce);
    }, re.prototype.sqr = function() {
      return this.mul(this);
    }, re.prototype.isqr = function() {
      return this.imul(this.clone());
    }, re.prototype.pow = function(ce) {
      var Oe = xt(ce);
      if (Oe.length === 0) return new re(1);
      for (var ot = this, ut = 0; ut < Oe.length && Oe[ut] === 0; ut++, ot = ot.sqr())
        ;
      if (++ut < Oe.length)
        for (var ht = ot.sqr(); ut < Oe.length; ut++, ht = ht.sqr())
          Oe[ut] !== 0 && (ot = ot.mul(ht));
      return ot;
    }, re.prototype.iushln = function(ce) {
      V(typeof ce == "number" && ce >= 0);
      var Oe = ce % 26, ot = (ce - Oe) / 26, ut = 67108863 >>> 26 - Oe << 26 - Oe, ht;
      if (Oe !== 0) {
        var dt = 0;
        for (ht = 0; ht < this.length; ht++) {
          var st = this.words[ht] & ut, yt = (this.words[ht] | 0) - st << Oe;
          this.words[ht] = yt | dt, dt = st >>> 26 - Oe;
        }
        dt && (this.words[ht] = dt, this.length++);
      }
      if (ot !== 0) {
        for (ht = this.length - 1; ht >= 0; ht--)
          this.words[ht + ot] = this.words[ht];
        for (ht = 0; ht < ot; ht++)
          this.words[ht] = 0;
        this.length += ot;
      }
      return this._strip();
    }, re.prototype.ishln = function(ce) {
      return V(this.negative === 0), this.iushln(ce);
    }, re.prototype.iushrn = function(ce, Oe, ot) {
      V(typeof ce == "number" && ce >= 0);
      var ut;
      Oe ? ut = (Oe - Oe % 26) / 26 : ut = 0;
      var ht = ce % 26, dt = Math.min((ce - ht) / 26, this.length), st = 67108863 ^ 67108863 >>> ht << ht, yt = ot;
      if (ut -= dt, ut = Math.max(0, ut), yt) {
        for (var ct = 0; ct < dt; ct++)
          yt.words[ct] = this.words[ct];
        yt.length = dt;
      }
      if (dt !== 0) if (this.length > dt)
        for (this.length -= dt, ct = 0; ct < this.length; ct++)
          this.words[ct] = this.words[ct + dt];
      else
        this.words[0] = 0, this.length = 1;
      var At = 0;
      for (ct = this.length - 1; ct >= 0 && (At !== 0 || ct >= ut); ct--) {
        var Kt = this.words[ct] | 0;
        this.words[ct] = At << 26 - ht | Kt >>> ht, At = Kt & st;
      }
      return yt && At !== 0 && (yt.words[yt.length++] = At), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, re.prototype.ishrn = function(ce, Oe, ot) {
      return V(this.negative === 0), this.iushrn(ce, Oe, ot);
    }, re.prototype.shln = function(ce) {
      return this.clone().ishln(ce);
    }, re.prototype.ushln = function(ce) {
      return this.clone().iushln(ce);
    }, re.prototype.shrn = function(ce) {
      return this.clone().ishrn(ce);
    }, re.prototype.ushrn = function(ce) {
      return this.clone().iushrn(ce);
    }, re.prototype.testn = function(ce) {
      V(typeof ce == "number" && ce >= 0);
      var Oe = ce % 26, ot = (ce - Oe) / 26, ut = 1 << Oe;
      if (this.length <= ot) return !1;
      var ht = this.words[ot];
      return !!(ht & ut);
    }, re.prototype.imaskn = function(ce) {
      V(typeof ce == "number" && ce >= 0);
      var Oe = ce % 26, ot = (ce - Oe) / 26;
      if (V(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ot)
        return this;
      if (Oe !== 0 && ot++, this.length = Math.min(ot, this.length), Oe !== 0) {
        var ut = 67108863 ^ 67108863 >>> Oe << Oe;
        this.words[this.length - 1] &= ut;
      }
      return this._strip();
    }, re.prototype.maskn = function(ce) {
      return this.clone().imaskn(ce);
    }, re.prototype.iaddn = function(ce) {
      return V(typeof ce == "number"), V(ce < 67108864), ce < 0 ? this.isubn(-ce) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ce ? (this.words[0] = ce - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ce), this.negative = 1, this) : this._iaddn(ce);
    }, re.prototype._iaddn = function(ce) {
      this.words[0] += ce;
      for (var Oe = 0; Oe < this.length && this.words[Oe] >= 67108864; Oe++)
        this.words[Oe] -= 67108864, Oe === this.length - 1 ? this.words[Oe + 1] = 1 : this.words[Oe + 1]++;
      return this.length = Math.max(this.length, Oe + 1), this;
    }, re.prototype.isubn = function(ce) {
      if (V(typeof ce == "number"), V(ce < 67108864), ce < 0) return this.iaddn(-ce);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(ce), this.negative = 1, this;
      if (this.words[0] -= ce, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var Oe = 0; Oe < this.length && this.words[Oe] < 0; Oe++)
          this.words[Oe] += 67108864, this.words[Oe + 1] -= 1;
      return this._strip();
    }, re.prototype.addn = function(ce) {
      return this.clone().iaddn(ce);
    }, re.prototype.subn = function(ce) {
      return this.clone().isubn(ce);
    }, re.prototype.iabs = function() {
      return this.negative = 0, this;
    }, re.prototype.abs = function() {
      return this.clone().iabs();
    }, re.prototype._ishlnsubmul = function(ce, Oe, ot) {
      var ut = ce.length + ot, ht;
      this._expand(ut);
      var dt, st = 0;
      for (ht = 0; ht < ce.length; ht++) {
        dt = (this.words[ht + ot] | 0) + st;
        var yt = (ce.words[ht] | 0) * Oe;
        dt -= yt & 67108863, st = (dt >> 26) - (yt / 67108864 | 0), this.words[ht + ot] = dt & 67108863;
      }
      for (; ht < this.length - ot; ht++)
        dt = (this.words[ht + ot] | 0) + st, st = dt >> 26, this.words[ht + ot] = dt & 67108863;
      if (st === 0) return this._strip();
      for (V(st === -1), st = 0, ht = 0; ht < this.length; ht++)
        dt = -(this.words[ht] | 0) + st, st = dt >> 26, this.words[ht] = dt & 67108863;
      return this.negative = 1, this._strip();
    }, re.prototype._wordDiv = function(ce, Oe) {
      var ot = this.length - ce.length, ut = this.clone(), ht = ce, dt = ht.words[ht.length - 1] | 0, st = this._countBits(dt);
      ot = 26 - st, ot !== 0 && (ht = ht.ushln(ot), ut.iushln(ot), dt = ht.words[ht.length - 1] | 0);
      var yt = ut.length - ht.length, ct;
      if (Oe !== "mod") {
        ct = new re(null), ct.length = yt + 1, ct.words = new Array(ct.length);
        for (var At = 0; At < ct.length; At++)
          ct.words[At] = 0;
      }
      var Kt = ut.clone()._ishlnsubmul(ht, 1, yt);
      Kt.negative === 0 && (ut = Kt, ct && (ct.words[yt] = 1));
      for (var Zt = yt - 1; Zt >= 0; Zt--) {
        var Ht = (ut.words[ht.length + Zt] | 0) * 67108864 + (ut.words[ht.length + Zt - 1] | 0);
        for (Ht = Math.min(Ht / dt | 0, 67108863), ut._ishlnsubmul(ht, Ht, Zt); ut.negative !== 0; )
          Ht--, ut.negative = 0, ut._ishlnsubmul(ht, 1, Zt), ut.isZero() || (ut.negative ^= 1);
        ct && (ct.words[Zt] = Ht);
      }
      return ct && ct._strip(), ut._strip(), Oe !== "div" && ot !== 0 && ut.iushrn(ot), {
        div: ct || null,
        mod: ut
      };
    }, re.prototype.divmod = function(ce, Oe, ot) {
      if (V(!ce.isZero()), this.isZero())
        return {
          div: new re(0),
          mod: new re(0)
        };
      var ut, ht, dt;
      return this.negative !== 0 && ce.negative === 0 ? (dt = this.neg().divmod(ce, Oe), Oe !== "mod" && (ut = dt.div.neg()), Oe !== "div" && (ht = dt.mod.neg(), ot && ht.negative !== 0 && ht.iadd(ce)), {
        div: ut,
        mod: ht
      }) : this.negative === 0 && ce.negative !== 0 ? (dt = this.divmod(ce.neg(), Oe), Oe !== "mod" && (ut = dt.div.neg()), {
        div: ut,
        mod: dt.mod
      }) : this.negative & ce.negative ? (dt = this.neg().divmod(ce.neg(), Oe), Oe !== "div" && (ht = dt.mod.neg(), ot && ht.negative !== 0 && ht.isub(ce)), {
        div: dt.div,
        mod: ht
      }) : ce.length > this.length || this.cmp(ce) < 0 ? {
        div: new re(0),
        mod: this
      } : ce.length === 1 ? Oe === "div" ? {
        div: this.divn(ce.words[0]),
        mod: null
      } : Oe === "mod" ? {
        div: null,
        mod: new re(this.modrn(ce.words[0]))
      } : {
        div: this.divn(ce.words[0]),
        mod: new re(this.modrn(ce.words[0]))
      } : this._wordDiv(ce, Oe);
    }, re.prototype.div = function(ce) {
      return this.divmod(ce, "div", !1).div;
    }, re.prototype.mod = function(ce) {
      return this.divmod(ce, "mod", !1).mod;
    }, re.prototype.umod = function(ce) {
      return this.divmod(ce, "mod", !0).mod;
    }, re.prototype.divRound = function(ce) {
      var Oe = this.divmod(ce);
      if (Oe.mod.isZero()) return Oe.div;
      var ot = Oe.div.negative !== 0 ? Oe.mod.isub(ce) : Oe.mod, ut = ce.ushrn(1), ht = ce.andln(1), dt = ot.cmp(ut);
      return dt < 0 || ht === 1 && dt === 0 ? Oe.div : Oe.div.negative !== 0 ? Oe.div.isubn(1) : Oe.div.iaddn(1);
    }, re.prototype.modrn = function(ce) {
      var Oe = ce < 0;
      Oe && (ce = -ce), V(ce <= 67108863);
      for (var ot = (1 << 26) % ce, ut = 0, ht = this.length - 1; ht >= 0; ht--)
        ut = (ot * ut + (this.words[ht] | 0)) % ce;
      return Oe ? -ut : ut;
    }, re.prototype.modn = function(ce) {
      return this.modrn(ce);
    }, re.prototype.idivn = function(ce) {
      var Oe = ce < 0;
      Oe && (ce = -ce), V(ce <= 67108863);
      for (var ot = 0, ut = this.length - 1; ut >= 0; ut--) {
        var ht = (this.words[ut] | 0) + ot * 67108864;
        this.words[ut] = ht / ce | 0, ot = ht % ce;
      }
      return this._strip(), Oe ? this.ineg() : this;
    }, re.prototype.divn = function(ce) {
      return this.clone().idivn(ce);
    }, re.prototype.egcd = function(ce) {
      V(ce.negative === 0), V(!ce.isZero());
      var Oe = this, ot = ce.clone();
      Oe.negative !== 0 ? Oe = Oe.umod(ce) : Oe = Oe.clone();
      for (var ut = new re(1), ht = new re(0), dt = new re(0), st = new re(1), yt = 0; Oe.isEven() && ot.isEven(); )
        Oe.iushrn(1), ot.iushrn(1), ++yt;
      for (var ct = ot.clone(), At = Oe.clone(); !Oe.isZero(); ) {
        for (var Kt = 0, Zt = 1; !(Oe.words[0] & Zt) && Kt < 26; ++Kt, Zt <<= 1) ;
        if (Kt > 0)
          for (Oe.iushrn(Kt); Kt-- > 0; )
            (ut.isOdd() || ht.isOdd()) && (ut.iadd(ct), ht.isub(At)), ut.iushrn(1), ht.iushrn(1);
        for (var Ht = 0, Pt = 1; !(ot.words[0] & Pt) && Ht < 26; ++Ht, Pt <<= 1) ;
        if (Ht > 0)
          for (ot.iushrn(Ht); Ht-- > 0; )
            (dt.isOdd() || st.isOdd()) && (dt.iadd(ct), st.isub(At)), dt.iushrn(1), st.iushrn(1);
        Oe.cmp(ot) >= 0 ? (Oe.isub(ot), ut.isub(dt), ht.isub(st)) : (ot.isub(Oe), dt.isub(ut), st.isub(ht));
      }
      return {
        a: dt,
        b: st,
        gcd: ot.iushln(yt)
      };
    }, re.prototype._invmp = function(ce) {
      V(ce.negative === 0), V(!ce.isZero());
      var Oe = this, ot = ce.clone();
      Oe.negative !== 0 ? Oe = Oe.umod(ce) : Oe = Oe.clone();
      for (var ut = new re(1), ht = new re(0), dt = ot.clone(); Oe.cmpn(1) > 0 && ot.cmpn(1) > 0; ) {
        for (var st = 0, yt = 1; !(Oe.words[0] & yt) && st < 26; ++st, yt <<= 1) ;
        if (st > 0)
          for (Oe.iushrn(st); st-- > 0; )
            ut.isOdd() && ut.iadd(dt), ut.iushrn(1);
        for (var ct = 0, At = 1; !(ot.words[0] & At) && ct < 26; ++ct, At <<= 1) ;
        if (ct > 0)
          for (ot.iushrn(ct); ct-- > 0; )
            ht.isOdd() && ht.iadd(dt), ht.iushrn(1);
        Oe.cmp(ot) >= 0 ? (Oe.isub(ot), ut.isub(ht)) : (ot.isub(Oe), ht.isub(ut));
      }
      var Kt;
      return Oe.cmpn(1) === 0 ? Kt = ut : Kt = ht, Kt.cmpn(0) < 0 && Kt.iadd(ce), Kt;
    }, re.prototype.gcd = function(ce) {
      if (this.isZero()) return ce.abs();
      if (ce.isZero()) return this.abs();
      var Oe = this.clone(), ot = ce.clone();
      Oe.negative = 0, ot.negative = 0;
      for (var ut = 0; Oe.isEven() && ot.isEven(); ut++)
        Oe.iushrn(1), ot.iushrn(1);
      do {
        for (; Oe.isEven(); )
          Oe.iushrn(1);
        for (; ot.isEven(); )
          ot.iushrn(1);
        var ht = Oe.cmp(ot);
        if (ht < 0) {
          var dt = Oe;
          Oe = ot, ot = dt;
        } else if (ht === 0 || ot.cmpn(1) === 0)
          break;
        Oe.isub(ot);
      } while (!0);
      return ot.iushln(ut);
    }, re.prototype.invm = function(ce) {
      return this.egcd(ce).a.umod(ce);
    }, re.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, re.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, re.prototype.andln = function(ce) {
      return this.words[0] & ce;
    }, re.prototype.bincn = function(ce) {
      V(typeof ce == "number");
      var Oe = ce % 26, ot = (ce - Oe) / 26, ut = 1 << Oe;
      if (this.length <= ot)
        return this._expand(ot + 1), this.words[ot] |= ut, this;
      for (var ht = ut, dt = ot; ht !== 0 && dt < this.length; dt++) {
        var st = this.words[dt] | 0;
        st += ht, ht = st >>> 26, st &= 67108863, this.words[dt] = st;
      }
      return ht !== 0 && (this.words[dt] = ht, this.length++), this;
    }, re.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, re.prototype.cmpn = function(ce) {
      var Oe = ce < 0;
      if (this.negative !== 0 && !Oe) return -1;
      if (this.negative === 0 && Oe) return 1;
      this._strip();
      var ot;
      if (this.length > 1)
        ot = 1;
      else {
        Oe && (ce = -ce), V(ce <= 67108863, "Number is too big");
        var ut = this.words[0] | 0;
        ot = ut === ce ? 0 : ut < ce ? -1 : 1;
      }
      return this.negative !== 0 ? -ot | 0 : ot;
    }, re.prototype.cmp = function(ce) {
      if (this.negative !== 0 && ce.negative === 0) return -1;
      if (this.negative === 0 && ce.negative !== 0) return 1;
      var Oe = this.ucmp(ce);
      return this.negative !== 0 ? -Oe | 0 : Oe;
    }, re.prototype.ucmp = function(ce) {
      if (this.length > ce.length) return 1;
      if (this.length < ce.length) return -1;
      for (var Oe = 0, ot = this.length - 1; ot >= 0; ot--) {
        var ut = this.words[ot] | 0, ht = ce.words[ot] | 0;
        if (ut !== ht) {
          ut < ht ? Oe = -1 : ut > ht && (Oe = 1);
          break;
        }
      }
      return Oe;
    }, re.prototype.gtn = function(ce) {
      return this.cmpn(ce) === 1;
    }, re.prototype.gt = function(ce) {
      return this.cmp(ce) === 1;
    }, re.prototype.gten = function(ce) {
      return this.cmpn(ce) >= 0;
    }, re.prototype.gte = function(ce) {
      return this.cmp(ce) >= 0;
    }, re.prototype.ltn = function(ce) {
      return this.cmpn(ce) === -1;
    }, re.prototype.lt = function(ce) {
      return this.cmp(ce) === -1;
    }, re.prototype.lten = function(ce) {
      return this.cmpn(ce) <= 0;
    }, re.prototype.lte = function(ce) {
      return this.cmp(ce) <= 0;
    }, re.prototype.eqn = function(ce) {
      return this.cmpn(ce) === 0;
    }, re.prototype.eq = function(ce) {
      return this.cmp(ce) === 0;
    }, re.red = function(ce) {
      return new wt(ce);
    }, re.prototype.toRed = function(ce) {
      return V(!this.red, "Already a number in reduction context"), V(this.negative === 0, "red works only with positives"), ce.convertTo(this)._forceRed(ce);
    }, re.prototype.fromRed = function() {
      return V(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, re.prototype._forceRed = function(ce) {
      return this.red = ce, this;
    }, re.prototype.forceRed = function(ce) {
      return V(!this.red, "Already a number in reduction context"), this._forceRed(ce);
    }, re.prototype.redAdd = function(ce) {
      return V(this.red, "redAdd works only with red numbers"), this.red.add(this, ce);
    }, re.prototype.redIAdd = function(ce) {
      return V(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ce);
    }, re.prototype.redSub = function(ce) {
      return V(this.red, "redSub works only with red numbers"), this.red.sub(this, ce);
    }, re.prototype.redISub = function(ce) {
      return V(this.red, "redISub works only with red numbers"), this.red.isub(this, ce);
    }, re.prototype.redShl = function(ce) {
      return V(this.red, "redShl works only with red numbers"), this.red.shl(this, ce);
    }, re.prototype.redMul = function(ce) {
      return V(this.red, "redMul works only with red numbers"), this.red._verify2(this, ce), this.red.mul(this, ce);
    }, re.prototype.redIMul = function(ce) {
      return V(this.red, "redMul works only with red numbers"), this.red._verify2(this, ce), this.red.imul(this, ce);
    }, re.prototype.redSqr = function() {
      return V(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, re.prototype.redISqr = function() {
      return V(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, re.prototype.redSqrt = function() {
      return V(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, re.prototype.redInvm = function() {
      return V(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, re.prototype.redNeg = function() {
      return V(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, re.prototype.redPow = function(ce) {
      return V(this.red && !ce.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ce);
    };
    var qt = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Dt(rt, ce) {
      this.name = rt, this.p = new re(ce, 16), this.n = this.p.bitLength(), this.k = new re(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Dt.prototype._tmp = function() {
      var ce = new re(null);
      return ce.words = new Array(Math.ceil(this.n / 13)), ce;
    }, Dt.prototype.ireduce = function(ce) {
      var Oe = ce, ot;
      do
        this.split(Oe, this.tmp), Oe = this.imulK(Oe), Oe = Oe.iadd(this.tmp), ot = Oe.bitLength();
      while (ot > this.n);
      var ut = ot < this.n ? -1 : Oe.ucmp(this.p);
      return ut === 0 ? (Oe.words[0] = 0, Oe.length = 1) : ut > 0 ? Oe.isub(this.p) : Oe.strip !== void 0 ? Oe.strip() : Oe._strip(), Oe;
    }, Dt.prototype.split = function(ce, Oe) {
      ce.iushrn(this.n, 0, Oe);
    }, Dt.prototype.imulK = function(ce) {
      return ce.imul(this.k);
    };
    function Xt() {
      Dt.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    J(Xt, Dt), Xt.prototype.split = function(ce, Oe) {
      for (var ot = 4194303, ut = Math.min(ce.length, 9), ht = 0; ht < ut; ht++)
        Oe.words[ht] = ce.words[ht];
      if (Oe.length = ut, ce.length <= 9) {
        ce.words[0] = 0, ce.length = 1;
        return;
      }
      var dt = ce.words[9];
      for (Oe.words[Oe.length++] = dt & ot, ht = 10; ht < ce.length; ht++) {
        var st = ce.words[ht] | 0;
        ce.words[ht - 10] = (st & ot) << 4 | dt >>> 22, dt = st;
      }
      dt >>>= 22, ce.words[ht - 10] = dt, dt === 0 && ce.length > 10 ? ce.length -= 10 : ce.length -= 9;
    }, Xt.prototype.imulK = function(ce) {
      ce.words[ce.length] = 0, ce.words[ce.length + 1] = 0, ce.length += 2;
      for (var Oe = 0, ot = 0; ot < ce.length; ot++) {
        var ut = ce.words[ot] | 0;
        Oe += ut * 977, ce.words[ot] = Oe & 67108863, Oe = ut * 64 + (Oe / 67108864 | 0);
      }
      return ce.words[ce.length - 1] === 0 && (ce.length--, ce.words[ce.length - 1] === 0 && ce.length--), ce;
    };
    function Bt() {
      Dt.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    J(Bt, Dt);
    function mt() {
      Dt.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    J(mt, Dt);
    function Ot() {
      Dt.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    J(Ot, Dt), Ot.prototype.imulK = function(ce) {
      for (var Oe = 0, ot = 0; ot < ce.length; ot++) {
        var ut = (ce.words[ot] | 0) * 19 + Oe, ht = ut & 67108863;
        ut >>>= 26, ce.words[ot] = ht, Oe = ut;
      }
      return Oe !== 0 && (ce.words[ce.length++] = Oe), ce;
    }, re._prime = function(ce) {
      if (qt[ce]) return qt[ce];
      var Oe;
      if (ce === "k256")
        Oe = new Xt();
      else if (ce === "p224")
        Oe = new Bt();
      else if (ce === "p192")
        Oe = new mt();
      else if (ce === "p25519")
        Oe = new Ot();
      else
        throw new Error("Unknown prime " + ce);
      return qt[ce] = Oe, Oe;
    };
    function wt(rt) {
      if (typeof rt == "string") {
        var ce = re._prime(rt);
        this.m = ce.p, this.prime = ce;
      } else
        V(rt.gtn(1), "modulus must be greater than 1"), this.m = rt, this.prime = null;
    }
    wt.prototype._verify1 = function(ce) {
      V(ce.negative === 0, "red works only with positives"), V(ce.red, "red works only with red numbers");
    }, wt.prototype._verify2 = function(ce, Oe) {
      V((ce.negative | Oe.negative) === 0, "red works only with positives"), V(
        ce.red && ce.red === Oe.red,
        "red works only with red numbers"
      );
    }, wt.prototype.imod = function(ce) {
      return this.prime ? this.prime.ireduce(ce)._forceRed(this) : (oe(ce, ce.umod(this.m)._forceRed(this)), ce);
    }, wt.prototype.neg = function(ce) {
      return ce.isZero() ? ce.clone() : this.m.sub(ce)._forceRed(this);
    }, wt.prototype.add = function(ce, Oe) {
      this._verify2(ce, Oe);
      var ot = ce.add(Oe);
      return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot._forceRed(this);
    }, wt.prototype.iadd = function(ce, Oe) {
      this._verify2(ce, Oe);
      var ot = ce.iadd(Oe);
      return ot.cmp(this.m) >= 0 && ot.isub(this.m), ot;
    }, wt.prototype.sub = function(ce, Oe) {
      this._verify2(ce, Oe);
      var ot = ce.sub(Oe);
      return ot.cmpn(0) < 0 && ot.iadd(this.m), ot._forceRed(this);
    }, wt.prototype.isub = function(ce, Oe) {
      this._verify2(ce, Oe);
      var ot = ce.isub(Oe);
      return ot.cmpn(0) < 0 && ot.iadd(this.m), ot;
    }, wt.prototype.shl = function(ce, Oe) {
      return this._verify1(ce), this.imod(ce.ushln(Oe));
    }, wt.prototype.imul = function(ce, Oe) {
      return this._verify2(ce, Oe), this.imod(ce.imul(Oe));
    }, wt.prototype.mul = function(ce, Oe) {
      return this._verify2(ce, Oe), this.imod(ce.mul(Oe));
    }, wt.prototype.isqr = function(ce) {
      return this.imul(ce, ce.clone());
    }, wt.prototype.sqr = function(ce) {
      return this.mul(ce, ce);
    }, wt.prototype.sqrt = function(ce) {
      if (ce.isZero()) return ce.clone();
      var Oe = this.m.andln(3);
      if (V(Oe % 2 === 1), Oe === 3) {
        var ot = this.m.add(new re(1)).iushrn(2);
        return this.pow(ce, ot);
      }
      for (var ut = this.m.subn(1), ht = 0; !ut.isZero() && ut.andln(1) === 0; )
        ht++, ut.iushrn(1);
      V(!ut.isZero());
      var dt = new re(1).toRed(this), st = dt.redNeg(), yt = this.m.subn(1).iushrn(1), ct = this.m.bitLength();
      for (ct = new re(2 * ct * ct).toRed(this); this.pow(ct, yt).cmp(st) !== 0; )
        ct.redIAdd(st);
      for (var At = this.pow(ct, ut), Kt = this.pow(ce, ut.addn(1).iushrn(1)), Zt = this.pow(ce, ut), Ht = ht; Zt.cmp(dt) !== 0; ) {
        for (var Pt = Zt, kt = 0; Pt.cmp(dt) !== 0; kt++)
          Pt = Pt.redSqr();
        V(kt < Ht);
        var Vt = this.pow(At, new re(1).iushln(Ht - kt - 1));
        Kt = Kt.redMul(Vt), At = Vt.redSqr(), Zt = Zt.redMul(At), Ht = kt;
      }
      return Kt;
    }, wt.prototype.invm = function(ce) {
      var Oe = ce._invmp(this.m);
      return Oe.negative !== 0 ? (Oe.negative = 0, this.imod(Oe).redNeg()) : this.imod(Oe);
    }, wt.prototype.pow = function(ce, Oe) {
      if (Oe.isZero()) return new re(1).toRed(this);
      if (Oe.cmpn(1) === 0) return ce.clone();
      var ot = 4, ut = new Array(1 << ot);
      ut[0] = new re(1).toRed(this), ut[1] = ce;
      for (var ht = 2; ht < ut.length; ht++)
        ut[ht] = this.mul(ut[ht - 1], ce);
      var dt = ut[0], st = 0, yt = 0, ct = Oe.bitLength() % 26;
      for (ct === 0 && (ct = 26), ht = Oe.length - 1; ht >= 0; ht--) {
        for (var At = Oe.words[ht], Kt = ct - 1; Kt >= 0; Kt--) {
          var Zt = At >> Kt & 1;
          if (dt !== ut[0] && (dt = this.sqr(dt)), Zt === 0 && st === 0) {
            yt = 0;
            continue;
          }
          st <<= 1, st |= Zt, yt++, !(yt !== ot && (ht !== 0 || Kt !== 0)) && (dt = this.mul(dt, ut[st]), yt = 0, st = 0);
        }
        ct = 26;
      }
      return dt;
    }, wt.prototype.convertTo = function(ce) {
      var Oe = ce.umod(this.m);
      return Oe === ce ? Oe.clone() : Oe;
    }, wt.prototype.convertFrom = function(ce) {
      var Oe = ce.clone();
      return Oe.red = null, Oe;
    }, re.mont = function(ce) {
      return new ke(ce);
    };
    function ke(rt) {
      wt.call(this, rt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new re(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    J(ke, wt), ke.prototype.convertTo = function(ce) {
      return this.imod(ce.ushln(this.shift));
    }, ke.prototype.convertFrom = function(ce) {
      var Oe = this.imod(ce.mul(this.rinv));
      return Oe.red = null, Oe;
    }, ke.prototype.imul = function(ce, Oe) {
      if (ce.isZero() || Oe.isZero())
        return ce.words[0] = 0, ce.length = 1, ce;
      var ot = ce.imul(Oe), ut = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = ot.isub(ut).iushrn(this.shift), dt = ht;
      return ht.cmp(this.m) >= 0 ? dt = ht.isub(this.m) : ht.cmpn(0) < 0 && (dt = ht.iadd(this.m)), dt._forceRed(this);
    }, ke.prototype.mul = function(ce, Oe) {
      if (ce.isZero() || Oe.isZero()) return new re(0)._forceRed(this);
      var ot = ce.mul(Oe), ut = ot.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = ot.isub(ut).iushrn(this.shift), dt = ht;
      return ht.cmp(this.m) >= 0 ? dt = ht.isub(this.m) : ht.cmpn(0) < 0 && (dt = ht.iadd(this.m)), dt._forceRed(this);
    }, ke.prototype.invm = function(ce) {
      var Oe = this.imod(ce._invmp(this.m).mul(this.r2));
      return Oe._forceRed(this);
    };
  })(A, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$a = bnExports, randomBytes$1 = browserExports, Buffer$8 = safeBufferExports$1.Buffer;
function getr(A) {
  var B = A.modulus.byteLength(), L;
  do
    L = new BN$a(randomBytes$1(B));
  while (L.cmp(A.modulus) >= 0 || !L.umod(A.prime1) || !L.umod(A.prime2));
  return L;
}
function blind(A) {
  var B = getr(A), L = B.toRed(BN$a.mont(A.modulus)).redPow(new BN$a(A.publicExponent)).fromRed();
  return { blinder: L, unblinder: B.invm(A.modulus) };
}
function crt$2(A, B) {
  var L = blind(B), V = B.modulus.byteLength(), J = new BN$a(A).mul(L.blinder).umod(B.modulus), re = J.toRed(BN$a.mont(B.prime1)), ne = J.toRed(BN$a.mont(B.prime2)), ie = B.coefficient, pe = B.prime1, nt = B.prime2, oe = re.redPow(B.exponent1).fromRed(), Ce = ne.redPow(B.exponent2).fromRed(), at = oe.isub(Ce).imul(ie).umod(pe).imul(nt);
  return Ce.iadd(at).imul(L.unblinder).umod(B.modulus).toArrayLike(Buffer$8, "be", V);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$m = {}, utils$l = {};
(function(A) {
  var B = A;
  function L(re, ne) {
    if (Array.isArray(re))
      return re.slice();
    if (!re)
      return [];
    var ie = [];
    if (typeof re != "string") {
      for (var pe = 0; pe < re.length; pe++)
        ie[pe] = re[pe] | 0;
      return ie;
    }
    if (ne === "hex") {
      re = re.replace(/[^a-z0-9]+/ig, ""), re.length % 2 !== 0 && (re = "0" + re);
      for (var pe = 0; pe < re.length; pe += 2)
        ie.push(parseInt(re[pe] + re[pe + 1], 16));
    } else
      for (var pe = 0; pe < re.length; pe++) {
        var nt = re.charCodeAt(pe), oe = nt >> 8, Ce = nt & 255;
        oe ? ie.push(oe, Ce) : ie.push(Ce);
      }
    return ie;
  }
  B.toArray = L;
  function V(re) {
    return re.length === 1 ? "0" + re : re;
  }
  B.zero2 = V;
  function J(re) {
    for (var ne = "", ie = 0; ie < re.length; ie++)
      ne += V(re[ie].toString(16));
    return ne;
  }
  B.toHex = J, B.encode = function(ne, ie) {
    return ie === "hex" ? J(ne) : ne;
  };
})(utils$l);
(function(A) {
  var B = A, L = bnExports$1, V = minimalisticAssert, J = utils$l;
  B.assert = V, B.toArray = J.toArray, B.zero2 = J.zero2, B.toHex = J.toHex, B.encode = J.encode;
  function re(oe, Ce, at) {
    var it = new Array(Math.max(oe.bitLength(), at) + 1), gt;
    for (gt = 0; gt < it.length; gt += 1)
      it[gt] = 0;
    var St = 1 << Ce + 1, xt = oe.clone();
    for (gt = 0; gt < it.length; gt++) {
      var Mt, bt = xt.andln(St - 1);
      xt.isOdd() ? (bt > (St >> 1) - 1 ? Mt = (St >> 1) - bt : Mt = bt, xt.isubn(Mt)) : Mt = 0, it[gt] = Mt, xt.iushrn(1);
    }
    return it;
  }
  B.getNAF = re;
  function ne(oe, Ce) {
    var at = [
      [],
      []
    ];
    oe = oe.clone(), Ce = Ce.clone();
    for (var it = 0, gt = 0, St; oe.cmpn(-it) > 0 || Ce.cmpn(-gt) > 0; ) {
      var xt = oe.andln(3) + it & 3, Mt = Ce.andln(3) + gt & 3;
      xt === 3 && (xt = -1), Mt === 3 && (Mt = -1);
      var bt;
      xt & 1 ? (St = oe.andln(7) + it & 7, (St === 3 || St === 5) && Mt === 2 ? bt = -xt : bt = xt) : bt = 0, at[0].push(bt);
      var Tt;
      Mt & 1 ? (St = Ce.andln(7) + gt & 7, (St === 3 || St === 5) && xt === 2 ? Tt = -Mt : Tt = Mt) : Tt = 0, at[1].push(Tt), 2 * it === bt + 1 && (it = 1 - it), 2 * gt === Tt + 1 && (gt = 1 - gt), oe.iushrn(1), Ce.iushrn(1);
    }
    return at;
  }
  B.getJSF = ne;
  function ie(oe, Ce, at) {
    var it = "_" + Ce;
    oe.prototype[Ce] = function() {
      return this[it] !== void 0 ? this[it] : this[it] = at.call(this);
    };
  }
  B.cachedProperty = ie;
  function pe(oe) {
    return typeof oe == "string" ? B.toArray(oe, "hex") : oe;
  }
  B.parseBytes = pe;
  function nt(oe) {
    return new L(oe, "hex", "le");
  }
  B.intFromLE = nt;
})(utils$m);
var curve = {}, BN$9 = bnExports$1, utils$k = utils$m, getNAF = utils$k.getNAF, getJSF = utils$k.getJSF, assert$e = utils$k.assert;
function BaseCurve(A, B) {
  this.type = A, this.p = new BN$9(B.p, 16), this.red = B.prime ? BN$9.red(B.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = B.n && new BN$9(B.n, 16), this.g = B.g && this.pointFromJSON(B.g, B.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var L = this.n && this.p.div(this.n);
  !L || L.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$3 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(B, L) {
  assert$e(B.precomputed);
  var V = B._getDoubles(), J = getNAF(L, 1, this._bitLength), re = (1 << V.step + 1) - (V.step % 2 === 0 ? 2 : 1);
  re /= 3;
  var ne = [], ie, pe;
  for (ie = 0; ie < J.length; ie += V.step) {
    pe = 0;
    for (var nt = ie + V.step - 1; nt >= ie; nt--)
      pe = (pe << 1) + J[nt];
    ne.push(pe);
  }
  for (var oe = this.jpoint(null, null, null), Ce = this.jpoint(null, null, null), at = re; at > 0; at--) {
    for (ie = 0; ie < ne.length; ie++)
      pe = ne[ie], pe === at ? Ce = Ce.mixedAdd(V.points[ie]) : pe === -at && (Ce = Ce.mixedAdd(V.points[ie].neg()));
    oe = oe.add(Ce);
  }
  return oe.toP();
};
BaseCurve.prototype._wnafMul = function(B, L) {
  var V = 4, J = B._getNAFPoints(V);
  V = J.wnd;
  for (var re = J.points, ne = getNAF(L, V, this._bitLength), ie = this.jpoint(null, null, null), pe = ne.length - 1; pe >= 0; pe--) {
    for (var nt = 0; pe >= 0 && ne[pe] === 0; pe--)
      nt++;
    if (pe >= 0 && nt++, ie = ie.dblp(nt), pe < 0)
      break;
    var oe = ne[pe];
    assert$e(oe !== 0), B.type === "affine" ? oe > 0 ? ie = ie.mixedAdd(re[oe - 1 >> 1]) : ie = ie.mixedAdd(re[-oe - 1 >> 1].neg()) : oe > 0 ? ie = ie.add(re[oe - 1 >> 1]) : ie = ie.add(re[-oe - 1 >> 1].neg());
  }
  return B.type === "affine" ? ie.toP() : ie;
};
BaseCurve.prototype._wnafMulAdd = function(B, L, V, J, re) {
  var ne = this._wnafT1, ie = this._wnafT2, pe = this._wnafT3, nt = 0, oe, Ce, at;
  for (oe = 0; oe < J; oe++) {
    at = L[oe];
    var it = at._getNAFPoints(B);
    ne[oe] = it.wnd, ie[oe] = it.points;
  }
  for (oe = J - 1; oe >= 1; oe -= 2) {
    var gt = oe - 1, St = oe;
    if (ne[gt] !== 1 || ne[St] !== 1) {
      pe[gt] = getNAF(V[gt], ne[gt], this._bitLength), pe[St] = getNAF(V[St], ne[St], this._bitLength), nt = Math.max(pe[gt].length, nt), nt = Math.max(pe[St].length, nt);
      continue;
    }
    var xt = [
      L[gt],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      L[St]
      /* 7 */
    ];
    L[gt].y.cmp(L[St].y) === 0 ? (xt[1] = L[gt].add(L[St]), xt[2] = L[gt].toJ().mixedAdd(L[St].neg())) : L[gt].y.cmp(L[St].y.redNeg()) === 0 ? (xt[1] = L[gt].toJ().mixedAdd(L[St]), xt[2] = L[gt].add(L[St].neg())) : (xt[1] = L[gt].toJ().mixedAdd(L[St]), xt[2] = L[gt].toJ().mixedAdd(L[St].neg()));
    var Mt = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], bt = getJSF(V[gt], V[St]);
    for (nt = Math.max(bt[0].length, nt), pe[gt] = new Array(nt), pe[St] = new Array(nt), Ce = 0; Ce < nt; Ce++) {
      var Tt = bt[0][Ce] | 0, It = bt[1][Ce] | 0;
      pe[gt][Ce] = Mt[(Tt + 1) * 3 + (It + 1)], pe[St][Ce] = 0, ie[gt] = xt;
    }
  }
  var qt = this.jpoint(null, null, null), Dt = this._wnafT4;
  for (oe = nt; oe >= 0; oe--) {
    for (var Xt = 0; oe >= 0; ) {
      var Bt = !0;
      for (Ce = 0; Ce < J; Ce++)
        Dt[Ce] = pe[Ce][oe] | 0, Dt[Ce] !== 0 && (Bt = !1);
      if (!Bt)
        break;
      Xt++, oe--;
    }
    if (oe >= 0 && Xt++, qt = qt.dblp(Xt), oe < 0)
      break;
    for (Ce = 0; Ce < J; Ce++) {
      var mt = Dt[Ce];
      mt !== 0 && (mt > 0 ? at = ie[Ce][mt - 1 >> 1] : mt < 0 && (at = ie[Ce][-mt - 1 >> 1].neg()), at.type === "affine" ? qt = qt.mixedAdd(at) : qt = qt.add(at));
    }
  }
  for (oe = 0; oe < J; oe++)
    ie[oe] = null;
  return re ? qt : qt.toP();
};
function BasePoint(A, B) {
  this.curve = A, this.type = B, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(B, L) {
  B = utils$k.toArray(B, L);
  var V = this.p.byteLength();
  if ((B[0] === 4 || B[0] === 6 || B[0] === 7) && B.length - 1 === 2 * V) {
    B[0] === 6 ? assert$e(B[B.length - 1] % 2 === 0) : B[0] === 7 && assert$e(B[B.length - 1] % 2 === 1);
    var J = this.point(
      B.slice(1, 1 + V),
      B.slice(1 + V, 1 + 2 * V)
    );
    return J;
  } else if ((B[0] === 2 || B[0] === 3) && B.length - 1 === V)
    return this.pointFromX(B.slice(1, 1 + V), B[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(B) {
  return this.encode(B, !0);
};
BasePoint.prototype._encode = function(B) {
  var L = this.curve.p.byteLength(), V = this.getX().toArray("be", L);
  return B ? [this.getY().isEven() ? 2 : 3].concat(V) : [4].concat(V, this.getY().toArray("be", L));
};
BasePoint.prototype.encode = function(B, L) {
  return utils$k.encode(this._encode(L), B);
};
BasePoint.prototype.precompute = function(B) {
  if (this.precomputed)
    return this;
  var L = {
    doubles: null,
    naf: null,
    beta: null
  };
  return L.naf = this._getNAFPoints(8), L.doubles = this._getDoubles(4, B), L.beta = this._getBeta(), this.precomputed = L, this;
};
BasePoint.prototype._hasDoubles = function(B) {
  if (!this.precomputed)
    return !1;
  var L = this.precomputed.doubles;
  return L ? L.points.length >= Math.ceil((B.bitLength() + 1) / L.step) : !1;
};
BasePoint.prototype._getDoubles = function(B, L) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var V = [this], J = this, re = 0; re < L; re += B) {
    for (var ne = 0; ne < B; ne++)
      J = J.dbl();
    V.push(J);
  }
  return {
    step: B,
    points: V
  };
};
BasePoint.prototype._getNAFPoints = function(B) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var L = [this], V = (1 << B) - 1, J = V === 1 ? null : this.dbl(), re = 1; re < V; re++)
    L[re] = L[re - 1].add(J);
  return {
    wnd: B,
    points: L
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(B) {
  for (var L = this, V = 0; V < B; V++)
    L = L.dbl();
  return L;
};
var utils$j = utils$m, BN$8 = bnExports$1, inherits$4 = inherits_browserExports, Base$2 = base$3, assert$d = utils$j.assert;
function ShortCurve(A) {
  Base$2.call(this, "short", A), this.a = new BN$8(A.a, 16).toRed(this.red), this.b = new BN$8(A.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(A), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(B) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var L, V;
    if (B.beta)
      L = new BN$8(B.beta, 16).toRed(this.red);
    else {
      var J = this._getEndoRoots(this.p);
      L = J[0].cmp(J[1]) < 0 ? J[0] : J[1], L = L.toRed(this.red);
    }
    if (B.lambda)
      V = new BN$8(B.lambda, 16);
    else {
      var re = this._getEndoRoots(this.n);
      this.g.mul(re[0]).x.cmp(this.g.x.redMul(L)) === 0 ? V = re[0] : (V = re[1], assert$d(this.g.mul(V).x.cmp(this.g.x.redMul(L)) === 0));
    }
    var ne;
    return B.basis ? ne = B.basis.map(function(ie) {
      return {
        a: new BN$8(ie.a, 16),
        b: new BN$8(ie.b, 16)
      };
    }) : ne = this._getEndoBasis(V), {
      beta: L,
      lambda: V,
      basis: ne
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(B) {
  var L = B === this.p ? this.red : BN$8.mont(B), V = new BN$8(2).toRed(L).redInvm(), J = V.redNeg(), re = new BN$8(3).toRed(L).redNeg().redSqrt().redMul(V), ne = J.redAdd(re).fromRed(), ie = J.redSub(re).fromRed();
  return [ne, ie];
};
ShortCurve.prototype._getEndoBasis = function(B) {
  for (var L = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), V = B, J = this.n.clone(), re = new BN$8(1), ne = new BN$8(0), ie = new BN$8(0), pe = new BN$8(1), nt, oe, Ce, at, it, gt, St, xt = 0, Mt, bt; V.cmpn(0) !== 0; ) {
    var Tt = J.div(V);
    Mt = J.sub(Tt.mul(V)), bt = ie.sub(Tt.mul(re));
    var It = pe.sub(Tt.mul(ne));
    if (!Ce && Mt.cmp(L) < 0)
      nt = St.neg(), oe = re, Ce = Mt.neg(), at = bt;
    else if (Ce && ++xt === 2)
      break;
    St = Mt, J = V, V = Mt, ie = re, re = bt, pe = ne, ne = It;
  }
  it = Mt.neg(), gt = bt;
  var qt = Ce.sqr().add(at.sqr()), Dt = it.sqr().add(gt.sqr());
  return Dt.cmp(qt) >= 0 && (it = nt, gt = oe), Ce.negative && (Ce = Ce.neg(), at = at.neg()), it.negative && (it = it.neg(), gt = gt.neg()), [
    { a: Ce, b: at },
    { a: it, b: gt }
  ];
};
ShortCurve.prototype._endoSplit = function(B) {
  var L = this.endo.basis, V = L[0], J = L[1], re = J.b.mul(B).divRound(this.n), ne = V.b.neg().mul(B).divRound(this.n), ie = re.mul(V.a), pe = ne.mul(J.a), nt = re.mul(V.b), oe = ne.mul(J.b), Ce = B.sub(ie).sub(pe), at = nt.add(oe).neg();
  return { k1: Ce, k2: at };
};
ShortCurve.prototype.pointFromX = function(B, L) {
  B = new BN$8(B, 16), B.red || (B = B.toRed(this.red));
  var V = B.redSqr().redMul(B).redIAdd(B.redMul(this.a)).redIAdd(this.b), J = V.redSqrt();
  if (J.redSqr().redSub(V).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var re = J.fromRed().isOdd();
  return (L && !re || !L && re) && (J = J.redNeg()), this.point(B, J);
};
ShortCurve.prototype.validate = function(B) {
  if (B.inf)
    return !0;
  var L = B.x, V = B.y, J = this.a.redMul(L), re = L.redSqr().redMul(L).redIAdd(J).redIAdd(this.b);
  return V.redSqr().redISub(re).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(B, L, V) {
  for (var J = this._endoWnafT1, re = this._endoWnafT2, ne = 0; ne < B.length; ne++) {
    var ie = this._endoSplit(L[ne]), pe = B[ne], nt = pe._getBeta();
    ie.k1.negative && (ie.k1.ineg(), pe = pe.neg(!0)), ie.k2.negative && (ie.k2.ineg(), nt = nt.neg(!0)), J[ne * 2] = pe, J[ne * 2 + 1] = nt, re[ne * 2] = ie.k1, re[ne * 2 + 1] = ie.k2;
  }
  for (var oe = this._wnafMulAdd(1, J, re, ne * 2, V), Ce = 0; Ce < ne * 2; Ce++)
    J[Ce] = null, re[Ce] = null;
  return oe;
};
function Point$2(A, B, L, V) {
  Base$2.BasePoint.call(this, A, "affine"), B === null && L === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(B, 16), this.y = new BN$8(L, 16), V && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(B, L, V) {
  return new Point$2(this, B, L, V);
};
ShortCurve.prototype.pointFromJSON = function(B, L) {
  return Point$2.fromJSON(this, B, L);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var B = this.precomputed;
    if (B && B.beta)
      return B.beta;
    var L = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (B) {
      var V = this.curve, J = function(re) {
        return V.point(re.x.redMul(V.endo.beta), re.y);
      };
      B.beta = L, L.precomputed = {
        beta: null,
        naf: B.naf && {
          wnd: B.naf.wnd,
          points: B.naf.points.map(J)
        },
        doubles: B.doubles && {
          step: B.doubles.step,
          points: B.doubles.points.map(J)
        }
      };
    }
    return L;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(B, L, V) {
  typeof L == "string" && (L = JSON.parse(L));
  var J = B.point(L[0], L[1], V);
  if (!L[2])
    return J;
  function re(ie) {
    return B.point(ie[0], ie[1], V);
  }
  var ne = L[2];
  return J.precomputed = {
    beta: null,
    doubles: ne.doubles && {
      step: ne.doubles.step,
      points: [J].concat(ne.doubles.points.map(re))
    },
    naf: ne.naf && {
      wnd: ne.naf.wnd,
      points: [J].concat(ne.naf.points.map(re))
    }
  }, J;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(B) {
  if (this.inf)
    return B;
  if (B.inf)
    return this;
  if (this.eq(B))
    return this.dbl();
  if (this.neg().eq(B))
    return this.curve.point(null, null);
  if (this.x.cmp(B.x) === 0)
    return this.curve.point(null, null);
  var L = this.y.redSub(B.y);
  L.cmpn(0) !== 0 && (L = L.redMul(this.x.redSub(B.x).redInvm()));
  var V = L.redSqr().redISub(this.x).redISub(B.x), J = L.redMul(this.x.redSub(V)).redISub(this.y);
  return this.curve.point(V, J);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var B = this.y.redAdd(this.y);
  if (B.cmpn(0) === 0)
    return this.curve.point(null, null);
  var L = this.curve.a, V = this.x.redSqr(), J = B.redInvm(), re = V.redAdd(V).redIAdd(V).redIAdd(L).redMul(J), ne = re.redSqr().redISub(this.x.redAdd(this.x)), ie = re.redMul(this.x.redSub(ne)).redISub(this.y);
  return this.curve.point(ne, ie);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(B) {
  return B = new BN$8(B, 16), this.isInfinity() ? this : this._hasDoubles(B) ? this.curve._fixedNafMul(this, B) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [B]) : this.curve._wnafMul(this, B);
};
Point$2.prototype.mulAdd = function(B, L, V) {
  var J = [this, L], re = [B, V];
  return this.curve.endo ? this.curve._endoWnafMulAdd(J, re) : this.curve._wnafMulAdd(1, J, re, 2);
};
Point$2.prototype.jmulAdd = function(B, L, V) {
  var J = [this, L], re = [B, V];
  return this.curve.endo ? this.curve._endoWnafMulAdd(J, re, !0) : this.curve._wnafMulAdd(1, J, re, 2, !0);
};
Point$2.prototype.eq = function(B) {
  return this === B || this.inf === B.inf && (this.inf || this.x.cmp(B.x) === 0 && this.y.cmp(B.y) === 0);
};
Point$2.prototype.neg = function(B) {
  if (this.inf)
    return this;
  var L = this.curve.point(this.x, this.y.redNeg());
  if (B && this.precomputed) {
    var V = this.precomputed, J = function(re) {
      return re.neg();
    };
    L.precomputed = {
      naf: V.naf && {
        wnd: V.naf.wnd,
        points: V.naf.points.map(J)
      },
      doubles: V.doubles && {
        step: V.doubles.step,
        points: V.doubles.points.map(J)
      }
    };
  }
  return L;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var B = this.curve.jpoint(this.x, this.y, this.curve.one);
  return B;
};
function JPoint(A, B, L, V) {
  Base$2.BasePoint.call(this, A, "jacobian"), B === null && L === null && V === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(B, 16), this.y = new BN$8(L, 16), this.z = new BN$8(V, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(B, L, V) {
  return new JPoint(this, B, L, V);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var B = this.z.redInvm(), L = B.redSqr(), V = this.x.redMul(L), J = this.y.redMul(L).redMul(B);
  return this.curve.point(V, J);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(B) {
  if (this.isInfinity())
    return B;
  if (B.isInfinity())
    return this;
  var L = B.z.redSqr(), V = this.z.redSqr(), J = this.x.redMul(L), re = B.x.redMul(V), ne = this.y.redMul(L.redMul(B.z)), ie = B.y.redMul(V.redMul(this.z)), pe = J.redSub(re), nt = ne.redSub(ie);
  if (pe.cmpn(0) === 0)
    return nt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var oe = pe.redSqr(), Ce = oe.redMul(pe), at = J.redMul(oe), it = nt.redSqr().redIAdd(Ce).redISub(at).redISub(at), gt = nt.redMul(at.redISub(it)).redISub(ne.redMul(Ce)), St = this.z.redMul(B.z).redMul(pe);
  return this.curve.jpoint(it, gt, St);
};
JPoint.prototype.mixedAdd = function(B) {
  if (this.isInfinity())
    return B.toJ();
  if (B.isInfinity())
    return this;
  var L = this.z.redSqr(), V = this.x, J = B.x.redMul(L), re = this.y, ne = B.y.redMul(L).redMul(this.z), ie = V.redSub(J), pe = re.redSub(ne);
  if (ie.cmpn(0) === 0)
    return pe.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var nt = ie.redSqr(), oe = nt.redMul(ie), Ce = V.redMul(nt), at = pe.redSqr().redIAdd(oe).redISub(Ce).redISub(Ce), it = pe.redMul(Ce.redISub(at)).redISub(re.redMul(oe)), gt = this.z.redMul(ie);
  return this.curve.jpoint(at, it, gt);
};
JPoint.prototype.dblp = function(B) {
  if (B === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!B)
    return this.dbl();
  var L;
  if (this.curve.zeroA || this.curve.threeA) {
    var V = this;
    for (L = 0; L < B; L++)
      V = V.dbl();
    return V;
  }
  var J = this.curve.a, re = this.curve.tinv, ne = this.x, ie = this.y, pe = this.z, nt = pe.redSqr().redSqr(), oe = ie.redAdd(ie);
  for (L = 0; L < B; L++) {
    var Ce = ne.redSqr(), at = oe.redSqr(), it = at.redSqr(), gt = Ce.redAdd(Ce).redIAdd(Ce).redIAdd(J.redMul(nt)), St = ne.redMul(at), xt = gt.redSqr().redISub(St.redAdd(St)), Mt = St.redISub(xt), bt = gt.redMul(Mt);
    bt = bt.redIAdd(bt).redISub(it);
    var Tt = oe.redMul(pe);
    L + 1 < B && (nt = nt.redMul(it)), ne = xt, pe = Tt, oe = bt;
  }
  return this.curve.jpoint(ne, oe.redMul(re), pe);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var B, L, V;
  if (this.zOne) {
    var J = this.x.redSqr(), re = this.y.redSqr(), ne = re.redSqr(), ie = this.x.redAdd(re).redSqr().redISub(J).redISub(ne);
    ie = ie.redIAdd(ie);
    var pe = J.redAdd(J).redIAdd(J), nt = pe.redSqr().redISub(ie).redISub(ie), oe = ne.redIAdd(ne);
    oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), B = nt, L = pe.redMul(ie.redISub(nt)).redISub(oe), V = this.y.redAdd(this.y);
  } else {
    var Ce = this.x.redSqr(), at = this.y.redSqr(), it = at.redSqr(), gt = this.x.redAdd(at).redSqr().redISub(Ce).redISub(it);
    gt = gt.redIAdd(gt);
    var St = Ce.redAdd(Ce).redIAdd(Ce), xt = St.redSqr(), Mt = it.redIAdd(it);
    Mt = Mt.redIAdd(Mt), Mt = Mt.redIAdd(Mt), B = xt.redISub(gt).redISub(gt), L = St.redMul(gt.redISub(B)).redISub(Mt), V = this.y.redMul(this.z), V = V.redIAdd(V);
  }
  return this.curve.jpoint(B, L, V);
};
JPoint.prototype._threeDbl = function() {
  var B, L, V;
  if (this.zOne) {
    var J = this.x.redSqr(), re = this.y.redSqr(), ne = re.redSqr(), ie = this.x.redAdd(re).redSqr().redISub(J).redISub(ne);
    ie = ie.redIAdd(ie);
    var pe = J.redAdd(J).redIAdd(J).redIAdd(this.curve.a), nt = pe.redSqr().redISub(ie).redISub(ie);
    B = nt;
    var oe = ne.redIAdd(ne);
    oe = oe.redIAdd(oe), oe = oe.redIAdd(oe), L = pe.redMul(ie.redISub(nt)).redISub(oe), V = this.y.redAdd(this.y);
  } else {
    var Ce = this.z.redSqr(), at = this.y.redSqr(), it = this.x.redMul(at), gt = this.x.redSub(Ce).redMul(this.x.redAdd(Ce));
    gt = gt.redAdd(gt).redIAdd(gt);
    var St = it.redIAdd(it);
    St = St.redIAdd(St);
    var xt = St.redAdd(St);
    B = gt.redSqr().redISub(xt), V = this.y.redAdd(this.z).redSqr().redISub(at).redISub(Ce);
    var Mt = at.redSqr();
    Mt = Mt.redIAdd(Mt), Mt = Mt.redIAdd(Mt), Mt = Mt.redIAdd(Mt), L = gt.redMul(St.redISub(B)).redISub(Mt);
  }
  return this.curve.jpoint(B, L, V);
};
JPoint.prototype._dbl = function() {
  var B = this.curve.a, L = this.x, V = this.y, J = this.z, re = J.redSqr().redSqr(), ne = L.redSqr(), ie = V.redSqr(), pe = ne.redAdd(ne).redIAdd(ne).redIAdd(B.redMul(re)), nt = L.redAdd(L);
  nt = nt.redIAdd(nt);
  var oe = nt.redMul(ie), Ce = pe.redSqr().redISub(oe.redAdd(oe)), at = oe.redISub(Ce), it = ie.redSqr();
  it = it.redIAdd(it), it = it.redIAdd(it), it = it.redIAdd(it);
  var gt = pe.redMul(at).redISub(it), St = V.redAdd(V).redMul(J);
  return this.curve.jpoint(Ce, gt, St);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var B = this.x.redSqr(), L = this.y.redSqr(), V = this.z.redSqr(), J = L.redSqr(), re = B.redAdd(B).redIAdd(B), ne = re.redSqr(), ie = this.x.redAdd(L).redSqr().redISub(B).redISub(J);
  ie = ie.redIAdd(ie), ie = ie.redAdd(ie).redIAdd(ie), ie = ie.redISub(ne);
  var pe = ie.redSqr(), nt = J.redIAdd(J);
  nt = nt.redIAdd(nt), nt = nt.redIAdd(nt), nt = nt.redIAdd(nt);
  var oe = re.redIAdd(ie).redSqr().redISub(ne).redISub(pe).redISub(nt), Ce = L.redMul(oe);
  Ce = Ce.redIAdd(Ce), Ce = Ce.redIAdd(Ce);
  var at = this.x.redMul(pe).redISub(Ce);
  at = at.redIAdd(at), at = at.redIAdd(at);
  var it = this.y.redMul(oe.redMul(nt.redISub(oe)).redISub(ie.redMul(pe)));
  it = it.redIAdd(it), it = it.redIAdd(it), it = it.redIAdd(it);
  var gt = this.z.redAdd(ie).redSqr().redISub(V).redISub(pe);
  return this.curve.jpoint(at, it, gt);
};
JPoint.prototype.mul = function(B, L) {
  return B = new BN$8(B, L), this.curve._wnafMul(this, B);
};
JPoint.prototype.eq = function(B) {
  if (B.type === "affine")
    return this.eq(B.toJ());
  if (this === B)
    return !0;
  var L = this.z.redSqr(), V = B.z.redSqr();
  if (this.x.redMul(V).redISub(B.x.redMul(L)).cmpn(0) !== 0)
    return !1;
  var J = L.redMul(this.z), re = V.redMul(B.z);
  return this.y.redMul(re).redISub(B.y.redMul(J)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(B) {
  var L = this.z.redSqr(), V = B.toRed(this.curve.red).redMul(L);
  if (this.x.cmp(V) === 0)
    return !0;
  for (var J = B.clone(), re = this.curve.redN.redMul(L); ; ) {
    if (J.iadd(this.curve.n), J.cmp(this.curve.p) >= 0)
      return !1;
    if (V.redIAdd(re), this.x.cmp(V) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$1, inherits$3 = inherits_browserExports, Base$1 = base$3, utils$i = utils$m;
function MontCurve(A) {
  Base$1.call(this, "mont", A), this.a = new BN$7(A.a, 16).toRed(this.red), this.b = new BN$7(A.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(B) {
  var L = B.normalize().x, V = L.redSqr(), J = V.redMul(L).redAdd(V.redMul(this.a)).redAdd(L), re = J.redSqrt();
  return re.redSqr().cmp(J) === 0;
};
function Point$1(A, B, L) {
  Base$1.BasePoint.call(this, A, "projective"), B === null && L === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(B, 16), this.z = new BN$7(L, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(B, L) {
  return this.point(utils$i.toArray(B, L), 1);
};
MontCurve.prototype.point = function(B, L) {
  return new Point$1(this, B, L);
};
MontCurve.prototype.pointFromJSON = function(B) {
  return Point$1.fromJSON(this, B);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(B, L) {
  return new Point$1(B, L[0], L[1] || B.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var B = this.x.redAdd(this.z), L = B.redSqr(), V = this.x.redSub(this.z), J = V.redSqr(), re = L.redSub(J), ne = L.redMul(J), ie = re.redMul(J.redAdd(this.curve.a24.redMul(re)));
  return this.curve.point(ne, ie);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(B, L) {
  var V = this.x.redAdd(this.z), J = this.x.redSub(this.z), re = B.x.redAdd(B.z), ne = B.x.redSub(B.z), ie = ne.redMul(V), pe = re.redMul(J), nt = L.z.redMul(ie.redAdd(pe).redSqr()), oe = L.x.redMul(ie.redISub(pe).redSqr());
  return this.curve.point(nt, oe);
};
Point$1.prototype.mul = function(B) {
  for (var L = B.clone(), V = this, J = this.curve.point(null, null), re = this, ne = []; L.cmpn(0) !== 0; L.iushrn(1))
    ne.push(L.andln(1));
  for (var ie = ne.length - 1; ie >= 0; ie--)
    ne[ie] === 0 ? (V = V.diffAdd(J, re), J = J.dbl()) : (J = V.diffAdd(J, re), V = V.dbl());
  return J;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(B) {
  return this.getX().cmp(B.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$h = utils$m, BN$6 = bnExports$1, inherits$2 = inherits_browserExports, Base = base$3, assert$c = utils$h.assert;
function EdwardsCurve(A) {
  this.twisted = (A.a | 0) !== 1, this.mOneA = this.twisted && (A.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", A), this.a = new BN$6(A.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(A.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(A.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (A.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(B) {
  return this.mOneA ? B.redNeg() : this.a.redMul(B);
};
EdwardsCurve.prototype._mulC = function(B) {
  return this.oneC ? B : this.c.redMul(B);
};
EdwardsCurve.prototype.jpoint = function(B, L, V, J) {
  return this.point(B, L, V, J);
};
EdwardsCurve.prototype.pointFromX = function(B, L) {
  B = new BN$6(B, 16), B.red || (B = B.toRed(this.red));
  var V = B.redSqr(), J = this.c2.redSub(this.a.redMul(V)), re = this.one.redSub(this.c2.redMul(this.d).redMul(V)), ne = J.redMul(re.redInvm()), ie = ne.redSqrt();
  if (ie.redSqr().redSub(ne).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var pe = ie.fromRed().isOdd();
  return (L && !pe || !L && pe) && (ie = ie.redNeg()), this.point(B, ie);
};
EdwardsCurve.prototype.pointFromY = function(B, L) {
  B = new BN$6(B, 16), B.red || (B = B.toRed(this.red));
  var V = B.redSqr(), J = V.redSub(this.c2), re = V.redMul(this.d).redMul(this.c2).redSub(this.a), ne = J.redMul(re.redInvm());
  if (ne.cmp(this.zero) === 0) {
    if (L)
      throw new Error("invalid point");
    return this.point(this.zero, B);
  }
  var ie = ne.redSqrt();
  if (ie.redSqr().redSub(ne).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return ie.fromRed().isOdd() !== L && (ie = ie.redNeg()), this.point(ie, B);
};
EdwardsCurve.prototype.validate = function(B) {
  if (B.isInfinity())
    return !0;
  B.normalize();
  var L = B.x.redSqr(), V = B.y.redSqr(), J = L.redMul(this.a).redAdd(V), re = this.c2.redMul(this.one.redAdd(this.d.redMul(L).redMul(V)));
  return J.cmp(re) === 0;
};
function Point(A, B, L, V, J) {
  Base.BasePoint.call(this, A, "projective"), B === null && L === null && V === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(B, 16), this.y = new BN$6(L, 16), this.z = V ? new BN$6(V, 16) : this.curve.one, this.t = J && new BN$6(J, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(B) {
  return Point.fromJSON(this, B);
};
EdwardsCurve.prototype.point = function(B, L, V, J) {
  return new Point(this, B, L, V, J);
};
Point.fromJSON = function(B, L) {
  return new Point(B, L[0], L[1], L[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var B = this.x.redSqr(), L = this.y.redSqr(), V = this.z.redSqr();
  V = V.redIAdd(V);
  var J = this.curve._mulA(B), re = this.x.redAdd(this.y).redSqr().redISub(B).redISub(L), ne = J.redAdd(L), ie = ne.redSub(V), pe = J.redSub(L), nt = re.redMul(ie), oe = ne.redMul(pe), Ce = re.redMul(pe), at = ie.redMul(ne);
  return this.curve.point(nt, oe, at, Ce);
};
Point.prototype._projDbl = function() {
  var B = this.x.redAdd(this.y).redSqr(), L = this.x.redSqr(), V = this.y.redSqr(), J, re, ne, ie, pe, nt;
  if (this.curve.twisted) {
    ie = this.curve._mulA(L);
    var oe = ie.redAdd(V);
    this.zOne ? (J = B.redSub(L).redSub(V).redMul(oe.redSub(this.curve.two)), re = oe.redMul(ie.redSub(V)), ne = oe.redSqr().redSub(oe).redSub(oe)) : (pe = this.z.redSqr(), nt = oe.redSub(pe).redISub(pe), J = B.redSub(L).redISub(V).redMul(nt), re = oe.redMul(ie.redSub(V)), ne = oe.redMul(nt));
  } else
    ie = L.redAdd(V), pe = this.curve._mulC(this.z).redSqr(), nt = ie.redSub(pe).redSub(pe), J = this.curve._mulC(B.redISub(ie)).redMul(nt), re = this.curve._mulC(ie).redMul(L.redISub(V)), ne = ie.redMul(nt);
  return this.curve.point(J, re, ne);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(B) {
  var L = this.y.redSub(this.x).redMul(B.y.redSub(B.x)), V = this.y.redAdd(this.x).redMul(B.y.redAdd(B.x)), J = this.t.redMul(this.curve.dd).redMul(B.t), re = this.z.redMul(B.z.redAdd(B.z)), ne = V.redSub(L), ie = re.redSub(J), pe = re.redAdd(J), nt = V.redAdd(L), oe = ne.redMul(ie), Ce = pe.redMul(nt), at = ne.redMul(nt), it = ie.redMul(pe);
  return this.curve.point(oe, Ce, it, at);
};
Point.prototype._projAdd = function(B) {
  var L = this.z.redMul(B.z), V = L.redSqr(), J = this.x.redMul(B.x), re = this.y.redMul(B.y), ne = this.curve.d.redMul(J).redMul(re), ie = V.redSub(ne), pe = V.redAdd(ne), nt = this.x.redAdd(this.y).redMul(B.x.redAdd(B.y)).redISub(J).redISub(re), oe = L.redMul(ie).redMul(nt), Ce, at;
  return this.curve.twisted ? (Ce = L.redMul(pe).redMul(re.redSub(this.curve._mulA(J))), at = ie.redMul(pe)) : (Ce = L.redMul(pe).redMul(re.redSub(J)), at = this.curve._mulC(ie).redMul(pe)), this.curve.point(oe, Ce, at);
};
Point.prototype.add = function(B) {
  return this.isInfinity() ? B : B.isInfinity() ? this : this.curve.extended ? this._extAdd(B) : this._projAdd(B);
};
Point.prototype.mul = function(B) {
  return this._hasDoubles(B) ? this.curve._fixedNafMul(this, B) : this.curve._wnafMul(this, B);
};
Point.prototype.mulAdd = function(B, L, V) {
  return this.curve._wnafMulAdd(1, [this, L], [B, V], 2, !1);
};
Point.prototype.jmulAdd = function(B, L, V) {
  return this.curve._wnafMulAdd(1, [this, L], [B, V], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var B = this.z.redInvm();
  return this.x = this.x.redMul(B), this.y = this.y.redMul(B), this.t && (this.t = this.t.redMul(B)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(B) {
  return this === B || this.getX().cmp(B.getX()) === 0 && this.getY().cmp(B.getY()) === 0;
};
Point.prototype.eqXToP = function(B) {
  var L = B.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(L) === 0)
    return !0;
  for (var V = B.clone(), J = this.curve.redN.redMul(this.z); ; ) {
    if (V.iadd(this.curve.n), V.cmp(this.curve.p) >= 0)
      return !1;
    if (L.redIAdd(J), this.x.cmp(L) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(A) {
  var B = A;
  B.base = base$3, B.short = short, B.mont = mont, B.edwards = edwards;
})(curve);
var curves$1 = {}, hash$2 = {}, utils$g = {}, assert$b = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$g.inherits = inherits$1;
function isSurrogatePair(A, B) {
  return (A.charCodeAt(B) & 64512) !== 55296 || B < 0 || B + 1 >= A.length ? !1 : (A.charCodeAt(B + 1) & 64512) === 56320;
}
function toArray(A, B) {
  if (Array.isArray(A))
    return A.slice();
  if (!A)
    return [];
  var L = [];
  if (typeof A == "string")
    if (B) {
      if (B === "hex")
        for (A = A.replace(/[^a-z0-9]+/ig, ""), A.length % 2 !== 0 && (A = "0" + A), J = 0; J < A.length; J += 2)
          L.push(parseInt(A[J] + A[J + 1], 16));
    } else for (var V = 0, J = 0; J < A.length; J++) {
      var re = A.charCodeAt(J);
      re < 128 ? L[V++] = re : re < 2048 ? (L[V++] = re >> 6 | 192, L[V++] = re & 63 | 128) : isSurrogatePair(A, J) ? (re = 65536 + ((re & 1023) << 10) + (A.charCodeAt(++J) & 1023), L[V++] = re >> 18 | 240, L[V++] = re >> 12 & 63 | 128, L[V++] = re >> 6 & 63 | 128, L[V++] = re & 63 | 128) : (L[V++] = re >> 12 | 224, L[V++] = re >> 6 & 63 | 128, L[V++] = re & 63 | 128);
    }
  else
    for (J = 0; J < A.length; J++)
      L[J] = A[J] | 0;
  return L;
}
utils$g.toArray = toArray;
function toHex(A) {
  for (var B = "", L = 0; L < A.length; L++)
    B += zero2(A[L].toString(16));
  return B;
}
utils$g.toHex = toHex;
function htonl(A) {
  var B = A >>> 24 | A >>> 8 & 65280 | A << 8 & 16711680 | (A & 255) << 24;
  return B >>> 0;
}
utils$g.htonl = htonl;
function toHex32(A, B) {
  for (var L = "", V = 0; V < A.length; V++) {
    var J = A[V];
    B === "little" && (J = htonl(J)), L += zero8(J.toString(16));
  }
  return L;
}
utils$g.toHex32 = toHex32;
function zero2(A) {
  return A.length === 1 ? "0" + A : A;
}
utils$g.zero2 = zero2;
function zero8(A) {
  return A.length === 7 ? "0" + A : A.length === 6 ? "00" + A : A.length === 5 ? "000" + A : A.length === 4 ? "0000" + A : A.length === 3 ? "00000" + A : A.length === 2 ? "000000" + A : A.length === 1 ? "0000000" + A : A;
}
utils$g.zero8 = zero8;
function join32(A, B, L, V) {
  var J = L - B;
  assert$b(J % 4 === 0);
  for (var re = new Array(J / 4), ne = 0, ie = B; ne < re.length; ne++, ie += 4) {
    var pe;
    V === "big" ? pe = A[ie] << 24 | A[ie + 1] << 16 | A[ie + 2] << 8 | A[ie + 3] : pe = A[ie + 3] << 24 | A[ie + 2] << 16 | A[ie + 1] << 8 | A[ie], re[ne] = pe >>> 0;
  }
  return re;
}
utils$g.join32 = join32;
function split32(A, B) {
  for (var L = new Array(A.length * 4), V = 0, J = 0; V < A.length; V++, J += 4) {
    var re = A[V];
    B === "big" ? (L[J] = re >>> 24, L[J + 1] = re >>> 16 & 255, L[J + 2] = re >>> 8 & 255, L[J + 3] = re & 255) : (L[J + 3] = re >>> 24, L[J + 2] = re >>> 16 & 255, L[J + 1] = re >>> 8 & 255, L[J] = re & 255);
  }
  return L;
}
utils$g.split32 = split32;
function rotr32$1(A, B) {
  return A >>> B | A << 32 - B;
}
utils$g.rotr32 = rotr32$1;
function rotl32$2(A, B) {
  return A << B | A >>> 32 - B;
}
utils$g.rotl32 = rotl32$2;
function sum32$3(A, B) {
  return A + B >>> 0;
}
utils$g.sum32 = sum32$3;
function sum32_3$1(A, B, L) {
  return A + B + L >>> 0;
}
utils$g.sum32_3 = sum32_3$1;
function sum32_4$2(A, B, L, V) {
  return A + B + L + V >>> 0;
}
utils$g.sum32_4 = sum32_4$2;
function sum32_5$2(A, B, L, V, J) {
  return A + B + L + V + J >>> 0;
}
utils$g.sum32_5 = sum32_5$2;
function sum64$1(A, B, L, V) {
  var J = A[B], re = A[B + 1], ne = V + re >>> 0, ie = (ne < V ? 1 : 0) + L + J;
  A[B] = ie >>> 0, A[B + 1] = ne;
}
utils$g.sum64 = sum64$1;
function sum64_hi$1(A, B, L, V) {
  var J = B + V >>> 0, re = (J < B ? 1 : 0) + A + L;
  return re >>> 0;
}
utils$g.sum64_hi = sum64_hi$1;
function sum64_lo$1(A, B, L, V) {
  var J = B + V;
  return J >>> 0;
}
utils$g.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(A, B, L, V, J, re, ne, ie) {
  var pe = 0, nt = B;
  nt = nt + V >>> 0, pe += nt < B ? 1 : 0, nt = nt + re >>> 0, pe += nt < re ? 1 : 0, nt = nt + ie >>> 0, pe += nt < ie ? 1 : 0;
  var oe = A + L + J + ne + pe;
  return oe >>> 0;
}
utils$g.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(A, B, L, V, J, re, ne, ie) {
  var pe = B + V + re + ie;
  return pe >>> 0;
}
utils$g.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(A, B, L, V, J, re, ne, ie, pe, nt) {
  var oe = 0, Ce = B;
  Ce = Ce + V >>> 0, oe += Ce < B ? 1 : 0, Ce = Ce + re >>> 0, oe += Ce < re ? 1 : 0, Ce = Ce + ie >>> 0, oe += Ce < ie ? 1 : 0, Ce = Ce + nt >>> 0, oe += Ce < nt ? 1 : 0;
  var at = A + L + J + ne + pe + oe;
  return at >>> 0;
}
utils$g.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(A, B, L, V, J, re, ne, ie, pe, nt) {
  var oe = B + V + re + ie + nt;
  return oe >>> 0;
}
utils$g.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(A, B, L) {
  var V = B << 32 - L | A >>> L;
  return V >>> 0;
}
utils$g.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(A, B, L) {
  var V = A << 32 - L | B >>> L;
  return V >>> 0;
}
utils$g.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(A, B, L) {
  return A >>> L;
}
utils$g.shr64_hi = shr64_hi$1;
function shr64_lo$1(A, B, L) {
  var V = A << 32 - L | B >>> L;
  return V >>> 0;
}
utils$g.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$f = utils$g, assert$a = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(B, L) {
  if (B = utils$f.toArray(B, L), this.pending ? this.pending = this.pending.concat(B) : this.pending = B, this.pendingTotal += B.length, this.pending.length >= this._delta8) {
    B = this.pending;
    var V = B.length % this._delta8;
    this.pending = B.slice(B.length - V, B.length), this.pending.length === 0 && (this.pending = null), B = utils$f.join32(B, 0, B.length - V, this.endian);
    for (var J = 0; J < B.length; J += this._delta32)
      this._update(B, J, J + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(B) {
  return this.update(this._pad()), assert$a(this.pending === null), this._digest(B);
};
BlockHash$4.prototype._pad = function() {
  var B = this.pendingTotal, L = this._delta8, V = L - (B + this.padLength) % L, J = new Array(V + this.padLength);
  J[0] = 128;
  for (var re = 1; re < V; re++)
    J[re] = 0;
  if (B <<= 3, this.endian === "big") {
    for (var ne = 8; ne < this.padLength; ne++)
      J[re++] = 0;
    J[re++] = 0, J[re++] = 0, J[re++] = 0, J[re++] = 0, J[re++] = B >>> 24 & 255, J[re++] = B >>> 16 & 255, J[re++] = B >>> 8 & 255, J[re++] = B & 255;
  } else
    for (J[re++] = B & 255, J[re++] = B >>> 8 & 255, J[re++] = B >>> 16 & 255, J[re++] = B >>> 24 & 255, J[re++] = 0, J[re++] = 0, J[re++] = 0, J[re++] = 0, ne = 8; ne < this.padLength; ne++)
      J[re++] = 0;
  return J;
};
var sha = {}, common$4 = {}, utils$e = utils$g, rotr32 = utils$e.rotr32;
function ft_1$1(A, B, L, V) {
  if (A === 0)
    return ch32$1(B, L, V);
  if (A === 1 || A === 3)
    return p32(B, L, V);
  if (A === 2)
    return maj32$1(B, L, V);
}
common$4.ft_1 = ft_1$1;
function ch32$1(A, B, L) {
  return A & B ^ ~A & L;
}
common$4.ch32 = ch32$1;
function maj32$1(A, B, L) {
  return A & B ^ A & L ^ B & L;
}
common$4.maj32 = maj32$1;
function p32(A, B, L) {
  return A ^ B ^ L;
}
common$4.p32 = p32;
function s0_256$1(A) {
  return rotr32(A, 2) ^ rotr32(A, 13) ^ rotr32(A, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(A) {
  return rotr32(A, 6) ^ rotr32(A, 11) ^ rotr32(A, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(A) {
  return rotr32(A, 7) ^ rotr32(A, 18) ^ A >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(A) {
  return rotr32(A, 17) ^ rotr32(A, 19) ^ A >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$d = utils$g, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$d.rotl32, sum32$2 = utils$d.sum32, sum32_5$1 = utils$d.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1$1() {
  if (!(this instanceof SHA1$1))
    return new SHA1$1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$d.inherits(SHA1$1, BlockHash$3);
var _1 = SHA1$1;
SHA1$1.blockSize = 512;
SHA1$1.outSize = 160;
SHA1$1.hmacStrength = 80;
SHA1$1.padLength = 64;
SHA1$1.prototype._update = function(B, L) {
  for (var V = this.W, J = 0; J < 16; J++)
    V[J] = B[L + J];
  for (; J < V.length; J++)
    V[J] = rotl32$1(V[J - 3] ^ V[J - 8] ^ V[J - 14] ^ V[J - 16], 1);
  var re = this.h[0], ne = this.h[1], ie = this.h[2], pe = this.h[3], nt = this.h[4];
  for (J = 0; J < V.length; J++) {
    var oe = ~~(J / 20), Ce = sum32_5$1(rotl32$1(re, 5), ft_1(oe, ne, ie, pe), nt, V[J], sha1_K[oe]);
    nt = pe, pe = ie, ie = rotl32$1(ne, 30), ne = re, re = Ce;
  }
  this.h[0] = sum32$2(this.h[0], re), this.h[1] = sum32$2(this.h[1], ne), this.h[2] = sum32$2(this.h[2], ie), this.h[3] = sum32$2(this.h[3], pe), this.h[4] = sum32$2(this.h[4], nt);
};
SHA1$1.prototype._digest = function(B) {
  return B === "hex" ? utils$d.toHex32(this.h, "big") : utils$d.split32(this.h, "big");
};
var utils$c = utils$g, common$2 = common$5, shaCommon = common$4, assert$9 = minimalisticAssert, sum32$1 = utils$c.sum32, sum32_4$1 = utils$c.sum32_4, sum32_5 = utils$c.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$c.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(B, L) {
  for (var V = this.W, J = 0; J < 16; J++)
    V[J] = B[L + J];
  for (; J < V.length; J++)
    V[J] = sum32_4$1(g1_256(V[J - 2]), V[J - 7], g0_256(V[J - 15]), V[J - 16]);
  var re = this.h[0], ne = this.h[1], ie = this.h[2], pe = this.h[3], nt = this.h[4], oe = this.h[5], Ce = this.h[6], at = this.h[7];
  for (assert$9(this.k.length === V.length), J = 0; J < V.length; J++) {
    var it = sum32_5(at, s1_256(nt), ch32(nt, oe, Ce), this.k[J], V[J]), gt = sum32$1(s0_256(re), maj32(re, ne, ie));
    at = Ce, Ce = oe, oe = nt, nt = sum32$1(pe, it), pe = ie, ie = ne, ne = re, re = sum32$1(it, gt);
  }
  this.h[0] = sum32$1(this.h[0], re), this.h[1] = sum32$1(this.h[1], ne), this.h[2] = sum32$1(this.h[2], ie), this.h[3] = sum32$1(this.h[3], pe), this.h[4] = sum32$1(this.h[4], nt), this.h[5] = sum32$1(this.h[5], oe), this.h[6] = sum32$1(this.h[6], Ce), this.h[7] = sum32$1(this.h[7], at);
};
SHA256$1.prototype._digest = function(B) {
  return B === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$g, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$b.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(B) {
  return B === "hex" ? utils$b.toHex32(this.h.slice(0, 7), "big") : utils$b.split32(this.h.slice(0, 7), "big");
};
var utils$a = utils$g, common$1 = common$5, assert$8 = minimalisticAssert, rotr64_hi = utils$a.rotr64_hi, rotr64_lo = utils$a.rotr64_lo, shr64_hi = utils$a.shr64_hi, shr64_lo = utils$a.shr64_lo, sum64 = utils$a.sum64, sum64_hi = utils$a.sum64_hi, sum64_lo = utils$a.sum64_lo, sum64_4_hi = utils$a.sum64_4_hi, sum64_4_lo = utils$a.sum64_4_lo, sum64_5_hi = utils$a.sum64_5_hi, sum64_5_lo = utils$a.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$a.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(B, L) {
  for (var V = this.W, J = 0; J < 32; J++)
    V[J] = B[L + J];
  for (; J < V.length; J += 2) {
    var re = g1_512_hi(V[J - 4], V[J - 3]), ne = g1_512_lo(V[J - 4], V[J - 3]), ie = V[J - 14], pe = V[J - 13], nt = g0_512_hi(V[J - 30], V[J - 29]), oe = g0_512_lo(V[J - 30], V[J - 29]), Ce = V[J - 32], at = V[J - 31];
    V[J] = sum64_4_hi(
      re,
      ne,
      ie,
      pe,
      nt,
      oe,
      Ce,
      at
    ), V[J + 1] = sum64_4_lo(
      re,
      ne,
      ie,
      pe,
      nt,
      oe,
      Ce,
      at
    );
  }
};
SHA512$1.prototype._update = function(B, L) {
  this._prepareBlock(B, L);
  var V = this.W, J = this.h[0], re = this.h[1], ne = this.h[2], ie = this.h[3], pe = this.h[4], nt = this.h[5], oe = this.h[6], Ce = this.h[7], at = this.h[8], it = this.h[9], gt = this.h[10], St = this.h[11], xt = this.h[12], Mt = this.h[13], bt = this.h[14], Tt = this.h[15];
  assert$8(this.k.length === V.length);
  for (var It = 0; It < V.length; It += 2) {
    var qt = bt, Dt = Tt, Xt = s1_512_hi(at, it), Bt = s1_512_lo(at, it), mt = ch64_hi(at, it, gt, St, xt), Ot = ch64_lo(at, it, gt, St, xt, Mt), wt = this.k[It], ke = this.k[It + 1], rt = V[It], ce = V[It + 1], Oe = sum64_5_hi(
      qt,
      Dt,
      Xt,
      Bt,
      mt,
      Ot,
      wt,
      ke,
      rt,
      ce
    ), ot = sum64_5_lo(
      qt,
      Dt,
      Xt,
      Bt,
      mt,
      Ot,
      wt,
      ke,
      rt,
      ce
    );
    qt = s0_512_hi(J, re), Dt = s0_512_lo(J, re), Xt = maj64_hi(J, re, ne, ie, pe), Bt = maj64_lo(J, re, ne, ie, pe, nt);
    var ut = sum64_hi(qt, Dt, Xt, Bt), ht = sum64_lo(qt, Dt, Xt, Bt);
    bt = xt, Tt = Mt, xt = gt, Mt = St, gt = at, St = it, at = sum64_hi(oe, Ce, Oe, ot), it = sum64_lo(Ce, Ce, Oe, ot), oe = pe, Ce = nt, pe = ne, nt = ie, ne = J, ie = re, J = sum64_hi(Oe, ot, ut, ht), re = sum64_lo(Oe, ot, ut, ht);
  }
  sum64(this.h, 0, J, re), sum64(this.h, 2, ne, ie), sum64(this.h, 4, pe, nt), sum64(this.h, 6, oe, Ce), sum64(this.h, 8, at, it), sum64(this.h, 10, gt, St), sum64(this.h, 12, xt, Mt), sum64(this.h, 14, bt, Tt);
};
SHA512$1.prototype._digest = function(B) {
  return B === "hex" ? utils$a.toHex32(this.h, "big") : utils$a.split32(this.h, "big");
};
function ch64_hi(A, B, L, V, J) {
  var re = A & L ^ ~A & J;
  return re < 0 && (re += 4294967296), re;
}
function ch64_lo(A, B, L, V, J, re) {
  var ne = B & V ^ ~B & re;
  return ne < 0 && (ne += 4294967296), ne;
}
function maj64_hi(A, B, L, V, J) {
  var re = A & L ^ A & J ^ L & J;
  return re < 0 && (re += 4294967296), re;
}
function maj64_lo(A, B, L, V, J, re) {
  var ne = B & V ^ B & re ^ V & re;
  return ne < 0 && (ne += 4294967296), ne;
}
function s0_512_hi(A, B) {
  var L = rotr64_hi(A, B, 28), V = rotr64_hi(B, A, 2), J = rotr64_hi(B, A, 7), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function s0_512_lo(A, B) {
  var L = rotr64_lo(A, B, 28), V = rotr64_lo(B, A, 2), J = rotr64_lo(B, A, 7), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function s1_512_hi(A, B) {
  var L = rotr64_hi(A, B, 14), V = rotr64_hi(A, B, 18), J = rotr64_hi(B, A, 9), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function s1_512_lo(A, B) {
  var L = rotr64_lo(A, B, 14), V = rotr64_lo(A, B, 18), J = rotr64_lo(B, A, 9), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function g0_512_hi(A, B) {
  var L = rotr64_hi(A, B, 1), V = rotr64_hi(A, B, 8), J = shr64_hi(A, B, 7), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function g0_512_lo(A, B) {
  var L = rotr64_lo(A, B, 1), V = rotr64_lo(A, B, 8), J = shr64_lo(A, B, 7), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function g1_512_hi(A, B) {
  var L = rotr64_hi(A, B, 19), V = rotr64_hi(B, A, 29), J = shr64_hi(A, B, 6), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
function g1_512_lo(A, B) {
  var L = rotr64_lo(A, B, 19), V = rotr64_lo(B, A, 29), J = shr64_lo(A, B, 6), re = L ^ V ^ J;
  return re < 0 && (re += 4294967296), re;
}
var utils$9 = utils$g, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$9.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(B) {
  return B === "hex" ? utils$9.toHex32(this.h.slice(0, 12), "big") : utils$9.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$8 = utils$g, common = common$5, rotl32 = utils$8.rotl32, sum32 = utils$8.sum32, sum32_3 = utils$8.sum32_3, sum32_4 = utils$8.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160$1() {
  if (!(this instanceof RIPEMD160$1))
    return new RIPEMD160$1();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$8.inherits(RIPEMD160$1, BlockHash);
ripemd.ripemd160 = RIPEMD160$1;
RIPEMD160$1.blockSize = 512;
RIPEMD160$1.outSize = 160;
RIPEMD160$1.hmacStrength = 192;
RIPEMD160$1.padLength = 64;
RIPEMD160$1.prototype._update = function(B, L) {
  for (var V = this.h[0], J = this.h[1], re = this.h[2], ne = this.h[3], ie = this.h[4], pe = V, nt = J, oe = re, Ce = ne, at = ie, it = 0; it < 80; it++) {
    var gt = sum32(
      rotl32(
        sum32_4(V, f$1(it, J, re, ne), B[r$1[it] + L], K(it)),
        s$1[it]
      ),
      ie
    );
    V = ie, ie = ne, ne = rotl32(re, 10), re = J, J = gt, gt = sum32(
      rotl32(
        sum32_4(pe, f$1(79 - it, nt, oe, Ce), B[rh[it] + L], Kh(it)),
        sh[it]
      ),
      at
    ), pe = at, at = Ce, Ce = rotl32(oe, 10), oe = nt, nt = gt;
  }
  gt = sum32_3(this.h[1], re, Ce), this.h[1] = sum32_3(this.h[2], ne, at), this.h[2] = sum32_3(this.h[3], ie, pe), this.h[3] = sum32_3(this.h[4], V, nt), this.h[4] = sum32_3(this.h[0], J, oe), this.h[0] = gt;
};
RIPEMD160$1.prototype._digest = function(B) {
  return B === "hex" ? utils$8.toHex32(this.h, "little") : utils$8.split32(this.h, "little");
};
function f$1(A, B, L, V) {
  return A <= 15 ? B ^ L ^ V : A <= 31 ? B & L | ~B & V : A <= 47 ? (B | ~L) ^ V : A <= 63 ? B & V | L & ~V : B ^ (L | ~V);
}
function K(A) {
  return A <= 15 ? 0 : A <= 31 ? 1518500249 : A <= 47 ? 1859775393 : A <= 63 ? 2400959708 : 2840853838;
}
function Kh(A) {
  return A <= 15 ? 1352829926 : A <= 31 ? 1548603684 : A <= 47 ? 1836072691 : A <= 63 ? 2053994217 : 0;
}
var r$1 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s$1 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$7 = utils$g, assert$7 = minimalisticAssert;
function Hmac(A, B, L) {
  if (!(this instanceof Hmac))
    return new Hmac(A, B, L);
  this.Hash = A, this.blockSize = A.blockSize / 8, this.outSize = A.outSize / 8, this.inner = null, this.outer = null, this._init(utils$7.toArray(B, L));
}
var hmac = Hmac;
Hmac.prototype._init = function(B) {
  B.length > this.blockSize && (B = new this.Hash().update(B).digest()), assert$7(B.length <= this.blockSize);
  for (var L = B.length; L < this.blockSize; L++)
    B.push(0);
  for (L = 0; L < B.length; L++)
    B[L] ^= 54;
  for (this.inner = new this.Hash().update(B), L = 0; L < B.length; L++)
    B[L] ^= 106;
  this.outer = new this.Hash().update(B);
};
Hmac.prototype.update = function(B, L) {
  return this.inner.update(B, L), this;
};
Hmac.prototype.digest = function(B) {
  return this.outer.update(this.inner.digest()), this.outer.digest(B);
};
(function(A) {
  var B = A;
  B.utils = utils$g, B.common = common$5, B.sha = sha, B.ripemd = ripemd, B.hmac = hmac, B.sha1 = B.sha.sha1, B.sha256 = B.sha.sha256, B.sha224 = B.sha.sha224, B.sha384 = B.sha.sha384, B.sha512 = B.sha.sha512, B.ripemd160 = B.ripemd.ripemd160;
})(hash$2);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(A) {
  var B = A, L = hash$2, V = curve, J = utils$m, re = J.assert;
  function ne(nt) {
    nt.type === "short" ? this.curve = new V.short(nt) : nt.type === "edwards" ? this.curve = new V.edwards(nt) : this.curve = new V.mont(nt), this.g = this.curve.g, this.n = this.curve.n, this.hash = nt.hash, re(this.g.validate(), "Invalid curve"), re(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  B.PresetCurve = ne;
  function ie(nt, oe) {
    Object.defineProperty(B, nt, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Ce = new ne(oe);
        return Object.defineProperty(B, nt, {
          configurable: !0,
          enumerable: !0,
          value: Ce
        }), Ce;
      }
    });
  }
  ie("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: L.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), ie("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: L.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), ie("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: L.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), ie("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: L.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), ie("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: L.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), ie("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: L.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), ie("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: L.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pe;
  try {
    pe = requireSecp256k1();
  } catch {
    pe = void 0;
  }
  ie("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: L.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pe
    ]
  });
})(curves$1);
var hash$1 = hash$2, utils$6 = utils$l, assert$6 = minimalisticAssert;
function HmacDRBG(A) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(A);
  this.hash = A.hash, this.predResist = !!A.predResist, this.outLen = this.hash.outSize, this.minEntropy = A.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var B = utils$6.toArray(A.entropy, A.entropyEnc || "hex"), L = utils$6.toArray(A.nonce, A.nonceEnc || "hex"), V = utils$6.toArray(A.pers, A.persEnc || "hex");
  assert$6(
    B.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(B, L, V);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(B, L, V) {
  var J = B.concat(L).concat(V);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var re = 0; re < this.V.length; re++)
    this.K[re] = 0, this.V[re] = 1;
  this._update(J), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$1.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(B) {
  var L = this._hmac().update(this.V).update([0]);
  B && (L = L.update(B)), this.K = L.digest(), this.V = this._hmac().update(this.V).digest(), B && (this.K = this._hmac().update(this.V).update([1]).update(B).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(B, L, V, J) {
  typeof L != "string" && (J = V, V = L, L = null), B = utils$6.toArray(B, L), V = utils$6.toArray(V, J), assert$6(
    B.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(B.concat(V || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(B, L, V, J) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof L != "string" && (J = V, V = L, L = null), V && (V = utils$6.toArray(V, J || "hex"), this._update(V));
  for (var re = []; re.length < B; )
    this.V = this._hmac().update(this.V).digest(), re = re.concat(this.V);
  var ne = re.slice(0, B);
  return this._update(V), this._reseed++, utils$6.encode(ne, L);
};
var BN$5 = bnExports$1, utils$5 = utils$m, assert$5 = utils$5.assert;
function KeyPair$2(A, B) {
  this.ec = A, this.priv = null, this.pub = null, B.priv && this._importPrivate(B.priv, B.privEnc), B.pub && this._importPublic(B.pub, B.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(B, L, V) {
  return L instanceof KeyPair$2 ? L : new KeyPair$2(B, {
    pub: L,
    pubEnc: V
  });
};
KeyPair$2.fromPrivate = function(B, L, V) {
  return L instanceof KeyPair$2 ? L : new KeyPair$2(B, {
    priv: L,
    privEnc: V
  });
};
KeyPair$2.prototype.validate = function() {
  var B = this.getPublic();
  return B.isInfinity() ? { result: !1, reason: "Invalid public key" } : B.validate() ? B.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(B, L) {
  return typeof B == "string" && (L = B, B = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), L ? this.pub.encode(L, B) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(B) {
  return B === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(B, L) {
  this.priv = new BN$5(B, L || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(B, L) {
  if (B.x || B.y) {
    this.ec.curve.type === "mont" ? assert$5(B.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$5(B.x && B.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(B.x, B.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(B, L);
};
KeyPair$2.prototype.derive = function(B) {
  return B.validate() || assert$5(B.validate(), "public point not validated"), B.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(B, L, V) {
  return this.ec.sign(B, this, L, V);
};
KeyPair$2.prototype.verify = function(B, L, V) {
  return this.ec.verify(B, L, this, void 0, V);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$1, utils$4 = utils$m, assert$4 = utils$4.assert;
function Signature$2(A, B) {
  if (A instanceof Signature$2)
    return A;
  this._importDER(A, B) || (assert$4(A.r && A.s, "Signature without r or s"), this.r = new BN$4(A.r, 16), this.s = new BN$4(A.s, 16), A.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = A.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(A, B) {
  var L = A[B.place++];
  if (!(L & 128))
    return L;
  var V = L & 15;
  if (V === 0 || V > 4 || A[B.place] === 0)
    return !1;
  for (var J = 0, re = 0, ne = B.place; re < V; re++, ne++)
    J <<= 8, J |= A[ne], J >>>= 0;
  return J <= 127 ? !1 : (B.place = ne, J);
}
function rmPadding(A) {
  for (var B = 0, L = A.length - 1; !A[B] && !(A[B + 1] & 128) && B < L; )
    B++;
  return B === 0 ? A : A.slice(B);
}
Signature$2.prototype._importDER = function(B, L) {
  B = utils$4.toArray(B, L);
  var V = new Position();
  if (B[V.place++] !== 48)
    return !1;
  var J = getLength(B, V);
  if (J === !1 || J + V.place !== B.length || B[V.place++] !== 2)
    return !1;
  var re = getLength(B, V);
  if (re === !1 || B[V.place] & 128)
    return !1;
  var ne = B.slice(V.place, re + V.place);
  if (V.place += re, B[V.place++] !== 2)
    return !1;
  var ie = getLength(B, V);
  if (ie === !1 || B.length !== ie + V.place || B[V.place] & 128)
    return !1;
  var pe = B.slice(V.place, ie + V.place);
  if (ne[0] === 0)
    if (ne[1] & 128)
      ne = ne.slice(1);
    else
      return !1;
  if (pe[0] === 0)
    if (pe[1] & 128)
      pe = pe.slice(1);
    else
      return !1;
  return this.r = new BN$4(ne), this.s = new BN$4(pe), this.recoveryParam = null, !0;
};
function constructLength(A, B) {
  if (B < 128) {
    A.push(B);
    return;
  }
  var L = 1 + (Math.log(B) / Math.LN2 >>> 3);
  for (A.push(L | 128); --L; )
    A.push(B >>> (L << 3) & 255);
  A.push(B);
}
Signature$2.prototype.toDER = function(B) {
  var L = this.r.toArray(), V = this.s.toArray();
  for (L[0] & 128 && (L = [0].concat(L)), V[0] & 128 && (V = [0].concat(V)), L = rmPadding(L), V = rmPadding(V); !V[0] && !(V[1] & 128); )
    V = V.slice(1);
  var J = [2];
  constructLength(J, L.length), J = J.concat(L), J.push(2), constructLength(J, V.length);
  var re = J.concat(V), ne = [48];
  return constructLength(ne, re.length), ne = ne.concat(re), utils$4.encode(ne, B);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var A = bnExports$1, B = hmacDrbg, L = utils$m, V = curves$1, J = requireBrorand(), re = L.assert, ne = key$1, ie = signature$1;
  function pe(nt) {
    if (!(this instanceof pe))
      return new pe(nt);
    typeof nt == "string" && (re(
      Object.prototype.hasOwnProperty.call(V, nt),
      "Unknown curve " + nt
    ), nt = V[nt]), nt instanceof V.PresetCurve && (nt = { curve: nt }), this.curve = nt.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = nt.curve.g, this.g.precompute(nt.curve.n.bitLength() + 1), this.hash = nt.hash || nt.curve.hash;
  }
  return ec = pe, pe.prototype.keyPair = function(oe) {
    return new ne(this, oe);
  }, pe.prototype.keyFromPrivate = function(oe, Ce) {
    return ne.fromPrivate(this, oe, Ce);
  }, pe.prototype.keyFromPublic = function(oe, Ce) {
    return ne.fromPublic(this, oe, Ce);
  }, pe.prototype.genKeyPair = function(oe) {
    oe || (oe = {});
    for (var Ce = new B({
      hash: this.hash,
      pers: oe.pers,
      persEnc: oe.persEnc || "utf8",
      entropy: oe.entropy || J(this.hash.hmacStrength),
      entropyEnc: oe.entropy && oe.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), at = this.n.byteLength(), it = this.n.sub(new A(2)); ; ) {
      var gt = new A(Ce.generate(at));
      if (!(gt.cmp(it) > 0))
        return gt.iaddn(1), this.keyFromPrivate(gt);
    }
  }, pe.prototype._truncateToN = function(oe, Ce, at) {
    var it;
    if (A.isBN(oe) || typeof oe == "number")
      oe = new A(oe, 16), it = oe.byteLength();
    else if (typeof oe == "object")
      it = oe.length, oe = new A(oe, 16);
    else {
      var gt = oe.toString();
      it = gt.length + 1 >>> 1, oe = new A(gt, 16);
    }
    typeof at != "number" && (at = it * 8);
    var St = at - this.n.bitLength();
    return St > 0 && (oe = oe.ushrn(St)), !Ce && oe.cmp(this.n) >= 0 ? oe.sub(this.n) : oe;
  }, pe.prototype.sign = function(oe, Ce, at, it) {
    if (typeof at == "object" && (it = at, at = null), it || (it = {}), typeof oe != "string" && typeof oe != "number" && !A.isBN(oe)) {
      re(
        typeof oe == "object" && oe && typeof oe.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), re(oe.length >>> 0 === oe.length);
      for (var gt = 0; gt < oe.length; gt++) re((oe[gt] & 255) === oe[gt]);
    }
    Ce = this.keyFromPrivate(Ce, at), oe = this._truncateToN(oe, !1, it.msgBitLength), re(!oe.isNeg(), "Can not sign a negative message");
    var St = this.n.byteLength(), xt = Ce.getPrivate().toArray("be", St), Mt = oe.toArray("be", St);
    re(new A(Mt).eq(oe), "Can not sign message");
    for (var bt = new B({
      hash: this.hash,
      entropy: xt,
      nonce: Mt,
      pers: it.pers,
      persEnc: it.persEnc || "utf8"
    }), Tt = this.n.sub(new A(1)), It = 0; ; It++) {
      var qt = it.k ? it.k(It) : new A(bt.generate(this.n.byteLength()));
      if (qt = this._truncateToN(qt, !0), !(qt.cmpn(1) <= 0 || qt.cmp(Tt) >= 0)) {
        var Dt = this.g.mul(qt);
        if (!Dt.isInfinity()) {
          var Xt = Dt.getX(), Bt = Xt.umod(this.n);
          if (Bt.cmpn(0) !== 0) {
            var mt = qt.invm(this.n).mul(Bt.mul(Ce.getPrivate()).iadd(oe));
            if (mt = mt.umod(this.n), mt.cmpn(0) !== 0) {
              var Ot = (Dt.getY().isOdd() ? 1 : 0) | (Xt.cmp(Bt) !== 0 ? 2 : 0);
              return it.canonical && mt.cmp(this.nh) > 0 && (mt = this.n.sub(mt), Ot ^= 1), new ie({ r: Bt, s: mt, recoveryParam: Ot });
            }
          }
        }
      }
    }
  }, pe.prototype.verify = function(oe, Ce, at, it, gt) {
    gt || (gt = {}), oe = this._truncateToN(oe, !1, gt.msgBitLength), at = this.keyFromPublic(at, it), Ce = new ie(Ce, "hex");
    var St = Ce.r, xt = Ce.s;
    if (St.cmpn(1) < 0 || St.cmp(this.n) >= 0 || xt.cmpn(1) < 0 || xt.cmp(this.n) >= 0)
      return !1;
    var Mt = xt.invm(this.n), bt = Mt.mul(oe).umod(this.n), Tt = Mt.mul(St).umod(this.n), It;
    return this.curve._maxwellTrick ? (It = this.g.jmulAdd(bt, at.getPublic(), Tt), It.isInfinity() ? !1 : It.eqXToP(St)) : (It = this.g.mulAdd(bt, at.getPublic(), Tt), It.isInfinity() ? !1 : It.getX().umod(this.n).cmp(St) === 0);
  }, pe.prototype.recoverPubKey = function(nt, oe, Ce, at) {
    re((3 & Ce) === Ce, "The recovery param is more than two bits"), oe = new ie(oe, at);
    var it = this.n, gt = new A(nt), St = oe.r, xt = oe.s, Mt = Ce & 1, bt = Ce >> 1;
    if (St.cmp(this.curve.p.umod(this.curve.n)) >= 0 && bt)
      throw new Error("Unable to find sencond key candinate");
    bt ? St = this.curve.pointFromX(St.add(this.curve.n), Mt) : St = this.curve.pointFromX(St, Mt);
    var Tt = oe.r.invm(it), It = it.sub(gt).mul(Tt).umod(it), qt = xt.mul(Tt).umod(it);
    return this.g.mulAdd(It, St, qt);
  }, pe.prototype.getKeyRecoveryParam = function(nt, oe, Ce, at) {
    if (oe = new ie(oe, at), oe.recoveryParam !== null)
      return oe.recoveryParam;
    for (var it = 0; it < 4; it++) {
      var gt;
      try {
        gt = this.recoverPubKey(nt, oe, it);
      } catch {
        continue;
      }
      if (gt.eq(Ce))
        return it;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$3 = utils$m, assert$3 = utils$3.assert, parseBytes$2 = utils$3.parseBytes, cachedProperty$1 = utils$3.cachedProperty;
function KeyPair$1(A, B) {
  this.eddsa = A, this._secret = parseBytes$2(B.secret), A.isPoint(B.pub) ? this._pub = B.pub : this._pubBytes = parseBytes$2(B.pub);
}
KeyPair$1.fromPublic = function(B, L) {
  return L instanceof KeyPair$1 ? L : new KeyPair$1(B, { pub: L });
};
KeyPair$1.fromSecret = function(B, L) {
  return L instanceof KeyPair$1 ? L : new KeyPair$1(B, { secret: L });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var B = this.eddsa, L = this.hash(), V = B.encodingLength - 1, J = L.slice(0, B.encodingLength);
  return J[0] &= 248, J[V] &= 127, J[V] |= 64, J;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(B) {
  return assert$3(this._secret, "KeyPair can only verify"), this.eddsa.sign(B, this);
};
KeyPair$1.prototype.verify = function(B, L) {
  return this.eddsa.verify(B, L, this);
};
KeyPair$1.prototype.getSecret = function(B) {
  return assert$3(this._secret, "KeyPair is public only"), utils$3.encode(this.secret(), B);
};
KeyPair$1.prototype.getPublic = function(B) {
  return utils$3.encode(this.pubBytes(), B);
};
var key = KeyPair$1, BN$3 = bnExports$1, utils$2 = utils$m, assert$2 = utils$2.assert, cachedProperty = utils$2.cachedProperty, parseBytes$1 = utils$2.parseBytes;
function Signature$1(A, B) {
  this.eddsa = A, typeof B != "object" && (B = parseBytes$1(B)), Array.isArray(B) && (assert$2(B.length === A.encodingLength * 2, "Signature has invalid size"), B = {
    R: B.slice(0, A.encodingLength),
    S: B.slice(A.encodingLength)
  }), assert$2(B.R && B.S, "Signature without R or S"), A.isPoint(B.R) && (this._R = B.R), B.S instanceof BN$3 && (this._S = B.S), this._Rencoded = Array.isArray(B.R) ? B.R : B.Rencoded, this._Sencoded = Array.isArray(B.S) ? B.S : B.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$2.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash = hash$2, curves = curves$1, utils$1 = utils$m, assert$1 = utils$1.assert, parseBytes = utils$1.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(A) {
  if (assert$1(A === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(A);
  A = curves[A].curve, this.curve = A, this.g = A.g, this.g.precompute(A.n.bitLength() + 1), this.pointClass = A.point().constructor, this.encodingLength = Math.ceil(A.n.bitLength() / 8), this.hash = hash.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(B, L) {
  B = parseBytes(B);
  var V = this.keyFromSecret(L), J = this.hashInt(V.messagePrefix(), B), re = this.g.mul(J), ne = this.encodePoint(re), ie = this.hashInt(ne, V.pubBytes(), B).mul(V.priv()), pe = J.add(ie).umod(this.curve.n);
  return this.makeSignature({ R: re, S: pe, Rencoded: ne });
};
EDDSA.prototype.verify = function(B, L, V) {
  if (B = parseBytes(B), L = this.makeSignature(L), L.S().gte(L.eddsa.curve.n) || L.S().isNeg())
    return !1;
  var J = this.keyFromPublic(V), re = this.hashInt(L.Rencoded(), J.pubBytes(), B), ne = this.g.mul(L.S()), ie = L.R().add(J.pub().mul(re));
  return ie.eq(ne);
};
EDDSA.prototype.hashInt = function() {
  for (var B = this.hash(), L = 0; L < arguments.length; L++)
    B.update(arguments[L]);
  return utils$1.intFromLE(B.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(B) {
  return KeyPair.fromPublic(this, B);
};
EDDSA.prototype.keyFromSecret = function(B) {
  return KeyPair.fromSecret(this, B);
};
EDDSA.prototype.makeSignature = function(B) {
  return B instanceof Signature ? B : new Signature(this, B);
};
EDDSA.prototype.encodePoint = function(B) {
  var L = B.getY().toArray("le", this.encodingLength);
  return L[this.encodingLength - 1] |= B.getX().isOdd() ? 128 : 0, L;
};
EDDSA.prototype.decodePoint = function(B) {
  B = utils$1.parseBytes(B);
  var L = B.length - 1, V = B.slice(0, L).concat(B[L] & -129), J = (B[L] & 128) !== 0, re = utils$1.intFromLE(V);
  return this.curve.pointFromY(re, J);
};
EDDSA.prototype.encodeInt = function(B) {
  return B.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(B) {
  return utils$1.intFromLE(B);
};
EDDSA.prototype.isPoint = function(B) {
  return B instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(A) {
    var B = A;
    B.version = require$$0.version, B.utils = utils$m, B.rand = requireBrorand(), B.curve = curve, B.curves = curves$1, B.ec = requireEc(), B.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(A, B) {
      if (A.indexOf) return A.indexOf(B);
      for (var L = 0; L < A.length; L++)
        if (A[L] === B) return L;
      return -1;
    }, Object_keys = function(A) {
      if (Object.keys) return Object.keys(A);
      var B = [];
      for (var L in A) B.push(L);
      return B;
    }, forEach = function(A, B) {
      if (A.forEach) return A.forEach(B);
      for (var L = 0; L < A.length; L++)
        B(A[L], L, A);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(A, B, L) {
          Object.defineProperty(A, B, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: L
          });
        };
      } catch {
        return function(B, L, V) {
          B[L] = V;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(A) {
      if (!(A instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var B = document.createElement("iframe");
      B.style || (B.style = {}), B.style.display = "none", document.body.appendChild(B);
      var L = B.contentWindow, V = L.eval, J = L.execScript;
      !V && J && (J.call(L, "null"), V = L.eval), forEach(Object_keys(A), function(ie) {
        L[ie] = A[ie];
      }), forEach(globals, function(ie) {
        A[ie] && (L[ie] = A[ie]);
      });
      var re = Object_keys(L), ne = V.call(L, this.code);
      return forEach(Object_keys(L), function(ie) {
        (ie in A || indexOf(re, ie) === -1) && (A[ie] = L[ie]);
      }), forEach(globals, function(ie) {
        ie in A || defineProp(A, ie, L[ie]);
      }), document.body.removeChild(B), ne;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(A) {
      var B = Script.createContext(A), L = this.runInContext(B);
      return A && forEach(Object_keys(B), function(V) {
        A[V] = B[V];
      }), L;
    }, forEach(Object_keys(Script.prototype), function(A) {
      exports[A] = Script[A] = function(B) {
        var L = Script(B);
        return L[A].apply(L, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(A) {
      return A instanceof Context;
    }, exports.createScript = function(A) {
      return exports.Script(A);
    }, exports.createContext = Script.createContext = function(A) {
      var B = new Context();
      return typeof A == "object" && forEach(Object_keys(A), function(L) {
        B[L] = A[L];
      }), B;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(A) {
    var B = requireAsn1(), L = inherits_browserExports, V = A;
    V.define = function(ne, ie) {
      return new J(ne, ie);
    };
    function J(re, ne) {
      this.name = re, this.body = ne, this.decoders = {}, this.encoders = {};
    }
    J.prototype._createNamed = function(ne) {
      var ie;
      try {
        ie = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ie = function(nt) {
          this._initNamed(nt);
        };
      }
      return L(ie, ne), ie.prototype._initNamed = function(nt) {
        ne.call(this, nt);
      }, new ie(this);
    }, J.prototype._getDecoder = function(ne) {
      return ne = ne || "der", this.decoders.hasOwnProperty(ne) || (this.decoders[ne] = this._createNamed(B.decoders[ne])), this.decoders[ne];
    }, J.prototype.decode = function(ne, ie, pe) {
      return this._getDecoder(ie).decode(ne, pe);
    }, J.prototype._getEncoder = function(ne) {
      return ne = ne || "der", this.encoders.hasOwnProperty(ne) || (this.encoders[ne] = this._createNamed(B.encoders[ne])), this.encoders[ne];
    }, J.prototype.encode = function(ne, ie, pe) {
      return this._getEncoder(ie).encode(ne, pe);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(A) {
  this._reporterState = {
    obj: null,
    path: [],
    options: A || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function A(B) {
  return B instanceof ReporterError;
};
Reporter.prototype.save = function A() {
  var B = this._reporterState;
  return { obj: B.obj, pathLen: B.path.length };
};
Reporter.prototype.restore = function A(B) {
  var L = this._reporterState;
  L.obj = B.obj, L.path = L.path.slice(0, B.pathLen);
};
Reporter.prototype.enterKey = function A(B) {
  return this._reporterState.path.push(B);
};
Reporter.prototype.exitKey = function A(B) {
  var L = this._reporterState;
  L.path = L.path.slice(0, B - 1);
};
Reporter.prototype.leaveKey = function A(B, L, V) {
  var J = this._reporterState;
  this.exitKey(B), J.obj !== null && (J.obj[L] = V);
};
Reporter.prototype.path = function A() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function A() {
  var B = this._reporterState, L = B.obj;
  return B.obj = {}, L;
};
Reporter.prototype.leaveObject = function A(B) {
  var L = this._reporterState, V = L.obj;
  return L.obj = B, V;
};
Reporter.prototype.error = function A(B) {
  var L, V = this._reporterState, J = B instanceof ReporterError;
  if (J ? L = B : L = new ReporterError(V.path.map(function(re) {
    return "[" + JSON.stringify(re) + "]";
  }).join(""), B.message || B, B.stack), !V.options.partial)
    throw L;
  return J || V.errors.push(L), L;
};
Reporter.prototype.wrapResult = function A(B) {
  var L = this._reporterState;
  return L.options.partial ? {
    result: this.isError(B) ? null : B,
    errors: L.errors
  } : B;
};
function ReporterError(A, B) {
  this.path = A, this.rethrow(B);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function A(B) {
  if (this.message = B + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (L) {
      this.stack = L.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var A = inherits_browserExports, B = requireBase().Reporter, L = dist$1.Buffer;
  function V(re, ne) {
    if (B.call(this, ne), !L.isBuffer(re)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = re, this.offset = 0, this.length = re.length;
  }
  A(V, B), buffer.DecoderBuffer = V, V.prototype.save = function() {
    return { offset: this.offset, reporter: B.prototype.save.call(this) };
  }, V.prototype.restore = function(ne) {
    var ie = new V(this.base);
    return ie.offset = ne.offset, ie.length = this.offset, this.offset = ne.offset, B.prototype.restore.call(this, ne.reporter), ie;
  }, V.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, V.prototype.readUInt8 = function(ne) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ne || "DecoderBuffer overrun");
  }, V.prototype.skip = function(ne, ie) {
    if (!(this.offset + ne <= this.length))
      return this.error(ie || "DecoderBuffer overrun");
    var pe = new V(this.base);
    return pe._reporterState = this._reporterState, pe.offset = this.offset, pe.length = this.offset + ne, this.offset += ne, pe;
  }, V.prototype.raw = function(ne) {
    return this.base.slice(ne ? ne.offset : this.offset, this.length);
  };
  function J(re, ne) {
    if (Array.isArray(re))
      this.length = 0, this.value = re.map(function(ie) {
        return ie instanceof J || (ie = new J(ie, ne)), this.length += ie.length, ie;
      }, this);
    else if (typeof re == "number") {
      if (!(0 <= re && re <= 255))
        return ne.error("non-byte EncoderBuffer value");
      this.value = re, this.length = 1;
    } else if (typeof re == "string")
      this.value = re, this.length = L.byteLength(re);
    else if (L.isBuffer(re))
      this.value = re, this.length = re.length;
    else
      return ne.error("Unsupported type: " + typeof re);
  }
  return buffer.EncoderBuffer = J, J.prototype.join = function(ne, ie) {
    return ne || (ne = new L(this.length)), ie || (ie = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(pe) {
      pe.join(ne, ie), ie += pe.length;
    }) : (typeof this.value == "number" ? ne[ie] = this.value : typeof this.value == "string" ? ne.write(this.value, ie) : L.isBuffer(this.value) && this.value.copy(ne, ie), ie += this.length)), ne;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var A = requireBase().Reporter, B = requireBase().EncoderBuffer, L = requireBase().DecoderBuffer, V = minimalisticAssert, J = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], re = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(J), ne = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ie(nt, oe) {
    var Ce = {};
    this._baseState = Ce, Ce.enc = nt, Ce.parent = oe || null, Ce.children = null, Ce.tag = null, Ce.args = null, Ce.reverseArgs = null, Ce.choice = null, Ce.optional = !1, Ce.any = !1, Ce.obj = !1, Ce.use = null, Ce.useDecoder = null, Ce.key = null, Ce.default = null, Ce.explicit = null, Ce.implicit = null, Ce.contains = null, Ce.parent || (Ce.children = [], this._wrap());
  }
  node = ie;
  var pe = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ie.prototype.clone = function() {
    var oe = this._baseState, Ce = {};
    pe.forEach(function(it) {
      Ce[it] = oe[it];
    });
    var at = new this.constructor(Ce.parent);
    return at._baseState = Ce, at;
  }, ie.prototype._wrap = function() {
    var oe = this._baseState;
    re.forEach(function(Ce) {
      this[Ce] = function() {
        var it = new this.constructor(this);
        return oe.children.push(it), it[Ce].apply(it, arguments);
      };
    }, this);
  }, ie.prototype._init = function(oe) {
    var Ce = this._baseState;
    V(Ce.parent === null), oe.call(this), Ce.children = Ce.children.filter(function(at) {
      return at._baseState.parent === this;
    }, this), V.equal(Ce.children.length, 1, "Root node can have only one child");
  }, ie.prototype._useArgs = function(oe) {
    var Ce = this._baseState, at = oe.filter(function(it) {
      return it instanceof this.constructor;
    }, this);
    oe = oe.filter(function(it) {
      return !(it instanceof this.constructor);
    }, this), at.length !== 0 && (V(Ce.children === null), Ce.children = at, at.forEach(function(it) {
      it._baseState.parent = this;
    }, this)), oe.length !== 0 && (V(Ce.args === null), Ce.args = oe, Ce.reverseArgs = oe.map(function(it) {
      if (typeof it != "object" || it.constructor !== Object)
        return it;
      var gt = {};
      return Object.keys(it).forEach(function(St) {
        St == (St | 0) && (St |= 0);
        var xt = it[St];
        gt[xt] = St;
      }), gt;
    }));
  }, ne.forEach(function(nt) {
    ie.prototype[nt] = function() {
      var Ce = this._baseState;
      throw new Error(nt + " not implemented for encoding: " + Ce.enc);
    };
  }), J.forEach(function(nt) {
    ie.prototype[nt] = function() {
      var Ce = this._baseState, at = Array.prototype.slice.call(arguments);
      return V(Ce.tag === null), Ce.tag = nt, this._useArgs(at), this;
    };
  }), ie.prototype.use = function(oe) {
    V(oe);
    var Ce = this._baseState;
    return V(Ce.use === null), Ce.use = oe, this;
  }, ie.prototype.optional = function() {
    var oe = this._baseState;
    return oe.optional = !0, this;
  }, ie.prototype.def = function(oe) {
    var Ce = this._baseState;
    return V(Ce.default === null), Ce.default = oe, Ce.optional = !0, this;
  }, ie.prototype.explicit = function(oe) {
    var Ce = this._baseState;
    return V(Ce.explicit === null && Ce.implicit === null), Ce.explicit = oe, this;
  }, ie.prototype.implicit = function(oe) {
    var Ce = this._baseState;
    return V(Ce.explicit === null && Ce.implicit === null), Ce.implicit = oe, this;
  }, ie.prototype.obj = function() {
    var oe = this._baseState, Ce = Array.prototype.slice.call(arguments);
    return oe.obj = !0, Ce.length !== 0 && this._useArgs(Ce), this;
  }, ie.prototype.key = function(oe) {
    var Ce = this._baseState;
    return V(Ce.key === null), Ce.key = oe, this;
  }, ie.prototype.any = function() {
    var oe = this._baseState;
    return oe.any = !0, this;
  }, ie.prototype.choice = function(oe) {
    var Ce = this._baseState;
    return V(Ce.choice === null), Ce.choice = oe, this._useArgs(Object.keys(oe).map(function(at) {
      return oe[at];
    })), this;
  }, ie.prototype.contains = function(oe) {
    var Ce = this._baseState;
    return V(Ce.use === null), Ce.contains = oe, this;
  }, ie.prototype._decode = function(oe, Ce) {
    var at = this._baseState;
    if (at.parent === null)
      return oe.wrapResult(at.children[0]._decode(oe, Ce));
    var it = at.default, gt = !0, St = null;
    if (at.key !== null && (St = oe.enterKey(at.key)), at.optional) {
      var xt = null;
      if (at.explicit !== null ? xt = at.explicit : at.implicit !== null ? xt = at.implicit : at.tag !== null && (xt = at.tag), xt === null && !at.any) {
        var Mt = oe.save();
        try {
          at.choice === null ? this._decodeGeneric(at.tag, oe, Ce) : this._decodeChoice(oe, Ce), gt = !0;
        } catch {
          gt = !1;
        }
        oe.restore(Mt);
      } else if (gt = this._peekTag(oe, xt, at.any), oe.isError(gt))
        return gt;
    }
    var bt;
    if (at.obj && gt && (bt = oe.enterObject()), gt) {
      if (at.explicit !== null) {
        var Tt = this._decodeTag(oe, at.explicit);
        if (oe.isError(Tt))
          return Tt;
        oe = Tt;
      }
      var It = oe.offset;
      if (at.use === null && at.choice === null) {
        if (at.any)
          var Mt = oe.save();
        var qt = this._decodeTag(
          oe,
          at.implicit !== null ? at.implicit : at.tag,
          at.any
        );
        if (oe.isError(qt))
          return qt;
        at.any ? it = oe.raw(Mt) : oe = qt;
      }
      if (Ce && Ce.track && at.tag !== null && Ce.track(oe.path(), It, oe.length, "tagged"), Ce && Ce.track && at.tag !== null && Ce.track(oe.path(), oe.offset, oe.length, "content"), at.any ? it = it : at.choice === null ? it = this._decodeGeneric(at.tag, oe, Ce) : it = this._decodeChoice(oe, Ce), oe.isError(it))
        return it;
      if (!at.any && at.choice === null && at.children !== null && at.children.forEach(function(Bt) {
        Bt._decode(oe, Ce);
      }), at.contains && (at.tag === "octstr" || at.tag === "bitstr")) {
        var Dt = new L(it);
        it = this._getUse(at.contains, oe._reporterState.obj)._decode(Dt, Ce);
      }
    }
    return at.obj && gt && (it = oe.leaveObject(bt)), at.key !== null && (it !== null || gt === !0) ? oe.leaveKey(St, at.key, it) : St !== null && oe.exitKey(St), it;
  }, ie.prototype._decodeGeneric = function(oe, Ce, at) {
    var it = this._baseState;
    return oe === "seq" || oe === "set" ? null : oe === "seqof" || oe === "setof" ? this._decodeList(Ce, oe, it.args[0], at) : /str$/.test(oe) ? this._decodeStr(Ce, oe, at) : oe === "objid" && it.args ? this._decodeObjid(Ce, it.args[0], it.args[1], at) : oe === "objid" ? this._decodeObjid(Ce, null, null, at) : oe === "gentime" || oe === "utctime" ? this._decodeTime(Ce, oe, at) : oe === "null_" ? this._decodeNull(Ce, at) : oe === "bool" ? this._decodeBool(Ce, at) : oe === "objDesc" ? this._decodeStr(Ce, oe, at) : oe === "int" || oe === "enum" ? this._decodeInt(Ce, it.args && it.args[0], at) : it.use !== null ? this._getUse(it.use, Ce._reporterState.obj)._decode(Ce, at) : Ce.error("unknown tag: " + oe);
  }, ie.prototype._getUse = function(oe, Ce) {
    var at = this._baseState;
    return at.useDecoder = this._use(oe, Ce), V(at.useDecoder._baseState.parent === null), at.useDecoder = at.useDecoder._baseState.children[0], at.implicit !== at.useDecoder._baseState.implicit && (at.useDecoder = at.useDecoder.clone(), at.useDecoder._baseState.implicit = at.implicit), at.useDecoder;
  }, ie.prototype._decodeChoice = function(oe, Ce) {
    var at = this._baseState, it = null, gt = !1;
    return Object.keys(at.choice).some(function(St) {
      var xt = oe.save(), Mt = at.choice[St];
      try {
        var bt = Mt._decode(oe, Ce);
        if (oe.isError(bt))
          return !1;
        it = { type: St, value: bt }, gt = !0;
      } catch {
        return oe.restore(xt), !1;
      }
      return !0;
    }, this), gt ? it : oe.error("Choice not matched");
  }, ie.prototype._createEncoderBuffer = function(oe) {
    return new B(oe, this.reporter);
  }, ie.prototype._encode = function(oe, Ce, at) {
    var it = this._baseState;
    if (!(it.default !== null && it.default === oe)) {
      var gt = this._encodeValue(oe, Ce, at);
      if (gt !== void 0 && !this._skipDefault(gt, Ce, at))
        return gt;
    }
  }, ie.prototype._encodeValue = function(oe, Ce, at) {
    var it = this._baseState;
    if (it.parent === null)
      return it.children[0]._encode(oe, Ce || new A());
    var Mt = null;
    if (this.reporter = Ce, it.optional && oe === void 0)
      if (it.default !== null)
        oe = it.default;
      else
        return;
    var gt = null, St = !1;
    if (it.any)
      Mt = this._createEncoderBuffer(oe);
    else if (it.choice)
      Mt = this._encodeChoice(oe, Ce);
    else if (it.contains)
      gt = this._getUse(it.contains, at)._encode(oe, Ce), St = !0;
    else if (it.children)
      gt = it.children.map(function(It) {
        if (It._baseState.tag === "null_")
          return It._encode(null, Ce, oe);
        if (It._baseState.key === null)
          return Ce.error("Child should have a key");
        var qt = Ce.enterKey(It._baseState.key);
        if (typeof oe != "object")
          return Ce.error("Child expected, but input is not object");
        var Dt = It._encode(oe[It._baseState.key], Ce, oe);
        return Ce.leaveKey(qt), Dt;
      }, this).filter(function(It) {
        return It;
      }), gt = this._createEncoderBuffer(gt);
    else if (it.tag === "seqof" || it.tag === "setof") {
      if (!(it.args && it.args.length === 1))
        return Ce.error("Too many args for : " + it.tag);
      if (!Array.isArray(oe))
        return Ce.error("seqof/setof, but data is not Array");
      var xt = this.clone();
      xt._baseState.implicit = null, gt = this._createEncoderBuffer(oe.map(function(It) {
        var qt = this._baseState;
        return this._getUse(qt.args[0], oe)._encode(It, Ce);
      }, xt));
    } else it.use !== null ? Mt = this._getUse(it.use, at)._encode(oe, Ce) : (gt = this._encodePrimitive(it.tag, oe), St = !0);
    var Mt;
    if (!it.any && it.choice === null) {
      var bt = it.implicit !== null ? it.implicit : it.tag, Tt = it.implicit === null ? "universal" : "context";
      bt === null ? it.use === null && Ce.error("Tag could be omitted only for .use()") : it.use === null && (Mt = this._encodeComposite(bt, St, Tt, gt));
    }
    return it.explicit !== null && (Mt = this._encodeComposite(it.explicit, !1, "context", Mt)), Mt;
  }, ie.prototype._encodeChoice = function(oe, Ce) {
    var at = this._baseState, it = at.choice[oe.type];
    return it || V(
      !1,
      oe.type + " not found in " + JSON.stringify(Object.keys(at.choice))
    ), it._encode(oe.value, Ce);
  }, ie.prototype._encodePrimitive = function(oe, Ce) {
    var at = this._baseState;
    if (/str$/.test(oe))
      return this._encodeStr(Ce, oe);
    if (oe === "objid" && at.args)
      return this._encodeObjid(Ce, at.reverseArgs[0], at.args[1]);
    if (oe === "objid")
      return this._encodeObjid(Ce, null, null);
    if (oe === "gentime" || oe === "utctime")
      return this._encodeTime(Ce, oe);
    if (oe === "null_")
      return this._encodeNull();
    if (oe === "int" || oe === "enum")
      return this._encodeInt(Ce, at.args && at.reverseArgs[0]);
    if (oe === "bool")
      return this._encodeBool(Ce);
    if (oe === "objDesc")
      return this._encodeStr(Ce, oe);
    throw new Error("Unsupported tag: " + oe);
  }, ie.prototype._isNumstr = function(oe) {
    return /^[0-9 ]*$/.test(oe);
  }, ie.prototype._isPrintstr = function(oe) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(oe);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(A) {
    var B = A;
    B.Reporter = reporter.Reporter, B.DecoderBuffer = requireBuffer().DecoderBuffer, B.EncoderBuffer = requireBuffer().EncoderBuffer, B.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(A) {
    var B = requireConstants();
    A.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, A.tagClassByName = B._reverse(A.tagClass), A.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, A.tagByName = B._reverse(A.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(A) {
    var B = A;
    B._reverse = function(V) {
      var J = {};
      return Object.keys(V).forEach(function(re) {
        (re | 0) == re && (re = re | 0);
        var ne = V[re];
        J[ne] = re;
      }), J;
    }, B.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var A = inherits_browserExports, B = requireAsn1(), L = B.base, V = B.bignum, J = B.constants.der;
  function re(nt) {
    this.enc = "der", this.name = nt.name, this.entity = nt, this.tree = new ne(), this.tree._init(nt.body);
  }
  der_1$1 = re, re.prototype.decode = function(oe, Ce) {
    return oe instanceof L.DecoderBuffer || (oe = new L.DecoderBuffer(oe, Ce)), this.tree._decode(oe, Ce);
  };
  function ne(nt) {
    L.Node.call(this, "der", nt);
  }
  A(ne, L.Node), ne.prototype._peekTag = function(oe, Ce, at) {
    if (oe.isEmpty())
      return !1;
    var it = oe.save(), gt = ie(oe, 'Failed to peek tag: "' + Ce + '"');
    return oe.isError(gt) ? gt : (oe.restore(it), gt.tag === Ce || gt.tagStr === Ce || gt.tagStr + "of" === Ce || at);
  }, ne.prototype._decodeTag = function(oe, Ce, at) {
    var it = ie(
      oe,
      'Failed to decode tag of "' + Ce + '"'
    );
    if (oe.isError(it))
      return it;
    var gt = pe(
      oe,
      it.primitive,
      'Failed to get length of "' + Ce + '"'
    );
    if (oe.isError(gt))
      return gt;
    if (!at && it.tag !== Ce && it.tagStr !== Ce && it.tagStr + "of" !== Ce)
      return oe.error('Failed to match tag: "' + Ce + '"');
    if (it.primitive || gt !== null)
      return oe.skip(gt, 'Failed to match body of: "' + Ce + '"');
    var St = oe.save(), xt = this._skipUntilEnd(
      oe,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return oe.isError(xt) ? xt : (gt = oe.offset - St.offset, oe.restore(St), oe.skip(gt, 'Failed to match body of: "' + Ce + '"'));
  }, ne.prototype._skipUntilEnd = function(oe, Ce) {
    for (; ; ) {
      var at = ie(oe, Ce);
      if (oe.isError(at))
        return at;
      var it = pe(oe, at.primitive, Ce);
      if (oe.isError(it))
        return it;
      var gt;
      if (at.primitive || it !== null ? gt = oe.skip(it) : gt = this._skipUntilEnd(oe, Ce), oe.isError(gt))
        return gt;
      if (at.tagStr === "end")
        break;
    }
  }, ne.prototype._decodeList = function(oe, Ce, at, it) {
    for (var gt = []; !oe.isEmpty(); ) {
      var St = this._peekTag(oe, "end");
      if (oe.isError(St))
        return St;
      var xt = at.decode(oe, "der", it);
      if (oe.isError(xt) && St)
        break;
      gt.push(xt);
    }
    return gt;
  }, ne.prototype._decodeStr = function(oe, Ce) {
    if (Ce === "bitstr") {
      var at = oe.readUInt8();
      return oe.isError(at) ? at : { unused: at, data: oe.raw() };
    } else if (Ce === "bmpstr") {
      var it = oe.raw();
      if (it.length % 2 === 1)
        return oe.error("Decoding of string type: bmpstr length mismatch");
      for (var gt = "", St = 0; St < it.length / 2; St++)
        gt += String.fromCharCode(it.readUInt16BE(St * 2));
      return gt;
    } else if (Ce === "numstr") {
      var xt = oe.raw().toString("ascii");
      return this._isNumstr(xt) ? xt : oe.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (Ce === "octstr")
        return oe.raw();
      if (Ce === "objDesc")
        return oe.raw();
      if (Ce === "printstr") {
        var Mt = oe.raw().toString("ascii");
        return this._isPrintstr(Mt) ? Mt : oe.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(Ce) ? oe.raw().toString() : oe.error("Decoding of string type: " + Ce + " unsupported");
    }
  }, ne.prototype._decodeObjid = function(oe, Ce, at) {
    for (var it, gt = [], St = 0; !oe.isEmpty(); ) {
      var xt = oe.readUInt8();
      St <<= 7, St |= xt & 127, xt & 128 || (gt.push(St), St = 0);
    }
    xt & 128 && gt.push(St);
    var Mt = gt[0] / 40 | 0, bt = gt[0] % 40;
    if (at ? it = gt : it = [Mt, bt].concat(gt.slice(1)), Ce) {
      var Tt = Ce[it.join(" ")];
      Tt === void 0 && (Tt = Ce[it.join(".")]), Tt !== void 0 && (it = Tt);
    }
    return it;
  }, ne.prototype._decodeTime = function(oe, Ce) {
    var at = oe.raw().toString();
    if (Ce === "gentime")
      var it = at.slice(0, 4) | 0, gt = at.slice(4, 6) | 0, St = at.slice(6, 8) | 0, xt = at.slice(8, 10) | 0, Mt = at.slice(10, 12) | 0, bt = at.slice(12, 14) | 0;
    else if (Ce === "utctime") {
      var it = at.slice(0, 2) | 0, gt = at.slice(2, 4) | 0, St = at.slice(4, 6) | 0, xt = at.slice(6, 8) | 0, Mt = at.slice(8, 10) | 0, bt = at.slice(10, 12) | 0;
      it < 70 ? it = 2e3 + it : it = 1900 + it;
    } else
      return oe.error("Decoding " + Ce + " time is not supported yet");
    return Date.UTC(it, gt - 1, St, xt, Mt, bt, 0);
  }, ne.prototype._decodeNull = function(oe) {
    return null;
  }, ne.prototype._decodeBool = function(oe) {
    var Ce = oe.readUInt8();
    return oe.isError(Ce) ? Ce : Ce !== 0;
  }, ne.prototype._decodeInt = function(oe, Ce) {
    var at = oe.raw(), it = new V(at);
    return Ce && (it = Ce[it.toString(10)] || it), it;
  }, ne.prototype._use = function(oe, Ce) {
    return typeof oe == "function" && (oe = oe(Ce)), oe._getDecoder("der").tree;
  };
  function ie(nt, oe) {
    var Ce = nt.readUInt8(oe);
    if (nt.isError(Ce))
      return Ce;
    var at = J.tagClass[Ce >> 6], it = (Ce & 32) === 0;
    if ((Ce & 31) === 31) {
      var gt = Ce;
      for (Ce = 0; (gt & 128) === 128; ) {
        if (gt = nt.readUInt8(oe), nt.isError(gt))
          return gt;
        Ce <<= 7, Ce |= gt & 127;
      }
    } else
      Ce &= 31;
    var St = J.tag[Ce];
    return {
      cls: at,
      primitive: it,
      tag: Ce,
      tagStr: St
    };
  }
  function pe(nt, oe, Ce) {
    var at = nt.readUInt8(Ce);
    if (nt.isError(at))
      return at;
    if (!oe && at === 128)
      return null;
    if (!(at & 128))
      return at;
    var it = at & 127;
    if (it > 4)
      return nt.error("length octect is too long");
    at = 0;
    for (var gt = 0; gt < it; gt++) {
      at <<= 8;
      var St = nt.readUInt8(Ce);
      if (nt.isError(St))
        return St;
      at |= St;
    }
    return at;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var A = inherits_browserExports, B = dist$1.Buffer, L = requireDer$1();
  function V(J) {
    L.call(this, J), this.enc = "pem";
  }
  return A(V, L), pem$1 = V, V.prototype.decode = function(re, ne) {
    for (var ie = re.toString().split(/[\r\n]+/g), pe = ne.label.toUpperCase(), nt = /^-----(BEGIN|END) ([^-]+)-----$/, oe = -1, Ce = -1, at = 0; at < ie.length; at++) {
      var it = ie[at].match(nt);
      if (it !== null && it[2] === pe)
        if (oe === -1) {
          if (it[1] !== "BEGIN")
            break;
          oe = at;
        } else {
          if (it[1] !== "END")
            break;
          Ce = at;
          break;
        }
    }
    if (oe === -1 || Ce === -1)
      throw new Error("PEM section not found for: " + pe);
    var gt = ie.slice(oe + 1, Ce).join("");
    gt.replace(/[^a-z0-9\+\/=]+/gi, "");
    var St = new B(gt, "base64");
    return L.prototype.decode.call(this, St, ne);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(A) {
    var B = A;
    B.der = requireDer$1(), B.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var A = inherits_browserExports, B = dist$1.Buffer, L = requireAsn1(), V = L.base, J = L.constants.der;
  function re(nt) {
    this.enc = "der", this.name = nt.name, this.entity = nt, this.tree = new ne(), this.tree._init(nt.body);
  }
  der_1 = re, re.prototype.encode = function(oe, Ce) {
    return this.tree._encode(oe, Ce).join();
  };
  function ne(nt) {
    V.Node.call(this, "der", nt);
  }
  A(ne, V.Node), ne.prototype._encodeComposite = function(oe, Ce, at, it) {
    var gt = pe(oe, Ce, at, this.reporter);
    if (it.length < 128) {
      var Mt = new B(2);
      return Mt[0] = gt, Mt[1] = it.length, this._createEncoderBuffer([Mt, it]);
    }
    for (var St = 1, xt = it.length; xt >= 256; xt >>= 8)
      St++;
    var Mt = new B(2 + St);
    Mt[0] = gt, Mt[1] = 128 | St;
    for (var xt = 1 + St, bt = it.length; bt > 0; xt--, bt >>= 8)
      Mt[xt] = bt & 255;
    return this._createEncoderBuffer([Mt, it]);
  }, ne.prototype._encodeStr = function(oe, Ce) {
    if (Ce === "bitstr")
      return this._createEncoderBuffer([oe.unused | 0, oe.data]);
    if (Ce === "bmpstr") {
      for (var at = new B(oe.length * 2), it = 0; it < oe.length; it++)
        at.writeUInt16BE(oe.charCodeAt(it), it * 2);
      return this._createEncoderBuffer(at);
    } else return Ce === "numstr" ? this._isNumstr(oe) ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : Ce === "printstr" ? this._isPrintstr(oe) ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(Ce) ? this._createEncoderBuffer(oe) : Ce === "objDesc" ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: " + Ce + " unsupported");
  }, ne.prototype._encodeObjid = function(oe, Ce, at) {
    if (typeof oe == "string") {
      if (!Ce)
        return this.reporter.error("string objid given, but no values map found");
      if (!Ce.hasOwnProperty(oe))
        return this.reporter.error("objid not found in values map");
      oe = Ce[oe].split(/[\s\.]+/g);
      for (var it = 0; it < oe.length; it++)
        oe[it] |= 0;
    } else if (Array.isArray(oe)) {
      oe = oe.slice();
      for (var it = 0; it < oe.length; it++)
        oe[it] |= 0;
    }
    if (!Array.isArray(oe))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(oe));
    if (!at) {
      if (oe[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      oe.splice(0, 2, oe[0] * 40 + oe[1]);
    }
    for (var gt = 0, it = 0; it < oe.length; it++) {
      var St = oe[it];
      for (gt++; St >= 128; St >>= 7)
        gt++;
    }
    for (var xt = new B(gt), Mt = xt.length - 1, it = oe.length - 1; it >= 0; it--) {
      var St = oe[it];
      for (xt[Mt--] = St & 127; (St >>= 7) > 0; )
        xt[Mt--] = 128 | St & 127;
    }
    return this._createEncoderBuffer(xt);
  };
  function ie(nt) {
    return nt < 10 ? "0" + nt : nt;
  }
  ne.prototype._encodeTime = function(oe, Ce) {
    var at, it = new Date(oe);
    return Ce === "gentime" ? at = [
      ie(it.getFullYear()),
      ie(it.getUTCMonth() + 1),
      ie(it.getUTCDate()),
      ie(it.getUTCHours()),
      ie(it.getUTCMinutes()),
      ie(it.getUTCSeconds()),
      "Z"
    ].join("") : Ce === "utctime" ? at = [
      ie(it.getFullYear() % 100),
      ie(it.getUTCMonth() + 1),
      ie(it.getUTCDate()),
      ie(it.getUTCHours()),
      ie(it.getUTCMinutes()),
      ie(it.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + Ce + " time is not supported yet"), this._encodeStr(at, "octstr");
  }, ne.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, ne.prototype._encodeInt = function(oe, Ce) {
    if (typeof oe == "string") {
      if (!Ce)
        return this.reporter.error("String int or enum given, but no values map");
      if (!Ce.hasOwnProperty(oe))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(oe));
      oe = Ce[oe];
    }
    if (typeof oe != "number" && !B.isBuffer(oe)) {
      var at = oe.toArray();
      !oe.sign && at[0] & 128 && at.unshift(0), oe = new B(at);
    }
    if (B.isBuffer(oe)) {
      var it = oe.length;
      oe.length === 0 && it++;
      var St = new B(it);
      return oe.copy(St), oe.length === 0 && (St[0] = 0), this._createEncoderBuffer(St);
    }
    if (oe < 128)
      return this._createEncoderBuffer(oe);
    if (oe < 256)
      return this._createEncoderBuffer([0, oe]);
    for (var it = 1, gt = oe; gt >= 256; gt >>= 8)
      it++;
    for (var St = new Array(it), gt = St.length - 1; gt >= 0; gt--)
      St[gt] = oe & 255, oe >>= 8;
    return St[0] & 128 && St.unshift(0), this._createEncoderBuffer(new B(St));
  }, ne.prototype._encodeBool = function(oe) {
    return this._createEncoderBuffer(oe ? 255 : 0);
  }, ne.prototype._use = function(oe, Ce) {
    return typeof oe == "function" && (oe = oe(Ce)), oe._getEncoder("der").tree;
  }, ne.prototype._skipDefault = function(oe, Ce, at) {
    var it = this._baseState, gt;
    if (it.default === null)
      return !1;
    var St = oe.join();
    if (it.defaultBuffer === void 0 && (it.defaultBuffer = this._encodeValue(it.default, Ce, at).join()), St.length !== it.defaultBuffer.length)
      return !1;
    for (gt = 0; gt < St.length; gt++)
      if (St[gt] !== it.defaultBuffer[gt])
        return !1;
    return !0;
  };
  function pe(nt, oe, Ce, at) {
    var it;
    if (nt === "seqof" ? nt = "seq" : nt === "setof" && (nt = "set"), J.tagByName.hasOwnProperty(nt))
      it = J.tagByName[nt];
    else if (typeof nt == "number" && (nt | 0) === nt)
      it = nt;
    else
      return at.error("Unknown tag: " + nt);
    return it >= 31 ? at.error("Multi-octet tag encoding unsupported") : (oe || (it |= 32), it |= J.tagClassByName[Ce || "universal"] << 6, it);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var A = inherits_browserExports, B = requireDer();
  function L(V) {
    B.call(this, V), this.enc = "pem";
  }
  return A(L, B), pem = L, L.prototype.encode = function(J, re) {
    for (var ne = B.prototype.encode.call(this, J), ie = ne.toString("base64"), pe = ["-----BEGIN " + re.label + "-----"], nt = 0; nt < ie.length; nt += 64)
      pe.push(ie.slice(nt, nt + 64));
    return pe.push("-----END " + re.label + "-----"), pe.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(A) {
    var B = A;
    B.der = requireDer(), B.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(A) {
    var B = A;
    B.bignum = bnExports$1, B.define = requireApi().define, B.base = requireBase(), B.constants = requireConstants(), B.decoders = requireDecoders(), B.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$7 = safeBufferExports$1.Buffer, fixProc$1 = function(A, B) {
  var L = A.toString(), V = L.match(findProc), J;
  if (V) {
    var ne = "aes" + V[1], ie = Buffer$7.from(V[2], "hex"), pe = Buffer$7.from(V[3].replace(/[\r\n]/g, ""), "base64"), nt = evp(B, ie.slice(0, 8), parseInt(V[1], 10)).key, oe = [], Ce = ciphers$1.createDecipheriv(ne, nt, ie);
    oe.push(Ce.update(pe)), oe.push(Ce.final()), J = Buffer$7.concat(oe);
  } else {
    var re = L.match(fullRegex);
    J = Buffer$7.from(re[2].replace(/[\r\n]/g, ""), "base64");
  }
  var at = L.match(startRegex)[1];
  return {
    tag: at,
    data: J
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$6 = safeBufferExports$1.Buffer;
function decrypt(A, B) {
  var L = A.algorithm.decrypt.kde.kdeparams.salt, V = parseInt(A.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), J = aesid[A.algorithm.decrypt.cipher.algo.join(".")], re = A.algorithm.decrypt.cipher.iv, ne = A.subjectPrivateKey, ie = parseInt(J.split("-")[1], 10) / 8, pe = compat.pbkdf2Sync(B, L, V, ie, "sha1"), nt = ciphers.createDecipheriv(J, pe, re), oe = [];
  return oe.push(nt.update(ne)), oe.push(nt.final()), Buffer$6.concat(oe);
}
function parseKeys$2(A) {
  var B;
  typeof A == "object" && !Buffer$6.isBuffer(A) && (B = A.passphrase, A = A.key), typeof A == "string" && (A = Buffer$6.from(A));
  var L = fixProc(A, B), V = L.tag, J = L.data, re, ne;
  switch (V) {
    case "CERTIFICATE":
      ne = asn1.certificate.decode(J, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (ne || (ne = asn1.PublicKey.decode(J, "der")), re = ne.algorithm.algorithm.join("."), re) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(ne.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return ne.subjectPrivateKey = ne.subjectPublicKey, {
            type: "ec",
            data: ne
          };
        case "1.2.840.10040.4.1":
          return ne.algorithm.params.pub_key = asn1.DSAparam.decode(ne.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: ne.algorithm.params
          };
        default:
          throw new Error("unknown key id " + re);
      }
    case "ENCRYPTED PRIVATE KEY":
      J = asn1.EncryptedPrivateKey.decode(J, "der"), J = decrypt(J, B);
    case "PRIVATE KEY":
      switch (ne = asn1.PrivateKey.decode(J, "der"), re = ne.algorithm.algorithm.join("."), re) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(ne.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: ne.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ne.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return ne.algorithm.params.priv_key = asn1.DSAparam.decode(ne.subjectPrivateKey, "der"), {
            type: "dsa",
            params: ne.algorithm.params
          };
        default:
          throw new Error("unknown key id " + re);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(J, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(J, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(J, "der")
      };
    case "EC PRIVATE KEY":
      return J = asn1.ECPrivateKey.decode(J, "der"), {
        curve: J.parameters.value,
        privateKey: J.privateKey
      };
    default:
      throw new Error("unknown key type " + V);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var A = safeBufferExports$1.Buffer, B = browser$8, L = browserifyRsa, V = requireElliptic().ec, J = bnExports, re = parseAsn1, ne = require$$4, ie = 1;
  function pe(Mt, bt, Tt, It, qt) {
    var Dt = re(bt);
    if (Dt.curve) {
      if (It !== "ecdsa" && It !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return nt(Mt, Dt);
    } else if (Dt.type === "dsa") {
      if (It !== "dsa")
        throw new Error("wrong private key type");
      return oe(Mt, Dt, Tt);
    }
    if (It !== "rsa" && It !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (bt.padding !== void 0 && bt.padding !== ie)
      throw new Error("illegal or unsupported padding mode");
    Mt = A.concat([qt, Mt]);
    for (var Xt = Dt.modulus.byteLength(), Bt = [0, 1]; Mt.length + Bt.length + 1 < Xt; )
      Bt.push(255);
    Bt.push(0);
    for (var mt = -1; ++mt < Mt.length; )
      Bt.push(Mt[mt]);
    var Ot = L(Bt, Dt);
    return Ot;
  }
  function nt(Mt, bt) {
    var Tt = ne[bt.curve.join(".")];
    if (!Tt)
      throw new Error("unknown curve " + bt.curve.join("."));
    var It = new V(Tt), qt = It.keyFromPrivate(bt.privateKey), Dt = qt.sign(Mt);
    return A.from(Dt.toDER());
  }
  function oe(Mt, bt, Tt) {
    for (var It = bt.params.priv_key, qt = bt.params.p, Dt = bt.params.q, Xt = bt.params.g, Bt = new J(0), mt, Ot = it(Mt, Dt).mod(Dt), wt = !1, ke = at(It, Dt, Mt, Tt); wt === !1; )
      mt = St(Dt, ke, Tt), Bt = xt(Xt, mt, qt, Dt), wt = mt.invm(Dt).imul(Ot.add(It.mul(Bt))).mod(Dt), wt.cmpn(0) === 0 && (wt = !1, Bt = new J(0));
    return Ce(Bt, wt);
  }
  function Ce(Mt, bt) {
    Mt = Mt.toArray(), bt = bt.toArray(), Mt[0] & 128 && (Mt = [0].concat(Mt)), bt[0] & 128 && (bt = [0].concat(bt));
    var Tt = Mt.length + bt.length + 4, It = [
      48,
      Tt,
      2,
      Mt.length
    ];
    return It = It.concat(Mt, [2, bt.length], bt), A.from(It);
  }
  function at(Mt, bt, Tt, It) {
    if (Mt = A.from(Mt.toArray()), Mt.length < bt.byteLength()) {
      var qt = A.alloc(bt.byteLength() - Mt.length);
      Mt = A.concat([qt, Mt]);
    }
    var Dt = Tt.length, Xt = gt(Tt, bt), Bt = A.alloc(Dt);
    Bt.fill(1);
    var mt = A.alloc(Dt);
    return mt = B(It, mt).update(Bt).update(A.from([0])).update(Mt).update(Xt).digest(), Bt = B(It, mt).update(Bt).digest(), mt = B(It, mt).update(Bt).update(A.from([1])).update(Mt).update(Xt).digest(), Bt = B(It, mt).update(Bt).digest(), { k: mt, v: Bt };
  }
  function it(Mt, bt) {
    var Tt = new J(Mt), It = (Mt.length << 3) - bt.bitLength();
    return It > 0 && Tt.ishrn(It), Tt;
  }
  function gt(Mt, bt) {
    Mt = it(Mt, bt), Mt = Mt.mod(bt);
    var Tt = A.from(Mt.toArray());
    if (Tt.length < bt.byteLength()) {
      var It = A.alloc(bt.byteLength() - Tt.length);
      Tt = A.concat([It, Tt]);
    }
    return Tt;
  }
  function St(Mt, bt, Tt) {
    var It, qt;
    do {
      for (It = A.alloc(0); It.length * 8 < Mt.bitLength(); )
        bt.v = B(Tt, bt.k).update(bt.v).digest(), It = A.concat([It, bt.v]);
      qt = it(It, Mt), bt.k = B(Tt, bt.k).update(bt.v).update(A.from([0])).digest(), bt.v = B(Tt, bt.k).update(bt.v).digest();
    } while (qt.cmp(Mt) !== -1);
    return qt;
  }
  function xt(Mt, bt, Tt, It) {
    return Mt.toRed(J.mont(Tt)).redPow(bt).fromRed().mod(It);
  }
  return sign.exports = pe, sign.exports.getKey = at, sign.exports.makeKey = St, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var A = safeBufferExports$1.Buffer, B = bnExports, L = requireElliptic().ec, V = parseAsn1, J = require$$4;
  function re(nt, oe, Ce, at, it) {
    var gt = V(Ce);
    if (gt.type === "ec") {
      if (at !== "ecdsa" && at !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return ne(nt, oe, gt);
    } else if (gt.type === "dsa") {
      if (at !== "dsa")
        throw new Error("wrong public key type");
      return ie(nt, oe, gt);
    }
    if (at !== "rsa" && at !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    oe = A.concat([it, oe]);
    for (var St = gt.modulus.byteLength(), xt = [1], Mt = 0; oe.length + xt.length + 2 < St; )
      xt.push(255), Mt += 1;
    xt.push(0);
    for (var bt = -1; ++bt < oe.length; )
      xt.push(oe[bt]);
    xt = A.from(xt);
    var Tt = B.mont(gt.modulus);
    nt = new B(nt).toRed(Tt), nt = nt.redPow(new B(gt.publicExponent)), nt = A.from(nt.fromRed().toArray());
    var It = Mt < 8 ? 1 : 0;
    for (St = Math.min(nt.length, xt.length), nt.length !== xt.length && (It = 1), bt = -1; ++bt < St; )
      It |= nt[bt] ^ xt[bt];
    return It === 0;
  }
  function ne(nt, oe, Ce) {
    var at = J[Ce.data.algorithm.curve.join(".")];
    if (!at)
      throw new Error("unknown curve " + Ce.data.algorithm.curve.join("."));
    var it = new L(at), gt = Ce.data.subjectPrivateKey.data;
    return it.verify(oe, nt, gt);
  }
  function ie(nt, oe, Ce) {
    var at = Ce.data.p, it = Ce.data.q, gt = Ce.data.g, St = Ce.data.pub_key, xt = V.signature.decode(nt, "der"), Mt = xt.s, bt = xt.r;
    pe(Mt, it), pe(bt, it);
    var Tt = B.mont(at), It = Mt.invm(it), qt = gt.toRed(Tt).redPow(new B(oe).mul(It).mod(it)).fromRed().mul(St.toRed(Tt).redPow(bt.mul(It).mod(it)).fromRed()).mod(at).mod(it);
    return qt.cmp(bt) === 0;
  }
  function pe(nt, oe) {
    if (nt.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (nt.cmp(oe) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = re, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var A = safeBufferExports$1.Buffer, B = browser$9, L = readableBrowserExports, V = inherits_browserExports, J = requireSign(), re = requireVerify(), ne = require$$6;
  Object.keys(ne).forEach(function(Ce) {
    ne[Ce].id = A.from(ne[Ce].id, "hex"), ne[Ce.toLowerCase()] = ne[Ce];
  });
  function ie(Ce) {
    L.Writable.call(this);
    var at = ne[Ce];
    if (!at)
      throw new Error("Unknown message digest");
    this._hashType = at.hash, this._hash = B(at.hash), this._tag = at.id, this._signType = at.sign;
  }
  V(ie, L.Writable), ie.prototype._write = function(at, it, gt) {
    this._hash.update(at), gt();
  }, ie.prototype.update = function(at, it) {
    return this._hash.update(typeof at == "string" ? A.from(at, it) : at), this;
  }, ie.prototype.sign = function(at, it) {
    this.end();
    var gt = this._hash.digest(), St = J(gt, at, this._hashType, this._signType, this._tag);
    return it ? St.toString(it) : St;
  };
  function pe(Ce) {
    L.Writable.call(this);
    var at = ne[Ce];
    if (!at)
      throw new Error("Unknown message digest");
    this._hash = B(at.hash), this._tag = at.id, this._signType = at.sign;
  }
  V(pe, L.Writable), pe.prototype._write = function(at, it, gt) {
    this._hash.update(at), gt();
  }, pe.prototype.update = function(at, it) {
    return this._hash.update(typeof at == "string" ? A.from(at, it) : at), this;
  }, pe.prototype.verify = function(at, it, gt) {
    var St = typeof it == "string" ? A.from(it, gt) : it;
    this.end();
    var xt = this._hash.digest();
    return re(St, xt, at, this._signType, this._tag);
  };
  function nt(Ce) {
    return new ie(Ce);
  }
  function oe(Ce) {
    return new pe(Ce);
  }
  return browser$3 = {
    Sign: nt,
    Verify: oe,
    createSign: nt,
    createVerify: oe
  }, browser$3;
}
var browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var A = requireElliptic(), B = bnExports$1;
  browser$2 = function(ne) {
    return new V(ne);
  };
  var L = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  L.p224 = L.secp224r1, L.p256 = L.secp256r1 = L.prime256v1, L.p192 = L.secp192r1 = L.prime192v1, L.p384 = L.secp384r1, L.p521 = L.secp521r1;
  function V(re) {
    this.curveType = L[re], this.curveType || (this.curveType = {
      name: re
    }), this.curve = new A.ec(this.curveType.name), this.keys = void 0;
  }
  V.prototype.generateKeys = function(re, ne) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(re, ne);
  }, V.prototype.computeSecret = function(re, ne, ie) {
    ne = ne || "utf8", Buffer$D.isBuffer(re) || (re = new Buffer$D(re, ne));
    var pe = this.curve.keyFromPublic(re).getPublic(), nt = pe.mul(this.keys.getPrivate()).getX();
    return J(nt, ie, this.curveType.byteLength);
  }, V.prototype.getPublicKey = function(re, ne) {
    var ie = this.keys.getPublic(ne === "compressed", !0);
    return ne === "hybrid" && (ie[ie.length - 1] % 2 ? ie[0] = 7 : ie[0] = 6), J(ie, re);
  }, V.prototype.getPrivateKey = function(re) {
    return J(this.keys.getPrivate(), re);
  }, V.prototype.setPublicKey = function(re, ne) {
    return ne = ne || "utf8", Buffer$D.isBuffer(re) || (re = new Buffer$D(re, ne)), this.keys._importPublic(re), this;
  }, V.prototype.setPrivateKey = function(re, ne) {
    ne = ne || "utf8", Buffer$D.isBuffer(re) || (re = new Buffer$D(re, ne));
    var ie = new B(re);
    return ie = ie.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ie), this;
  };
  function J(re, ne, ie) {
    Array.isArray(re) || (re = re.toArray());
    var pe = new Buffer$D(re);
    if (ie && pe.length < ie) {
      var nt = new Buffer$D(ie - pe.length);
      nt.fill(0), pe = Buffer$D.concat([nt, pe]);
    }
    return ne ? pe.toString(ne) : pe;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$5 = safeBufferExports$1.Buffer, mgf$2 = function(A, B) {
  for (var L = Buffer$5.alloc(0), V = 0, J; L.length < B; )
    J = i2ops(V++), L = Buffer$5.concat([L, createHash$2("sha1").update(A).update(J).digest()]);
  return L.slice(0, B);
};
function i2ops(A) {
  var B = Buffer$5.allocUnsafe(4);
  return B.writeUInt32BE(A, 0), B;
}
var xor$2 = function A(B, L) {
  for (var V = B.length, J = -1; ++J < V; )
    B[J] ^= L[J];
  return B;
}, BN$2 = bnExports$1, Buffer$4 = safeBufferExports$1.Buffer;
function withPublic$2(A, B) {
  return Buffer$4.from(A.toRed(BN$2.mont(B.modulus)).redPow(new BN$2(B.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports$1, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$3 = safeBufferExports$1.Buffer, publicEncrypt = function A(B, L, V) {
  var J;
  B.padding ? J = B.padding : V ? J = 1 : J = 4;
  var re = parseKeys$1(B), ne;
  if (J === 4)
    ne = oaep$1(re, L);
  else if (J === 1)
    ne = pkcs1$1(re, L, V);
  else if (J === 3) {
    if (ne = new BN$1(L), ne.cmp(re.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return V ? crt$1(ne, re) : withPublic$1(ne, re);
};
function oaep$1(A, B) {
  var L = A.modulus.byteLength(), V = B.length, J = createHash$1("sha1").update(Buffer$3.alloc(0)).digest(), re = J.length, ne = 2 * re;
  if (V > L - ne - 2)
    throw new Error("message too long");
  var ie = Buffer$3.alloc(L - V - ne - 2), pe = L - re - 1, nt = randomBytes(re), oe = xor$1(Buffer$3.concat([J, ie, Buffer$3.alloc(1, 1), B], pe), mgf$1(nt, pe)), Ce = xor$1(nt, mgf$1(oe, re));
  return new BN$1(Buffer$3.concat([Buffer$3.alloc(1), Ce, oe], L));
}
function pkcs1$1(A, B, L) {
  var V = B.length, J = A.modulus.byteLength();
  if (V > J - 11)
    throw new Error("message too long");
  var re;
  return L ? re = Buffer$3.alloc(J - V - 3, 255) : re = nonZero(J - V - 3), new BN$1(Buffer$3.concat([Buffer$3.from([0, L ? 1 : 2]), re, Buffer$3.alloc(1), B], J));
}
function nonZero(A) {
  for (var B = Buffer$3.allocUnsafe(A), L = 0, V = randomBytes(A * 2), J = 0, re; L < A; )
    J === V.length && (V = randomBytes(A * 2), J = 0), re = V[J++], re && (B[L++] = re);
  return B;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports$1, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$2 = safeBufferExports$1.Buffer, privateDecrypt = function A(B, L, V) {
  var J;
  B.padding ? J = B.padding : V ? J = 1 : J = 4;
  var re = parseKeys(B), ne = re.modulus.byteLength();
  if (L.length > ne || new BN(L).cmp(re.modulus) >= 0)
    throw new Error("decryption error");
  var ie;
  V ? ie = withPublic(new BN(L), re) : ie = crt(L, re);
  var pe = Buffer$2.alloc(ne - ie.length);
  if (ie = Buffer$2.concat([pe, ie], ne), J === 4)
    return oaep(re, ie);
  if (J === 1)
    return pkcs1(re, ie, V);
  if (J === 3)
    return ie;
  throw new Error("unknown padding");
};
function oaep(A, B) {
  var L = A.modulus.byteLength(), V = createHash("sha1").update(Buffer$2.alloc(0)).digest(), J = V.length;
  if (B[0] !== 0)
    throw new Error("decryption error");
  var re = B.slice(1, J + 1), ne = B.slice(J + 1), ie = xor(re, mgf(ne, J)), pe = xor(ne, mgf(ie, L - J - 1));
  if (compare$1(V, pe.slice(0, J)))
    throw new Error("decryption error");
  for (var nt = J; pe[nt] === 0; )
    nt++;
  if (pe[nt++] !== 1)
    throw new Error("decryption error");
  return pe.slice(nt);
}
function pkcs1(A, B, L) {
  for (var V = B.slice(0, 2), J = 2, re = 0; B[J++] !== 0; )
    if (J >= B.length) {
      re++;
      break;
    }
  var ne = B.slice(2, J - 1);
  if ((V.toString("hex") !== "0002" && !L || V.toString("hex") !== "0001" && L) && re++, ne.length < 8 && re++, re)
    throw new Error("decryption error");
  return B.slice(J);
}
function compare$1(A, B) {
  A = Buffer$2.from(A), B = Buffer$2.from(B);
  var L = 0, V = A.length;
  A.length !== B.length && (L++, V = Math.min(A.length, B.length));
  for (var J = -1; ++J < V; )
    L += A[J] ^ B[J];
  return L;
}
(function(A) {
  A.publicEncrypt = publicEncrypt, A.privateDecrypt = privateDecrypt, A.privateEncrypt = function(L, V) {
    return A.publicEncrypt(L, V, !0);
  }, A.publicDecrypt = function(L, V) {
    return A.privateDecrypt(L, V, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$1, randombytes = browserExports, Buffer$1 = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(A, B) {
  if (typeof A != "number" || A !== A)
    throw new TypeError("offset must be a number");
  if (A > kMaxUint32 || A < 0)
    throw new TypeError("offset must be a uint32");
  if (A > kBufferMaxLength || A > B)
    throw new RangeError("offset out of range");
}
function assertSize(A, B, L) {
  if (typeof A != "number" || A !== A)
    throw new TypeError("size must be a number");
  if (A > kMaxUint32 || A < 0)
    throw new TypeError("size must be a uint32");
  if (A + B > L || A > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(A, B, L, V) {
  if (!Buffer$1.isBuffer(A) && !(A instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof B == "function")
    V = B, B = 0, L = A.length;
  else if (typeof L == "function")
    V = L, L = A.length - B;
  else if (typeof V != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(B, A.length), assertSize(L, B, A.length), actualFill(A, B, L, V);
}
function actualFill(A, B, L, V) {
  if (process$1.browser) {
    var J = A.buffer, re = new Uint8Array(J, B, L);
    if (crypto$2.getRandomValues(re), V) {
      process$1.nextTick(function() {
        V(null, A);
      });
      return;
    }
    return A;
  }
  if (V) {
    randombytes(L, function(ie, pe) {
      if (ie)
        return V(ie);
      pe.copy(A, B), V(null, A);
    });
    return;
  }
  var ne = randombytes(L);
  return ne.copy(A, B), A;
}
function randomFillSync(A, B, L) {
  if (typeof B > "u" && (B = 0), !Buffer$1.isBuffer(A) && !(A instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(B, A.length), L === void 0 && (L = A.length - B), assertSize(L, B, A.length), actualFill(A, B, L);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var A = algos, B = Object.keys(A), L = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(B);
  cryptoBrowserify.getHashes = function() {
    return L;
  };
  var V = browser$7;
  cryptoBrowserify.pbkdf2 = V.pbkdf2, cryptoBrowserify.pbkdf2Sync = V.pbkdf2Sync;
  var J = browser$6;
  cryptoBrowserify.Cipher = J.Cipher, cryptoBrowserify.createCipher = J.createCipher, cryptoBrowserify.Cipheriv = J.Cipheriv, cryptoBrowserify.createCipheriv = J.createCipheriv, cryptoBrowserify.Decipher = J.Decipher, cryptoBrowserify.createDecipher = J.createDecipher, cryptoBrowserify.Decipheriv = J.Decipheriv, cryptoBrowserify.createDecipheriv = J.createDecipheriv, cryptoBrowserify.getCiphers = J.getCiphers, cryptoBrowserify.listCiphers = J.listCiphers;
  var re = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = re.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = re.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = re.getDiffieHellman, cryptoBrowserify.createDiffieHellman = re.createDiffieHellman, cryptoBrowserify.DiffieHellman = re.DiffieHellman;
  var ne = requireBrowser$1();
  cryptoBrowserify.createSign = ne.createSign, cryptoBrowserify.Sign = ne.Sign, cryptoBrowserify.createVerify = ne.createVerify, cryptoBrowserify.Verify = ne.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var ie = browser$1;
  cryptoBrowserify.publicEncrypt = ie.publicEncrypt, cryptoBrowserify.privateEncrypt = ie.privateEncrypt, cryptoBrowserify.publicDecrypt = ie.publicDecrypt, cryptoBrowserify.privateDecrypt = ie.privateDecrypt;
  var pe = browser;
  return cryptoBrowserify.randomFill = pe.randomFill, cryptoBrowserify.randomFillSync = pe.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(A) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.utils = A.schnorr = A.verify = A.signSync = A.sign = A.getSharedSecret = A.recoverPublicKey = A.getPublicKey = A.Signature = A.Point = A.CURVE = void 0;
  const B = requireCryptoBrowserify(), L = BigInt(0), V = BigInt(1), J = BigInt(2), re = BigInt(3), ne = BigInt(8), ie = Object.freeze({
    a: L,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: V,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  A.CURVE = ie;
  const pe = (Gt, Lt) => (Gt + Lt / J) / Lt, nt = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Gt) {
      const { n: Lt } = ie, zt = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Et = -V * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), lt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), pt = zt, Ct = BigInt("0x100000000000000000000000000000000"), Wt = pe(pt * Gt, Lt), Jt = pe(-Et * Gt, Lt);
      let Qt = At(Gt - Wt * zt - Jt * lt, Lt), ur = At(-Wt * Et - Jt * pt, Lt);
      const pr = Qt > Ct, jt = ur > Ct;
      if (pr && (Qt = Lt - Qt), jt && (ur = Lt - ur), Qt > Ct || ur > Ct)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Gt);
      return { k1neg: pr, k1: Qt, k2neg: jt, k2: ur };
    }
  }, oe = 32, Ce = 32, at = 32, it = oe + 1, gt = 2 * oe + 1;
  function St(Gt) {
    const { a: Lt, b: zt } = ie, Et = At(Gt * Gt), lt = At(Et * Gt);
    return At(lt + Lt * Gt + zt);
  }
  const xt = ie.a === L;
  class Mt extends Error {
    constructor(Lt) {
      super(Lt);
    }
  }
  function bt(Gt) {
    if (!(Gt instanceof Tt))
      throw new TypeError("JacobianPoint expected");
  }
  class Tt {
    constructor(Lt, zt, Et) {
      this.x = Lt, this.y = zt, this.z = Et;
    }
    static fromAffine(Lt) {
      if (!(Lt instanceof Dt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Lt.equals(Dt.ZERO) ? Tt.ZERO : new Tt(Lt.x, Lt.y, V);
    }
    static toAffineBatch(Lt) {
      const zt = Pt(Lt.map((Et) => Et.z));
      return Lt.map((Et, lt) => Et.toAffine(zt[lt]));
    }
    static normalizeZ(Lt) {
      return Tt.toAffineBatch(Lt).map(Tt.fromAffine);
    }
    equals(Lt) {
      bt(Lt);
      const { x: zt, y: Et, z: lt } = this, { x: pt, y: Ct, z: Wt } = Lt, Jt = At(lt * lt), Qt = At(Wt * Wt), ur = At(zt * Qt), pr = At(pt * Jt), jt = At(At(Et * Wt) * Qt), nr = At(At(Ct * lt) * Jt);
      return ur === pr && jt === nr;
    }
    negate() {
      return new Tt(this.x, At(-this.y), this.z);
    }
    double() {
      const { x: Lt, y: zt, z: Et } = this, lt = At(Lt * Lt), pt = At(zt * zt), Ct = At(pt * pt), Wt = Lt + pt, Jt = At(J * (At(Wt * Wt) - lt - Ct)), Qt = At(re * lt), ur = At(Qt * Qt), pr = At(ur - J * Jt), jt = At(Qt * (Jt - pr) - ne * Ct), nr = At(J * zt * Et);
      return new Tt(pr, jt, nr);
    }
    add(Lt) {
      bt(Lt);
      const { x: zt, y: Et, z: lt } = this, { x: pt, y: Ct, z: Wt } = Lt;
      if (pt === L || Ct === L)
        return this;
      if (zt === L || Et === L)
        return Lt;
      const Jt = At(lt * lt), Qt = At(Wt * Wt), ur = At(zt * Qt), pr = At(pt * Jt), jt = At(At(Et * Wt) * Qt), nr = At(At(Ct * lt) * Jt), ar = At(pr - ur), lr = At(nr - jt);
      if (ar === L)
        return lr === L ? this.double() : Tt.ZERO;
      const Sr = At(ar * ar), xr = At(ar * Sr), vr = At(ur * Sr), Rr = At(lr * lr - xr - J * vr), jr = At(lr * (vr - Rr) - jt * xr), Lr = At(lt * Wt * ar);
      return new Tt(Rr, jr, Lr);
    }
    subtract(Lt) {
      return this.add(Lt.negate());
    }
    multiplyUnsafe(Lt) {
      const zt = Tt.ZERO;
      if (typeof Lt == "bigint" && Lt === L)
        return zt;
      let Et = ct(Lt);
      if (Et === V)
        return this;
      if (!xt) {
        let pr = zt, jt = this;
        for (; Et > L; )
          Et & V && (pr = pr.add(jt)), jt = jt.double(), Et >>= V;
        return pr;
      }
      let { k1neg: lt, k1: pt, k2neg: Ct, k2: Wt } = nt.splitScalar(Et), Jt = zt, Qt = zt, ur = this;
      for (; pt > L || Wt > L; )
        pt & V && (Jt = Jt.add(ur)), Wt & V && (Qt = Qt.add(ur)), ur = ur.double(), pt >>= V, Wt >>= V;
      return lt && (Jt = Jt.negate()), Ct && (Qt = Qt.negate()), Qt = new Tt(At(Qt.x * nt.beta), Qt.y, Qt.z), Jt.add(Qt);
    }
    precomputeWindow(Lt) {
      const zt = xt ? 128 / Lt + 1 : 256 / Lt + 1, Et = [];
      let lt = this, pt = lt;
      for (let Ct = 0; Ct < zt; Ct++) {
        pt = lt, Et.push(pt);
        for (let Wt = 1; Wt < 2 ** (Lt - 1); Wt++)
          pt = pt.add(lt), Et.push(pt);
        lt = pt.double();
      }
      return Et;
    }
    wNAF(Lt, zt) {
      !zt && this.equals(Tt.BASE) && (zt = Dt.BASE);
      const Et = zt && zt._WINDOW_SIZE || 1;
      if (256 % Et)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let lt = zt && qt.get(zt);
      lt || (lt = this.precomputeWindow(Et), zt && Et !== 1 && (lt = Tt.normalizeZ(lt), qt.set(zt, lt)));
      let pt = Tt.ZERO, Ct = Tt.BASE;
      const Wt = 1 + (xt ? 128 / Et : 256 / Et), Jt = 2 ** (Et - 1), Qt = BigInt(2 ** Et - 1), ur = 2 ** Et, pr = BigInt(Et);
      for (let jt = 0; jt < Wt; jt++) {
        const nr = jt * Jt;
        let ar = Number(Lt & Qt);
        Lt >>= pr, ar > Jt && (ar -= ur, Lt += V);
        const lr = nr, Sr = nr + Math.abs(ar) - 1, xr = jt % 2 !== 0, vr = ar < 0;
        ar === 0 ? Ct = Ct.add(It(xr, lt[lr])) : pt = pt.add(It(vr, lt[Sr]));
      }
      return { p: pt, f: Ct };
    }
    multiply(Lt, zt) {
      let Et = ct(Lt), lt, pt;
      if (xt) {
        const { k1neg: Ct, k1: Wt, k2neg: Jt, k2: Qt } = nt.splitScalar(Et);
        let { p: ur, f: pr } = this.wNAF(Wt, zt), { p: jt, f: nr } = this.wNAF(Qt, zt);
        ur = It(Ct, ur), jt = It(Jt, jt), jt = new Tt(At(jt.x * nt.beta), jt.y, jt.z), lt = ur.add(jt), pt = pr.add(nr);
      } else {
        const { p: Ct, f: Wt } = this.wNAF(Et, zt);
        lt = Ct, pt = Wt;
      }
      return Tt.normalizeZ([lt, pt])[0];
    }
    toAffine(Lt) {
      const { x: zt, y: Et, z: lt } = this, pt = this.equals(Tt.ZERO);
      Lt == null && (Lt = pt ? ne : Ht(lt));
      const Ct = Lt, Wt = At(Ct * Ct), Jt = At(Wt * Ct), Qt = At(zt * Wt), ur = At(Et * Jt), pr = At(lt * Ct);
      if (pt)
        return Dt.ZERO;
      if (pr !== V)
        throw new Error("invZ was invalid");
      return new Dt(Qt, ur);
    }
  }
  Tt.BASE = new Tt(ie.Gx, ie.Gy, V), Tt.ZERO = new Tt(L, V, L);
  function It(Gt, Lt) {
    const zt = Lt.negate();
    return Gt ? zt : Lt;
  }
  const qt = /* @__PURE__ */ new WeakMap();
  class Dt {
    constructor(Lt, zt) {
      this.x = Lt, this.y = zt;
    }
    _setWindowSize(Lt) {
      this._WINDOW_SIZE = Lt, qt.delete(this);
    }
    hasEvenY() {
      return this.y % J === L;
    }
    static fromCompressedHex(Lt) {
      const zt = Lt.length === 32, Et = st(zt ? Lt : Lt.subarray(1));
      if (!fr(Et))
        throw new Error("Point is not on curve");
      const lt = St(Et);
      let pt = Zt(lt);
      const Ct = (pt & V) === V;
      zt ? Ct && (pt = At(-pt)) : (Lt[0] & 1) === 1 !== Ct && (pt = At(-pt));
      const Wt = new Dt(Et, pt);
      return Wt.assertValidity(), Wt;
    }
    static fromUncompressedHex(Lt) {
      const zt = st(Lt.subarray(1, oe + 1)), Et = st(Lt.subarray(oe + 1, oe * 2 + 1)), lt = new Dt(zt, Et);
      return lt.assertValidity(), lt;
    }
    static fromHex(Lt) {
      const zt = yt(Lt), Et = zt.length, lt = zt[0];
      if (Et === oe)
        return this.fromCompressedHex(zt);
      if (Et === it && (lt === 2 || lt === 3))
        return this.fromCompressedHex(zt);
      if (Et === gt && lt === 4)
        return this.fromUncompressedHex(zt);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${it} compressed bytes or ${gt} uncompressed bytes, not ${Et}`);
    }
    static fromPrivateKey(Lt) {
      return Dt.BASE.multiply(dr(Lt));
    }
    static fromSignature(Lt, zt, Et) {
      const { r: lt, s: pt } = wr(zt);
      if (![0, 1, 2, 3].includes(Et))
        throw new Error("Cannot recover: invalid recovery bit");
      const Ct = Vt(yt(Lt)), { n: Wt } = ie, Jt = Et === 2 || Et === 3 ? lt + Wt : lt, Qt = Ht(Jt, Wt), ur = At(-Ct * Qt, Wt), pr = At(pt * Qt, Wt), jt = Et & 1 ? "03" : "02", nr = Dt.fromHex(jt + Oe(Jt)), ar = Dt.BASE.multiplyAndAddUnsafe(nr, ur, pr);
      if (!ar)
        throw new Error("Cannot recover signature: point at infinify");
      return ar.assertValidity(), ar;
    }
    toRawBytes(Lt = !1) {
      return dt(this.toHex(Lt));
    }
    toHex(Lt = !1) {
      const zt = Oe(this.x);
      return Lt ? `${this.hasEvenY() ? "02" : "03"}${zt}` : `04${zt}${Oe(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Lt = "Point is not on elliptic curve", { x: zt, y: Et } = this;
      if (!fr(zt) || !fr(Et))
        throw new Error(Lt);
      const lt = At(Et * Et), pt = St(zt);
      if (At(lt - pt) !== L)
        throw new Error(Lt);
    }
    equals(Lt) {
      return this.x === Lt.x && this.y === Lt.y;
    }
    negate() {
      return new Dt(this.x, At(-this.y));
    }
    double() {
      return Tt.fromAffine(this).double().toAffine();
    }
    add(Lt) {
      return Tt.fromAffine(this).add(Tt.fromAffine(Lt)).toAffine();
    }
    subtract(Lt) {
      return this.add(Lt.negate());
    }
    multiply(Lt) {
      return Tt.fromAffine(this).multiply(Lt, this).toAffine();
    }
    multiplyAndAddUnsafe(Lt, zt, Et) {
      const lt = Tt.fromAffine(this), pt = zt === L || zt === V || this !== Dt.BASE ? lt.multiplyUnsafe(zt) : lt.multiply(zt), Ct = Tt.fromAffine(Lt).multiplyUnsafe(Et), Wt = pt.add(Ct);
      return Wt.equals(Tt.ZERO) ? void 0 : Wt.toAffine();
    }
  }
  A.Point = Dt, Dt.BASE = new Dt(ie.Gx, ie.Gy), Dt.ZERO = new Dt(L, L);
  function Xt(Gt) {
    return Number.parseInt(Gt[0], 16) >= 8 ? "00" + Gt : Gt;
  }
  function Bt(Gt) {
    if (Gt.length < 2 || Gt[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${rt(Gt)}`);
    const Lt = Gt[1], zt = Gt.subarray(2, Lt + 2);
    if (!Lt || zt.length !== Lt)
      throw new Error("Invalid signature integer: wrong length");
    if (zt[0] === 0 && zt[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: st(zt), left: Gt.subarray(Lt + 2) };
  }
  function mt(Gt) {
    if (Gt.length < 2 || Gt[0] != 48)
      throw new Error(`Invalid signature tag: ${rt(Gt)}`);
    if (Gt[1] !== Gt.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Lt, left: zt } = Bt(Gt.subarray(2)), { data: Et, left: lt } = Bt(zt);
    if (lt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${rt(lt)}`);
    return { r: Lt, s: Et };
  }
  class Ot {
    constructor(Lt, zt) {
      this.r = Lt, this.s = zt, this.assertValidity();
    }
    static fromCompact(Lt) {
      const zt = Lt instanceof Uint8Array, Et = "Signature.fromCompact";
      if (typeof Lt != "string" && !zt)
        throw new TypeError(`${Et}: Expected string or Uint8Array`);
      const lt = zt ? rt(Lt) : Lt;
      if (lt.length !== 128)
        throw new Error(`${Et}: Expected 64-byte hex`);
      return new Ot(ht(lt.slice(0, 64)), ht(lt.slice(64, 128)));
    }
    static fromDER(Lt) {
      const zt = Lt instanceof Uint8Array;
      if (typeof Lt != "string" && !zt)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Et, s: lt } = mt(zt ? Lt : dt(Lt));
      return new Ot(Et, lt);
    }
    static fromHex(Lt) {
      return this.fromDER(Lt);
    }
    assertValidity() {
      const { r: Lt, s: zt } = this;
      if (!er(Lt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!er(zt))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Lt = ie.n >> V;
      return this.s > Lt;
    }
    normalizeS() {
      return this.hasHighS() ? new Ot(this.r, At(-this.s, ie.n)) : this;
    }
    toDERRawBytes() {
      return dt(this.toDERHex());
    }
    toDERHex() {
      const Lt = Xt(ut(this.s)), zt = Xt(ut(this.r)), Et = Lt.length / 2, lt = zt.length / 2, pt = ut(Et), Ct = ut(lt);
      return `30${ut(lt + Et + 4)}02${Ct}${zt}02${pt}${Lt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return dt(this.toCompactHex());
    }
    toCompactHex() {
      return Oe(this.r) + Oe(this.s);
    }
  }
  A.Signature = Ot;
  function wt(...Gt) {
    if (!Gt.every((Et) => Et instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Gt.length === 1)
      return Gt[0];
    const Lt = Gt.reduce((Et, lt) => Et + lt.length, 0), zt = new Uint8Array(Lt);
    for (let Et = 0, lt = 0; Et < Gt.length; Et++) {
      const pt = Gt[Et];
      zt.set(pt, lt), lt += pt.length;
    }
    return zt;
  }
  const ke = Array.from({ length: 256 }, (Gt, Lt) => Lt.toString(16).padStart(2, "0"));
  function rt(Gt) {
    if (!(Gt instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Lt = "";
    for (let zt = 0; zt < Gt.length; zt++)
      Lt += ke[Gt[zt]];
    return Lt;
  }
  const ce = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Oe(Gt) {
    if (typeof Gt != "bigint")
      throw new Error("Expected bigint");
    if (!(L <= Gt && Gt < ce))
      throw new Error("Expected number 0 <= n < 2^256");
    return Gt.toString(16).padStart(64, "0");
  }
  function ot(Gt) {
    const Lt = dt(Oe(Gt));
    if (Lt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Lt;
  }
  function ut(Gt) {
    const Lt = Gt.toString(16);
    return Lt.length & 1 ? `0${Lt}` : Lt;
  }
  function ht(Gt) {
    if (typeof Gt != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Gt);
    return BigInt(`0x${Gt}`);
  }
  function dt(Gt) {
    if (typeof Gt != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Gt);
    if (Gt.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Gt.length);
    const Lt = new Uint8Array(Gt.length / 2);
    for (let zt = 0; zt < Lt.length; zt++) {
      const Et = zt * 2, lt = Gt.slice(Et, Et + 2), pt = Number.parseInt(lt, 16);
      if (Number.isNaN(pt) || pt < 0)
        throw new Error("Invalid byte sequence");
      Lt[zt] = pt;
    }
    return Lt;
  }
  function st(Gt) {
    return ht(rt(Gt));
  }
  function yt(Gt) {
    return Gt instanceof Uint8Array ? Uint8Array.from(Gt) : dt(Gt);
  }
  function ct(Gt) {
    if (typeof Gt == "number" && Number.isSafeInteger(Gt) && Gt > 0)
      return BigInt(Gt);
    if (typeof Gt == "bigint" && er(Gt))
      return Gt;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function At(Gt, Lt = ie.P) {
    const zt = Gt % Lt;
    return zt >= L ? zt : Lt + zt;
  }
  function Kt(Gt, Lt) {
    const { P: zt } = ie;
    let Et = Gt;
    for (; Lt-- > L; )
      Et *= Et, Et %= zt;
    return Et;
  }
  function Zt(Gt) {
    const { P: Lt } = ie, zt = BigInt(6), Et = BigInt(11), lt = BigInt(22), pt = BigInt(23), Ct = BigInt(44), Wt = BigInt(88), Jt = Gt * Gt * Gt % Lt, Qt = Jt * Jt * Gt % Lt, ur = Kt(Qt, re) * Qt % Lt, pr = Kt(ur, re) * Qt % Lt, jt = Kt(pr, J) * Jt % Lt, nr = Kt(jt, Et) * jt % Lt, ar = Kt(nr, lt) * nr % Lt, lr = Kt(ar, Ct) * ar % Lt, Sr = Kt(lr, Wt) * lr % Lt, xr = Kt(Sr, Ct) * ar % Lt, vr = Kt(xr, re) * Qt % Lt, Rr = Kt(vr, pt) * nr % Lt, jr = Kt(Rr, zt) * Jt % Lt, Lr = Kt(jr, J);
    if (Lr * Lr % Lt !== Gt)
      throw new Error("Cannot find square root");
    return Lr;
  }
  function Ht(Gt, Lt = ie.P) {
    if (Gt === L || Lt <= L)
      throw new Error(`invert: expected positive integers, got n=${Gt} mod=${Lt}`);
    let zt = At(Gt, Lt), Et = Lt, lt = L, pt = V;
    for (; zt !== L; ) {
      const Wt = Et / zt, Jt = Et % zt, Qt = lt - pt * Wt;
      Et = zt, zt = Jt, lt = pt, pt = Qt;
    }
    if (Et !== V)
      throw new Error("invert: does not exist");
    return At(lt, Lt);
  }
  function Pt(Gt, Lt = ie.P) {
    const zt = new Array(Gt.length), Et = Gt.reduce((pt, Ct, Wt) => Ct === L ? pt : (zt[Wt] = pt, At(pt * Ct, Lt)), V), lt = Ht(Et, Lt);
    return Gt.reduceRight((pt, Ct, Wt) => Ct === L ? pt : (zt[Wt] = At(pt * zt[Wt], Lt), At(pt * Ct, Lt)), lt), zt;
  }
  function kt(Gt) {
    const Lt = Gt.length * 8 - Ce * 8, zt = st(Gt);
    return Lt > 0 ? zt >> BigInt(Lt) : zt;
  }
  function Vt(Gt, Lt = !1) {
    const zt = kt(Gt);
    if (Lt)
      return zt;
    const { n: Et } = ie;
    return zt >= Et ? zt - Et : zt;
  }
  let tr, Nt;
  class Ft {
    constructor(Lt, zt) {
      if (this.hashLen = Lt, this.qByteLen = zt, typeof Lt != "number" || Lt < 2)
        throw new Error("hashLen must be a number");
      if (typeof zt != "number" || zt < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Lt).fill(1), this.k = new Uint8Array(Lt).fill(0), this.counter = 0;
    }
    hmac(...Lt) {
      return A.utils.hmacSha256(this.k, ...Lt);
    }
    hmacSync(...Lt) {
      return Nt(this.k, ...Lt);
    }
    checkSync() {
      if (typeof Nt != "function")
        throw new Mt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Lt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Lt), this.v = await this.hmac(this.v), Lt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Lt), this.v = await this.hmac(this.v));
    }
    reseedSync(Lt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Lt), this.v = this.hmacSync(this.v), Lt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Lt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Lt = 0;
      const zt = [];
      for (; Lt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Et = this.v.slice();
        zt.push(Et), Lt += this.v.length;
      }
      return wt(...zt);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Lt = 0;
      const zt = [];
      for (; Lt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Et = this.v.slice();
        zt.push(Et), Lt += this.v.length;
      }
      return wt(...zt);
    }
  }
  function er(Gt) {
    return L < Gt && Gt < ie.n;
  }
  function fr(Gt) {
    return L < Gt && Gt < ie.P;
  }
  function cr(Gt, Lt, zt, Et = !0) {
    const { n: lt } = ie, pt = Vt(Gt, !0);
    if (!er(pt))
      return;
    const Ct = Ht(pt, lt), Wt = Dt.BASE.multiply(pt), Jt = At(Wt.x, lt);
    if (Jt === L)
      return;
    const Qt = At(Ct * At(Lt + zt * Jt, lt), lt);
    if (Qt === L)
      return;
    let ur = new Ot(Jt, Qt), pr = (Wt.x === ur.r ? 0 : 2) | Number(Wt.y & V);
    return Et && ur.hasHighS() && (ur = ur.normalizeS(), pr ^= 1), { sig: ur, recovery: pr };
  }
  function dr(Gt) {
    let Lt;
    if (typeof Gt == "bigint")
      Lt = Gt;
    else if (typeof Gt == "number" && Number.isSafeInteger(Gt) && Gt > 0)
      Lt = BigInt(Gt);
    else if (typeof Gt == "string") {
      if (Gt.length !== 2 * Ce)
        throw new Error("Expected 32 bytes of private key");
      Lt = ht(Gt);
    } else if (Gt instanceof Uint8Array) {
      if (Gt.length !== Ce)
        throw new Error("Expected 32 bytes of private key");
      Lt = st(Gt);
    } else
      throw new TypeError("Expected valid private key");
    if (!er(Lt))
      throw new Error("Expected private key: 0 < key < n");
    return Lt;
  }
  function br(Gt) {
    return Gt instanceof Dt ? (Gt.assertValidity(), Gt) : Dt.fromHex(Gt);
  }
  function wr(Gt) {
    if (Gt instanceof Ot)
      return Gt.assertValidity(), Gt;
    try {
      return Ot.fromDER(Gt);
    } catch {
      return Ot.fromCompact(Gt);
    }
  }
  function or(Gt, Lt = !1) {
    return Dt.fromPrivateKey(Gt).toRawBytes(Lt);
  }
  A.getPublicKey = or;
  function Nr(Gt, Lt, zt, Et = !1) {
    return Dt.fromSignature(Gt, Lt, zt).toRawBytes(Et);
  }
  A.recoverPublicKey = Nr;
  function Br(Gt) {
    const Lt = Gt instanceof Uint8Array, zt = typeof Gt == "string", Et = (Lt || zt) && Gt.length;
    return Lt ? Et === it || Et === gt : zt ? Et === it * 2 || Et === gt * 2 : Gt instanceof Dt;
  }
  function Tr(Gt, Lt, zt = !1) {
    if (Br(Gt))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Br(Lt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Et = br(Lt);
    return Et.assertValidity(), Et.multiply(dr(Gt)).toRawBytes(zt);
  }
  A.getSharedSecret = Tr;
  function Mr(Gt) {
    const Lt = Gt.length > oe ? Gt.slice(0, oe) : Gt;
    return st(Lt);
  }
  function _r(Gt) {
    const Lt = Mr(Gt), zt = At(Lt, ie.n);
    return kr(zt < L ? Lt : zt);
  }
  function kr(Gt) {
    return ot(Gt);
  }
  function Fr(Gt, Lt, zt) {
    if (Gt == null)
      throw new Error(`sign: expected valid message hash, not "${Gt}"`);
    const Et = yt(Gt), lt = dr(Lt), pt = [kr(lt), _r(Et)];
    if (zt != null) {
      zt === !0 && (zt = A.utils.randomBytes(oe));
      const Jt = yt(zt);
      if (Jt.length !== oe)
        throw new Error(`sign: Expected ${oe} bytes of extra data`);
      pt.push(Jt);
    }
    const Ct = wt(...pt), Wt = Mr(Et);
    return { seed: Ct, m: Wt, d: lt };
  }
  function Ar(Gt, Lt) {
    const { sig: zt, recovery: Et } = Gt, { der: lt, recovered: pt } = Object.assign({ canonical: !0, der: !0 }, Lt), Ct = lt ? zt.toDERRawBytes() : zt.toCompactRawBytes();
    return pt ? [Ct, Et] : Ct;
  }
  async function Cr(Gt, Lt, zt = {}) {
    const { seed: Et, m: lt, d: pt } = Fr(Gt, Lt, zt.extraEntropy), Ct = new Ft(at, Ce);
    await Ct.reseed(Et);
    let Wt;
    for (; !(Wt = cr(await Ct.generate(), lt, pt, zt.canonical)); )
      await Ct.reseed();
    return Ar(Wt, zt);
  }
  A.sign = Cr;
  function Dr(Gt, Lt, zt = {}) {
    const { seed: Et, m: lt, d: pt } = Fr(Gt, Lt, zt.extraEntropy), Ct = new Ft(at, Ce);
    Ct.reseedSync(Et);
    let Wt;
    for (; !(Wt = cr(Ct.generateSync(), lt, pt, zt.canonical)); )
      Ct.reseedSync();
    return Ar(Wt, zt);
  }
  A.signSync = Dr;
  const Rt = { strict: !0 };
  function vt(Gt, Lt, zt, Et = Rt) {
    let lt;
    try {
      lt = wr(Gt), Lt = yt(Lt);
    } catch {
      return !1;
    }
    const { r: pt, s: Ct } = lt;
    if (Et.strict && lt.hasHighS())
      return !1;
    const Wt = Vt(Lt);
    let Jt;
    try {
      Jt = br(zt);
    } catch {
      return !1;
    }
    const { n: Qt } = ie, ur = Ht(Ct, Qt), pr = At(Wt * ur, Qt), jt = At(pt * ur, Qt), nr = Dt.BASE.multiplyAndAddUnsafe(Jt, pr, jt);
    return nr ? At(nr.x, Qt) === pt : !1;
  }
  A.verify = vt;
  function $t(Gt) {
    return At(st(Gt), ie.n);
  }
  class Ut {
    constructor(Lt, zt) {
      this.r = Lt, this.s = zt, this.assertValidity();
    }
    static fromHex(Lt) {
      const zt = yt(Lt);
      if (zt.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${zt.length}`);
      const Et = st(zt.subarray(0, 32)), lt = st(zt.subarray(32, 64));
      return new Ut(Et, lt);
    }
    assertValidity() {
      const { r: Lt, s: zt } = this;
      if (!fr(Lt) || !er(zt))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Oe(this.r) + Oe(this.s);
    }
    toRawBytes() {
      return dt(this.toHex());
    }
  }
  function Yt(Gt) {
    return Dt.fromPrivateKey(Gt).toRawX();
  }
  class rr {
    constructor(Lt, zt, Et = A.utils.randomBytes()) {
      if (Lt == null)
        throw new TypeError(`sign: Expected valid message, not "${Lt}"`);
      this.m = yt(Lt);
      const { x: lt, scalar: pt } = this.getScalar(dr(zt));
      if (this.px = lt, this.d = pt, this.rand = yt(Et), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Lt) {
      const zt = Dt.fromPrivateKey(Lt), Et = zt.hasEvenY() ? Lt : ie.n - Lt;
      return { point: zt, scalar: Et, x: zt.toRawX() };
    }
    initNonce(Lt, zt) {
      return ot(Lt ^ st(zt));
    }
    finalizeNonce(Lt) {
      const zt = At(st(Lt), ie.n);
      if (zt === L)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Et, x: lt, scalar: pt } = this.getScalar(zt);
      return { R: Et, rx: lt, k: pt };
    }
    finalizeSig(Lt, zt, Et, lt) {
      return new Ut(Lt.x, At(zt + Et * lt, ie.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Lt, d: zt, px: Et, rand: lt } = this, pt = A.utils.taggedHash, Ct = this.initNonce(zt, await pt(Or.aux, lt)), { R: Wt, rx: Jt, k: Qt } = this.finalizeNonce(await pt(Or.nonce, Ct, Et, Lt)), ur = $t(await pt(Or.challenge, Jt, Et, Lt)), pr = this.finalizeSig(Wt, Qt, ur, zt);
      return await Pr(pr, Lt, Et) || this.error(), pr;
    }
    calcSync() {
      const { m: Lt, d: zt, px: Et, rand: lt } = this, pt = A.utils.taggedHashSync, Ct = this.initNonce(zt, pt(Or.aux, lt)), { R: Wt, rx: Jt, k: Qt } = this.finalizeNonce(pt(Or.nonce, Ct, Et, Lt)), ur = $t(pt(Or.challenge, Jt, Et, Lt)), pr = this.finalizeSig(Wt, Qt, ur, zt);
      return $r(pr, Lt, Et) || this.error(), pr;
    }
  }
  async function ir(Gt, Lt, zt) {
    return new rr(Gt, Lt, zt).calc();
  }
  function gr(Gt, Lt, zt) {
    return new rr(Gt, Lt, zt).calcSync();
  }
  function Ir(Gt, Lt, zt) {
    const Et = Gt instanceof Ut, lt = Et ? Gt : Ut.fromHex(Gt);
    return Et && lt.assertValidity(), {
      ...lt,
      m: yt(Lt),
      P: br(zt)
    };
  }
  function yr(Gt, Lt, zt, Et) {
    const lt = Dt.BASE.multiplyAndAddUnsafe(Lt, dr(zt), At(-Et, ie.n));
    return !(!lt || !lt.hasEvenY() || lt.x !== Gt);
  }
  async function Pr(Gt, Lt, zt) {
    try {
      const { r: Et, s: lt, m: pt, P: Ct } = Ir(Gt, Lt, zt), Wt = $t(await A.utils.taggedHash(Or.challenge, ot(Et), Ct.toRawX(), pt));
      return yr(Et, Ct, lt, Wt);
    } catch {
      return !1;
    }
  }
  function $r(Gt, Lt, zt) {
    try {
      const { r: Et, s: lt, m: pt, P: Ct } = Ir(Gt, Lt, zt), Wt = $t(A.utils.taggedHashSync(Or.challenge, ot(Et), Ct.toRawX(), pt));
      return yr(Et, Ct, lt, Wt);
    } catch (Et) {
      if (Et instanceof Mt)
        throw Et;
      return !1;
    }
  }
  A.schnorr = {
    Signature: Ut,
    getPublicKey: Yt,
    sign: ir,
    verify: Pr,
    signSync: gr,
    verifySync: $r
  }, Dt.BASE._setWindowSize(8);
  const Er = {
    node: B,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Or = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Ur = {};
  A.utils = {
    bytesToHex: rt,
    hexToBytes: dt,
    concatBytes: wt,
    mod: At,
    invert: Ht,
    isValidPrivateKey(Gt) {
      try {
        return dr(Gt), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: ot,
    _normalizePrivateKey: dr,
    hashToPrivateKey: (Gt) => {
      Gt = yt(Gt);
      const Lt = Ce + 8;
      if (Gt.length < Lt || Gt.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const zt = At(st(Gt), ie.n - V) + V;
      return ot(zt);
    },
    randomBytes: (Gt = 32) => {
      if (Er.web)
        return Er.web.getRandomValues(new Uint8Array(Gt));
      if (Er.node) {
        const { randomBytes: Lt } = Er.node;
        return Uint8Array.from(Lt(Gt));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => A.utils.hashToPrivateKey(A.utils.randomBytes(Ce + 8)),
    precompute(Gt = 8, Lt = Dt.BASE) {
      const zt = Lt === Dt.BASE ? Lt : new Dt(Lt.x, Lt.y);
      return zt._setWindowSize(Gt), zt.multiply(re), zt;
    },
    sha256: async (...Gt) => {
      if (Er.web) {
        const Lt = await Er.web.subtle.digest("SHA-256", wt(...Gt));
        return new Uint8Array(Lt);
      } else if (Er.node) {
        const { createHash: Lt } = Er.node, zt = Lt("sha256");
        return Gt.forEach((Et) => zt.update(Et)), Uint8Array.from(zt.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Gt, ...Lt) => {
      if (Er.web) {
        const zt = await Er.web.subtle.importKey("raw", Gt, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Et = wt(...Lt), lt = await Er.web.subtle.sign("HMAC", zt, Et);
        return new Uint8Array(lt);
      } else if (Er.node) {
        const { createHmac: zt } = Er.node, Et = zt("sha256", Gt);
        return Lt.forEach((lt) => Et.update(lt)), Uint8Array.from(Et.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Gt, ...Lt) => {
      let zt = Ur[Gt];
      if (zt === void 0) {
        const Et = await A.utils.sha256(Uint8Array.from(Gt, (lt) => lt.charCodeAt(0)));
        zt = wt(Et, Et), Ur[Gt] = zt;
      }
      return A.utils.sha256(zt, ...Lt);
    },
    taggedHashSync: (Gt, ...Lt) => {
      if (typeof tr != "function")
        throw new Mt("sha256Sync is undefined, you need to set it");
      let zt = Ur[Gt];
      if (zt === void 0) {
        const Et = tr(Uint8Array.from(Gt, (lt) => lt.charCodeAt(0)));
        zt = wt(Et, Et), Ur[Gt] = zt;
      }
      return tr(zt, ...Lt);
    },
    _JacobianPoint: Tt
  }, Object.defineProperties(A.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return tr;
      },
      set(Gt) {
        tr || (tr = Gt);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Nt;
      },
      set(Gt) {
        Nt || (Nt = Gt);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(A) {
  return (A / 8 | 0) + (A % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(A) {
  const B = paramBytesForAlg[A];
  if (B)
    return B;
  throw new Error(`Unknown algorithm "${A}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(A) {
  if (A instanceof Uint8Array)
    return A;
  if (typeof A == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(A));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(A, B) {
  const L = signatureAsBytes(A), V = getParamBytesForAlg(B), J = V + 1, re = L.length;
  let ne = 0;
  if (L[ne++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ie = L[ne++];
  if (ie === (MAX_OCTET | 1) && (ie = L[ne++]), re - ne < ie)
    throw new Error(`"seq" specified length of "${ie}", only "${re - ne}" remaining`);
  if (L[ne++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const pe = L[ne++];
  if (re - ne - 2 < pe)
    throw new Error(`"r" specified length of "${pe}", only "${re - ne - 2}" available`);
  if (J < pe)
    throw new Error(`"r" specified length of "${pe}", max of "${J}" is acceptable`);
  const nt = ne;
  if (ne += pe, L[ne++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const oe = L[ne++];
  if (re - ne !== oe)
    throw new Error(`"s" specified length of "${oe}", expected "${re - ne}"`);
  if (J < oe)
    throw new Error(`"s" specified length of "${oe}", max of "${J}" is acceptable`);
  const Ce = ne;
  if (ne += oe, ne !== re)
    throw new Error(`Expected to consume entire array, but "${re - ne}" bytes remain`);
  const at = V - pe, it = V - oe, gt = new Uint8Array(at + pe + it + oe);
  for (ne = 0; ne < at; ++ne)
    gt[ne] = 0;
  gt.set(L.subarray(nt + Math.max(-at, 0), nt + pe), ne), ne = V;
  for (const St = ne; ne < St + it; ++ne)
    gt[ne] = 0;
  return gt.set(L.subarray(Ce + Math.max(-it, 0), Ce + oe), ne), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(gt));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(A, B, L) {
  let V = 0;
  for (; B + V < L && A[B + V] === 0; )
    ++V;
  return A[B + V] >= MAX_OCTET && --V, V;
}
function joseToDer(A, B) {
  A = signatureAsBytes(A);
  const L = getParamBytesForAlg(B), V = A.length;
  if (V !== L * 2)
    throw new TypeError(`"${B}" signatures must be "${L * 2}" bytes, saw "${V}"`);
  const J = countPadding(A, 0, L), re = countPadding(A, L, A.length), ne = L - J, ie = L - re, pe = 2 + ne + 1 + 1 + ie, nt = pe < MAX_OCTET, oe = new Uint8Array((nt ? 2 : 3) + pe);
  let Ce = 0;
  return oe[Ce++] = ENCODED_TAG_SEQ, nt ? oe[Ce++] = pe : (oe[Ce++] = MAX_OCTET | 1, oe[Ce++] = pe & 255), oe[Ce++] = ENCODED_TAG_INT, oe[Ce++] = ne, J < 0 ? (oe[Ce++] = 0, oe.set(A.subarray(0, L), Ce), Ce += L) : (oe.set(A.subarray(J, L), Ce), Ce += L - J), oe[Ce++] = ENCODED_TAG_INT, oe[Ce++] = ie, re < 0 ? (oe[Ce++] = 0, oe.set(A.subarray(L), Ce)) : oe.set(A.subarray(L + re), Ce), oe;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(B) {
    super(), this.name = "MissingParametersError", this.message = B || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(B) {
    super(), this.name = "InvalidTokenError", this.message = B || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$p;
secp.utils.hmacSha256Sync = (A, ...B) => {
  const L = hmac_1.hmac.create(sha256_1$3.sha256, A);
  return B.forEach((V) => L.update(V)), L.digest();
};
class SECP256K1Client {
  static derivePublicKey(B, L = !0) {
    return B.length === 66 && (B = B.slice(0, 64)), B.length < 64 && (B = B.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(B, L));
  }
  static signHash(B, L, V = "jose") {
    if (!B || !L)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const J = secp.signSync(B, L.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (V === "der")
      return (0, utils_1$2.bytesToHex)(J);
    if (V === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(J, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(B) {
    return (0, ecdsaSigFormatter_1.joseToDer)(B, "ES256");
  }
  static verifyHash(B, L, V) {
    if (!B || !L || !V)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(L, B, V, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.cryptoClients = A.SECP256K1Client = void 0;
  const B = secp256k1$1;
  Object.defineProperty(A, "SECP256K1Client", { enumerable: !0, get: function() {
    return B.SECP256K1Client;
  } });
  const L = {
    ES256K: B.SECP256K1Client
  };
  A.cryptoClients = L;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, V) {
  function J(re) {
    return re instanceof L ? re : new L(function(ne) {
      ne(re);
    });
  }
  return new (L || (L = Promise))(function(re, ne) {
    function ie(oe) {
      try {
        nt(V.next(oe));
      } catch (Ce) {
        ne(Ce);
      }
    }
    function pe(oe) {
      try {
        nt(V.throw(oe));
      } catch (Ce) {
        ne(Ce);
      }
    }
    function nt(oe) {
      oe.done ? re(oe.value) : J(oe.value).then(ie, pe);
    }
    nt((V = V.apply(A, B || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(A) {
  return (0, sha256_1$2.sha256)(A);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(A) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const L = typeof A == "string" ? new TextEncoder().encode(A) : A, V = yield crypto.subtle.digest("SHA-256", L);
        return new Uint8Array(V);
      } else {
        const L = requireCryptoBrowserify();
        if (!L.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(L.createHash("sha256").update(A).digest());
      }
    } catch (B) {
      return console.log(B), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(A));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, V) {
  function J(re) {
    return re instanceof L ? re : new L(function(ne) {
      ne(re);
    });
  }
  return new (L || (L = Promise))(function(re, ne) {
    function ie(oe) {
      try {
        nt(V.next(oe));
      } catch (Ce) {
        ne(Ce);
      }
    }
    function pe(oe) {
      try {
        nt(V.throw(oe));
      } catch (Ce) {
        ne(Ce);
      }
    }
    function nt(oe) {
      oe.done ? re(oe.value) : J(oe.value).then(ie, pe);
    }
    nt((V = V.apply(A, B || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(A, B) {
  const L = [], V = base64url$2.encode(JSON.stringify(B));
  L.push(V);
  const J = base64url$2.encode(JSON.stringify(A));
  return L.push(J), L.join(".");
}
function createUnsecuredToken(A) {
  return createSigningInput(A, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof B != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (B = B.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(B))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[B], this.rawPrivateKey = L;
  }
  header(B = {}) {
    const L = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, L, B);
  }
  sign(B, L = !1, V = {}) {
    const J = this.header(V), re = createSigningInput(B, J), ne = (0, sha256_1$1.hashSha256)(re);
    return this.createWithSignedHash(B, L, J, re, ne);
  }
  signAsync(B, L = !1, V = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const J = this.header(V), re = createSigningInput(B, J), ne = yield (0, sha256_1$1.hashSha256Async)(re);
      return this.createWithSignedHash(B, L, J, re, ne);
    });
  }
  createWithSignedHash(B, L, V, J, re) {
    const ne = this.cryptoClient.signHash(re, this.rawPrivateKey);
    return L ? {
      header: [base64url$2.encode(JSON.stringify(V))],
      payload: JSON.stringify(B),
      signature: [ne]
    } : [J, ne].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof B != "string")
      throw "signing algorithm parameter must be a string";
    if (B = B.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(B))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[B], this.rawPublicKey = L;
  }
  verify(B) {
    return typeof B == "string" ? this.verifyCompact(B, !1) : typeof B == "object" ? this.verifyExpanded(B, !1) : !1;
  }
  verifyAsync(B) {
    return typeof B == "string" ? this.verifyCompact(B, !0) : typeof B == "object" ? this.verifyExpanded(B, !0) : Promise.resolve(!1);
  }
  verifyCompact(B, L) {
    const V = B.split("."), J = V[0] + "." + V[1], re = (ne) => {
      const ie = this.cryptoClient.loadSignature(V[2]);
      return this.cryptoClient.verifyHash(ne, ie, this.rawPublicKey);
    };
    if (L)
      return (0, sha256_1.hashSha256Async)(J).then((ne) => re(ne));
    {
      const ne = (0, sha256_1.hashSha256)(J);
      return re(ne);
    }
  }
  verifyExpanded(B, L) {
    const V = [B.header.join("."), base64url$1.encode(B.payload)].join(".");
    let J = !0;
    const re = (ne) => (B.signature.map((ie) => {
      const pe = this.cryptoClient.loadSignature(ie);
      this.cryptoClient.verifyHash(ne, pe, this.rawPublicKey) || (J = !1);
    }), J);
    if (L)
      return (0, sha256_1.hashSha256Async)(V).then((ne) => re(ne));
    {
      const ne = (0, sha256_1.hashSha256)(V);
      return re(ne);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(A) {
  if (typeof A == "string") {
    const B = A.split("."), L = JSON.parse(base64url.decode(B[0])), V = JSON.parse(base64url.decode(B[1])), J = B[2];
    return {
      header: L,
      payload: V,
      signature: J
    };
  } else if (typeof A == "object") {
    if (typeof A.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let B = A.payload;
    A.payload[0] !== "{" && (B = base64url.decode(B));
    const L = [];
    return A.header.map((V) => {
      const J = JSON.parse(base64url.decode(V));
      L.push(J);
    }), {
      header: L,
      payload: JSON.parse(B),
      signature: A.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(A) {
  var B = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(V, J, re, ne) {
    ne === void 0 && (ne = re);
    var ie = Object.getOwnPropertyDescriptor(J, re);
    (!ie || ("get" in ie ? !J.__esModule : ie.writable || ie.configurable)) && (ie = { enumerable: !0, get: function() {
      return J[re];
    } }), Object.defineProperty(V, ne, ie);
  } : function(V, J, re, ne) {
    ne === void 0 && (ne = re), V[ne] = J[re];
  }), L = commonjsGlobal && commonjsGlobal.__exportStar || function(V, J) {
    for (var re in V) re !== "default" && !Object.prototype.hasOwnProperty.call(J, re) && B(J, V, re);
  };
  Object.defineProperty(A, "__esModule", { value: !0 }), L(signer, A), L(verifier, A), L(decode$i, A), L(errors$1, A), L(cryptoClients, A);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const A = Array(256).fill(-1);
  for (let B = 0; B < r.length; ++B) A[r.charCodeAt(B)] = B;
})();
var s, i, o, h$1 = (s = function(A, B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bech32m = B.bech32 = void 0;
  const L = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", V = {};
  for (let Ce = 0; Ce < 32; Ce++) {
    const at = L.charAt(Ce);
    V[at] = Ce;
  }
  function J(Ce) {
    const at = Ce >> 25;
    return (33554431 & Ce) << 5 ^ 996825010 & -(at >> 0 & 1) ^ 642813549 & -(at >> 1 & 1) ^ 513874426 & -(at >> 2 & 1) ^ 1027748829 & -(at >> 3 & 1) ^ 705979059 & -(at >> 4 & 1);
  }
  function re(Ce) {
    let at = 1;
    for (let it = 0; it < Ce.length; ++it) {
      const gt = Ce.charCodeAt(it);
      if (gt < 33 || gt > 126) return "Invalid prefix (" + Ce + ")";
      at = J(at) ^ gt >> 5;
    }
    at = J(at);
    for (let it = 0; it < Ce.length; ++it) {
      const gt = Ce.charCodeAt(it);
      at = J(at) ^ 31 & gt;
    }
    return at;
  }
  function ne(Ce, at, it, gt) {
    let St = 0, xt = 0;
    const Mt = (1 << it) - 1, bt = [];
    for (let Tt = 0; Tt < Ce.length; ++Tt) for (St = St << at | Ce[Tt], xt += at; xt >= it; ) xt -= it, bt.push(St >> xt & Mt);
    if (gt) xt > 0 && bt.push(St << it - xt & Mt);
    else {
      if (xt >= at) return "Excess padding";
      if (St << it - xt & Mt) return "Non-zero padding";
    }
    return bt;
  }
  function ie(Ce) {
    return ne(Ce, 8, 5, !0);
  }
  function pe(Ce) {
    const at = ne(Ce, 5, 8, !1);
    if (Array.isArray(at)) return at;
  }
  function nt(Ce) {
    const at = ne(Ce, 5, 8, !1);
    if (Array.isArray(at)) return at;
    throw new Error(at);
  }
  function oe(Ce) {
    let at;
    function it(gt, St) {
      if (St = St || 90, gt.length < 8) return gt + " too short";
      if (gt.length > St) return "Exceeds length limit";
      const xt = gt.toLowerCase(), Mt = gt.toUpperCase();
      if (gt !== xt && gt !== Mt) return "Mixed-case string " + gt;
      const bt = (gt = xt).lastIndexOf("1");
      if (bt === -1) return "No separator character for " + gt;
      if (bt === 0) return "Missing prefix for " + gt;
      const Tt = gt.slice(0, bt), It = gt.slice(bt + 1);
      if (It.length < 6) return "Data too short";
      let qt = re(Tt);
      if (typeof qt == "string") return qt;
      const Dt = [];
      for (let Xt = 0; Xt < It.length; ++Xt) {
        const Bt = It.charAt(Xt), mt = V[Bt];
        if (mt === void 0) return "Unknown character " + Bt;
        qt = J(qt) ^ mt, Xt + 6 >= It.length || Dt.push(mt);
      }
      return qt !== at ? "Invalid checksum for " + gt : { prefix: Tt, words: Dt };
    }
    return at = Ce === "bech32" ? 1 : 734539939, { decodeUnsafe: function(gt, St) {
      const xt = it(gt, St);
      if (typeof xt == "object") return xt;
    }, decode: function(gt, St) {
      const xt = it(gt, St);
      if (typeof xt == "object") return xt;
      throw new Error(xt);
    }, encode: function(gt, St, xt) {
      if (xt = xt || 90, gt.length + 7 + St.length > xt) throw new TypeError("Exceeds length limit");
      let Mt = re(gt = gt.toLowerCase());
      if (typeof Mt == "string") throw new Error(Mt);
      let bt = gt + "1";
      for (let Tt = 0; Tt < St.length; ++Tt) {
        const It = St[Tt];
        if (It >> 5) throw new Error("Non 5-bit word");
        Mt = J(Mt) ^ It, bt += L.charAt(It);
      }
      for (let Tt = 0; Tt < 6; ++Tt) Mt = J(Mt);
      Mt ^= at;
      for (let Tt = 0; Tt < 6; ++Tt) bt += L.charAt(Mt >> 5 * (5 - Tt) & 31);
      return bt;
    }, toWords: ie, fromWordsUnsafe: pe, fromWords: nt };
  }
  B.bech32 = oe("bech32"), B.bech32m = oe("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(A) {
  A.mainnet = "mainnet", A.testnet = "testnet", A.regtest = "regtest";
})(x || (x = {})), function(A) {
  A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
async function getProviderOrThrow(A) {
  var L;
  const B = await (A == null ? void 0 : A()) || ((L = window.XverseProviders) == null ? void 0 : L.BitcoinProvider) || window.BitcoinProvider;
  if (!B)
    throw new Error("No Bitcoin wallet installed");
  return B;
}
var BitcoinNetworkType = /* @__PURE__ */ ((A) => (A.Mainnet = "Mainnet", A.Testnet = "Testnet", A.Testnet4 = "Testnet4", A.Signet = "Signet", A.Regtest = "Regtest", A))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((A) => (A.Ordinals = "ordinals", A.Payment = "payment", A.Stacks = "stacks", A))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((A) => (A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr", A.stacks = "stacks", A))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), getAddress = async (A) => {
  var V, J;
  const B = await getProviderOrThrow(A.getProvider), { purposes: L } = A.payload;
  if (!L)
    throw new Error("Address purposes are required");
  try {
    const re = lib$1.createUnsecuredToken(A.payload), ne = await B.connect(re);
    (V = A.onFinish) == null || V.call(A, ne);
  } catch (re) {
    console.error("[Connect] Error during address request", re), (J = A.onCancel) == null || J.call(A);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((A) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((A) => (A.ECDSA = "ECDSA", A.BIP322 = "BIP322", A))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
async function waitForUnisatExtensionReady() {
  let A = 0;
  const B = 20;
  for (; A < B; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const L = await window.unisat.getAccounts();
        if (L && L.length > 0)
          return !0;
      } catch {
        break;
      }
    A += 1, await new Promise((L) => {
      setTimeout(L, 100);
    });
  }
  return !1;
}
const getXverseAddresses = async (A) => {
  var re;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((re = window.XverseProviders) == null ? void 0 : re.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const L = async () => window.XverseProviders.BitcoinProvider, V = [], J = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: BitcoinNetworkType.Testnet4
      }
    },
    getProvider: L,
    onFinish: (ne) => {
      if (!ne || !ne.addresses || ne.addresses.length !== 2)
        throw new BrowserWalletSigningError(
          "Failed to retrieve addresses using selected wallet"
        );
      ne.addresses.forEach((ie) => {
        const pe = getAddressFormat(ie.address, A);
        let nt = ie.publicKey;
        pe === "taproot" && (nt = Buffer$E.from(ie.publicKey, "hex").length === 33 ? nt : `02${nt}`), V.push({
          publicKey: nt,
          address: ie.address,
          format: pe
        });
      });
    },
    onCancel: () => {
      throw new BrowserWalletRequestCancelledByUserError();
    }
  };
  return await getAddress(J), V;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: A,
  wallet: B,
  chain: L = Chain.BITCOIN
}, { readOnly: V = !1 } = {}) => {
  switch (console.log("==>wallet", B), B) {
    case Wallet.UNISAT: {
      console.log("unisat1", A, B);
      const J = await getAddresses$3(A, L, { readOnly: V });
      if (!J || J.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const re = J[0];
      return {
        address: {
          ordinals: re.address,
          payments: re.address
        },
        publicKey: {
          ordinals: re.publicKey,
          payments: re.publicKey
        },
        format: {
          ordinals: re.format,
          payments: re.format
        }
      };
    }
    case Wallet.XVERSE: {
      console.log("xverse1", A, B);
      const J = await getXverseAddresses(A);
      if (console.log("xverse1", J), !J || J.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const re = J.find(
        (ie) => ie.format === "p2sh-p2wpkh" || ie.format === "segwit"
      );
      if (!re)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const ne = J.find(
        (ie) => ie.format === "taproot"
      );
      if (!ne)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return console.log("xverse2", ne, re), {
        address: {
          ordinals: ne.address,
          payments: re.address
        },
        publicKey: {
          ordinals: ne.publicKey,
          payments: re.publicKey
        },
        format: {
          ordinals: ne.format,
          payments: re.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const J = await getAddresses$2(A);
      if (!J || J.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const re = J.find(
        (ie) => ie.format === "segwit" || ie.format === "p2sh-p2wpkh"
      );
      if (!re)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const ne = J.find(
        (ie) => ie.format === "taproot"
      );
      if (!ne)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: ne.address,
          payments: re.address
        },
        publicKey: {
          ordinals: ne.publicKey,
          payments: re.publicKey
        },
        format: {
          ordinals: ne.format,
          payments: re.format
        }
      };
    }
    case Wallet.LEATHER: {
      const J = await getAddresses$1(A);
      if (!J || J.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const re = J.find(
        (ie) => ie.format === "segwit"
      );
      if (!re)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const ne = J.find(
        (ie) => ie.format === "taproot"
      );
      if (!ne)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: ne.address,
          payments: re.address
        },
        publicKey: {
          ordinals: ne.publicKey,
          payments: re.publicKey
        },
        format: {
          ordinals: ne.format,
          payments: re.format
        }
      };
    }
    case Wallet.OKX: {
      const J = await getAddresses(A);
      if (!J || J.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const re = J[0];
      return {
        address: {
          ordinals: re.address,
          payments: re.address
        },
        publicKey: {
          ordinals: re.publicKey,
          payments: re.publicKey
        },
        format: {
          ordinals: re.format,
          payments: re.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: A,
  onError: B
}) {
  const {
    updateAddress: L,
    network: V,
    updateWallet: J,
    updatePublicKey: re,
    updateFormat: ne,
    disconnectWallet: ie,
    address: pe,
    publicKey: nt,
    format: oe,
    wallet: Ce,
    chain: at
  } = useOrdConnect(), it = (St, xt) => {
    B(xt.message ?? xt.toString()), console.error(`Error while connecting to ${St} wallet`, xt), ie(), xt instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[St],
      "_blank",
      "noopener,noreferrer"
    );
  }, gt = async (St, { readOnly: xt = !1 } = {}) => {
    try {
      const { address: Mt, publicKey: bt, format: Tt } = await connectWallet(
        { network: V, wallet: St, chain: at },
        { readOnly: xt }
      );
      return L({
        ordinals: Mt.ordinals,
        payments: Mt.payments
      }), re({
        ordinals: bt.ordinals,
        payments: bt.payments
      }), J(St), ne({
        ordinals: Tt.ordinals,
        payments: Tt.payments
      }), A(), !0;
    } catch (Mt) {
      return it(St, Mt), !1;
    }
  };
  return useEffect(() => {
    if (console.log("connectedWallet", Ce), Ce !== Wallet.UNISAT) {
      console.log("connectedWallet", Ce);
      return;
    }
    let St = !0, xt = !1;
    const Mt = () => gt(Wallet.UNISAT);
    return pe && nt && oe && (async () => {
      const Tt = await waitForUnisatExtensionReady();
      if (St) {
        if (!Tt) {
          ie();
          return;
        }
        xt = await gt(Wallet.UNISAT, {
          readOnly: !0
        }), St && xt && window.unisat.addListener("accountsChanged", Mt);
      }
    })(), () => {
      St = !1, xt && window.unisat.removeListener("accountsChanged", Mt);
    };
  }, [Ce]), { connectWallet: gt };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: A,
  onConnect: B,
  icon: L,
  renderAvatar: V,
  isPreferred: J
}) {
  const re = isMobileUserAgent(), { wallet: ne, address: ie } = useOrdConnect(), [pe, nt] = useState(!1), oe = WALLET_TO_NAME[A], Ce = async () => {
    nt(!0);
    try {
      await B();
    } catch {
    }
    nt(!1);
  }, at = ne === A && ie.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Ce,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: L, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: oe }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: re ? "Available on app" : "" })
        ] }),
        ne === A && ie.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          V ? V(ie.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: re ? 12 : 16,
              variant: "beam",
              name: ie.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(ie.ordinals) })
        ] }) : null,
        !at && J ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        pe ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: re ? 20 : 24,
            height: re ? 20 : 24,
            alt: `${oe} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: re ? 20 : 24,
            height: re ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: A,
  closeModal: B,
  renderAvatar: L,
  preferredWallet: V,
  walletsOrder: J,
  visibleWallets: re
}) {
  const [ne, ie] = useState(""), { connectWallet: pe } = useConnect({
    onClose: B,
    onError: (it) => ie(it)
  }), { network: nt, chain: oe } = useOrdConnect(), Ce = isMobileUserAgent(), at = useMemo(() => {
    const gt = [
      {
        wallet: Wallet.OKX,
        onConnect: () => pe(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: Ce && nt !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => pe(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: Ce,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => pe(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => pe(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => pe(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: Ce,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((xt) => (re || []).includes(xt.wallet)).filter(
      (xt) => xt.chains.includes(oe) && !xt.hidden
    );
    return J ? gt.map((xt) => {
      const Mt = J.findIndex(
        (bt) => bt === xt.wallet
      );
      return Mt >= 0 ? { ...xt, order: Mt } : xt;
    }).sort((xt, Mt) => xt.order - Mt.order) : gt;
  }, [Ce, nt, J, pe, oe]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: A, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: B,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[oe],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: B,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: at.map((it, gt) => {
                  const St = gt === at.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: it.wallet,
                        onConnect: async () => {
                          ie("");
                          const xt = it.onConnect().then((bt) => (bt && ie(""), bt)), Mt = await Promise.race([
                            xt,
                            new Promise((bt) => {
                              setTimeout(() => bt("timeout"), 5e3);
                            })
                          ]);
                          return typeof Mt == "string" ? (ie(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), xt) : Mt;
                        },
                        icon: it.icon,
                        renderAvatar: L,
                        isPreferred: V === it.wallet
                      }
                    ),
                    !St && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, it.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: ne })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: A,
  onViewProfile: B,
  onChangeWalletClick: L,
  onDisconnectWalletClick: V,
  renderAvatar: J,
  preferredWallet: re,
  walletsOrder: ne
}) {
  const {
    address: ie,
    disconnectWallet: pe,
    network: nt,
    isModalOpen: oe,
    openModal: Ce,
    closeModal: at,
    visibleWallets: it
  } = useOrdConnect(), gt = useHasMounted(), St = () => A ? null : ie != null && ie.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ie.ordinals,
      network: nt,
      onViewProfile: B,
      onChangeWallet: () => {
        Ce(), L == null || L();
      },
      onDisconnectWallet: () => {
        pe(), V == null || V();
      },
      renderAvatar: J
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !gt, openModal: Ce });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    St(),
    gt ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: oe,
        closeModal: at,
        renderAvatar: J,
        preferredWallet: re,
        walletsOrder: ne,
        visibleWallets: it
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(A) {
  var B, L, V, J = bt.prototype = { constructor: bt, toString: null, valueOf: null }, re = new bt(1), ne = 20, ie = 4, pe = -7, nt = 21, oe = -1e7, Ce = 1e7, at = !1, it = 1, gt = 0, St = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, xt = "0123456789abcdefghijklmnopqrstuvwxyz", Mt = !0;
  function bt(Bt, mt) {
    var Ot, wt, ke, rt, ce, Oe, ot, ut, ht = this;
    if (!(ht instanceof bt)) return new bt(Bt, mt);
    if (mt == null) {
      if (Bt && Bt._isBigNumber === !0) {
        ht.s = Bt.s, !Bt.c || Bt.e > Ce ? ht.c = ht.e = null : Bt.e < oe ? ht.c = [ht.e = 0] : (ht.e = Bt.e, ht.c = Bt.c.slice());
        return;
      }
      if ((Oe = typeof Bt == "number") && Bt * 0 == 0) {
        if (ht.s = 1 / Bt < 0 ? (Bt = -Bt, -1) : 1, Bt === ~~Bt) {
          for (rt = 0, ce = Bt; ce >= 10; ce /= 10, rt++) ;
          rt > Ce ? ht.c = ht.e = null : (ht.e = rt, ht.c = [Bt]);
          return;
        }
        ut = String(Bt);
      } else {
        if (!isNumeric.test(ut = String(Bt))) return V(ht, ut, Oe);
        ht.s = ut.charCodeAt(0) == 45 ? (ut = ut.slice(1), -1) : 1;
      }
      (rt = ut.indexOf(".")) > -1 && (ut = ut.replace(".", "")), (ce = ut.search(/e/i)) > 0 ? (rt < 0 && (rt = ce), rt += +ut.slice(ce + 1), ut = ut.substring(0, ce)) : rt < 0 && (rt = ut.length);
    } else {
      if (intCheck(mt, 2, xt.length, "Base"), mt == 10 && Mt)
        return ht = new bt(Bt), Dt(ht, ne + ht.e + 1, ie);
      if (ut = String(Bt), Oe = typeof Bt == "number") {
        if (Bt * 0 != 0) return V(ht, ut, Oe, mt);
        if (ht.s = 1 / Bt < 0 ? (ut = ut.slice(1), -1) : 1, bt.DEBUG && ut.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Bt);
      } else
        ht.s = ut.charCodeAt(0) === 45 ? (ut = ut.slice(1), -1) : 1;
      for (Ot = xt.slice(0, mt), rt = ce = 0, ot = ut.length; ce < ot; ce++)
        if (Ot.indexOf(wt = ut.charAt(ce)) < 0) {
          if (wt == ".") {
            if (ce > rt) {
              rt = ot;
              continue;
            }
          } else if (!ke && (ut == ut.toUpperCase() && (ut = ut.toLowerCase()) || ut == ut.toLowerCase() && (ut = ut.toUpperCase()))) {
            ke = !0, ce = -1, rt = 0;
            continue;
          }
          return V(ht, String(Bt), Oe, mt);
        }
      Oe = !1, ut = L(ut, mt, 10, ht.s), (rt = ut.indexOf(".")) > -1 ? ut = ut.replace(".", "") : rt = ut.length;
    }
    for (ce = 0; ut.charCodeAt(ce) === 48; ce++) ;
    for (ot = ut.length; ut.charCodeAt(--ot) === 48; ) ;
    if (ut = ut.slice(ce, ++ot)) {
      if (ot -= ce, Oe && bt.DEBUG && ot > 15 && (Bt > MAX_SAFE_INTEGER$2 || Bt !== mathfloor(Bt)))
        throw Error(tooManyDigits + ht.s * Bt);
      if ((rt = rt - ce - 1) > Ce)
        ht.c = ht.e = null;
      else if (rt < oe)
        ht.c = [ht.e = 0];
      else {
        if (ht.e = rt, ht.c = [], ce = (rt + 1) % LOG_BASE, rt < 0 && (ce += LOG_BASE), ce < ot) {
          for (ce && ht.c.push(+ut.slice(0, ce)), ot -= LOG_BASE; ce < ot; )
            ht.c.push(+ut.slice(ce, ce += LOG_BASE));
          ce = LOG_BASE - (ut = ut.slice(ce)).length;
        } else
          ce -= ot;
        for (; ce--; ut += "0") ;
        ht.c.push(+ut);
      }
    } else
      ht.c = [ht.e = 0];
  }
  bt.clone = clone, bt.ROUND_UP = 0, bt.ROUND_DOWN = 1, bt.ROUND_CEIL = 2, bt.ROUND_FLOOR = 3, bt.ROUND_HALF_UP = 4, bt.ROUND_HALF_DOWN = 5, bt.ROUND_HALF_EVEN = 6, bt.ROUND_HALF_CEIL = 7, bt.ROUND_HALF_FLOOR = 8, bt.EUCLID = 9, bt.config = bt.set = function(Bt) {
    var mt, Ot;
    if (Bt != null)
      if (typeof Bt == "object") {
        if (Bt.hasOwnProperty(mt = "DECIMAL_PLACES") && (Ot = Bt[mt], intCheck(Ot, 0, MAX, mt), ne = Ot), Bt.hasOwnProperty(mt = "ROUNDING_MODE") && (Ot = Bt[mt], intCheck(Ot, 0, 8, mt), ie = Ot), Bt.hasOwnProperty(mt = "EXPONENTIAL_AT") && (Ot = Bt[mt], Ot && Ot.pop ? (intCheck(Ot[0], -1e9, 0, mt), intCheck(Ot[1], 0, MAX, mt), pe = Ot[0], nt = Ot[1]) : (intCheck(Ot, -1e9, MAX, mt), pe = -(nt = Ot < 0 ? -Ot : Ot))), Bt.hasOwnProperty(mt = "RANGE"))
          if (Ot = Bt[mt], Ot && Ot.pop)
            intCheck(Ot[0], -1e9, -1, mt), intCheck(Ot[1], 1, MAX, mt), oe = Ot[0], Ce = Ot[1];
          else if (intCheck(Ot, -1e9, MAX, mt), Ot)
            oe = -(Ce = Ot < 0 ? -Ot : Ot);
          else
            throw Error(bignumberError + mt + " cannot be zero: " + Ot);
        if (Bt.hasOwnProperty(mt = "CRYPTO"))
          if (Ot = Bt[mt], Ot === !!Ot)
            if (Ot)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                at = Ot;
              else
                throw at = !Ot, Error(bignumberError + "crypto unavailable");
            else
              at = Ot;
          else
            throw Error(bignumberError + mt + " not true or false: " + Ot);
        if (Bt.hasOwnProperty(mt = "MODULO_MODE") && (Ot = Bt[mt], intCheck(Ot, 0, 9, mt), it = Ot), Bt.hasOwnProperty(mt = "POW_PRECISION") && (Ot = Bt[mt], intCheck(Ot, 0, MAX, mt), gt = Ot), Bt.hasOwnProperty(mt = "FORMAT"))
          if (Ot = Bt[mt], typeof Ot == "object") St = Ot;
          else throw Error(bignumberError + mt + " not an object: " + Ot);
        if (Bt.hasOwnProperty(mt = "ALPHABET"))
          if (Ot = Bt[mt], typeof Ot == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Ot))
            Mt = Ot.slice(0, 10) == "0123456789", xt = Ot;
          else
            throw Error(bignumberError + mt + " invalid: " + Ot);
      } else
        throw Error(bignumberError + "Object expected: " + Bt);
    return {
      DECIMAL_PLACES: ne,
      ROUNDING_MODE: ie,
      EXPONENTIAL_AT: [pe, nt],
      RANGE: [oe, Ce],
      CRYPTO: at,
      MODULO_MODE: it,
      POW_PRECISION: gt,
      FORMAT: St,
      ALPHABET: xt
    };
  }, bt.isBigNumber = function(Bt) {
    if (!Bt || Bt._isBigNumber !== !0) return !1;
    if (!bt.DEBUG) return !0;
    var mt, Ot, wt = Bt.c, ke = Bt.e, rt = Bt.s;
    e: if ({}.toString.call(wt) == "[object Array]") {
      if ((rt === 1 || rt === -1) && ke >= -1e9 && ke <= MAX && ke === mathfloor(ke)) {
        if (wt[0] === 0) {
          if (ke === 0 && wt.length === 1) return !0;
          break e;
        }
        if (mt = (ke + 1) % LOG_BASE, mt < 1 && (mt += LOG_BASE), String(wt[0]).length == mt) {
          for (mt = 0; mt < wt.length; mt++)
            if (Ot = wt[mt], Ot < 0 || Ot >= BASE || Ot !== mathfloor(Ot)) break e;
          if (Ot !== 0) return !0;
        }
      }
    } else if (wt === null && ke === null && (rt === null || rt === 1 || rt === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Bt);
  }, bt.maximum = bt.max = function() {
    return It(arguments, -1);
  }, bt.minimum = bt.min = function() {
    return It(arguments, 1);
  }, bt.random = function() {
    var Bt = 9007199254740992, mt = Math.random() * Bt & 2097151 ? function() {
      return mathfloor(Math.random() * Bt);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Ot) {
      var wt, ke, rt, ce, Oe, ot = 0, ut = [], ht = new bt(re);
      if (Ot == null ? Ot = ne : intCheck(Ot, 0, MAX), ce = mathceil(Ot / LOG_BASE), at)
        if (crypto.getRandomValues) {
          for (wt = crypto.getRandomValues(new Uint32Array(ce *= 2)); ot < ce; )
            Oe = wt[ot] * 131072 + (wt[ot + 1] >>> 11), Oe >= 9e15 ? (ke = crypto.getRandomValues(new Uint32Array(2)), wt[ot] = ke[0], wt[ot + 1] = ke[1]) : (ut.push(Oe % 1e14), ot += 2);
          ot = ce / 2;
        } else if (crypto.randomBytes) {
          for (wt = crypto.randomBytes(ce *= 7); ot < ce; )
            Oe = (wt[ot] & 31) * 281474976710656 + wt[ot + 1] * 1099511627776 + wt[ot + 2] * 4294967296 + wt[ot + 3] * 16777216 + (wt[ot + 4] << 16) + (wt[ot + 5] << 8) + wt[ot + 6], Oe >= 9e15 ? crypto.randomBytes(7).copy(wt, ot) : (ut.push(Oe % 1e14), ot += 7);
          ot = ce / 7;
        } else
          throw at = !1, Error(bignumberError + "crypto unavailable");
      if (!at)
        for (; ot < ce; )
          Oe = mt(), Oe < 9e15 && (ut[ot++] = Oe % 1e14);
      for (ce = ut[--ot], Ot %= LOG_BASE, ce && Ot && (Oe = POWS_TEN[LOG_BASE - Ot], ut[ot] = mathfloor(ce / Oe) * Oe); ut[ot] === 0; ut.pop(), ot--) ;
      if (ot < 0)
        ut = [rt = 0];
      else {
        for (rt = -1; ut[0] === 0; ut.splice(0, 1), rt -= LOG_BASE) ;
        for (ot = 1, Oe = ut[0]; Oe >= 10; Oe /= 10, ot++) ;
        ot < LOG_BASE && (rt -= LOG_BASE - ot);
      }
      return ht.e = rt, ht.c = ut, ht;
    };
  }(), bt.sum = function() {
    for (var Bt = 1, mt = arguments, Ot = new bt(mt[0]); Bt < mt.length; ) Ot = Ot.plus(mt[Bt++]);
    return Ot;
  }, L = /* @__PURE__ */ function() {
    var Bt = "0123456789";
    function mt(Ot, wt, ke, rt) {
      for (var ce, Oe = [0], ot, ut = 0, ht = Ot.length; ut < ht; ) {
        for (ot = Oe.length; ot--; Oe[ot] *= wt) ;
        for (Oe[0] += rt.indexOf(Ot.charAt(ut++)), ce = 0; ce < Oe.length; ce++)
          Oe[ce] > ke - 1 && (Oe[ce + 1] == null && (Oe[ce + 1] = 0), Oe[ce + 1] += Oe[ce] / ke | 0, Oe[ce] %= ke);
      }
      return Oe.reverse();
    }
    return function(Ot, wt, ke, rt, ce) {
      var Oe, ot, ut, ht, dt, st, yt, ct, At = Ot.indexOf("."), Kt = ne, Zt = ie;
      for (At >= 0 && (ht = gt, gt = 0, Ot = Ot.replace(".", ""), ct = new bt(wt), st = ct.pow(Ot.length - At), gt = ht, ct.c = mt(
        toFixedPoint(coeffToString(st.c), st.e, "0"),
        10,
        ke,
        Bt
      ), ct.e = ct.c.length), yt = mt(Ot, wt, ke, ce ? (Oe = xt, Bt) : (Oe = Bt, xt)), ut = ht = yt.length; yt[--ht] == 0; yt.pop()) ;
      if (!yt[0]) return Oe.charAt(0);
      if (At < 0 ? --ut : (st.c = yt, st.e = ut, st.s = rt, st = B(st, ct, Kt, Zt, ke), yt = st.c, dt = st.r, ut = st.e), ot = ut + Kt + 1, At = yt[ot], ht = ke / 2, dt = dt || ot < 0 || yt[ot + 1] != null, dt = Zt < 4 ? (At != null || dt) && (Zt == 0 || Zt == (st.s < 0 ? 3 : 2)) : At > ht || At == ht && (Zt == 4 || dt || Zt == 6 && yt[ot - 1] & 1 || Zt == (st.s < 0 ? 8 : 7)), ot < 1 || !yt[0])
        Ot = dt ? toFixedPoint(Oe.charAt(1), -Kt, Oe.charAt(0)) : Oe.charAt(0);
      else {
        if (yt.length = ot, dt)
          for (--ke; ++yt[--ot] > ke; )
            yt[ot] = 0, ot || (++ut, yt = [1].concat(yt));
        for (ht = yt.length; !yt[--ht]; ) ;
        for (At = 0, Ot = ""; At <= ht; Ot += Oe.charAt(yt[At++])) ;
        Ot = toFixedPoint(Ot, ut, Oe.charAt(0));
      }
      return Ot;
    };
  }(), B = /* @__PURE__ */ function() {
    function Bt(wt, ke, rt) {
      var ce, Oe, ot, ut, ht = 0, dt = wt.length, st = ke % SQRT_BASE, yt = ke / SQRT_BASE | 0;
      for (wt = wt.slice(); dt--; )
        ot = wt[dt] % SQRT_BASE, ut = wt[dt] / SQRT_BASE | 0, ce = yt * ot + ut * st, Oe = st * ot + ce % SQRT_BASE * SQRT_BASE + ht, ht = (Oe / rt | 0) + (ce / SQRT_BASE | 0) + yt * ut, wt[dt] = Oe % rt;
      return ht && (wt = [ht].concat(wt)), wt;
    }
    function mt(wt, ke, rt, ce) {
      var Oe, ot;
      if (rt != ce)
        ot = rt > ce ? 1 : -1;
      else
        for (Oe = ot = 0; Oe < rt; Oe++)
          if (wt[Oe] != ke[Oe]) {
            ot = wt[Oe] > ke[Oe] ? 1 : -1;
            break;
          }
      return ot;
    }
    function Ot(wt, ke, rt, ce) {
      for (var Oe = 0; rt--; )
        wt[rt] -= Oe, Oe = wt[rt] < ke[rt] ? 1 : 0, wt[rt] = Oe * ce + wt[rt] - ke[rt];
      for (; !wt[0] && wt.length > 1; wt.splice(0, 1)) ;
    }
    return function(wt, ke, rt, ce, Oe) {
      var ot, ut, ht, dt, st, yt, ct, At, Kt, Zt, Ht, Pt, kt, Vt, tr, Nt, Ft, er = wt.s == ke.s ? 1 : -1, fr = wt.c, cr = ke.c;
      if (!fr || !fr[0] || !cr || !cr[0])
        return new bt(
          // Return NaN if either NaN, or both Infinity or 0.
          !wt.s || !ke.s || (fr ? cr && fr[0] == cr[0] : !cr) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            fr && fr[0] == 0 || !cr ? er * 0 : er / 0
          )
        );
      for (At = new bt(er), Kt = At.c = [], ut = wt.e - ke.e, er = rt + ut + 1, Oe || (Oe = BASE, ut = bitFloor(wt.e / LOG_BASE) - bitFloor(ke.e / LOG_BASE), er = er / LOG_BASE | 0), ht = 0; cr[ht] == (fr[ht] || 0); ht++) ;
      if (cr[ht] > (fr[ht] || 0) && ut--, er < 0)
        Kt.push(1), dt = !0;
      else {
        for (Vt = fr.length, Nt = cr.length, ht = 0, er += 2, st = mathfloor(Oe / (cr[0] + 1)), st > 1 && (cr = Bt(cr, st, Oe), fr = Bt(fr, st, Oe), Nt = cr.length, Vt = fr.length), kt = Nt, Zt = fr.slice(0, Nt), Ht = Zt.length; Ht < Nt; Zt[Ht++] = 0) ;
        Ft = cr.slice(), Ft = [0].concat(Ft), tr = cr[0], cr[1] >= Oe / 2 && tr++;
        do {
          if (st = 0, ot = mt(cr, Zt, Nt, Ht), ot < 0) {
            if (Pt = Zt[0], Nt != Ht && (Pt = Pt * Oe + (Zt[1] || 0)), st = mathfloor(Pt / tr), st > 1)
              for (st >= Oe && (st = Oe - 1), yt = Bt(cr, st, Oe), ct = yt.length, Ht = Zt.length; mt(yt, Zt, ct, Ht) == 1; )
                st--, Ot(yt, Nt < ct ? Ft : cr, ct, Oe), ct = yt.length, ot = 1;
            else
              st == 0 && (ot = st = 1), yt = cr.slice(), ct = yt.length;
            if (ct < Ht && (yt = [0].concat(yt)), Ot(Zt, yt, Ht, Oe), Ht = Zt.length, ot == -1)
              for (; mt(cr, Zt, Nt, Ht) < 1; )
                st++, Ot(Zt, Nt < Ht ? Ft : cr, Ht, Oe), Ht = Zt.length;
          } else ot === 0 && (st++, Zt = [0]);
          Kt[ht++] = st, Zt[0] ? Zt[Ht++] = fr[kt] || 0 : (Zt = [fr[kt]], Ht = 1);
        } while ((kt++ < Vt || Zt[0] != null) && er--);
        dt = Zt[0] != null, Kt[0] || Kt.splice(0, 1);
      }
      if (Oe == BASE) {
        for (ht = 1, er = Kt[0]; er >= 10; er /= 10, ht++) ;
        Dt(At, rt + (At.e = ht + ut * LOG_BASE - 1) + 1, ce, dt);
      } else
        At.e = ut, At.r = +dt;
      return At;
    };
  }();
  function Tt(Bt, mt, Ot, wt) {
    var ke, rt, ce, Oe, ot;
    if (Ot == null ? Ot = ie : intCheck(Ot, 0, 8), !Bt.c) return Bt.toString();
    if (ke = Bt.c[0], ce = Bt.e, mt == null)
      ot = coeffToString(Bt.c), ot = wt == 1 || wt == 2 && (ce <= pe || ce >= nt) ? toExponential(ot, ce) : toFixedPoint(ot, ce, "0");
    else if (Bt = Dt(new bt(Bt), mt, Ot), rt = Bt.e, ot = coeffToString(Bt.c), Oe = ot.length, wt == 1 || wt == 2 && (mt <= rt || rt <= pe)) {
      for (; Oe < mt; ot += "0", Oe++) ;
      ot = toExponential(ot, rt);
    } else if (mt -= ce, ot = toFixedPoint(ot, rt, "0"), rt + 1 > Oe) {
      if (--mt > 0) for (ot += "."; mt--; ot += "0") ;
    } else if (mt += rt - Oe, mt > 0)
      for (rt + 1 == Oe && (ot += "."); mt--; ot += "0") ;
    return Bt.s < 0 && ke ? "-" + ot : ot;
  }
  function It(Bt, mt) {
    for (var Ot, wt, ke = 1, rt = new bt(Bt[0]); ke < Bt.length; ke++)
      wt = new bt(Bt[ke]), (!wt.s || (Ot = compare(rt, wt)) === mt || Ot === 0 && rt.s === mt) && (rt = wt);
    return rt;
  }
  function qt(Bt, mt, Ot) {
    for (var wt = 1, ke = mt.length; !mt[--ke]; mt.pop()) ;
    for (ke = mt[0]; ke >= 10; ke /= 10, wt++) ;
    return (Ot = wt + Ot * LOG_BASE - 1) > Ce ? Bt.c = Bt.e = null : Ot < oe ? Bt.c = [Bt.e = 0] : (Bt.e = Ot, Bt.c = mt), Bt;
  }
  V = /* @__PURE__ */ function() {
    var Bt = /^(-?)0([xbo])(?=\w[\w.]*$)/i, mt = /^([^.]+)\.$/, Ot = /^\.([^.]+)$/, wt = /^-?(Infinity|NaN)$/, ke = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(rt, ce, Oe, ot) {
      var ut, ht = Oe ? ce : ce.replace(ke, "");
      if (wt.test(ht))
        rt.s = isNaN(ht) ? null : ht < 0 ? -1 : 1;
      else {
        if (!Oe && (ht = ht.replace(Bt, function(dt, st, yt) {
          return ut = (yt = yt.toLowerCase()) == "x" ? 16 : yt == "b" ? 2 : 8, !ot || ot == ut ? st : dt;
        }), ot && (ut = ot, ht = ht.replace(mt, "$1").replace(Ot, "0.$1")), ce != ht))
          return new bt(ht, ut);
        if (bt.DEBUG)
          throw Error(bignumberError + "Not a" + (ot ? " base " + ot : "") + " number: " + ce);
        rt.s = null;
      }
      rt.c = rt.e = null;
    };
  }();
  function Dt(Bt, mt, Ot, wt) {
    var ke, rt, ce, Oe, ot, ut, ht, dt = Bt.c, st = POWS_TEN;
    if (dt) {
      e: {
        for (ke = 1, Oe = dt[0]; Oe >= 10; Oe /= 10, ke++) ;
        if (rt = mt - ke, rt < 0)
          rt += LOG_BASE, ce = mt, ot = dt[ut = 0], ht = mathfloor(ot / st[ke - ce - 1] % 10);
        else if (ut = mathceil((rt + 1) / LOG_BASE), ut >= dt.length)
          if (wt) {
            for (; dt.length <= ut; dt.push(0)) ;
            ot = ht = 0, ke = 1, rt %= LOG_BASE, ce = rt - LOG_BASE + 1;
          } else
            break e;
        else {
          for (ot = Oe = dt[ut], ke = 1; Oe >= 10; Oe /= 10, ke++) ;
          rt %= LOG_BASE, ce = rt - LOG_BASE + ke, ht = ce < 0 ? 0 : mathfloor(ot / st[ke - ce - 1] % 10);
        }
        if (wt = wt || mt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        dt[ut + 1] != null || (ce < 0 ? ot : ot % st[ke - ce - 1]), wt = Ot < 4 ? (ht || wt) && (Ot == 0 || Ot == (Bt.s < 0 ? 3 : 2)) : ht > 5 || ht == 5 && (Ot == 4 || wt || Ot == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (rt > 0 ? ce > 0 ? ot / st[ke - ce] : 0 : dt[ut - 1]) % 10 & 1 || Ot == (Bt.s < 0 ? 8 : 7)), mt < 1 || !dt[0])
          return dt.length = 0, wt ? (mt -= Bt.e + 1, dt[0] = st[(LOG_BASE - mt % LOG_BASE) % LOG_BASE], Bt.e = -mt || 0) : dt[0] = Bt.e = 0, Bt;
        if (rt == 0 ? (dt.length = ut, Oe = 1, ut--) : (dt.length = ut + 1, Oe = st[LOG_BASE - rt], dt[ut] = ce > 0 ? mathfloor(ot / st[ke - ce] % st[ce]) * Oe : 0), wt)
          for (; ; )
            if (ut == 0) {
              for (rt = 1, ce = dt[0]; ce >= 10; ce /= 10, rt++) ;
              for (ce = dt[0] += Oe, Oe = 1; ce >= 10; ce /= 10, Oe++) ;
              rt != Oe && (Bt.e++, dt[0] == BASE && (dt[0] = 1));
              break;
            } else {
              if (dt[ut] += Oe, dt[ut] != BASE) break;
              dt[ut--] = 0, Oe = 1;
            }
        for (rt = dt.length; dt[--rt] === 0; dt.pop()) ;
      }
      Bt.e > Ce ? Bt.c = Bt.e = null : Bt.e < oe && (Bt.c = [Bt.e = 0]);
    }
    return Bt;
  }
  function Xt(Bt) {
    var mt, Ot = Bt.e;
    return Ot === null ? Bt.toString() : (mt = coeffToString(Bt.c), mt = Ot <= pe || Ot >= nt ? toExponential(mt, Ot) : toFixedPoint(mt, Ot, "0"), Bt.s < 0 ? "-" + mt : mt);
  }
  return J.absoluteValue = J.abs = function() {
    var Bt = new bt(this);
    return Bt.s < 0 && (Bt.s = 1), Bt;
  }, J.comparedTo = function(Bt, mt) {
    return compare(this, new bt(Bt, mt));
  }, J.decimalPlaces = J.dp = function(Bt, mt) {
    var Ot, wt, ke, rt = this;
    if (Bt != null)
      return intCheck(Bt, 0, MAX), mt == null ? mt = ie : intCheck(mt, 0, 8), Dt(new bt(rt), Bt + rt.e + 1, mt);
    if (!(Ot = rt.c)) return null;
    if (wt = ((ke = Ot.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, ke = Ot[ke]) for (; ke % 10 == 0; ke /= 10, wt--) ;
    return wt < 0 && (wt = 0), wt;
  }, J.dividedBy = J.div = function(Bt, mt) {
    return B(this, new bt(Bt, mt), ne, ie);
  }, J.dividedToIntegerBy = J.idiv = function(Bt, mt) {
    return B(this, new bt(Bt, mt), 0, 1);
  }, J.exponentiatedBy = J.pow = function(Bt, mt) {
    var Ot, wt, ke, rt, ce, Oe, ot, ut, ht, dt = this;
    if (Bt = new bt(Bt), Bt.c && !Bt.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Xt(Bt));
    if (mt != null && (mt = new bt(mt)), Oe = Bt.e > 14, !dt.c || !dt.c[0] || dt.c[0] == 1 && !dt.e && dt.c.length == 1 || !Bt.c || !Bt.c[0])
      return ht = new bt(Math.pow(+Xt(dt), Oe ? Bt.s * (2 - isOdd(Bt)) : +Xt(Bt))), mt ? ht.mod(mt) : ht;
    if (ot = Bt.s < 0, mt) {
      if (mt.c ? !mt.c[0] : !mt.s) return new bt(NaN);
      wt = !ot && dt.isInteger() && mt.isInteger(), wt && (dt = dt.mod(mt));
    } else {
      if (Bt.e > 9 && (dt.e > 0 || dt.e < -1 || (dt.e == 0 ? dt.c[0] > 1 || Oe && dt.c[1] >= 24e7 : dt.c[0] < 8e13 || Oe && dt.c[0] <= 9999975e7)))
        return rt = dt.s < 0 && isOdd(Bt) ? -0 : 0, dt.e > -1 && (rt = 1 / rt), new bt(ot ? 1 / rt : rt);
      gt && (rt = mathceil(gt / LOG_BASE + 2));
    }
    for (Oe ? (Ot = new bt(0.5), ot && (Bt.s = 1), ut = isOdd(Bt)) : (ke = Math.abs(+Xt(Bt)), ut = ke % 2), ht = new bt(re); ; ) {
      if (ut) {
        if (ht = ht.times(dt), !ht.c) break;
        rt ? ht.c.length > rt && (ht.c.length = rt) : wt && (ht = ht.mod(mt));
      }
      if (ke) {
        if (ke = mathfloor(ke / 2), ke === 0) break;
        ut = ke % 2;
      } else if (Bt = Bt.times(Ot), Dt(Bt, Bt.e + 1, 1), Bt.e > 14)
        ut = isOdd(Bt);
      else {
        if (ke = +Xt(Bt), ke === 0) break;
        ut = ke % 2;
      }
      dt = dt.times(dt), rt ? dt.c && dt.c.length > rt && (dt.c.length = rt) : wt && (dt = dt.mod(mt));
    }
    return wt ? ht : (ot && (ht = re.div(ht)), mt ? ht.mod(mt) : rt ? Dt(ht, gt, ie, ce) : ht);
  }, J.integerValue = function(Bt) {
    var mt = new bt(this);
    return Bt == null ? Bt = ie : intCheck(Bt, 0, 8), Dt(mt, mt.e + 1, Bt);
  }, J.isEqualTo = J.eq = function(Bt, mt) {
    return compare(this, new bt(Bt, mt)) === 0;
  }, J.isFinite = function() {
    return !!this.c;
  }, J.isGreaterThan = J.gt = function(Bt, mt) {
    return compare(this, new bt(Bt, mt)) > 0;
  }, J.isGreaterThanOrEqualTo = J.gte = function(Bt, mt) {
    return (mt = compare(this, new bt(Bt, mt))) === 1 || mt === 0;
  }, J.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, J.isLessThan = J.lt = function(Bt, mt) {
    return compare(this, new bt(Bt, mt)) < 0;
  }, J.isLessThanOrEqualTo = J.lte = function(Bt, mt) {
    return (mt = compare(this, new bt(Bt, mt))) === -1 || mt === 0;
  }, J.isNaN = function() {
    return !this.s;
  }, J.isNegative = function() {
    return this.s < 0;
  }, J.isPositive = function() {
    return this.s > 0;
  }, J.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, J.minus = function(Bt, mt) {
    var Ot, wt, ke, rt, ce = this, Oe = ce.s;
    if (Bt = new bt(Bt, mt), mt = Bt.s, !Oe || !mt) return new bt(NaN);
    if (Oe != mt)
      return Bt.s = -mt, ce.plus(Bt);
    var ot = ce.e / LOG_BASE, ut = Bt.e / LOG_BASE, ht = ce.c, dt = Bt.c;
    if (!ot || !ut) {
      if (!ht || !dt) return ht ? (Bt.s = -mt, Bt) : new bt(dt ? ce : NaN);
      if (!ht[0] || !dt[0])
        return dt[0] ? (Bt.s = -mt, Bt) : new bt(ht[0] ? ce : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ie == 3 ? -0 : 0
        ));
    }
    if (ot = bitFloor(ot), ut = bitFloor(ut), ht = ht.slice(), Oe = ot - ut) {
      for ((rt = Oe < 0) ? (Oe = -Oe, ke = ht) : (ut = ot, ke = dt), ke.reverse(), mt = Oe; mt--; ke.push(0)) ;
      ke.reverse();
    } else
      for (wt = (rt = (Oe = ht.length) < (mt = dt.length)) ? Oe : mt, Oe = mt = 0; mt < wt; mt++)
        if (ht[mt] != dt[mt]) {
          rt = ht[mt] < dt[mt];
          break;
        }
    if (rt && (ke = ht, ht = dt, dt = ke, Bt.s = -Bt.s), mt = (wt = dt.length) - (Ot = ht.length), mt > 0) for (; mt--; ht[Ot++] = 0) ;
    for (mt = BASE - 1; wt > Oe; ) {
      if (ht[--wt] < dt[wt]) {
        for (Ot = wt; Ot && !ht[--Ot]; ht[Ot] = mt) ;
        --ht[Ot], ht[wt] += BASE;
      }
      ht[wt] -= dt[wt];
    }
    for (; ht[0] == 0; ht.splice(0, 1), --ut) ;
    return ht[0] ? qt(Bt, ht, ut) : (Bt.s = ie == 3 ? -1 : 1, Bt.c = [Bt.e = 0], Bt);
  }, J.modulo = J.mod = function(Bt, mt) {
    var Ot, wt, ke = this;
    return Bt = new bt(Bt, mt), !ke.c || !Bt.s || Bt.c && !Bt.c[0] ? new bt(NaN) : !Bt.c || ke.c && !ke.c[0] ? new bt(ke) : (it == 9 ? (wt = Bt.s, Bt.s = 1, Ot = B(ke, Bt, 0, 3), Bt.s = wt, Ot.s *= wt) : Ot = B(ke, Bt, 0, it), Bt = ke.minus(Ot.times(Bt)), !Bt.c[0] && it == 1 && (Bt.s = ke.s), Bt);
  }, J.multipliedBy = J.times = function(Bt, mt) {
    var Ot, wt, ke, rt, ce, Oe, ot, ut, ht, dt, st, yt, ct, At, Kt, Zt = this, Ht = Zt.c, Pt = (Bt = new bt(Bt, mt)).c;
    if (!Ht || !Pt || !Ht[0] || !Pt[0])
      return !Zt.s || !Bt.s || Ht && !Ht[0] && !Pt || Pt && !Pt[0] && !Ht ? Bt.c = Bt.e = Bt.s = null : (Bt.s *= Zt.s, !Ht || !Pt ? Bt.c = Bt.e = null : (Bt.c = [0], Bt.e = 0)), Bt;
    for (wt = bitFloor(Zt.e / LOG_BASE) + bitFloor(Bt.e / LOG_BASE), Bt.s *= Zt.s, ot = Ht.length, dt = Pt.length, ot < dt && (ct = Ht, Ht = Pt, Pt = ct, ke = ot, ot = dt, dt = ke), ke = ot + dt, ct = []; ke--; ct.push(0)) ;
    for (At = BASE, Kt = SQRT_BASE, ke = dt; --ke >= 0; ) {
      for (Ot = 0, st = Pt[ke] % Kt, yt = Pt[ke] / Kt | 0, ce = ot, rt = ke + ce; rt > ke; )
        ut = Ht[--ce] % Kt, ht = Ht[ce] / Kt | 0, Oe = yt * ut + ht * st, ut = st * ut + Oe % Kt * Kt + ct[rt] + Ot, Ot = (ut / At | 0) + (Oe / Kt | 0) + yt * ht, ct[rt--] = ut % At;
      ct[rt] = Ot;
    }
    return Ot ? ++wt : ct.splice(0, 1), qt(Bt, ct, wt);
  }, J.negated = function() {
    var Bt = new bt(this);
    return Bt.s = -Bt.s || null, Bt;
  }, J.plus = function(Bt, mt) {
    var Ot, wt = this, ke = wt.s;
    if (Bt = new bt(Bt, mt), mt = Bt.s, !ke || !mt) return new bt(NaN);
    if (ke != mt)
      return Bt.s = -mt, wt.minus(Bt);
    var rt = wt.e / LOG_BASE, ce = Bt.e / LOG_BASE, Oe = wt.c, ot = Bt.c;
    if (!rt || !ce) {
      if (!Oe || !ot) return new bt(ke / 0);
      if (!Oe[0] || !ot[0]) return ot[0] ? Bt : new bt(Oe[0] ? wt : ke * 0);
    }
    if (rt = bitFloor(rt), ce = bitFloor(ce), Oe = Oe.slice(), ke = rt - ce) {
      for (ke > 0 ? (ce = rt, Ot = ot) : (ke = -ke, Ot = Oe), Ot.reverse(); ke--; Ot.push(0)) ;
      Ot.reverse();
    }
    for (ke = Oe.length, mt = ot.length, ke - mt < 0 && (Ot = ot, ot = Oe, Oe = Ot, mt = ke), ke = 0; mt; )
      ke = (Oe[--mt] = Oe[mt] + ot[mt] + ke) / BASE | 0, Oe[mt] = BASE === Oe[mt] ? 0 : Oe[mt] % BASE;
    return ke && (Oe = [ke].concat(Oe), ++ce), qt(Bt, Oe, ce);
  }, J.precision = J.sd = function(Bt, mt) {
    var Ot, wt, ke, rt = this;
    if (Bt != null && Bt !== !!Bt)
      return intCheck(Bt, 1, MAX), mt == null ? mt = ie : intCheck(mt, 0, 8), Dt(new bt(rt), Bt, mt);
    if (!(Ot = rt.c)) return null;
    if (ke = Ot.length - 1, wt = ke * LOG_BASE + 1, ke = Ot[ke]) {
      for (; ke % 10 == 0; ke /= 10, wt--) ;
      for (ke = Ot[0]; ke >= 10; ke /= 10, wt++) ;
    }
    return Bt && rt.e + 1 > wt && (wt = rt.e + 1), wt;
  }, J.shiftedBy = function(Bt) {
    return intCheck(Bt, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + Bt);
  }, J.squareRoot = J.sqrt = function() {
    var Bt, mt, Ot, wt, ke, rt = this, ce = rt.c, Oe = rt.s, ot = rt.e, ut = ne + 4, ht = new bt("0.5");
    if (Oe !== 1 || !ce || !ce[0])
      return new bt(!Oe || Oe < 0 && (!ce || ce[0]) ? NaN : ce ? rt : 1 / 0);
    if (Oe = Math.sqrt(+Xt(rt)), Oe == 0 || Oe == 1 / 0 ? (mt = coeffToString(ce), (mt.length + ot) % 2 == 0 && (mt += "0"), Oe = Math.sqrt(+mt), ot = bitFloor((ot + 1) / 2) - (ot < 0 || ot % 2), Oe == 1 / 0 ? mt = "5e" + ot : (mt = Oe.toExponential(), mt = mt.slice(0, mt.indexOf("e") + 1) + ot), Ot = new bt(mt)) : Ot = new bt(Oe + ""), Ot.c[0]) {
      for (ot = Ot.e, Oe = ot + ut, Oe < 3 && (Oe = 0); ; )
        if (ke = Ot, Ot = ht.times(ke.plus(B(rt, ke, ut, 1))), coeffToString(ke.c).slice(0, Oe) === (mt = coeffToString(Ot.c)).slice(0, Oe))
          if (Ot.e < ot && --Oe, mt = mt.slice(Oe - 3, Oe + 1), mt == "9999" || !wt && mt == "4999") {
            if (!wt && (Dt(ke, ke.e + ne + 2, 0), ke.times(ke).eq(rt))) {
              Ot = ke;
              break;
            }
            ut += 4, Oe += 4, wt = 1;
          } else {
            (!+mt || !+mt.slice(1) && mt.charAt(0) == "5") && (Dt(Ot, Ot.e + ne + 2, 1), Bt = !Ot.times(Ot).eq(rt));
            break;
          }
    }
    return Dt(Ot, Ot.e + ne + 1, ie, Bt);
  }, J.toExponential = function(Bt, mt) {
    return Bt != null && (intCheck(Bt, 0, MAX), Bt++), Tt(this, Bt, mt, 1);
  }, J.toFixed = function(Bt, mt) {
    return Bt != null && (intCheck(Bt, 0, MAX), Bt = Bt + this.e + 1), Tt(this, Bt, mt);
  }, J.toFormat = function(Bt, mt, Ot) {
    var wt, ke = this;
    if (Ot == null)
      Bt != null && mt && typeof mt == "object" ? (Ot = mt, mt = null) : Bt && typeof Bt == "object" ? (Ot = Bt, Bt = mt = null) : Ot = St;
    else if (typeof Ot != "object")
      throw Error(bignumberError + "Argument not an object: " + Ot);
    if (wt = ke.toFixed(Bt, mt), ke.c) {
      var rt, ce = wt.split("."), Oe = +Ot.groupSize, ot = +Ot.secondaryGroupSize, ut = Ot.groupSeparator || "", ht = ce[0], dt = ce[1], st = ke.s < 0, yt = st ? ht.slice(1) : ht, ct = yt.length;
      if (ot && (rt = Oe, Oe = ot, ot = rt, ct -= rt), Oe > 0 && ct > 0) {
        for (rt = ct % Oe || Oe, ht = yt.substr(0, rt); rt < ct; rt += Oe) ht += ut + yt.substr(rt, Oe);
        ot > 0 && (ht += ut + yt.slice(rt)), st && (ht = "-" + ht);
      }
      wt = dt ? ht + (Ot.decimalSeparator || "") + ((ot = +Ot.fractionGroupSize) ? dt.replace(
        new RegExp("\\d{" + ot + "}\\B", "g"),
        "$&" + (Ot.fractionGroupSeparator || "")
      ) : dt) : ht;
    }
    return (Ot.prefix || "") + wt + (Ot.suffix || "");
  }, J.toFraction = function(Bt) {
    var mt, Ot, wt, ke, rt, ce, Oe, ot, ut, ht, dt, st, yt = this, ct = yt.c;
    if (Bt != null && (Oe = new bt(Bt), !Oe.isInteger() && (Oe.c || Oe.s !== 1) || Oe.lt(re)))
      throw Error(bignumberError + "Argument " + (Oe.isInteger() ? "out of range: " : "not an integer: ") + Xt(Oe));
    if (!ct) return new bt(yt);
    for (mt = new bt(re), ut = Ot = new bt(re), wt = ot = new bt(re), st = coeffToString(ct), rt = mt.e = st.length - yt.e - 1, mt.c[0] = POWS_TEN[(ce = rt % LOG_BASE) < 0 ? LOG_BASE + ce : ce], Bt = !Bt || Oe.comparedTo(mt) > 0 ? rt > 0 ? mt : ut : Oe, ce = Ce, Ce = 1 / 0, Oe = new bt(st), ot.c[0] = 0; ht = B(Oe, mt, 0, 1), ke = Ot.plus(ht.times(wt)), ke.comparedTo(Bt) != 1; )
      Ot = wt, wt = ke, ut = ot.plus(ht.times(ke = ut)), ot = ke, mt = Oe.minus(ht.times(ke = mt)), Oe = ke;
    return ke = B(Bt.minus(Ot), wt, 0, 1), ot = ot.plus(ke.times(ut)), Ot = Ot.plus(ke.times(wt)), ot.s = ut.s = yt.s, rt = rt * 2, dt = B(ut, wt, rt, ie).minus(yt).abs().comparedTo(
      B(ot, Ot, rt, ie).minus(yt).abs()
    ) < 1 ? [ut, wt] : [ot, Ot], Ce = ce, dt;
  }, J.toNumber = function() {
    return +Xt(this);
  }, J.toPrecision = function(Bt, mt) {
    return Bt != null && intCheck(Bt, 1, MAX), Tt(this, Bt, mt, 2);
  }, J.toString = function(Bt) {
    var mt, Ot = this, wt = Ot.s, ke = Ot.e;
    return ke === null ? wt ? (mt = "Infinity", wt < 0 && (mt = "-" + mt)) : mt = "NaN" : (Bt == null ? mt = ke <= pe || ke >= nt ? toExponential(coeffToString(Ot.c), ke) : toFixedPoint(coeffToString(Ot.c), ke, "0") : Bt === 10 && Mt ? (Ot = Dt(new bt(Ot), ne + ke + 1, ie), mt = toFixedPoint(coeffToString(Ot.c), Ot.e, "0")) : (intCheck(Bt, 2, xt.length, "Base"), mt = L(toFixedPoint(coeffToString(Ot.c), ke, "0"), 10, Bt, wt, !0)), wt < 0 && Ot.c[0] && (mt = "-" + mt)), mt;
  }, J.valueOf = J.toJSON = function() {
    return Xt(this);
  }, J._isBigNumber = !0, J[Symbol.toStringTag] = "BigNumber", J[Symbol.for("nodejs.util.inspect.custom")] = J.valueOf, A != null && bt.set(A), bt;
}
function bitFloor(A) {
  var B = A | 0;
  return A > 0 || A === B ? B : B - 1;
}
function coeffToString(A) {
  for (var B, L, V = 1, J = A.length, re = A[0] + ""; V < J; ) {
    for (B = A[V++] + "", L = LOG_BASE - B.length; L--; B = "0" + B) ;
    re += B;
  }
  for (J = re.length; re.charCodeAt(--J) === 48; ) ;
  return re.slice(0, J + 1 || 1);
}
function compare(A, B) {
  var L, V, J = A.c, re = B.c, ne = A.s, ie = B.s, pe = A.e, nt = B.e;
  if (!ne || !ie) return null;
  if (L = J && !J[0], V = re && !re[0], L || V) return L ? V ? 0 : -ie : ne;
  if (ne != ie) return ne;
  if (L = ne < 0, V = pe == nt, !J || !re) return V ? 0 : !J ^ L ? 1 : -1;
  if (!V) return pe > nt ^ L ? 1 : -1;
  for (ie = (pe = J.length) < (nt = re.length) ? pe : nt, ne = 0; ne < ie; ne++) if (J[ne] != re[ne]) return J[ne] > re[ne] ^ L ? 1 : -1;
  return pe == nt ? 0 : pe > nt ^ L ? 1 : -1;
}
function intCheck(A, B, L, V) {
  if (A < B || A > L || A !== mathfloor(A))
    throw Error(bignumberError + (V || "Argument") + (typeof A == "number" ? A < B || A > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(A));
}
function isOdd(A) {
  var B = A.c.length - 1;
  return bitFloor(A.e / LOG_BASE) == B && A.c[B] % 2 != 0;
}
function toExponential(A, B) {
  return (A.length > 1 ? A.charAt(0) + "." + A.slice(1) : A) + (B < 0 ? "e" : "e+") + B;
}
function toFixedPoint(A, B, L) {
  var V, J;
  if (B < 0) {
    for (J = L + "."; ++B; J += L) ;
    A = J + A;
  } else if (V = A.length, ++B > V) {
    for (J = L, B -= V; --B; J += L) ;
    A += J;
  } else B < V && (A = A.slice(0, B) + "." + A.slice(B));
  return A;
}
var BigNumber = clone();
function useBalance() {
  const { network: A, publicKey: B, format: L } = useOrdConnect(), [V, J] = useState(null), [re, ne] = useState(!1);
  return { getBalance: useCallback(async () => {
    ne(!0);
    try {
      if (J(null), !L || !L.payments || !B || !B.payments)
        throw new Error("No wallet is connected");
      const { address: pe } = getAddressesFromPublicKey(
        B.payments,
        A,
        ADDRESS_FORMAT_TO_TYPE[L.payments]
      )[0], oe = await new JsonRpcDatasource({ network: A }).getBalance({ address: pe }), Ce = Number(
        new BigNumber(oe).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return ne(!1), Ce;
    } catch (pe) {
      throw J(pe.message), ne(!1), pe;
    }
  }, [L, A, B]), error: V, loading: re };
}
async function signPsbt({
  address: A,
  wallet: B,
  network: L,
  psbt: V,
  options: J
}) {
  var pe, nt;
  if ((pe = J == null ? void 0 : J.signingIndexes) != null && pe.length && ((nt = J == null ? void 0 : J.inputsToSign) != null && nt.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const re = (J == null ? void 0 : J.finalize) ?? !0, ne = (J == null ? void 0 : J.extractTx) ?? !0, ie = () => V.data.inputs.map((oe, Ce) => Ce);
  if (B === Wallet.MAGICEDEN)
    return await signPsbt$1(V, {
      network: L,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: re,
      extractTx: ne
    });
  if (B === Wallet.UNISAT)
    return await signPsbt$2(V, {
      finalize: re,
      extractTx: ne
    });
  if (B === Wallet.XVERSE)
    return await signPsbt$3(V, {
      network: L,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ],
      finalize: re,
      extractTx: ne
    });
  if (B === Wallet.LEATHER)
    return await signPsbt$4(V, {
      network: L,
      finalize: re,
      extractTx: ne,
      allowedSighash: J != null && J.sigHash ? [J == null ? void 0 : J.sigHash] : [],
      signAtIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie()
      // If signingIndexes is not provided, just sign everything
    });
  if (B === Wallet.OKX)
    return await signPsbt$5(V, {
      finalize: re,
      extractTx: ne,
      network: L,
      inputsToSign: (J == null ? void 0 : J.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (J == null ? void 0 : J.signingIndexes) ?? ie(),
          // If signingIndexes is not provided, just sign everything
          sigHash: J == null ? void 0 : J.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: A, network: B, address: L, publicKey: V } = useOrdConnect(), [J, re] = useState(null), [ne, ie] = useState(!1);
  return { send: useCallback(
    async (nt, oe, Ce, at = !0) => {
      ie(!0);
      try {
        if (re(null), !L || !L.payments || !V || !V.payments || !A)
          throw new Error("No wallet is connected");
        const it = new PSBTBuilder({
          address: L.payments,
          feeRate: Ce,
          network: B,
          publicKey: V.payments,
          outputs: [
            {
              address: nt,
              value: oe
            }
          ]
        });
        await it.prepare();
        const gt = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: it.toPSBT()
        });
        if (at) {
          const xt = await new JsonRpcDatasource({ network: B }).relay({ hex: gt.hex });
          return ie(!1), xt;
        }
        return ie(!1), gt.hex;
      } catch (it) {
        return re(it.message), ie(!1), null;
      }
    },
    [L, B, V, A]
  ), error: J, loading: ne };
}
function useSendV2() {
  const { wallet: A, network: B, address: L, publicKey: V } = useOrdConnect(), [J, re] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ie,
      satoshis: pe,
      feeRate: nt,
      relay: oe = !0,
      rbf: Ce = !1
    }) => {
      re(!0);
      try {
        if (!L || !L.payments || !V || !V.payments || !A)
          throw new Error("No wallet is connected");
        const at = new PSBTBuilder({
          address: L.payments,
          feeRate: nt,
          network: B,
          publicKey: V.payments,
          outputs: [
            {
              address: ie,
              value: pe
            }
          ]
        });
        at.setRBF(Ce), await at.prepare();
        const it = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: at.toPSBT()
        });
        if (oe) {
          const St = await new JsonRpcDatasource({ network: B }).relay({ hex: it.hex });
          return re(!1), {
            txId: St
          };
        }
        return re(!1), {
          signedPsbtHex: it.hex
        };
      } catch (at) {
        return re(!1), {
          error: at.message
        };
      }
    },
    [L, B, V, A]
  ), isLoading: J };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(A) {
  if (A.length < 8 || A.length > 72 || A[0] !== 48 || A[1] !== A.length - 2 || A[2] !== 2) return !1;
  const B = A[3];
  if (B === 0 || 5 + B >= A.length || A[4 + B] !== 2) return !1;
  const L = A[5 + B];
  return !(L === 0 || 6 + B + L !== A.length || A[4] & 128 || B > 1 && A[4] === 0 && !(A[5] & 128) || A[B + 6] & 128 || L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128));
}
bip66.check = check$d;
function decode$h(A) {
  if (A.length < 8) throw new Error("DER sequence length is too short");
  if (A.length > 72) throw new Error("DER sequence length is too long");
  if (A[0] !== 48) throw new Error("Expected DER sequence");
  if (A[1] !== A.length - 2)
    throw new Error("DER sequence length is invalid");
  if (A[2] !== 2) throw new Error("Expected DER integer");
  const B = A[3];
  if (B === 0) throw new Error("R length is zero");
  if (5 + B >= A.length) throw new Error("R length is too long");
  if (A[4 + B] !== 2) throw new Error("Expected DER integer (2)");
  const L = A[5 + B];
  if (L === 0) throw new Error("S length is zero");
  if (6 + B + L !== A.length) throw new Error("S length is invalid");
  if (A[4] & 128) throw new Error("R value is negative");
  if (B > 1 && A[4] === 0 && !(A[5] & 128))
    throw new Error("R value excessively padded");
  if (A[B + 6] & 128) throw new Error("S value is negative");
  if (L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: A.slice(4, 4 + B),
    s: A.slice(6 + B)
  };
}
bip66.decode = decode$h;
function encode$i(A, B) {
  const L = A.length, V = B.length;
  if (L === 0) throw new Error("R length is zero");
  if (V === 0) throw new Error("S length is zero");
  if (L > 33) throw new Error("R length is too long");
  if (V > 33) throw new Error("S length is too long");
  if (A[0] & 128) throw new Error("R value is negative");
  if (B[0] & 128) throw new Error("S value is negative");
  if (L > 1 && A[0] === 0 && !(A[1] & 128))
    throw new Error("R value excessively padded");
  if (V > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("S value excessively padded");
  const J = Buffer$D.allocUnsafe(6 + L + V);
  return J[0] = 48, J[1] = J.length - 2, J[2] = 2, J[3] = A.length, A.copy(J, 4), J[4 + L] = 2, J[5 + L] = B.length, B.copy(J, 6 + L), J;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const A of Object.keys(OPS$7)) {
  const B = OPS$7[A];
  REVERSE_OPS[B] = A;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(A) {
  return A < ops_1.OPS.OP_PUSHDATA1 ? 1 : A <= 255 ? 2 : A <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(A, B, L) {
  const V = encodingLength$2(B);
  return V === 1 ? A.writeUInt8(B, L) : V === 2 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA1, L), A.writeUInt8(B, L + 1)) : V === 3 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA2, L), A.writeUInt16LE(B, L + 1)) : (A.writeUInt8(ops_1.OPS.OP_PUSHDATA4, L), A.writeUInt32LE(B, L + 1)), V;
}
push_data.encode = encode$h;
function decode$g(A, B) {
  const L = A.readUInt8(B);
  let V, J;
  if (L < ops_1.OPS.OP_PUSHDATA1)
    V = L, J = 1;
  else if (L === ops_1.OPS.OP_PUSHDATA1) {
    if (B + 2 > A.length) return null;
    V = A.readUInt8(B + 1), J = 2;
  } else if (L === ops_1.OPS.OP_PUSHDATA2) {
    if (B + 3 > A.length) return null;
    V = A.readUInt16LE(B + 1), J = 3;
  } else {
    if (B + 5 > A.length) return null;
    if (L !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    V = A.readUInt32LE(B + 1), J = 5;
  }
  return {
    opcode: L,
    number: V,
    size: J
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(A, B, L) {
  B = B || 4, L = L === void 0 ? !0 : L;
  const V = A.length;
  if (V === 0) return 0;
  if (V > B) throw new TypeError("Script number overflow");
  if (L && !(A[V - 1] & 127) && (V <= 1 || !(A[V - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (V === 5) {
    const re = A.readUInt32LE(0), ne = A.readUInt8(4);
    return ne & 128 ? -((ne & -129) * 4294967296 + re) : ne * 4294967296 + re;
  }
  let J = 0;
  for (let re = 0; re < V; ++re)
    J |= A[re] << 8 * re;
  return A[V - 1] & 128 ? -(J & ~(128 << 8 * (V - 1))) : J;
}
script_number.decode = decode$f;
function scriptNumSize(A) {
  return A > 2147483647 ? 5 : A > 8388607 ? 4 : A > 32767 ? 3 : A > 127 ? 2 : A > 0 ? 1 : 0;
}
function encode$g(A) {
  let B = Math.abs(A);
  const L = scriptNumSize(B), V = Buffer$D.allocUnsafe(L), J = A < 0;
  for (let re = 0; re < L; ++re)
    V.writeUInt8(B & 255, re), B >>= 8;
  return V[L - 1] & 128 ? V.writeUInt8(J ? 128 : 0, L - 1) : J && (V[L - 1] |= 128), V;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(A) {
    return A != null && A.constructor === Array;
  },
  Boolean: function(A) {
    return typeof A == "boolean";
  },
  Function: function(A) {
    return typeof A == "function";
  },
  Nil: function(A) {
    return A == null;
  },
  Number: function(A) {
    return typeof A == "number";
  },
  Object: function(A) {
    return typeof A == "object";
  },
  String: function(A) {
    return typeof A == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(A) {
    return A;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(A) {
  return A.name || A.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(A) {
  return native.Nil(A) ? "" : getTypeName(A.constructor);
}
function getValue(A) {
  return native.Function(A) ? "" : native.String(A) ? JSON.stringify(A) : A && native.Object(A) ? "" : A;
}
function captureStackTrace(A, B) {
  Error.captureStackTrace && Error.captureStackTrace(A, B);
}
function tfJSON$1(A) {
  return native.Function(A) ? A.toJSON ? A.toJSON() : getTypeName(A) : native.Array(A) ? "Array" : A && native.Object(A) ? "Object" : A !== void 0 ? A : "";
}
function tfErrorString(A, B, L) {
  var V = getValue(B);
  return "Expected " + tfJSON$1(A) + ", got" + (L !== "" ? " " + L : "") + (V !== "" ? " " + V : "");
}
function TfTypeError$1(A, B, L) {
  L = L || getValueTypeName$1(B), this.message = tfErrorString(A, B, L), captureStackTrace(this, TfTypeError$1), this.__type = A, this.__value = B, this.__valueTypeName = L;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(A, B, L, V, J) {
  var re = '" of type ';
  return B === "key" && (re = '" with key type '), tfErrorString('property "' + tfJSON$1(L) + re + tfJSON$1(A), V, J);
}
function TfPropertyTypeError$1(A, B, L, V, J) {
  A ? (J = J || getValueTypeName$1(V), this.message = tfPropertyErrorString(A, L, B, V, J)) : this.message = 'Unexpected property "' + B + '"', captureStackTrace(this, TfTypeError$1), this.__label = L, this.__property = B, this.__type = A, this.__value = V, this.__valueTypeName = J;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(A, B) {
  return new TfTypeError$1(A, {}, B);
}
function tfSubError$1(A, B, L) {
  return A instanceof TfPropertyTypeError$1 ? (B = B + "." + A.__property, A = new TfPropertyTypeError$1(
    A.__type,
    B,
    A.__label,
    A.__value,
    A.__valueTypeName
  )) : A instanceof TfTypeError$1 && (A = new TfPropertyTypeError$1(
    A.__type,
    B,
    L,
    A.__value,
    A.__valueTypeName
  )), captureStackTrace(A), A;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var A = native$1, B = errors;
  function L(Dt) {
    return Buffer$D.isBuffer(Dt);
  }
  function V(Dt) {
    return typeof Dt == "string" && /^([0-9a-f]{2})+$/i.test(Dt);
  }
  function J(Dt, Xt) {
    var Bt = Dt.toJSON();
    function mt(Ot) {
      if (!Dt(Ot)) return !1;
      if (Ot.length === Xt) return !0;
      throw B.tfCustomError(Bt + "(Length: " + Xt + ")", Bt + "(Length: " + Ot.length + ")");
    }
    return mt.toJSON = function() {
      return Bt;
    }, mt;
  }
  var re = J.bind(null, A.Array), ne = J.bind(null, L), ie = J.bind(null, V), pe = J.bind(null, A.String);
  function nt(Dt, Xt, Bt) {
    Bt = Bt || A.Number;
    function mt(Ot, wt) {
      return Bt(Ot, wt) && Ot > Dt && Ot < Xt;
    }
    return mt.toJSON = function() {
      return `${Bt.toJSON()} between [${Dt}, ${Xt}]`;
    }, mt;
  }
  var oe = Math.pow(2, 53) - 1;
  function Ce(Dt) {
    return typeof Dt == "number" && isFinite(Dt);
  }
  function at(Dt) {
    return Dt << 24 >> 24 === Dt;
  }
  function it(Dt) {
    return Dt << 16 >> 16 === Dt;
  }
  function gt(Dt) {
    return (Dt | 0) === Dt;
  }
  function St(Dt) {
    return typeof Dt == "number" && Dt >= -oe && Dt <= oe && Math.floor(Dt) === Dt;
  }
  function xt(Dt) {
    return (Dt & 255) === Dt;
  }
  function Mt(Dt) {
    return (Dt & 65535) === Dt;
  }
  function bt(Dt) {
    return Dt >>> 0 === Dt;
  }
  function Tt(Dt) {
    return typeof Dt == "number" && Dt >= 0 && Dt <= oe && Math.floor(Dt) === Dt;
  }
  var It = {
    ArrayN: re,
    Buffer: L,
    BufferN: ne,
    Finite: Ce,
    Hex: V,
    HexN: ie,
    Int8: at,
    Int16: it,
    Int32: gt,
    Int53: St,
    Range: nt,
    StringN: pe,
    UInt8: xt,
    UInt16: Mt,
    UInt32: bt,
    UInt53: Tt
  };
  for (var qt in It)
    It[qt].toJSON = (function(Dt) {
      return Dt;
    }).bind(null, qt);
  return extra = It, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function A(B, L) {
    B = compile(B), L = L || {};
    function V(J, re) {
      return !NATIVE.Array(J) || NATIVE.Nil(J) || L.minLength !== void 0 && J.length < L.minLength || L.maxLength !== void 0 && J.length > L.maxLength || L.length !== void 0 && J.length !== L.length ? !1 : J.every(function(ne, ie) {
        try {
          return typeforce$3(B, ne, re);
        } catch (pe) {
          throw tfSubError(pe, ie);
        }
      });
    }
    return V.toJSON = function() {
      var J = "[" + tfJSON(B) + "]";
      return L.length !== void 0 ? J += "{" + L.length + "}" : (L.minLength !== void 0 || L.maxLength !== void 0) && (J += "{" + (L.minLength === void 0 ? 0 : L.minLength) + "," + (L.maxLength === void 0 ? 1 / 0 : L.maxLength) + "}"), J;
    }, V;
  },
  maybe: function A(B) {
    B = compile(B);
    function L(V, J) {
      return NATIVE.Nil(V) || B(V, J, A);
    }
    return L.toJSON = function() {
      return "?" + tfJSON(B);
    }, L;
  },
  map: function A(B, L) {
    B = compile(B), L && (L = compile(L));
    function V(J, re) {
      if (!NATIVE.Object(J) || NATIVE.Nil(J)) return !1;
      for (var ne in J) {
        try {
          L && typeforce$3(L, ne, re);
        } catch (pe) {
          throw tfSubError(pe, ne, "key");
        }
        try {
          var ie = J[ne];
          typeforce$3(B, ie, re);
        } catch (pe) {
          throw tfSubError(pe, ne);
        }
      }
      return !0;
    }
    return L ? V.toJSON = function() {
      return "{" + tfJSON(L) + ": " + tfJSON(B) + "}";
    } : V.toJSON = function() {
      return "{" + tfJSON(B) + "}";
    }, V;
  },
  object: function A(B) {
    var L = {};
    for (var V in B)
      L[V] = compile(B[V]);
    function J(re, ne) {
      if (!NATIVE.Object(re) || NATIVE.Nil(re)) return !1;
      var ie;
      try {
        for (ie in L) {
          var pe = L[ie], nt = re[ie];
          typeforce$3(pe, nt, ne);
        }
      } catch (oe) {
        throw tfSubError(oe, ie);
      }
      if (ne) {
        for (ie in re)
          if (!L[ie])
            throw new TfPropertyTypeError(void 0, ie);
      }
      return !0;
    }
    return J.toJSON = function() {
      return tfJSON(L);
    }, J;
  },
  anyOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(V, J) {
      return B.some(function(re) {
        try {
          return typeforce$3(re, V, J);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join("|");
    }, L;
  },
  allOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(V, J) {
      return B.every(function(re) {
        try {
          return typeforce$3(re, V, J);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join(" & ");
    }, L;
  },
  quacksLike: function A(B) {
    function L(V) {
      return B === getValueTypeName(V);
    }
    return L.toJSON = function() {
      return B;
    }, L;
  },
  tuple: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(V, J) {
      return NATIVE.Nil(V) || NATIVE.Nil(V.length) || J && V.length !== B.length ? !1 : B.every(function(re, ne) {
        try {
          return typeforce$3(re, V[ne], J);
        } catch (ie) {
          throw tfSubError(ie, ne);
        }
      });
    }
    return L.toJSON = function() {
      return "(" + B.map(tfJSON).join(", ") + ")";
    }, L;
  },
  value: function A(B) {
    function L(V) {
      return V === B;
    }
    return L.toJSON = function() {
      return B;
    }, L;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(A) {
  if (NATIVE.String(A))
    return A[0] === "?" ? TYPES.maybe(A.slice(1)) : NATIVE[A] || TYPES.quacksLike(A);
  if (A && NATIVE.Object(A)) {
    if (NATIVE.Array(A)) {
      if (A.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(A[0]);
    }
    return TYPES.object(A);
  } else if (NATIVE.Function(A))
    return A;
  return TYPES.value(A);
}
function typeforce$3(A, B, L, V) {
  if (NATIVE.Function(A)) {
    if (A(B, L)) return !0;
    throw new TfTypeError(V || A, B);
  }
  return typeforce$3(compile(A), B, L);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.oneOf = A.Null = A.BufferN = A.Function = A.UInt32 = A.UInt8 = A.tuple = A.maybe = A.Hex = A.Buffer = A.String = A.Boolean = A.Array = A.Number = A.Hash256bit = A.Hash160bit = A.Buffer256bit = A.isTaptree = A.isTapleaf = A.TAPLEAF_VERSION_MASK = A.Satoshi = A.isPoint = A.stacksEqual = A.typeforce = void 0;
  const B = dist$1;
  A.typeforce = typeforce_1;
  const L = B.Buffer.alloc(32, 0), V = B.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function J(oe, Ce) {
    return oe.length !== Ce.length ? !1 : oe.every((at, it) => at.equals(Ce[it]));
  }
  A.stacksEqual = J;
  function re(oe) {
    if (!B.Buffer.isBuffer(oe) || oe.length < 33) return !1;
    const Ce = oe[0], at = oe.slice(1, 33);
    if (at.compare(L) === 0 || at.compare(V) >= 0) return !1;
    if ((Ce === 2 || Ce === 3) && oe.length === 33)
      return !0;
    const it = oe.slice(33);
    return it.compare(L) === 0 || it.compare(V) >= 0 ? !1 : Ce === 4 && oe.length === 65;
  }
  A.isPoint = re;
  const ne = 21 * 1e14;
  function ie(oe) {
    return A.typeforce.UInt53(oe) && oe <= ne;
  }
  A.Satoshi = ie, A.TAPLEAF_VERSION_MASK = 254;
  function pe(oe) {
    return !oe || !("output" in oe) || !B.Buffer.isBuffer(oe.output) ? !1 : oe.version !== void 0 ? (oe.version & A.TAPLEAF_VERSION_MASK) === oe.version : !0;
  }
  A.isTapleaf = pe;
  function nt(oe) {
    return (0, A.Array)(oe) ? oe.length !== 2 ? !1 : oe.every((Ce) => nt(Ce)) : pe(oe);
  }
  A.isTaptree = nt, A.Buffer256bit = A.typeforce.BufferN(32), A.Hash160bit = A.typeforce.BufferN(20), A.Hash256bit = A.typeforce.BufferN(32), A.Number = A.typeforce.Number, A.Array = A.typeforce.Array, A.Boolean = A.typeforce.Boolean, A.String = A.typeforce.String, A.Buffer = A.typeforce.Buffer, A.Hex = A.typeforce.Hex, A.maybe = A.typeforce.maybe, A.tuple = A.typeforce.tuple, A.UInt8 = A.typeforce.UInt8, A.UInt32 = A.typeforce.UInt32, A.Function = A.typeforce.Function, A.BufferN = A.typeforce.BufferN, A.Null = A.typeforce.Null, A.oneOf = A.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const A = bip66, B = requireScript(), L = types$4, { typeforce: V } = L, J = Buffer$D.alloc(1, 0);
  function re(nt) {
    let oe = 0;
    for (; nt[oe] === 0; ) ++oe;
    return oe === nt.length ? J : (nt = nt.slice(oe), nt[0] & 128 ? Buffer$D.concat([J, nt], 1 + nt.length) : nt);
  }
  function ne(nt) {
    nt[0] === 0 && (nt = nt.slice(1));
    const oe = Buffer$D.alloc(32, 0), Ce = Math.max(0, 32 - nt.length);
    return nt.copy(oe, Ce), oe;
  }
  function ie(nt) {
    const oe = nt.readUInt8(nt.length - 1);
    if (!(0, B.isDefinedHashType)(oe))
      throw new Error("Invalid hashType " + oe);
    const Ce = A.decode(nt.slice(0, -1)), at = ne(Ce.r), it = ne(Ce.s);
    return { signature: Buffer$D.concat([at, it], 64), hashType: oe };
  }
  script_signature.decode = ie;
  function pe(nt, oe) {
    if (V(
      {
        signature: L.BufferN(64),
        hashType: L.UInt8
      },
      { signature: nt, hashType: oe }
    ), !(0, B.isDefinedHashType)(oe))
      throw new Error("Invalid hashType " + oe);
    const Ce = Buffer$D.allocUnsafe(1);
    Ce.writeUInt8(oe, 0);
    const at = re(nt.slice(0, 32)), it = re(nt.slice(32, 64));
    return Buffer$D.concat([A.encode(at, it), Ce]);
  }
  return script_signature.encode = pe, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.signature = A.number = A.isCanonicalScriptSignature = A.isDefinedHashType = A.isCanonicalPubKey = A.toStack = A.fromASM = A.toASM = A.decompile = A.compile = A.countNonPushOnlyOPs = A.isPushOnly = A.OPS = void 0;
    const B = bip66, L = ops;
    Object.defineProperty(A, "OPS", {
      enumerable: !0,
      get: function() {
        return L.OPS;
      }
    });
    const V = push_data, J = script_number, re = requireScript_signature(), ne = types$4, { typeforce: ie } = ne, pe = L.OPS.OP_RESERVED;
    function nt(mt) {
      return ne.Number(mt) && (mt === L.OPS.OP_0 || mt >= L.OPS.OP_1 && mt <= L.OPS.OP_16 || mt === L.OPS.OP_1NEGATE);
    }
    function oe(mt) {
      return ne.Buffer(mt) || nt(mt);
    }
    function Ce(mt) {
      return ne.Array(mt) && mt.every(oe);
    }
    A.isPushOnly = Ce;
    function at(mt) {
      return mt.length - mt.filter(oe).length;
    }
    A.countNonPushOnlyOPs = at;
    function it(mt) {
      if (mt.length === 0) return L.OPS.OP_0;
      if (mt.length === 1) {
        if (mt[0] >= 1 && mt[0] <= 16) return pe + mt[0];
        if (mt[0] === 129) return L.OPS.OP_1NEGATE;
      }
    }
    function gt(mt) {
      return Buffer$D.isBuffer(mt);
    }
    function St(mt) {
      return ne.Array(mt);
    }
    function xt(mt) {
      return Buffer$D.isBuffer(mt);
    }
    function Mt(mt) {
      if (gt(mt)) return mt;
      ie(ne.Array, mt);
      const Ot = mt.reduce((rt, ce) => xt(ce) ? ce.length === 1 && it(ce) !== void 0 ? rt + 1 : rt + V.encodingLength(ce.length) + ce.length : rt + 1, 0), wt = Buffer$D.allocUnsafe(Ot);
      let ke = 0;
      if (mt.forEach((rt) => {
        if (xt(rt)) {
          const ce = it(rt);
          if (ce !== void 0) {
            wt.writeUInt8(ce, ke), ke += 1;
            return;
          }
          ke += V.encode(wt, rt.length, ke), rt.copy(wt, ke), ke += rt.length;
        } else
          wt.writeUInt8(rt, ke), ke += 1;
      }), ke !== wt.length) throw new Error("Could not decode chunks");
      return wt;
    }
    A.compile = Mt;
    function bt(mt) {
      if (St(mt)) return mt;
      ie(ne.Buffer, mt);
      const Ot = [];
      let wt = 0;
      for (; wt < mt.length; ) {
        const ke = mt[wt];
        if (ke > L.OPS.OP_0 && ke <= L.OPS.OP_PUSHDATA4) {
          const rt = V.decode(mt, wt);
          if (rt === null || (wt += rt.size, wt + rt.number > mt.length)) return null;
          const ce = mt.slice(wt, wt + rt.number);
          wt += rt.number;
          const Oe = it(ce);
          Oe !== void 0 ? Ot.push(Oe) : Ot.push(ce);
        } else
          Ot.push(ke), wt += 1;
      }
      return Ot;
    }
    A.decompile = bt;
    function Tt(mt) {
      if (gt(mt) && (mt = bt(mt)), !mt)
        throw new Error("Could not convert invalid chunks to ASM");
      return mt.map((Ot) => {
        if (xt(Ot)) {
          const wt = it(Ot);
          if (wt === void 0) return Ot.toString("hex");
          Ot = wt;
        }
        return L.REVERSE_OPS[Ot];
      }).join(" ");
    }
    A.toASM = Tt;
    function It(mt) {
      return ie(ne.String, mt), Mt(
        mt.split(" ").map((Ot) => L.OPS[Ot] !== void 0 ? L.OPS[Ot] : (ie(ne.Hex, Ot), Buffer$D.from(Ot, "hex")))
      );
    }
    A.fromASM = It;
    function qt(mt) {
      return mt = bt(mt), ie(Ce, mt), mt.map((Ot) => xt(Ot) ? Ot : Ot === L.OPS.OP_0 ? Buffer$D.allocUnsafe(0) : J.encode(Ot - pe));
    }
    A.toStack = qt;
    function Dt(mt) {
      return ne.isPoint(mt);
    }
    A.isCanonicalPubKey = Dt;
    function Xt(mt) {
      const Ot = mt & -129;
      return Ot > 0 && Ot < 4;
    }
    A.isDefinedHashType = Xt;
    function Bt(mt) {
      return !Buffer$D.isBuffer(mt) || !Xt(mt[mt.length - 1]) ? !1 : B.check(mt.slice(0, -1));
    }
    A.isCanonicalScriptSignature = Bt, A.number = J, A.signature = re;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(A, B, L) {
  Object.defineProperty(A, B, {
    configurable: !0,
    enumerable: !0,
    get() {
      const V = L.call(this);
      return this[B] = V, V;
    },
    set(V) {
      Object.defineProperty(this, B, {
        configurable: !0,
        enumerable: !0,
        value: V,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(A) {
  let B;
  return () => (B !== void 0 || (B = A()), B);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(A, B) {
  if (!A.data && !A.output) throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    A
  );
  const V = { name: "embed", network: A.network || networks_1$7.bitcoin };
  if (lazy$6.prop(V, "output", () => {
    if (A.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(A.data));
  }), lazy$6.prop(V, "data", () => {
    if (A.output)
      return bscript$9.decompile(A.output).slice(1);
  }), B.validate && A.output) {
    const J = bscript$9.decompile(A.output);
    if (J[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!J.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (A.data && !(0, types_1$7.stacksEqual)(A.data, V.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(V, A);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(A, B) {
  if (!A.input && !A.output && !(A.pubkeys && A.m !== void 0) && !A.signatures)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {});
  function L(pe) {
    return bscript$8.isCanonicalScriptSignature(pe) || (B.allowIncomplete && pe === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(L)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    A
  );
  const J = { network: A.network || networks_1$6.bitcoin };
  let re = [], ne = !1;
  function ie(pe) {
    ne || (ne = !0, re = bscript$8.decompile(pe), J.m = re[0] - OP_INT_BASE, J.n = re[re.length - 2] - OP_INT_BASE, J.pubkeys = re.slice(1, -2));
  }
  if (lazy$5.prop(J, "output", () => {
    if (A.m && J.n && A.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + A.m,
          A.pubkeys,
          OP_INT_BASE + J.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(J, "m", () => {
    if (J.output)
      return ie(J.output), J.m;
  }), lazy$5.prop(J, "n", () => {
    if (J.pubkeys)
      return J.pubkeys.length;
  }), lazy$5.prop(J, "pubkeys", () => {
    if (A.output)
      return ie(A.output), J.pubkeys;
  }), lazy$5.prop(J, "signatures", () => {
    if (A.input)
      return bscript$8.decompile(A.input).slice(1);
  }), lazy$5.prop(J, "input", () => {
    if (A.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(A.signatures));
  }), lazy$5.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), lazy$5.prop(J, "name", () => {
    if (!(!J.m || !J.n))
      return `p2ms(${J.m} of ${J.n})`;
  }), B.validate) {
    if (A.output) {
      if (ie(A.output), !types_1$6.typeforce.Number(re[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(re[re.length - 2]))
        throw new TypeError("Output is invalid");
      if (re[re.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (J.m <= 0 || J.n > 16 || J.m > J.n || J.n !== re.length - 3)
        throw new TypeError("Output is invalid");
      if (!J.pubkeys.every((pe) => (0, types_1$6.isPoint)(pe)))
        throw new TypeError("Output is invalid");
      if (A.m !== void 0 && A.m !== J.m) throw new TypeError("m mismatch");
      if (A.n !== void 0 && A.n !== J.n) throw new TypeError("n mismatch");
      if (A.pubkeys && !(0, types_1$6.stacksEqual)(A.pubkeys, J.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (A.pubkeys) {
      if (A.n !== void 0 && A.n !== A.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (J.n = A.pubkeys.length, J.n < J.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (A.signatures) {
      if (A.signatures.length < J.m)
        throw new TypeError("Not enough signatures provided");
      if (A.signatures.length > J.m)
        throw new TypeError("Too many signatures provided");
    }
    if (A.input) {
      if (A.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (J.signatures.length === 0 || !J.signatures.every(L))
        throw new TypeError("Input has invalid signature(s)");
      if (A.signatures && !(0, types_1$6.stacksEqual)(A.signatures, J.signatures))
        throw new TypeError("Signature mismatch");
      if (A.m !== void 0 && A.m !== A.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(J, A);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(A, B) {
  if (!A.input && !A.output && !A.pubkey && !A.input && !A.signature)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    A
  );
  const L = lazy$4.value(() => bscript$7.decompile(A.input)), J = { name: "p2pk", network: A.network || networks_1$5.bitcoin };
  if (lazy$4.prop(J, "output", () => {
    if (A.pubkey)
      return bscript$7.compile([A.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(J, "pubkey", () => {
    if (A.output)
      return A.output.slice(1, -1);
  }), lazy$4.prop(J, "signature", () => {
    if (A.input)
      return L()[0];
  }), lazy$4.prop(J, "input", () => {
    if (A.signature)
      return bscript$7.compile([A.signature]);
  }), lazy$4.prop(J, "witness", () => {
    if (J.input)
      return [];
  }), B.validate) {
    if (A.output) {
      if (A.output[A.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(J.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (A.pubkey && !A.pubkey.equals(J.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (A.signature && A.input && !A.input.equals(J.input))
      throw new TypeError("Signature mismatch");
    if (A.input) {
      if (L().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(J.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(J, A);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$p, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((A, B) => B)), Pi = /* @__PURE__ */ Id.map((A) => (9 * A + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let A = 0; A < 4; A++)
  for (let B of [idxL, idxR])
    B.push(B[A].map((L) => Rho[L]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((A) => new Uint8Array(A)), shiftsL = /* @__PURE__ */ idxL.map((A, B) => A.map((L) => shifts[B][L])), shiftsR = /* @__PURE__ */ idxR.map((A, B) => A.map((L) => shifts[B][L])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(A, B, L, V) {
  return A === 0 ? B ^ L ^ V : A === 1 ? B & L | ~B & V : A === 2 ? (B | ~L) ^ V : A === 3 ? B & V | L & ~V : B ^ (L | ~V);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: B, h1: L, h2: V, h3: J, h4: re } = this;
    return [B, L, V, J, re];
  }
  set(B, L, V, J, re) {
    this.h0 = B | 0, this.h1 = L | 0, this.h2 = V | 0, this.h3 = J | 0, this.h4 = re | 0;
  }
  process(B, L) {
    for (let it = 0; it < 16; it++, L += 4)
      R_BUF[it] = B.getUint32(L, !0);
    let V = this.h0 | 0, J = V, re = this.h1 | 0, ne = re, ie = this.h2 | 0, pe = ie, nt = this.h3 | 0, oe = nt, Ce = this.h4 | 0, at = Ce;
    for (let it = 0; it < 5; it++) {
      const gt = 4 - it, St = Kl[it], xt = Kr[it], Mt = idxL[it], bt = idxR[it], Tt = shiftsL[it], It = shiftsR[it];
      for (let qt = 0; qt < 16; qt++) {
        const Dt = (0, utils_js_1$1.rotl)(V + f(it, re, ie, nt) + R_BUF[Mt[qt]] + St, Tt[qt]) + Ce | 0;
        V = Ce, Ce = nt, nt = (0, utils_js_1$1.rotl)(ie, 10) | 0, ie = re, re = Dt;
      }
      for (let qt = 0; qt < 16; qt++) {
        const Dt = (0, utils_js_1$1.rotl)(J + f(gt, ne, pe, oe) + R_BUF[bt[qt]] + xt, It[qt]) + at | 0;
        J = at, at = oe, oe = (0, utils_js_1$1.rotl)(pe, 10) | 0, pe = ne, ne = Dt;
      }
    }
    this.set(this.h1 + ie + oe | 0, this.h2 + nt + at | 0, this.h3 + Ce + J | 0, this.h4 + V + ne | 0, this.h0 + re + pe | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$p, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: B, B: L, C: V, D: J, E: re } = this;
    return [B, L, V, J, re];
  }
  set(B, L, V, J, re) {
    this.A = B | 0, this.B = L | 0, this.C = V | 0, this.D = J | 0, this.E = re | 0;
  }
  process(B, L) {
    for (let pe = 0; pe < 16; pe++, L += 4)
      SHA1_W[pe] = B.getUint32(L, !1);
    for (let pe = 16; pe < 80; pe++)
      SHA1_W[pe] = (0, utils_js_1.rotl)(SHA1_W[pe - 3] ^ SHA1_W[pe - 8] ^ SHA1_W[pe - 14] ^ SHA1_W[pe - 16], 1);
    let { A: V, B: J, C: re, D: ne, E: ie } = this;
    for (let pe = 0; pe < 80; pe++) {
      let nt, oe;
      pe < 20 ? (nt = (0, _md_js_1.Chi)(J, re, ne), oe = 1518500249) : pe < 40 ? (nt = J ^ re ^ ne, oe = 1859775393) : pe < 60 ? (nt = (0, _md_js_1.Maj)(J, re, ne), oe = 2400959708) : (nt = J ^ re ^ ne, oe = 3395469782);
      const Ce = (0, utils_js_1.rotl)(V, 5) + nt + ie + oe + SHA1_W[pe] | 0;
      ie = ne, ne = re, re = (0, utils_js_1.rotl)(J, 30), J = V, V = Ce;
    }
    V = V + this.A | 0, J = J + this.B | 0, re = re + this.C | 0, ne = ne + this.D | 0, ie = ie + this.E | 0, this.set(V, J, re, ne, ie);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.taggedHash = A.TAGGED_HASH_PREFIXES = A.TAGS = A.hash256 = A.hash160 = A.sha256 = A.sha1 = A.ripemd160 = void 0;
  const B = ripemd160, L = sha1, V = sha256$4;
  function J(oe) {
    return Buffer$D.from((0, B.ripemd160)(Uint8Array.from(oe)));
  }
  A.ripemd160 = J;
  function re(oe) {
    return Buffer$D.from((0, L.sha1)(Uint8Array.from(oe)));
  }
  A.sha1 = re;
  function ne(oe) {
    return Buffer$D.from((0, V.sha256)(Uint8Array.from(oe)));
  }
  A.sha256 = ne;
  function ie(oe) {
    return Buffer$D.from(
      (0, B.ripemd160)((0, V.sha256)(Uint8Array.from(oe)))
    );
  }
  A.hash160 = ie;
  function pe(oe) {
    return Buffer$D.from(
      (0, V.sha256)((0, V.sha256)(Uint8Array.from(oe)))
    );
  }
  A.hash256 = pe, A.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], A.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$D.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$D.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$D.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$D.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$D.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$D.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$D.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$D.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$D.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function nt(oe, Ce) {
    return ne(Buffer$D.concat([A.TAGGED_HASH_PREFIXES[oe], Ce]));
  }
  A.taggedHash = nt;
})(crypto$1);
function base$1(A) {
  if (A.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var B = new Uint8Array(256), L = 0; L < B.length; L++)
    B[L] = 255;
  for (var V = 0; V < A.length; V++) {
    var J = A.charAt(V), re = J.charCodeAt(0);
    if (B[re] !== 255)
      throw new TypeError(J + " is ambiguous");
    B[re] = V;
  }
  var ne = A.length, ie = A.charAt(0), pe = Math.log(ne) / Math.log(256), nt = Math.log(256) / Math.log(ne);
  function oe(it) {
    if (it instanceof Uint8Array || (ArrayBuffer.isView(it) ? it = new Uint8Array(it.buffer, it.byteOffset, it.byteLength) : Array.isArray(it) && (it = Uint8Array.from(it))), !(it instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (it.length === 0)
      return "";
    for (var gt = 0, St = 0, xt = 0, Mt = it.length; xt !== Mt && it[xt] === 0; )
      xt++, gt++;
    for (var bt = (Mt - xt) * nt + 1 >>> 0, Tt = new Uint8Array(bt); xt !== Mt; ) {
      for (var It = it[xt], qt = 0, Dt = bt - 1; (It !== 0 || qt < St) && Dt !== -1; Dt--, qt++)
        It += 256 * Tt[Dt] >>> 0, Tt[Dt] = It % ne >>> 0, It = It / ne >>> 0;
      if (It !== 0)
        throw new Error("Non-zero carry");
      St = qt, xt++;
    }
    for (var Xt = bt - St; Xt !== bt && Tt[Xt] === 0; )
      Xt++;
    for (var Bt = ie.repeat(gt); Xt < bt; ++Xt)
      Bt += A.charAt(Tt[Xt]);
    return Bt;
  }
  function Ce(it) {
    if (typeof it != "string")
      throw new TypeError("Expected String");
    if (it.length === 0)
      return new Uint8Array();
    for (var gt = 0, St = 0, xt = 0; it[gt] === ie; )
      St++, gt++;
    for (var Mt = (it.length - gt) * pe + 1 >>> 0, bt = new Uint8Array(Mt); it[gt]; ) {
      var Tt = B[it.charCodeAt(gt)];
      if (Tt === 255)
        return;
      for (var It = 0, qt = Mt - 1; (Tt !== 0 || It < xt) && qt !== -1; qt--, It++)
        Tt += ne * bt[qt] >>> 0, bt[qt] = Tt % 256 >>> 0, Tt = Tt / 256 >>> 0;
      if (Tt !== 0)
        throw new Error("Non-zero carry");
      xt = It, gt++;
    }
    for (var Dt = Mt - xt; Dt !== Mt && bt[Dt] === 0; )
      Dt++;
    for (var Xt = new Uint8Array(St + (Mt - Dt)), Bt = St; Dt !== Mt; )
      Xt[Bt++] = bt[Dt++];
    return Xt;
  }
  function at(it) {
    var gt = Ce(it);
    if (gt)
      return gt;
    throw new Error("Non-base" + ne + " character");
  }
  return {
    encode: oe,
    decodeUnsafe: Ce,
    decode: at
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(A) {
  function B(re) {
    var ne = Uint8Array.from(re), ie = A(ne), pe = ne.length + 4, nt = new Uint8Array(pe);
    return nt.set(ne, 0), nt.set(ie.subarray(0, 4), ne.length), base58.encode(nt, pe);
  }
  function L(re) {
    var ne = re.slice(0, -4), ie = re.slice(-4), pe = A(ne);
    if (!(ie[0] ^ pe[0] | ie[1] ^ pe[1] | ie[2] ^ pe[2] | ie[3] ^ pe[3]))
      return ne;
  }
  function V(re) {
    var ne = base58.decodeUnsafe(re);
    if (ne)
      return L(ne);
  }
  function J(re) {
    var ne = base58.decode(re), ie = L(ne);
    if (!ie) throw new Error("Invalid checksum");
    return ie;
  }
  return {
    encode: B,
    decode: J,
    decodeUnsafe: V
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(A) {
  return sha256(sha256(A));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    A
  );
  const L = lazy$3.value(() => {
    const ne = Buffer$D.from(bs58check$1.decode(A.address)), ie = ne.readUInt8(0), pe = ne.slice(1);
    return { version: ie, hash: pe };
  }), V = lazy$3.value(() => bscript$6.decompile(A.input)), J = A.network || networks_1$4.bitcoin, re = { name: "p2pkh", network: J };
  if (lazy$3.prop(re, "address", () => {
    if (!re.hash) return;
    const ne = Buffer$D.allocUnsafe(21);
    return ne.writeUInt8(J.pubKeyHash, 0), re.hash.copy(ne, 1), bs58check$1.encode(ne);
  }), lazy$3.prop(re, "hash", () => {
    if (A.output) return A.output.slice(3, 23);
    if (A.address) return L().hash;
    if (A.pubkey || re.pubkey) return bcrypto$5.hash160(A.pubkey || re.pubkey);
  }), lazy$3.prop(re, "output", () => {
    if (re.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        re.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(re, "pubkey", () => {
    if (A.input)
      return V()[1];
  }), lazy$3.prop(re, "signature", () => {
    if (A.input)
      return V()[0];
  }), lazy$3.prop(re, "input", () => {
    if (A.pubkey && A.signature)
      return bscript$6.compile([A.signature, A.pubkey]);
  }), lazy$3.prop(re, "witness", () => {
    if (re.input)
      return [];
  }), B.validate) {
    let ne = Buffer$D.from([]);
    if (A.address) {
      if (L().version !== J.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (L().hash.length !== 20) throw new TypeError("Invalid address");
      ne = L().hash;
    }
    if (A.hash) {
      if (ne.length > 0 && !ne.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ne = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 25 || A.output[0] !== OPS$3.OP_DUP || A.output[1] !== OPS$3.OP_HASH160 || A.output[2] !== 20 || A.output[23] !== OPS$3.OP_EQUALVERIFY || A.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ie = A.output.slice(3, 23);
      if (ne.length > 0 && !ne.equals(ie))
        throw new TypeError("Hash mismatch");
      ne = ie;
    }
    if (A.pubkey) {
      const ie = bcrypto$5.hash160(A.pubkey);
      if (ne.length > 0 && !ne.equals(ie))
        throw new TypeError("Hash mismatch");
      ne = ie;
    }
    if (A.input) {
      const ie = V();
      if (ie.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ie[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ie[1]))
        throw new TypeError("Input has invalid pubkey");
      if (A.signature && !A.signature.equals(ie[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(ie[1]))
        throw new TypeError("Pubkey mismatch");
      const pe = bcrypto$5.hash160(ie[1]);
      if (ne.length > 0 && !ne.equals(pe))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(re, A);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    A
  );
  let L = A.network;
  L || (L = A.redeem && A.redeem.network || networks_1$3.bitcoin);
  const V = { network: L }, J = lazy$2.value(() => {
    const ie = Buffer$D.from(bs58check.decode(A.address)), pe = ie.readUInt8(0), nt = ie.slice(1);
    return { version: pe, hash: nt };
  }), re = lazy$2.value(() => bscript$5.decompile(A.input)), ne = lazy$2.value(() => {
    const ie = re(), pe = ie[ie.length - 1];
    return {
      network: L,
      output: pe === OPS$2.OP_FALSE ? Buffer$D.from([]) : pe,
      input: bscript$5.compile(ie.slice(0, -1)),
      witness: A.witness || []
    };
  });
  if (lazy$2.prop(V, "address", () => {
    if (!V.hash) return;
    const ie = Buffer$D.allocUnsafe(21);
    return ie.writeUInt8(V.network.scriptHash, 0), V.hash.copy(ie, 1), bs58check.encode(ie);
  }), lazy$2.prop(V, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return J().hash;
    if (V.redeem && V.redeem.output) return bcrypto$4.hash160(V.redeem.output);
  }), lazy$2.prop(V, "output", () => {
    if (V.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, V.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(V, "redeem", () => {
    if (A.input)
      return ne();
  }), lazy$2.prop(V, "input", () => {
    if (!(!A.redeem || !A.redeem.input || !A.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(A.redeem.input), A.redeem.output)
      );
  }), lazy$2.prop(V, "witness", () => {
    if (V.redeem && V.redeem.witness) return V.redeem.witness;
    if (V.input) return [];
  }), lazy$2.prop(V, "name", () => {
    const ie = ["p2sh"];
    return V.redeem !== void 0 && V.redeem.name !== void 0 && ie.push(V.redeem.name), ie.join("-");
  }), B.validate) {
    let ie = Buffer$D.from([]);
    if (A.address) {
      if (J().version !== L.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (J().hash.length !== 20) throw new TypeError("Invalid address");
      ie = J().hash;
    }
    if (A.hash) {
      if (ie.length > 0 && !ie.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ie = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 23 || A.output[0] !== OPS$2.OP_HASH160 || A.output[1] !== 20 || A.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const nt = A.output.slice(2, 22);
      if (ie.length > 0 && !ie.equals(nt))
        throw new TypeError("Hash mismatch");
      ie = nt;
    }
    const pe = (nt) => {
      if (nt.output) {
        const oe = bscript$5.decompile(nt.output);
        if (!oe || oe.length < 1)
          throw new TypeError("Redeem.output too short");
        if (nt.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(oe) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const Ce = bcrypto$4.hash160(nt.output);
        if (ie.length > 0 && !ie.equals(Ce))
          throw new TypeError("Hash mismatch");
        ie = Ce;
      }
      if (nt.input) {
        const oe = nt.input.length > 0, Ce = nt.witness && nt.witness.length > 0;
        if (!oe && !Ce) throw new TypeError("Empty input");
        if (oe && Ce)
          throw new TypeError("Input and witness provided");
        if (oe) {
          const at = bscript$5.decompile(nt.input);
          if (!bscript$5.isPushOnly(at))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (A.input) {
      const nt = re();
      if (!nt || nt.length < 1) throw new TypeError("Input too short");
      if (!Buffer$D.isBuffer(ne().output))
        throw new TypeError("Input is invalid");
      pe(ne());
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== L)
        throw new TypeError("Network mismatch");
      if (A.input) {
        const nt = ne();
        if (A.redeem.output && !A.redeem.output.equals(nt.output))
          throw new TypeError("Redeem.output mismatch");
        if (A.redeem.input && !A.redeem.input.equals(nt.input))
          throw new TypeError("Redeem.input mismatch");
      }
      pe(A.redeem);
    }
    if (A.witness && A.redeem && A.redeem.witness && !(0, types_1$3.stacksEqual)(A.redeem.witness, A.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(V, A);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let A = 0; A < ALPHABET.length; A++) {
  const B = ALPHABET.charAt(A);
  ALPHABET_MAP[B] = A;
}
function polymodStep(A) {
  const B = A >> 25;
  return (A & 33554431) << 5 ^ -(B >> 0 & 1) & 996825010 ^ -(B >> 1 & 1) & 642813549 ^ -(B >> 2 & 1) & 513874426 ^ -(B >> 3 & 1) & 1027748829 ^ -(B >> 4 & 1) & 705979059;
}
function prefixChk(A) {
  let B = 1;
  for (let L = 0; L < A.length; ++L) {
    const V = A.charCodeAt(L);
    if (V < 33 || V > 126)
      return "Invalid prefix (" + A + ")";
    B = polymodStep(B) ^ V >> 5;
  }
  B = polymodStep(B);
  for (let L = 0; L < A.length; ++L) {
    const V = A.charCodeAt(L);
    B = polymodStep(B) ^ V & 31;
  }
  return B;
}
function convert$2(A, B, L, V) {
  let J = 0, re = 0;
  const ne = (1 << L) - 1, ie = [];
  for (let pe = 0; pe < A.length; ++pe)
    for (J = J << B | A[pe], re += B; re >= L; )
      re -= L, ie.push(J >> re & ne);
  if (V)
    re > 0 && ie.push(J << L - re & ne);
  else {
    if (re >= B)
      return "Excess padding";
    if (J << L - re & ne)
      return "Non-zero padding";
  }
  return ie;
}
function toWords(A) {
  return convert$2(A, 8, 5, !0);
}
function fromWordsUnsafe(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
}
function fromWords(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
  throw new Error(B);
}
function getLibraryFromEncoding(A) {
  let B;
  A === "bech32" ? B = 1 : B = 734539939;
  function L(ne, ie, pe) {
    if (pe = pe || 90, ne.length + 7 + ie.length > pe)
      throw new TypeError("Exceeds length limit");
    ne = ne.toLowerCase();
    let nt = prefixChk(ne);
    if (typeof nt == "string")
      throw new Error(nt);
    let oe = ne + "1";
    for (let Ce = 0; Ce < ie.length; ++Ce) {
      const at = ie[Ce];
      if (at >> 5)
        throw new Error("Non 5-bit word");
      nt = polymodStep(nt) ^ at, oe += ALPHABET.charAt(at);
    }
    for (let Ce = 0; Ce < 6; ++Ce)
      nt = polymodStep(nt);
    nt ^= B;
    for (let Ce = 0; Ce < 6; ++Ce) {
      const at = nt >> (5 - Ce) * 5 & 31;
      oe += ALPHABET.charAt(at);
    }
    return oe;
  }
  function V(ne, ie) {
    if (ie = ie || 90, ne.length < 8)
      return ne + " too short";
    if (ne.length > ie)
      return "Exceeds length limit";
    const pe = ne.toLowerCase(), nt = ne.toUpperCase();
    if (ne !== pe && ne !== nt)
      return "Mixed-case string " + ne;
    ne = pe;
    const oe = ne.lastIndexOf("1");
    if (oe === -1)
      return "No separator character for " + ne;
    if (oe === 0)
      return "Missing prefix for " + ne;
    const Ce = ne.slice(0, oe), at = ne.slice(oe + 1);
    if (at.length < 6)
      return "Data too short";
    let it = prefixChk(Ce);
    if (typeof it == "string")
      return it;
    const gt = [];
    for (let St = 0; St < at.length; ++St) {
      const xt = at.charAt(St), Mt = ALPHABET_MAP[xt];
      if (Mt === void 0)
        return "Unknown character " + xt;
      it = polymodStep(it) ^ Mt, !(St + 6 >= at.length) && gt.push(Mt);
    }
    return it !== B ? "Invalid checksum for " + ne : { prefix: Ce, words: gt };
  }
  function J(ne, ie) {
    const pe = V(ne, ie);
    if (typeof pe == "object")
      return pe;
  }
  function re(ne, ie) {
    const pe = V(ne, ie);
    if (typeof pe == "object")
      return pe;
    throw new Error(pe);
  }
  return {
    decodeUnsafe: J,
    decode: re,
    encode: L,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$D.alloc(0);
function p2wpkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy$1.value(() => {
    const re = bech32_1$1.bech32.decode(A.address), ne = re.words.shift(), ie = bech32_1$1.bech32.fromWords(re.words);
    return {
      version: ne,
      prefix: re.prefix,
      data: Buffer$D.from(ie)
    };
  }), V = A.network || networks_1$2.bitcoin, J = { name: "p2wpkh", network: V };
  if (lazy$1.prop(J, "address", () => {
    if (!J.hash) return;
    const re = bech32_1$1.bech32.toWords(J.hash);
    return re.unshift(0), bech32_1$1.bech32.encode(V.bech32, re);
  }), lazy$1.prop(J, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return L().data;
    if (A.pubkey || J.pubkey) return bcrypto$3.hash160(A.pubkey || J.pubkey);
  }), lazy$1.prop(J, "output", () => {
    if (J.hash)
      return bscript$4.compile([OPS$1.OP_0, J.hash]);
  }), lazy$1.prop(J, "pubkey", () => {
    if (A.pubkey) return A.pubkey;
    if (A.witness)
      return A.witness[1];
  }), lazy$1.prop(J, "signature", () => {
    if (A.witness)
      return A.witness[0];
  }), lazy$1.prop(J, "input", () => {
    if (J.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(J, "witness", () => {
    if (A.pubkey && A.signature)
      return [A.signature, A.pubkey];
  }), B.validate) {
    let re = Buffer$D.from([]);
    if (A.address) {
      if (V && V.bech32 !== L().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 20)
        throw new TypeError("Invalid address data");
      re = L().data;
    }
    if (A.hash) {
      if (re.length > 0 && !re.equals(A.hash))
        throw new TypeError("Hash mismatch");
      re = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 22 || A.output[0] !== OPS$1.OP_0 || A.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (re.length > 0 && !re.equals(A.output.slice(2)))
        throw new TypeError("Hash mismatch");
      re = A.output.slice(2);
    }
    if (A.pubkey) {
      const ne = bcrypto$3.hash160(A.pubkey);
      if (re.length > 0 && !re.equals(ne))
        throw new TypeError("Hash mismatch");
      if (re = ne, !(0, types_1$2.isPoint)(A.pubkey) || A.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (A.witness) {
      if (A.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(A.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(A.witness[1]) || A.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (A.signature && !A.signature.equals(A.witness[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(A.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const ne = bcrypto$3.hash160(A.witness[1]);
      if (re.length > 0 && !re.equals(ne))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(J, A);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$D.alloc(0);
function chunkHasUncompressedPubkey(A) {
  return !!(Buffer$D.isBuffer(A) && A.length === 65 && A[0] === 4 && (0, types_1$1.isPoint)(A));
}
function p2wsh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy.value(() => {
    const ne = bech32_1.bech32.decode(A.address), ie = ne.words.shift(), pe = bech32_1.bech32.fromWords(ne.words);
    return {
      version: ie,
      prefix: ne.prefix,
      data: Buffer$D.from(pe)
    };
  }), V = lazy.value(() => bscript$3.decompile(A.redeem.input));
  let J = A.network;
  J || (J = A.redeem && A.redeem.network || networks_1$1.bitcoin);
  const re = { network: J };
  if (lazy.prop(re, "address", () => {
    if (!re.hash) return;
    const ne = bech32_1.bech32.toWords(re.hash);
    return ne.unshift(0), bech32_1.bech32.encode(J.bech32, ne);
  }), lazy.prop(re, "hash", () => {
    if (A.output) return A.output.slice(2);
    if (A.address) return L().data;
    if (re.redeem && re.redeem.output) return bcrypto$2.sha256(re.redeem.output);
  }), lazy.prop(re, "output", () => {
    if (re.hash)
      return bscript$3.compile([OPS.OP_0, re.hash]);
  }), lazy.prop(re, "redeem", () => {
    if (A.witness)
      return {
        output: A.witness[A.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: A.witness.slice(0, -1)
      };
  }), lazy.prop(re, "input", () => {
    if (re.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(re, "witness", () => {
    if (A.redeem && A.redeem.input && A.redeem.input.length > 0 && A.redeem.output && A.redeem.output.length > 0) {
      const ne = bscript$3.toStack(V());
      return re.redeem = Object.assign({ witness: ne }, A.redeem), re.redeem.input = EMPTY_BUFFER$1, [].concat(ne, A.redeem.output);
    }
    if (A.redeem && A.redeem.output && A.redeem.witness)
      return [].concat(A.redeem.witness, A.redeem.output);
  }), lazy.prop(re, "name", () => {
    const ne = ["p2wsh"];
    return re.redeem !== void 0 && re.redeem.name !== void 0 && ne.push(re.redeem.name), ne.join("-");
  }), B.validate) {
    let ne = Buffer$D.from([]);
    if (A.address) {
      if (L().prefix !== J.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 32)
        throw new TypeError("Invalid address data");
      ne = L().data;
    }
    if (A.hash) {
      if (ne.length > 0 && !ne.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ne = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 34 || A.output[0] !== OPS.OP_0 || A.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ie = A.output.slice(2);
      if (ne.length > 0 && !ne.equals(ie))
        throw new TypeError("Hash mismatch");
      ne = ie;
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== J)
        throw new TypeError("Network mismatch");
      if (A.redeem.input && A.redeem.input.length > 0 && A.redeem.witness && A.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (A.redeem.output) {
        const ie = bscript$3.decompile(A.redeem.output);
        if (!ie || ie.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (A.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ie) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const pe = bcrypto$2.sha256(A.redeem.output);
        if (ne.length > 0 && !ne.equals(pe))
          throw new TypeError("Hash mismatch");
        ne = pe;
      }
      if (A.redeem.input && !bscript$3.isPushOnly(V()))
        throw new TypeError("Non push-only scriptSig");
      if (A.witness && A.redeem.witness && !(0, types_1$1.stacksEqual)(A.witness, A.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (A.redeem.input && V().some(chunkHasUncompressedPubkey) || A.redeem.output && (bscript$3.decompile(A.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (A.witness && A.witness.length > 0) {
      const ie = A.witness[A.witness.length - 1];
      if (A.redeem && A.redeem.output && !A.redeem.output.equals(ie))
        throw new TypeError("Witness and redeem.output mismatch");
      if (A.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ie) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(re, A);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(A) {
  A ? A !== _ECCLIB_CACHE.eccLib && (verifyEcc(A), _ECCLIB_CACHE.eccLib = A) : _ECCLIB_CACHE.eccLib = A;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (A) => Buffer$D.from(A, "hex");
function verifyEcc(A) {
  assert(typeof A.isXOnlyPoint == "function"), assert(
    A.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    A.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof A.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((B) => {
    const L = A.xOnlyPointAddTweak(h(B.pubkey), h(B.tweak));
    B.result === null ? assert(L === null) : (assert(L !== null), assert(L.parity === B.parity), assert(Buffer$D.from(L.xOnlyPubkey).equals(h(B.result))));
  });
}
function assert(A) {
  if (!A) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports$1.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER$1 || A % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(A, B, L) {
  if (checkUInt53$1(A), B || (B = Buffer.allocUnsafe(encodingLength$1(A))), !Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), encode$f.bytes = 1) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), encode$f.bytes = 3) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), encode$f.bytes = 5) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), encode$f.bytes = 9), B;
}
function decode$e(A, B) {
  if (!Buffer.isBuffer(A)) throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  var L = A.readUInt8(B);
  if (L < 253)
    return decode$e.bytes = 1, L;
  if (L === 253)
    return decode$e.bytes = 3, A.readUInt16LE(B + 1);
  if (L === 254)
    return decode$e.bytes = 5, A.readUInt32LE(B + 1);
  decode$e.bytes = 9;
  var V = A.readUInt32LE(B + 1), J = A.readUInt32LE(B + 5), re = J * 4294967296 + V;
  return checkUInt53$1(re), re;
}
function encodingLength$1(A) {
  return checkUInt53$1(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(A, B) {
  const L = A.readUInt32LE(B);
  let V = A.readUInt32LE(B + 4);
  return V *= 4294967296, verifuint$1(V + L, 9007199254740991), V + L;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(A, B, L) {
  return verifuint$1(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let V = 0; V < A.length / 2; V++)
    L = A[V], A[V] = A[B], A[B] = L, B--;
  return A;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(A) {
  const B = Buffer$D.allocUnsafe(A.length);
  return A.copy(B), B;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(B) {
    return new BufferWriter(Buffer$D.alloc(B));
  }
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  writeUInt8(B) {
    this.offset = this.buffer.writeUInt8(B, this.offset);
  }
  writeInt32(B) {
    this.offset = this.buffer.writeInt32LE(B, this.offset);
  }
  writeUInt32(B) {
    this.offset = this.buffer.writeUInt32LE(B, this.offset);
  }
  writeUInt64(B) {
    this.offset = writeUInt64LE$1(this.buffer, B, this.offset);
  }
  writeVarInt(B) {
    varuint$7.encode(B, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(B) {
    if (this.buffer.length < this.offset + B.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += B.copy(this.buffer, this.offset);
  }
  writeVarSlice(B) {
    this.writeVarInt(B.length), this.writeSlice(B);
  }
  writeVector(B) {
    this.writeVarInt(B.length), B.forEach((L) => this.writeVarSlice(L));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  readUInt8() {
    const B = this.buffer.readUInt8(this.offset);
    return this.offset++, B;
  }
  readInt32() {
    const B = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt32() {
    const B = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt64() {
    const B = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, B;
  }
  readVarInt() {
    const B = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, B;
  }
  readSlice(B) {
    if (this.buffer.length < this.offset + B)
      throw new Error("Cannot read slice out of bounds");
    const L = this.buffer.slice(this.offset, this.offset + B);
    return this.offset += B, L;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const B = this.readVarInt(), L = [];
    for (let V = 0; V < B; V++) L.push(this.readVarSlice());
    return L;
  }
}
bufferutils.BufferReader = BufferReader;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.tweakKey = A.tapTweakHash = A.tapleafHash = A.findScriptPath = A.toHashTree = A.rootHashFromPath = A.MAX_TAPTREE_DEPTH = A.LEAF_VERSION_TAPSCRIPT = void 0;
  const B = dist$1, L = ecc_lib, V = crypto$1, J = bufferutils, re = types$4;
  A.LEAF_VERSION_TAPSCRIPT = 192, A.MAX_TAPTREE_DEPTH = 128;
  const ne = (St) => "left" in St && "right" in St;
  function ie(St, xt) {
    if (St.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${St.length}, expected min 33.`
      );
    const Mt = (St.length - 33) / 32;
    let bt = xt;
    for (let Tt = 0; Tt < Mt; Tt++) {
      const It = St.slice(33 + 32 * Tt, 65 + 32 * Tt);
      bt.compare(It) < 0 ? bt = it(bt, It) : bt = it(It, bt);
    }
    return bt;
  }
  A.rootHashFromPath = ie;
  function pe(St) {
    if ((0, re.isTapleaf)(St))
      return { hash: oe(St) };
    const xt = [pe(St[0]), pe(St[1])];
    xt.sort((Tt, It) => Tt.hash.compare(It.hash));
    const [Mt, bt] = xt;
    return {
      hash: it(Mt.hash, bt.hash),
      left: Mt,
      right: bt
    };
  }
  A.toHashTree = pe;
  function nt(St, xt) {
    if (ne(St)) {
      const Mt = nt(St.left, xt);
      if (Mt !== void 0) return [...Mt, St.right.hash];
      const bt = nt(St.right, xt);
      if (bt !== void 0) return [...bt, St.left.hash];
    } else if (St.hash.equals(xt))
      return [];
  }
  A.findScriptPath = nt;
  function oe(St) {
    const xt = St.version || A.LEAF_VERSION_TAPSCRIPT;
    return V.taggedHash(
      "TapLeaf",
      B.Buffer.concat([
        B.Buffer.from([xt]),
        gt(St.output)
      ])
    );
  }
  A.tapleafHash = oe;
  function Ce(St, xt) {
    return V.taggedHash(
      "TapTweak",
      B.Buffer.concat(xt ? [St, xt] : [St])
    );
  }
  A.tapTweakHash = Ce;
  function at(St, xt) {
    if (!B.Buffer.isBuffer(St) || St.length !== 32 || xt && xt.length !== 32) return null;
    const Mt = Ce(St, xt), bt = (0, L.getEccLib)().xOnlyPointAddTweak(St, Mt);
    return !bt || bt.xOnlyPubkey === null ? null : {
      parity: bt.parity,
      x: B.Buffer.from(bt.xOnlyPubkey)
    };
  }
  A.tweakKey = at;
  function it(St, xt) {
    return V.taggedHash("TapBranch", B.Buffer.concat([St, xt]));
  }
  function gt(St) {
    const xt = J.varuint.encodingLength(St.length), Mt = B.Buffer.allocUnsafe(xt);
    return J.varuint.encode(St.length, Mt), B.Buffer.concat([Mt, St]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const A = dist$1, B = networks, L = requireScript(), V = types$4, J = ecc_lib, re = bip341, ne = lazy$7, ie = dist, pe = requireAddress(), nt = L.OPS, oe = 1, Ce = 80;
  function at(it, gt) {
    if (!it.address && !it.output && !it.pubkey && !it.internalPubkey && !(it.witness && it.witness.length > 1))
      throw new TypeError("Not enough data");
    gt = Object.assign({ validate: !0 }, gt || {}), (0, V.typeforce)(
      {
        address: V.typeforce.maybe(V.typeforce.String),
        input: V.typeforce.maybe(V.typeforce.BufferN(0)),
        network: V.typeforce.maybe(V.typeforce.Object),
        output: V.typeforce.maybe(V.typeforce.BufferN(34)),
        internalPubkey: V.typeforce.maybe(V.typeforce.BufferN(32)),
        hash: V.typeforce.maybe(V.typeforce.BufferN(32)),
        pubkey: V.typeforce.maybe(V.typeforce.BufferN(32)),
        signature: V.typeforce.maybe(
          V.typeforce.anyOf(
            V.typeforce.BufferN(64),
            V.typeforce.BufferN(65)
          )
        ),
        witness: V.typeforce.maybe(
          V.typeforce.arrayOf(V.typeforce.Buffer)
        ),
        scriptTree: V.typeforce.maybe(V.isTaptree),
        redeem: V.typeforce.maybe({
          output: V.typeforce.maybe(V.typeforce.Buffer),
          redeemVersion: V.typeforce.maybe(V.typeforce.Number),
          witness: V.typeforce.maybe(
            V.typeforce.arrayOf(V.typeforce.Buffer)
          )
        }),
        redeemVersion: V.typeforce.maybe(V.typeforce.Number)
      },
      it
    );
    const St = ne.value(() => (0, pe.fromBech32)(it.address)), xt = ne.value(() => {
      if (!(!it.witness || !it.witness.length))
        return it.witness.length >= 2 && it.witness[it.witness.length - 1][0] === Ce ? it.witness.slice(0, -1) : it.witness.slice();
    }), Mt = ne.value(() => {
      if (it.scriptTree) return (0, re.toHashTree)(it.scriptTree);
      if (it.hash) return { hash: it.hash };
    }), bt = it.network || B.bitcoin, Tt = { name: "p2tr", network: bt };
    if (ne.prop(Tt, "address", () => {
      if (!Tt.pubkey) return;
      const It = ie.bech32m.toWords(Tt.pubkey);
      return It.unshift(oe), ie.bech32m.encode(bt.bech32, It);
    }), ne.prop(Tt, "hash", () => {
      const It = Mt();
      if (It) return It.hash;
      const qt = xt();
      if (qt && qt.length > 1) {
        const Dt = qt[qt.length - 1], Xt = Dt[0] & V.TAPLEAF_VERSION_MASK, Bt = qt[qt.length - 2], mt = (0, re.tapleafHash)({
          output: Bt,
          version: Xt
        });
        return (0, re.rootHashFromPath)(Dt, mt);
      }
      return null;
    }), ne.prop(Tt, "output", () => {
      if (Tt.pubkey)
        return L.compile([nt.OP_1, Tt.pubkey]);
    }), ne.prop(Tt, "redeemVersion", () => it.redeemVersion ? it.redeemVersion : it.redeem && it.redeem.redeemVersion !== void 0 && it.redeem.redeemVersion !== null ? it.redeem.redeemVersion : re.LEAF_VERSION_TAPSCRIPT), ne.prop(Tt, "redeem", () => {
      const It = xt();
      if (!(!It || It.length < 2))
        return {
          output: It[It.length - 2],
          witness: It.slice(0, -2),
          redeemVersion: It[It.length - 1][0] & V.TAPLEAF_VERSION_MASK
        };
    }), ne.prop(Tt, "pubkey", () => {
      if (it.pubkey) return it.pubkey;
      if (it.output) return it.output.slice(2);
      if (it.address) return St().data;
      if (Tt.internalPubkey) {
        const It = (0, re.tweakKey)(Tt.internalPubkey, Tt.hash);
        if (It) return It.x;
      }
    }), ne.prop(Tt, "internalPubkey", () => {
      if (it.internalPubkey) return it.internalPubkey;
      const It = xt();
      if (It && It.length > 1)
        return It[It.length - 1].slice(1, 33);
    }), ne.prop(Tt, "signature", () => {
      if (it.signature) return it.signature;
      const It = xt();
      if (!(!It || It.length !== 1))
        return It[0];
    }), ne.prop(Tt, "witness", () => {
      if (it.witness) return it.witness;
      const It = Mt();
      if (It && it.redeem && it.redeem.output && it.internalPubkey) {
        const qt = (0, re.tapleafHash)({
          output: it.redeem.output,
          version: Tt.redeemVersion
        }), Dt = (0, re.findScriptPath)(It, qt);
        if (!Dt) return;
        const Xt = (0, re.tweakKey)(it.internalPubkey, It.hash);
        if (!Xt) return;
        const Bt = A.Buffer.concat(
          [
            A.Buffer.from([Tt.redeemVersion | Xt.parity]),
            it.internalPubkey
          ].concat(Dt)
        );
        return [it.redeem.output, Bt];
      }
      if (it.signature) return [it.signature];
    }), gt.validate) {
      let It = A.Buffer.from([]);
      if (it.address) {
        if (bt && bt.bech32 !== St().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (St().version !== oe)
          throw new TypeError("Invalid address version");
        if (St().data.length !== 32)
          throw new TypeError("Invalid address data");
        It = St().data;
      }
      if (it.pubkey) {
        if (It.length > 0 && !It.equals(it.pubkey))
          throw new TypeError("Pubkey mismatch");
        It = it.pubkey;
      }
      if (it.output) {
        if (it.output.length !== 34 || it.output[0] !== nt.OP_1 || it.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (It.length > 0 && !It.equals(it.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        It = it.output.slice(2);
      }
      if (it.internalPubkey) {
        const Xt = (0, re.tweakKey)(it.internalPubkey, Tt.hash);
        if (It.length > 0 && !It.equals(Xt.x))
          throw new TypeError("Pubkey mismatch");
        It = Xt.x;
      }
      if (It && It.length && !(0, J.getEccLib)().isXOnlyPoint(It))
        throw new TypeError("Invalid pubkey for p2tr");
      const qt = Mt();
      if (it.hash && qt && !it.hash.equals(qt.hash))
        throw new TypeError("Hash mismatch");
      if (it.redeem && it.redeem.output && qt) {
        const Xt = (0, re.tapleafHash)({
          output: it.redeem.output,
          version: Tt.redeemVersion
        });
        if (!(0, re.findScriptPath)(qt, Xt))
          throw new TypeError("Redeem script not in tree");
      }
      const Dt = xt();
      if (it.redeem && Tt.redeem) {
        if (it.redeem.redeemVersion && it.redeem.redeemVersion !== Tt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (it.redeem.output) {
          if (L.decompile(it.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (Tt.redeem.output && !it.redeem.output.equals(Tt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (it.redeem.witness && Tt.redeem.witness && !(0, V.stacksEqual)(it.redeem.witness, Tt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Dt && Dt.length)
        if (Dt.length === 1) {
          if (it.signature && !it.signature.equals(Dt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Xt = Dt[Dt.length - 1];
          if (Xt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Xt.length}, expected min 33.`
            );
          if ((Xt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Xt.length} is incorrect!`
            );
          const Bt = (Xt.length - 33) / 32;
          if (Bt > 128)
            throw new TypeError(
              `The script path is too long. Got ${Bt}, expected max 128.`
            );
          const mt = Xt.slice(1, 33);
          if (it.internalPubkey && !it.internalPubkey.equals(mt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, J.getEccLib)().isXOnlyPoint(mt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Ot = Xt[0] & V.TAPLEAF_VERSION_MASK, wt = Dt[Dt.length - 2], ke = (0, re.tapleafHash)({
            output: wt,
            version: Ot
          }), rt = (0, re.rootHashFromPath)(Xt, ke), ce = (0, re.tweakKey)(mt, rt);
          if (!ce)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (It.length && !It.equals(ce.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (ce.parity !== (Xt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(Tt, it);
  }
  return p2tr.p2tr = at, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.p2tr = A.p2wsh = A.p2wpkh = A.p2sh = A.p2pkh = A.p2pk = A.p2ms = A.embed = void 0;
    const B = embed;
    Object.defineProperty(A, "embed", {
      enumerable: !0,
      get: function() {
        return B.p2data;
      }
    });
    const L = p2ms$1;
    Object.defineProperty(A, "p2ms", {
      enumerable: !0,
      get: function() {
        return L.p2ms;
      }
    });
    const V = p2pk$1;
    Object.defineProperty(A, "p2pk", {
      enumerable: !0,
      get: function() {
        return V.p2pk;
      }
    });
    const J = p2pkh$1;
    Object.defineProperty(A, "p2pkh", {
      enumerable: !0,
      get: function() {
        return J.p2pkh;
      }
    });
    const re = p2sh$1;
    Object.defineProperty(A, "p2sh", {
      enumerable: !0,
      get: function() {
        return re.p2sh;
      }
    });
    const ne = p2wpkh$1;
    Object.defineProperty(A, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return ne.p2wpkh;
      }
    });
    const ie = p2wsh$1;
    Object.defineProperty(A, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ie.p2wsh;
      }
    });
    const pe = requireP2tr();
    Object.defineProperty(A, "p2tr", {
      enumerable: !0,
      get: function() {
        return pe.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const A = networks, B = requirePayments(), L = requireScript(), V = types$4, J = dist, re = bs58check$2, ne = 40, ie = 2, pe = 16, nt = 2, oe = 80, Ce = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function at(Tt, It) {
    const qt = Tt.slice(2);
    if (qt.length < ie || qt.length > ne)
      throw new TypeError("Invalid program length for segwit address");
    const Dt = Tt[0] - oe;
    if (Dt < nt || Dt > pe)
      throw new TypeError("Invalid version for segwit address");
    if (Tt[1] !== qt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(Ce), xt(qt, Dt, It.bech32);
  }
  function it(Tt) {
    const It = Buffer$D.from(re.decode(Tt));
    if (It.length < 21) throw new TypeError(Tt + " is too short");
    if (It.length > 21) throw new TypeError(Tt + " is too long");
    const qt = It.readUInt8(0), Dt = It.slice(1);
    return { version: qt, hash: Dt };
  }
  address.fromBase58Check = it;
  function gt(Tt) {
    let It, qt;
    try {
      It = J.bech32.decode(Tt);
    } catch {
    }
    if (It) {
      if (qt = It.words[0], qt !== 0) throw new TypeError(Tt + " uses wrong encoding");
    } else if (It = J.bech32m.decode(Tt), qt = It.words[0], qt === 0) throw new TypeError(Tt + " uses wrong encoding");
    const Dt = J.bech32.fromWords(It.words.slice(1));
    return {
      version: qt,
      prefix: It.prefix,
      data: Buffer$D.from(Dt)
    };
  }
  address.fromBech32 = gt;
  function St(Tt, It) {
    (0, V.typeforce)(
      (0, V.tuple)(V.Hash160bit, V.UInt8),
      arguments
    );
    const qt = Buffer$D.allocUnsafe(21);
    return qt.writeUInt8(It, 0), Tt.copy(qt, 1), re.encode(qt);
  }
  address.toBase58Check = St;
  function xt(Tt, It, qt) {
    const Dt = J.bech32.toWords(Tt);
    return Dt.unshift(It), It === 0 ? J.bech32.encode(qt, Dt) : J.bech32m.encode(qt, Dt);
  }
  address.toBech32 = xt;
  function Mt(Tt, It) {
    It = It || A.bitcoin;
    try {
      return B.p2pkh({ output: Tt, network: It }).address;
    } catch {
    }
    try {
      return B.p2sh({ output: Tt, network: It }).address;
    } catch {
    }
    try {
      return B.p2wpkh({ output: Tt, network: It }).address;
    } catch {
    }
    try {
      return B.p2wsh({ output: Tt, network: It }).address;
    } catch {
    }
    try {
      return B.p2tr({ output: Tt, network: It }).address;
    } catch {
    }
    try {
      return at(Tt, It);
    } catch {
    }
    throw new Error(L.toASM(Tt) + " has no matching Address");
  }
  address.fromOutputScript = Mt;
  function bt(Tt, It) {
    It = It || A.bitcoin;
    let qt, Dt;
    try {
      qt = it(Tt);
    } catch {
    }
    if (qt) {
      if (qt.version === It.pubKeyHash)
        return B.p2pkh({ hash: qt.hash }).output;
      if (qt.version === It.scriptHash)
        return B.p2sh({ hash: qt.hash }).output;
    } else {
      try {
        Dt = gt(Tt);
      } catch {
      }
      if (Dt) {
        if (Dt.prefix !== It.bech32)
          throw new Error(Tt + " has an invalid prefix");
        if (Dt.version === 0) {
          if (Dt.data.length === 20)
            return B.p2wpkh({ hash: Dt.data }).output;
          if (Dt.data.length === 32)
            return B.p2wsh({ hash: Dt.data }).output;
        } else if (Dt.version === 1) {
          if (Dt.data.length === 32)
            return B.p2tr({ pubkey: Dt.data }).output;
        } else if (Dt.version >= nt && Dt.version <= pe && Dt.data.length >= ie && Dt.data.length <= ne)
          return console.warn(Ce), L.compile([
            Dt.version + oe,
            Dt.data
          ]);
      }
    }
    throw new Error(Tt + " has no matching Script");
  }
  return address.toOutputScript = bt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(A, B) {
  if (!Array.isArray(A)) throw TypeError("Expected values Array");
  if (typeof B != "function")
    throw TypeError("Expected digest Function");
  let L = A.length;
  const V = A.concat();
  for (; L > 1; ) {
    let J = 0;
    for (let re = 0; re < L; re += 2, ++J) {
      const ne = V[re], ie = re + 1 === L ? ne : V[re + 1], pe = Buffer$D.concat([ne, ie]);
      V[J] = B(pe);
    }
    L = J;
  }
  return V[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + B;
}
function vectorSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + A.reduce((L, V) => L + varSliceSize(V), 0);
}
const EMPTY_BUFFER = Buffer$D.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$D.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$D.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(A) {
  return A.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(B, L) {
    const V = new bufferutils_1$2.BufferReader(B), J = new Transaction();
    J.version = V.readInt32();
    const re = V.readUInt8(), ne = V.readUInt8();
    let ie = !1;
    re === Transaction.ADVANCED_TRANSACTION_MARKER && ne === Transaction.ADVANCED_TRANSACTION_FLAG ? ie = !0 : V.offset -= 2;
    const pe = V.readVarInt();
    for (let oe = 0; oe < pe; ++oe)
      J.ins.push({
        hash: V.readSlice(32),
        index: V.readUInt32(),
        script: V.readVarSlice(),
        sequence: V.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const nt = V.readVarInt();
    for (let oe = 0; oe < nt; ++oe)
      J.outs.push({
        value: V.readUInt64(),
        script: V.readVarSlice()
      });
    if (ie) {
      for (let oe = 0; oe < pe; ++oe)
        J.ins[oe].witness = V.readVector();
      if (!J.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (J.locktime = V.readUInt32(), L) return J;
    if (V.offset !== B.length)
      throw new Error("Transaction has unexpected data");
    return J;
  }
  static fromHex(B) {
    return Transaction.fromBuffer(Buffer$D.from(B, "hex"), !1);
  }
  static isCoinbaseHash(B) {
    typeforce$1(types$1.Hash256bit, B);
    for (let L = 0; L < 32; ++L)
      if (B[L] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(B, L, V, J) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(V) && (V = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: B,
      index: L,
      script: J || EMPTY_BUFFER,
      sequence: V,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(B, L) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: B,
      value: L
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((B) => B.witness.length !== 0);
  }
  weight() {
    const B = this.byteLength(!1), L = this.byteLength(!0);
    return B * 3 + L;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(B = !0) {
    const L = B && this.hasWitnesses();
    return (L ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((V, J) => V + 40 + varSliceSize(J.script), 0) + this.outs.reduce((V, J) => V + 8 + varSliceSize(J.script), 0) + (L ? this.ins.reduce((V, J) => V + vectorSize(J.witness), 0) : 0);
  }
  clone() {
    const B = new Transaction();
    return B.version = this.version, B.locktime = this.locktime, B.ins = this.ins.map((L) => ({
      hash: L.hash,
      index: L.index,
      script: L.script,
      sequence: L.sequence,
      witness: L.witness
    })), B.outs = this.outs.map((L) => ({
      script: L.script,
      value: L.value
    })), B;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(B, L, V) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), B >= this.ins.length) return ONE;
    const J = bscript$2.compile(
      bscript$2.decompile(L).filter((ie) => ie !== script_1.OPS.OP_CODESEPARATOR)
    ), re = this.clone();
    if ((V & 31) === Transaction.SIGHASH_NONE)
      re.outs = [], re.ins.forEach((ie, pe) => {
        pe !== B && (ie.sequence = 0);
      });
    else if ((V & 31) === Transaction.SIGHASH_SINGLE) {
      if (B >= this.outs.length) return ONE;
      re.outs.length = B + 1;
      for (let ie = 0; ie < B; ie++)
        re.outs[ie] = BLANK_OUTPUT;
      re.ins.forEach((ie, pe) => {
        pe !== B && (ie.sequence = 0);
      });
    }
    V & Transaction.SIGHASH_ANYONECANPAY ? (re.ins = [re.ins[B]], re.ins[0].script = J) : (re.ins.forEach((ie) => {
      ie.script = EMPTY_BUFFER;
    }), re.ins[B].script = J);
    const ne = Buffer$D.allocUnsafe(re.byteLength(!1) + 4);
    return ne.writeInt32LE(V, ne.length - 4), re.__toBuffer(ne, 0, !1), bcrypto$1.hash256(ne);
  }
  hashForWitnessV1(B, L, V, J, re, ne) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), V.length !== this.ins.length || L.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ie = J === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : J & Transaction.SIGHASH_OUTPUT_MASK, nt = (J & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, oe = ie === Transaction.SIGHASH_NONE, Ce = ie === Transaction.SIGHASH_SINGLE;
    let at = EMPTY_BUFFER, it = EMPTY_BUFFER, gt = EMPTY_BUFFER, St = EMPTY_BUFFER, xt = EMPTY_BUFFER;
    if (!nt) {
      let It = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((qt) => {
        It.writeSlice(qt.hash), It.writeUInt32(qt.index);
      }), at = bcrypto$1.sha256(It.end()), It = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), V.forEach((qt) => It.writeUInt64(qt)), it = bcrypto$1.sha256(It.end()), It = bufferutils_1$2.BufferWriter.withCapacity(
        L.map(varSliceSize).reduce((qt, Dt) => qt + Dt)
      ), L.forEach(
        (qt) => It.writeVarSlice(qt)
      ), gt = bcrypto$1.sha256(It.end()), It = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((qt) => It.writeUInt32(qt.sequence)), St = bcrypto$1.sha256(It.end());
    }
    if (oe || Ce) {
      if (Ce && B < this.outs.length) {
        const It = this.outs[B], qt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(It.script)
        );
        qt.writeUInt64(It.value), qt.writeVarSlice(It.script), xt = bcrypto$1.sha256(qt.end());
      }
    } else {
      const It = this.outs.map((Dt) => 8 + varSliceSize(Dt.script)).reduce((Dt, Xt) => Dt + Xt), qt = bufferutils_1$2.BufferWriter.withCapacity(It);
      this.outs.forEach((Dt) => {
        qt.writeUInt64(Dt.value), qt.writeVarSlice(Dt.script);
      }), xt = bcrypto$1.sha256(qt.end());
    }
    const Mt = (re ? 2 : 0) + (ne ? 1 : 0), bt = 174 - (nt ? 49 : 0) - (oe ? 32 : 0) + (ne ? 32 : 0) + (re ? 37 : 0), Tt = bufferutils_1$2.BufferWriter.withCapacity(bt);
    if (Tt.writeUInt8(J), Tt.writeInt32(this.version), Tt.writeUInt32(this.locktime), Tt.writeSlice(at), Tt.writeSlice(it), Tt.writeSlice(gt), Tt.writeSlice(St), oe || Ce || Tt.writeSlice(xt), Tt.writeUInt8(Mt), nt) {
      const It = this.ins[B];
      Tt.writeSlice(It.hash), Tt.writeUInt32(It.index), Tt.writeUInt64(V[B]), Tt.writeVarSlice(L[B]), Tt.writeUInt32(It.sequence);
    } else
      Tt.writeUInt32(B);
    if (ne) {
      const It = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(ne)
      );
      It.writeVarSlice(ne), Tt.writeSlice(bcrypto$1.sha256(It.end()));
    }
    return Ce && Tt.writeSlice(xt), re && (Tt.writeSlice(re), Tt.writeUInt8(0), Tt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$D.concat([Buffer$D.from([0]), Tt.end()])
    );
  }
  hashForWitnessV0(B, L, V, J) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let re = Buffer$D.from([]), ne, ie = ZERO, pe = ZERO, nt = ZERO;
    if (J & Transaction.SIGHASH_ANYONECANPAY || (re = Buffer$D.allocUnsafe(36 * this.ins.length), ne = new bufferutils_1$2.BufferWriter(re, 0), this.ins.forEach((Ce) => {
      ne.writeSlice(Ce.hash), ne.writeUInt32(Ce.index);
    }), pe = bcrypto$1.hash256(re)), !(J & Transaction.SIGHASH_ANYONECANPAY) && (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE && (re = Buffer$D.allocUnsafe(4 * this.ins.length), ne = new bufferutils_1$2.BufferWriter(re, 0), this.ins.forEach((Ce) => {
      ne.writeUInt32(Ce.sequence);
    }), nt = bcrypto$1.hash256(re)), (J & 31) !== Transaction.SIGHASH_SINGLE && (J & 31) !== Transaction.SIGHASH_NONE) {
      const Ce = this.outs.reduce((at, it) => at + 8 + varSliceSize(it.script), 0);
      re = Buffer$D.allocUnsafe(Ce), ne = new bufferutils_1$2.BufferWriter(re, 0), this.outs.forEach((at) => {
        ne.writeUInt64(at.value), ne.writeVarSlice(at.script);
      }), ie = bcrypto$1.hash256(re);
    } else if ((J & 31) === Transaction.SIGHASH_SINGLE && B < this.outs.length) {
      const Ce = this.outs[B];
      re = Buffer$D.allocUnsafe(8 + varSliceSize(Ce.script)), ne = new bufferutils_1$2.BufferWriter(re, 0), ne.writeUInt64(Ce.value), ne.writeVarSlice(Ce.script), ie = bcrypto$1.hash256(re);
    }
    re = Buffer$D.allocUnsafe(156 + varSliceSize(L)), ne = new bufferutils_1$2.BufferWriter(re, 0);
    const oe = this.ins[B];
    return ne.writeInt32(this.version), ne.writeSlice(pe), ne.writeSlice(nt), ne.writeSlice(oe.hash), ne.writeUInt32(oe.index), ne.writeVarSlice(L), ne.writeUInt64(V), ne.writeUInt32(oe.sequence), ne.writeSlice(ie), ne.writeUInt32(this.locktime), ne.writeUInt32(J), bcrypto$1.hash256(re);
  }
  getHash(B) {
    return B && this.isCoinbase() ? Buffer$D.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, B));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(B, L) {
    return this.__toBuffer(B, L, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[B].script = L;
  }
  setWitness(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[B].witness = L;
  }
  __toBuffer(B, L, V = !1) {
    B || (B = Buffer$D.allocUnsafe(this.byteLength(V)));
    const J = new bufferutils_1$2.BufferWriter(
      B,
      L || 0
    );
    J.writeInt32(this.version);
    const re = V && this.hasWitnesses();
    return re && (J.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), J.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), J.writeVarInt(this.ins.length), this.ins.forEach((ne) => {
      J.writeSlice(ne.hash), J.writeUInt32(ne.index), J.writeVarSlice(ne.script), J.writeUInt32(ne.sequence);
    }), J.writeVarInt(this.outs.length), this.outs.forEach((ne) => {
      isOutput(ne) ? J.writeUInt64(ne.value) : J.writeSlice(ne.valueBuffer), J.writeVarSlice(ne.script);
    }), re && this.ins.forEach((ne) => {
      J.writeVector(ne.witness);
    }), J.writeUInt32(this.locktime), L !== void 0 ? B.slice(L, J.offset) : B;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(B) {
    if (B.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const L = new bufferutils_1$1.BufferReader(B), V = new Block();
    if (V.version = L.readInt32(), V.prevHash = L.readSlice(32), V.merkleRoot = L.readSlice(32), V.timestamp = L.readUInt32(), V.bits = L.readUInt32(), V.nonce = L.readUInt32(), B.length === 80) return V;
    const J = () => {
      const ie = transaction_1$3.Transaction.fromBuffer(
        L.buffer.slice(L.offset),
        !0
      );
      return L.offset += ie.byteLength(), ie;
    }, re = L.readVarInt();
    V.transactions = [];
    for (let ie = 0; ie < re; ++ie) {
      const pe = J();
      V.transactions.push(pe);
    }
    const ne = V.getWitnessCommit();
    return ne && (V.witnessCommit = ne), V;
  }
  static fromHex(B) {
    return Block.fromBuffer(Buffer$D.from(B, "hex"));
  }
  static calculateTarget(B) {
    const L = ((B & 4278190080) >> 24) - 3, V = B & 8388607, J = Buffer$D.alloc(32, 0);
    return J.writeUIntBE(V, 29 - L, 3), J;
  }
  static calculateMerkleRoot(B, L) {
    if (typeforce([{ getHash: types.Function }], B), B.length === 0) throw errorMerkleNoTxes;
    if (L && !txesHaveWitnessCommit(B))
      throw errorWitnessNotSegwit;
    const V = B.map(
      (re) => re.getHash(L)
    ), J = (0, merkle_1.fastMerkleRoot)(V, bcrypto.hash256);
    return L ? bcrypto.hash256(
      Buffer$D.concat([J, B[0].ins[0].witness[0]])
    ) : J;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const B = this.transactions[0].outs.filter(
      (V) => V.script.slice(0, 6).equals(Buffer$D.from("6a24aa21a9ed", "hex"))
    ).map((V) => V.script.slice(6, 38));
    if (B.length === 0) return null;
    const L = B[B.length - 1];
    return L instanceof Buffer$D && L.length === 32 ? L : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$D && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const B = this.byteLength(!1, !1), L = this.byteLength(!1, !0);
    return B * 3 + L;
  }
  byteLength(B, L = !0) {
    return B || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((V, J) => V + J.byteLength(L), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const B = /* @__PURE__ */ new Date(0);
    return B.setUTCSeconds(this.timestamp), B;
  }
  // TODO: buffer, offset compatibility
  toBuffer(B) {
    const L = Buffer$D.allocUnsafe(this.byteLength(B)), V = new bufferutils_1$1.BufferWriter(L);
    return V.writeInt32(this.version), V.writeSlice(this.prevHash), V.writeSlice(this.merkleRoot), V.writeUInt32(this.timestamp), V.writeUInt32(this.bits), V.writeUInt32(this.nonce), B || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      L,
      V.offset
    ), V.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((J) => {
      const re = J.byteLength();
      J.toBuffer(L, V.offset), V.offset += re;
    })), L;
  }
  toHex(B) {
    return this.toBuffer(B).toString("hex");
  }
  checkTxRoots() {
    const B = this.hasWitnessCommit();
    return !B && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (B ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const B = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), L = Block.calculateTarget(this.bits);
    return B.compare(L) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const B = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(B) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const B = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(B) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(A) {
  return A instanceof Array && A[0] && A[0].ins && A[0].ins instanceof Array && A[0].ins[0] && A[0].ins[0].witness && A[0].ins[0].witness instanceof Array && A[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(A) {
  return A instanceof Array && A.some(
    (B) => typeof B == "object" && B.ins instanceof Array && B.ins.some(
      (L) => typeof L == "object" && L.witness instanceof Array && L.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), function(B) {
    B[B.UNSIGNED_TX = 0] = "UNSIGNED_TX", B[B.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(A.GlobalTypes || (A.GlobalTypes = {})), A.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(B) {
    B[B.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", B[B.WITNESS_UTXO = 1] = "WITNESS_UTXO", B[B.PARTIAL_SIG = 2] = "PARTIAL_SIG", B[B.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", B[B.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", B[B.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", B[B.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", B[B.POR_COMMITMENT = 9] = "POR_COMMITMENT", B[B.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", B[B.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", B[B.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", B[B.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", B[B.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(A.InputTypes || (A.InputTypes = {})), A.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(B) {
    B[B.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", B[B.TAP_TREE = 6] = "TAP_TREE", B[B.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(A.OutputTypes || (A.OutputTypes = {})), A.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (A) => [...Array(A).keys()];
function decode$d(A) {
  if (A.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 79 || ![2, 3].includes(A.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + A.key.toString("hex")
    );
  if (A.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const B = A.key.slice(1), L = {
    masterFingerprint: A.value.slice(0, 4),
    extendedPubkey: B,
    path: "m"
  };
  for (const V of range$2(A.value.length / 4 - 1)) {
    const J = A.value.readUInt32LE(V * 4 + 4), re = !!(J & 2147483648), ne = J & 2147483647;
    L.path += "/" + ne.toString(10) + (re ? "'" : "");
  }
  return L;
}
globalXpub$1.decode = decode$d;
function encode$e(A) {
  const B = Buffer$D.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), L = Buffer$D.concat([B, A.extendedPubkey]), V = A.path.split("/"), J = Buffer$D.allocUnsafe(V.length * 4);
  A.masterFingerprint.copy(J, 0);
  let re = 4;
  return V.slice(1).forEach((ne) => {
    const ie = ne.slice(-1) === "'";
    let pe = 2147483647 & parseInt(ie ? ne.slice(0, -1) : ne, 10);
    ie && (pe += 2147483648), J.writeUInt32LE(pe, re), re += 4;
  }), {
    key: L,
    value: J
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(A) {
  const B = A.extendedPubkey, L = A.masterFingerprint, V = A.path;
  return Buffer$D.isBuffer(B) && B.length === 78 && [2, 3].indexOf(B[45]) > -1 && Buffer$D.isBuffer(L) && L.length === 4 && typeof V == "string" && !!V.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(A, B, L) {
  const V = B.extendedPubkey.toString("hex");
  return L.has(V) ? !1 : (L.add(V), A.filter((J) => J.extendedPubkey.equals(B.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(A) {
  return {
    key: Buffer$D.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: A.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(A) {
  if (A.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(A) {
  return {
    key: Buffer$D.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: A
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(A) {
  return Buffer$D.isBuffer(A);
}
finalScriptSig$1.check = check$b;
function canAdd$8(A, B) {
  return !!A && !!B && A.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(A) {
  if (A.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(A) {
  return {
    key: Buffer$D.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: A
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(A) {
  return Buffer$D.isBuffer(A);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(A, B) {
  return !!A && !!B && A.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(A) {
  if (A.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(A) {
  return {
    key: Buffer$D.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: A
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(A) {
  return Buffer$D.isBuffer(A);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(A, B) {
  return !!A && !!B && A.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(A) {
  if (A.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + A.key.toString("hex")
    );
  if (!(A.key.length === 34 || A.key.length === 66) || ![2, 3, 4].includes(A.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + A.key.toString("hex")
    );
  return {
    pubkey: A.key.slice(1),
    signature: A.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(A) {
  const B = Buffer$D.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$D.concat([B, A.pubkey]),
    value: A.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(A) {
  return Buffer$D.isBuffer(A.pubkey) && Buffer$D.isBuffer(A.signature) && [33, 65].includes(A.pubkey.length) && [2, 3, 4].includes(A.pubkey[0]) && isDerSigWithSighash(A.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(A) {
  if (!Buffer$D.isBuffer(A) || A.length < 9 || A[0] !== 48 || A.length !== A[1] + 3 || A[2] !== 2) return !1;
  const B = A[3];
  if (B > 33 || B < 1 || A[3 + B + 1] !== 2) return !1;
  const L = A[3 + B + 2];
  return !(L > 33 || L < 1 || A.length !== 3 + B + 2 + L + 2);
}
function canAddToArray$2(A, B, L) {
  const V = B.pubkey.toString("hex");
  return L.has(V) ? !1 : (L.add(V), A.filter((J) => J.pubkey.equals(B.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(A) {
  if (A.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + A.key.toString("hex")
    );
  return A.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(A) {
  return {
    key: Buffer$D.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$D.from(A, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(A) {
  return typeof A == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(A, B) {
  return !!A && !!B && A.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(A) {
  if (A.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + A.key.toString("hex")
    );
  return A.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(A) {
  const B = Buffer$D.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), L = Buffer$D.allocUnsafe(4);
  return L.writeUInt32LE(A, 0), {
    key: B,
    value: L
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(A) {
  return typeof A == "number";
}
sighashType$1.check = check$6;
function canAdd$4(A, B) {
  return !!A && !!B && A.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(A) {
  if (A.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + A.key.toString("hex")
    );
  if (!check$5(A.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return A.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(A) {
  return { key: Buffer$D.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: A };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(A) {
  return Buffer$D.isBuffer(A) && (A.length === 64 || A.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(A, B) {
  return !!A && !!B && A.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(A) {
  if (A.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + A.key.toString("hex")
    );
  if ((A.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + A.key.toString("hex")
    );
  const B = A.value[A.value.length - 1];
  if ((A.key[1] & 254) !== B)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + A.key.toString("hex")
    );
  const L = A.value.slice(0, -1);
  return { controlBlock: A.key.slice(1), script: L, leafVersion: B };
}
tapLeafScript$1.decode = decode$5;
function encode$5(A) {
  const B = Buffer$D.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), L = Buffer$D.from([A.leafVersion]);
  return {
    key: Buffer$D.concat([B, A.controlBlock]),
    value: Buffer$D.concat([A.script, L])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(A) {
  return Buffer$D.isBuffer(A.controlBlock) && (A.controlBlock.length - 1) % 32 === 0 && (A.controlBlock[0] & 254) === A.leafVersion && Buffer$D.isBuffer(A.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(A, B, L) {
  const V = B.controlBlock.toString("hex");
  return L.has(V) ? !1 : (L.add(V), A.filter((J) => J.controlBlock.equals(B.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(A) {
  if (A.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + A.key.toString("hex")
    );
  if (!check$3(A.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return A.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(A) {
  return { key: Buffer$D.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: A };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(A) {
  return Buffer$D.isBuffer(A) && A.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(A, B) {
  return !!A && !!B && A.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(A) {
  if (A.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + A.key.toString("hex")
    );
  if (A.value.length !== 64 && A.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + A.key.toString("hex")
    );
  const B = A.key.slice(1, 33), L = A.key.slice(33);
  return {
    pubkey: B,
    leafHash: L,
    signature: A.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(A) {
  const B = Buffer$D.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$D.concat([B, A.pubkey, A.leafHash]),
    value: A.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(A) {
  return Buffer$D.isBuffer(A.pubkey) && Buffer$D.isBuffer(A.leafHash) && Buffer$D.isBuffer(A.signature) && A.pubkey.length === 32 && A.leafHash.length === 32 && (A.signature.length === 64 || A.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(A, B, L) {
  const V = B.pubkey.toString("hex") + B.leafHash.toString("hex");
  return L.has(V) ? !1 : (L.add(V), A.filter(
    (J) => J.pubkey.equals(B.pubkey) && J.leafHash.equals(B.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER || A % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(A, B, L) {
  if (checkUInt53(A), B || (B = Buffer$D.allocUnsafe(encodingLength(A))), !Buffer$D.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), Object.assign(encode$2, { bytes: 1 })) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), Object.assign(encode$2, { bytes: 3 })) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), Object.assign(encode$2, { bytes: 5 })) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), Object.assign(encode$2, { bytes: 9 })), B;
}
varint.encode = encode$2;
function decode$2(A, B) {
  if (!Buffer$D.isBuffer(A))
    throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  const L = A.readUInt8(B);
  if (L < 253)
    return Object.assign(decode$2, { bytes: 1 }), L;
  if (L === 253)
    return Object.assign(decode$2, { bytes: 3 }), A.readUInt16LE(B + 1);
  if (L === 254)
    return Object.assign(decode$2, { bytes: 5 }), A.readUInt32LE(B + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const V = A.readUInt32LE(B + 1), re = A.readUInt32LE(B + 5) * 4294967296 + V;
    return checkUInt53(re), re;
  }
}
varint.decode = decode$2;
function encodingLength(A) {
  return checkUInt53(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (A) => [...Array(A).keys()];
function reverseBuffer(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let V = 0; V < A.length / 2; V++)
    L = A[V], A[V] = A[B], A[B] = L, B--;
  return A;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(A) {
  const B = A.map(keyValToBuffer);
  return B.push(Buffer$D.from([0])), Buffer$D.concat(B);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(A) {
  const B = A.key.length, L = A.value.length, V = varuint$6.encodingLength(B), J = varuint$6.encodingLength(L), re = Buffer$D.allocUnsafe(
    V + B + J + L
  );
  return varuint$6.encode(B, re, 0), A.key.copy(re, V), varuint$6.encode(L, re, V + B), A.value.copy(re, V + B + J), re;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE(A, B) {
  const L = A.readUInt32LE(B);
  let V = A.readUInt32LE(B + 4);
  return V *= 4294967296, verifuint(V + L, 9007199254740991), V + L;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(A, B, L) {
  return verifuint(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(A) {
  if (A.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + A.key.toString("hex")
    );
  const B = tools_1$2.readUInt64LE(A.value, 0);
  let L = 8;
  const V = varuint$5.decode(A.value, L);
  L += varuint$5.encodingLength(V);
  const J = A.value.slice(L);
  if (J.length !== V)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: J,
    value: B
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(A) {
  const { script: B, value: L } = A, V = varuint$5.encodingLength(B.length), J = Buffer$D.allocUnsafe(8 + V + B.length);
  return tools_1$2.writeUInt64LE(J, L, 0), varuint$5.encode(B.length, J, 8), B.copy(J, 8 + V), {
    key: Buffer$D.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: J
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(A) {
  return Buffer$D.isBuffer(A.script) && typeof A.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(A, B) {
  return !!A && !!B && A.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(A) {
  if (A.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + A.key.toString("hex")
    );
  let B = 0;
  const L = [];
  for (; B < A.value.length; ) {
    const V = A.value[B++], J = A.value[B++], re = varuint$4.decode(A.value, B);
    B += varuint$4.encodingLength(re), L.push({
      depth: V,
      leafVersion: J,
      script: A.value.slice(B, B + re)
    }), B += re;
  }
  return { leaves: L };
}
tapTree$1.decode = decode;
function encode(A) {
  const B = Buffer$D.from([typeFields_1$3.OutputTypes.TAP_TREE]), L = [].concat(
    ...A.leaves.map((V) => [
      Buffer$D.of(V.depth, V.leafVersion),
      varuint$4.encode(V.script.length),
      V.script
    ])
  );
  return {
    key: B,
    value: Buffer$D.concat(L)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(A) {
  return Array.isArray(A.leaves) && A.leaves.every(
    (B) => B.depth >= 0 && B.depth <= 128 && (B.leafVersion & 254) === B.leafVersion && Buffer$D.isBuffer(B.script)
  );
}
tapTree$1.check = check;
function canAdd(A, B) {
  return !!A && !!B && A.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (A) => [...Array(A).keys()], isValidDERKey = (A) => A.length === 33 && [2, 3].includes(A[0]) || A.length === 65 && A[0] === 4;
function makeConverter$4(A, B = isValidDERKey) {
  function L(ie) {
    if (ie.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ie.key.toString("hex")
      );
    const pe = ie.key.slice(1);
    if (!B(pe))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ie.key.toString("hex")
      );
    if (ie.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const nt = {
      masterFingerprint: ie.value.slice(0, 4),
      pubkey: pe,
      path: "m"
    };
    for (const oe of range$1(ie.value.length / 4 - 1)) {
      const Ce = ie.value.readUInt32LE(oe * 4 + 4), at = !!(Ce & 2147483648), it = Ce & 2147483647;
      nt.path += "/" + it.toString(10) + (at ? "'" : "");
    }
    return nt;
  }
  function V(ie) {
    const pe = Buffer$D.from([A]), nt = Buffer$D.concat([pe, ie.pubkey]), oe = ie.path.split("/"), Ce = Buffer$D.allocUnsafe(oe.length * 4);
    ie.masterFingerprint.copy(Ce, 0);
    let at = 4;
    return oe.slice(1).forEach((it) => {
      const gt = it.slice(-1) === "'";
      let St = 2147483647 & parseInt(gt ? it.slice(0, -1) : it, 10);
      gt && (St += 2147483648), Ce.writeUInt32LE(St, at), at += 4;
    }), {
      key: nt,
      value: Ce
    };
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function re(ie) {
    return Buffer$D.isBuffer(ie.pubkey) && Buffer$D.isBuffer(ie.masterFingerprint) && typeof ie.path == "string" && B(ie.pubkey) && ie.masterFingerprint.length === 4;
  }
  function ne(ie, pe, nt) {
    const oe = pe.pubkey.toString("hex");
    return nt.has(oe) ? !1 : (nt.add(oe), ie.filter((Ce) => Ce.pubkey.equals(pe.pubkey)).length === 0);
  }
  return {
    decode: L,
    encode: V,
    check: re,
    expected: J,
    canAddToArray: ne
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(A) {
  return B;
  function B(L) {
    let V;
    if (A.includes(L.key[0]) && (V = L.key.slice(1), !(V.length === 33 || V.length === 65) || ![2, 3, 4].includes(V[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + L.key.toString("hex")
      );
    return V;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(A) {
  function B(ne) {
    if (ne.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + ne.key.toString("hex")
      );
    return ne.value;
  }
  function L(ne) {
    return {
      key: Buffer$D.from([A]),
      value: ne
    };
  }
  const V = "Buffer";
  function J(ne) {
    return Buffer$D.isBuffer(ne);
  }
  function re(ne, ie) {
    return !!ne && !!ie && ne.redeemScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: J,
    expected: V,
    canAdd: re
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (A) => A.length === 32;
function makeConverter$2(A) {
  const B = bip32Derivation$1.makeConverter(A, isValidBIP340Key);
  function L(ne) {
    const ie = varuint$3.decode(ne.value), pe = varuint$3.encodingLength(ie), nt = B.decode({
      key: ne.key,
      value: ne.value.slice(pe + ie * 32)
    }), oe = new Array(ie);
    for (let Ce = 0, at = pe; Ce < ie; Ce++, at += 32)
      oe[Ce] = ne.value.slice(at, at + 32);
    return Object.assign({}, nt, { leafHashes: oe });
  }
  function V(ne) {
    const ie = B.encode(ne), pe = varuint$3.encodingLength(ne.leafHashes.length), nt = Buffer$D.allocUnsafe(pe);
    varuint$3.encode(ne.leafHashes.length, nt);
    const oe = Buffer$D.concat([nt, ...ne.leafHashes, ie.value]);
    return Object.assign({}, ie, { value: oe });
  }
  const J = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function re(ne) {
    return Array.isArray(ne.leafHashes) && ne.leafHashes.every(
      (ie) => Buffer$D.isBuffer(ie) && ie.length === 32
    ) && B.check(ne);
  }
  return {
    decode: L,
    encode: V,
    check: re,
    expected: J,
    canAddToArray: B.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(A) {
  function B(ne) {
    if (ne.key[0] !== A || ne.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + ne.key.toString("hex")
      );
    if (ne.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return ne.value;
  }
  function L(ne) {
    return { key: Buffer$D.from([A]), value: ne };
  }
  const V = "Buffer";
  function J(ne) {
    return Buffer$D.isBuffer(ne) && ne.length === 32;
  }
  function re(ne, ie) {
    return !!ne && !!ie && ne.tapInternalKey === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: J,
    expected: V,
    canAdd: re
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(A) {
  function B(ne) {
    if (ne.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + ne.key.toString("hex")
      );
    return ne.value;
  }
  function L(ne) {
    return {
      key: Buffer$D.from([A]),
      value: ne
    };
  }
  const V = "Buffer";
  function J(ne) {
    return Buffer$D.isBuffer(ne);
  }
  function re(ne, ie) {
    return !!ne && !!ie && ne.witnessScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: J,
    expected: V,
    canAdd: re
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(A, B) {
  let L = 0;
  function V() {
    const xt = varuint$2.decode(A, L);
    L += varuint$2.encodingLength(xt);
    const Mt = A.slice(L, L + xt);
    return L += xt, Mt;
  }
  function J() {
    const xt = A.readUInt32BE(L);
    return L += 4, xt;
  }
  function re() {
    const xt = A.readUInt8(L);
    return L += 1, xt;
  }
  function ne() {
    const xt = V(), Mt = V();
    return {
      key: xt,
      value: Mt
    };
  }
  function ie() {
    if (L >= A.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const xt = A.readUInt8(L) === 0;
    return xt && L++, xt;
  }
  if (J() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (re() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const pe = [], nt = {};
  for (; !ie(); ) {
    const xt = ne(), Mt = xt.key.toString("hex");
    if (nt[Mt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + Mt
      );
    nt[Mt] = 1, pe.push(xt);
  }
  const oe = pe.filter(
    (xt) => xt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (oe.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const Ce = B(oe[0].value), { inputCount: at, outputCount: it } = Ce.getInputOutputCounts(), gt = [], St = [];
  for (const xt of tools_1$1.range(at)) {
    const Mt = {}, bt = [];
    for (; !ie(); ) {
      const Tt = ne(), It = Tt.key.toString("hex");
      if (Mt[It])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + xt + " key " + It
        );
      Mt[It] = 1, bt.push(Tt);
    }
    gt.push(bt);
  }
  for (const xt of tools_1$1.range(it)) {
    const Mt = {}, bt = [];
    for (; !ie(); ) {
      const Tt = ne(), It = Tt.key.toString("hex");
      if (Mt[It])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + xt + " key " + It
        );
      Mt[It] = 1, bt.push(Tt);
    }
    St.push(bt);
  }
  return psbtFromKeyVals(Ce, {
    globalMapKeyVals: pe,
    inputKeyVals: gt,
    outputKeyVals: St
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(A, B, L) {
  if (!B.equals(Buffer$D.from([L])))
    throw new Error(
      `Format Error: Invalid ${A} key: ${B.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(A, { globalMapKeyVals: B, inputKeyVals: L, outputKeyVals: V }) {
  const J = {
    unsignedTx: A
  };
  let re = 0;
  for (const oe of B)
    switch (oe.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          oe.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), re > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        re++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        J.globalXpub === void 0 && (J.globalXpub = []), J.globalXpub.push(convert$1.globals.globalXpub.decode(oe));
        break;
      default:
        J.unknownKeyVals || (J.unknownKeyVals = []), J.unknownKeyVals.push(oe);
    }
  const ne = L.length, ie = V.length, pe = [], nt = [];
  for (const oe of tools_1$1.range(ne)) {
    const Ce = {};
    for (const at of L[oe])
      switch (convert$1.inputs.checkPubkey(at), at.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), Ce.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          Ce.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(at);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), Ce.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          Ce.witnessUtxo = convert$1.inputs.witnessUtxo.decode(at);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          Ce.partialSig === void 0 && (Ce.partialSig = []), Ce.partialSig.push(convert$1.inputs.partialSig.decode(at));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), Ce.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          Ce.sighashType = convert$1.inputs.sighashType.decode(at);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), Ce.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          Ce.redeemScript = convert$1.inputs.redeemScript.decode(at);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), Ce.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          Ce.witnessScript = convert$1.inputs.witnessScript.decode(at);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          Ce.bip32Derivation === void 0 && (Ce.bip32Derivation = []), Ce.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(at)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), Ce.finalScriptSig = convert$1.inputs.finalScriptSig.decode(at);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), Ce.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            at
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), Ce.porCommitment = convert$1.inputs.porCommitment.decode(at);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), Ce.tapKeySig = convert$1.inputs.tapKeySig.decode(at);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          Ce.tapScriptSig === void 0 && (Ce.tapScriptSig = []), Ce.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(at));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          Ce.tapLeafScript === void 0 && (Ce.tapLeafScript = []), Ce.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(at));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          Ce.tapBip32Derivation === void 0 && (Ce.tapBip32Derivation = []), Ce.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(at)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), Ce.tapInternalKey = convert$1.inputs.tapInternalKey.decode(at);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            at.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), Ce.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(at);
          break;
        default:
          Ce.unknownKeyVals || (Ce.unknownKeyVals = []), Ce.unknownKeyVals.push(at);
      }
    pe.push(Ce);
  }
  for (const oe of tools_1$1.range(ie)) {
    const Ce = {};
    for (const at of V[oe])
      switch (convert$1.outputs.checkPubkey(at), at.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            at.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), Ce.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          Ce.redeemScript = convert$1.outputs.redeemScript.decode(at);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            at.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), Ce.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          Ce.witnessScript = convert$1.outputs.witnessScript.decode(at);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          Ce.bip32Derivation === void 0 && (Ce.bip32Derivation = []), Ce.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(at)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            at.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), Ce.tapInternalKey = convert$1.outputs.tapInternalKey.decode(at);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            at.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), Ce.tapTree = convert$1.outputs.tapTree.decode(at);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          Ce.tapBip32Derivation === void 0 && (Ce.tapBip32Derivation = []), Ce.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(at)
          );
          break;
        default:
          Ce.unknownKeyVals || (Ce.unknownKeyVals = []), Ce.unknownKeyVals.push(at);
      }
    nt.push(Ce);
  }
  return { globalMap: J, inputs: pe, outputs: nt };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: A, inputs: B, outputs: L }) {
  const { globalKeyVals: V, inputKeyVals: J, outputKeyVals: re } = psbtToKeyVals({
    globalMap: A,
    inputs: B,
    outputs: L
  }), ne = tools_1.keyValsToBuffer(V), ie = (Ce) => Ce.length === 0 ? [Buffer$D.from([0])] : Ce.map(tools_1.keyValsToBuffer), pe = ie(J), nt = ie(re), oe = Buffer$D.allocUnsafe(5);
  return oe.writeUIntBE(482972169471, 0, 5), Buffer$D.concat(
    [oe, ne].concat(pe, nt)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (A, B) => A.key.compare(B.key);
function keyValsFromMap(A, B) {
  const L = /* @__PURE__ */ new Set(), V = Object.entries(A).reduce((re, [ne, ie]) => {
    if (ne === "unknownKeyVals") return re;
    const pe = B[ne];
    if (pe === void 0) return re;
    const nt = (Array.isArray(ie) ? ie : [ie]).map(
      pe.encode
    );
    return nt.map((Ce) => Ce.key.toString("hex")).forEach((Ce) => {
      if (L.has(Ce))
        throw new Error("Serialize Error: Duplicate key: " + Ce);
      L.add(Ce);
    }), re.concat(nt);
  }, []), J = A.unknownKeyVals ? A.unknownKeyVals.filter((re) => !L.has(re.key.toString("hex"))) : [];
  return V.concat(J).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: A, inputs: B, outputs: L }) {
  return {
    globalKeyVals: keyValsFromMap(A, convert.globals),
    inputKeyVals: B.map((V) => keyValsFromMap(V, convert.inputs)),
    outputKeyVals: L.map((V) => keyValsFromMap(V, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(A) {
  function B(L) {
    for (var V in L) A.hasOwnProperty(V) || (A[V] = L[V]);
  }
  Object.defineProperty(A, "__esModule", { value: !0 }), B(fromBuffer), B(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(A) {
  const B = A[0], L = parser_1$1.psbtToKeyVals(B), V = A.slice(1);
  if (V.length === 0) throw new Error("Combine: Nothing to combine");
  const J = getTx(B);
  if (J === void 0)
    throw new Error("Combine: Self missing transaction");
  const re = getKeySet(L.globalKeyVals), ne = L.inputKeyVals.map(getKeySet), ie = L.outputKeyVals.map(getKeySet);
  for (const pe of V) {
    const nt = getTx(pe);
    if (nt === void 0 || !nt.toBuffer().equals(J.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const oe = parser_1$1.psbtToKeyVals(pe);
    getKeySet(oe.globalKeyVals).forEach(
      keyPusher(
        re,
        L.globalKeyVals,
        oe.globalKeyVals
      )
    ), oe.inputKeyVals.map(getKeySet).forEach(
      (gt, St) => gt.forEach(
        keyPusher(
          ne[St],
          L.inputKeyVals[St],
          oe.inputKeyVals[St]
        )
      )
    ), oe.outputKeyVals.map(getKeySet).forEach(
      (gt, St) => gt.forEach(
        keyPusher(
          ie[St],
          L.outputKeyVals[St],
          oe.outputKeyVals[St]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(J, {
    globalMapKeyVals: L.globalKeyVals,
    inputKeyVals: L.inputKeyVals,
    outputKeyVals: L.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(A, B, L) {
  return (V) => {
    if (A.has(V)) return;
    const J = L.filter((re) => re.key.toString("hex") === V)[0];
    B.push(J), A.add(V);
  };
}
function getTx(A) {
  return A.globalMap.unsignedTx;
}
function getKeySet(A) {
  const B = /* @__PURE__ */ new Set();
  return A.forEach((L) => {
    const V = L.key.toString("hex");
    if (B.has(V))
      throw new Error("Combine: KeyValue Map keys should be unique");
    B.add(V);
  }), B;
}
var utils = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 });
  const B = converter;
  function L(it, gt) {
    const St = it[gt];
    if (St === void 0) throw new Error(`No input #${gt}`);
    return St;
  }
  A.checkForInput = L;
  function V(it, gt) {
    const St = it[gt];
    if (St === void 0) throw new Error(`No output #${gt}`);
    return St;
  }
  A.checkForOutput = V;
  function J(it, gt, St) {
    if (it.key[0] < St)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (gt && gt.filter((xt) => xt.key.equals(it.key)).length !== 0)
      throw new Error(`Duplicate Key: ${it.key.toString("hex")}`);
  }
  A.checkHasKey = J;
  function re(it) {
    let gt = 0;
    return Object.keys(it).forEach((St) => {
      Number(isNaN(Number(St))) && gt++;
    }), gt;
  }
  A.getEnumLength = re;
  function ne(it, gt) {
    let St = !1;
    if (gt.nonWitnessUtxo || gt.witnessUtxo) {
      const xt = !!gt.redeemScript, Mt = !!gt.witnessScript, bt = !xt || !!gt.finalScriptSig, Tt = !Mt || !!gt.finalScriptWitness, It = !!gt.finalScriptSig || !!gt.finalScriptWitness;
      St = bt && Tt && It;
    }
    if (St === !1)
      throw new Error(
        `Input #${it} has too much or too little data to clean`
      );
  }
  A.inputCheckUncleanFinalized = ne;
  function ie(it, gt, St, xt) {
    throw new Error(
      `Data for ${it} key ${gt} is incorrect: Expected ${St} and got ${JSON.stringify(xt)}`
    );
  }
  function pe(it) {
    return (gt, St) => {
      for (const xt of Object.keys(gt)) {
        const Mt = gt[xt], { canAdd: bt, canAddToArray: Tt, check: It, expected: qt } = (
          // @ts-ignore
          B[it + "s"][xt] || {}
        ), Dt = !!Tt;
        if (It)
          if (Dt) {
            if (!Array.isArray(Mt) || // @ts-ignore
            St[xt] && !Array.isArray(St[xt]))
              throw new Error(`Key type ${xt} must be an array`);
            Mt.every(It) || ie(it, xt, qt, Mt);
            const Xt = St[xt] || [], Bt = /* @__PURE__ */ new Set();
            if (!Mt.every((mt) => Tt(Xt, mt, Bt)))
              throw new Error("Can not add duplicate data to array");
            St[xt] = Xt.concat(Mt);
          } else {
            if (It(Mt) || ie(it, xt, qt, Mt), !bt(St, Mt))
              throw new Error(`Can not add duplicate data to ${it}`);
            St[xt] = Mt;
          }
      }
    };
  }
  A.updateGlobal = pe("global"), A.updateInput = pe("input"), A.updateOutput = pe("output");
  function nt(it, gt) {
    const St = it.length - 1, xt = L(it, St);
    A.updateInput(gt, xt);
  }
  A.addInputAttributes = nt;
  function oe(it, gt) {
    const St = it.length - 1, xt = V(it, St);
    A.updateOutput(gt, xt);
  }
  A.addOutputAttributes = oe;
  function Ce(it, gt) {
    if (!Buffer$D.isBuffer(gt) || gt.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return gt.writeUInt32LE(it, 0), gt;
  }
  A.defaultVersionSetter = Ce;
  function at(it, gt) {
    if (!Buffer$D.isBuffer(gt) || gt.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return gt.writeUInt32LE(it, gt.length - 4), gt;
  }
  A.defaultLocktimeSetter = at;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: B
    };
  }
  static fromBase64(B, L) {
    const V = Buffer$D.from(B, "base64");
    return this.fromBuffer(V, L);
  }
  static fromHex(B, L) {
    const V = Buffer$D.from(B, "hex");
    return this.fromBuffer(V, L);
  }
  static fromBuffer(B, L) {
    const V = parser_1.psbtFromBuffer(B, L), J = new this(V.globalMap.unsignedTx);
    return Object.assign(J, V), J;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$1.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, L) {
    const V = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.updateInput(L, V), this;
  }
  updateOutput(B, L) {
    const V = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.updateOutput(L, V), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$1.checkHasKey(
      B,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    const V = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.checkHasKey(
      L,
      V.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), V.unknownKeyVals || (V.unknownKeyVals = []), V.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    const V = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.checkHasKey(
      L,
      V.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), V.unknownKeyVals || (V.unknownKeyVals = []), V.unknownKeyVals.push(L), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], V = this.inputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (J) => this.addUnknownKeyValToInput(V, J)
    ), utils_1$1.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], V = this.outputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (J) => this.addUnknownKeyValToOutput(V, J)
    ), utils_1$1.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const L = utils_1$1.checkForInput(this.inputs, B);
    utils_1$1.inputCheckUncleanFinalized(B, L);
    for (const V of Object.keys(L))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(V) || delete L[V];
    return this;
  }
  combine(...B) {
    const L = combiner_1.combine([this].concat(B));
    return Object.assign(this, L), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(A) {
  return (B) => {
    try {
      return A({ output: B }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(A) {
  let B = Buffer$D.allocUnsafe(0);
  function L(ne) {
    B = Buffer$D.concat([B, Buffer$D.from(ne)]);
  }
  function V(ne) {
    const ie = B.length, pe = varuint$1.encodingLength(ne);
    B = Buffer$D.concat([B, Buffer$D.allocUnsafe(pe)]), varuint$1.encode(ne, B, ie);
  }
  function J(ne) {
    V(ne.length), L(ne);
  }
  function re(ne) {
    V(ne.length), ne.forEach(J);
  }
  return re(A), B;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(A, B) {
  const L = (0, crypto_1.hash160)(A), V = A.slice(1, 33), J = bscript$1.decompile(B);
  if (J === null) throw new Error("Unknown script error");
  return J.findIndex((re) => typeof re == "number" ? !1 : re.equals(A) || re.equals(L) || re.equals(V));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(A, B) {
  return pubkeyPositionInScript(A, B) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(A, B) {
  return extractPartialSigs(A).some(
    (V) => signatureBlocksAction(V, bscript$1.signature.decode, B)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(A, B, L) {
  const { hashType: V } = B(A), J = [];
  switch (V & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && J.push("addInput"), V & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      J.push("addOutput"), J.push("setInputSequence");
      break;
  }
  return J.indexOf(L) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(A) {
  let B = [];
  if ((A.partialSig || []).length === 0) {
    if (!A.finalScriptSig && !A.finalScriptWitness) return [];
    B = getPsigsFromInputFinalScripts(A);
  } else
    B = A.partialSig;
  return B.map((L) => L.signature);
}
function getPsigsFromInputFinalScripts(A) {
  const B = A.finalScriptSig ? bscript$1.decompile(A.finalScriptSig) || [] : [], L = A.finalScriptWitness ? bscript$1.decompile(A.finalScriptWitness) || [] : [];
  return B.concat(L).filter((V) => Buffer$D.isBuffer(V) && bscript$1.isCanonicalScriptSignature(V)).map((V) => ({ signature: V }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (A) => A.length === 32 ? A : A.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(A, B, L) {
  const V = findTapLeafToFinalize(
    B,
    A,
    L
  );
  try {
    const re = sortSignatures(B, V).concat(V.script).concat(V.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(re)
    };
  } catch (J) {
    throw new Error(`Can not finalize taproot input #${A}: ${J}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(A, B) {
  const L = B ? Buffer$D.from([B]) : Buffer$D.from([]);
  return Buffer$D.concat([A, L]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(A) {
  return A && !!(A.tapInternalKey || A.tapMerkleRoot || A.tapLeafScript && A.tapLeafScript.length || A.tapBip32Derivation && A.tapBip32Derivation.length || A.witnessUtxo && (0, psbtutils_1$1.isP2TR)(A.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(A, B) {
  return A && !!(A.tapInternalKey || A.tapTree || A.tapBip32Derivation && A.tapBip32Derivation.length || B && (0, psbtutils_1$1.isP2TR)(B));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootInputFields(A, B, L), checkIfTapLeafInTree(A, B, L);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootOutputFields(A, B, L), checkTaprootScriptPubkey(A, B);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(A, B) {
  if (!B.tapTree && !B.tapInternalKey) return;
  const L = B.tapInternalKey || A.tapInternalKey, V = B.tapTree || A.tapTree;
  if (L) {
    const { script: J } = A, re = getTaprootScripPubkey(L, V);
    if (J && !J.equals(re))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(A, B) {
  const L = B && tapTreeFromList(B.leaves), { output: V } = (0, payments_1.p2tr)({
    internalPubkey: A,
    scriptTree: L
  });
  return V;
}
function tweakInternalPubKey(A, B) {
  const L = B.tapInternalKey, V = L && (0, bip341_1$1.tweakKey)(L, B.tapMerkleRoot);
  if (!V)
    throw new Error(
      `Cannot tweak tap internal key for input #${A}. Public key: ${L && L.toString("hex")}`
    );
  return V.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(A) {
  if (!(0, types_1.isTaptree)(A))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(A);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(A = []) {
  return A.length === 1 && A[0].depth === 0 ? {
    output: A[0].script,
    version: A[0].leafVersion
  } : instertLeavesInTree(A);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(A, B) {
  return extractTaprootSigs(A).some(
    (V) => (0, psbtutils_2.signatureBlocksAction)(V, decodeSchnorrSignature, B)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(A) {
  return {
    signature: A.slice(0, 64),
    hashType: A.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(A) {
  const B = [];
  if (A.tapKeySig && B.push(A.tapKeySig), A.tapScriptSig && B.push(...A.tapScriptSig.map((L) => L.signature)), !B.length) {
    const L = getTapKeySigFromWithness(A.finalScriptWitness);
    L && B.push(L);
  }
  return B;
}
function getTapKeySigFromWithness(A) {
  if (!A) return;
  const B = A.slice(2);
  if (B.length === 64 || B.length === 65) return B;
}
function _tapTreeToList(A, B = [], L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return A ? (0, types_1.isTapleaf)(A) ? (B.push({
    depth: L,
    leafVersion: A.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: A.output
  }), B) : (A[0] && _tapTreeToList(A[0], B, L + 1), A[1] && _tapTreeToList(A[1], B, L + 1), B) : [];
}
function instertLeavesInTree(A) {
  let B;
  for (const L of A)
    if (B = instertLeafInTree(L, B), !B) throw new Error("No room left to insert tapleaf in tree");
  return B;
}
function instertLeafInTree(A, B, L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (A.depth === L)
    return B ? void 0 : {
      output: A.script,
      version: A.leafVersion
    };
  if ((0, types_1.isTapleaf)(B)) return;
  const V = instertLeafInTree(A, B && B[0], L + 1);
  if (V) return [V, B && B[1]];
  const J = instertLeafInTree(A, B && B[1], L + 1);
  if (J) return [B && B[0], J];
}
function checkMixedTaprootAndNonTaprootInputFields(A, B, L) {
  const V = isTaprootInput(A) && hasNonTaprootFields(B), J = hasNonTaprootFields(A) && isTaprootInput(B), re = A === B && isTaprootInput(B) && hasNonTaprootFields(B);
  if (V || J || re)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(A, B, L) {
  const V = isTaprootOutput(A) && hasNonTaprootFields(B), J = hasNonTaprootFields(A) && isTaprootOutput(B), re = A === B && isTaprootOutput(B) && hasNonTaprootFields(B);
  if (V || J || re)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(A, B, L) {
  if (B.tapMerkleRoot) {
    const V = (B.tapLeafScript || []).every(
      (re) => isTapLeafInTree(re, B.tapMerkleRoot)
    ), J = (A.tapLeafScript || []).every(
      (re) => isTapLeafInTree(re, B.tapMerkleRoot)
    );
    if (!V || !J)
      throw new Error(
        `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
      );
  } else if (A.tapMerkleRoot && !(B.tapLeafScript || []).every(
    (J) => isTapLeafInTree(J, A.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(A, B) {
  if (!B) return !0;
  const L = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    A.controlBlock,
    L
  ).equals(B);
}
function sortSignatures(A, B) {
  const L = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (A.tapScriptSig || []).filter((V) => V.leafHash.equals(L)).map((V) => addPubkeyPositionInScript(B.script, V)).sort((V, J) => J.positionInScript - V.positionInScript).map((V) => V.signature);
}
function addPubkeyPositionInScript(A, B) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        B.pubkey,
        A
      )
    },
    B
  );
}
function findTapLeafToFinalize(A, B, L) {
  if (!A.tapScriptSig || !A.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${B}. No tapleaf script signature provided.`
    );
  const V = (A.tapLeafScript || []).sort((J, re) => J.controlBlock.length - re.controlBlock.length).find(
    (J) => canFinalizeLeaf(J, A.tapScriptSig, L)
  );
  if (!V)
    throw new Error(
      `Can not finalize taproot input #${B}. Signature for tapleaf script not found.`
    );
  return V;
}
function canFinalizeLeaf(A, B, L) {
  const V = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (!L || L.equals(V)) && B.find((re) => re.leafHash.equals(V)) !== void 0;
}
function hasNonTaprootFields(A) {
  return A && !!(A.redeemScript || A.witnessScript || A.bip32Derivation && A.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(B, L = {}) {
    const V = Buffer$D.from(B, "base64");
    return this.fromBuffer(V, L);
  }
  static fromHex(B, L = {}) {
    const V = Buffer$D.from(B, "hex");
    return this.fromBuffer(V, L);
  }
  static fromBuffer(B, L = {}) {
    const V = bip174_1.Psbt.fromBuffer(B, transactionFromBuffer), J = new Psbt(L, V);
    return checkTxForDupeIns(J.__CACHE.__TX, J.__CACHE), J;
  }
  constructor(B = {}, L = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = L, this.opts = Object.assign({}, DEFAULT_OPTS, B), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const V = (J, re, ne, ie) => Object.defineProperty(J, re, {
      enumerable: ne,
      writable: ie
    });
    V(this, "__CACHE", !1, !0), V(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(B) {
    this.setVersion(B);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(B) {
    this.setLocktime(B);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((B) => ({
      hash: (0, bufferutils_1.cloneBuffer)(B.hash),
      index: B.index,
      sequence: B.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((B) => {
      let L;
      try {
        L = (0, address_1.fromOutputScript)(
          B.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(B.script),
        value: B.value,
        address: L
      };
    });
  }
  combine(...B) {
    return this.data.combine(...B.map((L) => L.data)), this;
  }
  clone() {
    const B = Psbt.fromBuffer(this.data.toBuffer());
    return B.opts = JSON.parse(JSON.stringify(this.opts)), B;
  }
  setMaximumFeeRate(B) {
    check32Bit(B), this.opts.maximumFeeRate = B;
  }
  setVersion(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const L = this.__CACHE;
    return L.__TX.version = B, L.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const L = this.__CACHE;
    return L.__TX.locktime = B, L.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(B, L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const V = this.__CACHE;
    if (V.__TX.ins.length <= B)
      throw new Error("Input index too high");
    return V.__TX.ins[B].sequence = L, V.__EXTRACTED_TX = void 0, this;
  }
  addInputs(B) {
    return B.forEach((L) => this.addInput(L)), this;
  }
  addInput(B) {
    if (arguments.length > 1 || !B || B.hash === void 0 || B.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(B, B, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), B.witnessScript && checkInvalidP2WSH(B.witnessScript);
    const L = this.__CACHE;
    this.data.addInput(B);
    const V = L.__TX.ins[L.__TX.ins.length - 1];
    checkTxInputCache(L, V);
    const J = this.data.inputs.length - 1, re = this.data.inputs[J];
    return re.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, re, J), L.__FEE = void 0, L.__FEE_RATE = void 0, L.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(B) {
    return B.forEach((L) => this.addOutput(L)), this;
  }
  addOutput(B) {
    if (arguments.length > 1 || !B || B.value === void 0 || B.address === void 0 && B.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: L } = B;
    if (typeof L == "string") {
      const { network: J } = this.opts, re = (0, address_1.toOutputScript)(L, J);
      B = Object.assign({}, B, { script: re });
    }
    (0, bip371_1.checkTaprootOutputFields)(B, B, "addOutput");
    const V = this.__CACHE;
    return this.data.addOutput(B), V.__FEE = void 0, V.__FEE_RATE = void 0, V.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(B) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const L = this.__CACHE;
    if (B || checkFees(this, L, this.opts), L.__EXTRACTED_TX) return L.__EXTRACTED_TX;
    const V = L.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, V, L, !0), V;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((B) => this.finalizeInput(B)), this;
  }
  finalizeInput(B, L) {
    const V = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(V) ? this._finalizeTaprootInput(
      B,
      V,
      void 0,
      L
    ) : this._finalizeInput(B, V, L);
  }
  finalizeTaprootInput(B, L, V = bip371_1.tapScriptFinalizer) {
    const J = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(J))
      return this._finalizeTaprootInput(
        B,
        J,
        L,
        V
      );
    throw new Error(`Cannot finalize input #${B}. Not Taproot.`);
  }
  _finalizeInput(B, L, V = getFinalScripts) {
    const { script: J, isP2SH: re, isP2WSH: ne, isSegwit: ie } = getScriptFromInput(
      B,
      L,
      this.__CACHE
    );
    if (!J) throw new Error(`No script found for input #${B}`);
    checkPartialSigSighashes(L);
    const { finalScriptSig: pe, finalScriptWitness: nt } = V(
      B,
      L,
      J,
      ie,
      re,
      ne
    );
    if (pe && this.data.updateInput(B, { finalScriptSig: pe }), nt && this.data.updateInput(B, { finalScriptWitness: nt }), !pe && !nt)
      throw new Error(`Unknown error finalizing input #${B}`);
    return this.data.clearFinalizedInput(B), this;
  }
  _finalizeTaprootInput(B, L, V, J = bip371_1.tapScriptFinalizer) {
    if (!L.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${B}. Missing withness utxo.`
      );
    if (L.tapKeySig) {
      const re = payments.p2tr({
        output: L.witnessUtxo.script,
        signature: L.tapKeySig
      }), ne = (0, psbtutils_1.witnessStackToScriptWitness)(
        re.witness
      );
      this.data.updateInput(B, { finalScriptWitness: ne });
    } else {
      const { finalScriptWitness: re } = J(
        B,
        L,
        V
      );
      this.data.updateInput(B, { finalScriptWitness: re });
    }
    return this.data.clearFinalizedInput(B), this;
  }
  getInputType(B) {
    const L = (0, utils_1.checkForInput)(this.data.inputs, B), V = getScriptFromUtxo(B, L, this.__CACHE), J = getMeaningfulScript(
      V,
      B,
      "input",
      L.redeemScript || redeemFromFinalScriptSig(L.finalScriptSig),
      L.witnessScript || redeemFromFinalWitnessScript(L.finalScriptWitness)
    ), re = J.type === "raw" ? "" : J.type + "-", ne = classifyScript(J.meaningfulScript);
    return re + ne;
  }
  inputHasPubkey(B, L) {
    const V = (0, utils_1.checkForInput)(this.data.inputs, B);
    return pubkeyInInput(L, V, B, this.__CACHE);
  }
  inputHasHDKey(B, L) {
    const V = (0, utils_1.checkForInput)(this.data.inputs, B), J = bip32DerivationIsMine(L);
    return !!V.bip32Derivation && V.bip32Derivation.some(J);
  }
  outputHasPubkey(B, L) {
    const V = (0, utils_1.checkForOutput)(this.data.outputs, B);
    return pubkeyInOutput(L, V, B, this.__CACHE);
  }
  outputHasHDKey(B, L) {
    const V = (0, utils_1.checkForOutput)(this.data.outputs, B), J = bip32DerivationIsMine(L);
    return !!V.bip32Derivation && V.bip32Derivation.some(J);
  }
  validateSignaturesOfAllInputs(B) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (V) => this.validateSignaturesOfInput(V, B)
    ).reduce((V, J) => J === !0 && V, !0);
  }
  validateSignaturesOfInput(B, L, V) {
    const J = this.data.inputs[B];
    return (0, bip371_1.isTaprootInput)(J) ? this.validateSignaturesOfTaprootInput(
      B,
      L,
      V
    ) : this._validateSignaturesOfInput(B, L, V);
  }
  _validateSignaturesOfInput(B, L, V) {
    const J = this.data.inputs[B], re = (J || {}).partialSig;
    if (!J || !re || re.length < 1)
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    const ne = V ? re.filter((Ce) => Ce.pubkey.equals(V)) : re;
    if (ne.length < 1) throw new Error("No signatures for this pubkey");
    const ie = [];
    let pe, nt, oe;
    for (const Ce of ne) {
      const at = bscript.signature.decode(Ce.signature), { hash: it, script: gt } = oe !== at.hashType ? getHashForSig(
        B,
        Object.assign({}, J, { sighashType: at.hashType }),
        this.__CACHE,
        !0
      ) : { hash: pe, script: nt };
      oe = at.hashType, pe = it, nt = gt, checkScriptForPubkey(Ce.pubkey, gt, "verify"), ie.push(L(Ce.pubkey, it, at.signature));
    }
    return ie.every((Ce) => Ce === !0);
  }
  validateSignaturesOfTaprootInput(B, L, V) {
    const J = this.data.inputs[B], re = (J || {}).tapKeySig, ne = (J || {}).tapScriptSig;
    if (!J && !re && !(ne && !ne.length))
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    V = V && (0, bip371_1.toXOnly)(V);
    const ie = V ? getTaprootHashesForSig(
      B,
      J,
      this.data.inputs,
      V,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      B,
      J,
      this.data.inputs,
      this.__CACHE
    );
    if (!ie.length) throw new Error("No signatures for this pubkey");
    const pe = ie.find((oe) => !oe.leafHash);
    let nt = 0;
    if (re && pe) {
      if (!L(
        pe.pubkey,
        pe.hash,
        trimTaprootSig(re)
      )) return !1;
      nt++;
    }
    if (ne)
      for (const oe of ne) {
        const Ce = ie.find((at) => oe.pubkey.equals(at.pubkey));
        if (Ce) {
          if (!L(
            oe.pubkey,
            Ce.hash,
            trimTaprootSig(oe.signature)
          )) return !1;
          nt++;
        }
      }
    return nt > 0;
  }
  signAllInputsHD(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!B || !B.publicKey || !B.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const V = [];
    for (const J of range(this.data.inputs.length))
      try {
        this.signInputHD(J, B, L), V.push(!0);
      } catch {
        V.push(!1);
      }
    if (V.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((V, J) => {
      if (!B || !B.publicKey || !B.fingerprint)
        return J(new Error("Need HDSigner to sign input"));
      const re = [], ne = [];
      for (const ie of range(this.data.inputs.length))
        ne.push(
          this.signInputHDAsync(ie, B, L).then(
            () => {
              re.push(!0);
            },
            () => {
              re.push(!1);
            }
          )
        );
      return Promise.all(ne).then(() => {
        if (re.every((ie) => ie === !1))
          return J(new Error("No inputs were signed"));
        V();
      });
    });
  }
  signInputHD(B, L, V = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(B, this.data.inputs, L).forEach((re) => this.signInput(B, re, V)), this;
  }
  signInputHDAsync(B, L, V = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((J, re) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return re(new Error("Need HDSigner to sign input"));
      const ie = getSignersFromHD(B, this.data.inputs, L).map(
        (pe) => this.signInputAsync(B, pe, V)
      );
      return Promise.all(ie).then(() => {
        J();
      }).catch(re);
    });
  }
  signAllInputs(B, L) {
    if (!B || !B.publicKey)
      throw new Error("Need Signer to sign input");
    const V = [];
    for (const J of range(this.data.inputs.length))
      try {
        this.signInput(J, B, L), V.push(!0);
      } catch {
        V.push(!1);
      }
    if (V.every((J) => J === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(B, L) {
    return new Promise((V, J) => {
      if (!B || !B.publicKey)
        return J(new Error("Need Signer to sign input"));
      const re = [], ne = [];
      for (const [ie] of this.data.inputs.entries())
        ne.push(
          this.signInputAsync(ie, B, L).then(
            () => {
              re.push(!0);
            },
            () => {
              re.push(!1);
            }
          )
        );
      return Promise.all(ne).then(() => {
        if (re.every((ie) => ie === !1))
          return J(new Error("No inputs were signed"));
        V();
      });
    });
  }
  signInput(B, L, V) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const J = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInput(
      B,
      J,
      L,
      void 0,
      V
    ) : this._signInput(B, L, V);
  }
  signTaprootInput(B, L, V, J) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const re = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(re))
      return this._signTaprootInput(
        B,
        re,
        L,
        V,
        J
      );
    throw new Error(`Input #${B} is not of type Taproot.`);
  }
  _signInput(B, L, V = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: re } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      V
    ), ne = [
      {
        pubkey: L.publicKey,
        signature: bscript.signature.encode(L.sign(J), re)
      }
    ];
    return this.data.updateInput(B, { partialSig: ne }), this;
  }
  _signTaprootInput(B, L, V, J, re = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const ne = this.checkTaprootHashesForSig(
      B,
      L,
      V,
      J,
      re
    ), ie = ne.filter((nt) => !nt.leafHash).map(
      (nt) => (0, bip371_1.serializeTaprootSignature)(
        V.signSchnorr(nt.hash),
        L.sighashType
      )
    )[0], pe = ne.filter((nt) => !!nt.leafHash).map((nt) => ({
      pubkey: (0, bip371_1.toXOnly)(V.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        V.signSchnorr(nt.hash),
        L.sighashType
      ),
      leafHash: nt.leafHash
    }));
    return ie && this.data.updateInput(B, { tapKeySig: ie }), pe.length && this.data.updateInput(B, { tapScriptSig: pe }), this;
  }
  signInputAsync(B, L, V) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const J = (0, utils_1.checkForInput)(this.data.inputs, B);
      return (0, bip371_1.isTaprootInput)(J) ? this._signTaprootInputAsync(
        B,
        J,
        L,
        void 0,
        V
      ) : this._signInputAsync(B, L, V);
    });
  }
  signTaprootInputAsync(B, L, V, J) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const re = (0, utils_1.checkForInput)(this.data.inputs, B);
      if ((0, bip371_1.isTaprootInput)(re))
        return this._signTaprootInputAsync(
          B,
          re,
          L,
          V,
          J
        );
      throw new Error(`Input #${B} is not of type Taproot.`);
    });
  }
  _signInputAsync(B, L, V = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: J, sighashType: re } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      V
    );
    return Promise.resolve(L.sign(J)).then((ne) => {
      const ie = [
        {
          pubkey: L.publicKey,
          signature: bscript.signature.encode(ne, re)
        }
      ];
      this.data.updateInput(B, { partialSig: ie });
    });
  }
  async _signTaprootInputAsync(B, L, V, J, re = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const ne = this.checkTaprootHashesForSig(
      B,
      L,
      V,
      J,
      re
    ), ie = [], pe = ne.filter((oe) => !oe.leafHash)[0];
    if (pe) {
      const oe = Promise.resolve(
        V.signSchnorr(pe.hash)
      ).then((Ce) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          Ce,
          L.sighashType
        )
      }));
      ie.push(oe);
    }
    const nt = ne.filter((oe) => !!oe.leafHash);
    if (nt.length) {
      const oe = nt.map((Ce) => Promise.resolve(V.signSchnorr(Ce.hash)).then(
        (at) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(V.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              at,
              L.sighashType
            ),
            leafHash: Ce.leafHash
          }
        ] })
      ));
      ie.push(...oe);
    }
    return Promise.all(ie).then((oe) => {
      oe.forEach((Ce) => this.data.updateInput(B, Ce));
    });
  }
  checkTaprootHashesForSig(B, L, V, J, re) {
    if (typeof V.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${B}.`
      );
    const ne = getTaprootHashesForSig(
      B,
      L,
      this.data.inputs,
      V.publicKey,
      this.__CACHE,
      J,
      re
    );
    if (!ne || !ne.length)
      throw new Error(
        `Can not sign for input #${B} with the key ${V.publicKey.toString(
          "hex"
        )}`
      );
    return ne;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(B) {
    return this.data.updateGlobal(B), this;
  }
  updateInput(B, L) {
    return L.witnessScript && checkInvalidP2WSH(L.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[B],
      L,
      "updateInput"
    ), this.data.updateInput(B, L), L.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[B],
      B
    ), this;
  }
  updateOutput(B, L) {
    const V = this.data.outputs[B];
    return (0, bip371_1.checkTaprootOutputFields)(
      V,
      L,
      "updateOutput"
    ), this.data.updateOutput(B, L), this;
  }
  addUnknownKeyValToGlobal(B) {
    return this.data.addUnknownKeyValToGlobal(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    return this.data.addUnknownKeyValToInput(B, L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    return this.data.addUnknownKeyValToOutput(B, L), this;
  }
  clearFinalizedInput(B) {
    return this.data.clearFinalizedInput(B), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (A) => new PsbtTransaction(A);
class PsbtTransaction {
  constructor(B = Buffer$D.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(B), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(B) {
    if (B.hash === void 0 || B.index === void 0 || !Buffer$D.isBuffer(B.hash) && typeof B.hash != "string" || typeof B.index != "number")
      throw new Error("Error adding input.");
    const L = typeof B.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$D.from(B.hash, "hex")) : B.hash;
    this.tx.addInput(L, B.index, B.sequence);
  }
  addOutput(B) {
    if (B.script === void 0 || B.value === void 0 || !Buffer$D.isBuffer(B.script) || typeof B.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(B.script, B.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(A, B, L) {
  switch (L) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, A.partialSig);
    case "multisig":
      const V = payments.p2ms({ output: B });
      return hasSigs(V.m, A.partialSig, V.pubkeys);
    default:
      return !1;
  }
}
function checkCache(A) {
  if (A.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(A, B, L) {
  if (!B) return !1;
  let V;
  if (L ? V = L.map((J) => {
    const re = compressPubkey(J);
    return B.find((ne) => ne.pubkey.equals(re));
  }).filter((J) => !!J) : V = B, V.length > A) throw new Error("Too many signatures");
  return V.length === A;
}
function isFinalized(A) {
  return !!A.finalScriptSig || !!A.finalScriptWitness;
}
function bip32DerivationIsMine(A) {
  return (B) => !(!B.masterFingerprint.equals(A.fingerprint) || !A.derivePath(B.path).publicKey.equals(B.pubkey));
}
function check32Bit(A) {
  if (typeof A != "number" || A !== Math.floor(A) || A > 4294967295 || A < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(A, B, L) {
  const V = B.__FEE_RATE || A.getFeeRate(), J = B.__EXTRACTED_TX.virtualSize(), re = V * J;
  if (V >= L.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(re / 1e8).toFixed(8)} in fees, which is ${V} satoshi per byte for a transaction with a VSize of ${J} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(A, B) {
  A.forEach((L) => {
    if ((0, bip371_1.isTaprootInput)(L) ? (0, bip371_1.checkTaprootInputForSigs)(L, B) : (0, psbtutils_1.checkInputForSig)(L, B))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(A) {
  if (!A.sighashType || !A.partialSig) return;
  const { partialSig: B, sighashType: L } = A;
  B.forEach((V) => {
    const { hashType: J } = bscript.signature.decode(V.signature);
    if (L !== J)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(A, B, L) {
  if (!(0, psbtutils_1.pubkeyInScript)(A, B))
    throw new Error(
      `Can not ${L} for this input with the key ${A.toString("hex")}`
    );
}
function checkTxEmpty(A) {
  if (!A.ins.every(
    (L) => L.script && L.script.length === 0 && L.witness && L.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(A, B) {
  A.ins.forEach((L) => {
    checkTxInputCache(B, L);
  });
}
function checkTxInputCache(A, B) {
  const L = (0, bufferutils_1.reverseBuffer)(Buffer$D.from(B.hash)).toString("hex") + ":" + B.index;
  if (A.__TX_IN_CACHE[L]) throw new Error("Duplicate input detected.");
  A.__TX_IN_CACHE[L] = 1;
}
function scriptCheckerFactory(A, B) {
  return (L, V, J, re) => {
    const ne = A({
      redeem: { output: J }
    }).output;
    if (!V.equals(ne))
      throw new Error(
        `${B} for ${re} #${L} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(A, B, L, V) {
  if (!L.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${B}`);
  if (A === "__FEE_RATE" && V.__FEE_RATE) return V.__FEE_RATE;
  if (A === "__FEE" && V.__FEE) return V.__FEE;
  let J, re = !0;
  if (V.__EXTRACTED_TX ? (J = V.__EXTRACTED_TX, re = !1) : J = V.__TX.clone(), inputFinalizeGetAmts(L, J, V, re), A === "__FEE_RATE") return V.__FEE_RATE;
  if (A === "__FEE") return V.__FEE;
}
function getFinalScripts(A, B, L, V, J, re) {
  const ne = classifyScript(L);
  if (!canFinalize(B, L, ne))
    throw new Error(`Can not finalize input #${A}`);
  return prepareFinalScripts(
    L,
    ne,
    B.partialSig,
    V,
    J,
    re
  );
}
function prepareFinalScripts(A, B, L, V, J, re) {
  let ne, ie;
  const pe = getPayment(A, B, L), nt = re ? payments.p2wsh({ redeem: pe }) : null, oe = J ? payments.p2sh({ redeem: nt || pe }) : null;
  return V ? (nt ? ie = (0, psbtutils_1.witnessStackToScriptWitness)(
    nt.witness
  ) : ie = (0, psbtutils_1.witnessStackToScriptWitness)(
    pe.witness
  ), oe && (ne = oe.input)) : oe ? ne = oe.input : ne = pe.input, {
    finalScriptSig: ne,
    finalScriptWitness: ie
  };
}
function getHashAndSighashType(A, B, L, V, J) {
  const re = (0, utils_1.checkForInput)(A, B), { hash: ne, sighashType: ie, script: pe } = getHashForSig(
    B,
    re,
    V,
    !1,
    J
  );
  return checkScriptForPubkey(L, pe, "sign"), {
    hash: ne,
    sighashType: ie
  };
}
function getHashForSig(A, B, L, V, J) {
  const re = L.__TX, ne = B.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(ne, J);
  let ie, pe;
  if (B.nonWitnessUtxo) {
    const Ce = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), at = re.ins[A].hash, it = Ce.getHash();
    if (!at.equals(it))
      throw new Error(
        `Non-witness UTXO hash for input #${A} doesn't match the hash specified in the prevout`
      );
    const gt = re.ins[A].index;
    pe = Ce.outs[gt];
  } else if (B.witnessUtxo)
    pe = B.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: nt, type: oe } = getMeaningfulScript(
    pe.script,
    A,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(oe) >= 0)
    ie = re.hashForWitnessV0(
      A,
      nt,
      pe.value,
      ne
    );
  else if ((0, psbtutils_1.isP2WPKH)(nt)) {
    const Ce = payments.p2pkh({
      hash: nt.slice(2)
    }).output;
    ie = re.hashForWitnessV0(
      A,
      Ce,
      pe.value,
      ne
    );
  } else {
    if (B.nonWitnessUtxo === void 0 && L.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${A} has witnessUtxo but non-segwit script: ${nt.toString("hex")}`
      );
    !V && L.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ie = re.hashForSignature(
      A,
      nt,
      ne
    );
  }
  return {
    script: nt,
    sighashType: ne,
    hash: ie
  };
}
function getAllTaprootHashesForSig(A, B, L, V) {
  const J = [];
  if (B.tapInternalKey) {
    const ne = getPrevoutTaprootKey(A, B, V);
    ne && J.push(ne);
  }
  if (B.tapScriptSig) {
    const ne = B.tapScriptSig.map((ie) => ie.pubkey);
    J.push(...ne);
  }
  return J.map(
    (ne) => getTaprootHashesForSig(A, B, L, ne, V)
  ).flat();
}
function getPrevoutTaprootKey(A, B, L) {
  const { script: V } = getScriptAndAmountFromUtxo(A, B, L);
  return (0, psbtutils_1.isP2TR)(V) ? V.subarray(2, 34) : null;
}
function trimTaprootSig(A) {
  return A.length === 64 ? A : A.subarray(0, 64);
}
function getTaprootHashesForSig(A, B, L, V, J, re, ne) {
  const ie = J.__TX, pe = B.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(pe, ne);
  const nt = L.map(
    (gt, St) => getScriptAndAmountFromUtxo(St, gt, J)
  ), oe = nt.map((gt) => gt.script), Ce = nt.map((gt) => gt.value), at = [];
  if (B.tapInternalKey && !re) {
    const gt = getPrevoutTaprootKey(A, B, J) || Buffer$D.from([]);
    if ((0, bip371_1.toXOnly)(V).equals(gt)) {
      const St = ie.hashForWitnessV1(
        A,
        oe,
        Ce,
        pe
      );
      at.push({ pubkey: V, hash: St });
    }
  }
  const it = (B.tapLeafScript || []).filter((gt) => (0, psbtutils_1.pubkeyInScript)(V, gt.script)).map((gt) => {
    const St = (0, bip341_1.tapleafHash)({
      output: gt.script,
      version: gt.leafVersion
    });
    return Object.assign({ hash: St }, gt);
  }).filter(
    (gt) => !re || re.equals(gt.hash)
  ).map((gt) => {
    const St = ie.hashForWitnessV1(
      A,
      oe,
      Ce,
      pe,
      gt.hash
    );
    return {
      pubkey: V,
      hash: St,
      leafHash: gt.hash
    };
  });
  return at.concat(it);
}
function checkSighashTypeAllowed(A, B) {
  if (B && B.indexOf(A) < 0) {
    const L = sighashTypeToString(A);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${L}`
    );
  }
}
function getPayment(A, B, L) {
  let V;
  switch (B) {
    case "multisig":
      const J = getSortedSigs(A, L);
      V = payments.p2ms({
        output: A,
        signatures: J
      });
      break;
    case "pubkey":
      V = payments.p2pk({
        output: A,
        signature: L[0].signature
      });
      break;
    case "pubkeyhash":
      V = payments.p2pkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
    case "witnesspubkeyhash":
      V = payments.p2wpkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
  }
  return V;
}
function getScriptFromInput(A, B, L) {
  const V = L.__TX, J = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (J.isP2SH = !!B.redeemScript, J.isP2WSH = !!B.witnessScript, B.witnessScript)
    J.script = B.witnessScript;
  else if (B.redeemScript)
    J.script = B.redeemScript;
  else if (B.nonWitnessUtxo) {
    const re = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), ne = V.ins[A].index;
    J.script = re.outs[ne].script;
  } else B.witnessUtxo && (J.script = B.witnessUtxo.script);
  return (B.witnessScript || (0, psbtutils_1.isP2WPKH)(J.script)) && (J.isSegwit = !0), J;
}
function getSignersFromHD(A, B, L) {
  const V = (0, utils_1.checkForInput)(B, A);
  if (!V.bip32Derivation || V.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const J = V.bip32Derivation.map((ne) => {
    if (ne.masterFingerprint.equals(L.fingerprint))
      return ne;
  }).filter((ne) => !!ne);
  if (J.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return J.map((ne) => {
    const ie = L.derivePath(ne.path);
    if (!ne.pubkey.equals(ie.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ie;
  });
}
function getSortedSigs(A, B) {
  return payments.p2ms({ output: A }).pubkeys.map((V) => (B.filter((J) => J.pubkey.equals(V))[0] || {}).signature).filter((V) => !!V);
}
function scriptWitnessToWitnessStack(A) {
  let B = 0;
  function L(ne) {
    return B += ne, A.slice(B - ne, B);
  }
  function V() {
    const ne = varuint.decode(A, B);
    return B += varuint.decode.bytes, ne;
  }
  function J() {
    return L(V());
  }
  function re() {
    const ne = V(), ie = [];
    for (let pe = 0; pe < ne; pe++) ie.push(J());
    return ie;
  }
  return re();
}
function sighashTypeToString(A) {
  let B = A & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (A & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      B += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      B += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      B += "SIGHASH_NONE";
      break;
  }
  return B;
}
function addNonWitnessTxCache(A, B, L) {
  A.__NON_WITNESS_UTXO_BUF_CACHE[L] = B.nonWitnessUtxo;
  const V = transaction_1.Transaction.fromBuffer(B.nonWitnessUtxo);
  A.__NON_WITNESS_UTXO_TX_CACHE[L] = V;
  const J = A, re = L;
  delete B.nonWitnessUtxo, Object.defineProperty(B, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const ne = J.__NON_WITNESS_UTXO_BUF_CACHE[re], ie = J.__NON_WITNESS_UTXO_TX_CACHE[re];
      if (ne !== void 0)
        return ne;
      {
        const pe = ie.toBuffer();
        return J.__NON_WITNESS_UTXO_BUF_CACHE[re] = pe, pe;
      }
    },
    set(ne) {
      J.__NON_WITNESS_UTXO_BUF_CACHE[re] = ne;
    }
  });
}
function inputFinalizeGetAmts(A, B, L, V) {
  let J = 0;
  A.forEach((pe, nt) => {
    if (V && pe.finalScriptSig && (B.ins[nt].script = pe.finalScriptSig), V && pe.finalScriptWitness && (B.ins[nt].witness = scriptWitnessToWitnessStack(
      pe.finalScriptWitness
    )), pe.witnessUtxo)
      J += pe.witnessUtxo.value;
    else if (pe.nonWitnessUtxo) {
      const oe = nonWitnessUtxoTxFromCache(L, pe, nt), Ce = B.ins[nt].index, at = oe.outs[Ce];
      J += at.value;
    }
  });
  const re = B.outs.reduce((pe, nt) => pe + nt.value, 0), ne = J - re;
  if (ne < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ie = B.virtualSize();
  L.__FEE = ne, L.__EXTRACTED_TX = B, L.__FEE_RATE = Math.floor(ne / ie);
}
function nonWitnessUtxoTxFromCache(A, B, L) {
  const V = A.__NON_WITNESS_UTXO_TX_CACHE;
  return V[L] || addNonWitnessTxCache(A, B, L), V[L];
}
function getScriptFromUtxo(A, B, L) {
  const { script: V } = getScriptAndAmountFromUtxo(A, B, L);
  return V;
}
function getScriptAndAmountFromUtxo(A, B, L) {
  if (B.witnessUtxo !== void 0)
    return {
      script: B.witnessUtxo.script,
      value: B.witnessUtxo.value
    };
  if (B.nonWitnessUtxo !== void 0) {
    const J = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ).outs[L.__TX.ins[A].index];
    return { script: J.script, value: J.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(A, B, L, V) {
  const J = getScriptFromUtxo(L, B, V), { meaningfulScript: re } = getMeaningfulScript(
    J,
    L,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, re);
}
function pubkeyInOutput(A, B, L, V) {
  const J = V.__TX.outs[L].script, { meaningfulScript: re } = getMeaningfulScript(
    J,
    L,
    "output",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, re);
}
function redeemFromFinalScriptSig(A) {
  if (!A) return;
  const B = bscript.decompile(A);
  if (!B) return;
  const L = B[B.length - 1];
  if (!(!Buffer$D.isBuffer(L) || isPubkeyLike(L) || isSigLike(L) || !bscript.decompile(L)))
    return L;
}
function redeemFromFinalWitnessScript(A) {
  if (!A) return;
  const B = scriptWitnessToWitnessStack(A), L = B[B.length - 1];
  if (!(isPubkeyLike(L) || !bscript.decompile(L)))
    return L;
}
function compressPubkey(A) {
  if (A.length === 65) {
    const B = A[64] & 1, L = A.slice(0, 33);
    return L[0] = 2 | B, L;
  }
  return A.slice();
}
function isPubkeyLike(A) {
  return A.length === 33 && bscript.isCanonicalPubKey(A);
}
function isSigLike(A) {
  return bscript.isCanonicalScriptSignature(A);
}
function getMeaningfulScript(A, B, L, V, J) {
  const re = (0, psbtutils_1.isP2SHScript)(A), ne = re && V && (0, psbtutils_1.isP2WSHScript)(V), ie = (0, psbtutils_1.isP2WSHScript)(A);
  if (re && V === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ie || ne) && J === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let pe;
  return ne ? (pe = J, checkRedeemScript(B, A, V, L), checkWitnessScript(B, V, J, L), checkInvalidP2WSH(pe)) : ie ? (pe = J, checkWitnessScript(B, A, J, L), checkInvalidP2WSH(pe)) : re ? (pe = V, checkRedeemScript(B, A, V, L)) : pe = A, {
    meaningfulScript: pe,
    type: ne ? "p2sh-p2wsh" : re ? "p2sh" : ie ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(A) {
  if ((0, psbtutils_1.isP2WPKH)(A) || (0, psbtutils_1.isP2SHScript)(A))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(A) {
  return (0, psbtutils_1.isP2WPKH)(A) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(A) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(A) ? "multisig" : (0, psbtutils_1.isP2PK)(A) ? "pubkey" : "nonstandard";
}
function range(A) {
  return [...Array(A).keys()];
}
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.initEccLib = A.Transaction = A.opcodes = A.Psbt = A.Block = A.script = A.payments = A.networks = A.crypto = A.address = void 0;
  const B = requireAddress();
  A.address = B;
  const L = crypto$1;
  A.crypto = L;
  const V = networks;
  A.networks = V;
  const J = requirePayments();
  A.payments = J;
  const re = requireScript();
  A.script = re;
  var ne = block;
  Object.defineProperty(A, "Block", {
    enumerable: !0,
    get: function() {
      return ne.Block;
    }
  });
  var ie = psbt$1;
  Object.defineProperty(A, "Psbt", {
    enumerable: !0,
    get: function() {
      return ie.Psbt;
    }
  });
  var pe = ops;
  Object.defineProperty(A, "opcodes", {
    enumerable: !0,
    get: function() {
      return pe.OPS;
    }
  });
  var nt = transaction;
  Object.defineProperty(A, "Transaction", {
    enumerable: !0,
    get: function() {
      return nt.Transaction;
    }
  });
  var oe = ecc_lib;
  Object.defineProperty(A, "initEccLib", {
    enumerable: !0,
    get: function() {
      return oe.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: A, publicKey: B, format: L, wallet: V } = useOrdConnect(), [J, re] = useState(null), [ne, ie] = useState(!1);
  return { sign: useCallback(
    async (nt, oe, Ce) => {
      ie(!0);
      try {
        if (re(null), !L || !B || !V)
          throw new Error("No wallet is connected");
        const at = src$1.Psbt.fromBase64(oe), it = await signPsbt({
          address: nt,
          wallet: V,
          network: A,
          psbt: at,
          options: Ce
        });
        return ie(!1), it;
      } catch (at) {
        throw re(at.message), ie(!1), at;
      }
    },
    [L, A, B, V]
  ), error: J, loading: ne };
}
function leatherPaymentTypeFromFormat(A) {
  if (A === "segwit")
    return LeatherAddressType.P2WPKH;
  if (A === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: A,
  wallet: B,
  address: L,
  network: V,
  format: J
}) {
  if (B === Wallet.MAGICEDEN) {
    const { base64: re } = await signMessage$1(A, L, V);
    return re;
  }
  if (B === Wallet.UNISAT) {
    const { base64: re } = await signMessage$2(A, "bip322-simple");
    return re;
  }
  if (B === Wallet.XVERSE) {
    const { base64: re } = await signMessage$3(A, L, V);
    return re;
  }
  if (B === Wallet.LEATHER) {
    const re = leatherPaymentTypeFromFormat(J), { base64: ne } = await signMessage$4(A, {
      paymentType: re,
      network: V
    });
    return ne;
  }
  if (B === Wallet.OKX) {
    const { base64: re } = await signMessage$5(A, "bip322-simple", V);
    return re;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: A,
    wallet: B,
    publicKey: L,
    format: V,
    address: J
  } = useOrdConnect(), [re, ne] = useState(null), [ie, pe] = useState(!1);
  return { signMsg: useCallback(
    async (oe, Ce) => {
      pe(!0);
      try {
        if (ne(null), !V || !L || !B)
          throw new Error("No wallet is connected");
        if (J.ordinals !== oe && J.payments !== oe)
          throw new Error("Address supplied is not connected address");
        const at = await signMessage({
          address: oe,
          wallet: B,
          message: Ce,
          network: A,
          format: J.ordinals === oe ? V.ordinals : V.payments
        });
        return pe(!1), at;
      } catch (at) {
        throw ne(at.message), pe(!1), at;
      }
    },
    [V, A, L, B, J]
  ), error: re, isLoading: ie };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
