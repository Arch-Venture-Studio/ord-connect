(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as C$2 from "react";
import C__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useLayoutEffect, useRef, forwardRef, Fragment, isValidElement, cloneElement, createElement, useReducer, createRef } from "react";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletRequestCancelledByUserError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { createPortal } from "react-dom";
import { signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(A) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(A, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(A, 0);
  try {
    return cachedSetTimeout(A, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, A, 0);
    } catch {
      return cachedSetTimeout.call(this, A, 0);
    }
  }
}
function runClearTimeout(A) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(A);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(A);
  try {
    return cachedClearTimeout(A);
  } catch {
    try {
      return cachedClearTimeout.call(null, A);
    } catch {
      return cachedClearTimeout.call(this, A);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var A = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var B = queue.length; B; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < B; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, B = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(A);
  }
}
process.nextTick = function(A) {
  var B = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var L = 1; L < arguments.length; L++)
      B[L - 1] = arguments[L];
  queue.push(new Item(A, B)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(A, B) {
  this.fun = A, this.array = B;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(A) {
  return [];
};
process.binding = function(A) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(A) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(A) {
  return A && A.__esModule && Object.prototype.hasOwnProperty.call(A, "default") ? A.default : A;
}
function getAugmentedNamespace(A) {
  if (A.__esModule) return A;
  var B = A.default;
  if (typeof B == "function") {
    var L = function K() {
      return this instanceof K ? Reflect.construct(B, arguments, this.constructor) : B.apply(this, arguments);
    };
    L.prototype = B.prototype;
  } else L = {};
  return Object.defineProperty(L, "__esModule", { value: !0 }), Object.keys(A).forEach(function(K) {
    var V = Object.getOwnPropertyDescriptor(A, K);
    Object.defineProperty(L, K, V.get ? V : {
      enumerable: !0,
      get: function() {
        return A[K];
      }
    });
  }), L;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.fragment"), K = Object.prototype.hasOwnProperty, V = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, W = { key: !0, ref: !0, __self: !0, __source: !0 };
  function J(ne, ie, ce) {
    var re, oe = {}, ke = null, Oe = null;
    ce !== void 0 && (ke = "" + ce), ie.key !== void 0 && (ke = "" + ie.key), ie.ref !== void 0 && (Oe = ie.ref);
    for (re in ie) K.call(ie, re) && !W.hasOwnProperty(re) && (oe[re] = ie[re]);
    if (ne && ne.defaultProps) for (re in ie = ne.defaultProps, ie) oe[re] === void 0 && (oe[re] = ie[re]);
    return { $$typeof: B, type: ne, key: ke, ref: Oe, props: oe, _owner: V.current };
  }
  return reactJsxRuntime_production_min.Fragment = L, reactJsxRuntime_production_min.jsx = J, reactJsxRuntime_production_min.jsxs = J, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var A = C__default, B = Symbol.for("react.element"), L = Symbol.for("react.portal"), K = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), W = Symbol.for("react.profiler"), J = Symbol.for("react.provider"), ne = Symbol.for("react.context"), ie = Symbol.for("react.forward_ref"), ce = Symbol.for("react.suspense"), re = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), ke = Symbol.for("react.lazy"), Oe = Symbol.for("react.offscreen"), it = Symbol.iterator, at = "@@iterator";
    function ut(Nt) {
      if (Nt === null || typeof Nt != "object")
        return null;
      var Qt = it && Nt[it] || Nt[at];
      return typeof Qt == "function" ? Qt : null;
    }
    var dt = A.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function ct(Nt) {
      {
        for (var Qt = arguments.length, rr = new Array(Qt > 1 ? Qt - 1 : 0), ar = 1; ar < Qt; ar++)
          rr[ar - 1] = arguments[ar];
        bt("error", Nt, rr);
      }
    }
    function bt(Nt, Qt, rr) {
      {
        var ar = dt.ReactDebugCurrentFrame, br = ar.getStackAddendum();
        br !== "" && (Qt += "%s", rr = rr.concat([br]));
        var _r = rr.map(function(pr) {
          return String(pr);
        });
        _r.unshift("Warning: " + Qt), Function.prototype.apply.call(console[Nt], console, _r);
      }
    }
    var vt = !1, $t = !1, xt = !1, Ot = !1, At = !1, yt;
    yt = Symbol.for("react.module.reference");
    function Bt(Nt) {
      return !!(typeof Nt == "string" || typeof Nt == "function" || Nt === K || Nt === W || At || Nt === V || Nt === ce || Nt === re || Ot || Nt === Oe || vt || $t || xt || typeof Nt == "object" && Nt !== null && (Nt.$$typeof === ke || Nt.$$typeof === oe || Nt.$$typeof === J || Nt.$$typeof === ne || Nt.$$typeof === ie || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Nt.$$typeof === yt || Nt.getModuleId !== void 0));
    }
    function gt(Nt, Qt, rr) {
      var ar = Nt.displayName;
      if (ar)
        return ar;
      var br = Qt.displayName || Qt.name || "";
      return br !== "" ? rr + "(" + br + ")" : rr;
    }
    function rt(Nt) {
      return Nt.displayName || "Context";
    }
    function Ce(Nt) {
      if (Nt == null)
        return null;
      if (typeof Nt.tag == "number" && ct("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Nt == "function")
        return Nt.displayName || Nt.name || null;
      if (typeof Nt == "string")
        return Nt;
      switch (Nt) {
        case K:
          return "Fragment";
        case L:
          return "Portal";
        case W:
          return "Profiler";
        case V:
          return "StrictMode";
        case ce:
          return "Suspense";
        case re:
          return "SuspenseList";
      }
      if (typeof Nt == "object")
        switch (Nt.$$typeof) {
          case ne:
            var Qt = Nt;
            return rt(Qt) + ".Consumer";
          case J:
            var rr = Nt;
            return rt(rr._context) + ".Provider";
          case ie:
            return gt(Nt, Nt.render, "ForwardRef");
          case oe:
            var ar = Nt.displayName || null;
            return ar !== null ? ar : Ce(Nt.type) || "Memo";
          case ke: {
            var br = Nt, _r = br._payload, pr = br._init;
            try {
              return Ce(pr(_r));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var pe = Object.assign, nt = 0, st, ot, ht, pt, ft, mt, lt;
    function St() {
    }
    St.__reactDisabledLog = !0;
    function Ft() {
      {
        if (nt === 0) {
          st = console.log, ot = console.info, ht = console.warn, pt = console.error, ft = console.group, mt = console.groupCollapsed, lt = console.groupEnd;
          var Nt = {
            configurable: !0,
            enumerable: !0,
            value: St,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Nt,
            log: Nt,
            warn: Nt,
            error: Nt,
            group: Nt,
            groupCollapsed: Nt,
            groupEnd: Nt
          });
        }
        nt++;
      }
    }
    function Gt() {
      {
        if (nt--, nt === 0) {
          var Nt = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: pe({}, Nt, {
              value: st
            }),
            info: pe({}, Nt, {
              value: ot
            }),
            warn: pe({}, Nt, {
              value: ht
            }),
            error: pe({}, Nt, {
              value: pt
            }),
            group: pe({}, Nt, {
              value: ft
            }),
            groupCollapsed: pe({}, Nt, {
              value: mt
            }),
            groupEnd: pe({}, Nt, {
              value: lt
            })
          });
        }
        nt < 0 && ct("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var qt = dt.ReactCurrentDispatcher, Pt;
    function Tt(Nt, Qt, rr) {
      {
        if (Pt === void 0)
          try {
            throw Error();
          } catch (br) {
            var ar = br.stack.trim().match(/\n( *(at )?)/);
            Pt = ar && ar[1] || "";
          }
        return `
` + Pt + Nt;
      }
    }
    var Ut = !1, Wt;
    {
      var It = typeof WeakMap == "function" ? WeakMap : Map;
      Wt = new It();
    }
    function Rt(Nt, Qt) {
      if (!Nt || Ut)
        return "";
      {
        var rr = Wt.get(Nt);
        if (rr !== void 0)
          return rr;
      }
      var ar;
      Ut = !0;
      var br = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var _r;
      _r = qt.current, qt.current = null, Ft();
      try {
        if (Qt) {
          var pr = function() {
            throw Error();
          };
          if (Object.defineProperty(pr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(pr, []);
            } catch (Fr) {
              ar = Fr;
            }
            Reflect.construct(Nt, [], pr);
          } else {
            try {
              pr.call();
            } catch (Fr) {
              ar = Fr;
            }
            Nt.call(pr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Fr) {
            ar = Fr;
          }
          Nt();
        }
      } catch (Fr) {
        if (Fr && ar && typeof Fr.stack == "string") {
          for (var Tr = Fr.stack.split(`
`), Nr = ar.stack.split(`
`), kr = Tr.length - 1, qr = Nr.length - 1; kr >= 1 && qr >= 0 && Tr[kr] !== Nr[qr]; )
            qr--;
          for (; kr >= 1 && qr >= 0; kr--, qr--)
            if (Tr[kr] !== Nr[qr]) {
              if (kr !== 1 || qr !== 1)
                do
                  if (kr--, qr--, qr < 0 || Tr[kr] !== Nr[qr]) {
                    var Lr = `
` + Tr[kr].replace(" at new ", " at ");
                    return Nt.displayName && Lr.includes("<anonymous>") && (Lr = Lr.replace("<anonymous>", Nt.displayName)), typeof Nt == "function" && Wt.set(Nt, Lr), Lr;
                  }
                while (kr >= 1 && qr >= 0);
              break;
            }
        }
      } finally {
        Ut = !1, qt.current = _r, Gt(), Error.prepareStackTrace = br;
      }
      var Dr = Nt ? Nt.displayName || Nt.name : "", Ur = Dr ? Tt(Dr) : "";
      return typeof Nt == "function" && Wt.set(Nt, Ur), Ur;
    }
    function jt(Nt, Qt, rr) {
      return Rt(Nt, !1);
    }
    function Jt(Nt) {
      var Qt = Nt.prototype;
      return !!(Qt && Qt.isReactComponent);
    }
    function er(Nt, Qt, rr) {
      if (Nt == null)
        return "";
      if (typeof Nt == "function")
        return Rt(Nt, Jt(Nt));
      if (typeof Nt == "string")
        return Tt(Nt);
      switch (Nt) {
        case ce:
          return Tt("Suspense");
        case re:
          return Tt("SuspenseList");
      }
      if (typeof Nt == "object")
        switch (Nt.$$typeof) {
          case ie:
            return jt(Nt.render);
          case oe:
            return er(Nt.type, Qt, rr);
          case ke: {
            var ar = Nt, br = ar._payload, _r = ar._init;
            try {
              return er(_r(br), Qt, rr);
            } catch {
            }
          }
        }
      return "";
    }
    var nr = Object.prototype.hasOwnProperty, fr = {}, lr = dt.ReactDebugCurrentFrame;
    function Yt(Nt) {
      if (Nt) {
        var Qt = Nt._owner, rr = er(Nt.type, Nt._source, Qt ? Qt.type : null);
        lr.setExtraStackFrame(rr);
      } else
        lr.setExtraStackFrame(null);
    }
    function Pr(Nt, Qt, rr, ar, br) {
      {
        var _r = Function.call.bind(nr);
        for (var pr in Nt)
          if (_r(Nt, pr)) {
            var Tr = void 0;
            try {
              if (typeof Nt[pr] != "function") {
                var Nr = Error((ar || "React class") + ": " + rr + " type `" + pr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Nt[pr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Nr.name = "Invariant Violation", Nr;
              }
              Tr = Nt[pr](Qt, pr, ar, rr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (kr) {
              Tr = kr;
            }
            Tr && !(Tr instanceof Error) && (Yt(br), ct("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ar || "React class", rr, pr, typeof Tr), Yt(null)), Tr instanceof Error && !(Tr.message in fr) && (fr[Tr.message] = !0, Yt(br), ct("Failed %s type: %s", rr, Tr.message), Yt(null));
          }
      }
    }
    var or = Array.isArray;
    function Ar(Nt) {
      return or(Nt);
    }
    function Br(Nt) {
      {
        var Qt = typeof Symbol == "function" && Symbol.toStringTag, rr = Qt && Nt[Symbol.toStringTag] || Nt.constructor.name || "Object";
        return rr;
      }
    }
    function cr(Nt) {
      try {
        return xr(Nt), !1;
      } catch {
        return !0;
      }
    }
    function xr(Nt) {
      return "" + Nt;
    }
    function Ir(Nt) {
      if (cr(Nt))
        return ct("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Br(Nt)), xr(Nt);
    }
    var gr = dt.ReactCurrentOwner, Rr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Or, Mt;
    function wt(Nt) {
      if (nr.call(Nt, "ref")) {
        var Qt = Object.getOwnPropertyDescriptor(Nt, "ref").get;
        if (Qt && Qt.isReactWarning)
          return !1;
      }
      return Nt.ref !== void 0;
    }
    function Et(Nt) {
      if (nr.call(Nt, "key")) {
        var Qt = Object.getOwnPropertyDescriptor(Nt, "key").get;
        if (Qt && Qt.isReactWarning)
          return !1;
      }
      return Nt.key !== void 0;
    }
    function Ct(Nt, Qt) {
      typeof Nt.ref == "string" && gr.current;
    }
    function Kt(Nt, Qt) {
      {
        var rr = function() {
          Or || (Or = !0, ct("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Qt));
        };
        rr.isReactWarning = !0, Object.defineProperty(Nt, "key", {
          get: rr,
          configurable: !0
        });
      }
    }
    function Vt(Nt, Qt) {
      {
        var rr = function() {
          Mt || (Mt = !0, ct("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Qt));
        };
        rr.isReactWarning = !0, Object.defineProperty(Nt, "ref", {
          get: rr,
          configurable: !0
        });
      }
    }
    var zt = function(Nt, Qt, rr, ar, br, _r, pr) {
      var Tr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: B,
        // Built-in properties that belong on the element
        type: Nt,
        key: Qt,
        ref: rr,
        props: pr,
        // Record the component responsible for creating this element.
        _owner: _r
      };
      return Tr._store = {}, Object.defineProperty(Tr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Tr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ar
      }), Object.defineProperty(Tr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: br
      }), Object.freeze && (Object.freeze(Tr.props), Object.freeze(Tr)), Tr;
    };
    function yr(Nt, Qt, rr, ar, br) {
      {
        var _r, pr = {}, Tr = null, Nr = null;
        rr !== void 0 && (Ir(rr), Tr = "" + rr), Et(Qt) && (Ir(Qt.key), Tr = "" + Qt.key), wt(Qt) && (Nr = Qt.ref, Ct(Qt, br));
        for (_r in Qt)
          nr.call(Qt, _r) && !Rr.hasOwnProperty(_r) && (pr[_r] = Qt[_r]);
        if (Nt && Nt.defaultProps) {
          var kr = Nt.defaultProps;
          for (_r in kr)
            pr[_r] === void 0 && (pr[_r] = kr[_r]);
        }
        if (Tr || Nr) {
          var qr = typeof Nt == "function" ? Nt.displayName || Nt.name || "Unknown" : Nt;
          Tr && Kt(pr, qr), Nr && Vt(pr, qr);
        }
        return zt(Nt, Tr, Nr, br, ar, gr.current, pr);
      }
    }
    var $r = dt.ReactCurrentOwner, hr = dt.ReactDebugCurrentFrame;
    function Er(Nt) {
      if (Nt) {
        var Qt = Nt._owner, rr = er(Nt.type, Nt._source, Qt ? Qt.type : null);
        hr.setExtraStackFrame(rr);
      } else
        hr.setExtraStackFrame(null);
    }
    var Sr;
    Sr = !1;
    function wr(Nt) {
      return typeof Nt == "object" && Nt !== null && Nt.$$typeof === B;
    }
    function Mr() {
      {
        if ($r.current) {
          var Nt = Ce($r.current.type);
          if (Nt)
            return `

Check the render method of \`` + Nt + "`.";
        }
        return "";
      }
    }
    function Cr(Nt) {
      return "";
    }
    var Lt = {};
    function kt(Nt) {
      {
        var Qt = Mr();
        if (!Qt) {
          var rr = typeof Nt == "string" ? Nt : Nt.displayName || Nt.name;
          rr && (Qt = `

Check the top-level render call using <` + rr + ">.");
        }
        return Qt;
      }
    }
    function Dt(Nt, Qt) {
      {
        if (!Nt._store || Nt._store.validated || Nt.key != null)
          return;
        Nt._store.validated = !0;
        var rr = kt(Qt);
        if (Lt[rr])
          return;
        Lt[rr] = !0;
        var ar = "";
        Nt && Nt._owner && Nt._owner !== $r.current && (ar = " It was passed a child from " + Ce(Nt._owner.type) + "."), Er(Nt), ct('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', rr, ar), Er(null);
      }
    }
    function Ht(Nt, Qt) {
      {
        if (typeof Nt != "object")
          return;
        if (Ar(Nt))
          for (var rr = 0; rr < Nt.length; rr++) {
            var ar = Nt[rr];
            wr(ar) && Dt(ar, Qt);
          }
        else if (wr(Nt))
          Nt._store && (Nt._store.validated = !0);
        else if (Nt) {
          var br = ut(Nt);
          if (typeof br == "function" && br !== Nt.entries)
            for (var _r = br.call(Nt), pr; !(pr = _r.next()).done; )
              wr(pr.value) && Dt(pr.value, Qt);
        }
      }
    }
    function Xt(Nt) {
      {
        var Qt = Nt.type;
        if (Qt == null || typeof Qt == "string")
          return;
        var rr;
        if (typeof Qt == "function")
          rr = Qt.propTypes;
        else if (typeof Qt == "object" && (Qt.$$typeof === ie || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Qt.$$typeof === oe))
          rr = Qt.propTypes;
        else
          return;
        if (rr) {
          var ar = Ce(Qt);
          Pr(rr, Nt.props, "prop", ar, Nt);
        } else if (Qt.PropTypes !== void 0 && !Sr) {
          Sr = !0;
          var br = Ce(Qt);
          ct("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", br || "Unknown");
        }
        typeof Qt.getDefaultProps == "function" && !Qt.getDefaultProps.isReactClassApproved && ct("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Zt(Nt) {
      {
        for (var Qt = Object.keys(Nt.props), rr = 0; rr < Qt.length; rr++) {
          var ar = Qt[rr];
          if (ar !== "children" && ar !== "key") {
            Er(Nt), ct("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ar), Er(null);
            break;
          }
        }
        Nt.ref !== null && (Er(Nt), ct("Invalid attribute `ref` supplied to `React.Fragment`."), Er(null));
      }
    }
    var tr = {};
    function ir(Nt, Qt, rr, ar, br, _r) {
      {
        var pr = Bt(Nt);
        if (!pr) {
          var Tr = "";
          (Nt === void 0 || typeof Nt == "object" && Nt !== null && Object.keys(Nt).length === 0) && (Tr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Nr = Cr();
          Nr ? Tr += Nr : Tr += Mr();
          var kr;
          Nt === null ? kr = "null" : Ar(Nt) ? kr = "array" : Nt !== void 0 && Nt.$$typeof === B ? (kr = "<" + (Ce(Nt.type) || "Unknown") + " />", Tr = " Did you accidentally export a JSX literal instead of a component?") : kr = typeof Nt, ct("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", kr, Tr);
        }
        var qr = yr(Nt, Qt, rr, br, _r);
        if (qr == null)
          return qr;
        if (pr) {
          var Lr = Qt.children;
          if (Lr !== void 0)
            if (ar)
              if (Ar(Lr)) {
                for (var Dr = 0; Dr < Lr.length; Dr++)
                  Ht(Lr[Dr], Nt);
                Object.freeze && Object.freeze(Lr);
              } else
                ct("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ht(Lr, Nt);
        }
        if (nr.call(Qt, "key")) {
          var Ur = Ce(Nt), Fr = Object.keys(Qt).filter(function(Wr) {
            return Wr !== "key";
          }), jr = Fr.length > 0 ? "{key: someKey, " + Fr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!tr[Ur + jr]) {
            var Hr = Fr.length > 0 ? "{" + Fr.join(": ..., ") + ": ...}" : "{}";
            ct(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, jr, Ur, Hr, Ur), tr[Ur + jr] = !0;
          }
        }
        return Nt === K ? Zt(qr) : Xt(qr), qr;
      }
    }
    function ur(Nt, Qt, rr) {
      return ir(Nt, Qt, rr, !0);
    }
    function sr(Nt, Qt, rr) {
      return ir(Nt, Qt, rr, !1);
    }
    var dr = sr, vr = ur;
    reactJsxRuntime_development.Fragment = K, reactJsxRuntime_development.jsx = dr, reactJsxRuntime_development.jsxs = vr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [A, B] = useState(!1);
  return useEffect(() => {
    B(!0);
  }, []), A;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(A) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${A} even though environment is not a browser.`
  );
  const B = `${KEY_PREFIX}_${A}`;
  try {
    const L = window.localStorage.getItem(B);
    return L != null ? JSON.parse(L) : null;
  } catch (L) {
    return console.error(`Error retrieving ${B} from localStorage`, L), null;
  }
}
function setItemToLocalStorage(A, B) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${A} even though environment is not a browser.`
  );
  const L = `${KEY_PREFIX}_${A}`;
  try {
    B ? window.localStorage.setItem(L, JSON.stringify(B)) : window.localStorage.removeItem(L);
  } catch (K) {
    console.error(`Error saving ${L} to localStorage`, K);
  }
}
function useLocalStorage(A, B, L = {}) {
  const { initializeWithValue: K = !0 } = L, V = useCallback(() => {
    const ie = getItemFromLocalStorage(A);
    return ie || (setItemToLocalStorage(A, B), B);
  }, [B, A]), [W, J] = useState(() => K ? V() : B), ne = useCallback(
    (ie) => {
      setItemToLocalStorage(A, ie), J(ie);
    },
    [A]
  );
  return useEffect(() => {
    J(V());
  }, [A]), [W, ne];
}
var Network = /* @__PURE__ */ ((A) => (A.MAINNET = "mainnet", A.TESTNET = "testnet", A.SIGNET = "signet", A))(Network || {}), Wallet = /* @__PURE__ */ ((A) => (A.UNISAT = "unisat", A.XVERSE = "xverse", A.MAGICEDEN = "magiceden", A.LEATHER = "leather", A.OKX = "okx", A))(Wallet || {}), Chain = /* @__PURE__ */ ((A) => (A.BITCOIN = "bitcoin", A.FRACTAL_BITCOIN = "fractal-bitcoin", A))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: A,
  network: B,
  visibleWallets: L,
  chain: K = "bitcoin",
  ssr: V = !1
}) {
  if (!B)
    throw new Error("Network cannot be empty");
  if (!L || L.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [W, J] = useState(B), [ne, ie] = useState(L), [ce, re] = useState(K), [oe, ke] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !V }
  ), [Oe, it] = useLocalStorage(WALLET, null, {
    initializeWithValue: !V
  }), [at, ut] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !V }
  ), [dt, ct] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !V }
  ), [bt, vt] = useState(!1), $t = useCallback(() => vt(!0), []), xt = useCallback(() => vt(!1), []), Ot = useCallback(() => {
    ke(EMPTY_BIADDRESS_OBJECT), ut(EMPTY_BIADDRESS_OBJECT), ct(EMPTY_BIADDRESS_OBJECT), it(null);
  }, [ke, ct, ut, it]), At = useMemo(
    () => ({
      address: oe,
      updateAddress: ke,
      publicKey: at,
      updatePublicKey: ut,
      network: W,
      updateNetwork: J,
      wallet: Oe,
      updateWallet: it,
      isModalOpen: bt,
      openModal: $t,
      closeModal: xt,
      format: dt,
      updateFormat: ct,
      disconnectWallet: Ot,
      chain: ce,
      updateChain: re,
      visibleWallets: ne,
      updateVisibleWallets: ie
    }),
    [
      oe,
      ke,
      at,
      ut,
      W,
      J,
      Oe,
      it,
      bt,
      $t,
      xt,
      dt,
      ct,
      Ot,
      ce,
      re
    ]
  );
  return useEffect(() => {
    J(B);
  }, [B]), useEffect(() => {
    ce !== K && (Ot(), re(K));
  }, [K, ce, Ot]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: At, children: A });
}
function useOrdConnect() {
  const A = useContext(OrdConnectContext);
  if (console.log("+context", A), !A)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return A;
}
var build = { exports: {} };
(function(A, B) {
  (function(L, K) {
    A.exports = K(C__default);
  })(commonjsGlobal, function(L) {
    return function(K) {
      var V = {};
      function W(J) {
        if (V[J]) return V[J].exports;
        var ne = V[J] = { i: J, l: !1, exports: {} };
        return K[J].call(ne.exports, ne, ne.exports, W), ne.l = !0, ne.exports;
      }
      return W.m = K, W.c = V, W.d = function(J, ne, ie) {
        W.o(J, ne) || Object.defineProperty(J, ne, { enumerable: !0, get: ie });
      }, W.r = function(J) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(J, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(J, "__esModule", { value: !0 });
      }, W.t = function(J, ne) {
        if (1 & ne && (J = W(J)), 8 & ne || 4 & ne && typeof J == "object" && J && J.__esModule) return J;
        var ie = /* @__PURE__ */ Object.create(null);
        if (W.r(ie), Object.defineProperty(ie, "default", { enumerable: !0, value: J }), 2 & ne && typeof J != "string") for (var ce in J) W.d(ie, ce, (function(re) {
          return J[re];
        }).bind(null, ce));
        return ie;
      }, W.n = function(J) {
        var ne = J && J.__esModule ? function() {
          return J.default;
        } : function() {
          return J;
        };
        return W.d(ne, "a", ne), ne;
      }, W.o = function(J, ne) {
        return Object.prototype.hasOwnProperty.call(J, ne);
      }, W.p = "/", W(W.s = 1);
    }([function(K, V) {
      K.exports = L;
    }, function(K, V, W) {
      K.exports = W(2);
    }, function(K, V, W) {
      function J(ct, bt) {
        if (ct == null) return {};
        var vt, $t, xt = function(At, yt) {
          if (At == null) return {};
          var Bt, gt, rt = {}, Ce = Object.keys(At);
          for (gt = 0; gt < Ce.length; gt++) Bt = Ce[gt], yt.indexOf(Bt) >= 0 || (rt[Bt] = At[Bt]);
          return rt;
        }(ct, bt);
        if (Object.getOwnPropertySymbols) {
          var Ot = Object.getOwnPropertySymbols(ct);
          for ($t = 0; $t < Ot.length; $t++) vt = Ot[$t], bt.indexOf(vt) >= 0 || Object.prototype.propertyIsEnumerable.call(ct, vt) && (xt[vt] = ct[vt]);
        }
        return xt;
      }
      W.r(V);
      var ne = W(0), ie = W.n(ne), ce = function(ct) {
        for (var bt = 0, vt = 0; vt < ct.length; vt++)
          bt = (bt << 5) - bt + ct.charCodeAt(vt), bt &= bt;
        return Math.abs(bt);
      }, re = function(ct, bt) {
        return Math.floor(ct / Math.pow(10, bt) % 10);
      }, oe = function(ct, bt) {
        return !(re(ct, bt) % 2);
      }, ke = function(ct, bt, vt) {
        var $t = ct % bt;
        return vt && re(ct, vt) % 2 === 0 ? -$t : $t;
      }, Oe = function(ct, bt, vt) {
        return bt[ct % vt];
      }, it = function(ct) {
        var bt = ct.name, vt = ct.colors, $t = ct.title, xt = ct.square, Ot = ct.size, At = J(ct, ["name", "colors", "title", "square", "size"]), yt = function(gt, rt) {
          var Ce = ce(gt), pe = rt && rt.length;
          return Array.from({ length: 3 }, function(nt, st) {
            return { color: Oe(Ce + st, rt, pe), translateX: ke(Ce * (st + 1), 8, 1), translateY: ke(Ce * (st + 1), 8, 2), scale: 1.2 + ke(Ce * (st + 1), 4) / 10, rotate: ke(Ce * (st + 1), 360, 1) };
          });
        }(bt, vt), Bt = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Ot, height: Ot }, At), $t && ne.createElement("title", null, bt), ne.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(Bt, ")") }, ne.createElement("rect", { width: 80, height: 80, fill: yt[0].color }), ne.createElement("path", { filter: "url(#filter_".concat(Bt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: yt[1].color, transform: "translate(" + yt[1].translateX + " " + yt[1].translateY + ") rotate(" + yt[1].rotate + " 40 40) scale(" + yt[2].scale + ")" }), ne.createElement("path", { filter: "url(#filter_".concat(Bt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: yt[2].color, transform: "translate(" + yt[2].translateX + " " + yt[2].translateY + ") rotate(" + yt[2].rotate + " 40 40) scale(" + yt[2].scale + ")" })), ne.createElement("defs", null, ne.createElement("filter", { id: "filter_".concat(Bt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, ne.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), ne.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), ne.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, at = { pixel: function(ct) {
        var bt = ct.name, vt = ct.colors, $t = ct.title, xt = ct.square, Ot = ct.size, At = J(ct, ["name", "colors", "title", "square", "size"]), yt = function(gt, rt) {
          var Ce = ce(gt), pe = rt && rt.length;
          return Array.from({ length: 64 }, function(nt, st) {
            return Oe(Ce % (st + 1), rt, pe);
          });
        }(bt, vt), Bt = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Ot, height: Ot }, At), $t && ne.createElement("title", null, bt), ne.createElement("mask", { id: Bt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(Bt, ")") }, ne.createElement("rect", { width: 10, height: 10, fill: yt[0] }), ne.createElement("rect", { x: 20, width: 10, height: 10, fill: yt[1] }), ne.createElement("rect", { x: 40, width: 10, height: 10, fill: yt[2] }), ne.createElement("rect", { x: 60, width: 10, height: 10, fill: yt[3] }), ne.createElement("rect", { x: 10, width: 10, height: 10, fill: yt[4] }), ne.createElement("rect", { x: 30, width: 10, height: 10, fill: yt[5] }), ne.createElement("rect", { x: 50, width: 10, height: 10, fill: yt[6] }), ne.createElement("rect", { x: 70, width: 10, height: 10, fill: yt[7] }), ne.createElement("rect", { y: 10, width: 10, height: 10, fill: yt[8] }), ne.createElement("rect", { y: 20, width: 10, height: 10, fill: yt[9] }), ne.createElement("rect", { y: 30, width: 10, height: 10, fill: yt[10] }), ne.createElement("rect", { y: 40, width: 10, height: 10, fill: yt[11] }), ne.createElement("rect", { y: 50, width: 10, height: 10, fill: yt[12] }), ne.createElement("rect", { y: 60, width: 10, height: 10, fill: yt[13] }), ne.createElement("rect", { y: 70, width: 10, height: 10, fill: yt[14] }), ne.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: yt[15] }), ne.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: yt[16] }), ne.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: yt[17] }), ne.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: yt[18] }), ne.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: yt[19] }), ne.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: yt[20] }), ne.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: yt[21] }), ne.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: yt[22] }), ne.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: yt[23] }), ne.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: yt[24] }), ne.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: yt[25] }), ne.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: yt[26] }), ne.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: yt[27] }), ne.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: yt[28] }), ne.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: yt[29] }), ne.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: yt[30] }), ne.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: yt[31] }), ne.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: yt[32] }), ne.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: yt[33] }), ne.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: yt[34] }), ne.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: yt[35] }), ne.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: yt[36] }), ne.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: yt[37] }), ne.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: yt[38] }), ne.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: yt[39] }), ne.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: yt[40] }), ne.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: yt[41] }), ne.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: yt[42] }), ne.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: yt[43] }), ne.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: yt[44] }), ne.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: yt[45] }), ne.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: yt[46] }), ne.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: yt[47] }), ne.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: yt[48] }), ne.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: yt[49] }), ne.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: yt[50] }), ne.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: yt[51] }), ne.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: yt[52] }), ne.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: yt[53] }), ne.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: yt[54] }), ne.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: yt[55] }), ne.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: yt[56] }), ne.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: yt[57] }), ne.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: yt[58] }), ne.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: yt[59] }), ne.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: yt[60] }), ne.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: yt[61] }), ne.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: yt[62] }), ne.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: yt[63] })));
      }, bauhaus: function(ct) {
        var bt = ct.name, vt = ct.colors, $t = ct.title, xt = ct.square, Ot = ct.size, At = J(ct, ["name", "colors", "title", "square", "size"]), yt = function(gt, rt) {
          var Ce = ce(gt), pe = rt && rt.length;
          return Array.from({ length: 4 }, function(nt, st) {
            return { color: Oe(Ce + st, rt, pe), translateX: ke(Ce * (st + 1), 40 - (st + 17), 1), translateY: ke(Ce * (st + 1), 40 - (st + 17), 2), rotate: ke(Ce * (st + 1), 360), isSquare: oe(Ce, 2) };
          });
        }(bt, vt), Bt = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Ot, height: Ot }, At), $t && ne.createElement("title", null, bt), ne.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(Bt, ")") }, ne.createElement("rect", { width: 80, height: 80, fill: yt[0].color }), ne.createElement("rect", { x: 10, y: 30, width: 80, height: yt[1].isSquare ? 80 : 10, fill: yt[1].color, transform: "translate(" + yt[1].translateX + " " + yt[1].translateY + ") rotate(" + yt[1].rotate + " 40 40)" }), ne.createElement("circle", { cx: 40, cy: 40, fill: yt[2].color, r: 16, transform: "translate(" + yt[2].translateX + " " + yt[2].translateY + ")" }), ne.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: yt[3].color, transform: "translate(" + yt[3].translateX + " " + yt[3].translateY + ") rotate(" + yt[3].rotate + " 40 40)" })));
      }, ring: function(ct) {
        var bt = ct.name, vt = ct.colors, $t = ct.title, xt = ct.square, Ot = ct.size, At = J(ct, ["name", "colors", "title", "square", "size"]), yt = function(gt, rt) {
          var Ce = ce(rt), pe = gt && gt.length, nt = Array.from({ length: 5 }, function(ot, ht) {
            return Oe(Ce + ht, gt, pe);
          }), st = [];
          return st[0] = nt[0], st[1] = nt[1], st[2] = nt[1], st[3] = nt[2], st[4] = nt[2], st[5] = nt[3], st[6] = nt[3], st[7] = nt[0], st[8] = nt[4], st;
        }(vt, bt), Bt = ie.a.useId();
        return ie.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Ot, height: Ot }, At), $t && ie.a.createElement("title", null, bt), ie.a.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ie.a.createElement("rect", { width: 90, height: 90, rx: xt ? void 0 : 180, fill: "#FFFFFF" })), ie.a.createElement("g", { mask: "url(#".concat(Bt, ")") }, ie.a.createElement("path", { d: "M0 0h90v45H0z", fill: yt[0] }), ie.a.createElement("path", { d: "M0 45h90v45H0z", fill: yt[1] }), ie.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: yt[2] }), ie.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: yt[3] }), ie.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: yt[4] }), ie.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: yt[5] }), ie.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: yt[6] }), ie.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: yt[7] }), ie.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: yt[8] })));
      }, beam: function(ct) {
        var bt = ct.name, vt = ct.colors, $t = ct.title, xt = ct.square, Ot = ct.size, At = J(ct, ["name", "colors", "title", "square", "size"]), yt = function(gt, rt) {
          var Ce, pe = ce(gt), nt = rt && rt.length, st = Oe(pe, rt, nt), ot = ke(pe, 10, 1), ht = ot < 5 ? ot + 4 : ot, pt = ke(pe, 10, 2), ft = pt < 5 ? pt + 4 : pt;
          return { wrapperColor: st, faceColor: (Ce = st, Ce.slice(0, 1) === "#" && (Ce = Ce.slice(1)), (299 * parseInt(Ce.substr(0, 2), 16) + 587 * parseInt(Ce.substr(2, 2), 16) + 114 * parseInt(Ce.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Oe(pe + 13, rt, nt), wrapperTranslateX: ht, wrapperTranslateY: ft, wrapperRotate: ke(pe, 360), wrapperScale: 1 + ke(pe, 3) / 10, isMouthOpen: oe(pe, 2), isCircle: oe(pe, 1), eyeSpread: ke(pe, 5), mouthSpread: ke(pe, 3), faceRotate: ke(pe, 10, 3), faceTranslateX: ht > 6 ? ht / 2 : ke(pe, 8, 1), faceTranslateY: ft > 6 ? ft / 2 : ke(pe, 7, 2) };
        }(bt, vt), Bt = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Ot, height: Ot }, At), $t && ne.createElement("title", null, bt), ne.createElement("mask", { id: Bt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, ne.createElement("rect", { width: 36, height: 36, rx: xt ? void 0 : 72, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(Bt, ")") }, ne.createElement("rect", { width: 36, height: 36, fill: yt.backgroundColor }), ne.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + yt.wrapperTranslateX + " " + yt.wrapperTranslateY + ") rotate(" + yt.wrapperRotate + " 18 18) scale(" + yt.wrapperScale + ")", fill: yt.wrapperColor, rx: yt.isCircle ? 36 : 6 }), ne.createElement("g", { transform: "translate(" + yt.faceTranslateX + " " + yt.faceTranslateY + ") rotate(" + yt.faceRotate + " 18 18)" }, yt.isMouthOpen ? ne.createElement("path", { d: "M15 " + (19 + yt.mouthSpread) + "c2 1 4 1 6 0", stroke: yt.faceColor, fill: "none", strokeLinecap: "round" }) : ne.createElement("path", { d: "M13," + (19 + yt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: yt.faceColor }), ne.createElement("rect", { x: 14 - yt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: yt.faceColor }), ne.createElement("rect", { x: 20 + yt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: yt.faceColor }))));
      }, sunset: function(ct) {
        var bt = ct.name, vt = ct.colors, $t = ct.title, xt = ct.square, Ot = ct.size, At = J(ct, ["name", "colors", "title", "square", "size"]), yt = function(rt, Ce) {
          var pe = ce(rt), nt = Ce && Ce.length;
          return Array.from({ length: 4 }, function(st, ot) {
            return Oe(pe + ot, Ce, nt);
          });
        }(bt, vt), Bt = bt.replace(/\s/g, ""), gt = ne.useId();
        return ne.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Ot, height: Ot }, At), $t && ne.createElement("title", null, bt), ne.createElement("mask", { id: gt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, ne.createElement("rect", { width: 80, height: 80, rx: xt ? void 0 : 160, fill: "#FFFFFF" })), ne.createElement("g", { mask: "url(#".concat(gt, ")") }, ne.createElement("path", { fill: "url(#gradient_paint0_linear_" + Bt + ")", d: "M0 0h80v40H0z" }), ne.createElement("path", { fill: "url(#gradient_paint1_linear_" + Bt + ")", d: "M0 40h80v40H0z" })), ne.createElement("defs", null, ne.createElement("linearGradient", { id: "gradient_paint0_linear_" + Bt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, ne.createElement("stop", { stopColor: yt[0] }), ne.createElement("stop", { offset: 1, stopColor: yt[1] })), ne.createElement("linearGradient", { id: "gradient_paint1_linear_" + Bt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, ne.createElement("stop", { stopColor: yt[2] }), ne.createElement("stop", { offset: 1, stopColor: yt[3] }))));
      }, marble: it }, ut = { geometric: "beam", abstract: "bauhaus" }, dt = function(ct) {
        var bt = ct.variant, vt = bt === void 0 ? "marble" : bt, $t = ct.colors, xt = $t === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : $t, Ot = ct.name, At = Ot === void 0 ? "Clara Barton" : Ot, yt = ct.title, Bt = yt !== void 0 && yt, gt = ct.size, rt = ct.square, Ce = rt !== void 0 && rt, pe = J(ct, ["variant", "colors", "name", "title", "size", "square"]), nt = at[ut[vt] || vt] || it;
        return ie.a.createElement(nt, Object.assign({ colors: xt, name: At, title: Bt, size: gt, square: Ce }, pe));
      };
      V.default = dt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
var i$7 = Object.defineProperty, d$5 = (A, B, L) => B in A ? i$7(A, B, { enumerable: !0, configurable: !0, writable: !0, value: L }) : A[B] = L, r$4 = (A, B, L) => (d$5(A, typeof B != "symbol" ? B + "" : B, L), L);
let o$7 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(B) {
    this.current !== B && (this.handoffState = "pending", this.currentId = 0, this.current = B);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$a = new o$7(), l$5 = (A, B) => {
  s$a.isServer ? useEffect(A, B) : useLayoutEffect(A, B);
};
function s$9(A) {
  let B = useRef(A);
  return l$5(() => {
    B.current = A;
  }, [A]), B;
}
let o$6 = function(A) {
  let B = s$9(A);
  return C__default.useCallback((...L) => B.current(...L), [B]);
};
function t$7(A) {
  typeof queueMicrotask == "function" ? queueMicrotask(A) : Promise.resolve().then(A).catch((B) => setTimeout(() => {
    throw B;
  }));
}
function o$5() {
  let A = [], B = { addEventListener(L, K, V, W) {
    return L.addEventListener(K, V, W), B.add(() => L.removeEventListener(K, V, W));
  }, requestAnimationFrame(...L) {
    let K = requestAnimationFrame(...L);
    return B.add(() => cancelAnimationFrame(K));
  }, nextFrame(...L) {
    return B.requestAnimationFrame(() => B.requestAnimationFrame(...L));
  }, setTimeout(...L) {
    let K = setTimeout(...L);
    return B.add(() => clearTimeout(K));
  }, microTask(...L) {
    let K = { current: !0 };
    return t$7(() => {
      K.current && L[0]();
    }), B.add(() => {
      K.current = !1;
    });
  }, style(L, K, V) {
    let W = L.style.getPropertyValue(K);
    return Object.assign(L.style, { [K]: V }), this.add(() => {
      Object.assign(L.style, { [K]: W });
    });
  }, group(L) {
    let K = o$5();
    return L(K), this.add(() => K.dispose());
  }, add(L) {
    return A.push(L), () => {
      let K = A.indexOf(L);
      if (K >= 0) for (let V of A.splice(K, 1)) V();
    };
  }, dispose() {
    for (let L of A.splice(0)) L();
  } };
  return B;
}
function p$3() {
  let [A] = useState(o$5);
  return useEffect(() => () => A.dispose(), [A]), A;
}
function s$8() {
  let A = typeof document > "u";
  return "useSyncExternalStore" in C$2 ? ((B) => B.useSyncExternalStore)(C$2)(() => () => {
  }, () => !1, () => !A) : !1;
}
function l$4() {
  let A = s$8(), [B, L] = C$2.useState(s$a.isHandoffComplete);
  return B && s$a.isHandoffComplete === !1 && L(!1), C$2.useEffect(() => {
    B !== !0 && L(!0);
  }, [B]), C$2.useEffect(() => s$a.handoff(), []), A ? !1 : B;
}
var o$4;
let I$5 = (o$4 = C__default.useId) != null ? o$4 : function() {
  let A = l$4(), [B, L] = C__default.useState(A ? () => s$a.nextId() : null);
  return l$5(() => {
    B === null && L(s$a.nextId());
  }, [B]), B != null ? "" + B : void 0;
};
function u$7(A, B, ...L) {
  if (A in B) {
    let V = B[A];
    return typeof V == "function" ? V(...L) : V;
  }
  let K = new Error(`Tried to handle "${A}" but there is no handler defined. Only defined handlers are: ${Object.keys(B).map((V) => `"${V}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(K, u$7), K;
}
function o$3(A) {
  return s$a.isServer ? null : A instanceof Node ? A.ownerDocument : A != null && A.hasOwnProperty("current") && A.current instanceof Node ? A.current.ownerDocument : document;
}
let c$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((A) => `${A}:not([tabindex='-1'])`).join(",");
var M$2 = ((A) => (A[A.First = 1] = "First", A[A.Previous = 2] = "Previous", A[A.Next = 4] = "Next", A[A.Last = 8] = "Last", A[A.WrapAround = 16] = "WrapAround", A[A.NoScroll = 32] = "NoScroll", A))(M$2 || {}), N$2 = ((A) => (A[A.Error = 0] = "Error", A[A.Overflow = 1] = "Overflow", A[A.Success = 2] = "Success", A[A.Underflow = 3] = "Underflow", A))(N$2 || {}), F$3 = ((A) => (A[A.Previous = -1] = "Previous", A[A.Next = 1] = "Next", A))(F$3 || {});
function f$6(A = document.body) {
  return A == null ? [] : Array.from(A.querySelectorAll(c$5)).sort((B, L) => Math.sign((B.tabIndex || Number.MAX_SAFE_INTEGER) - (L.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T$2 = ((A) => (A[A.Strict = 0] = "Strict", A[A.Loose = 1] = "Loose", A))(T$2 || {});
function h$4(A, B = 0) {
  var L;
  return A === ((L = o$3(A)) == null ? void 0 : L.body) ? !1 : u$7(B, { 0() {
    return A.matches(c$5);
  }, 1() {
    let K = A;
    for (; K !== null; ) {
      if (K.matches(c$5)) return !0;
      K = K.parentElement;
    }
    return !1;
  } });
}
function D$3(A) {
  let B = o$3(A);
  o$5().nextFrame(() => {
    B && !h$4(B.activeElement, 0) && y$3(A);
  });
}
var w$2 = ((A) => (A[A.Keyboard = 0] = "Keyboard", A[A.Mouse = 1] = "Mouse", A))(w$2 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (A) => {
  A.metaKey || A.altKey || A.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (A) => {
  A.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : A.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function y$3(A) {
  A == null || A.focus({ preventScroll: !0 });
}
let S$5 = ["textarea", "input"].join(",");
function H(A) {
  var B, L;
  return (L = (B = A == null ? void 0 : A.matches) == null ? void 0 : B.call(A, S$5)) != null ? L : !1;
}
function I$4(A, B = (L) => L) {
  return A.slice().sort((L, K) => {
    let V = B(L), W = B(K);
    if (V === null || W === null) return 0;
    let J = V.compareDocumentPosition(W);
    return J & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : J & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _$2(A, B) {
  return O$1(f$6(), B, { relativeTo: A });
}
function O$1(A, B, { sorted: L = !0, relativeTo: K = null, skipElements: V = [] } = {}) {
  let W = Array.isArray(A) ? A.length > 0 ? A[0].ownerDocument : document : A.ownerDocument, J = Array.isArray(A) ? L ? I$4(A) : A : f$6(A);
  V.length > 0 && J.length > 1 && (J = J.filter((Oe) => !V.includes(Oe))), K = K ?? W.activeElement;
  let ne = (() => {
    if (B & 5) return 1;
    if (B & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ie = (() => {
    if (B & 1) return 0;
    if (B & 2) return Math.max(0, J.indexOf(K)) - 1;
    if (B & 4) return Math.max(0, J.indexOf(K)) + 1;
    if (B & 8) return J.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ce = B & 32 ? { preventScroll: !0 } : {}, re = 0, oe = J.length, ke;
  do {
    if (re >= oe || re + oe <= 0) return 0;
    let Oe = ie + re;
    if (B & 16) Oe = (Oe + oe) % oe;
    else {
      if (Oe < 0) return 3;
      if (Oe >= oe) return 1;
    }
    ke = J[Oe], ke == null || ke.focus(ce), re += ne;
  } while (ke !== W.activeElement);
  return B & 6 && H(ke) && ke.select(), 2;
}
function t$6() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$6() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$3() {
  return t$6() || i$6();
}
function d$4(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function V(W) {
      K.current(W);
    }
    return document.addEventListener(A, V, L), () => document.removeEventListener(A, V, L);
  }, [A, L]);
}
function s$7(A, B, L) {
  let K = s$9(B);
  useEffect(() => {
    function V(W) {
      K.current(W);
    }
    return window.addEventListener(A, V, L), () => window.removeEventListener(A, V, L);
  }, [A, L]);
}
function y$2(A, B, L = !0) {
  let K = useRef(!1);
  useEffect(() => {
    requestAnimationFrame(() => {
      K.current = L;
    });
  }, [L]);
  function V(J, ne) {
    if (!K.current || J.defaultPrevented) return;
    let ie = ne(J);
    if (ie === null || !ie.getRootNode().contains(ie) || !ie.isConnected) return;
    let ce = function re(oe) {
      return typeof oe == "function" ? re(oe()) : Array.isArray(oe) || oe instanceof Set ? oe : [oe];
    }(A);
    for (let re of ce) {
      if (re === null) continue;
      let oe = re instanceof HTMLElement ? re : re.current;
      if (oe != null && oe.contains(ie) || J.composed && J.composedPath().includes(oe)) return;
    }
    return !h$4(ie, T$2.Loose) && ie.tabIndex !== -1 && J.preventDefault(), B(J, ie);
  }
  let W = useRef(null);
  d$4("pointerdown", (J) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = J.composedPath) == null ? void 0 : ne.call(J)) == null ? void 0 : ie[0]) || J.target);
  }, !0), d$4("mousedown", (J) => {
    var ne, ie;
    K.current && (W.current = ((ie = (ne = J.composedPath) == null ? void 0 : ne.call(J)) == null ? void 0 : ie[0]) || J.target);
  }, !0), d$4("click", (J) => {
    n$3() || W.current && (V(J, () => W.current), W.current = null);
  }, !0), d$4("touchend", (J) => V(J, () => J.target instanceof HTMLElement ? J.target : null), !0), s$7("blur", (J) => V(J, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$2(...A) {
  return useMemo(() => o$3(...A), [...A]);
}
function i$5(A) {
  var B;
  if (A.type) return A.type;
  let L = (B = A.as) != null ? B : "button";
  if (typeof L == "string" && L.toLowerCase() === "button") return "button";
}
function T$1(A, B) {
  let [L, K] = useState(() => i$5(A));
  return l$5(() => {
    K(i$5(A));
  }, [A.type, A.as]), l$5(() => {
    L || B.current && B.current instanceof HTMLButtonElement && !B.current.hasAttribute("type") && K("button");
  }, [L, B]), L;
}
let u$6 = Symbol();
function T(A, B = !0) {
  return Object.assign(A, { [u$6]: B });
}
function y$1(...A) {
  let B = useRef(A);
  useEffect(() => {
    B.current = A;
  }, [A]);
  let L = o$6((K) => {
    for (let V of B.current) V != null && (typeof V == "function" ? V(K) : V.current = K);
  });
  return A.every((K) => K == null || (K == null ? void 0 : K[u$6])) ? void 0 : L;
}
function t$5(A) {
  return [A.screenX, A.screenY];
}
function u$5() {
  let A = useRef([-1, -1]);
  return { wasMoved(B) {
    let L = t$5(B);
    return A.current[0] === L[0] && A.current[1] === L[1] ? !1 : (A.current = L, !0);
  }, update(B) {
    A.current = t$5(B);
  } };
}
function F$2({ container: A, accept: B, walk: L, enabled: K = !0 }) {
  let V = useRef(B), W = useRef(L);
  useEffect(() => {
    V.current = B, W.current = L;
  }, [B, L]), l$5(() => {
    if (!A || !K) return;
    let J = o$3(A);
    if (!J) return;
    let ne = V.current, ie = W.current, ce = Object.assign((oe) => ne(oe), { acceptNode: ne }), re = J.createTreeWalker(A, NodeFilter.SHOW_ELEMENT, ce, !1);
    for (; re.nextNode(); ) ie(re.currentNode);
  }, [A, K, V, W]);
}
function m$2(A, B) {
  let L = useRef([]), K = o$6(A);
  useEffect(() => {
    let V = [...L.current];
    for (let [W, J] of B.entries()) if (L.current[W] !== J) {
      let ne = K(B, V);
      return L.current = B, ne;
    }
  }, [K, ...B]);
}
function t$4(...A) {
  return Array.from(new Set(A.flatMap((B) => typeof B == "string" ? B.split(" ") : []))).filter(Boolean).join(" ");
}
var O = ((A) => (A[A.None = 0] = "None", A[A.RenderStrategy = 1] = "RenderStrategy", A[A.Static = 2] = "Static", A))(O || {}), v$1 = ((A) => (A[A.Unmount = 0] = "Unmount", A[A.Hidden = 1] = "Hidden", A))(v$1 || {});
function C$1({ ourProps: A, theirProps: B, slot: L, defaultTag: K, features: V, visible: W = !0, name: J, mergeRefs: ne }) {
  ne = ne ?? k$1;
  let ie = R(B, A);
  if (W) return m$1(ie, L, K, J, ne);
  let ce = V ?? 0;
  if (ce & 2) {
    let { static: re = !1, ...oe } = ie;
    if (re) return m$1(oe, L, K, J, ne);
  }
  if (ce & 1) {
    let { unmount: re = !0, ...oe } = ie;
    return u$7(re ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return m$1({ ...oe, hidden: !0, style: { display: "none" } }, L, K, J, ne);
    } });
  }
  return m$1(ie, L, K, J, ne);
}
function m$1(A, B = {}, L, K, V) {
  let { as: W = L, children: J, refName: ne = "ref", ...ie } = F$1(A, ["unmount", "static"]), ce = A.ref !== void 0 ? { [ne]: A.ref } : {}, re = typeof J == "function" ? J(B) : J;
  "className" in ie && ie.className && typeof ie.className == "function" && (ie.className = ie.className(B));
  let oe = {};
  if (B) {
    let ke = !1, Oe = [];
    for (let [it, at] of Object.entries(B)) typeof at == "boolean" && (ke = !0), at === !0 && Oe.push(it);
    ke && (oe["data-headlessui-state"] = Oe.join(" "));
  }
  if (W === Fragment && Object.keys(x$2(ie)).length > 0) {
    if (!isValidElement(re) || Array.isArray(re) && re.length > 1) throw new Error(['Passing props on "Fragment"!', "", `The current component <${K} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(ie).map((at) => `  - ${at}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((at) => `  - ${at}`).join(`
`)].join(`
`));
    let ke = re.props, Oe = typeof (ke == null ? void 0 : ke.className) == "function" ? (...at) => t$4(ke == null ? void 0 : ke.className(...at), ie.className) : t$4(ke == null ? void 0 : ke.className, ie.className), it = Oe ? { className: Oe } : {};
    return cloneElement(re, Object.assign({}, R(re.props, x$2(F$1(ie, ["ref"]))), oe, ce, { ref: V(re.ref, ce.ref) }, it));
  }
  return createElement(W, Object.assign({}, F$1(ie, ["ref"]), W !== Fragment && ce, W !== Fragment && oe), re);
}
function k$1(...A) {
  return A.every((B) => B == null) ? void 0 : (B) => {
    for (let L of A) L != null && (typeof L == "function" ? L(B) : L.current = B);
  };
}
function R(...A) {
  if (A.length === 0) return {};
  if (A.length === 1) return A[0];
  let B = {}, L = {};
  for (let K of A) for (let V in K) V.startsWith("on") && typeof K[V] == "function" ? (L[V] != null || (L[V] = []), L[V].push(K[V])) : B[V] = K[V];
  if (B.disabled || B["aria-disabled"]) return Object.assign(B, Object.fromEntries(Object.keys(L).map((K) => [K, void 0])));
  for (let K in L) Object.assign(B, { [K](V, ...W) {
    let J = L[K];
    for (let ne of J) {
      if ((V instanceof Event || (V == null ? void 0 : V.nativeEvent) instanceof Event) && V.defaultPrevented) return;
      ne(V, ...W);
    }
  } });
  return B;
}
function U$3(A) {
  var B;
  return Object.assign(forwardRef(A), { displayName: (B = A.displayName) != null ? B : A.name });
}
function x$2(A) {
  let B = Object.assign({}, A);
  for (let L in B) B[L] === void 0 && delete B[L];
  return B;
}
function F$1(A, B = []) {
  let L = Object.assign({}, A);
  for (let K of B) K in L && delete L[K];
  return L;
}
let p$2 = "div";
var s$6 = ((A) => (A[A.None = 1] = "None", A[A.Focusable = 2] = "Focusable", A[A.Hidden = 4] = "Hidden", A))(s$6 || {});
function l$3(A, B) {
  var L;
  let { features: K = 1, ...V } = A, W = { ref: B, "aria-hidden": (K & 2) === 2 ? !0 : (L = V["aria-hidden"]) != null ? L : void 0, hidden: (K & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(K & 4) === 4 && (K & 2) !== 2 && { display: "none" } } };
  return C$1({ ourProps: W, theirProps: V, slot: {}, defaultTag: p$2, name: "Hidden" });
}
let u$4 = U$3(l$3), n$1 = createContext(null);
n$1.displayName = "OpenClosedContext";
var d$3 = ((A) => (A[A.Open = 1] = "Open", A[A.Closed = 2] = "Closed", A[A.Closing = 4] = "Closing", A[A.Opening = 8] = "Opening", A))(d$3 || {});
function u$3() {
  return useContext(n$1);
}
function s$5({ value: A, children: B }) {
  return C__default.createElement(n$1.Provider, { value: A }, B);
}
function t$3(A) {
  function B() {
    document.readyState !== "loading" && (A(), document.removeEventListener("DOMContentLoaded", B));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", B), B());
}
let t$2 = [];
t$3(() => {
  function A(B) {
    B.target instanceof HTMLElement && B.target !== document.body && t$2[0] !== B.target && (t$2.unshift(B.target), t$2 = t$2.filter((L) => L != null && L.isConnected), t$2.splice(10));
  }
  window.addEventListener("click", A, { capture: !0 }), window.addEventListener("mousedown", A, { capture: !0 }), window.addEventListener("focus", A, { capture: !0 }), document.body.addEventListener("click", A, { capture: !0 }), document.body.addEventListener("mousedown", A, { capture: !0 }), document.body.addEventListener("focus", A, { capture: !0 });
});
function r$3(A) {
  let B = A.parentElement, L = null;
  for (; B && !(B instanceof HTMLFieldSetElement); ) B instanceof HTMLLegendElement && (L = B), B = B.parentElement;
  let K = (B == null ? void 0 : B.getAttribute("disabled")) === "";
  return K && i$4(L) ? !1 : K;
}
function i$4(A) {
  if (!A) return !1;
  let B = A.previousElementSibling;
  for (; B !== null; ) {
    if (B instanceof HTMLLegendElement) return !1;
    B = B.previousElementSibling;
  }
  return !0;
}
function u$2(A) {
  throw new Error("Unexpected object: " + A);
}
var c$4 = ((A) => (A[A.First = 0] = "First", A[A.Previous = 1] = "Previous", A[A.Next = 2] = "Next", A[A.Last = 3] = "Last", A[A.Specific = 4] = "Specific", A[A.Nothing = 5] = "Nothing", A))(c$4 || {});
function f$5(A, B) {
  let L = B.resolveItems();
  if (L.length <= 0) return null;
  let K = B.resolveActiveIndex(), V = K ?? -1;
  switch (A.focus) {
    case 0: {
      for (let W = 0; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 1: {
      for (let W = V - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 2: {
      for (let W = V + 1; W < L.length; ++W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 3: {
      for (let W = L.length - 1; W >= 0; --W) if (!B.resolveDisabled(L[W], W, L)) return W;
      return K;
    }
    case 4: {
      for (let W = 0; W < L.length; ++W) if (B.resolveId(L[W], W, L) === A.id) return W;
      return K;
    }
    case 5:
      return null;
    default:
      u$2(A);
  }
}
var o$2 = ((A) => (A.Space = " ", A.Enter = "Enter", A.Escape = "Escape", A.Backspace = "Backspace", A.Delete = "Delete", A.ArrowLeft = "ArrowLeft", A.ArrowUp = "ArrowUp", A.ArrowRight = "ArrowRight", A.ArrowDown = "ArrowDown", A.Home = "Home", A.End = "End", A.PageUp = "PageUp", A.PageDown = "PageDown", A.Tab = "Tab", A))(o$2 || {});
function E(A, B, L, K) {
  let V = s$9(L);
  useEffect(() => {
    A = A ?? window;
    function W(J) {
      V.current(J);
    }
    return A.addEventListener(B, W, K), () => A.removeEventListener(B, W, K);
  }, [A, B, K]);
}
function f$4() {
  let A = useRef(!1);
  return l$5(() => (A.current = !0, () => {
    A.current = !1;
  }), []), A;
}
function c$3(A) {
  let B = o$6(A), L = useRef(!1);
  useEffect(() => (L.current = !1, () => {
    L.current = !0, t$7(() => {
      L.current && B();
    });
  }), [B]);
}
var s$4 = ((A) => (A[A.Forwards = 0] = "Forwards", A[A.Backwards = 1] = "Backwards", A))(s$4 || {});
function n() {
  let A = useRef(0);
  return s$7("keydown", (B) => {
    B.key === "Tab" && (A.current = B.shiftKey ? 1 : 0);
  }, !0), A;
}
function P(A) {
  if (!A) return /* @__PURE__ */ new Set();
  if (typeof A == "function") return new Set(A());
  let B = /* @__PURE__ */ new Set();
  for (let L of A.current) L.current instanceof HTMLElement && B.add(L.current);
  return B;
}
let X = "div";
var _$1 = ((A) => (A[A.None = 1] = "None", A[A.InitialFocus = 2] = "InitialFocus", A[A.TabLock = 4] = "TabLock", A[A.FocusLock = 8] = "FocusLock", A[A.RestoreFocus = 16] = "RestoreFocus", A[A.All = 30] = "All", A))(_$1 || {});
function z(A, B) {
  let L = useRef(null), K = y$1(L, B), { initialFocus: V, containers: W, features: J = 30, ...ne } = A;
  l$4() || (J = 1);
  let ie = n$2(L);
  Y({ ownerDocument: ie }, !!(J & 16));
  let ce = Z({ ownerDocument: ie, container: L, initialFocus: V }, !!(J & 2));
  $({ ownerDocument: ie, container: L, containers: W, previousActiveElement: ce }, !!(J & 8));
  let re = n(), oe = o$6((at) => {
    let ut = L.current;
    ut && ((dt) => dt())(() => {
      u$7(re.current, { [s$4.Forwards]: () => {
        O$1(ut, M$2.First, { skipElements: [at.relatedTarget] });
      }, [s$4.Backwards]: () => {
        O$1(ut, M$2.Last, { skipElements: [at.relatedTarget] });
      } });
    });
  }), ke = p$3(), Oe = useRef(!1), it = { ref: K, onKeyDown(at) {
    at.key == "Tab" && (Oe.current = !0, ke.requestAnimationFrame(() => {
      Oe.current = !1;
    }));
  }, onBlur(at) {
    let ut = P(W);
    L.current instanceof HTMLElement && ut.add(L.current);
    let dt = at.relatedTarget;
    dt instanceof HTMLElement && dt.dataset.headlessuiFocusGuard !== "true" && (S$4(ut, dt) || (Oe.current ? O$1(L.current, u$7(re.current, { [s$4.Forwards]: () => M$2.Next, [s$4.Backwards]: () => M$2.Previous }) | M$2.WrapAround, { relativeTo: at.target }) : at.target instanceof HTMLElement && y$3(at.target)));
  } };
  return C__default.createElement(C__default.Fragment, null, !!(J & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: oe, features: s$6.Focusable }), C$1({ ourProps: it, theirProps: ne, defaultTag: X, name: "FocusTrap" }), !!(J & 4) && C__default.createElement(u$4, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: oe, features: s$6.Focusable }));
}
let D$2 = U$3(z), de$1 = Object.assign(D$2, { features: _$1 });
function Q(A = !0) {
  let B = useRef(t$2.slice());
  return m$2(([L], [K]) => {
    K === !0 && L === !1 && t$7(() => {
      B.current.splice(0);
    }), K === !1 && L === !0 && (B.current = t$2.slice());
  }, [A, t$2, B]), o$6(() => {
    var L;
    return (L = B.current.find((K) => K != null && K.isConnected)) != null ? L : null;
  });
}
function Y({ ownerDocument: A }, B) {
  let L = Q(B);
  m$2(() => {
    B || (A == null ? void 0 : A.activeElement) === (A == null ? void 0 : A.body) && y$3(L());
  }, [B]), c$3(() => {
    B && y$3(L());
  });
}
function Z({ ownerDocument: A, container: B, initialFocus: L }, K) {
  let V = useRef(null), W = f$4();
  return m$2(() => {
    if (!K) return;
    let J = B.current;
    J && t$7(() => {
      if (!W.current) return;
      let ne = A == null ? void 0 : A.activeElement;
      if (L != null && L.current) {
        if ((L == null ? void 0 : L.current) === ne) {
          V.current = ne;
          return;
        }
      } else if (J.contains(ne)) {
        V.current = ne;
        return;
      }
      L != null && L.current ? y$3(L.current) : O$1(J, M$2.First) === N$2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), V.current = A == null ? void 0 : A.activeElement;
    });
  }, [K]), V;
}
function $({ ownerDocument: A, container: B, containers: L, previousActiveElement: K }, V) {
  let W = f$4();
  E(A == null ? void 0 : A.defaultView, "focus", (J) => {
    if (!V || !W.current) return;
    let ne = P(L);
    B.current instanceof HTMLElement && ne.add(B.current);
    let ie = K.current;
    if (!ie) return;
    let ce = J.target;
    ce && ce instanceof HTMLElement ? S$4(ne, ce) ? (K.current = ce, y$3(ce)) : (J.preventDefault(), J.stopPropagation(), y$3(ie)) : y$3(K.current);
  }, !0);
}
function S$4(A, B) {
  for (let L of A) if (L.contains(B)) return !0;
  return !1;
}
let e = createContext(!1);
function a$5() {
  return useContext(e);
}
function l$2(A) {
  return C__default.createElement(e.Provider, { value: A.force }, A.children);
}
function F(A) {
  let B = a$5(), L = useContext(_), K = n$2(A), [V, W] = useState(() => {
    if (!B && L !== null || s$a.isServer) return null;
    let J = K == null ? void 0 : K.getElementById("headlessui-portal-root");
    if (J) return J;
    if (K === null) return null;
    let ne = K.createElement("div");
    return ne.setAttribute("id", "headlessui-portal-root"), K.body.appendChild(ne);
  });
  return useEffect(() => {
    V !== null && (K != null && K.body.contains(V) || K == null || K.body.appendChild(V));
  }, [V, K]), useEffect(() => {
    B || L !== null && W(L.current);
  }, [L, W, B]), V;
}
let U$2 = Fragment;
function N$1(A, B) {
  let L = A, K = useRef(null), V = y$1(T((re) => {
    K.current = re;
  }), B), W = n$2(K), J = F(K), [ne] = useState(() => {
    var re;
    return s$a.isServer ? null : (re = W == null ? void 0 : W.createElement("div")) != null ? re : null;
  }), ie = useContext(f$3), ce = l$4();
  return l$5(() => {
    !J || !ne || J.contains(ne) || (ne.setAttribute("data-headlessui-portal", ""), J.appendChild(ne));
  }, [J, ne]), l$5(() => {
    if (ne && ie) return ie.register(ne);
  }, [ie, ne]), c$3(() => {
    var re;
    !J || !ne || (ne instanceof Node && J.contains(ne) && J.removeChild(ne), J.childNodes.length <= 0 && ((re = J.parentElement) == null || re.removeChild(J)));
  }), ce ? !J || !ne ? null : createPortal(C$1({ ourProps: { ref: V }, theirProps: L, defaultTag: U$2, name: "Portal" }), ne) : null;
}
let S$3 = Fragment, _ = createContext(null);
function j(A, B) {
  let { target: L, ...K } = A, V = { ref: y$1(B) };
  return C__default.createElement(_.Provider, { value: L }, C$1({ ourProps: V, theirProps: K, defaultTag: S$3, name: "Popover.Group" }));
}
let f$3 = createContext(null);
function ee() {
  let A = useContext(f$3), B = useRef([]), L = o$6((W) => (B.current.push(W), A && A.register(W), () => K(W))), K = o$6((W) => {
    let J = B.current.indexOf(W);
    J !== -1 && B.current.splice(J, 1), A && A.unregister(W);
  }), V = useMemo(() => ({ register: L, unregister: K, portals: B }), [L, K, B]);
  return [B, useMemo(() => function({ children: W }) {
    return C__default.createElement(f$3.Provider, { value: V }, W);
  }, [V])];
}
let D$1 = U$3(N$1), I$3 = U$3(j), te = Object.assign(D$1, { Group: I$3 });
function i$3(A, B) {
  return A === B && (A !== 0 || 1 / A === 1 / B) || A !== A && B !== B;
}
const d$2 = typeof Object.is == "function" ? Object.is : i$3, { useState: u$1, useEffect: h$3, useLayoutEffect: f$2, useDebugValue: p$1 } = C$2;
function y(A, B, L) {
  const K = B(), [{ inst: V }, W] = u$1({ inst: { value: K, getSnapshot: B } });
  return f$2(() => {
    V.value = K, V.getSnapshot = B, r$2(V) && W({ inst: V });
  }, [A, K, B]), h$3(() => (r$2(V) && W({ inst: V }), A(() => {
    r$2(V) && W({ inst: V });
  })), [A]), p$1(K), K;
}
function r$2(A) {
  const B = A.getSnapshot, L = A.value;
  try {
    const K = B();
    return !d$2(L, K);
  } catch {
    return !0;
  }
}
function t$1(A, B, L) {
  return B();
}
const r$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", s$3 = !r$1, c$2 = s$3 ? t$1 : y, a$4 = "useSyncExternalStore" in C$2 ? ((A) => A.useSyncExternalStore)(C$2) : c$2;
function S$2(A) {
  return a$4(A.subscribe, A.getSnapshot, A.getSnapshot);
}
function a$3(A, B) {
  let L = A(), K = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return L;
  }, subscribe(V) {
    return K.add(V), () => K.delete(V);
  }, dispatch(V, ...W) {
    let J = B[V].call(L, ...W);
    J && (L = J, K.forEach((ne) => ne()));
  } };
}
function c$1() {
  let A;
  return { before({ doc: B }) {
    var L;
    let K = B.documentElement;
    A = ((L = B.defaultView) != null ? L : window).innerWidth - K.clientWidth;
  }, after({ doc: B, d: L }) {
    let K = B.documentElement, V = K.clientWidth - K.offsetWidth, W = A - V;
    L.style(K, "paddingRight", `${W}px`);
  } };
}
function d$1() {
  return t$6() ? { before({ doc: A, d: B, meta: L }) {
    function K(V) {
      return L.containers.flatMap((W) => W()).some((W) => W.contains(V));
    }
    B.microTask(() => {
      var V;
      if (window.getComputedStyle(A.documentElement).scrollBehavior !== "auto") {
        let ne = o$5();
        ne.style(A.documentElement, "scrollBehavior", "auto"), B.add(() => B.microTask(() => ne.dispose()));
      }
      let W = (V = window.scrollY) != null ? V : window.pageYOffset, J = null;
      B.addEventListener(A, "click", (ne) => {
        if (ne.target instanceof HTMLElement) try {
          let ie = ne.target.closest("a");
          if (!ie) return;
          let { hash: ce } = new URL(ie.href), re = A.querySelector(ce);
          re && !K(re) && (J = re);
        } catch {
        }
      }, !0), B.addEventListener(A, "touchstart", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && K(ie.parentElement); ) ie = ie.parentElement;
          B.style(ie, "overscrollBehavior", "contain");
        } else B.style(ne.target, "touchAction", "none");
      }), B.addEventListener(A, "touchmove", (ne) => {
        if (ne.target instanceof HTMLElement) if (K(ne.target)) {
          let ie = ne.target;
          for (; ie.parentElement && ie.dataset.headlessuiPortal !== "" && !(ie.scrollHeight > ie.clientHeight || ie.scrollWidth > ie.clientWidth); ) ie = ie.parentElement;
          ie.dataset.headlessuiPortal === "" && ne.preventDefault();
        } else ne.preventDefault();
      }, { passive: !1 }), B.add(() => {
        var ne;
        let ie = (ne = window.scrollY) != null ? ne : window.pageYOffset;
        W !== ie && window.scrollTo(0, W), J && J.isConnected && (J.scrollIntoView({ block: "nearest" }), J = null);
      });
    });
  } } : {};
}
function l$1() {
  return { before({ doc: A, d: B }) {
    B.style(A.documentElement, "overflow", "hidden");
  } };
}
function m(A) {
  let B = {};
  for (let L of A) Object.assign(B, L(B));
  return B;
}
let a$2 = a$3(() => /* @__PURE__ */ new Map(), { PUSH(A, B) {
  var L;
  let K = (L = this.get(A)) != null ? L : { doc: A, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return K.count++, K.meta.add(B), this.set(A, K), this;
}, POP(A, B) {
  let L = this.get(A);
  return L && (L.count--, L.meta.delete(B)), this;
}, SCROLL_PREVENT({ doc: A, d: B, meta: L }) {
  let K = { doc: A, d: B, meta: m(L) }, V = [d$1(), c$1(), l$1()];
  V.forEach(({ before: W }) => W == null ? void 0 : W(K)), V.forEach(({ after: W }) => W == null ? void 0 : W(K));
}, SCROLL_ALLOW({ d: A }) {
  A.dispose();
}, TEARDOWN({ doc: A }) {
  this.delete(A);
} });
a$2.subscribe(() => {
  let A = a$2.getSnapshot(), B = /* @__PURE__ */ new Map();
  for (let [L] of A) B.set(L, L.documentElement.style.overflow);
  for (let L of A.values()) {
    let K = B.get(L.doc) === "hidden", V = L.count !== 0;
    (V && !K || !V && K) && a$2.dispatch(L.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", L), L.count === 0 && a$2.dispatch("TEARDOWN", L);
  }
});
function p(A, B, L) {
  let K = S$2(a$2), V = A ? K.get(A) : void 0, W = V ? V.count > 0 : !1;
  return l$5(() => {
    if (!(!A || !B)) return a$2.dispatch("PUSH", A, L), () => a$2.dispatch("POP", A, L);
  }, [B, A]), W;
}
let u = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map();
function b$3(A, B = !0) {
  l$5(() => {
    var L;
    if (!B) return;
    let K = typeof A == "function" ? A() : A.current;
    if (!K) return;
    function V() {
      var J;
      if (!K) return;
      let ne = (J = t.get(K)) != null ? J : 1;
      if (ne === 1 ? t.delete(K) : t.set(K, ne - 1), ne !== 1) return;
      let ie = u.get(K);
      ie && (ie["aria-hidden"] === null ? K.removeAttribute("aria-hidden") : K.setAttribute("aria-hidden", ie["aria-hidden"]), K.inert = ie.inert, u.delete(K));
    }
    let W = (L = t.get(K)) != null ? L : 0;
    return t.set(K, W + 1), W !== 0 || (u.set(K, { "aria-hidden": K.getAttribute("aria-hidden"), inert: K.inert }), K.setAttribute("aria-hidden", "true"), K.inert = !0), V;
  }, [A, B]);
}
function N({ defaultContainers: A = [], portals: B, mainTreeNodeRef: L } = {}) {
  var K;
  let V = useRef((K = L == null ? void 0 : L.current) != null ? K : null), W = n$2(V), J = o$6(() => {
    var ne, ie, ce;
    let re = [];
    for (let oe of A) oe !== null && (oe instanceof HTMLElement ? re.push(oe) : "current" in oe && oe.current instanceof HTMLElement && re.push(oe.current));
    if (B != null && B.current) for (let oe of B.current) re.push(oe);
    for (let oe of (ne = W == null ? void 0 : W.querySelectorAll("html > *, body > *")) != null ? ne : []) oe !== document.body && oe !== document.head && oe instanceof HTMLElement && oe.id !== "headlessui-portal-root" && (oe.contains(V.current) || oe.contains((ce = (ie = V.current) == null ? void 0 : ie.getRootNode()) == null ? void 0 : ce.host) || re.some((ke) => oe.contains(ke)) || re.push(oe));
    return re;
  });
  return { resolveContainers: J, contains: o$6((ne) => J().some((ie) => ie.contains(ne))), mainTreeNodeRef: V, MainTreeNode: useMemo(() => function() {
    return L != null ? null : C__default.createElement(u$4, { features: s$6.Hidden, ref: V });
  }, [V, L]) };
}
let a$1 = createContext(() => {
});
a$1.displayName = "StackContext";
var s$2 = ((A) => (A[A.Add = 0] = "Add", A[A.Remove = 1] = "Remove", A))(s$2 || {});
function x$1() {
  return useContext(a$1);
}
function b$2({ children: A, onUpdate: B, type: L, element: K, enabled: V }) {
  let W = x$1(), J = o$6((...ne) => {
    B == null || B(...ne), W(...ne);
  });
  return l$5(() => {
    let ne = V === void 0 || V === !0;
    return ne && J(0, L, K), () => {
      ne && J(1, L, K);
    };
  }, [J, L, K, V]), C__default.createElement(a$1.Provider, { value: J }, A);
}
let d = createContext(null);
function f$1() {
  let A = useContext(d);
  if (A === null) {
    let B = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(B, f$1), B;
  }
  return A;
}
function w$1() {
  let [A, B] = useState([]);
  return [A.length > 0 ? A.join(" ") : void 0, useMemo(() => function(L) {
    let K = o$6((W) => (B((J) => [...J, W]), () => B((J) => {
      let ne = J.slice(), ie = ne.indexOf(W);
      return ie !== -1 && ne.splice(ie, 1), ne;
    }))), V = useMemo(() => ({ register: K, slot: L.slot, name: L.name, props: L.props }), [K, L.slot, L.name, L.props]);
    return C__default.createElement(d.Provider, { value: V }, L.children);
  }, [B])];
}
let I$2 = "p";
function S$1(A, B) {
  let L = I$5(), { id: K = `headlessui-description-${L}`, ...V } = A, W = f$1(), J = y$1(B);
  l$5(() => W.register(K), [K, W.register]);
  let ne = { ref: J, ...W.props, id: K };
  return C$1({ ourProps: ne, theirProps: V, slot: W.slot || {}, defaultTag: I$2, name: W.name || "Description" });
}
let h$2 = U$3(S$1), G = Object.assign(h$2, {});
var Me$1 = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(Me$1 || {}), we = ((A) => (A[A.SetTitleId = 0] = "SetTitleId", A))(we || {});
let He$1 = { 0(A, B) {
  return A.titleId === B.id ? A : { ...A, titleId: B.id };
} }, I$1 = createContext(null);
I$1.displayName = "DialogContext";
function b$1(A) {
  let B = useContext(I$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, b$1), L;
  }
  return B;
}
function Be(A, B, L = () => [document.body]) {
  p(A, B, (K) => {
    var V;
    return { containers: [...(V = K.containers) != null ? V : [], L] };
  });
}
function Ge(A, B) {
  return u$7(B.type, He$1, A, B);
}
let Ne$1 = "div", Ue = O.RenderStrategy | O.Static;
function We(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-${L}`, open: V, onClose: W, initialFocus: J, role: ne = "dialog", __demoMode: ie = !1, ...ce } = A, [re, oe] = useState(0), ke = useRef(!1);
  ne = function() {
    return ne === "dialog" || ne === "alertdialog" ? ne : (ke.current || (ke.current = !0, console.warn(`Invalid role [${ne}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Oe = u$3();
  V === void 0 && Oe !== null && (V = (Oe & d$3.Open) === d$3.Open);
  let it = useRef(null), at = y$1(it, B), ut = n$2(it), dt = A.hasOwnProperty("open") || Oe !== null, ct = A.hasOwnProperty("onClose");
  if (!dt && !ct) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!dt) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!ct) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof V != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${V}`);
  if (typeof W != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${W}`);
  let bt = V ? 0 : 1, [vt, $t] = useReducer(Ge, { titleId: null, descriptionId: null, panelRef: createRef() }), xt = o$6(() => W(!1)), Ot = o$6((It) => $t({ type: 0, id: It })), At = l$4() ? ie ? !1 : bt === 0 : !1, yt = re > 1, Bt = useContext(I$1) !== null, [gt, rt] = ee(), Ce = { get current() {
    var It;
    return (It = vt.panelRef.current) != null ? It : it.current;
  } }, { resolveContainers: pe, mainTreeNodeRef: nt, MainTreeNode: st } = N({ portals: gt, defaultContainers: [Ce] }), ot = yt ? "parent" : "leaf", ht = Oe !== null ? (Oe & d$3.Closing) === d$3.Closing : !1, pt = Bt || ht ? !1 : At, ft = useCallback(() => {
    var It, Rt;
    return (Rt = Array.from((It = ut == null ? void 0 : ut.querySelectorAll("body > *")) != null ? It : []).find((jt) => jt.id === "headlessui-portal-root" ? !1 : jt.contains(nt.current) && jt instanceof HTMLElement)) != null ? Rt : null;
  }, [nt]);
  b$3(ft, pt);
  let mt = yt ? !0 : At, lt = useCallback(() => {
    var It, Rt;
    return (Rt = Array.from((It = ut == null ? void 0 : ut.querySelectorAll("[data-headlessui-portal]")) != null ? It : []).find((jt) => jt.contains(nt.current) && jt instanceof HTMLElement)) != null ? Rt : null;
  }, [nt]);
  b$3(lt, mt), y$2(pe, (It) => {
    It.preventDefault(), xt();
  }, !(!At || yt));
  let Ft = !(yt || bt !== 0);
  E(ut == null ? void 0 : ut.defaultView, "keydown", (It) => {
    Ft && (It.defaultPrevented || It.key === o$2.Escape && (It.preventDefault(), It.stopPropagation(), xt()));
  }), Be(ut, !(ht || bt !== 0 || Bt), pe), useEffect(() => {
    if (bt !== 0 || !it.current) return;
    let It = new ResizeObserver((Rt) => {
      for (let jt of Rt) {
        let Jt = jt.target.getBoundingClientRect();
        Jt.x === 0 && Jt.y === 0 && Jt.width === 0 && Jt.height === 0 && xt();
      }
    });
    return It.observe(it.current), () => It.disconnect();
  }, [bt, it, xt]);
  let [qt, Pt] = w$1(), Tt = useMemo(() => [{ dialogState: bt, close: xt, setTitleId: Ot }, vt], [bt, vt, xt, Ot]), Ut = useMemo(() => ({ open: bt === 0 }), [bt]), Wt = { ref: at, id: K, role: ne, "aria-modal": bt === 0 ? !0 : void 0, "aria-labelledby": vt.titleId, "aria-describedby": qt };
  return C__default.createElement(b$2, { type: "Dialog", enabled: bt === 0, element: it, onUpdate: o$6((It, Rt) => {
    Rt === "Dialog" && u$7(It, { [s$2.Add]: () => oe((jt) => jt + 1), [s$2.Remove]: () => oe((jt) => jt - 1) });
  }) }, C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C__default.createElement(I$1.Provider, { value: Tt }, C__default.createElement(te.Group, { target: it }, C__default.createElement(l$2, { force: !1 }, C__default.createElement(Pt, { slot: Ut, name: "Dialog.Description" }, C__default.createElement(de$1, { initialFocus: J, containers: pe, features: At ? u$7(ot, { parent: de$1.features.RestoreFocus, leaf: de$1.features.All & ~de$1.features.FocusLock }) : de$1.features.None }, C__default.createElement(rt, null, C$1({ ourProps: Wt, theirProps: ce, slot: Ut, defaultTag: Ne$1, features: Ue, visible: bt === 0, name: "Dialog" }))))))))), C__default.createElement(st, null));
}
let $e = "div";
function Ye(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-overlay-${L}`, ...V } = A, [{ dialogState: W, close: J }] = b$1("Dialog.Overlay"), ne = y$1(B), ie = o$6((re) => {
    if (re.target === re.currentTarget) {
      if (r$3(re.currentTarget)) return re.preventDefault();
      re.preventDefault(), re.stopPropagation(), J();
    }
  }), ce = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0, onClick: ie }, theirProps: V, slot: ce, defaultTag: $e, name: "Dialog.Overlay" });
}
let je = "div";
function Je(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-backdrop-${L}`, ...V } = A, [{ dialogState: W }, J] = b$1("Dialog.Backdrop"), ne = y$1(B);
  useEffect(() => {
    if (J.panelRef.current === null) throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [J.panelRef]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C__default.createElement(l$2, { force: !0 }, C__default.createElement(te, null, C$1({ ourProps: { ref: ne, id: K, "aria-hidden": !0 }, theirProps: V, slot: ie, defaultTag: je, name: "Dialog.Backdrop" })));
}
let Xe = "div";
function Ke(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-panel-${L}`, ...V } = A, [{ dialogState: W }, J] = b$1("Dialog.Panel"), ne = y$1(B, J.panelRef), ie = useMemo(() => ({ open: W === 0 }), [W]), ce = o$6((re) => {
    re.stopPropagation();
  });
  return C$1({ ourProps: { ref: ne, id: K, onClick: ce }, theirProps: V, slot: ie, defaultTag: Xe, name: "Dialog.Panel" });
}
let Ve = "h2";
function qe$2(A, B) {
  let L = I$5(), { id: K = `headlessui-dialog-title-${L}`, ...V } = A, [{ dialogState: W, setTitleId: J }] = b$1("Dialog.Title"), ne = y$1(B);
  useEffect(() => (J(K), () => J(null)), [K, J]);
  let ie = useMemo(() => ({ open: W === 0 }), [W]);
  return C$1({ ourProps: { ref: ne, id: K }, theirProps: V, slot: ie, defaultTag: Ve, name: "Dialog.Title" });
}
let ze = U$3(We), Qe = U$3(Je), Ze = U$3(Ke), et = U$3(Ye), tt = U$3(qe$2), _t = Object.assign(ze, { Backdrop: Qe, Panel: Ze, Overlay: et, Title: tt, Description: G }), a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(A) {
  var B, L;
  let K = (B = A.innerText) != null ? B : "", V = A.cloneNode(!0);
  if (!(V instanceof HTMLElement)) return K;
  let W = !1;
  for (let ne of V.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) ne.remove(), W = !0;
  let J = W ? (L = V.innerText) != null ? L : "" : K;
  return a.test(J) && (J = J.replace(a, "")), J;
}
function g$1(A) {
  let B = A.getAttribute("aria-label");
  if (typeof B == "string") return B.trim();
  let L = A.getAttribute("aria-labelledby");
  if (L) {
    let K = L.split(" ").map((V) => {
      let W = document.getElementById(V);
      if (W) {
        let J = W.getAttribute("aria-label");
        return typeof J == "string" ? J.trim() : o$1(W).trim();
      }
      return null;
    }).filter(Boolean);
    if (K.length > 0) return K.join(", ");
  }
  return o$1(A).trim();
}
function s$1(A) {
  let B = useRef(""), L = useRef("");
  return o$6(() => {
    let K = A.current;
    if (!K) return "";
    let V = K.innerText;
    if (B.current === V) return L.current;
    let W = g$1(K).trim().toLowerCase();
    return B.current = V, L.current = W, W;
  });
}
var me = ((A) => (A[A.Open = 0] = "Open", A[A.Closed = 1] = "Closed", A))(me || {}), de = ((A) => (A[A.Pointer = 0] = "Pointer", A[A.Other = 1] = "Other", A))(de || {}), fe = ((A) => (A[A.OpenMenu = 0] = "OpenMenu", A[A.CloseMenu = 1] = "CloseMenu", A[A.GoToItem = 2] = "GoToItem", A[A.Search = 3] = "Search", A[A.ClearSearch = 4] = "ClearSearch", A[A.RegisterItem = 5] = "RegisterItem", A[A.UnregisterItem = 6] = "UnregisterItem", A))(fe || {});
function w(A, B = (L) => L) {
  let L = A.activeItemIndex !== null ? A.items[A.activeItemIndex] : null, K = I$4(B(A.items.slice()), (W) => W.dataRef.current.domRef.current), V = L ? K.indexOf(L) : null;
  return V === -1 && (V = null), { items: K, activeItemIndex: V };
}
let Te = { 1(A) {
  return A.menuState === 1 ? A : { ...A, activeItemIndex: null, menuState: 1 };
}, 0(A) {
  return A.menuState === 0 ? A : { ...A, __demoMode: !1, menuState: 0 };
}, 2: (A, B) => {
  var L;
  let K = w(A), V = f$5(B, { resolveItems: () => K.items, resolveActiveIndex: () => K.activeItemIndex, resolveId: (W) => W.id, resolveDisabled: (W) => W.dataRef.current.disabled });
  return { ...A, ...K, searchQuery: "", activeItemIndex: V, activationTrigger: (L = B.trigger) != null ? L : 1 };
}, 3: (A, B) => {
  let L = A.searchQuery !== "" ? 0 : 1, K = A.searchQuery + B.value.toLowerCase(), V = (A.activeItemIndex !== null ? A.items.slice(A.activeItemIndex + L).concat(A.items.slice(0, A.activeItemIndex + L)) : A.items).find((J) => {
    var ne;
    return ((ne = J.dataRef.current.textValue) == null ? void 0 : ne.startsWith(K)) && !J.dataRef.current.disabled;
  }), W = V ? A.items.indexOf(V) : -1;
  return W === -1 || W === A.activeItemIndex ? { ...A, searchQuery: K } : { ...A, searchQuery: K, activeItemIndex: W, activationTrigger: 1 };
}, 4(A) {
  return A.searchQuery === "" ? A : { ...A, searchQuery: "", searchActiveItemIndex: null };
}, 5: (A, B) => {
  let L = w(A, (K) => [...K, { id: B.id, dataRef: B.dataRef }]);
  return { ...A, ...L };
}, 6: (A, B) => {
  let L = w(A, (K) => {
    let V = K.findIndex((W) => W.id === B.id);
    return V !== -1 && K.splice(V, 1), K;
  });
  return { ...A, ...L, activationTrigger: 1 };
} }, U$1 = createContext(null);
U$1.displayName = "MenuContext";
function C(A) {
  let B = useContext(U$1);
  if (B === null) {
    let L = new Error(`<${A} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(L, C), L;
  }
  return B;
}
function ye$1(A, B) {
  return u$7(B.type, Te, A, B);
}
let Ie = Fragment;
function Me(A, B) {
  let { __demoMode: L = !1, ...K } = A, V = useReducer(ye$1, { __demoMode: L, menuState: L ? 0 : 1, buttonRef: createRef(), itemsRef: createRef(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: W, itemsRef: J, buttonRef: ne }, ie] = V, ce = y$1(B);
  y$2([ne, J], (Oe, it) => {
    var at;
    ie({ type: 1 }), h$4(it, T$2.Loose) || (Oe.preventDefault(), (at = ne.current) == null || at.focus());
  }, W === 0);
  let re = o$6(() => {
    ie({ type: 1 });
  }), oe = useMemo(() => ({ open: W === 0, close: re }), [W, re]), ke = { ref: ce };
  return C__default.createElement(U$1.Provider, { value: V }, C__default.createElement(s$5, { value: u$7(W, { 0: d$3.Open, 1: d$3.Closed }) }, C$1({ ourProps: ke, theirProps: K, slot: oe, defaultTag: Ie, name: "Menu" })));
}
let ge = "button";
function Re$1(A, B) {
  var L;
  let K = I$5(), { id: V = `headlessui-menu-button-${K}`, ...W } = A, [J, ne] = C("Menu.Button"), ie = y$1(J.buttonRef, B), ce = p$3(), re = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
      case o$2.Enter:
      case o$2.ArrowDown:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), ce.nextFrame(() => ne({ type: 2, focus: c$4.First }));
        break;
      case o$2.ArrowUp:
        at.preventDefault(), at.stopPropagation(), ne({ type: 0 }), ce.nextFrame(() => ne({ type: 2, focus: c$4.Last }));
        break;
    }
  }), oe = o$6((at) => {
    switch (at.key) {
      case o$2.Space:
        at.preventDefault();
        break;
    }
  }), ke = o$6((at) => {
    if (r$3(at.currentTarget)) return at.preventDefault();
    A.disabled || (J.menuState === 0 ? (ne({ type: 1 }), ce.nextFrame(() => {
      var ut;
      return (ut = J.buttonRef.current) == null ? void 0 : ut.focus({ preventScroll: !0 });
    })) : (at.preventDefault(), ne({ type: 0 })));
  }), Oe = useMemo(() => ({ open: J.menuState === 0 }), [J]), it = { ref: ie, id: V, type: T$1(A, J.buttonRef), "aria-haspopup": "menu", "aria-controls": (L = J.itemsRef.current) == null ? void 0 : L.id, "aria-expanded": J.menuState === 0, onKeyDown: re, onKeyUp: oe, onClick: ke };
  return C$1({ ourProps: it, theirProps: W, slot: Oe, defaultTag: ge, name: "Menu.Button" });
}
let Ae = "div", be = O.RenderStrategy | O.Static;
function Ee(A, B) {
  var L, K;
  let V = I$5(), { id: W = `headlessui-menu-items-${V}`, ...J } = A, [ne, ie] = C("Menu.Items"), ce = y$1(ne.itemsRef, B), re = n$2(ne.itemsRef), oe = p$3(), ke = u$3(), Oe = ke !== null ? (ke & d$3.Open) === d$3.Open : ne.menuState === 0;
  useEffect(() => {
    let ct = ne.itemsRef.current;
    ct && ne.menuState === 0 && ct !== (re == null ? void 0 : re.activeElement) && ct.focus({ preventScroll: !0 });
  }, [ne.menuState, ne.itemsRef, re]), F$2({ container: ne.itemsRef.current, enabled: ne.menuState === 0, accept(ct) {
    return ct.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : ct.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(ct) {
    ct.setAttribute("role", "none");
  } });
  let it = o$6((ct) => {
    var bt, vt;
    switch (oe.dispose(), ct.key) {
      case o$2.Space:
        if (ne.searchQuery !== "") return ct.preventDefault(), ct.stopPropagation(), ie({ type: 3, value: ct.key });
      case o$2.Enter:
        if (ct.preventDefault(), ct.stopPropagation(), ie({ type: 1 }), ne.activeItemIndex !== null) {
          let { dataRef: $t } = ne.items[ne.activeItemIndex];
          (vt = (bt = $t.current) == null ? void 0 : bt.domRef.current) == null || vt.click();
        }
        D$3(ne.buttonRef.current);
        break;
      case o$2.ArrowDown:
        return ct.preventDefault(), ct.stopPropagation(), ie({ type: 2, focus: c$4.Next });
      case o$2.ArrowUp:
        return ct.preventDefault(), ct.stopPropagation(), ie({ type: 2, focus: c$4.Previous });
      case o$2.Home:
      case o$2.PageUp:
        return ct.preventDefault(), ct.stopPropagation(), ie({ type: 2, focus: c$4.First });
      case o$2.End:
      case o$2.PageDown:
        return ct.preventDefault(), ct.stopPropagation(), ie({ type: 2, focus: c$4.Last });
      case o$2.Escape:
        ct.preventDefault(), ct.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          var $t;
          return ($t = ne.buttonRef.current) == null ? void 0 : $t.focus({ preventScroll: !0 });
        });
        break;
      case o$2.Tab:
        ct.preventDefault(), ct.stopPropagation(), ie({ type: 1 }), o$5().nextFrame(() => {
          _$2(ne.buttonRef.current, ct.shiftKey ? M$2.Previous : M$2.Next);
        });
        break;
      default:
        ct.key.length === 1 && (ie({ type: 3, value: ct.key }), oe.setTimeout(() => ie({ type: 4 }), 350));
        break;
    }
  }), at = o$6((ct) => {
    switch (ct.key) {
      case o$2.Space:
        ct.preventDefault();
        break;
    }
  }), ut = useMemo(() => ({ open: ne.menuState === 0 }), [ne]), dt = { "aria-activedescendant": ne.activeItemIndex === null || (L = ne.items[ne.activeItemIndex]) == null ? void 0 : L.id, "aria-labelledby": (K = ne.buttonRef.current) == null ? void 0 : K.id, id: W, onKeyDown: it, onKeyUp: at, role: "menu", tabIndex: 0, ref: ce };
  return C$1({ ourProps: dt, theirProps: J, slot: ut, defaultTag: Ae, features: be, visible: Oe, name: "Menu.Items" });
}
let Se$1 = Fragment;
function xe$1(A, B) {
  let L = I$5(), { id: K = `headlessui-menu-item-${L}`, disabled: V = !1, ...W } = A, [J, ne] = C("Menu.Item"), ie = J.activeItemIndex !== null ? J.items[J.activeItemIndex].id === K : !1, ce = useRef(null), re = y$1(B, ce);
  l$5(() => {
    if (J.__demoMode || J.menuState !== 0 || !ie || J.activationTrigger === 0) return;
    let $t = o$5();
    return $t.requestAnimationFrame(() => {
      var xt, Ot;
      (Ot = (xt = ce.current) == null ? void 0 : xt.scrollIntoView) == null || Ot.call(xt, { block: "nearest" });
    }), $t.dispose;
  }, [J.__demoMode, ce, ie, J.menuState, J.activationTrigger, J.activeItemIndex]);
  let oe = s$1(ce), ke = useRef({ disabled: V, domRef: ce, get textValue() {
    return oe();
  } });
  l$5(() => {
    ke.current.disabled = V;
  }, [ke, V]), l$5(() => (ne({ type: 5, id: K, dataRef: ke }), () => ne({ type: 6, id: K })), [ke, K]);
  let Oe = o$6(() => {
    ne({ type: 1 });
  }), it = o$6(($t) => {
    if (V) return $t.preventDefault();
    ne({ type: 1 }), D$3(J.buttonRef.current);
  }), at = o$6(() => {
    if (V) return ne({ type: 2, focus: c$4.Nothing });
    ne({ type: 2, focus: c$4.Specific, id: K });
  }), ut = u$5(), dt = o$6(($t) => ut.update($t)), ct = o$6(($t) => {
    ut.wasMoved($t) && (V || ie || ne({ type: 2, focus: c$4.Specific, id: K, trigger: 0 }));
  }), bt = o$6(($t) => {
    ut.wasMoved($t) && (V || ie && ne({ type: 2, focus: c$4.Nothing }));
  }), vt = useMemo(() => ({ active: ie, disabled: V, close: Oe }), [ie, V, Oe]);
  return C$1({ ourProps: { id: K, ref: re, role: "menuitem", tabIndex: V === !0 ? void 0 : -1, "aria-disabled": V === !0 ? !0 : void 0, disabled: void 0, onClick: it, onFocus: at, onPointerEnter: dt, onMouseEnter: dt, onPointerMove: ct, onMouseMove: ct, onPointerLeave: bt, onMouseLeave: bt }, theirProps: W, slot: vt, defaultTag: Se$1, name: "Menu.Item" });
}
let Pe$1 = U$3(Me), ve = U$3(Re$1), he = U$3(Ee), De$1 = U$3(xe$1), qe$1 = Object.assign(Pe$1, { Button: ve, Items: he, Item: De$1 });
function c(A = 0) {
  let [B, L] = useState(A), K = f$4(), V = useCallback((ie) => {
    K.current && L((ce) => ce | ie);
  }, [B, K]), W = useCallback((ie) => !!(B & ie), [B]), J = useCallback((ie) => {
    K.current && L((ce) => ce & ~ie);
  }, [L, K]), ne = useCallback((ie) => {
    K.current && L((ce) => ce ^ ie);
  }, [L]);
  return { flags: B, addFlag: V, hasFlag: W, removeFlag: J, toggleFlag: ne };
}
function l(A) {
  let B = { called: !1 };
  return (...L) => {
    if (!B.called) return B.called = !0, A(...L);
  };
}
function g(A, ...B) {
  A && B.length > 0 && A.classList.add(...B);
}
function v(A, ...B) {
  A && B.length > 0 && A.classList.remove(...B);
}
function b(A, B) {
  let L = o$5();
  if (!A) return L.dispose;
  let { transitionDuration: K, transitionDelay: V } = getComputedStyle(A), [W, J] = [K, V].map((ie) => {
    let [ce = 0] = ie.split(",").filter(Boolean).map((re) => re.includes("ms") ? parseFloat(re) : parseFloat(re) * 1e3).sort((re, oe) => oe - re);
    return ce;
  }), ne = W + J;
  if (ne !== 0) {
    L.group((ce) => {
      ce.setTimeout(() => {
        B(), ce.dispose();
      }, ne), ce.addEventListener(A, "transitionrun", (re) => {
        re.target === re.currentTarget && ce.dispose();
      });
    });
    let ie = L.addEventListener(A, "transitionend", (ce) => {
      ce.target === ce.currentTarget && (B(), ie());
    });
  } else B();
  return L.add(() => B()), L.dispose;
}
function M$1(A, B, L, K) {
  let V = L ? "enter" : "leave", W = o$5(), J = K !== void 0 ? l(K) : () => {
  };
  V === "enter" && (A.removeAttribute("hidden"), A.style.display = "");
  let ne = u$7(V, { enter: () => B.enter, leave: () => B.leave }), ie = u$7(V, { enter: () => B.enterTo, leave: () => B.leaveTo }), ce = u$7(V, { enter: () => B.enterFrom, leave: () => B.leaveFrom });
  return v(A, ...B.base, ...B.enter, ...B.enterTo, ...B.enterFrom, ...B.leave, ...B.leaveFrom, ...B.leaveTo, ...B.entered), g(A, ...B.base, ...ne, ...ce), W.nextFrame(() => {
    v(A, ...B.base, ...ne, ...ce), g(A, ...B.base, ...ne, ...ie), b(A, () => (v(A, ...B.base, ...ne), g(A, ...B.base, ...B.entered), J()));
  }), W.dispose;
}
function D({ immediate: A, container: B, direction: L, classes: K, onStart: V, onStop: W }) {
  let J = f$4(), ne = p$3(), ie = s$9(L);
  l$5(() => {
    A && (ie.current = "enter");
  }, [A]), l$5(() => {
    let ce = o$5();
    ne.add(ce.dispose);
    let re = B.current;
    if (re && ie.current !== "idle" && J.current) return ce.dispose(), V.current(ie.current), ce.add(M$1(re, K.current, ie.current === "enter", () => {
      ce.dispose(), W.current(ie.current);
    })), ce.dispose;
  }, [L]);
}
function S(A = "") {
  return A.split(/\s+/).filter((B) => B.length > 1);
}
let I = createContext(null);
I.displayName = "TransitionContext";
var Se = ((A) => (A.Visible = "visible", A.Hidden = "hidden", A))(Se || {});
function ye() {
  let A = useContext(I);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
function xe() {
  let A = useContext(M);
  if (A === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return A;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(A) {
  return "children" in A ? U(A.children) : A.current.filter(({ el: B }) => B.current !== null).filter(({ state: B }) => B === "visible").length > 0;
}
function se(A, B) {
  let L = s$9(A), K = useRef([]), V = f$4(), W = p$3(), J = o$6((Oe, it = v$1.Hidden) => {
    let at = K.current.findIndex(({ el: ut }) => ut === Oe);
    at !== -1 && (u$7(it, { [v$1.Unmount]() {
      K.current.splice(at, 1);
    }, [v$1.Hidden]() {
      K.current[at].state = "hidden";
    } }), W.microTask(() => {
      var ut;
      !U(K) && V.current && ((ut = L.current) == null || ut.call(L));
    }));
  }), ne = o$6((Oe) => {
    let it = K.current.find(({ el: at }) => at === Oe);
    return it ? it.state !== "visible" && (it.state = "visible") : K.current.push({ el: Oe, state: "visible" }), () => J(Oe, v$1.Unmount);
  }), ie = useRef([]), ce = useRef(Promise.resolve()), re = useRef({ enter: [], leave: [], idle: [] }), oe = o$6((Oe, it, at) => {
    ie.current.splice(0), B && (B.chains.current[it] = B.chains.current[it].filter(([ut]) => ut !== Oe)), B == null || B.chains.current[it].push([Oe, new Promise((ut) => {
      ie.current.push(ut);
    })]), B == null || B.chains.current[it].push([Oe, new Promise((ut) => {
      Promise.all(re.current[it].map(([dt, ct]) => ct)).then(() => ut());
    })]), it === "enter" ? ce.current = ce.current.then(() => B == null ? void 0 : B.wait.current).then(() => at(it)) : at(it);
  }), ke = o$6((Oe, it, at) => {
    Promise.all(re.current[it].splice(0).map(([ut, dt]) => dt)).then(() => {
      var ut;
      (ut = ie.current.shift()) == null || ut();
    }).then(() => at(it));
  });
  return useMemo(() => ({ children: K, register: ne, unregister: J, onStart: oe, onStop: ke, wait: ce, chains: re }), [ne, J, K, oe, ke, re, ce]);
}
function Ne() {
}
let Pe = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function ae(A) {
  var B;
  let L = {};
  for (let K of Pe) L[K] = (B = A[K]) != null ? B : Ne;
  return L;
}
function Re(A) {
  let B = useRef(ae(A));
  return useEffect(() => {
    B.current = ae(A);
  }, [A]), B;
}
let De = "div", le = O.RenderStrategy;
function He(A, B) {
  var L, K;
  let { beforeEnter: V, afterEnter: W, beforeLeave: J, afterLeave: ne, enter: ie, enterFrom: ce, enterTo: re, entered: oe, leave: ke, leaveFrom: Oe, leaveTo: it, ...at } = A, ut = useRef(null), dt = y$1(ut, B), ct = (L = at.unmount) == null || L ? v$1.Unmount : v$1.Hidden, { show: bt, appear: vt, initial: $t } = ye(), [xt, Ot] = useState(bt ? "visible" : "hidden"), At = xe(), { register: yt, unregister: Bt } = At;
  useEffect(() => yt(ut), [yt, ut]), useEffect(() => {
    if (ct === v$1.Hidden && ut.current) {
      if (bt && xt !== "visible") {
        Ot("visible");
        return;
      }
      return u$7(xt, { hidden: () => Bt(ut), visible: () => yt(ut) });
    }
  }, [xt, ut, yt, Bt, bt, ct]);
  let gt = s$9({ base: S(at.className), enter: S(ie), enterFrom: S(ce), enterTo: S(re), entered: S(oe), leave: S(ke), leaveFrom: S(Oe), leaveTo: S(it) }), rt = Re({ beforeEnter: V, afterEnter: W, beforeLeave: J, afterLeave: ne }), Ce = l$4();
  useEffect(() => {
    if (Ce && xt === "visible" && ut.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [ut, xt, Ce]);
  let pe = $t && !vt, nt = vt && bt && $t, st = !Ce || pe ? "idle" : bt ? "enter" : "leave", ot = c(0), ht = o$6((Ft) => u$7(Ft, { enter: () => {
    ot.addFlag(d$3.Opening), rt.current.beforeEnter();
  }, leave: () => {
    ot.addFlag(d$3.Closing), rt.current.beforeLeave();
  }, idle: () => {
  } })), pt = o$6((Ft) => u$7(Ft, { enter: () => {
    ot.removeFlag(d$3.Opening), rt.current.afterEnter();
  }, leave: () => {
    ot.removeFlag(d$3.Closing), rt.current.afterLeave();
  }, idle: () => {
  } })), ft = se(() => {
    Ot("hidden"), Bt(ut);
  }, At), mt = useRef(!1);
  D({ immediate: nt, container: ut, classes: gt, direction: st, onStart: s$9((Ft) => {
    mt.current = !0, ft.onStart(ut, Ft, ht);
  }), onStop: s$9((Ft) => {
    mt.current = !1, ft.onStop(ut, Ft, pt), Ft === "leave" && !U(ft) && (Ot("hidden"), Bt(ut));
  }) });
  let lt = at, St = { ref: dt };
  return nt ? lt = { ...lt, className: t$4(at.className, ...gt.current.enter, ...gt.current.enterFrom) } : mt.current && (lt.className = t$4(at.className, (K = ut.current) == null ? void 0 : K.className), lt.className === "" && delete lt.className), C__default.createElement(M.Provider, { value: ft }, C__default.createElement(s$5, { value: u$7(xt, { visible: d$3.Open, hidden: d$3.Closed }) | ot.flags }, C$1({ ourProps: St, theirProps: lt, defaultTag: De, features: le, visible: xt === "visible", name: "Transition.Child" })));
}
function Fe(A, B) {
  let { show: L, appear: K = !1, unmount: V = !0, ...W } = A, J = useRef(null), ne = y$1(J, B);
  l$4();
  let ie = u$3();
  if (L === void 0 && ie !== null && (L = (ie & d$3.Open) === d$3.Open), ![!0, !1].includes(L)) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [ce, re] = useState(L ? "visible" : "hidden"), oe = se(() => {
    re("hidden");
  }), [ke, Oe] = useState(!0), it = useRef([L]);
  l$5(() => {
    ke !== !1 && it.current[it.current.length - 1] !== L && (it.current.push(L), Oe(!1));
  }, [it, L]);
  let at = useMemo(() => ({ show: L, appear: K, initial: ke }), [L, K, ke]);
  useEffect(() => {
    if (L) re("visible");
    else if (!U(oe)) re("hidden");
    else {
      let bt = J.current;
      if (!bt) return;
      let vt = bt.getBoundingClientRect();
      vt.x === 0 && vt.y === 0 && vt.width === 0 && vt.height === 0 && re("hidden");
    }
  }, [L, oe]);
  let ut = { unmount: V }, dt = o$6(() => {
    var bt;
    ke && Oe(!1), (bt = A.beforeEnter) == null || bt.call(A);
  }), ct = o$6(() => {
    var bt;
    ke && Oe(!1), (bt = A.beforeLeave) == null || bt.call(A);
  });
  return C__default.createElement(M.Provider, { value: oe }, C__default.createElement(I.Provider, { value: at }, C$1({ ourProps: { ...ut, as: Fragment, children: C__default.createElement(ue, { ref: ne, ...ut, ...W, beforeEnter: dt, beforeLeave: ct }) }, theirProps: {}, defaultTag: Fragment, features: le, visible: ce === "visible", name: "Transition" })));
}
function _e(A, B) {
  let L = useContext(I) !== null, K = u$3() !== null;
  return C__default.createElement(C__default.Fragment, null, !L && K ? C__default.createElement(q, { ref: B, ...A }) : C__default.createElement(ue, { ref: B, ...A }));
}
let q = U$3(Fe), ue = U$3(He), Le = U$3(_e), qe = Object.assign(q, { Child: Le, Root: q });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(A, B = 4, L = 5) {
  if (A.length <= B + L)
    return A;
  const K = A.slice(0, B), V = A.slice(A.length - L);
  return `${K}...${V}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: A,
  network: B,
  onViewProfile: L,
  onChangeWallet: K,
  onDisconnectWallet: V,
  renderAvatar: W
}) {
  const { wallet: J } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    qe$1,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: ne }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            W ? W(A, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: A,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[J],
                alt: `${J} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(A) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[B] ?? B })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${ne ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(qe$1.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => L == null ? void 0 : L(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(A) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => K == null ? void 0 : K(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                qe$1.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => V == null ? void 0 : V(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: A,
  disabled: B
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: A,
      disabled: B,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength$1(A) {
  var B = getLens$1(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength$1(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray$1(A) {
  var B, L = getLens$1(A), K = L[0], V = L[1], W = new Arr$1(_byteLength$1(A, K, V)), J = 0, ne = V > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup$1[A.charCodeAt(ie)] << 18 | revLookup$1[A.charCodeAt(ie + 1)] << 12 | revLookup$1[A.charCodeAt(ie + 2)] << 6 | revLookup$1[A.charCodeAt(ie + 3)], W[J++] = B >> 16 & 255, W[J++] = B >> 8 & 255, W[J++] = B & 255;
  return V === 2 && (B = revLookup$1[A.charCodeAt(ie)] << 2 | revLookup$1[A.charCodeAt(ie + 1)] >> 4, W[J++] = B & 255), V === 1 && (B = revLookup$1[A.charCodeAt(ie)] << 10 | revLookup$1[A.charCodeAt(ie + 1)] << 4 | revLookup$1[A.charCodeAt(ie + 2)] >> 2, W[J++] = B >> 8 & 255, W[J++] = B & 255), W;
}
function tripletToBase64$1(A) {
  return lookup$1[A >> 18 & 63] + lookup$1[A >> 12 & 63] + lookup$1[A >> 6 & 63] + lookup$1[A & 63];
}
function encodeChunk$1(A, B, L) {
  for (var K, V = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), V.push(tripletToBase64$1(K));
  return V.join("");
}
function fromByteArray$1(A) {
  for (var B, L = A.length, K = L % 3, V = [], W = 16383, J = 0, ne = L - K; J < ne; J += W)
    V.push(encodeChunk$1(A, J, J + W > ne ? ne : J + W));
  return K === 1 ? (B = A[L - 1], V.push(
    lookup$1[B >> 2] + lookup$1[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], V.push(
    lookup$1[B >> 10] + lookup$1[B >> 4 & 63] + lookup$1[B << 2 & 63] + "="
  )), V.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(A, B, L, K, V) {
  var W, J, ne = V * 8 - K - 1, ie = (1 << ne) - 1, ce = ie >> 1, re = -7, oe = L ? V - 1 : 0, ke = L ? -1 : 1, Oe = A[B + oe];
  for (oe += ke, W = Oe & (1 << -re) - 1, Oe >>= -re, re += ne; re > 0; W = W * 256 + A[B + oe], oe += ke, re -= 8)
    ;
  for (J = W & (1 << -re) - 1, W >>= -re, re += K; re > 0; J = J * 256 + A[B + oe], oe += ke, re -= 8)
    ;
  if (W === 0)
    W = 1 - ce;
  else {
    if (W === ie)
      return J ? NaN : (Oe ? -1 : 1) * (1 / 0);
    J = J + Math.pow(2, K), W = W - ce;
  }
  return (Oe ? -1 : 1) * J * Math.pow(2, W - K);
};
ieee754.write = function(A, B, L, K, V, W) {
  var J, ne, ie, ce = W * 8 - V - 1, re = (1 << ce) - 1, oe = re >> 1, ke = V === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Oe = K ? 0 : W - 1, it = K ? 1 : -1, at = B < 0 || B === 0 && 1 / B < 0 ? 1 : 0;
  for (B = Math.abs(B), isNaN(B) || B === 1 / 0 ? (ne = isNaN(B) ? 1 : 0, J = re) : (J = Math.floor(Math.log(B) / Math.LN2), B * (ie = Math.pow(2, -J)) < 1 && (J--, ie *= 2), J + oe >= 1 ? B += ke / ie : B += ke * Math.pow(2, 1 - oe), B * ie >= 2 && (J++, ie /= 2), J + oe >= re ? (ne = 0, J = re) : J + oe >= 1 ? (ne = (B * ie - 1) * Math.pow(2, V), J = J + oe) : (ne = B * Math.pow(2, oe - 1) * Math.pow(2, V), J = 0)); V >= 8; A[L + Oe] = ne & 255, Oe += it, ne /= 256, V -= 8)
    ;
  for (J = J << V | ne, ce += V; ce > 0; A[L + Oe] = J & 255, Oe += it, J /= 256, ce -= 8)
    ;
  A[L + Oe - it] |= at * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(A) {
  const B = base64Js$1, L = ieee754, K = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  A.Buffer = re, A.SlowBuffer = $t, A.INSPECT_MAX_BYTES = 50;
  const V = 2147483647;
  A.kMaxLength = V;
  const { Uint8Array: W, ArrayBuffer: J, SharedArrayBuffer: ne } = globalThis;
  re.TYPED_ARRAY_SUPPORT = ie(), !re.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ie() {
    try {
      const Mt = new W(1), wt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(wt, W.prototype), Object.setPrototypeOf(Mt, wt), Mt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(re.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (re.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(re.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (re.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ce(Mt) {
    if (Mt > V)
      throw new RangeError('The value "' + Mt + '" is invalid for option "size"');
    const wt = new W(Mt);
    return Object.setPrototypeOf(wt, re.prototype), wt;
  }
  function re(Mt, wt, Et) {
    if (typeof Mt == "number") {
      if (typeof wt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return it(Mt);
    }
    return oe(Mt, wt, Et);
  }
  re.poolSize = 8192;
  function oe(Mt, wt, Et) {
    if (typeof Mt == "string")
      return at(Mt, wt);
    if (J.isView(Mt))
      return dt(Mt);
    if (Mt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Mt
      );
    if (xr(Mt, J) || Mt && xr(Mt.buffer, J) || typeof ne < "u" && (xr(Mt, ne) || Mt && xr(Mt.buffer, ne)))
      return ct(Mt, wt, Et);
    if (typeof Mt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Ct = Mt.valueOf && Mt.valueOf();
    if (Ct != null && Ct !== Mt)
      return re.from(Ct, wt, Et);
    const Kt = bt(Mt);
    if (Kt) return Kt;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Mt[Symbol.toPrimitive] == "function")
      return re.from(Mt[Symbol.toPrimitive]("string"), wt, Et);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Mt
    );
  }
  re.from = function(Mt, wt, Et) {
    return oe(Mt, wt, Et);
  }, Object.setPrototypeOf(re.prototype, W.prototype), Object.setPrototypeOf(re, W);
  function ke(Mt) {
    if (typeof Mt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Mt < 0)
      throw new RangeError('The value "' + Mt + '" is invalid for option "size"');
  }
  function Oe(Mt, wt, Et) {
    return ke(Mt), Mt <= 0 ? ce(Mt) : wt !== void 0 ? typeof Et == "string" ? ce(Mt).fill(wt, Et) : ce(Mt).fill(wt) : ce(Mt);
  }
  re.alloc = function(Mt, wt, Et) {
    return Oe(Mt, wt, Et);
  };
  function it(Mt) {
    return ke(Mt), ce(Mt < 0 ? 0 : vt(Mt) | 0);
  }
  re.allocUnsafe = function(Mt) {
    return it(Mt);
  }, re.allocUnsafeSlow = function(Mt) {
    return it(Mt);
  };
  function at(Mt, wt) {
    if ((typeof wt != "string" || wt === "") && (wt = "utf8"), !re.isEncoding(wt))
      throw new TypeError("Unknown encoding: " + wt);
    const Et = xt(Mt, wt) | 0;
    let Ct = ce(Et);
    const Kt = Ct.write(Mt, wt);
    return Kt !== Et && (Ct = Ct.slice(0, Kt)), Ct;
  }
  function ut(Mt) {
    const wt = Mt.length < 0 ? 0 : vt(Mt.length) | 0, Et = ce(wt);
    for (let Ct = 0; Ct < wt; Ct += 1)
      Et[Ct] = Mt[Ct] & 255;
    return Et;
  }
  function dt(Mt) {
    if (xr(Mt, W)) {
      const wt = new W(Mt);
      return ct(wt.buffer, wt.byteOffset, wt.byteLength);
    }
    return ut(Mt);
  }
  function ct(Mt, wt, Et) {
    if (wt < 0 || Mt.byteLength < wt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Mt.byteLength < wt + (Et || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Ct;
    return wt === void 0 && Et === void 0 ? Ct = new W(Mt) : Et === void 0 ? Ct = new W(Mt, wt) : Ct = new W(Mt, wt, Et), Object.setPrototypeOf(Ct, re.prototype), Ct;
  }
  function bt(Mt) {
    if (re.isBuffer(Mt)) {
      const wt = vt(Mt.length) | 0, Et = ce(wt);
      return Et.length === 0 || Mt.copy(Et, 0, 0, wt), Et;
    }
    if (Mt.length !== void 0)
      return typeof Mt.length != "number" || Ir(Mt.length) ? ce(0) : ut(Mt);
    if (Mt.type === "Buffer" && Array.isArray(Mt.data))
      return ut(Mt.data);
  }
  function vt(Mt) {
    if (Mt >= V)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + V.toString(16) + " bytes");
    return Mt | 0;
  }
  function $t(Mt) {
    return +Mt != Mt && (Mt = 0), re.alloc(+Mt);
  }
  re.isBuffer = function(wt) {
    return wt != null && wt._isBuffer === !0 && wt !== re.prototype;
  }, re.compare = function(wt, Et) {
    if (xr(wt, W) && (wt = re.from(wt, wt.offset, wt.byteLength)), xr(Et, W) && (Et = re.from(Et, Et.offset, Et.byteLength)), !re.isBuffer(wt) || !re.isBuffer(Et))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (wt === Et) return 0;
    let Ct = wt.length, Kt = Et.length;
    for (let Vt = 0, zt = Math.min(Ct, Kt); Vt < zt; ++Vt)
      if (wt[Vt] !== Et[Vt]) {
        Ct = wt[Vt], Kt = Et[Vt];
        break;
      }
    return Ct < Kt ? -1 : Kt < Ct ? 1 : 0;
  }, re.isEncoding = function(wt) {
    switch (String(wt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, re.concat = function(wt, Et) {
    if (!Array.isArray(wt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (wt.length === 0)
      return re.alloc(0);
    let Ct;
    if (Et === void 0)
      for (Et = 0, Ct = 0; Ct < wt.length; ++Ct)
        Et += wt[Ct].length;
    const Kt = re.allocUnsafe(Et);
    let Vt = 0;
    for (Ct = 0; Ct < wt.length; ++Ct) {
      let zt = wt[Ct];
      if (xr(zt, W))
        Vt + zt.length > Kt.length ? (re.isBuffer(zt) || (zt = re.from(zt)), zt.copy(Kt, Vt)) : W.prototype.set.call(
          Kt,
          zt,
          Vt
        );
      else if (re.isBuffer(zt))
        zt.copy(Kt, Vt);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Vt += zt.length;
    }
    return Kt;
  };
  function xt(Mt, wt) {
    if (re.isBuffer(Mt))
      return Mt.length;
    if (J.isView(Mt) || xr(Mt, J))
      return Mt.byteLength;
    if (typeof Mt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Mt
      );
    const Et = Mt.length, Ct = arguments.length > 2 && arguments[2] === !0;
    if (!Ct && Et === 0) return 0;
    let Kt = !1;
    for (; ; )
      switch (wt) {
        case "ascii":
        case "latin1":
        case "binary":
          return Et;
        case "utf8":
        case "utf-8":
          return Pr(Mt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Et * 2;
        case "hex":
          return Et >>> 1;
        case "base64":
          return Br(Mt).length;
        default:
          if (Kt)
            return Ct ? -1 : Pr(Mt).length;
          wt = ("" + wt).toLowerCase(), Kt = !0;
      }
  }
  re.byteLength = xt;
  function Ot(Mt, wt, Et) {
    let Ct = !1;
    if ((wt === void 0 || wt < 0) && (wt = 0), wt > this.length || ((Et === void 0 || Et > this.length) && (Et = this.length), Et <= 0) || (Et >>>= 0, wt >>>= 0, Et <= wt))
      return "";
    for (Mt || (Mt = "utf8"); ; )
      switch (Mt) {
        case "hex":
          return lt(this, wt, Et);
        case "utf8":
        case "utf-8":
          return ot(this, wt, Et);
        case "ascii":
          return ft(this, wt, Et);
        case "latin1":
        case "binary":
          return mt(this, wt, Et);
        case "base64":
          return st(this, wt, Et);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return St(this, wt, Et);
        default:
          if (Ct) throw new TypeError("Unknown encoding: " + Mt);
          Mt = (Mt + "").toLowerCase(), Ct = !0;
      }
  }
  re.prototype._isBuffer = !0;
  function At(Mt, wt, Et) {
    const Ct = Mt[wt];
    Mt[wt] = Mt[Et], Mt[Et] = Ct;
  }
  re.prototype.swap16 = function() {
    const wt = this.length;
    if (wt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Et = 0; Et < wt; Et += 2)
      At(this, Et, Et + 1);
    return this;
  }, re.prototype.swap32 = function() {
    const wt = this.length;
    if (wt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Et = 0; Et < wt; Et += 4)
      At(this, Et, Et + 3), At(this, Et + 1, Et + 2);
    return this;
  }, re.prototype.swap64 = function() {
    const wt = this.length;
    if (wt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Et = 0; Et < wt; Et += 8)
      At(this, Et, Et + 7), At(this, Et + 1, Et + 6), At(this, Et + 2, Et + 5), At(this, Et + 3, Et + 4);
    return this;
  }, re.prototype.toString = function() {
    const wt = this.length;
    return wt === 0 ? "" : arguments.length === 0 ? ot(this, 0, wt) : Ot.apply(this, arguments);
  }, re.prototype.toLocaleString = re.prototype.toString, re.prototype.equals = function(wt) {
    if (!re.isBuffer(wt)) throw new TypeError("Argument must be a Buffer");
    return this === wt ? !0 : re.compare(this, wt) === 0;
  }, re.prototype.inspect = function() {
    let wt = "";
    const Et = A.INSPECT_MAX_BYTES;
    return wt = this.toString("hex", 0, Et).replace(/(.{2})/g, "$1 ").trim(), this.length > Et && (wt += " ... "), "<Buffer " + wt + ">";
  }, K && (re.prototype[K] = re.prototype.inspect), re.prototype.compare = function(wt, Et, Ct, Kt, Vt) {
    if (xr(wt, W) && (wt = re.from(wt, wt.offset, wt.byteLength)), !re.isBuffer(wt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof wt
      );
    if (Et === void 0 && (Et = 0), Ct === void 0 && (Ct = wt ? wt.length : 0), Kt === void 0 && (Kt = 0), Vt === void 0 && (Vt = this.length), Et < 0 || Ct > wt.length || Kt < 0 || Vt > this.length)
      throw new RangeError("out of range index");
    if (Kt >= Vt && Et >= Ct)
      return 0;
    if (Kt >= Vt)
      return -1;
    if (Et >= Ct)
      return 1;
    if (Et >>>= 0, Ct >>>= 0, Kt >>>= 0, Vt >>>= 0, this === wt) return 0;
    let zt = Vt - Kt, yr = Ct - Et;
    const $r = Math.min(zt, yr), hr = this.slice(Kt, Vt), Er = wt.slice(Et, Ct);
    for (let Sr = 0; Sr < $r; ++Sr)
      if (hr[Sr] !== Er[Sr]) {
        zt = hr[Sr], yr = Er[Sr];
        break;
      }
    return zt < yr ? -1 : yr < zt ? 1 : 0;
  };
  function yt(Mt, wt, Et, Ct, Kt) {
    if (Mt.length === 0) return -1;
    if (typeof Et == "string" ? (Ct = Et, Et = 0) : Et > 2147483647 ? Et = 2147483647 : Et < -2147483648 && (Et = -2147483648), Et = +Et, Ir(Et) && (Et = Kt ? 0 : Mt.length - 1), Et < 0 && (Et = Mt.length + Et), Et >= Mt.length) {
      if (Kt) return -1;
      Et = Mt.length - 1;
    } else if (Et < 0)
      if (Kt) Et = 0;
      else return -1;
    if (typeof wt == "string" && (wt = re.from(wt, Ct)), re.isBuffer(wt))
      return wt.length === 0 ? -1 : Bt(Mt, wt, Et, Ct, Kt);
    if (typeof wt == "number")
      return wt = wt & 255, typeof W.prototype.indexOf == "function" ? Kt ? W.prototype.indexOf.call(Mt, wt, Et) : W.prototype.lastIndexOf.call(Mt, wt, Et) : Bt(Mt, [wt], Et, Ct, Kt);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Bt(Mt, wt, Et, Ct, Kt) {
    let Vt = 1, zt = Mt.length, yr = wt.length;
    if (Ct !== void 0 && (Ct = String(Ct).toLowerCase(), Ct === "ucs2" || Ct === "ucs-2" || Ct === "utf16le" || Ct === "utf-16le")) {
      if (Mt.length < 2 || wt.length < 2)
        return -1;
      Vt = 2, zt /= 2, yr /= 2, Et /= 2;
    }
    function $r(Er, Sr) {
      return Vt === 1 ? Er[Sr] : Er.readUInt16BE(Sr * Vt);
    }
    let hr;
    if (Kt) {
      let Er = -1;
      for (hr = Et; hr < zt; hr++)
        if ($r(Mt, hr) === $r(wt, Er === -1 ? 0 : hr - Er)) {
          if (Er === -1 && (Er = hr), hr - Er + 1 === yr) return Er * Vt;
        } else
          Er !== -1 && (hr -= hr - Er), Er = -1;
    } else
      for (Et + yr > zt && (Et = zt - yr), hr = Et; hr >= 0; hr--) {
        let Er = !0;
        for (let Sr = 0; Sr < yr; Sr++)
          if ($r(Mt, hr + Sr) !== $r(wt, Sr)) {
            Er = !1;
            break;
          }
        if (Er) return hr;
      }
    return -1;
  }
  re.prototype.includes = function(wt, Et, Ct) {
    return this.indexOf(wt, Et, Ct) !== -1;
  }, re.prototype.indexOf = function(wt, Et, Ct) {
    return yt(this, wt, Et, Ct, !0);
  }, re.prototype.lastIndexOf = function(wt, Et, Ct) {
    return yt(this, wt, Et, Ct, !1);
  };
  function gt(Mt, wt, Et, Ct) {
    Et = Number(Et) || 0;
    const Kt = Mt.length - Et;
    Ct ? (Ct = Number(Ct), Ct > Kt && (Ct = Kt)) : Ct = Kt;
    const Vt = wt.length;
    Ct > Vt / 2 && (Ct = Vt / 2);
    let zt;
    for (zt = 0; zt < Ct; ++zt) {
      const yr = parseInt(wt.substr(zt * 2, 2), 16);
      if (Ir(yr)) return zt;
      Mt[Et + zt] = yr;
    }
    return zt;
  }
  function rt(Mt, wt, Et, Ct) {
    return cr(Pr(wt, Mt.length - Et), Mt, Et, Ct);
  }
  function Ce(Mt, wt, Et, Ct) {
    return cr(or(wt), Mt, Et, Ct);
  }
  function pe(Mt, wt, Et, Ct) {
    return cr(Br(wt), Mt, Et, Ct);
  }
  function nt(Mt, wt, Et, Ct) {
    return cr(Ar(wt, Mt.length - Et), Mt, Et, Ct);
  }
  re.prototype.write = function(wt, Et, Ct, Kt) {
    if (Et === void 0)
      Kt = "utf8", Ct = this.length, Et = 0;
    else if (Ct === void 0 && typeof Et == "string")
      Kt = Et, Ct = this.length, Et = 0;
    else if (isFinite(Et))
      Et = Et >>> 0, isFinite(Ct) ? (Ct = Ct >>> 0, Kt === void 0 && (Kt = "utf8")) : (Kt = Ct, Ct = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const Vt = this.length - Et;
    if ((Ct === void 0 || Ct > Vt) && (Ct = Vt), wt.length > 0 && (Ct < 0 || Et < 0) || Et > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Kt || (Kt = "utf8");
    let zt = !1;
    for (; ; )
      switch (Kt) {
        case "hex":
          return gt(this, wt, Et, Ct);
        case "utf8":
        case "utf-8":
          return rt(this, wt, Et, Ct);
        case "ascii":
        case "latin1":
        case "binary":
          return Ce(this, wt, Et, Ct);
        case "base64":
          return pe(this, wt, Et, Ct);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return nt(this, wt, Et, Ct);
        default:
          if (zt) throw new TypeError("Unknown encoding: " + Kt);
          Kt = ("" + Kt).toLowerCase(), zt = !0;
      }
  }, re.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function st(Mt, wt, Et) {
    return wt === 0 && Et === Mt.length ? B.fromByteArray(Mt) : B.fromByteArray(Mt.slice(wt, Et));
  }
  function ot(Mt, wt, Et) {
    Et = Math.min(Mt.length, Et);
    const Ct = [];
    let Kt = wt;
    for (; Kt < Et; ) {
      const Vt = Mt[Kt];
      let zt = null, yr = Vt > 239 ? 4 : Vt > 223 ? 3 : Vt > 191 ? 2 : 1;
      if (Kt + yr <= Et) {
        let $r, hr, Er, Sr;
        switch (yr) {
          case 1:
            Vt < 128 && (zt = Vt);
            break;
          case 2:
            $r = Mt[Kt + 1], ($r & 192) === 128 && (Sr = (Vt & 31) << 6 | $r & 63, Sr > 127 && (zt = Sr));
            break;
          case 3:
            $r = Mt[Kt + 1], hr = Mt[Kt + 2], ($r & 192) === 128 && (hr & 192) === 128 && (Sr = (Vt & 15) << 12 | ($r & 63) << 6 | hr & 63, Sr > 2047 && (Sr < 55296 || Sr > 57343) && (zt = Sr));
            break;
          case 4:
            $r = Mt[Kt + 1], hr = Mt[Kt + 2], Er = Mt[Kt + 3], ($r & 192) === 128 && (hr & 192) === 128 && (Er & 192) === 128 && (Sr = (Vt & 15) << 18 | ($r & 63) << 12 | (hr & 63) << 6 | Er & 63, Sr > 65535 && Sr < 1114112 && (zt = Sr));
        }
      }
      zt === null ? (zt = 65533, yr = 1) : zt > 65535 && (zt -= 65536, Ct.push(zt >>> 10 & 1023 | 55296), zt = 56320 | zt & 1023), Ct.push(zt), Kt += yr;
    }
    return pt(Ct);
  }
  const ht = 4096;
  function pt(Mt) {
    const wt = Mt.length;
    if (wt <= ht)
      return String.fromCharCode.apply(String, Mt);
    let Et = "", Ct = 0;
    for (; Ct < wt; )
      Et += String.fromCharCode.apply(
        String,
        Mt.slice(Ct, Ct += ht)
      );
    return Et;
  }
  function ft(Mt, wt, Et) {
    let Ct = "";
    Et = Math.min(Mt.length, Et);
    for (let Kt = wt; Kt < Et; ++Kt)
      Ct += String.fromCharCode(Mt[Kt] & 127);
    return Ct;
  }
  function mt(Mt, wt, Et) {
    let Ct = "";
    Et = Math.min(Mt.length, Et);
    for (let Kt = wt; Kt < Et; ++Kt)
      Ct += String.fromCharCode(Mt[Kt]);
    return Ct;
  }
  function lt(Mt, wt, Et) {
    const Ct = Mt.length;
    (!wt || wt < 0) && (wt = 0), (!Et || Et < 0 || Et > Ct) && (Et = Ct);
    let Kt = "";
    for (let Vt = wt; Vt < Et; ++Vt)
      Kt += gr[Mt[Vt]];
    return Kt;
  }
  function St(Mt, wt, Et) {
    const Ct = Mt.slice(wt, Et);
    let Kt = "";
    for (let Vt = 0; Vt < Ct.length - 1; Vt += 2)
      Kt += String.fromCharCode(Ct[Vt] + Ct[Vt + 1] * 256);
    return Kt;
  }
  re.prototype.slice = function(wt, Et) {
    const Ct = this.length;
    wt = ~~wt, Et = Et === void 0 ? Ct : ~~Et, wt < 0 ? (wt += Ct, wt < 0 && (wt = 0)) : wt > Ct && (wt = Ct), Et < 0 ? (Et += Ct, Et < 0 && (Et = 0)) : Et > Ct && (Et = Ct), Et < wt && (Et = wt);
    const Kt = this.subarray(wt, Et);
    return Object.setPrototypeOf(Kt, re.prototype), Kt;
  };
  function Ft(Mt, wt, Et) {
    if (Mt % 1 !== 0 || Mt < 0) throw new RangeError("offset is not uint");
    if (Mt + wt > Et) throw new RangeError("Trying to access beyond buffer length");
  }
  re.prototype.readUintLE = re.prototype.readUIntLE = function(wt, Et, Ct) {
    wt = wt >>> 0, Et = Et >>> 0, Ct || Ft(wt, Et, this.length);
    let Kt = this[wt], Vt = 1, zt = 0;
    for (; ++zt < Et && (Vt *= 256); )
      Kt += this[wt + zt] * Vt;
    return Kt;
  }, re.prototype.readUintBE = re.prototype.readUIntBE = function(wt, Et, Ct) {
    wt = wt >>> 0, Et = Et >>> 0, Ct || Ft(wt, Et, this.length);
    let Kt = this[wt + --Et], Vt = 1;
    for (; Et > 0 && (Vt *= 256); )
      Kt += this[wt + --Et] * Vt;
    return Kt;
  }, re.prototype.readUint8 = re.prototype.readUInt8 = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 1, this.length), this[wt];
  }, re.prototype.readUint16LE = re.prototype.readUInt16LE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 2, this.length), this[wt] | this[wt + 1] << 8;
  }, re.prototype.readUint16BE = re.prototype.readUInt16BE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 2, this.length), this[wt] << 8 | this[wt + 1];
  }, re.prototype.readUint32LE = re.prototype.readUInt32LE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 4, this.length), (this[wt] | this[wt + 1] << 8 | this[wt + 2] << 16) + this[wt + 3] * 16777216;
  }, re.prototype.readUint32BE = re.prototype.readUInt32BE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 4, this.length), this[wt] * 16777216 + (this[wt + 1] << 16 | this[wt + 2] << 8 | this[wt + 3]);
  }, re.prototype.readBigUInt64LE = Rr(function(wt) {
    wt = wt >>> 0, nr(wt, "offset");
    const Et = this[wt], Ct = this[wt + 7];
    (Et === void 0 || Ct === void 0) && fr(wt, this.length - 8);
    const Kt = Et + this[++wt] * 2 ** 8 + this[++wt] * 2 ** 16 + this[++wt] * 2 ** 24, Vt = this[++wt] + this[++wt] * 2 ** 8 + this[++wt] * 2 ** 16 + Ct * 2 ** 24;
    return BigInt(Kt) + (BigInt(Vt) << BigInt(32));
  }), re.prototype.readBigUInt64BE = Rr(function(wt) {
    wt = wt >>> 0, nr(wt, "offset");
    const Et = this[wt], Ct = this[wt + 7];
    (Et === void 0 || Ct === void 0) && fr(wt, this.length - 8);
    const Kt = Et * 2 ** 24 + this[++wt] * 2 ** 16 + this[++wt] * 2 ** 8 + this[++wt], Vt = this[++wt] * 2 ** 24 + this[++wt] * 2 ** 16 + this[++wt] * 2 ** 8 + Ct;
    return (BigInt(Kt) << BigInt(32)) + BigInt(Vt);
  }), re.prototype.readIntLE = function(wt, Et, Ct) {
    wt = wt >>> 0, Et = Et >>> 0, Ct || Ft(wt, Et, this.length);
    let Kt = this[wt], Vt = 1, zt = 0;
    for (; ++zt < Et && (Vt *= 256); )
      Kt += this[wt + zt] * Vt;
    return Vt *= 128, Kt >= Vt && (Kt -= Math.pow(2, 8 * Et)), Kt;
  }, re.prototype.readIntBE = function(wt, Et, Ct) {
    wt = wt >>> 0, Et = Et >>> 0, Ct || Ft(wt, Et, this.length);
    let Kt = Et, Vt = 1, zt = this[wt + --Kt];
    for (; Kt > 0 && (Vt *= 256); )
      zt += this[wt + --Kt] * Vt;
    return Vt *= 128, zt >= Vt && (zt -= Math.pow(2, 8 * Et)), zt;
  }, re.prototype.readInt8 = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 1, this.length), this[wt] & 128 ? (255 - this[wt] + 1) * -1 : this[wt];
  }, re.prototype.readInt16LE = function(wt, Et) {
    wt = wt >>> 0, Et || Ft(wt, 2, this.length);
    const Ct = this[wt] | this[wt + 1] << 8;
    return Ct & 32768 ? Ct | 4294901760 : Ct;
  }, re.prototype.readInt16BE = function(wt, Et) {
    wt = wt >>> 0, Et || Ft(wt, 2, this.length);
    const Ct = this[wt + 1] | this[wt] << 8;
    return Ct & 32768 ? Ct | 4294901760 : Ct;
  }, re.prototype.readInt32LE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 4, this.length), this[wt] | this[wt + 1] << 8 | this[wt + 2] << 16 | this[wt + 3] << 24;
  }, re.prototype.readInt32BE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 4, this.length), this[wt] << 24 | this[wt + 1] << 16 | this[wt + 2] << 8 | this[wt + 3];
  }, re.prototype.readBigInt64LE = Rr(function(wt) {
    wt = wt >>> 0, nr(wt, "offset");
    const Et = this[wt], Ct = this[wt + 7];
    (Et === void 0 || Ct === void 0) && fr(wt, this.length - 8);
    const Kt = this[wt + 4] + this[wt + 5] * 2 ** 8 + this[wt + 6] * 2 ** 16 + (Ct << 24);
    return (BigInt(Kt) << BigInt(32)) + BigInt(Et + this[++wt] * 2 ** 8 + this[++wt] * 2 ** 16 + this[++wt] * 2 ** 24);
  }), re.prototype.readBigInt64BE = Rr(function(wt) {
    wt = wt >>> 0, nr(wt, "offset");
    const Et = this[wt], Ct = this[wt + 7];
    (Et === void 0 || Ct === void 0) && fr(wt, this.length - 8);
    const Kt = (Et << 24) + // Overflow
    this[++wt] * 2 ** 16 + this[++wt] * 2 ** 8 + this[++wt];
    return (BigInt(Kt) << BigInt(32)) + BigInt(this[++wt] * 2 ** 24 + this[++wt] * 2 ** 16 + this[++wt] * 2 ** 8 + Ct);
  }), re.prototype.readFloatLE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 4, this.length), L.read(this, wt, !0, 23, 4);
  }, re.prototype.readFloatBE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 4, this.length), L.read(this, wt, !1, 23, 4);
  }, re.prototype.readDoubleLE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 8, this.length), L.read(this, wt, !0, 52, 8);
  }, re.prototype.readDoubleBE = function(wt, Et) {
    return wt = wt >>> 0, Et || Ft(wt, 8, this.length), L.read(this, wt, !1, 52, 8);
  };
  function Gt(Mt, wt, Et, Ct, Kt, Vt) {
    if (!re.isBuffer(Mt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (wt > Kt || wt < Vt) throw new RangeError('"value" argument is out of bounds');
    if (Et + Ct > Mt.length) throw new RangeError("Index out of range");
  }
  re.prototype.writeUintLE = re.prototype.writeUIntLE = function(wt, Et, Ct, Kt) {
    if (wt = +wt, Et = Et >>> 0, Ct = Ct >>> 0, !Kt) {
      const yr = Math.pow(2, 8 * Ct) - 1;
      Gt(this, wt, Et, Ct, yr, 0);
    }
    let Vt = 1, zt = 0;
    for (this[Et] = wt & 255; ++zt < Ct && (Vt *= 256); )
      this[Et + zt] = wt / Vt & 255;
    return Et + Ct;
  }, re.prototype.writeUintBE = re.prototype.writeUIntBE = function(wt, Et, Ct, Kt) {
    if (wt = +wt, Et = Et >>> 0, Ct = Ct >>> 0, !Kt) {
      const yr = Math.pow(2, 8 * Ct) - 1;
      Gt(this, wt, Et, Ct, yr, 0);
    }
    let Vt = Ct - 1, zt = 1;
    for (this[Et + Vt] = wt & 255; --Vt >= 0 && (zt *= 256); )
      this[Et + Vt] = wt / zt & 255;
    return Et + Ct;
  }, re.prototype.writeUint8 = re.prototype.writeUInt8 = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 1, 255, 0), this[Et] = wt & 255, Et + 1;
  }, re.prototype.writeUint16LE = re.prototype.writeUInt16LE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 2, 65535, 0), this[Et] = wt & 255, this[Et + 1] = wt >>> 8, Et + 2;
  }, re.prototype.writeUint16BE = re.prototype.writeUInt16BE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 2, 65535, 0), this[Et] = wt >>> 8, this[Et + 1] = wt & 255, Et + 2;
  }, re.prototype.writeUint32LE = re.prototype.writeUInt32LE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 4, 4294967295, 0), this[Et + 3] = wt >>> 24, this[Et + 2] = wt >>> 16, this[Et + 1] = wt >>> 8, this[Et] = wt & 255, Et + 4;
  }, re.prototype.writeUint32BE = re.prototype.writeUInt32BE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 4, 4294967295, 0), this[Et] = wt >>> 24, this[Et + 1] = wt >>> 16, this[Et + 2] = wt >>> 8, this[Et + 3] = wt & 255, Et + 4;
  };
  function qt(Mt, wt, Et, Ct, Kt) {
    er(wt, Ct, Kt, Mt, Et, 7);
    let Vt = Number(wt & BigInt(4294967295));
    Mt[Et++] = Vt, Vt = Vt >> 8, Mt[Et++] = Vt, Vt = Vt >> 8, Mt[Et++] = Vt, Vt = Vt >> 8, Mt[Et++] = Vt;
    let zt = Number(wt >> BigInt(32) & BigInt(4294967295));
    return Mt[Et++] = zt, zt = zt >> 8, Mt[Et++] = zt, zt = zt >> 8, Mt[Et++] = zt, zt = zt >> 8, Mt[Et++] = zt, Et;
  }
  function Pt(Mt, wt, Et, Ct, Kt) {
    er(wt, Ct, Kt, Mt, Et, 7);
    let Vt = Number(wt & BigInt(4294967295));
    Mt[Et + 7] = Vt, Vt = Vt >> 8, Mt[Et + 6] = Vt, Vt = Vt >> 8, Mt[Et + 5] = Vt, Vt = Vt >> 8, Mt[Et + 4] = Vt;
    let zt = Number(wt >> BigInt(32) & BigInt(4294967295));
    return Mt[Et + 3] = zt, zt = zt >> 8, Mt[Et + 2] = zt, zt = zt >> 8, Mt[Et + 1] = zt, zt = zt >> 8, Mt[Et] = zt, Et + 8;
  }
  re.prototype.writeBigUInt64LE = Rr(function(wt, Et = 0) {
    return qt(this, wt, Et, BigInt(0), BigInt("0xffffffffffffffff"));
  }), re.prototype.writeBigUInt64BE = Rr(function(wt, Et = 0) {
    return Pt(this, wt, Et, BigInt(0), BigInt("0xffffffffffffffff"));
  }), re.prototype.writeIntLE = function(wt, Et, Ct, Kt) {
    if (wt = +wt, Et = Et >>> 0, !Kt) {
      const $r = Math.pow(2, 8 * Ct - 1);
      Gt(this, wt, Et, Ct, $r - 1, -$r);
    }
    let Vt = 0, zt = 1, yr = 0;
    for (this[Et] = wt & 255; ++Vt < Ct && (zt *= 256); )
      wt < 0 && yr === 0 && this[Et + Vt - 1] !== 0 && (yr = 1), this[Et + Vt] = (wt / zt >> 0) - yr & 255;
    return Et + Ct;
  }, re.prototype.writeIntBE = function(wt, Et, Ct, Kt) {
    if (wt = +wt, Et = Et >>> 0, !Kt) {
      const $r = Math.pow(2, 8 * Ct - 1);
      Gt(this, wt, Et, Ct, $r - 1, -$r);
    }
    let Vt = Ct - 1, zt = 1, yr = 0;
    for (this[Et + Vt] = wt & 255; --Vt >= 0 && (zt *= 256); )
      wt < 0 && yr === 0 && this[Et + Vt + 1] !== 0 && (yr = 1), this[Et + Vt] = (wt / zt >> 0) - yr & 255;
    return Et + Ct;
  }, re.prototype.writeInt8 = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 1, 127, -128), wt < 0 && (wt = 255 + wt + 1), this[Et] = wt & 255, Et + 1;
  }, re.prototype.writeInt16LE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 2, 32767, -32768), this[Et] = wt & 255, this[Et + 1] = wt >>> 8, Et + 2;
  }, re.prototype.writeInt16BE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 2, 32767, -32768), this[Et] = wt >>> 8, this[Et + 1] = wt & 255, Et + 2;
  }, re.prototype.writeInt32LE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 4, 2147483647, -2147483648), this[Et] = wt & 255, this[Et + 1] = wt >>> 8, this[Et + 2] = wt >>> 16, this[Et + 3] = wt >>> 24, Et + 4;
  }, re.prototype.writeInt32BE = function(wt, Et, Ct) {
    return wt = +wt, Et = Et >>> 0, Ct || Gt(this, wt, Et, 4, 2147483647, -2147483648), wt < 0 && (wt = 4294967295 + wt + 1), this[Et] = wt >>> 24, this[Et + 1] = wt >>> 16, this[Et + 2] = wt >>> 8, this[Et + 3] = wt & 255, Et + 4;
  }, re.prototype.writeBigInt64LE = Rr(function(wt, Et = 0) {
    return qt(this, wt, Et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), re.prototype.writeBigInt64BE = Rr(function(wt, Et = 0) {
    return Pt(this, wt, Et, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Tt(Mt, wt, Et, Ct, Kt, Vt) {
    if (Et + Ct > Mt.length) throw new RangeError("Index out of range");
    if (Et < 0) throw new RangeError("Index out of range");
  }
  function Ut(Mt, wt, Et, Ct, Kt) {
    return wt = +wt, Et = Et >>> 0, Kt || Tt(Mt, wt, Et, 4), L.write(Mt, wt, Et, Ct, 23, 4), Et + 4;
  }
  re.prototype.writeFloatLE = function(wt, Et, Ct) {
    return Ut(this, wt, Et, !0, Ct);
  }, re.prototype.writeFloatBE = function(wt, Et, Ct) {
    return Ut(this, wt, Et, !1, Ct);
  };
  function Wt(Mt, wt, Et, Ct, Kt) {
    return wt = +wt, Et = Et >>> 0, Kt || Tt(Mt, wt, Et, 8), L.write(Mt, wt, Et, Ct, 52, 8), Et + 8;
  }
  re.prototype.writeDoubleLE = function(wt, Et, Ct) {
    return Wt(this, wt, Et, !0, Ct);
  }, re.prototype.writeDoubleBE = function(wt, Et, Ct) {
    return Wt(this, wt, Et, !1, Ct);
  }, re.prototype.copy = function(wt, Et, Ct, Kt) {
    if (!re.isBuffer(wt)) throw new TypeError("argument should be a Buffer");
    if (Ct || (Ct = 0), !Kt && Kt !== 0 && (Kt = this.length), Et >= wt.length && (Et = wt.length), Et || (Et = 0), Kt > 0 && Kt < Ct && (Kt = Ct), Kt === Ct || wt.length === 0 || this.length === 0) return 0;
    if (Et < 0)
      throw new RangeError("targetStart out of bounds");
    if (Ct < 0 || Ct >= this.length) throw new RangeError("Index out of range");
    if (Kt < 0) throw new RangeError("sourceEnd out of bounds");
    Kt > this.length && (Kt = this.length), wt.length - Et < Kt - Ct && (Kt = wt.length - Et + Ct);
    const Vt = Kt - Ct;
    return this === wt && typeof W.prototype.copyWithin == "function" ? this.copyWithin(Et, Ct, Kt) : W.prototype.set.call(
      wt,
      this.subarray(Ct, Kt),
      Et
    ), Vt;
  }, re.prototype.fill = function(wt, Et, Ct, Kt) {
    if (typeof wt == "string") {
      if (typeof Et == "string" ? (Kt = Et, Et = 0, Ct = this.length) : typeof Ct == "string" && (Kt = Ct, Ct = this.length), Kt !== void 0 && typeof Kt != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Kt == "string" && !re.isEncoding(Kt))
        throw new TypeError("Unknown encoding: " + Kt);
      if (wt.length === 1) {
        const zt = wt.charCodeAt(0);
        (Kt === "utf8" && zt < 128 || Kt === "latin1") && (wt = zt);
      }
    } else typeof wt == "number" ? wt = wt & 255 : typeof wt == "boolean" && (wt = Number(wt));
    if (Et < 0 || this.length < Et || this.length < Ct)
      throw new RangeError("Out of range index");
    if (Ct <= Et)
      return this;
    Et = Et >>> 0, Ct = Ct === void 0 ? this.length : Ct >>> 0, wt || (wt = 0);
    let Vt;
    if (typeof wt == "number")
      for (Vt = Et; Vt < Ct; ++Vt)
        this[Vt] = wt;
    else {
      const zt = re.isBuffer(wt) ? wt : re.from(wt, Kt), yr = zt.length;
      if (yr === 0)
        throw new TypeError('The value "' + wt + '" is invalid for argument "value"');
      for (Vt = 0; Vt < Ct - Et; ++Vt)
        this[Vt + Et] = zt[Vt % yr];
    }
    return this;
  };
  const It = {};
  function Rt(Mt, wt, Et) {
    It[Mt] = class extends Et {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: wt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Mt}]`, this.stack, delete this.name;
      }
      get code() {
        return Mt;
      }
      set code(Kt) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: Kt,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Mt}]: ${this.message}`;
      }
    };
  }
  Rt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Mt) {
      return Mt ? `${Mt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Rt(
    "ERR_INVALID_ARG_TYPE",
    function(Mt, wt) {
      return `The "${Mt}" argument must be of type number. Received type ${typeof wt}`;
    },
    TypeError
  ), Rt(
    "ERR_OUT_OF_RANGE",
    function(Mt, wt, Et) {
      let Ct = `The value of "${Mt}" is out of range.`, Kt = Et;
      return Number.isInteger(Et) && Math.abs(Et) > 2 ** 32 ? Kt = jt(String(Et)) : typeof Et == "bigint" && (Kt = String(Et), (Et > BigInt(2) ** BigInt(32) || Et < -(BigInt(2) ** BigInt(32))) && (Kt = jt(Kt)), Kt += "n"), Ct += ` It must be ${wt}. Received ${Kt}`, Ct;
    },
    RangeError
  );
  function jt(Mt) {
    let wt = "", Et = Mt.length;
    const Ct = Mt[0] === "-" ? 1 : 0;
    for (; Et >= Ct + 4; Et -= 3)
      wt = `_${Mt.slice(Et - 3, Et)}${wt}`;
    return `${Mt.slice(0, Et)}${wt}`;
  }
  function Jt(Mt, wt, Et) {
    nr(wt, "offset"), (Mt[wt] === void 0 || Mt[wt + Et] === void 0) && fr(wt, Mt.length - (Et + 1));
  }
  function er(Mt, wt, Et, Ct, Kt, Vt) {
    if (Mt > Et || Mt < wt) {
      const zt = typeof wt == "bigint" ? "n" : "";
      let yr;
      throw wt === 0 || wt === BigInt(0) ? yr = `>= 0${zt} and < 2${zt} ** ${(Vt + 1) * 8}${zt}` : yr = `>= -(2${zt} ** ${(Vt + 1) * 8 - 1}${zt}) and < 2 ** ${(Vt + 1) * 8 - 1}${zt}`, new It.ERR_OUT_OF_RANGE("value", yr, Mt);
    }
    Jt(Ct, Kt, Vt);
  }
  function nr(Mt, wt) {
    if (typeof Mt != "number")
      throw new It.ERR_INVALID_ARG_TYPE(wt, "number", Mt);
  }
  function fr(Mt, wt, Et) {
    throw Math.floor(Mt) !== Mt ? (nr(Mt, Et), new It.ERR_OUT_OF_RANGE("offset", "an integer", Mt)) : wt < 0 ? new It.ERR_BUFFER_OUT_OF_BOUNDS() : new It.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${wt}`,
      Mt
    );
  }
  const lr = /[^+/0-9A-Za-z-_]/g;
  function Yt(Mt) {
    if (Mt = Mt.split("=")[0], Mt = Mt.trim().replace(lr, ""), Mt.length < 2) return "";
    for (; Mt.length % 4 !== 0; )
      Mt = Mt + "=";
    return Mt;
  }
  function Pr(Mt, wt) {
    wt = wt || 1 / 0;
    let Et;
    const Ct = Mt.length;
    let Kt = null;
    const Vt = [];
    for (let zt = 0; zt < Ct; ++zt) {
      if (Et = Mt.charCodeAt(zt), Et > 55295 && Et < 57344) {
        if (!Kt) {
          if (Et > 56319) {
            (wt -= 3) > -1 && Vt.push(239, 191, 189);
            continue;
          } else if (zt + 1 === Ct) {
            (wt -= 3) > -1 && Vt.push(239, 191, 189);
            continue;
          }
          Kt = Et;
          continue;
        }
        if (Et < 56320) {
          (wt -= 3) > -1 && Vt.push(239, 191, 189), Kt = Et;
          continue;
        }
        Et = (Kt - 55296 << 10 | Et - 56320) + 65536;
      } else Kt && (wt -= 3) > -1 && Vt.push(239, 191, 189);
      if (Kt = null, Et < 128) {
        if ((wt -= 1) < 0) break;
        Vt.push(Et);
      } else if (Et < 2048) {
        if ((wt -= 2) < 0) break;
        Vt.push(
          Et >> 6 | 192,
          Et & 63 | 128
        );
      } else if (Et < 65536) {
        if ((wt -= 3) < 0) break;
        Vt.push(
          Et >> 12 | 224,
          Et >> 6 & 63 | 128,
          Et & 63 | 128
        );
      } else if (Et < 1114112) {
        if ((wt -= 4) < 0) break;
        Vt.push(
          Et >> 18 | 240,
          Et >> 12 & 63 | 128,
          Et >> 6 & 63 | 128,
          Et & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Vt;
  }
  function or(Mt) {
    const wt = [];
    for (let Et = 0; Et < Mt.length; ++Et)
      wt.push(Mt.charCodeAt(Et) & 255);
    return wt;
  }
  function Ar(Mt, wt) {
    let Et, Ct, Kt;
    const Vt = [];
    for (let zt = 0; zt < Mt.length && !((wt -= 2) < 0); ++zt)
      Et = Mt.charCodeAt(zt), Ct = Et >> 8, Kt = Et % 256, Vt.push(Kt), Vt.push(Ct);
    return Vt;
  }
  function Br(Mt) {
    return B.toByteArray(Yt(Mt));
  }
  function cr(Mt, wt, Et, Ct) {
    let Kt;
    for (Kt = 0; Kt < Ct && !(Kt + Et >= wt.length || Kt >= Mt.length); ++Kt)
      wt[Kt + Et] = Mt[Kt];
    return Kt;
  }
  function xr(Mt, wt) {
    return Mt instanceof wt || Mt != null && Mt.constructor != null && Mt.constructor.name != null && Mt.constructor.name === wt.name;
  }
  function Ir(Mt) {
    return Mt !== Mt;
  }
  const gr = function() {
    const Mt = "0123456789abcdef", wt = new Array(256);
    for (let Et = 0; Et < 16; ++Et) {
      const Ct = Et * 16;
      for (let Kt = 0; Kt < 16; ++Kt)
        wt[Ct + Kt] = Mt[Et] + Mt[Kt];
    }
    return wt;
  }();
  function Rr(Mt) {
    return typeof BigInt > "u" ? Or : Mt;
  }
  function Or() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var store2;
function getGlobalMessage(A) {
  return store2 == null ? void 0 : store2.get(A);
}
var store3;
function getSchemaMessage(A) {
  return store3 == null ? void 0 : store3.get(A);
}
var store4;
function getSpecificMessage(A, B) {
  var L;
  return (L = store4 == null ? void 0 : store4.get(A)) == null ? void 0 : L.get(B);
}
function _stringify(A) {
  var L, K;
  const B = typeof A;
  return B === "string" ? `"${A}"` : B === "number" || B === "bigint" || B === "boolean" ? `${A}` : B === "object" || B === "function" ? (A && ((K = (L = Object.getPrototypeOf(A)) == null ? void 0 : L.constructor) == null ? void 0 : K.name)) ?? "null" : B;
}
function _addIssue(A, B, L, K, V) {
  const W = V && "input" in V ? V.input : L.value, J = (V == null ? void 0 : V.expected) ?? A.expects ?? null, ne = (V == null ? void 0 : V.received) ?? _stringify(W), ie = {
    kind: A.kind,
    type: A.type,
    input: W,
    expected: J,
    received: ne,
    message: `Invalid ${B}: ${J ? `Expected ${J} but r` : "R"}eceived ${ne}`,
    requirement: A.requirement,
    path: V == null ? void 0 : V.path,
    issues: V == null ? void 0 : V.issues,
    lang: K.lang,
    abortEarly: K.abortEarly,
    abortPipeEarly: K.abortPipeEarly
  }, ce = A.kind === "schema", re = (V == null ? void 0 : V.message) ?? A.message ?? getSpecificMessage(A.reference, ie.lang) ?? (ce ? getSchemaMessage(ie.lang) : null) ?? K.message ?? getGlobalMessage(ie.lang);
  re && (ie.message = typeof re == "function" ? (
    // @ts-expect-error
    re(ie)
  ) : re), ce && (L.typed = !1), L.issues ? L.issues.push(ie) : L.issues = [ie];
}
function _isValidObjectKey(A, B) {
  return Object.hasOwn(A, B) && B !== "__proto__" && B !== "prototype" && B !== "constructor";
}
function _joinExpects(A, B) {
  const L = [...new Set(A)];
  return L.length > 1 ? `(${L.join(` ${B} `)})` : L[0] ?? "never";
}
function check$e(A, B) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: A,
    message: B,
    _run(L, K) {
      return L.typed && !this.requirement(L.value) && _addIssue(this, "input", L, K), L;
    }
  };
}
function maxLength(A, B) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${A}`,
    requirement: A,
    message: B,
    _run(L, K) {
      return L.typed && L.value.length > this.requirement && _addIssue(this, "length", L, K, {
        received: `${L.value.length}`
      }), L;
    }
  };
}
function minLength(A, B) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${A}`,
    requirement: A,
    message: B,
    _run(L, K) {
      return L.typed && L.value.length < this.requirement && _addIssue(this, "length", L, K, {
        received: `${L.value.length}`
      }), L;
    }
  };
}
function getDefault(A, B, L) {
  return typeof A.default == "function" ? (
    // @ts-expect-error
    A.default(B, L)
  ) : (
    // @ts-expect-error
    A.default
  );
}
function array(A, B) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: A,
    message: B,
    _run(L, K) {
      var W;
      const V = L.value;
      if (Array.isArray(V)) {
        L.typed = !0, L.value = [];
        for (let J = 0; J < V.length; J++) {
          const ne = V[J], ie = this.item._run({ typed: !1, value: ne }, K);
          if (ie.issues) {
            const ce = {
              type: "array",
              origin: "value",
              input: V,
              key: J,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(ce) : re.path = [ce], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), L.value.push(ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function boolean(A) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "boolean" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function enum_(A, B) {
  const L = Object.entries(A).filter(([K]) => isNaN(+K)).map(([, K]) => K);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(L.map(_stringify), "|"),
    async: !1,
    enum: A,
    options: L,
    message: B,
    _run(K, V) {
      return this.options.includes(K.value) ? K.typed = !0 : _addIssue(this, "type", K, V), K;
    }
  };
}
function literal(A, B) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(A),
    async: !1,
    literal: A,
    message: B,
    _run(L, K) {
      return L.value === this.literal ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function looseObject(A, B) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const V = L.value;
      if (V && typeof V == "object") {
        L.typed = !0, L.value = {};
        for (const J in this.entries) {
          const ne = V[J], ie = this.entries[J]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const ce = {
              type: "object",
              origin: "value",
              input: V,
              key: J,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(ce) : re.path = [ce], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || J in V) && (L.value[J] = ie.value);
        }
        if (!L.issues || !K.abortEarly)
          for (const J in V)
            _isValidObjectKey(V, J) && !(J in this.entries) && (L.value[J] = V[J]);
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function nonOptional(A, B) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: A,
    message: B,
    _run(L, K) {
      return L.value === void 0 ? (_addIssue(this, "type", L, K), L) : this.wrapped._run(L, K);
    }
  };
}
function null_(A) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: A,
    _run(B, L) {
      return B.value === null ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function nullish(A, ...B) {
  const L = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${A.expects} | null | undefined)`,
    async: !1,
    wrapped: A,
    _run(K, V) {
      return (K.value === null || K.value === void 0) && ("default" in this && (K.value = getDefault(
        this,
        K,
        V
      )), K.value === null || K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, V);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function number(A) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "number" && !isNaN(B.value) ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function object(A, B) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: A,
    message: B,
    _run(L, K) {
      var W;
      const V = L.value;
      if (V && typeof V == "object") {
        L.typed = !0, L.value = {};
        for (const J in this.entries) {
          const ne = V[J], ie = this.entries[J]._run(
            { typed: !1, value: ne },
            K
          );
          if (ie.issues) {
            const ce = {
              type: "object",
              origin: "value",
              input: V,
              key: J,
              value: ne
            };
            for (const re of ie.issues)
              re.path ? re.path.unshift(ce) : re.path = [ce], (W = L.issues) == null || W.push(re);
            if (L.issues || (L.issues = ie.issues), K.abortEarly) {
              L.typed = !1;
              break;
            }
          }
          ie.typed || (L.typed = !1), (ie.value !== void 0 || J in V) && (L.value[J] = ie.value);
        }
      } else
        _addIssue(this, "type", L, K);
      return L;
    }
  };
}
function optional(A, ...B) {
  const L = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${A.expects} | undefined)`,
    async: !1,
    wrapped: A,
    _run(K, V) {
      return K.value === void 0 && ("default" in this && (K.value = getDefault(
        this,
        K,
        V
      )), K.value === void 0) ? (K.typed = !0, K) : this.wrapped._run(K, V);
    }
  };
  return 0 in B && (L.default = B[0]), L;
}
function picklist(A, B) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(A.map(_stringify), "|"),
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      return this.options.includes(L.value) ? L.typed = !0 : _addIssue(this, "type", L, K), L;
    }
  };
}
function record(A, B, L) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: A,
    value: B,
    message: L,
    _run(K, V) {
      var J, ne;
      const W = K.value;
      if (W && typeof W == "object") {
        K.typed = !0, K.value = {};
        for (const ie in W)
          if (_isValidObjectKey(W, ie)) {
            const ce = W[ie], re = this.key._run(
              { typed: !1, value: ie },
              V
            );
            if (re.issues) {
              const ke = {
                type: "object",
                origin: "key",
                input: W,
                key: ie,
                value: ce
              };
              for (const Oe of re.issues)
                Oe.path = [ke], (J = K.issues) == null || J.push(Oe);
              if (K.issues || (K.issues = re.issues), V.abortEarly) {
                K.typed = !1;
                break;
              }
            }
            const oe = this.value._run(
              { typed: !1, value: ce },
              V
            );
            if (oe.issues) {
              const ke = {
                type: "object",
                origin: "value",
                input: W,
                key: ie,
                value: ce
              };
              for (const Oe of oe.issues)
                Oe.path ? Oe.path.unshift(ke) : Oe.path = [ke], (ne = K.issues) == null || ne.push(Oe);
              if (K.issues || (K.issues = oe.issues), V.abortEarly) {
                K.typed = !1;
                break;
              }
            }
            (!re.typed || !oe.typed) && (K.typed = !1), re.typed && (K.value[re.value] = oe.value);
          }
      } else
        _addIssue(this, "type", K, V);
      return K;
    }
  };
}
function string(A) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: A,
    _run(B, L) {
      return typeof B.value == "string" ? B.typed = !0 : _addIssue(this, "type", B, L), B;
    }
  };
}
function _subIssues(A) {
  let B;
  if (A)
    for (const L of A)
      B ? B.push(...L.issues) : B = L.issues;
  return B;
}
function union(A, B) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      A.map((L) => L.expects),
      "|"
    ),
    async: !1,
    options: A,
    message: B,
    _run(L, K) {
      let V, W, J;
      for (const ne of this.options) {
        const ie = ne._run(
          { typed: !1, value: L.value },
          K
        );
        if (ie.typed)
          if (ie.issues)
            W ? W.push(ie) : W = [ie];
          else {
            V = ie;
            break;
          }
        else
          J ? J.push(ie) : J = [ie];
      }
      if (V)
        return V;
      if (W) {
        if (W.length === 1)
          return W[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(W)
        }), L.typed = !0;
      } else {
        if ((J == null ? void 0 : J.length) === 1)
          return J[0];
        _addIssue(this, "type", L, K, {
          issues: _subIssues(J)
        });
      }
      return L;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(A) {
      return A.typed = !0, A;
    }
  };
}
function variant(A, B, L) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: A,
    options: B,
    message: L,
    _run(K, V) {
      const W = K.value;
      if (W && typeof W == "object") {
        let J, ne = 0, ie = this.key, ce = [];
        const re = (oe, ke) => {
          for (const Oe of oe.options) {
            if (Oe.type === "variant")
              re(Oe, new Set(ke).add(Oe.key));
            else {
              let it = !0, at = 0;
              for (const ut of ke) {
                if (Oe.entries[ut]._run(
                  // @ts-expect-error
                  { typed: !1, value: W[ut] },
                  V
                ).issues) {
                  it = !1, ie !== ut && (ne < at || ne === at && ut in W && !(ie in W)) && (ne = at, ie = ut, ce = []), ie === ut && ce.push(
                    Oe.entries[ut].expects
                  );
                  break;
                }
                at++;
              }
              if (it) {
                const ut = Oe._run(
                  { typed: !1, value: W },
                  V
                );
                (!J || !J.typed && ut.typed) && (J = ut);
              }
            }
            if (J && !J.issues)
              break;
          }
        };
        if (re(this, /* @__PURE__ */ new Set([this.key])), J)
          return J;
        _addIssue(this, "type", K, V, {
          // @ts-expect-error
          input: W[ie],
          expected: _joinExpects(ce, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: W,
              key: ie,
              // @ts-expect-error
              value: W[ie]
            }
          ]
        });
      } else
        _addIssue(this, "type", K, V);
      return K;
    }
  };
}
function omit(A, B) {
  const L = {
    ...A.entries
  };
  for (const K of B)
    delete L[K];
  return { ...A, entries: L };
}
function pipe(...A) {
  return {
    ...A[0],
    pipe: A,
    _run(B, L) {
      for (const K of A)
        if (K.kind !== "metadata") {
          if (B.issues && (K.kind === "schema" || K.kind === "transformation")) {
            B.typed = !1;
            break;
          }
          (!B.issues || !L.abortEarly && !L.abortPipeEarly) && (B = K._run(B, L));
        }
      return B;
    }
  };
}
function unwrap(A) {
  return A.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(A) {
  var B = A.length;
  if (B % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var L = A.indexOf("=");
  L === -1 && (L = B);
  var K = L === B ? 0 : 4 - L % 4;
  return [L, K];
}
function byteLength(A) {
  var B = getLens(A), L = B[0], K = B[1];
  return (L + K) * 3 / 4 - K;
}
function _byteLength(A, B, L) {
  return (B + L) * 3 / 4 - L;
}
function toByteArray(A) {
  var B, L = getLens(A), K = L[0], V = L[1], W = new Arr(_byteLength(A, K, V)), J = 0, ne = V > 0 ? K - 4 : K, ie;
  for (ie = 0; ie < ne; ie += 4)
    B = revLookup[A.charCodeAt(ie)] << 18 | revLookup[A.charCodeAt(ie + 1)] << 12 | revLookup[A.charCodeAt(ie + 2)] << 6 | revLookup[A.charCodeAt(ie + 3)], W[J++] = B >> 16 & 255, W[J++] = B >> 8 & 255, W[J++] = B & 255;
  return V === 2 && (B = revLookup[A.charCodeAt(ie)] << 2 | revLookup[A.charCodeAt(ie + 1)] >> 4, W[J++] = B & 255), V === 1 && (B = revLookup[A.charCodeAt(ie)] << 10 | revLookup[A.charCodeAt(ie + 1)] << 4 | revLookup[A.charCodeAt(ie + 2)] >> 2, W[J++] = B >> 8 & 255, W[J++] = B & 255), W;
}
function tripletToBase64(A) {
  return lookup[A >> 18 & 63] + lookup[A >> 12 & 63] + lookup[A >> 6 & 63] + lookup[A & 63];
}
function encodeChunk(A, B, L) {
  for (var K, V = [], W = B; W < L; W += 3)
    K = (A[W] << 16 & 16711680) + (A[W + 1] << 8 & 65280) + (A[W + 2] & 255), V.push(tripletToBase64(K));
  return V.join("");
}
function fromByteArray(A) {
  for (var B, L = A.length, K = L % 3, V = [], W = 16383, J = 0, ne = L - K; J < ne; J += W)
    V.push(encodeChunk(A, J, J + W > ne ? ne : J + W));
  return K === 1 ? (B = A[L - 1], V.push(
    lookup[B >> 2] + lookup[B << 4 & 63] + "=="
  )) : K === 2 && (B = (A[L - 2] << 8) + A[L - 1], V.push(
    lookup[B >> 10] + lookup[B >> 4 & 63] + lookup[B << 2 & 63] + "="
  )), V.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(A) {
  return `${A}${"=".repeat(4 - (A.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(A) {
  return A.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(A) {
  return pad(A).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(A) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(A)));
}
base64Url.encode = encode$j;
function decode$j(A) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(A))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(A) {
  if (!Number.isSafeInteger(A) || A < 0)
    throw new Error("positive integer expected, got " + A);
}
function isBytes(A) {
  return A instanceof Uint8Array || ArrayBuffer.isView(A) && A.constructor.name === "Uint8Array";
}
function abytes(A, ...B) {
  if (!isBytes(A))
    throw new Error("Uint8Array expected");
  if (B.length > 0 && !B.includes(A.length))
    throw new Error("Uint8Array expected of length " + B + ", got length=" + A.length);
}
function ahash(A) {
  if (typeof A != "function" || typeof A.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(A.outputLen), anumber(A.blockLen);
}
function aexists(A, B = !0) {
  if (A.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (B && A.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(A, B) {
  abytes(A);
  const L = B.outputLen;
  if (A.length < L)
    throw new Error("digestInto() expects output buffer of length at least " + L);
}
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(A) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.Hash = A.nextTick = A.byteSwapIfBE = A.isLE = void 0, A.isBytes = K, A.u8 = V, A.u32 = W, A.createView = J, A.rotr = ne, A.rotl = ie, A.byteSwap = ce, A.byteSwap32 = re, A.bytesToHex = ke, A.hexToBytes = at, A.asyncLoop = dt, A.utf8ToBytes = ct, A.toBytes = bt, A.concatBytes = vt, A.checkOpts = xt, A.wrapConstructor = Ot, A.wrapConstructorWithOpts = At, A.wrapXOFConstructorWithOpts = yt, A.randomBytes = Bt;
  const B = crypto$2, L = _assert;
  function K(gt) {
    return gt instanceof Uint8Array || ArrayBuffer.isView(gt) && gt.constructor.name === "Uint8Array";
  }
  function V(gt) {
    return new Uint8Array(gt.buffer, gt.byteOffset, gt.byteLength);
  }
  function W(gt) {
    return new Uint32Array(gt.buffer, gt.byteOffset, Math.floor(gt.byteLength / 4));
  }
  function J(gt) {
    return new DataView(gt.buffer, gt.byteOffset, gt.byteLength);
  }
  function ne(gt, rt) {
    return gt << 32 - rt | gt >>> rt;
  }
  function ie(gt, rt) {
    return gt << rt | gt >>> 32 - rt >>> 0;
  }
  A.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function ce(gt) {
    return gt << 24 & 4278190080 | gt << 8 & 16711680 | gt >>> 8 & 65280 | gt >>> 24 & 255;
  }
  A.byteSwapIfBE = A.isLE ? (gt) => gt : (gt) => ce(gt);
  function re(gt) {
    for (let rt = 0; rt < gt.length; rt++)
      gt[rt] = ce(gt[rt]);
  }
  const oe = /* @__PURE__ */ Array.from({ length: 256 }, (gt, rt) => rt.toString(16).padStart(2, "0"));
  function ke(gt) {
    (0, L.abytes)(gt);
    let rt = "";
    for (let Ce = 0; Ce < gt.length; Ce++)
      rt += oe[gt[Ce]];
    return rt;
  }
  const Oe = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function it(gt) {
    if (gt >= Oe._0 && gt <= Oe._9)
      return gt - Oe._0;
    if (gt >= Oe.A && gt <= Oe.F)
      return gt - (Oe.A - 10);
    if (gt >= Oe.a && gt <= Oe.f)
      return gt - (Oe.a - 10);
  }
  function at(gt) {
    if (typeof gt != "string")
      throw new Error("hex string expected, got " + typeof gt);
    const rt = gt.length, Ce = rt / 2;
    if (rt % 2)
      throw new Error("hex string expected, got unpadded hex of length " + rt);
    const pe = new Uint8Array(Ce);
    for (let nt = 0, st = 0; nt < Ce; nt++, st += 2) {
      const ot = it(gt.charCodeAt(st)), ht = it(gt.charCodeAt(st + 1));
      if (ot === void 0 || ht === void 0) {
        const pt = gt[st] + gt[st + 1];
        throw new Error('hex string expected, got non-hex character "' + pt + '" at index ' + st);
      }
      pe[nt] = ot * 16 + ht;
    }
    return pe;
  }
  const ut = async () => {
  };
  A.nextTick = ut;
  async function dt(gt, rt, Ce) {
    let pe = Date.now();
    for (let nt = 0; nt < gt; nt++) {
      Ce(nt);
      const st = Date.now() - pe;
      st >= 0 && st < rt || (await (0, A.nextTick)(), pe += st);
    }
  }
  function ct(gt) {
    if (typeof gt != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof gt);
    return new Uint8Array(new TextEncoder().encode(gt));
  }
  function bt(gt) {
    return typeof gt == "string" && (gt = ct(gt)), (0, L.abytes)(gt), gt;
  }
  function vt(...gt) {
    let rt = 0;
    for (let pe = 0; pe < gt.length; pe++) {
      const nt = gt[pe];
      (0, L.abytes)(nt), rt += nt.length;
    }
    const Ce = new Uint8Array(rt);
    for (let pe = 0, nt = 0; pe < gt.length; pe++) {
      const st = gt[pe];
      Ce.set(st, nt), nt += st.length;
    }
    return Ce;
  }
  class $t {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  A.Hash = $t;
  function xt(gt, rt) {
    if (rt !== void 0 && {}.toString.call(rt) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(gt, rt);
  }
  function Ot(gt) {
    const rt = (pe) => gt().update(bt(pe)).digest(), Ce = gt();
    return rt.outputLen = Ce.outputLen, rt.blockLen = Ce.blockLen, rt.create = () => gt(), rt;
  }
  function At(gt) {
    const rt = (pe, nt) => gt(nt).update(bt(pe)).digest(), Ce = gt({});
    return rt.outputLen = Ce.outputLen, rt.blockLen = Ce.blockLen, rt.create = (pe) => gt(pe), rt;
  }
  function yt(gt) {
    const rt = (pe, nt) => gt(nt).update(bt(pe)).digest(), Ce = gt({});
    return rt.outputLen = Ce.outputLen, rt.blockLen = Ce.blockLen, rt.create = (pe) => gt(pe), rt;
  }
  function Bt(gt = 32) {
    if (B.crypto && typeof B.crypto.getRandomValues == "function")
      return B.crypto.getRandomValues(new Uint8Array(gt));
    if (B.crypto && typeof B.crypto.randomBytes == "function")
      return B.crypto.randomBytes(gt);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.hmac = A.HMAC = void 0;
  const B = _assert, L = utils$5;
  class K extends L.Hash {
    constructor(J, ne) {
      super(), this.finished = !1, this.destroyed = !1, (0, B.ahash)(J);
      const ie = (0, L.toBytes)(ne);
      if (this.iHash = J.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ce = this.blockLen, re = new Uint8Array(ce);
      re.set(ie.length > ce ? J.create().update(ie).digest() : ie);
      for (let oe = 0; oe < re.length; oe++)
        re[oe] ^= 54;
      this.iHash.update(re), this.oHash = J.create();
      for (let oe = 0; oe < re.length; oe++)
        re[oe] ^= 106;
      this.oHash.update(re), re.fill(0);
    }
    update(J) {
      return (0, B.aexists)(this), this.iHash.update(J), this;
    }
    digestInto(J) {
      (0, B.aexists)(this), (0, B.abytes)(J, this.outputLen), this.finished = !0, this.iHash.digestInto(J), this.oHash.update(J), this.oHash.digestInto(J), this.destroy();
    }
    digest() {
      const J = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(J), J;
    }
    _cloneInto(J) {
      J || (J = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: ne, iHash: ie, finished: ce, destroyed: re, blockLen: oe, outputLen: ke } = this;
      return J = J, J.finished = ce, J.destroyed = re, J.blockLen = oe, J.outputLen = ke, J.oHash = ne._cloneInto(J.oHash), J.iHash = ie._cloneInto(J.iHash), J;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  A.HMAC = K;
  const V = (W, J, ne) => new K(W, J).update(ne).digest();
  A.hmac = V, A.hmac.create = (W, J) => new K(W, J);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(A, B, L, K) {
  if (typeof A.setBigUint64 == "function")
    return A.setBigUint64(B, L, K);
  const V = BigInt(32), W = BigInt(4294967295), J = Number(L >> V & W), ne = Number(L & W), ie = K ? 4 : 0, ce = K ? 0 : 4;
  A.setUint32(B + ie, J, K), A.setUint32(B + ce, ne, K);
}
function Chi(A, B, L) {
  return A & B ^ ~A & L;
}
function Maj(A, B, L) {
  return A & B ^ A & L ^ B & L;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(B, L, K, V) {
    super(), this.blockLen = B, this.outputLen = L, this.padOffset = K, this.isLE = V, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(B), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(B) {
    (0, _assert_js_1.aexists)(this);
    const { view: L, buffer: K, blockLen: V } = this;
    B = (0, utils_js_1$3.toBytes)(B);
    const W = B.length;
    for (let J = 0; J < W; ) {
      const ne = Math.min(V - this.pos, W - J);
      if (ne === V) {
        const ie = (0, utils_js_1$3.createView)(B);
        for (; V <= W - J; J += V)
          this.process(ie, J);
        continue;
      }
      K.set(B.subarray(J, J + ne), this.pos), this.pos += ne, J += ne, this.pos === V && (this.process(L, 0), this.pos = 0);
    }
    return this.length += B.length, this.roundClean(), this;
  }
  digestInto(B) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(B, this), this.finished = !0;
    const { buffer: L, view: K, blockLen: V, isLE: W } = this;
    let { pos: J } = this;
    L[J++] = 128, this.buffer.subarray(J).fill(0), this.padOffset > V - J && (this.process(K, 0), J = 0);
    for (let oe = J; oe < V; oe++)
      L[oe] = 0;
    setBigUint64(K, V - 8, BigInt(this.length * 8), W), this.process(K, 0);
    const ne = (0, utils_js_1$3.createView)(B), ie = this.outputLen;
    if (ie % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ce = ie / 4, re = this.get();
    if (ce > re.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let oe = 0; oe < ce; oe++)
      ne.setUint32(4 * oe, re[oe], W);
  }
  digest() {
    const { buffer: B, outputLen: L } = this;
    this.digestInto(B);
    const K = B.slice(0, L);
    return this.destroy(), K;
  }
  _cloneInto(B) {
    B || (B = new this.constructor()), B.set(...this.get());
    const { blockLen: L, buffer: K, length: V, finished: W, destroyed: J, pos: ne } = this;
    return B.length = V, B.pos = ne, B.finished = W, B.destroyed = J, V % L && B.buffer.set(K), B;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: V, E: W, F: J, G: ne, H: ie } = this;
    return [B, L, K, V, W, J, ne, ie];
  }
  // prettier-ignore
  set(B, L, K, V, W, J, ne, ie) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = V | 0, this.E = W | 0, this.F = J | 0, this.G = ne | 0, this.H = ie | 0;
  }
  process(B, L) {
    for (let oe = 0; oe < 16; oe++, L += 4)
      SHA256_W[oe] = B.getUint32(L, !1);
    for (let oe = 16; oe < 64; oe++) {
      const ke = SHA256_W[oe - 15], Oe = SHA256_W[oe - 2], it = (0, utils_js_1$2.rotr)(ke, 7) ^ (0, utils_js_1$2.rotr)(ke, 18) ^ ke >>> 3, at = (0, utils_js_1$2.rotr)(Oe, 17) ^ (0, utils_js_1$2.rotr)(Oe, 19) ^ Oe >>> 10;
      SHA256_W[oe] = at + SHA256_W[oe - 7] + it + SHA256_W[oe - 16] | 0;
    }
    let { A: K, B: V, C: W, D: J, E: ne, F: ie, G: ce, H: re } = this;
    for (let oe = 0; oe < 64; oe++) {
      const ke = (0, utils_js_1$2.rotr)(ne, 6) ^ (0, utils_js_1$2.rotr)(ne, 11) ^ (0, utils_js_1$2.rotr)(ne, 25), Oe = re + ke + (0, _md_js_1$2.Chi)(ne, ie, ce) + SHA256_K[oe] + SHA256_W[oe] | 0, at = ((0, utils_js_1$2.rotr)(K, 2) ^ (0, utils_js_1$2.rotr)(K, 13) ^ (0, utils_js_1$2.rotr)(K, 22)) + (0, _md_js_1$2.Maj)(K, V, W) | 0;
      re = ce, ce = ie, ie = ne, ne = J + Oe | 0, J = W, W = V, V = K, K = Oe + at | 0;
    }
    K = K + this.A | 0, V = V + this.B | 0, W = W + this.C | 0, J = J + this.D | 0, ne = ne + this.E | 0, ie = ie + this.F | 0, ce = ce + this.G | 0, re = re + this.H | 0, this.set(K, V, W, J, ne, ie, ce, re);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$4.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} };
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(A, B) {
  var L = require$$0$1, K = L.Buffer;
  function V(J, ne) {
    for (var ie in J)
      ne[ie] = J[ie];
  }
  K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (V(L, B), B.Buffer = W);
  function W(J, ne, ie) {
    return K(J, ne, ie);
  }
  W.prototype = Object.create(K.prototype), V(K, W), W.from = function(J, ne, ie) {
    if (typeof J == "number")
      throw new TypeError("Argument must not be a number");
    return K(J, ne, ie);
  }, W.alloc = function(J, ne, ie) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    var ce = K(J);
    return ne !== void 0 ? typeof ie == "string" ? ce.fill(ne, ie) : ce.fill(ne) : ce.fill(0), ce;
  }, W.allocUnsafe = function(J) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    return K(J);
  }, W.allocUnsafeSlow = function(J) {
    if (typeof J != "number")
      throw new TypeError("Argument must be a number");
    return L.SlowBuffer(J);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var A = 65536, B = 4294967295;
  function L() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var K = safeBufferExports.Buffer, V = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  V && V.getRandomValues ? browser$b.exports = W : browser$b.exports = L;
  function W(J, ne) {
    if (J > B) throw new RangeError("requested too many random bytes");
    var ie = K.allocUnsafe(J);
    if (J > 0)
      if (J > A)
        for (var ce = 0; ce < J; ce += A)
          V.getRandomValues(ie.slice(ce, ce + A));
      else
        V.getRandomValues(ie);
    return typeof ne == "function" ? process$1.nextTick(function() {
      ne(null, ie);
    }) : ie;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(B, L) {
    L && (B.super_ = L, B.prototype = Object.create(L.prototype, {
      constructor: {
        value: B,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(B, L) {
    if (L) {
      B.super_ = L;
      var K = function() {
      };
      K.prototype = L.prototype, B.prototype = new K(), B.prototype.constructor = B;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var A = typeof Reflect == "object" ? Reflect : null, B = A && typeof A.apply == "function" ? A.apply : function($t, xt, Ot) {
    return Function.prototype.apply.call($t, xt, Ot);
  }, L;
  A && typeof A.ownKeys == "function" ? L = A.ownKeys : Object.getOwnPropertySymbols ? L = function($t) {
    return Object.getOwnPropertyNames($t).concat(Object.getOwnPropertySymbols($t));
  } : L = function($t) {
    return Object.getOwnPropertyNames($t);
  };
  function K(vt) {
    console && console.warn && console.warn(vt);
  }
  var V = Number.isNaN || function($t) {
    return $t !== $t;
  };
  function W() {
    W.init.call(this);
  }
  events.exports = W, events.exports.once = dt, W.EventEmitter = W, W.prototype._events = void 0, W.prototype._eventsCount = 0, W.prototype._maxListeners = void 0;
  var J = 10;
  function ne(vt) {
    if (typeof vt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof vt);
  }
  Object.defineProperty(W, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return J;
    },
    set: function(vt) {
      if (typeof vt != "number" || vt < 0 || V(vt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + vt + ".");
      J = vt;
    }
  }), W.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, W.prototype.setMaxListeners = function($t) {
    if (typeof $t != "number" || $t < 0 || V($t))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + $t + ".");
    return this._maxListeners = $t, this;
  };
  function ie(vt) {
    return vt._maxListeners === void 0 ? W.defaultMaxListeners : vt._maxListeners;
  }
  W.prototype.getMaxListeners = function() {
    return ie(this);
  }, W.prototype.emit = function($t) {
    for (var xt = [], Ot = 1; Ot < arguments.length; Ot++) xt.push(arguments[Ot]);
    var At = $t === "error", yt = this._events;
    if (yt !== void 0)
      At = At && yt.error === void 0;
    else if (!At)
      return !1;
    if (At) {
      var Bt;
      if (xt.length > 0 && (Bt = xt[0]), Bt instanceof Error)
        throw Bt;
      var gt = new Error("Unhandled error." + (Bt ? " (" + Bt.message + ")" : ""));
      throw gt.context = Bt, gt;
    }
    var rt = yt[$t];
    if (rt === void 0)
      return !1;
    if (typeof rt == "function")
      B(rt, this, xt);
    else
      for (var Ce = rt.length, pe = it(rt, Ce), Ot = 0; Ot < Ce; ++Ot)
        B(pe[Ot], this, xt);
    return !0;
  };
  function ce(vt, $t, xt, Ot) {
    var At, yt, Bt;
    if (ne(xt), yt = vt._events, yt === void 0 ? (yt = vt._events = /* @__PURE__ */ Object.create(null), vt._eventsCount = 0) : (yt.newListener !== void 0 && (vt.emit(
      "newListener",
      $t,
      xt.listener ? xt.listener : xt
    ), yt = vt._events), Bt = yt[$t]), Bt === void 0)
      Bt = yt[$t] = xt, ++vt._eventsCount;
    else if (typeof Bt == "function" ? Bt = yt[$t] = Ot ? [xt, Bt] : [Bt, xt] : Ot ? Bt.unshift(xt) : Bt.push(xt), At = ie(vt), At > 0 && Bt.length > At && !Bt.warned) {
      Bt.warned = !0;
      var gt = new Error("Possible EventEmitter memory leak detected. " + Bt.length + " " + String($t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      gt.name = "MaxListenersExceededWarning", gt.emitter = vt, gt.type = $t, gt.count = Bt.length, K(gt);
    }
    return vt;
  }
  W.prototype.addListener = function($t, xt) {
    return ce(this, $t, xt, !1);
  }, W.prototype.on = W.prototype.addListener, W.prototype.prependListener = function($t, xt) {
    return ce(this, $t, xt, !0);
  };
  function re() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function oe(vt, $t, xt) {
    var Ot = { fired: !1, wrapFn: void 0, target: vt, type: $t, listener: xt }, At = re.bind(Ot);
    return At.listener = xt, Ot.wrapFn = At, At;
  }
  W.prototype.once = function($t, xt) {
    return ne(xt), this.on($t, oe(this, $t, xt)), this;
  }, W.prototype.prependOnceListener = function($t, xt) {
    return ne(xt), this.prependListener($t, oe(this, $t, xt)), this;
  }, W.prototype.removeListener = function($t, xt) {
    var Ot, At, yt, Bt, gt;
    if (ne(xt), At = this._events, At === void 0)
      return this;
    if (Ot = At[$t], Ot === void 0)
      return this;
    if (Ot === xt || Ot.listener === xt)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete At[$t], At.removeListener && this.emit("removeListener", $t, Ot.listener || xt));
    else if (typeof Ot != "function") {
      for (yt = -1, Bt = Ot.length - 1; Bt >= 0; Bt--)
        if (Ot[Bt] === xt || Ot[Bt].listener === xt) {
          gt = Ot[Bt].listener, yt = Bt;
          break;
        }
      if (yt < 0)
        return this;
      yt === 0 ? Ot.shift() : at(Ot, yt), Ot.length === 1 && (At[$t] = Ot[0]), At.removeListener !== void 0 && this.emit("removeListener", $t, gt || xt);
    }
    return this;
  }, W.prototype.off = W.prototype.removeListener, W.prototype.removeAllListeners = function($t) {
    var xt, Ot, At;
    if (Ot = this._events, Ot === void 0)
      return this;
    if (Ot.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Ot[$t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Ot[$t]), this;
    if (arguments.length === 0) {
      var yt = Object.keys(Ot), Bt;
      for (At = 0; At < yt.length; ++At)
        Bt = yt[At], Bt !== "removeListener" && this.removeAllListeners(Bt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (xt = Ot[$t], typeof xt == "function")
      this.removeListener($t, xt);
    else if (xt !== void 0)
      for (At = xt.length - 1; At >= 0; At--)
        this.removeListener($t, xt[At]);
    return this;
  };
  function ke(vt, $t, xt) {
    var Ot = vt._events;
    if (Ot === void 0)
      return [];
    var At = Ot[$t];
    return At === void 0 ? [] : typeof At == "function" ? xt ? [At.listener || At] : [At] : xt ? ut(At) : it(At, At.length);
  }
  W.prototype.listeners = function($t) {
    return ke(this, $t, !0);
  }, W.prototype.rawListeners = function($t) {
    return ke(this, $t, !1);
  }, W.listenerCount = function(vt, $t) {
    return typeof vt.listenerCount == "function" ? vt.listenerCount($t) : Oe.call(vt, $t);
  }, W.prototype.listenerCount = Oe;
  function Oe(vt) {
    var $t = this._events;
    if ($t !== void 0) {
      var xt = $t[vt];
      if (typeof xt == "function")
        return 1;
      if (xt !== void 0)
        return xt.length;
    }
    return 0;
  }
  W.prototype.eventNames = function() {
    return this._eventsCount > 0 ? L(this._events) : [];
  };
  function it(vt, $t) {
    for (var xt = new Array($t), Ot = 0; Ot < $t; ++Ot)
      xt[Ot] = vt[Ot];
    return xt;
  }
  function at(vt, $t) {
    for (; $t + 1 < vt.length; $t++)
      vt[$t] = vt[$t + 1];
    vt.pop();
  }
  function ut(vt) {
    for (var $t = new Array(vt.length), xt = 0; xt < $t.length; ++xt)
      $t[xt] = vt[xt].listener || vt[xt];
    return $t;
  }
  function dt(vt, $t) {
    return new Promise(function(xt, Ot) {
      function At(Bt) {
        vt.removeListener($t, yt), Ot(Bt);
      }
      function yt() {
        typeof vt.removeListener == "function" && vt.removeListener("error", At), xt([].slice.call(arguments));
      }
      bt(vt, $t, yt, { once: !0 }), $t !== "error" && ct(vt, At, { once: !0 });
    });
  }
  function ct(vt, $t, xt) {
    typeof vt.on == "function" && bt(vt, "error", $t, xt);
  }
  function bt(vt, $t, xt, Ot) {
    if (typeof vt.on == "function")
      Ot.once ? vt.once($t, xt) : vt.on($t, xt);
    else if (typeof vt.addEventListener == "function")
      vt.addEventListener($t, function At(yt) {
        Ot.once && vt.removeEventListener($t, At), xt(yt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof vt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var B = {}, L = Symbol("test"), K = Object(L);
    if (typeof L == "string" || Object.prototype.toString.call(L) !== "[object Symbol]" || Object.prototype.toString.call(K) !== "[object Symbol]")
      return !1;
    var V = 42;
    B[L] = V;
    for (var W in B)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(B).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(B).length !== 0)
      return !1;
    var J = Object.getOwnPropertySymbols(B);
    if (J.length !== 1 || J[0] !== L || !Object.prototype.propertyIsEnumerable.call(B, L))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var ne = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(B, L)
      );
      if (ne.value !== V || ne.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var A = requireShams$1();
  return shams = function() {
    return A() && !!Symbol.toStringTag;
  }, shams;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(B) {
    return B !== B;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var A = require_isNaN();
  return sign$1 = function(L) {
    return A(L) || L === 0 ? L : L < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var A = requireGOPD();
  if (A)
    try {
      A([], "length");
    } catch {
      A = null;
    }
  return gopd = A, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var A = Object.defineProperty || !1;
  if (A)
    try {
      A({}, "a", { value: 1 });
    } catch {
      A = !1;
    }
  return esDefineProperty = A, esDefineProperty;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var A = typeof Symbol < "u" && Symbol, B = requireShams$1();
  return hasSymbols = function() {
    return typeof A != "function" || typeof Symbol != "function" || typeof A("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : B();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var A = requireEsObjectAtoms();
  return Object_getPrototypeOf = A.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var A = "Function.prototype.bind called on incompatible ", B = Object.prototype.toString, L = Math.max, K = "[object Function]", V = function(ie, ce) {
    for (var re = [], oe = 0; oe < ie.length; oe += 1)
      re[oe] = ie[oe];
    for (var ke = 0; ke < ce.length; ke += 1)
      re[ke + ie.length] = ce[ke];
    return re;
  }, W = function(ie, ce) {
    for (var re = [], oe = ce, ke = 0; oe < ie.length; oe += 1, ke += 1)
      re[ke] = ie[oe];
    return re;
  }, J = function(ne, ie) {
    for (var ce = "", re = 0; re < ne.length; re += 1)
      ce += ne[re], re + 1 < ne.length && (ce += ie);
    return ce;
  };
  return implementation = function(ie) {
    var ce = this;
    if (typeof ce != "function" || B.apply(ce) !== K)
      throw new TypeError(A + ce);
    for (var re = W(arguments, 1), oe, ke = function() {
      if (this instanceof oe) {
        var dt = ce.apply(
          this,
          V(re, arguments)
        );
        return Object(dt) === dt ? dt : this;
      }
      return ce.apply(
        ie,
        V(re, arguments)
      );
    }, Oe = L(0, ce.length - re.length), it = [], at = 0; at < Oe; at++)
      it[at] = "$" + at;
    if (oe = Function("binder", "return function (" + J(it, ",") + "){ return binder.apply(this,arguments); }")(ke), ce.prototype) {
      var ut = function() {
      };
      ut.prototype = ce.prototype, oe.prototype = new ut(), ut.prototype = null;
    }
    return oe;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var A = requireImplementation();
  return functionBind = Function.prototype.bind || A, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var A = requireFunctionBind(), B = requireFunctionApply(), L = requireFunctionCall(), K = requireReflectApply();
  return actualApply = K || A.call(L, B), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var A = requireFunctionBind(), B = requireType(), L = requireFunctionCall(), K = requireActualApply();
  return callBindApplyHelpers = function(W) {
    if (W.length < 1 || typeof W[0] != "function")
      throw new B("a function is required");
    return K(A, L, W);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var A = requireCallBindApplyHelpers(), B = requireGopd(), L;
  try {
    L = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (J) {
    if (!J || typeof J != "object" || !("code" in J) || J.code !== "ERR_PROTO_ACCESS")
      throw J;
  }
  var K = !!L && B && B(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), V = Object, W = V.getPrototypeOf;
  return get = K && typeof K.get == "function" ? A([K.get]) : typeof W == "function" ? (
    /** @type {import('./get')} */
    function(ne) {
      return W(ne == null ? ne : V(ne));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var A = requireReflect_getPrototypeOf(), B = requireObject_getPrototypeOf(), L = requireGet();
  return getProto = A ? function(V) {
    return A(V);
  } : B ? function(V) {
    if (!V || typeof V != "object" && typeof V != "function")
      throw new TypeError("getProto: not an object");
    return B(V);
  } : L ? function(V) {
    return L(V);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var A = Function.prototype.call, B = Object.prototype.hasOwnProperty, L = requireFunctionBind();
  return hasown = L.call(A, B), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var A, B = requireEsObjectAtoms(), L = requireEsErrors(), K = require_eval(), V = requireRange(), W = requireRef(), J = requireSyntax(), ne = requireType(), ie = requireUri(), ce = requireAbs(), re = requireFloor(), oe = requireMax(), ke = requireMin(), Oe = requirePow(), it = requireRound(), at = requireSign$1(), ut = Function, dt = function(Ut) {
    try {
      return ut('"use strict"; return (' + Ut + ").constructor;")();
    } catch {
    }
  }, ct = requireGopd(), bt = requireEsDefineProperty(), vt = function() {
    throw new ne();
  }, $t = ct ? function() {
    try {
      return arguments.callee, vt;
    } catch {
      try {
        return ct(arguments, "callee").get;
      } catch {
        return vt;
      }
    }
  }() : vt, xt = requireHasSymbols()(), Ot = requireGetProto(), At = requireObject_getPrototypeOf(), yt = requireReflect_getPrototypeOf(), Bt = requireFunctionApply(), gt = requireFunctionCall(), rt = {}, Ce = typeof Uint8Array > "u" || !Ot ? A : Ot(Uint8Array), pe = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? A : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? A : ArrayBuffer,
    "%ArrayIteratorPrototype%": xt && Ot ? Ot([][Symbol.iterator]()) : A,
    "%AsyncFromSyncIteratorPrototype%": A,
    "%AsyncFunction%": rt,
    "%AsyncGenerator%": rt,
    "%AsyncGeneratorFunction%": rt,
    "%AsyncIteratorPrototype%": rt,
    "%Atomics%": typeof Atomics > "u" ? A : Atomics,
    "%BigInt%": typeof BigInt > "u" ? A : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? A : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? A : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? A : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": L,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": K,
    "%Float32Array%": typeof Float32Array > "u" ? A : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? A : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? A : FinalizationRegistry,
    "%Function%": ut,
    "%GeneratorFunction%": rt,
    "%Int8Array%": typeof Int8Array > "u" ? A : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? A : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? A : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": xt && Ot ? Ot(Ot([][Symbol.iterator]())) : A,
    "%JSON%": typeof JSON == "object" ? JSON : A,
    "%Map%": typeof Map > "u" ? A : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !xt || !Ot ? A : Ot((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": B,
    "%Object.getOwnPropertyDescriptor%": ct,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? A : Promise,
    "%Proxy%": typeof Proxy > "u" ? A : Proxy,
    "%RangeError%": V,
    "%ReferenceError%": W,
    "%Reflect%": typeof Reflect > "u" ? A : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? A : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !xt || !Ot ? A : Ot((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? A : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": xt && Ot ? Ot(""[Symbol.iterator]()) : A,
    "%Symbol%": xt ? Symbol : A,
    "%SyntaxError%": J,
    "%ThrowTypeError%": $t,
    "%TypedArray%": Ce,
    "%TypeError%": ne,
    "%Uint8Array%": typeof Uint8Array > "u" ? A : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? A : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? A : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? A : Uint32Array,
    "%URIError%": ie,
    "%WeakMap%": typeof WeakMap > "u" ? A : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? A : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? A : WeakSet,
    "%Function.prototype.call%": gt,
    "%Function.prototype.apply%": Bt,
    "%Object.defineProperty%": bt,
    "%Object.getPrototypeOf%": At,
    "%Math.abs%": ce,
    "%Math.floor%": re,
    "%Math.max%": oe,
    "%Math.min%": ke,
    "%Math.pow%": Oe,
    "%Math.round%": it,
    "%Math.sign%": at,
    "%Reflect.getPrototypeOf%": yt
  };
  if (Ot)
    try {
      null.error;
    } catch (Ut) {
      var nt = Ot(Ot(Ut));
      pe["%Error.prototype%"] = nt;
    }
  var st = function Ut(Wt) {
    var It;
    if (Wt === "%AsyncFunction%")
      It = dt("async function () {}");
    else if (Wt === "%GeneratorFunction%")
      It = dt("function* () {}");
    else if (Wt === "%AsyncGeneratorFunction%")
      It = dt("async function* () {}");
    else if (Wt === "%AsyncGenerator%") {
      var Rt = Ut("%AsyncGeneratorFunction%");
      Rt && (It = Rt.prototype);
    } else if (Wt === "%AsyncIteratorPrototype%") {
      var jt = Ut("%AsyncGenerator%");
      jt && Ot && (It = Ot(jt.prototype));
    }
    return pe[Wt] = It, It;
  }, ot = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ht = requireFunctionBind(), pt = requireHasown(), ft = ht.call(gt, Array.prototype.concat), mt = ht.call(Bt, Array.prototype.splice), lt = ht.call(gt, String.prototype.replace), St = ht.call(gt, String.prototype.slice), Ft = ht.call(gt, RegExp.prototype.exec), Gt = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, qt = /\\(\\)?/g, Pt = function(Wt) {
    var It = St(Wt, 0, 1), Rt = St(Wt, -1);
    if (It === "%" && Rt !== "%")
      throw new J("invalid intrinsic syntax, expected closing `%`");
    if (Rt === "%" && It !== "%")
      throw new J("invalid intrinsic syntax, expected opening `%`");
    var jt = [];
    return lt(Wt, Gt, function(Jt, er, nr, fr) {
      jt[jt.length] = nr ? lt(fr, qt, "$1") : er || Jt;
    }), jt;
  }, Tt = function(Wt, It) {
    var Rt = Wt, jt;
    if (pt(ot, Rt) && (jt = ot[Rt], Rt = "%" + jt[0] + "%"), pt(pe, Rt)) {
      var Jt = pe[Rt];
      if (Jt === rt && (Jt = st(Rt)), typeof Jt > "u" && !It)
        throw new ne("intrinsic " + Wt + " exists, but is not available. Please file an issue!");
      return {
        alias: jt,
        name: Rt,
        value: Jt
      };
    }
    throw new J("intrinsic " + Wt + " does not exist!");
  };
  return getIntrinsic = function(Wt, It) {
    if (typeof Wt != "string" || Wt.length === 0)
      throw new ne("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof It != "boolean")
      throw new ne('"allowMissing" argument must be a boolean');
    if (Ft(/^%?[^%]*%?$/, Wt) === null)
      throw new J("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var Rt = Pt(Wt), jt = Rt.length > 0 ? Rt[0] : "", Jt = Tt("%" + jt + "%", It), er = Jt.name, nr = Jt.value, fr = !1, lr = Jt.alias;
    lr && (jt = lr[0], mt(Rt, ft([0, 1], lr)));
    for (var Yt = 1, Pr = !0; Yt < Rt.length; Yt += 1) {
      var or = Rt[Yt], Ar = St(or, 0, 1), Br = St(or, -1);
      if ((Ar === '"' || Ar === "'" || Ar === "`" || Br === '"' || Br === "'" || Br === "`") && Ar !== Br)
        throw new J("property names with quotes must have matching quotes");
      if ((or === "constructor" || !Pr) && (fr = !0), jt += "." + or, er = "%" + jt + "%", pt(pe, er))
        nr = pe[er];
      else if (nr != null) {
        if (!(or in nr)) {
          if (!It)
            throw new ne("base intrinsic for " + Wt + " exists, but the property is not available.");
          return;
        }
        if (ct && Yt + 1 >= Rt.length) {
          var cr = ct(nr, or);
          Pr = !!cr, Pr && "get" in cr && !("originalValue" in cr.get) ? nr = cr.get : nr = nr[or];
        } else
          Pr = pt(nr, or), nr = nr[or];
        Pr && !fr && (pe[er] = nr);
      }
    }
    return nr;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var A = requireGetIntrinsic(), B = requireCallBindApplyHelpers(), L = B([A("%String.prototype.indexOf%")]);
  return callBound = function(V, W) {
    var J = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      A(V, !!W)
    );
    return typeof J == "function" && L(V, ".prototype.") > -1 ? B([J]) : J;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var A = requireShams()(), B = requireCallBound(), L = B("Object.prototype.toString"), K = function(ne) {
    return A && ne && typeof ne == "object" && Symbol.toStringTag in ne ? !1 : L(ne) === "[object Arguments]";
  }, V = function(ne) {
    return K(ne) ? !0 : ne !== null && typeof ne == "object" && "length" in ne && typeof ne.length == "number" && ne.length >= 0 && L(ne) !== "[object Array]" && "callee" in ne && L(ne.callee) === "[object Function]";
  }, W = function() {
    return K(arguments);
  }();
  return K.isLegacyArguments = V, isArguments = W ? K : V, isArguments;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var A = requireCallBound(), B = requireShams()(), L = requireHasown(), K = requireGopd(), V;
  if (B) {
    var W = A("RegExp.prototype.exec"), J = {}, ne = function() {
      throw J;
    }, ie = {
      toString: ne,
      valueOf: ne
    };
    typeof Symbol.toPrimitive == "symbol" && (ie[Symbol.toPrimitive] = ne), V = function(ke) {
      if (!ke || typeof ke != "object")
        return !1;
      var Oe = (
        /** @type {NonNullable<typeof gOPD>} */
        K(
          /** @type {{ lastIndex?: unknown }} */
          ke,
          "lastIndex"
        )
      ), it = Oe && L(Oe, "value");
      if (!it)
        return !1;
      try {
        W(
          ke,
          /** @type {string} */
          /** @type {unknown} */
          ie
        );
      } catch (at) {
        return at === J;
      }
    };
  } else {
    var ce = A("Object.prototype.toString"), re = "[object RegExp]";
    V = function(ke) {
      return !ke || typeof ke != "object" && typeof ke != "function" ? !1 : ce(ke) === re;
    };
  }
  return isRegex = V, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var A = requireCallBound(), B = requireIsRegex(), L = A("RegExp.prototype.exec"), K = requireType();
  return safeRegexTest = function(W) {
    if (!B(W))
      throw new K("`regex` must be a RegExp");
    return function(ne) {
      return L(W, ne) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var A = requireCallBound(), B = requireSafeRegexTest(), L = B(/^\s*(?:function)?\*/), K = requireShams()(), V = requireGetProto(), W = A("Object.prototype.toString"), J = A("Function.prototype.toString"), ne = function() {
    if (!K)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, ie;
  return isGeneratorFunction = function(re) {
    if (typeof re != "function")
      return !1;
    if (L(J(re)))
      return !0;
    if (!K) {
      var oe = W(re);
      return oe === "[object GeneratorFunction]";
    }
    if (!V)
      return !1;
    if (typeof ie > "u") {
      var ke = ne();
      ie = ke ? (
        /** @type {GeneratorFunctionConstructor} */
        V(ke)
      ) : !1;
    }
    return V(re) === ie;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var A = Function.prototype.toString, B = typeof Reflect == "object" && Reflect !== null && Reflect.apply, L, K;
  if (typeof B == "function" && typeof Object.defineProperty == "function")
    try {
      L = Object.defineProperty({}, "length", {
        get: function() {
          throw K;
        }
      }), K = {}, B(function() {
        throw 42;
      }, null, L);
    } catch (ct) {
      ct !== K && (B = null);
    }
  else
    B = null;
  var V = /^\s*class\b/, W = function(bt) {
    try {
      var vt = A.call(bt);
      return V.test(vt);
    } catch {
      return !1;
    }
  }, J = function(bt) {
    try {
      return W(bt) ? !1 : (A.call(bt), !0);
    } catch {
      return !1;
    }
  }, ne = Object.prototype.toString, ie = "[object Object]", ce = "[object Function]", re = "[object GeneratorFunction]", oe = "[object HTMLAllCollection]", ke = "[object HTML document.all class]", Oe = "[object HTMLCollection]", it = typeof Symbol == "function" && !!Symbol.toStringTag, at = !(0 in [,]), ut = function() {
    return !1;
  };
  if (typeof document == "object") {
    var dt = document.all;
    ne.call(dt) === ne.call(document.all) && (ut = function(bt) {
      if ((at || !bt) && (typeof bt > "u" || typeof bt == "object"))
        try {
          var vt = ne.call(bt);
          return (vt === oe || vt === ke || vt === Oe || vt === ie) && bt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = B ? function(bt) {
    if (ut(bt))
      return !0;
    if (!bt || typeof bt != "function" && typeof bt != "object")
      return !1;
    try {
      B(bt, null, L);
    } catch (vt) {
      if (vt !== K)
        return !1;
    }
    return !W(bt) && J(bt);
  } : function(bt) {
    if (ut(bt))
      return !0;
    if (!bt || typeof bt != "function" && typeof bt != "object")
      return !1;
    if (it)
      return J(bt);
    if (W(bt))
      return !1;
    var vt = ne.call(bt);
    return vt !== ce && vt !== re && !/^\[object HTML/.test(vt) ? !1 : J(bt);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var A = requireIsCallable(), B = Object.prototype.toString, L = Object.prototype.hasOwnProperty, K = function(ie, ce, re) {
    for (var oe = 0, ke = ie.length; oe < ke; oe++)
      L.call(ie, oe) && (re == null ? ce(ie[oe], oe, ie) : ce.call(re, ie[oe], oe, ie));
  }, V = function(ie, ce, re) {
    for (var oe = 0, ke = ie.length; oe < ke; oe++)
      re == null ? ce(ie.charAt(oe), oe, ie) : ce.call(re, ie.charAt(oe), oe, ie);
  }, W = function(ie, ce, re) {
    for (var oe in ie)
      L.call(ie, oe) && (re == null ? ce(ie[oe], oe, ie) : ce.call(re, ie[oe], oe, ie));
  };
  function J(ne) {
    return B.call(ne) === "[object Array]";
  }
  return forEach = function(ie, ce, re) {
    if (!A(ce))
      throw new TypeError("iterator must be a function");
    var oe;
    arguments.length >= 3 && (oe = re), J(ie) ? K(ie, ce, oe) : typeof ie == "string" ? V(ie, ce, oe) : W(ie, ce, oe);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var A = requirePossibleTypedArrayNames(), B = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var K = [], V = 0; V < A.length; V++)
      typeof B[A[V]] == "function" && (K[K.length] = A[V]);
    return K;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var A = requireEsDefineProperty(), B = requireSyntax(), L = requireType(), K = requireGopd();
  return defineDataProperty = function(W, J, ne) {
    if (!W || typeof W != "object" && typeof W != "function")
      throw new L("`obj` must be an object or a function`");
    if (typeof J != "string" && typeof J != "symbol")
      throw new L("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new L("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new L("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new L("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new L("`loose`, if provided, must be a boolean");
    var ie = arguments.length > 3 ? arguments[3] : null, ce = arguments.length > 4 ? arguments[4] : null, re = arguments.length > 5 ? arguments[5] : null, oe = arguments.length > 6 ? arguments[6] : !1, ke = !!K && K(W, J);
    if (A)
      A(W, J, {
        configurable: re === null && ke ? ke.configurable : !re,
        enumerable: ie === null && ke ? ke.enumerable : !ie,
        value: ne,
        writable: ce === null && ke ? ke.writable : !ce
      });
    else if (oe || !ie && !ce && !re)
      W[J] = ne;
    else
      throw new B("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var A = requireEsDefineProperty(), B = function() {
    return !!A;
  };
  return B.hasArrayLengthDefineBug = function() {
    if (!A)
      return null;
    try {
      return A([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = B, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var A = requireGetIntrinsic(), B = requireDefineDataProperty(), L = requireHasPropertyDescriptors()(), K = requireGopd(), V = requireType(), W = A("%Math.floor%");
  return setFunctionLength = function(ne, ie) {
    if (typeof ne != "function")
      throw new V("`fn` is not a function");
    if (typeof ie != "number" || ie < 0 || ie > 4294967295 || W(ie) !== ie)
      throw new V("`length` must be a positive 32-bit integer");
    var ce = arguments.length > 2 && !!arguments[2], re = !0, oe = !0;
    if ("length" in ne && K) {
      var ke = K(ne, "length");
      ke && !ke.configurable && (re = !1), ke && !ke.writable && (oe = !1);
    }
    return (re || oe || !ce) && (L ? B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie,
      !0,
      !0
    ) : B(
      /** @type {Parameters<define>[0]} */
      ne,
      "length",
      ie
    )), ne;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var A = requireFunctionBind(), B = requireFunctionApply(), L = requireActualApply();
  return applyBind = function() {
    return L(A, B, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(A) {
    var B = requireSetFunctionLength(), L = requireEsDefineProperty(), K = requireCallBindApplyHelpers(), V = requireApplyBind();
    A.exports = function(J) {
      var ne = K(arguments), ie = J.length - (arguments.length - 1);
      return B(
        ne,
        1 + (ie > 0 ? ie : 0),
        !0
      );
    }, L ? L(A.exports, "apply", { value: V }) : A.exports.apply = V;
  }(callBind)), callBind.exports;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var A = requireForEach(), B = requireAvailableTypedArrays(), L = requireCallBind(), K = requireCallBound(), V = requireGopd(), W = K("Object.prototype.toString"), J = requireShams()(), ne = typeof globalThis > "u" ? commonjsGlobal : globalThis, ie = B(), ce = K("String.prototype.slice"), re = Object.getPrototypeOf, oe = K("Array.prototype.indexOf", !0) || function(ut, dt) {
    for (var ct = 0; ct < ut.length; ct += 1)
      if (ut[ct] === dt)
        return ct;
    return -1;
  }, ke = { __proto__: null };
  J && V && re ? A(ie, function(at) {
    var ut = new ne[at]();
    if (Symbol.toStringTag in ut) {
      var dt = re(ut), ct = V(dt, Symbol.toStringTag);
      if (!ct) {
        var bt = re(dt);
        ct = V(bt, Symbol.toStringTag);
      }
      ke["$" + at] = L(ct.get);
    }
  }) : A(ie, function(at) {
    var ut = new ne[at](), dt = ut.slice || ut.set;
    dt && (ke["$" + at] = L(dt));
  });
  var Oe = function(ut) {
    var dt = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(ct, bt) {
        if (!dt)
          try {
            "$" + ct(ut) === bt && (dt = ce(bt, 1));
          } catch {
          }
      }
    ), dt;
  }, it = function(ut) {
    var dt = !1;
    return A(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      ke,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(ct, bt) {
        if (!dt)
          try {
            ct(ut), dt = ce(bt, 1);
          } catch {
          }
      }
    ), dt;
  };
  return whichTypedArray = function(ut) {
    if (!ut || typeof ut != "object")
      return !1;
    if (!J) {
      var dt = ce(W(ut), 8, -1);
      return oe(ie, dt) > -1 ? dt : dt !== "Object" ? !1 : it(ut);
    }
    return V ? Oe(ut) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var A = requireWhichTypedArray();
  return isTypedArray = function(L) {
    return !!A(L);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(A) {
    var B = requireIsArguments(), L = requireIsGeneratorFunction(), K = requireWhichTypedArray(), V = requireIsTypedArray();
    function W(Yt) {
      return Yt.call.bind(Yt);
    }
    var J = typeof BigInt < "u", ne = typeof Symbol < "u", ie = W(Object.prototype.toString), ce = W(Number.prototype.valueOf), re = W(String.prototype.valueOf), oe = W(Boolean.prototype.valueOf);
    if (J)
      var ke = W(BigInt.prototype.valueOf);
    if (ne)
      var Oe = W(Symbol.prototype.valueOf);
    function it(Yt, Pr) {
      if (typeof Yt != "object")
        return !1;
      try {
        return Pr(Yt), !0;
      } catch {
        return !1;
      }
    }
    A.isArgumentsObject = B, A.isGeneratorFunction = L, A.isTypedArray = V;
    function at(Yt) {
      return typeof Promise < "u" && Yt instanceof Promise || Yt !== null && typeof Yt == "object" && typeof Yt.then == "function" && typeof Yt.catch == "function";
    }
    A.isPromise = at;
    function ut(Yt) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Yt) : V(Yt) || St(Yt);
    }
    A.isArrayBufferView = ut;
    function dt(Yt) {
      return K(Yt) === "Uint8Array";
    }
    A.isUint8Array = dt;
    function ct(Yt) {
      return K(Yt) === "Uint8ClampedArray";
    }
    A.isUint8ClampedArray = ct;
    function bt(Yt) {
      return K(Yt) === "Uint16Array";
    }
    A.isUint16Array = bt;
    function vt(Yt) {
      return K(Yt) === "Uint32Array";
    }
    A.isUint32Array = vt;
    function $t(Yt) {
      return K(Yt) === "Int8Array";
    }
    A.isInt8Array = $t;
    function xt(Yt) {
      return K(Yt) === "Int16Array";
    }
    A.isInt16Array = xt;
    function Ot(Yt) {
      return K(Yt) === "Int32Array";
    }
    A.isInt32Array = Ot;
    function At(Yt) {
      return K(Yt) === "Float32Array";
    }
    A.isFloat32Array = At;
    function yt(Yt) {
      return K(Yt) === "Float64Array";
    }
    A.isFloat64Array = yt;
    function Bt(Yt) {
      return K(Yt) === "BigInt64Array";
    }
    A.isBigInt64Array = Bt;
    function gt(Yt) {
      return K(Yt) === "BigUint64Array";
    }
    A.isBigUint64Array = gt;
    function rt(Yt) {
      return ie(Yt) === "[object Map]";
    }
    rt.working = typeof Map < "u" && rt(/* @__PURE__ */ new Map());
    function Ce(Yt) {
      return typeof Map > "u" ? !1 : rt.working ? rt(Yt) : Yt instanceof Map;
    }
    A.isMap = Ce;
    function pe(Yt) {
      return ie(Yt) === "[object Set]";
    }
    pe.working = typeof Set < "u" && pe(/* @__PURE__ */ new Set());
    function nt(Yt) {
      return typeof Set > "u" ? !1 : pe.working ? pe(Yt) : Yt instanceof Set;
    }
    A.isSet = nt;
    function st(Yt) {
      return ie(Yt) === "[object WeakMap]";
    }
    st.working = typeof WeakMap < "u" && st(/* @__PURE__ */ new WeakMap());
    function ot(Yt) {
      return typeof WeakMap > "u" ? !1 : st.working ? st(Yt) : Yt instanceof WeakMap;
    }
    A.isWeakMap = ot;
    function ht(Yt) {
      return ie(Yt) === "[object WeakSet]";
    }
    ht.working = typeof WeakSet < "u" && ht(/* @__PURE__ */ new WeakSet());
    function pt(Yt) {
      return ht(Yt);
    }
    A.isWeakSet = pt;
    function ft(Yt) {
      return ie(Yt) === "[object ArrayBuffer]";
    }
    ft.working = typeof ArrayBuffer < "u" && ft(new ArrayBuffer());
    function mt(Yt) {
      return typeof ArrayBuffer > "u" ? !1 : ft.working ? ft(Yt) : Yt instanceof ArrayBuffer;
    }
    A.isArrayBuffer = mt;
    function lt(Yt) {
      return ie(Yt) === "[object DataView]";
    }
    lt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && lt(new DataView(new ArrayBuffer(1), 0, 1));
    function St(Yt) {
      return typeof DataView > "u" ? !1 : lt.working ? lt(Yt) : Yt instanceof DataView;
    }
    A.isDataView = St;
    var Ft = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function Gt(Yt) {
      return ie(Yt) === "[object SharedArrayBuffer]";
    }
    function qt(Yt) {
      return typeof Ft > "u" ? !1 : (typeof Gt.working > "u" && (Gt.working = Gt(new Ft())), Gt.working ? Gt(Yt) : Yt instanceof Ft);
    }
    A.isSharedArrayBuffer = qt;
    function Pt(Yt) {
      return ie(Yt) === "[object AsyncFunction]";
    }
    A.isAsyncFunction = Pt;
    function Tt(Yt) {
      return ie(Yt) === "[object Map Iterator]";
    }
    A.isMapIterator = Tt;
    function Ut(Yt) {
      return ie(Yt) === "[object Set Iterator]";
    }
    A.isSetIterator = Ut;
    function Wt(Yt) {
      return ie(Yt) === "[object Generator]";
    }
    A.isGeneratorObject = Wt;
    function It(Yt) {
      return ie(Yt) === "[object WebAssembly.Module]";
    }
    A.isWebAssemblyCompiledModule = It;
    function Rt(Yt) {
      return it(Yt, ce);
    }
    A.isNumberObject = Rt;
    function jt(Yt) {
      return it(Yt, re);
    }
    A.isStringObject = jt;
    function Jt(Yt) {
      return it(Yt, oe);
    }
    A.isBooleanObject = Jt;
    function er(Yt) {
      return J && it(Yt, ke);
    }
    A.isBigIntObject = er;
    function nr(Yt) {
      return ne && it(Yt, Oe);
    }
    A.isSymbolObject = nr;
    function fr(Yt) {
      return Rt(Yt) || jt(Yt) || Jt(Yt) || er(Yt) || nr(Yt);
    }
    A.isBoxedPrimitive = fr;
    function lr(Yt) {
      return typeof Uint8Array < "u" && (mt(Yt) || qt(Yt));
    }
    A.isAnyArrayBuffer = lr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Yt) {
      Object.defineProperty(A, Yt, {
        enumerable: !1,
        value: function() {
          throw new Error(Yt + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(B) {
    return B && typeof B == "object" && typeof B.copy == "function" && typeof B.fill == "function" && typeof B.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(A) {
    var B = Object.getOwnPropertyDescriptors || function(St) {
      for (var Ft = Object.keys(St), Gt = {}, qt = 0; qt < Ft.length; qt++)
        Gt[Ft[qt]] = Object.getOwnPropertyDescriptor(St, Ft[qt]);
      return Gt;
    }, L = /%[sdj%]/g;
    A.format = function(lt) {
      if (!$t(lt)) {
        for (var St = [], Ft = 0; Ft < arguments.length; Ft++)
          St.push(J(arguments[Ft]));
        return St.join(" ");
      }
      for (var Ft = 1, Gt = arguments, qt = Gt.length, Pt = String(lt).replace(L, function(Ut) {
        if (Ut === "%%") return "%";
        if (Ft >= qt) return Ut;
        switch (Ut) {
          case "%s":
            return String(Gt[Ft++]);
          case "%d":
            return Number(Gt[Ft++]);
          case "%j":
            try {
              return JSON.stringify(Gt[Ft++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ut;
        }
      }), Tt = Gt[Ft]; Ft < qt; Tt = Gt[++Ft])
        ct(Tt) || !yt(Tt) ? Pt += " " + Tt : Pt += " " + J(Tt);
      return Pt;
    }, A.deprecate = function(lt, St) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return lt;
      if (typeof process$1 > "u")
        return function() {
          return A.deprecate(lt, St).apply(this, arguments);
        };
      var Ft = !1;
      function Gt() {
        if (!Ft) {
          if (process$1.throwDeprecation)
            throw new Error(St);
          process$1.traceDeprecation ? console.trace(St) : console.error(St), Ft = !0;
        }
        return lt.apply(this, arguments);
      }
      return Gt;
    };
    var K = {}, V = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var W = process$1.env.NODE_DEBUG;
      W = W.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), V = new RegExp("^" + W + "$", "i");
    }
    A.debuglog = function(lt) {
      if (lt = lt.toUpperCase(), !K[lt])
        if (V.test(lt)) {
          var St = process$1.pid;
          K[lt] = function() {
            var Ft = A.format.apply(A, arguments);
            console.error("%s %d: %s", lt, St, Ft);
          };
        } else
          K[lt] = function() {
          };
      return K[lt];
    };
    function J(lt, St) {
      var Ft = {
        seen: [],
        stylize: ie
      };
      return arguments.length >= 3 && (Ft.depth = arguments[2]), arguments.length >= 4 && (Ft.colors = arguments[3]), dt(St) ? Ft.showHidden = St : St && A._extend(Ft, St), Ot(Ft.showHidden) && (Ft.showHidden = !1), Ot(Ft.depth) && (Ft.depth = 2), Ot(Ft.colors) && (Ft.colors = !1), Ot(Ft.customInspect) && (Ft.customInspect = !0), Ft.colors && (Ft.stylize = ne), re(Ft, lt, Ft.depth);
    }
    A.inspect = J, J.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, J.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function ne(lt, St) {
      var Ft = J.styles[St];
      return Ft ? "\x1B[" + J.colors[Ft][0] + "m" + lt + "\x1B[" + J.colors[Ft][1] + "m" : lt;
    }
    function ie(lt, St) {
      return lt;
    }
    function ce(lt) {
      var St = {};
      return lt.forEach(function(Ft, Gt) {
        St[Ft] = !0;
      }), St;
    }
    function re(lt, St, Ft) {
      if (lt.customInspect && St && rt(St.inspect) && // Filter out the util module, it's inspect function is special
      St.inspect !== A.inspect && // Also filter out any prototype objects using the circular check.
      !(St.constructor && St.constructor.prototype === St)) {
        var Gt = St.inspect(Ft, lt);
        return $t(Gt) || (Gt = re(lt, Gt, Ft)), Gt;
      }
      var qt = oe(lt, St);
      if (qt)
        return qt;
      var Pt = Object.keys(St), Tt = ce(Pt);
      if (lt.showHidden && (Pt = Object.getOwnPropertyNames(St)), gt(St) && (Pt.indexOf("message") >= 0 || Pt.indexOf("description") >= 0))
        return ke(St);
      if (Pt.length === 0) {
        if (rt(St)) {
          var Ut = St.name ? ": " + St.name : "";
          return lt.stylize("[Function" + Ut + "]", "special");
        }
        if (At(St))
          return lt.stylize(RegExp.prototype.toString.call(St), "regexp");
        if (Bt(St))
          return lt.stylize(Date.prototype.toString.call(St), "date");
        if (gt(St))
          return ke(St);
      }
      var Wt = "", It = !1, Rt = ["{", "}"];
      if (ut(St) && (It = !0, Rt = ["[", "]"]), rt(St)) {
        var jt = St.name ? ": " + St.name : "";
        Wt = " [Function" + jt + "]";
      }
      if (At(St) && (Wt = " " + RegExp.prototype.toString.call(St)), Bt(St) && (Wt = " " + Date.prototype.toUTCString.call(St)), gt(St) && (Wt = " " + ke(St)), Pt.length === 0 && (!It || St.length == 0))
        return Rt[0] + Wt + Rt[1];
      if (Ft < 0)
        return At(St) ? lt.stylize(RegExp.prototype.toString.call(St), "regexp") : lt.stylize("[Object]", "special");
      lt.seen.push(St);
      var Jt;
      return It ? Jt = Oe(lt, St, Ft, Tt, Pt) : Jt = Pt.map(function(er) {
        return it(lt, St, Ft, Tt, er, It);
      }), lt.seen.pop(), at(Jt, Wt, Rt);
    }
    function oe(lt, St) {
      if (Ot(St))
        return lt.stylize("undefined", "undefined");
      if ($t(St)) {
        var Ft = "'" + JSON.stringify(St).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return lt.stylize(Ft, "string");
      }
      if (vt(St))
        return lt.stylize("" + St, "number");
      if (dt(St))
        return lt.stylize("" + St, "boolean");
      if (ct(St))
        return lt.stylize("null", "null");
    }
    function ke(lt) {
      return "[" + Error.prototype.toString.call(lt) + "]";
    }
    function Oe(lt, St, Ft, Gt, qt) {
      for (var Pt = [], Tt = 0, Ut = St.length; Tt < Ut; ++Tt)
        ht(St, String(Tt)) ? Pt.push(it(
          lt,
          St,
          Ft,
          Gt,
          String(Tt),
          !0
        )) : Pt.push("");
      return qt.forEach(function(Wt) {
        Wt.match(/^\d+$/) || Pt.push(it(
          lt,
          St,
          Ft,
          Gt,
          Wt,
          !0
        ));
      }), Pt;
    }
    function it(lt, St, Ft, Gt, qt, Pt) {
      var Tt, Ut, Wt;
      if (Wt = Object.getOwnPropertyDescriptor(St, qt) || { value: St[qt] }, Wt.get ? Wt.set ? Ut = lt.stylize("[Getter/Setter]", "special") : Ut = lt.stylize("[Getter]", "special") : Wt.set && (Ut = lt.stylize("[Setter]", "special")), ht(Gt, qt) || (Tt = "[" + qt + "]"), Ut || (lt.seen.indexOf(Wt.value) < 0 ? (ct(Ft) ? Ut = re(lt, Wt.value, null) : Ut = re(lt, Wt.value, Ft - 1), Ut.indexOf(`
`) > -1 && (Pt ? Ut = Ut.split(`
`).map(function(It) {
        return "  " + It;
      }).join(`
`).slice(2) : Ut = `
` + Ut.split(`
`).map(function(It) {
        return "   " + It;
      }).join(`
`))) : Ut = lt.stylize("[Circular]", "special")), Ot(Tt)) {
        if (Pt && qt.match(/^\d+$/))
          return Ut;
        Tt = JSON.stringify("" + qt), Tt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Tt = Tt.slice(1, -1), Tt = lt.stylize(Tt, "name")) : (Tt = Tt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Tt = lt.stylize(Tt, "string"));
      }
      return Tt + ": " + Ut;
    }
    function at(lt, St, Ft) {
      var Gt = lt.reduce(function(qt, Pt) {
        return Pt.indexOf(`
`) >= 0, qt + Pt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return Gt > 60 ? Ft[0] + (St === "" ? "" : St + `
 `) + " " + lt.join(`,
  `) + " " + Ft[1] : Ft[0] + St + " " + lt.join(", ") + " " + Ft[1];
    }
    A.types = requireTypes();
    function ut(lt) {
      return Array.isArray(lt);
    }
    A.isArray = ut;
    function dt(lt) {
      return typeof lt == "boolean";
    }
    A.isBoolean = dt;
    function ct(lt) {
      return lt === null;
    }
    A.isNull = ct;
    function bt(lt) {
      return lt == null;
    }
    A.isNullOrUndefined = bt;
    function vt(lt) {
      return typeof lt == "number";
    }
    A.isNumber = vt;
    function $t(lt) {
      return typeof lt == "string";
    }
    A.isString = $t;
    function xt(lt) {
      return typeof lt == "symbol";
    }
    A.isSymbol = xt;
    function Ot(lt) {
      return lt === void 0;
    }
    A.isUndefined = Ot;
    function At(lt) {
      return yt(lt) && pe(lt) === "[object RegExp]";
    }
    A.isRegExp = At, A.types.isRegExp = At;
    function yt(lt) {
      return typeof lt == "object" && lt !== null;
    }
    A.isObject = yt;
    function Bt(lt) {
      return yt(lt) && pe(lt) === "[object Date]";
    }
    A.isDate = Bt, A.types.isDate = Bt;
    function gt(lt) {
      return yt(lt) && (pe(lt) === "[object Error]" || lt instanceof Error);
    }
    A.isError = gt, A.types.isNativeError = gt;
    function rt(lt) {
      return typeof lt == "function";
    }
    A.isFunction = rt;
    function Ce(lt) {
      return lt === null || typeof lt == "boolean" || typeof lt == "number" || typeof lt == "string" || typeof lt == "symbol" || // ES6 symbol
      typeof lt > "u";
    }
    A.isPrimitive = Ce, A.isBuffer = requireIsBufferBrowser();
    function pe(lt) {
      return Object.prototype.toString.call(lt);
    }
    function nt(lt) {
      return lt < 10 ? "0" + lt.toString(10) : lt.toString(10);
    }
    var st = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function ot() {
      var lt = /* @__PURE__ */ new Date(), St = [
        nt(lt.getHours()),
        nt(lt.getMinutes()),
        nt(lt.getSeconds())
      ].join(":");
      return [lt.getDate(), st[lt.getMonth()], St].join(" ");
    }
    A.log = function() {
      console.log("%s - %s", ot(), A.format.apply(A, arguments));
    }, A.inherits = requireInherits_browser(), A._extend = function(lt, St) {
      if (!St || !yt(St)) return lt;
      for (var Ft = Object.keys(St), Gt = Ft.length; Gt--; )
        lt[Ft[Gt]] = St[Ft[Gt]];
      return lt;
    };
    function ht(lt, St) {
      return Object.prototype.hasOwnProperty.call(lt, St);
    }
    var pt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    A.promisify = function(St) {
      if (typeof St != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (pt && St[pt]) {
        var Ft = St[pt];
        if (typeof Ft != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(Ft, pt, {
          value: Ft,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), Ft;
      }
      function Ft() {
        for (var Gt, qt, Pt = new Promise(function(Wt, It) {
          Gt = Wt, qt = It;
        }), Tt = [], Ut = 0; Ut < arguments.length; Ut++)
          Tt.push(arguments[Ut]);
        Tt.push(function(Wt, It) {
          Wt ? qt(Wt) : Gt(It);
        });
        try {
          St.apply(this, Tt);
        } catch (Wt) {
          qt(Wt);
        }
        return Pt;
      }
      return Object.setPrototypeOf(Ft, Object.getPrototypeOf(St)), pt && Object.defineProperty(Ft, pt, {
        value: Ft,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        Ft,
        B(St)
      );
    }, A.promisify.custom = pt;
    function ft(lt, St) {
      if (!lt) {
        var Ft = new Error("Promise was rejected with a falsy value");
        Ft.reason = lt, lt = Ft;
      }
      return St(lt);
    }
    function mt(lt) {
      if (typeof lt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function St() {
        for (var Ft = [], Gt = 0; Gt < arguments.length; Gt++)
          Ft.push(arguments[Gt]);
        var qt = Ft.pop();
        if (typeof qt != "function")
          throw new TypeError("The last argument must be of type Function");
        var Pt = this, Tt = function() {
          return qt.apply(Pt, arguments);
        };
        lt.apply(this, Ft).then(
          function(Ut) {
            process$1.nextTick(Tt.bind(null, null, Ut));
          },
          function(Ut) {
            process$1.nextTick(ft.bind(null, Ut, Tt));
          }
        );
      }
      return Object.setPrototypeOf(St, Object.getPrototypeOf(lt)), Object.defineProperties(
        St,
        B(lt)
      ), St;
    }
    A.callbackify = mt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function A(it, at) {
    var ut = Object.keys(it);
    if (Object.getOwnPropertySymbols) {
      var dt = Object.getOwnPropertySymbols(it);
      at && (dt = dt.filter(function(ct) {
        return Object.getOwnPropertyDescriptor(it, ct).enumerable;
      })), ut.push.apply(ut, dt);
    }
    return ut;
  }
  function B(it) {
    for (var at = 1; at < arguments.length; at++) {
      var ut = arguments[at] != null ? arguments[at] : {};
      at % 2 ? A(Object(ut), !0).forEach(function(dt) {
        L(it, dt, ut[dt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(it, Object.getOwnPropertyDescriptors(ut)) : A(Object(ut)).forEach(function(dt) {
        Object.defineProperty(it, dt, Object.getOwnPropertyDescriptor(ut, dt));
      });
    }
    return it;
  }
  function L(it, at, ut) {
    return at = J(at), at in it ? Object.defineProperty(it, at, { value: ut, enumerable: !0, configurable: !0, writable: !0 }) : it[at] = ut, it;
  }
  function K(it, at) {
    if (!(it instanceof at))
      throw new TypeError("Cannot call a class as a function");
  }
  function V(it, at) {
    for (var ut = 0; ut < at.length; ut++) {
      var dt = at[ut];
      dt.enumerable = dt.enumerable || !1, dt.configurable = !0, "value" in dt && (dt.writable = !0), Object.defineProperty(it, J(dt.key), dt);
    }
  }
  function W(it, at, ut) {
    return at && V(it.prototype, at), Object.defineProperty(it, "prototype", { writable: !1 }), it;
  }
  function J(it) {
    var at = ne(it, "string");
    return typeof at == "symbol" ? at : String(at);
  }
  function ne(it, at) {
    if (typeof it != "object" || it === null) return it;
    var ut = it[Symbol.toPrimitive];
    if (ut !== void 0) {
      var dt = ut.call(it, at);
      if (typeof dt != "object") return dt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(it);
  }
  var ie = require$$0$1, ce = ie.Buffer, re = requireUtil$1(), oe = re.inspect, ke = oe && oe.custom || "inspect";
  function Oe(it, at, ut) {
    ce.prototype.copy.call(it, at, ut);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function it() {
      K(this, it), this.head = null, this.tail = null, this.length = 0;
    }
    return W(it, [{
      key: "push",
      value: function(ut) {
        var dt = {
          data: ut,
          next: null
        };
        this.length > 0 ? this.tail.next = dt : this.head = dt, this.tail = dt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ut) {
        var dt = {
          data: ut,
          next: this.head
        };
        this.length === 0 && (this.tail = dt), this.head = dt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ut = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ut;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ut) {
        if (this.length === 0) return "";
        for (var dt = this.head, ct = "" + dt.data; dt = dt.next; ) ct += ut + dt.data;
        return ct;
      }
    }, {
      key: "concat",
      value: function(ut) {
        if (this.length === 0) return ce.alloc(0);
        for (var dt = ce.allocUnsafe(ut >>> 0), ct = this.head, bt = 0; ct; )
          Oe(ct.data, dt, bt), bt += ct.data.length, ct = ct.next;
        return dt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ut, dt) {
        var ct;
        return ut < this.head.data.length ? (ct = this.head.data.slice(0, ut), this.head.data = this.head.data.slice(ut)) : ut === this.head.data.length ? ct = this.shift() : ct = dt ? this._getString(ut) : this._getBuffer(ut), ct;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ut) {
        var dt = this.head, ct = 1, bt = dt.data;
        for (ut -= bt.length; dt = dt.next; ) {
          var vt = dt.data, $t = ut > vt.length ? vt.length : ut;
          if ($t === vt.length ? bt += vt : bt += vt.slice(0, ut), ut -= $t, ut === 0) {
            $t === vt.length ? (++ct, dt.next ? this.head = dt.next : this.head = this.tail = null) : (this.head = dt, dt.data = vt.slice($t));
            break;
          }
          ++ct;
        }
        return this.length -= ct, bt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ut) {
        var dt = ce.allocUnsafe(ut), ct = this.head, bt = 1;
        for (ct.data.copy(dt), ut -= ct.data.length; ct = ct.next; ) {
          var vt = ct.data, $t = ut > vt.length ? vt.length : ut;
          if (vt.copy(dt, dt.length - ut, 0, $t), ut -= $t, ut === 0) {
            $t === vt.length ? (++bt, ct.next ? this.head = ct.next : this.head = this.tail = null) : (this.head = ct, ct.data = vt.slice($t));
            break;
          }
          ++bt;
        }
        return this.length -= bt, dt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: ke,
      value: function(ut, dt) {
        return oe(this, B(B({}, dt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), it;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function A(J, ne) {
    var ie = this, ce = this._readableState && this._readableState.destroyed, re = this._writableState && this._writableState.destroyed;
    return ce || re ? (ne ? ne(J) : J && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(V, this, J)) : process$1.nextTick(V, this, J)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(J || null, function(oe) {
      !ne && oe ? ie._writableState ? ie._writableState.errorEmitted ? process$1.nextTick(L, ie) : (ie._writableState.errorEmitted = !0, process$1.nextTick(B, ie, oe)) : process$1.nextTick(B, ie, oe) : ne ? (process$1.nextTick(L, ie), ne(oe)) : process$1.nextTick(L, ie);
    }), this);
  }
  function B(J, ne) {
    V(J, ne), L(J);
  }
  function L(J) {
    J._writableState && !J._writableState.emitClose || J._readableState && !J._readableState.emitClose || J.emit("close");
  }
  function K() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function V(J, ne) {
    J.emit("error", ne);
  }
  function W(J, ne) {
    var ie = J._readableState, ce = J._writableState;
    ie && ie.autoDestroy || ce && ce.autoDestroy ? J.destroy(ne) : J.emit("error", ne);
  }
  return destroy_1$1 = {
    destroy: A,
    undestroy: K,
    errorOrDestroy: W
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function A(ne, ie) {
    ne.prototype = Object.create(ie.prototype), ne.prototype.constructor = ne, ne.__proto__ = ie;
  }
  var B = {};
  function L(ne, ie, ce) {
    ce || (ce = Error);
    function re(ke, Oe, it) {
      return typeof ie == "string" ? ie : ie(ke, Oe, it);
    }
    var oe = /* @__PURE__ */ function(ke) {
      A(Oe, ke);
      function Oe(it, at, ut) {
        return ke.call(this, re(it, at, ut)) || this;
      }
      return Oe;
    }(ce);
    oe.prototype.name = ce.name, oe.prototype.code = ne, B[ne] = oe;
  }
  function K(ne, ie) {
    if (Array.isArray(ne)) {
      var ce = ne.length;
      return ne = ne.map(function(re) {
        return String(re);
      }), ce > 2 ? "one of ".concat(ie, " ").concat(ne.slice(0, ce - 1).join(", "), ", or ") + ne[ce - 1] : ce === 2 ? "one of ".concat(ie, " ").concat(ne[0], " or ").concat(ne[1]) : "of ".concat(ie, " ").concat(ne[0]);
    } else
      return "of ".concat(ie, " ").concat(String(ne));
  }
  function V(ne, ie, ce) {
    return ne.substr(0, ie.length) === ie;
  }
  function W(ne, ie, ce) {
    return (ce === void 0 || ce > ne.length) && (ce = ne.length), ne.substring(ce - ie.length, ce) === ie;
  }
  function J(ne, ie, ce) {
    return typeof ce != "number" && (ce = 0), ce + ie.length > ne.length ? !1 : ne.indexOf(ie, ce) !== -1;
  }
  return L("ERR_INVALID_OPT_VALUE", function(ne, ie) {
    return 'The value "' + ie + '" is invalid for option "' + ne + '"';
  }, TypeError), L("ERR_INVALID_ARG_TYPE", function(ne, ie, ce) {
    var re;
    typeof ie == "string" && V(ie, "not ") ? (re = "must not be", ie = ie.replace(/^not /, "")) : re = "must be";
    var oe;
    if (W(ne, " argument"))
      oe = "The ".concat(ne, " ").concat(re, " ").concat(K(ie, "type"));
    else {
      var ke = J(ne, ".") ? "property" : "argument";
      oe = 'The "'.concat(ne, '" ').concat(ke, " ").concat(re, " ").concat(K(ie, "type"));
    }
    return oe += ". Received type ".concat(typeof ce), oe;
  }, TypeError), L("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), L("ERR_METHOD_NOT_IMPLEMENTED", function(ne) {
    return "The " + ne + " method is not implemented";
  }), L("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), L("ERR_STREAM_DESTROYED", function(ne) {
    return "Cannot call " + ne + " after a stream was destroyed";
  }), L("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), L("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), L("ERR_STREAM_WRITE_AFTER_END", "write after end"), L("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), L("ERR_UNKNOWN_ENCODING", function(ne) {
    return "Unknown encoding: " + ne;
  }, TypeError), L("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = B, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var A = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function B(K, V, W) {
    return K.highWaterMark != null ? K.highWaterMark : V ? K[W] : null;
  }
  function L(K, V, W, J) {
    var ne = B(V, J, W);
    if (ne != null) {
      if (!(isFinite(ne) && Math.floor(ne) === ne) || ne < 0) {
        var ie = J ? W : "highWaterMark";
        throw new A(ie, ne);
      }
      return Math.floor(ne);
    }
    return K.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: L
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = A;
  function A(L, K) {
    if (B("noDeprecation"))
      return L;
    var V = !1;
    function W() {
      if (!V) {
        if (B("throwDeprecation"))
          throw new Error(K);
        B("traceDeprecation") ? console.trace(K) : console.warn(K), V = !0;
      }
      return L.apply(this, arguments);
    }
    return W;
  }
  function B(L) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var K = commonjsGlobal.localStorage[L];
    return K == null ? !1 : String(K).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = At;
  function A(qt) {
    var Pt = this;
    this.next = null, this.entry = null, this.finish = function() {
      Gt(Pt, qt);
    };
  }
  var B;
  At.WritableState = xt;
  var L = {
    deprecate: requireBrowser$a()
  }, K = requireStreamBrowser$1(), V = require$$0$1.Buffer, W = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function J(qt) {
    return V.from(qt);
  }
  function ne(qt) {
    return V.isBuffer(qt) || qt instanceof W;
  }
  var ie = requireDestroy$1(), ce = requireState(), re = ce.getHighWaterMark, oe = requireErrorsBrowser().codes, ke = oe.ERR_INVALID_ARG_TYPE, Oe = oe.ERR_METHOD_NOT_IMPLEMENTED, it = oe.ERR_MULTIPLE_CALLBACK, at = oe.ERR_STREAM_CANNOT_PIPE, ut = oe.ERR_STREAM_DESTROYED, dt = oe.ERR_STREAM_NULL_VALUES, ct = oe.ERR_STREAM_WRITE_AFTER_END, bt = oe.ERR_UNKNOWN_ENCODING, vt = ie.errorOrDestroy;
  requireInherits_browser()(At, K);
  function $t() {
  }
  function xt(qt, Pt, Tt) {
    B = B || require_stream_duplex$1(), qt = qt || {}, typeof Tt != "boolean" && (Tt = Pt instanceof B), this.objectMode = !!qt.objectMode, Tt && (this.objectMode = this.objectMode || !!qt.writableObjectMode), this.highWaterMark = re(this, qt, "writableHighWaterMark", Tt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ut = qt.decodeStrings === !1;
    this.decodeStrings = !Ut, this.defaultEncoding = qt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Wt) {
      st(Pt, Wt);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = qt.emitClose !== !1, this.autoDestroy = !!qt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new A(this);
  }
  xt.prototype.getBuffer = function() {
    for (var Pt = this.bufferedRequest, Tt = []; Pt; )
      Tt.push(Pt), Pt = Pt.next;
    return Tt;
  }, function() {
    try {
      Object.defineProperty(xt.prototype, "buffer", {
        get: L.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Ot;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Ot = Function.prototype[Symbol.hasInstance], Object.defineProperty(At, Symbol.hasInstance, {
    value: function(Pt) {
      return Ot.call(this, Pt) ? !0 : this !== At ? !1 : Pt && Pt._writableState instanceof xt;
    }
  })) : Ot = function(Pt) {
    return Pt instanceof this;
  };
  function At(qt) {
    B = B || require_stream_duplex$1();
    var Pt = this instanceof B;
    if (!Pt && !Ot.call(At, this)) return new At(qt);
    this._writableState = new xt(qt, this, Pt), this.writable = !0, qt && (typeof qt.write == "function" && (this._write = qt.write), typeof qt.writev == "function" && (this._writev = qt.writev), typeof qt.destroy == "function" && (this._destroy = qt.destroy), typeof qt.final == "function" && (this._final = qt.final)), K.call(this);
  }
  At.prototype.pipe = function() {
    vt(this, new at());
  };
  function yt(qt, Pt) {
    var Tt = new ct();
    vt(qt, Tt), process$1.nextTick(Pt, Tt);
  }
  function Bt(qt, Pt, Tt, Ut) {
    var Wt;
    return Tt === null ? Wt = new dt() : typeof Tt != "string" && !Pt.objectMode && (Wt = new ke("chunk", ["string", "Buffer"], Tt)), Wt ? (vt(qt, Wt), process$1.nextTick(Ut, Wt), !1) : !0;
  }
  At.prototype.write = function(qt, Pt, Tt) {
    var Ut = this._writableState, Wt = !1, It = !Ut.objectMode && ne(qt);
    return It && !V.isBuffer(qt) && (qt = J(qt)), typeof Pt == "function" && (Tt = Pt, Pt = null), It ? Pt = "buffer" : Pt || (Pt = Ut.defaultEncoding), typeof Tt != "function" && (Tt = $t), Ut.ending ? yt(this, Tt) : (It || Bt(this, Ut, qt, Tt)) && (Ut.pendingcb++, Wt = rt(this, Ut, It, qt, Pt, Tt)), Wt;
  }, At.prototype.cork = function() {
    this._writableState.corked++;
  }, At.prototype.uncork = function() {
    var qt = this._writableState;
    qt.corked && (qt.corked--, !qt.writing && !qt.corked && !qt.bufferProcessing && qt.bufferedRequest && pt(this, qt));
  }, At.prototype.setDefaultEncoding = function(Pt) {
    if (typeof Pt == "string" && (Pt = Pt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Pt + "").toLowerCase()) > -1)) throw new bt(Pt);
    return this._writableState.defaultEncoding = Pt, this;
  }, Object.defineProperty(At.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function gt(qt, Pt, Tt) {
    return !qt.objectMode && qt.decodeStrings !== !1 && typeof Pt == "string" && (Pt = V.from(Pt, Tt)), Pt;
  }
  Object.defineProperty(At.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function rt(qt, Pt, Tt, Ut, Wt, It) {
    if (!Tt) {
      var Rt = gt(Pt, Ut, Wt);
      Ut !== Rt && (Tt = !0, Wt = "buffer", Ut = Rt);
    }
    var jt = Pt.objectMode ? 1 : Ut.length;
    Pt.length += jt;
    var Jt = Pt.length < Pt.highWaterMark;
    if (Jt || (Pt.needDrain = !0), Pt.writing || Pt.corked) {
      var er = Pt.lastBufferedRequest;
      Pt.lastBufferedRequest = {
        chunk: Ut,
        encoding: Wt,
        isBuf: Tt,
        callback: It,
        next: null
      }, er ? er.next = Pt.lastBufferedRequest : Pt.bufferedRequest = Pt.lastBufferedRequest, Pt.bufferedRequestCount += 1;
    } else
      Ce(qt, Pt, !1, jt, Ut, Wt, It);
    return Jt;
  }
  function Ce(qt, Pt, Tt, Ut, Wt, It, Rt) {
    Pt.writelen = Ut, Pt.writecb = Rt, Pt.writing = !0, Pt.sync = !0, Pt.destroyed ? Pt.onwrite(new ut("write")) : Tt ? qt._writev(Wt, Pt.onwrite) : qt._write(Wt, It, Pt.onwrite), Pt.sync = !1;
  }
  function pe(qt, Pt, Tt, Ut, Wt) {
    --Pt.pendingcb, Tt ? (process$1.nextTick(Wt, Ut), process$1.nextTick(St, qt, Pt), qt._writableState.errorEmitted = !0, vt(qt, Ut)) : (Wt(Ut), qt._writableState.errorEmitted = !0, vt(qt, Ut), St(qt, Pt));
  }
  function nt(qt) {
    qt.writing = !1, qt.writecb = null, qt.length -= qt.writelen, qt.writelen = 0;
  }
  function st(qt, Pt) {
    var Tt = qt._writableState, Ut = Tt.sync, Wt = Tt.writecb;
    if (typeof Wt != "function") throw new it();
    if (nt(Tt), Pt) pe(qt, Tt, Ut, Pt, Wt);
    else {
      var It = ft(Tt) || qt.destroyed;
      !It && !Tt.corked && !Tt.bufferProcessing && Tt.bufferedRequest && pt(qt, Tt), Ut ? process$1.nextTick(ot, qt, Tt, It, Wt) : ot(qt, Tt, It, Wt);
    }
  }
  function ot(qt, Pt, Tt, Ut) {
    Tt || ht(qt, Pt), Pt.pendingcb--, Ut(), St(qt, Pt);
  }
  function ht(qt, Pt) {
    Pt.length === 0 && Pt.needDrain && (Pt.needDrain = !1, qt.emit("drain"));
  }
  function pt(qt, Pt) {
    Pt.bufferProcessing = !0;
    var Tt = Pt.bufferedRequest;
    if (qt._writev && Tt && Tt.next) {
      var Ut = Pt.bufferedRequestCount, Wt = new Array(Ut), It = Pt.corkedRequestsFree;
      It.entry = Tt;
      for (var Rt = 0, jt = !0; Tt; )
        Wt[Rt] = Tt, Tt.isBuf || (jt = !1), Tt = Tt.next, Rt += 1;
      Wt.allBuffers = jt, Ce(qt, Pt, !0, Pt.length, Wt, "", It.finish), Pt.pendingcb++, Pt.lastBufferedRequest = null, It.next ? (Pt.corkedRequestsFree = It.next, It.next = null) : Pt.corkedRequestsFree = new A(Pt), Pt.bufferedRequestCount = 0;
    } else {
      for (; Tt; ) {
        var Jt = Tt.chunk, er = Tt.encoding, nr = Tt.callback, fr = Pt.objectMode ? 1 : Jt.length;
        if (Ce(qt, Pt, !1, fr, Jt, er, nr), Tt = Tt.next, Pt.bufferedRequestCount--, Pt.writing)
          break;
      }
      Tt === null && (Pt.lastBufferedRequest = null);
    }
    Pt.bufferedRequest = Tt, Pt.bufferProcessing = !1;
  }
  At.prototype._write = function(qt, Pt, Tt) {
    Tt(new Oe("_write()"));
  }, At.prototype._writev = null, At.prototype.end = function(qt, Pt, Tt) {
    var Ut = this._writableState;
    return typeof qt == "function" ? (Tt = qt, qt = null, Pt = null) : typeof Pt == "function" && (Tt = Pt, Pt = null), qt != null && this.write(qt, Pt), Ut.corked && (Ut.corked = 1, this.uncork()), Ut.ending || Ft(this, Ut, Tt), this;
  }, Object.defineProperty(At.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ft(qt) {
    return qt.ending && qt.length === 0 && qt.bufferedRequest === null && !qt.finished && !qt.writing;
  }
  function mt(qt, Pt) {
    qt._final(function(Tt) {
      Pt.pendingcb--, Tt && vt(qt, Tt), Pt.prefinished = !0, qt.emit("prefinish"), St(qt, Pt);
    });
  }
  function lt(qt, Pt) {
    !Pt.prefinished && !Pt.finalCalled && (typeof qt._final == "function" && !Pt.destroyed ? (Pt.pendingcb++, Pt.finalCalled = !0, process$1.nextTick(mt, qt, Pt)) : (Pt.prefinished = !0, qt.emit("prefinish")));
  }
  function St(qt, Pt) {
    var Tt = ft(Pt);
    if (Tt && (lt(qt, Pt), Pt.pendingcb === 0 && (Pt.finished = !0, qt.emit("finish"), Pt.autoDestroy))) {
      var Ut = qt._readableState;
      (!Ut || Ut.autoDestroy && Ut.endEmitted) && qt.destroy();
    }
    return Tt;
  }
  function Ft(qt, Pt, Tt) {
    Pt.ending = !0, St(qt, Pt), Tt && (Pt.finished ? process$1.nextTick(Tt) : qt.once("finish", Tt)), Pt.ended = !0, qt.writable = !1;
  }
  function Gt(qt, Pt, Tt) {
    var Ut = qt.entry;
    for (qt.entry = null; Ut; ) {
      var Wt = Ut.callback;
      Pt.pendingcb--, Wt(Tt), Ut = Ut.next;
    }
    Pt.corkedRequestsFree.next = qt;
  }
  return Object.defineProperty(At.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Pt) {
      this._writableState && (this._writableState.destroyed = Pt);
    }
  }), At.prototype.destroy = ie.destroy, At.prototype._undestroy = ie.undestroy, At.prototype._destroy = function(qt, Pt) {
    Pt(qt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var A = Object.keys || function(ce) {
    var re = [];
    for (var oe in ce) re.push(oe);
    return re;
  };
  _stream_duplex$1 = J;
  var B = require_stream_readable$1(), L = require_stream_writable$1();
  requireInherits_browser()(J, B);
  for (var K = A(L.prototype), V = 0; V < K.length; V++) {
    var W = K[V];
    J.prototype[W] || (J.prototype[W] = L.prototype[W]);
  }
  function J(ce) {
    if (!(this instanceof J)) return new J(ce);
    B.call(this, ce), L.call(this, ce), this.allowHalfOpen = !0, ce && (ce.readable === !1 && (this.readable = !1), ce.writable === !1 && (this.writable = !1), ce.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", ne)));
  }
  Object.defineProperty(J.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(J.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(J.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function ne() {
    this._writableState.ended || process$1.nextTick(ie, this);
  }
  function ie(ce) {
    ce.end();
  }
  return Object.defineProperty(J.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(re) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = re, this._writableState.destroyed = re);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var A = safeBufferExports.Buffer, B = A.isEncoding || function(dt) {
    switch (dt = "" + dt, dt && dt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function L(dt) {
    if (!dt) return "utf8";
    for (var ct; ; )
      switch (dt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return dt;
        default:
          if (ct) return;
          dt = ("" + dt).toLowerCase(), ct = !0;
      }
  }
  function K(dt) {
    var ct = L(dt);
    if (typeof ct != "string" && (A.isEncoding === B || !B(dt))) throw new Error("Unknown encoding: " + dt);
    return ct || dt;
  }
  string_decoder.StringDecoder = V;
  function V(dt) {
    this.encoding = K(dt);
    var ct;
    switch (this.encoding) {
      case "utf16le":
        this.text = oe, this.end = ke, ct = 4;
        break;
      case "utf8":
        this.fillLast = ie, ct = 4;
        break;
      case "base64":
        this.text = Oe, this.end = it, ct = 3;
        break;
      default:
        this.write = at, this.end = ut;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = A.allocUnsafe(ct);
  }
  V.prototype.write = function(dt) {
    if (dt.length === 0) return "";
    var ct, bt;
    if (this.lastNeed) {
      if (ct = this.fillLast(dt), ct === void 0) return "";
      bt = this.lastNeed, this.lastNeed = 0;
    } else
      bt = 0;
    return bt < dt.length ? ct ? ct + this.text(dt, bt) : this.text(dt, bt) : ct || "";
  }, V.prototype.end = re, V.prototype.text = ce, V.prototype.fillLast = function(dt) {
    if (this.lastNeed <= dt.length)
      return dt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    dt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, dt.length), this.lastNeed -= dt.length;
  };
  function W(dt) {
    return dt <= 127 ? 0 : dt >> 5 === 6 ? 2 : dt >> 4 === 14 ? 3 : dt >> 3 === 30 ? 4 : dt >> 6 === 2 ? -1 : -2;
  }
  function J(dt, ct, bt) {
    var vt = ct.length - 1;
    if (vt < bt) return 0;
    var $t = W(ct[vt]);
    return $t >= 0 ? ($t > 0 && (dt.lastNeed = $t - 1), $t) : --vt < bt || $t === -2 ? 0 : ($t = W(ct[vt]), $t >= 0 ? ($t > 0 && (dt.lastNeed = $t - 2), $t) : --vt < bt || $t === -2 ? 0 : ($t = W(ct[vt]), $t >= 0 ? ($t > 0 && ($t === 2 ? $t = 0 : dt.lastNeed = $t - 3), $t) : 0));
  }
  function ne(dt, ct, bt) {
    if ((ct[0] & 192) !== 128)
      return dt.lastNeed = 0, "";
    if (dt.lastNeed > 1 && ct.length > 1) {
      if ((ct[1] & 192) !== 128)
        return dt.lastNeed = 1, "";
      if (dt.lastNeed > 2 && ct.length > 2 && (ct[2] & 192) !== 128)
        return dt.lastNeed = 2, "";
    }
  }
  function ie(dt) {
    var ct = this.lastTotal - this.lastNeed, bt = ne(this, dt);
    if (bt !== void 0) return bt;
    if (this.lastNeed <= dt.length)
      return dt.copy(this.lastChar, ct, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    dt.copy(this.lastChar, ct, 0, dt.length), this.lastNeed -= dt.length;
  }
  function ce(dt, ct) {
    var bt = J(this, dt, ct);
    if (!this.lastNeed) return dt.toString("utf8", ct);
    this.lastTotal = bt;
    var vt = dt.length - (bt - this.lastNeed);
    return dt.copy(this.lastChar, 0, vt), dt.toString("utf8", ct, vt);
  }
  function re(dt) {
    var ct = dt && dt.length ? this.write(dt) : "";
    return this.lastNeed ? ct + "" : ct;
  }
  function oe(dt, ct) {
    if ((dt.length - ct) % 2 === 0) {
      var bt = dt.toString("utf16le", ct);
      if (bt) {
        var vt = bt.charCodeAt(bt.length - 1);
        if (vt >= 55296 && vt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = dt[dt.length - 2], this.lastChar[1] = dt[dt.length - 1], bt.slice(0, -1);
      }
      return bt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = dt[dt.length - 1], dt.toString("utf16le", ct, dt.length - 1);
  }
  function ke(dt) {
    var ct = dt && dt.length ? this.write(dt) : "";
    if (this.lastNeed) {
      var bt = this.lastTotal - this.lastNeed;
      return ct + this.lastChar.toString("utf16le", 0, bt);
    }
    return ct;
  }
  function Oe(dt, ct) {
    var bt = (dt.length - ct) % 3;
    return bt === 0 ? dt.toString("base64", ct) : (this.lastNeed = 3 - bt, this.lastTotal = 3, bt === 1 ? this.lastChar[0] = dt[dt.length - 1] : (this.lastChar[0] = dt[dt.length - 2], this.lastChar[1] = dt[dt.length - 1]), dt.toString("base64", ct, dt.length - bt));
  }
  function it(dt) {
    var ct = dt && dt.length ? this.write(dt) : "";
    return this.lastNeed ? ct + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ct;
  }
  function at(dt) {
    return dt.toString(this.encoding);
  }
  function ut(dt) {
    return dt && dt.length ? this.write(dt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var A = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function B(W) {
    var J = !1;
    return function() {
      if (!J) {
        J = !0;
        for (var ne = arguments.length, ie = new Array(ne), ce = 0; ce < ne; ce++)
          ie[ce] = arguments[ce];
        W.apply(this, ie);
      }
    };
  }
  function L() {
  }
  function K(W) {
    return W.setHeader && typeof W.abort == "function";
  }
  function V(W, J, ne) {
    if (typeof J == "function") return V(W, null, J);
    J || (J = {}), ne = B(ne || L);
    var ie = J.readable || J.readable !== !1 && W.readable, ce = J.writable || J.writable !== !1 && W.writable, re = function() {
      W.writable || ke();
    }, oe = W._writableState && W._writableState.finished, ke = function() {
      ce = !1, oe = !0, ie || ne.call(W);
    }, Oe = W._readableState && W._readableState.endEmitted, it = function() {
      ie = !1, Oe = !0, ce || ne.call(W);
    }, at = function(bt) {
      ne.call(W, bt);
    }, ut = function() {
      var bt;
      if (ie && !Oe)
        return (!W._readableState || !W._readableState.ended) && (bt = new A()), ne.call(W, bt);
      if (ce && !oe)
        return (!W._writableState || !W._writableState.ended) && (bt = new A()), ne.call(W, bt);
    }, dt = function() {
      W.req.on("finish", ke);
    };
    return K(W) ? (W.on("complete", ke), W.on("abort", ut), W.req ? dt() : W.on("request", dt)) : ce && !W._writableState && (W.on("end", re), W.on("close", re)), W.on("end", it), W.on("finish", ke), J.error !== !1 && W.on("error", at), W.on("close", ut), function() {
      W.removeListener("complete", ke), W.removeListener("abort", ut), W.removeListener("request", dt), W.req && W.req.removeListener("finish", ke), W.removeListener("end", re), W.removeListener("close", re), W.removeListener("finish", ke), W.removeListener("end", it), W.removeListener("error", at), W.removeListener("close", ut);
    };
  }
  return endOfStream = V, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var A;
  function B(bt, vt, $t) {
    return vt = L(vt), vt in bt ? Object.defineProperty(bt, vt, { value: $t, enumerable: !0, configurable: !0, writable: !0 }) : bt[vt] = $t, bt;
  }
  function L(bt) {
    var vt = K(bt, "string");
    return typeof vt == "symbol" ? vt : String(vt);
  }
  function K(bt, vt) {
    if (typeof bt != "object" || bt === null) return bt;
    var $t = bt[Symbol.toPrimitive];
    if ($t !== void 0) {
      var xt = $t.call(bt, vt);
      if (typeof xt != "object") return xt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (vt === "string" ? String : Number)(bt);
  }
  var V = requireEndOfStream(), W = Symbol("lastResolve"), J = Symbol("lastReject"), ne = Symbol("error"), ie = Symbol("ended"), ce = Symbol("lastPromise"), re = Symbol("handlePromise"), oe = Symbol("stream");
  function ke(bt, vt) {
    return {
      value: bt,
      done: vt
    };
  }
  function Oe(bt) {
    var vt = bt[W];
    if (vt !== null) {
      var $t = bt[oe].read();
      $t !== null && (bt[ce] = null, bt[W] = null, bt[J] = null, vt(ke($t, !1)));
    }
  }
  function it(bt) {
    process$1.nextTick(Oe, bt);
  }
  function at(bt, vt) {
    return function($t, xt) {
      bt.then(function() {
        if (vt[ie]) {
          $t(ke(void 0, !0));
          return;
        }
        vt[re]($t, xt);
      }, xt);
    };
  }
  var ut = Object.getPrototypeOf(function() {
  }), dt = Object.setPrototypeOf((A = {
    get stream() {
      return this[oe];
    },
    next: function() {
      var vt = this, $t = this[ne];
      if ($t !== null)
        return Promise.reject($t);
      if (this[ie])
        return Promise.resolve(ke(void 0, !0));
      if (this[oe].destroyed)
        return new Promise(function(yt, Bt) {
          process$1.nextTick(function() {
            vt[ne] ? Bt(vt[ne]) : yt(ke(void 0, !0));
          });
        });
      var xt = this[ce], Ot;
      if (xt)
        Ot = new Promise(at(xt, this));
      else {
        var At = this[oe].read();
        if (At !== null)
          return Promise.resolve(ke(At, !1));
        Ot = new Promise(this[re]);
      }
      return this[ce] = Ot, Ot;
    }
  }, B(A, Symbol.asyncIterator, function() {
    return this;
  }), B(A, "return", function() {
    var vt = this;
    return new Promise(function($t, xt) {
      vt[oe].destroy(null, function(Ot) {
        if (Ot) {
          xt(Ot);
          return;
        }
        $t(ke(void 0, !0));
      });
    });
  }), A), ut), ct = function(vt) {
    var $t, xt = Object.create(dt, ($t = {}, B($t, oe, {
      value: vt,
      writable: !0
    }), B($t, W, {
      value: null,
      writable: !0
    }), B($t, J, {
      value: null,
      writable: !0
    }), B($t, ne, {
      value: null,
      writable: !0
    }), B($t, ie, {
      value: vt._readableState.endEmitted,
      writable: !0
    }), B($t, re, {
      value: function(At, yt) {
        var Bt = xt[oe].read();
        Bt ? (xt[ce] = null, xt[W] = null, xt[J] = null, At(ke(Bt, !1))) : (xt[W] = At, xt[J] = yt);
      },
      writable: !0
    }), $t));
    return xt[ce] = null, V(vt, function(Ot) {
      if (Ot && Ot.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var At = xt[J];
        At !== null && (xt[ce] = null, xt[W] = null, xt[J] = null, At(Ot)), xt[ne] = Ot;
        return;
      }
      var yt = xt[W];
      yt !== null && (xt[ce] = null, xt[W] = null, xt[J] = null, yt(ke(void 0, !0))), xt[ie] = !0;
    }), vt.on("readable", it.bind(null, xt)), xt;
  };
  return async_iterator = ct, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = yt;
  var A;
  yt.ReadableState = At, requireEvents().EventEmitter;
  var B = function(Rt, jt) {
    return Rt.listeners(jt).length;
  }, L = requireStreamBrowser$1(), K = require$$0$1.Buffer, V = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function W(It) {
    return K.from(It);
  }
  function J(It) {
    return K.isBuffer(It) || It instanceof V;
  }
  var ne = requireUtil$1(), ie;
  ne && ne.debuglog ? ie = ne.debuglog("stream") : ie = function() {
  };
  var ce = requireBuffer_list(), re = requireDestroy$1(), oe = requireState(), ke = oe.getHighWaterMark, Oe = requireErrorsBrowser().codes, it = Oe.ERR_INVALID_ARG_TYPE, at = Oe.ERR_STREAM_PUSH_AFTER_EOF, ut = Oe.ERR_METHOD_NOT_IMPLEMENTED, dt = Oe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ct, bt, vt;
  requireInherits_browser()(yt, L);
  var $t = re.errorOrDestroy, xt = ["error", "close", "destroy", "pause", "resume"];
  function Ot(It, Rt, jt) {
    if (typeof It.prependListener == "function") return It.prependListener(Rt, jt);
    !It._events || !It._events[Rt] ? It.on(Rt, jt) : Array.isArray(It._events[Rt]) ? It._events[Rt].unshift(jt) : It._events[Rt] = [jt, It._events[Rt]];
  }
  function At(It, Rt, jt) {
    A = A || require_stream_duplex$1(), It = It || {}, typeof jt != "boolean" && (jt = Rt instanceof A), this.objectMode = !!It.objectMode, jt && (this.objectMode = this.objectMode || !!It.readableObjectMode), this.highWaterMark = ke(this, It, "readableHighWaterMark", jt), this.buffer = new ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = It.emitClose !== !1, this.autoDestroy = !!It.autoDestroy, this.destroyed = !1, this.defaultEncoding = It.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, It.encoding && (ct || (ct = requireString_decoder().StringDecoder), this.decoder = new ct(It.encoding), this.encoding = It.encoding);
  }
  function yt(It) {
    if (A = A || require_stream_duplex$1(), !(this instanceof yt)) return new yt(It);
    var Rt = this instanceof A;
    this._readableState = new At(It, this, Rt), this.readable = !0, It && (typeof It.read == "function" && (this._read = It.read), typeof It.destroy == "function" && (this._destroy = It.destroy)), L.call(this);
  }
  Object.defineProperty(yt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Rt) {
      this._readableState && (this._readableState.destroyed = Rt);
    }
  }), yt.prototype.destroy = re.destroy, yt.prototype._undestroy = re.undestroy, yt.prototype._destroy = function(It, Rt) {
    Rt(It);
  }, yt.prototype.push = function(It, Rt) {
    var jt = this._readableState, Jt;
    return jt.objectMode ? Jt = !0 : typeof It == "string" && (Rt = Rt || jt.defaultEncoding, Rt !== jt.encoding && (It = K.from(It, Rt), Rt = ""), Jt = !0), Bt(this, It, Rt, !1, Jt);
  }, yt.prototype.unshift = function(It) {
    return Bt(this, It, null, !0, !1);
  };
  function Bt(It, Rt, jt, Jt, er) {
    ie("readableAddChunk", Rt);
    var nr = It._readableState;
    if (Rt === null)
      nr.reading = !1, st(It, nr);
    else {
      var fr;
      if (er || (fr = rt(nr, Rt)), fr)
        $t(It, fr);
      else if (nr.objectMode || Rt && Rt.length > 0)
        if (typeof Rt != "string" && !nr.objectMode && Object.getPrototypeOf(Rt) !== K.prototype && (Rt = W(Rt)), Jt)
          nr.endEmitted ? $t(It, new dt()) : gt(It, nr, Rt, !0);
        else if (nr.ended)
          $t(It, new at());
        else {
          if (nr.destroyed)
            return !1;
          nr.reading = !1, nr.decoder && !jt ? (Rt = nr.decoder.write(Rt), nr.objectMode || Rt.length !== 0 ? gt(It, nr, Rt, !1) : pt(It, nr)) : gt(It, nr, Rt, !1);
        }
      else Jt || (nr.reading = !1, pt(It, nr));
    }
    return !nr.ended && (nr.length < nr.highWaterMark || nr.length === 0);
  }
  function gt(It, Rt, jt, Jt) {
    Rt.flowing && Rt.length === 0 && !Rt.sync ? (Rt.awaitDrain = 0, It.emit("data", jt)) : (Rt.length += Rt.objectMode ? 1 : jt.length, Jt ? Rt.buffer.unshift(jt) : Rt.buffer.push(jt), Rt.needReadable && ot(It)), pt(It, Rt);
  }
  function rt(It, Rt) {
    var jt;
    return !J(Rt) && typeof Rt != "string" && Rt !== void 0 && !It.objectMode && (jt = new it("chunk", ["string", "Buffer", "Uint8Array"], Rt)), jt;
  }
  yt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, yt.prototype.setEncoding = function(It) {
    ct || (ct = requireString_decoder().StringDecoder);
    var Rt = new ct(It);
    this._readableState.decoder = Rt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var jt = this._readableState.buffer.head, Jt = ""; jt !== null; )
      Jt += Rt.write(jt.data), jt = jt.next;
    return this._readableState.buffer.clear(), Jt !== "" && this._readableState.buffer.push(Jt), this._readableState.length = Jt.length, this;
  };
  var Ce = 1073741824;
  function pe(It) {
    return It >= Ce ? It = Ce : (It--, It |= It >>> 1, It |= It >>> 2, It |= It >>> 4, It |= It >>> 8, It |= It >>> 16, It++), It;
  }
  function nt(It, Rt) {
    return It <= 0 || Rt.length === 0 && Rt.ended ? 0 : Rt.objectMode ? 1 : It !== It ? Rt.flowing && Rt.length ? Rt.buffer.head.data.length : Rt.length : (It > Rt.highWaterMark && (Rt.highWaterMark = pe(It)), It <= Rt.length ? It : Rt.ended ? Rt.length : (Rt.needReadable = !0, 0));
  }
  yt.prototype.read = function(It) {
    ie("read", It), It = parseInt(It, 10);
    var Rt = this._readableState, jt = It;
    if (It !== 0 && (Rt.emittedReadable = !1), It === 0 && Rt.needReadable && ((Rt.highWaterMark !== 0 ? Rt.length >= Rt.highWaterMark : Rt.length > 0) || Rt.ended))
      return ie("read: emitReadable", Rt.length, Rt.ended), Rt.length === 0 && Rt.ended ? Tt(this) : ot(this), null;
    if (It = nt(It, Rt), It === 0 && Rt.ended)
      return Rt.length === 0 && Tt(this), null;
    var Jt = Rt.needReadable;
    ie("need readable", Jt), (Rt.length === 0 || Rt.length - It < Rt.highWaterMark) && (Jt = !0, ie("length less than watermark", Jt)), Rt.ended || Rt.reading ? (Jt = !1, ie("reading or ended", Jt)) : Jt && (ie("do read"), Rt.reading = !0, Rt.sync = !0, Rt.length === 0 && (Rt.needReadable = !0), this._read(Rt.highWaterMark), Rt.sync = !1, Rt.reading || (It = nt(jt, Rt)));
    var er;
    return It > 0 ? er = Pt(It, Rt) : er = null, er === null ? (Rt.needReadable = Rt.length <= Rt.highWaterMark, It = 0) : (Rt.length -= It, Rt.awaitDrain = 0), Rt.length === 0 && (Rt.ended || (Rt.needReadable = !0), jt !== It && Rt.ended && Tt(this)), er !== null && this.emit("data", er), er;
  };
  function st(It, Rt) {
    if (ie("onEofChunk"), !Rt.ended) {
      if (Rt.decoder) {
        var jt = Rt.decoder.end();
        jt && jt.length && (Rt.buffer.push(jt), Rt.length += Rt.objectMode ? 1 : jt.length);
      }
      Rt.ended = !0, Rt.sync ? ot(It) : (Rt.needReadable = !1, Rt.emittedReadable || (Rt.emittedReadable = !0, ht(It)));
    }
  }
  function ot(It) {
    var Rt = It._readableState;
    ie("emitReadable", Rt.needReadable, Rt.emittedReadable), Rt.needReadable = !1, Rt.emittedReadable || (ie("emitReadable", Rt.flowing), Rt.emittedReadable = !0, process$1.nextTick(ht, It));
  }
  function ht(It) {
    var Rt = It._readableState;
    ie("emitReadable_", Rt.destroyed, Rt.length, Rt.ended), !Rt.destroyed && (Rt.length || Rt.ended) && (It.emit("readable"), Rt.emittedReadable = !1), Rt.needReadable = !Rt.flowing && !Rt.ended && Rt.length <= Rt.highWaterMark, qt(It);
  }
  function pt(It, Rt) {
    Rt.readingMore || (Rt.readingMore = !0, process$1.nextTick(ft, It, Rt));
  }
  function ft(It, Rt) {
    for (; !Rt.reading && !Rt.ended && (Rt.length < Rt.highWaterMark || Rt.flowing && Rt.length === 0); ) {
      var jt = Rt.length;
      if (ie("maybeReadMore read 0"), It.read(0), jt === Rt.length)
        break;
    }
    Rt.readingMore = !1;
  }
  yt.prototype._read = function(It) {
    $t(this, new ut("_read()"));
  }, yt.prototype.pipe = function(It, Rt) {
    var jt = this, Jt = this._readableState;
    switch (Jt.pipesCount) {
      case 0:
        Jt.pipes = It;
        break;
      case 1:
        Jt.pipes = [Jt.pipes, It];
        break;
      default:
        Jt.pipes.push(It);
        break;
    }
    Jt.pipesCount += 1, ie("pipe count=%d opts=%j", Jt.pipesCount, Rt);
    var er = (!Rt || Rt.end !== !1) && It !== process$1.stdout && It !== process$1.stderr, nr = er ? lr : Ir;
    Jt.endEmitted ? process$1.nextTick(nr) : jt.once("end", nr), It.on("unpipe", fr);
    function fr(gr, Rr) {
      ie("onunpipe"), gr === jt && Rr && Rr.hasUnpiped === !1 && (Rr.hasUnpiped = !0, or());
    }
    function lr() {
      ie("onend"), It.end();
    }
    var Yt = mt(jt);
    It.on("drain", Yt);
    var Pr = !1;
    function or() {
      ie("cleanup"), It.removeListener("close", cr), It.removeListener("finish", xr), It.removeListener("drain", Yt), It.removeListener("error", Br), It.removeListener("unpipe", fr), jt.removeListener("end", lr), jt.removeListener("end", Ir), jt.removeListener("data", Ar), Pr = !0, Jt.awaitDrain && (!It._writableState || It._writableState.needDrain) && Yt();
    }
    jt.on("data", Ar);
    function Ar(gr) {
      ie("ondata");
      var Rr = It.write(gr);
      ie("dest.write", Rr), Rr === !1 && ((Jt.pipesCount === 1 && Jt.pipes === It || Jt.pipesCount > 1 && Wt(Jt.pipes, It) !== -1) && !Pr && (ie("false write response, pause", Jt.awaitDrain), Jt.awaitDrain++), jt.pause());
    }
    function Br(gr) {
      ie("onerror", gr), Ir(), It.removeListener("error", Br), B(It, "error") === 0 && $t(It, gr);
    }
    Ot(It, "error", Br);
    function cr() {
      It.removeListener("finish", xr), Ir();
    }
    It.once("close", cr);
    function xr() {
      ie("onfinish"), It.removeListener("close", cr), Ir();
    }
    It.once("finish", xr);
    function Ir() {
      ie("unpipe"), jt.unpipe(It);
    }
    return It.emit("pipe", jt), Jt.flowing || (ie("pipe resume"), jt.resume()), It;
  };
  function mt(It) {
    return function() {
      var jt = It._readableState;
      ie("pipeOnDrain", jt.awaitDrain), jt.awaitDrain && jt.awaitDrain--, jt.awaitDrain === 0 && B(It, "data") && (jt.flowing = !0, qt(It));
    };
  }
  yt.prototype.unpipe = function(It) {
    var Rt = this._readableState, jt = {
      hasUnpiped: !1
    };
    if (Rt.pipesCount === 0) return this;
    if (Rt.pipesCount === 1)
      return It && It !== Rt.pipes ? this : (It || (It = Rt.pipes), Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1, It && It.emit("unpipe", this, jt), this);
    if (!It) {
      var Jt = Rt.pipes, er = Rt.pipesCount;
      Rt.pipes = null, Rt.pipesCount = 0, Rt.flowing = !1;
      for (var nr = 0; nr < er; nr++) Jt[nr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var fr = Wt(Rt.pipes, It);
    return fr === -1 ? this : (Rt.pipes.splice(fr, 1), Rt.pipesCount -= 1, Rt.pipesCount === 1 && (Rt.pipes = Rt.pipes[0]), It.emit("unpipe", this, jt), this);
  }, yt.prototype.on = function(It, Rt) {
    var jt = L.prototype.on.call(this, It, Rt), Jt = this._readableState;
    return It === "data" ? (Jt.readableListening = this.listenerCount("readable") > 0, Jt.flowing !== !1 && this.resume()) : It === "readable" && !Jt.endEmitted && !Jt.readableListening && (Jt.readableListening = Jt.needReadable = !0, Jt.flowing = !1, Jt.emittedReadable = !1, ie("on readable", Jt.length, Jt.reading), Jt.length ? ot(this) : Jt.reading || process$1.nextTick(St, this)), jt;
  }, yt.prototype.addListener = yt.prototype.on, yt.prototype.removeListener = function(It, Rt) {
    var jt = L.prototype.removeListener.call(this, It, Rt);
    return It === "readable" && process$1.nextTick(lt, this), jt;
  }, yt.prototype.removeAllListeners = function(It) {
    var Rt = L.prototype.removeAllListeners.apply(this, arguments);
    return (It === "readable" || It === void 0) && process$1.nextTick(lt, this), Rt;
  };
  function lt(It) {
    var Rt = It._readableState;
    Rt.readableListening = It.listenerCount("readable") > 0, Rt.resumeScheduled && !Rt.paused ? Rt.flowing = !0 : It.listenerCount("data") > 0 && It.resume();
  }
  function St(It) {
    ie("readable nexttick read 0"), It.read(0);
  }
  yt.prototype.resume = function() {
    var It = this._readableState;
    return It.flowing || (ie("resume"), It.flowing = !It.readableListening, Ft(this, It)), It.paused = !1, this;
  };
  function Ft(It, Rt) {
    Rt.resumeScheduled || (Rt.resumeScheduled = !0, process$1.nextTick(Gt, It, Rt));
  }
  function Gt(It, Rt) {
    ie("resume", Rt.reading), Rt.reading || It.read(0), Rt.resumeScheduled = !1, It.emit("resume"), qt(It), Rt.flowing && !Rt.reading && It.read(0);
  }
  yt.prototype.pause = function() {
    return ie("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ie("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function qt(It) {
    var Rt = It._readableState;
    for (ie("flow", Rt.flowing); Rt.flowing && It.read() !== null; ) ;
  }
  yt.prototype.wrap = function(It) {
    var Rt = this, jt = this._readableState, Jt = !1;
    It.on("end", function() {
      if (ie("wrapped end"), jt.decoder && !jt.ended) {
        var fr = jt.decoder.end();
        fr && fr.length && Rt.push(fr);
      }
      Rt.push(null);
    }), It.on("data", function(fr) {
      if (ie("wrapped data"), jt.decoder && (fr = jt.decoder.write(fr)), !(jt.objectMode && fr == null) && !(!jt.objectMode && (!fr || !fr.length))) {
        var lr = Rt.push(fr);
        lr || (Jt = !0, It.pause());
      }
    });
    for (var er in It)
      this[er] === void 0 && typeof It[er] == "function" && (this[er] = /* @__PURE__ */ function(lr) {
        return function() {
          return It[lr].apply(It, arguments);
        };
      }(er));
    for (var nr = 0; nr < xt.length; nr++)
      It.on(xt[nr], this.emit.bind(this, xt[nr]));
    return this._read = function(fr) {
      ie("wrapped _read", fr), Jt && (Jt = !1, It.resume());
    }, this;
  }, typeof Symbol == "function" && (yt.prototype[Symbol.asyncIterator] = function() {
    return bt === void 0 && (bt = requireAsync_iterator()), bt(this);
  }), Object.defineProperty(yt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(yt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(yt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Rt) {
      this._readableState && (this._readableState.flowing = Rt);
    }
  }), yt._fromList = Pt, Object.defineProperty(yt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Pt(It, Rt) {
    if (Rt.length === 0) return null;
    var jt;
    return Rt.objectMode ? jt = Rt.buffer.shift() : !It || It >= Rt.length ? (Rt.decoder ? jt = Rt.buffer.join("") : Rt.buffer.length === 1 ? jt = Rt.buffer.first() : jt = Rt.buffer.concat(Rt.length), Rt.buffer.clear()) : jt = Rt.buffer.consume(It, Rt.decoder), jt;
  }
  function Tt(It) {
    var Rt = It._readableState;
    ie("endReadable", Rt.endEmitted), Rt.endEmitted || (Rt.ended = !0, process$1.nextTick(Ut, Rt, It));
  }
  function Ut(It, Rt) {
    if (ie("endReadableNT", It.endEmitted, It.length), !It.endEmitted && It.length === 0 && (It.endEmitted = !0, Rt.readable = !1, Rt.emit("end"), It.autoDestroy)) {
      var jt = Rt._writableState;
      (!jt || jt.autoDestroy && jt.finished) && Rt.destroy();
    }
  }
  typeof Symbol == "function" && (yt.from = function(It, Rt) {
    return vt === void 0 && (vt = requireFromBrowser()), vt(yt, It, Rt);
  });
  function Wt(It, Rt) {
    for (var jt = 0, Jt = It.length; jt < Jt; jt++)
      if (It[jt] === Rt) return jt;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = ne;
  var A = requireErrorsBrowser().codes, B = A.ERR_METHOD_NOT_IMPLEMENTED, L = A.ERR_MULTIPLE_CALLBACK, K = A.ERR_TRANSFORM_ALREADY_TRANSFORMING, V = A.ERR_TRANSFORM_WITH_LENGTH_0, W = require_stream_duplex$1();
  requireInherits_browser()(ne, W);
  function J(re, oe) {
    var ke = this._transformState;
    ke.transforming = !1;
    var Oe = ke.writecb;
    if (Oe === null)
      return this.emit("error", new L());
    ke.writechunk = null, ke.writecb = null, oe != null && this.push(oe), Oe(re);
    var it = this._readableState;
    it.reading = !1, (it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
  }
  function ne(re) {
    if (!(this instanceof ne)) return new ne(re);
    W.call(this, re), this._transformState = {
      afterTransform: J.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, re && (typeof re.transform == "function" && (this._transform = re.transform), typeof re.flush == "function" && (this._flush = re.flush)), this.on("prefinish", ie);
  }
  function ie() {
    var re = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(oe, ke) {
      ce(re, oe, ke);
    }) : ce(this, null, null);
  }
  ne.prototype.push = function(re, oe) {
    return this._transformState.needTransform = !1, W.prototype.push.call(this, re, oe);
  }, ne.prototype._transform = function(re, oe, ke) {
    ke(new B("_transform()"));
  }, ne.prototype._write = function(re, oe, ke) {
    var Oe = this._transformState;
    if (Oe.writecb = ke, Oe.writechunk = re, Oe.writeencoding = oe, !Oe.transforming) {
      var it = this._readableState;
      (Oe.needTransform || it.needReadable || it.length < it.highWaterMark) && this._read(it.highWaterMark);
    }
  }, ne.prototype._read = function(re) {
    var oe = this._transformState;
    oe.writechunk !== null && !oe.transforming ? (oe.transforming = !0, this._transform(oe.writechunk, oe.writeencoding, oe.afterTransform)) : oe.needTransform = !0;
  }, ne.prototype._destroy = function(re, oe) {
    W.prototype._destroy.call(this, re, function(ke) {
      oe(ke);
    });
  };
  function ce(re, oe, ke) {
    if (oe) return re.emit("error", oe);
    if (ke != null && re.push(ke), re._writableState.length) throw new V();
    if (re._transformState.transforming) throw new K();
    return re.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = B;
  var A = require_stream_transform$1();
  requireInherits_browser()(B, A);
  function B(L) {
    if (!(this instanceof B)) return new B(L);
    A.call(this, L);
  }
  return B.prototype._transform = function(L, K, V) {
    V(null, L);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var A;
  function B(ke) {
    var Oe = !1;
    return function() {
      Oe || (Oe = !0, ke.apply(void 0, arguments));
    };
  }
  var L = requireErrorsBrowser().codes, K = L.ERR_MISSING_ARGS, V = L.ERR_STREAM_DESTROYED;
  function W(ke) {
    if (ke) throw ke;
  }
  function J(ke) {
    return ke.setHeader && typeof ke.abort == "function";
  }
  function ne(ke, Oe, it, at) {
    at = B(at);
    var ut = !1;
    ke.on("close", function() {
      ut = !0;
    }), A === void 0 && (A = requireEndOfStream()), A(ke, {
      readable: Oe,
      writable: it
    }, function(ct) {
      if (ct) return at(ct);
      ut = !0, at();
    });
    var dt = !1;
    return function(ct) {
      if (!ut && !dt) {
        if (dt = !0, J(ke)) return ke.abort();
        if (typeof ke.destroy == "function") return ke.destroy();
        at(ct || new V("pipe"));
      }
    };
  }
  function ie(ke) {
    ke();
  }
  function ce(ke, Oe) {
    return ke.pipe(Oe);
  }
  function re(ke) {
    return !ke.length || typeof ke[ke.length - 1] != "function" ? W : ke.pop();
  }
  function oe() {
    for (var ke = arguments.length, Oe = new Array(ke), it = 0; it < ke; it++)
      Oe[it] = arguments[it];
    var at = re(Oe);
    if (Array.isArray(Oe[0]) && (Oe = Oe[0]), Oe.length < 2)
      throw new K("streams");
    var ut, dt = Oe.map(function(ct, bt) {
      var vt = bt < Oe.length - 1, $t = bt > 0;
      return ne(ct, vt, $t, function(xt) {
        ut || (ut = xt), xt && dt.forEach(ie), !vt && (dt.forEach(ie), at(ut));
      });
    });
    return Oe.reduce(ce);
  }
  return pipeline_1 = oe, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(A, B) {
    B = A.exports = require_stream_readable$1(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable$1(), B.Duplex = require_stream_duplex$1(), B.Transform = require_stream_transform$1(), B.PassThrough = require_stream_passthrough$1(), B.finished = requireEndOfStream(), B.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var A = safeBufferExports.Buffer, B = requireReadableBrowser$1().Transform, L = requireInherits_browser();
  function K(W, J) {
    if (!A.isBuffer(W) && typeof W != "string")
      throw new TypeError(J + " must be a string or a buffer");
  }
  function V(W) {
    B.call(this), this._block = A.allocUnsafe(W), this._blockSize = W, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return L(V, B), V.prototype._transform = function(W, J, ne) {
    var ie = null;
    try {
      this.update(W, J);
    } catch (ce) {
      ie = ce;
    }
    ne(ie);
  }, V.prototype._flush = function(W) {
    var J = null;
    try {
      this.push(this.digest());
    } catch (ne) {
      J = ne;
    }
    W(J);
  }, V.prototype.update = function(W, J) {
    if (K(W, "Data"), this._finalized) throw new Error("Digest already called");
    A.isBuffer(W) || (W = A.from(W, J));
    for (var ne = this._block, ie = 0; this._blockOffset + W.length - ie >= this._blockSize; ) {
      for (var ce = this._blockOffset; ce < this._blockSize; ) ne[ce++] = W[ie++];
      this._update(), this._blockOffset = 0;
    }
    for (; ie < W.length; ) ne[this._blockOffset++] = W[ie++];
    for (var re = 0, oe = W.length * 8; oe > 0; ++re)
      this._length[re] += oe, oe = this._length[re] / 4294967296 | 0, oe > 0 && (this._length[re] -= 4294967296 * oe);
    return this;
  }, V.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, V.prototype.digest = function(W) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var J = this._digest();
    W !== void 0 && (J = J.toString(W)), this._block.fill(0), this._blockOffset = 0;
    for (var ne = 0; ne < 4; ++ne) this._length[ne] = 0;
    return J;
  }, V.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = V, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var A = requireInherits_browser(), B = requireHashBase(), L = safeBufferExports.Buffer, K = new Array(16);
  function V() {
    B.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  A(V, B), V.prototype._update = function() {
    for (var re = K, oe = 0; oe < 16; ++oe) re[oe] = this._block.readInt32LE(oe * 4);
    var ke = this._a, Oe = this._b, it = this._c, at = this._d;
    ke = J(ke, Oe, it, at, re[0], 3614090360, 7), at = J(at, ke, Oe, it, re[1], 3905402710, 12), it = J(it, at, ke, Oe, re[2], 606105819, 17), Oe = J(Oe, it, at, ke, re[3], 3250441966, 22), ke = J(ke, Oe, it, at, re[4], 4118548399, 7), at = J(at, ke, Oe, it, re[5], 1200080426, 12), it = J(it, at, ke, Oe, re[6], 2821735955, 17), Oe = J(Oe, it, at, ke, re[7], 4249261313, 22), ke = J(ke, Oe, it, at, re[8], 1770035416, 7), at = J(at, ke, Oe, it, re[9], 2336552879, 12), it = J(it, at, ke, Oe, re[10], 4294925233, 17), Oe = J(Oe, it, at, ke, re[11], 2304563134, 22), ke = J(ke, Oe, it, at, re[12], 1804603682, 7), at = J(at, ke, Oe, it, re[13], 4254626195, 12), it = J(it, at, ke, Oe, re[14], 2792965006, 17), Oe = J(Oe, it, at, ke, re[15], 1236535329, 22), ke = ne(ke, Oe, it, at, re[1], 4129170786, 5), at = ne(at, ke, Oe, it, re[6], 3225465664, 9), it = ne(it, at, ke, Oe, re[11], 643717713, 14), Oe = ne(Oe, it, at, ke, re[0], 3921069994, 20), ke = ne(ke, Oe, it, at, re[5], 3593408605, 5), at = ne(at, ke, Oe, it, re[10], 38016083, 9), it = ne(it, at, ke, Oe, re[15], 3634488961, 14), Oe = ne(Oe, it, at, ke, re[4], 3889429448, 20), ke = ne(ke, Oe, it, at, re[9], 568446438, 5), at = ne(at, ke, Oe, it, re[14], 3275163606, 9), it = ne(it, at, ke, Oe, re[3], 4107603335, 14), Oe = ne(Oe, it, at, ke, re[8], 1163531501, 20), ke = ne(ke, Oe, it, at, re[13], 2850285829, 5), at = ne(at, ke, Oe, it, re[2], 4243563512, 9), it = ne(it, at, ke, Oe, re[7], 1735328473, 14), Oe = ne(Oe, it, at, ke, re[12], 2368359562, 20), ke = ie(ke, Oe, it, at, re[5], 4294588738, 4), at = ie(at, ke, Oe, it, re[8], 2272392833, 11), it = ie(it, at, ke, Oe, re[11], 1839030562, 16), Oe = ie(Oe, it, at, ke, re[14], 4259657740, 23), ke = ie(ke, Oe, it, at, re[1], 2763975236, 4), at = ie(at, ke, Oe, it, re[4], 1272893353, 11), it = ie(it, at, ke, Oe, re[7], 4139469664, 16), Oe = ie(Oe, it, at, ke, re[10], 3200236656, 23), ke = ie(ke, Oe, it, at, re[13], 681279174, 4), at = ie(at, ke, Oe, it, re[0], 3936430074, 11), it = ie(it, at, ke, Oe, re[3], 3572445317, 16), Oe = ie(Oe, it, at, ke, re[6], 76029189, 23), ke = ie(ke, Oe, it, at, re[9], 3654602809, 4), at = ie(at, ke, Oe, it, re[12], 3873151461, 11), it = ie(it, at, ke, Oe, re[15], 530742520, 16), Oe = ie(Oe, it, at, ke, re[2], 3299628645, 23), ke = ce(ke, Oe, it, at, re[0], 4096336452, 6), at = ce(at, ke, Oe, it, re[7], 1126891415, 10), it = ce(it, at, ke, Oe, re[14], 2878612391, 15), Oe = ce(Oe, it, at, ke, re[5], 4237533241, 21), ke = ce(ke, Oe, it, at, re[12], 1700485571, 6), at = ce(at, ke, Oe, it, re[3], 2399980690, 10), it = ce(it, at, ke, Oe, re[10], 4293915773, 15), Oe = ce(Oe, it, at, ke, re[1], 2240044497, 21), ke = ce(ke, Oe, it, at, re[8], 1873313359, 6), at = ce(at, ke, Oe, it, re[15], 4264355552, 10), it = ce(it, at, ke, Oe, re[6], 2734768916, 15), Oe = ce(Oe, it, at, ke, re[13], 1309151649, 21), ke = ce(ke, Oe, it, at, re[4], 4149444226, 6), at = ce(at, ke, Oe, it, re[11], 3174756917, 10), it = ce(it, at, ke, Oe, re[2], 718787259, 15), Oe = ce(Oe, it, at, ke, re[9], 3951481745, 21), this._a = this._a + ke | 0, this._b = this._b + Oe | 0, this._c = this._c + it | 0, this._d = this._d + at | 0;
  }, V.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var re = L.allocUnsafe(16);
    return re.writeInt32LE(this._a, 0), re.writeInt32LE(this._b, 4), re.writeInt32LE(this._c, 8), re.writeInt32LE(this._d, 12), re;
  };
  function W(re, oe) {
    return re << oe | re >>> 32 - oe;
  }
  function J(re, oe, ke, Oe, it, at, ut) {
    return W(re + (oe & ke | ~oe & Oe) + it + at | 0, ut) + oe | 0;
  }
  function ne(re, oe, ke, Oe, it, at, ut) {
    return W(re + (oe & Oe | ke & ~Oe) + it + at | 0, ut) + oe | 0;
  }
  function ie(re, oe, ke, Oe, it, at, ut) {
    return W(re + (oe ^ ke ^ Oe) + it + at | 0, ut) + oe | 0;
  }
  function ce(re, oe, ke, Oe, it, at, ut) {
    return W(re + (ke ^ (oe | ~Oe)) + it + at | 0, ut) + oe | 0;
  }
  return md5_js = V, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var A = require$$0$1.Buffer, B = requireInherits_browser(), L = requireHashBase(), K = new Array(16), V = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], W = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], J = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ne = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ie = [0, 1518500249, 1859775393, 2400959708, 2840853838], ce = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function re() {
    L.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  B(re, L), re.prototype._update = function() {
    for (var dt = K, ct = 0; ct < 16; ++ct) dt[ct] = this._block.readInt32LE(ct * 4);
    for (var bt = this._a | 0, vt = this._b | 0, $t = this._c | 0, xt = this._d | 0, Ot = this._e | 0, At = this._a | 0, yt = this._b | 0, Bt = this._c | 0, gt = this._d | 0, rt = this._e | 0, Ce = 0; Ce < 80; Ce += 1) {
      var pe, nt;
      Ce < 16 ? (pe = ke(bt, vt, $t, xt, Ot, dt[V[Ce]], ie[0], J[Ce]), nt = ut(At, yt, Bt, gt, rt, dt[W[Ce]], ce[0], ne[Ce])) : Ce < 32 ? (pe = Oe(bt, vt, $t, xt, Ot, dt[V[Ce]], ie[1], J[Ce]), nt = at(At, yt, Bt, gt, rt, dt[W[Ce]], ce[1], ne[Ce])) : Ce < 48 ? (pe = it(bt, vt, $t, xt, Ot, dt[V[Ce]], ie[2], J[Ce]), nt = it(At, yt, Bt, gt, rt, dt[W[Ce]], ce[2], ne[Ce])) : Ce < 64 ? (pe = at(bt, vt, $t, xt, Ot, dt[V[Ce]], ie[3], J[Ce]), nt = Oe(At, yt, Bt, gt, rt, dt[W[Ce]], ce[3], ne[Ce])) : (pe = ut(bt, vt, $t, xt, Ot, dt[V[Ce]], ie[4], J[Ce]), nt = ke(At, yt, Bt, gt, rt, dt[W[Ce]], ce[4], ne[Ce])), bt = Ot, Ot = xt, xt = oe($t, 10), $t = vt, vt = pe, At = rt, rt = gt, gt = oe(Bt, 10), Bt = yt, yt = nt;
    }
    var st = this._b + $t + gt | 0;
    this._b = this._c + xt + rt | 0, this._c = this._d + Ot + At | 0, this._d = this._e + bt + yt | 0, this._e = this._a + vt + Bt | 0, this._a = st;
  }, re.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var dt = A.alloc ? A.alloc(20) : new A(20);
    return dt.writeInt32LE(this._a, 0), dt.writeInt32LE(this._b, 4), dt.writeInt32LE(this._c, 8), dt.writeInt32LE(this._d, 12), dt.writeInt32LE(this._e, 16), dt;
  };
  function oe(dt, ct) {
    return dt << ct | dt >>> 32 - ct;
  }
  function ke(dt, ct, bt, vt, $t, xt, Ot, At) {
    return oe(dt + (ct ^ bt ^ vt) + xt + Ot | 0, At) + $t | 0;
  }
  function Oe(dt, ct, bt, vt, $t, xt, Ot, At) {
    return oe(dt + (ct & bt | ~ct & vt) + xt + Ot | 0, At) + $t | 0;
  }
  function it(dt, ct, bt, vt, $t, xt, Ot, At) {
    return oe(dt + ((ct | ~bt) ^ vt) + xt + Ot | 0, At) + $t | 0;
  }
  function at(dt, ct, bt, vt, $t, xt, Ot, At) {
    return oe(dt + (ct & vt | bt & ~vt) + xt + Ot | 0, At) + $t | 0;
  }
  function ut(dt, ct, bt, vt, $t, xt, Ot, At) {
    return oe(dt + (ct ^ (bt | ~vt)) + xt + Ot | 0, At) + $t | 0;
  }
  return ripemd160$1 = re, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K) {
    this._block = A.alloc(L), this._finalSize = K, this._blockSize = L, this._len = 0;
  }
  return B.prototype.update = function(L, K) {
    typeof L == "string" && (K = K || "utf8", L = A.from(L, K));
    for (var V = this._block, W = this._blockSize, J = L.length, ne = this._len, ie = 0; ie < J; ) {
      for (var ce = ne % W, re = Math.min(J - ie, W - ce), oe = 0; oe < re; oe++)
        V[ce + oe] = L[ie + oe];
      ne += re, ie += re, ne % W === 0 && this._update(V);
    }
    return this._len += J, this;
  }, B.prototype.digest = function(L) {
    var K = this._len % this._blockSize;
    this._block[K] = 128, this._block.fill(0, K + 1), K >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var V = this._len * 8;
    if (V <= 4294967295)
      this._block.writeUInt32BE(V, this._blockSize - 4);
    else {
      var W = (V & 4294967295) >>> 0, J = (V - W) / 4294967296;
      this._block.writeUInt32BE(J, this._blockSize - 8), this._block.writeUInt32BE(W, this._blockSize - 4);
    }
    this._update(this._block);
    var ne = this._hash();
    return L ? ne.toString(L) : ne;
  }, B.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = B, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], V = new Array(80);
  function W() {
    this.init(), this._w = V, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function J(ce) {
    return ce << 5 | ce >>> 27;
  }
  function ne(ce) {
    return ce << 30 | ce >>> 2;
  }
  function ie(ce, re, oe, ke) {
    return ce === 0 ? re & oe | ~re & ke : ce === 2 ? re & oe | re & ke | oe & ke : re ^ oe ^ ke;
  }
  return W.prototype._update = function(ce) {
    for (var re = this._w, oe = this._a | 0, ke = this._b | 0, Oe = this._c | 0, it = this._d | 0, at = this._e | 0, ut = 0; ut < 16; ++ut) re[ut] = ce.readInt32BE(ut * 4);
    for (; ut < 80; ++ut) re[ut] = re[ut - 3] ^ re[ut - 8] ^ re[ut - 14] ^ re[ut - 16];
    for (var dt = 0; dt < 80; ++dt) {
      var ct = ~~(dt / 20), bt = J(oe) + ie(ct, ke, Oe, it) + at + re[dt] + K[ct] | 0;
      at = it, it = Oe, Oe = ne(ke), ke = oe, oe = bt;
    }
    this._a = oe + this._a | 0, this._b = ke + this._b | 0, this._c = Oe + this._c | 0, this._d = it + this._d | 0, this._e = at + this._e | 0;
  }, W.prototype._hash = function() {
    var ce = L.allocUnsafe(20);
    return ce.writeInt32BE(this._a | 0, 0), ce.writeInt32BE(this._b | 0, 4), ce.writeInt32BE(this._c | 0, 8), ce.writeInt32BE(this._d | 0, 12), ce.writeInt32BE(this._e | 0, 16), ce;
  }, sha$1 = W, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], V = new Array(80);
  function W() {
    this.init(), this._w = V, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function J(re) {
    return re << 1 | re >>> 31;
  }
  function ne(re) {
    return re << 5 | re >>> 27;
  }
  function ie(re) {
    return re << 30 | re >>> 2;
  }
  function ce(re, oe, ke, Oe) {
    return re === 0 ? oe & ke | ~oe & Oe : re === 2 ? oe & ke | oe & Oe | ke & Oe : oe ^ ke ^ Oe;
  }
  return W.prototype._update = function(re) {
    for (var oe = this._w, ke = this._a | 0, Oe = this._b | 0, it = this._c | 0, at = this._d | 0, ut = this._e | 0, dt = 0; dt < 16; ++dt) oe[dt] = re.readInt32BE(dt * 4);
    for (; dt < 80; ++dt) oe[dt] = J(oe[dt - 3] ^ oe[dt - 8] ^ oe[dt - 14] ^ oe[dt - 16]);
    for (var ct = 0; ct < 80; ++ct) {
      var bt = ~~(ct / 20), vt = ne(ke) + ce(bt, Oe, it, at) + ut + oe[ct] + K[bt] | 0;
      ut = at, at = it, it = ie(Oe), Oe = ke, ke = vt;
    }
    this._a = ke + this._a | 0, this._b = Oe + this._b | 0, this._c = it + this._c | 0, this._d = at + this._d | 0, this._e = ut + this._e | 0;
  }, W.prototype._hash = function() {
    var re = L.allocUnsafe(20);
    return re.writeInt32BE(this._a | 0, 0), re.writeInt32BE(this._b | 0, 4), re.writeInt32BE(this._c | 0, 8), re.writeInt32BE(this._d | 0, 12), re.writeInt32BE(this._e | 0, 16), re;
  }, sha1$1 = W, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], V = new Array(64);
  function W() {
    this.init(), this._w = V, B.call(this, 64, 56);
  }
  A(W, B), W.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function J(ke, Oe, it) {
    return it ^ ke & (Oe ^ it);
  }
  function ne(ke, Oe, it) {
    return ke & Oe | it & (ke | Oe);
  }
  function ie(ke) {
    return (ke >>> 2 | ke << 30) ^ (ke >>> 13 | ke << 19) ^ (ke >>> 22 | ke << 10);
  }
  function ce(ke) {
    return (ke >>> 6 | ke << 26) ^ (ke >>> 11 | ke << 21) ^ (ke >>> 25 | ke << 7);
  }
  function re(ke) {
    return (ke >>> 7 | ke << 25) ^ (ke >>> 18 | ke << 14) ^ ke >>> 3;
  }
  function oe(ke) {
    return (ke >>> 17 | ke << 15) ^ (ke >>> 19 | ke << 13) ^ ke >>> 10;
  }
  return W.prototype._update = function(ke) {
    for (var Oe = this._w, it = this._a | 0, at = this._b | 0, ut = this._c | 0, dt = this._d | 0, ct = this._e | 0, bt = this._f | 0, vt = this._g | 0, $t = this._h | 0, xt = 0; xt < 16; ++xt) Oe[xt] = ke.readInt32BE(xt * 4);
    for (; xt < 64; ++xt) Oe[xt] = oe(Oe[xt - 2]) + Oe[xt - 7] + re(Oe[xt - 15]) + Oe[xt - 16] | 0;
    for (var Ot = 0; Ot < 64; ++Ot) {
      var At = $t + ce(ct) + J(ct, bt, vt) + K[Ot] + Oe[Ot] | 0, yt = ie(it) + ne(it, at, ut) | 0;
      $t = vt, vt = bt, bt = ct, ct = dt + At | 0, dt = ut, ut = at, at = it, it = At + yt | 0;
    }
    this._a = it + this._a | 0, this._b = at + this._b | 0, this._c = ut + this._c | 0, this._d = dt + this._d | 0, this._e = ct + this._e | 0, this._f = bt + this._f | 0, this._g = vt + this._g | 0, this._h = $t + this._h | 0;
  }, W.prototype._hash = function() {
    var ke = L.allocUnsafe(32);
    return ke.writeInt32BE(this._a, 0), ke.writeInt32BE(this._b, 4), ke.writeInt32BE(this._c, 8), ke.writeInt32BE(this._d, 12), ke.writeInt32BE(this._e, 16), ke.writeInt32BE(this._f, 20), ke.writeInt32BE(this._g, 24), ke.writeInt32BE(this._h, 28), ke;
  }, sha256$3 = W, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var A = requireInherits_browser(), B = requireSha256(), L = requireHash$1(), K = safeBufferExports.Buffer, V = new Array(64);
  function W() {
    this.init(), this._w = V, L.call(this, 64, 56);
  }
  return A(W, B), W.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, W.prototype._hash = function() {
    var J = K.allocUnsafe(28);
    return J.writeInt32BE(this._a, 0), J.writeInt32BE(this._b, 4), J.writeInt32BE(this._c, 8), J.writeInt32BE(this._d, 12), J.writeInt32BE(this._e, 16), J.writeInt32BE(this._f, 20), J.writeInt32BE(this._g, 24), J;
  }, sha224$1 = W, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var A = requireInherits_browser(), B = requireHash$1(), L = safeBufferExports.Buffer, K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], V = new Array(160);
  function W() {
    this.init(), this._w = V, B.call(this, 128, 112);
  }
  A(W, B), W.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function J(at, ut, dt) {
    return dt ^ at & (ut ^ dt);
  }
  function ne(at, ut, dt) {
    return at & ut | dt & (at | ut);
  }
  function ie(at, ut) {
    return (at >>> 28 | ut << 4) ^ (ut >>> 2 | at << 30) ^ (ut >>> 7 | at << 25);
  }
  function ce(at, ut) {
    return (at >>> 14 | ut << 18) ^ (at >>> 18 | ut << 14) ^ (ut >>> 9 | at << 23);
  }
  function re(at, ut) {
    return (at >>> 1 | ut << 31) ^ (at >>> 8 | ut << 24) ^ at >>> 7;
  }
  function oe(at, ut) {
    return (at >>> 1 | ut << 31) ^ (at >>> 8 | ut << 24) ^ (at >>> 7 | ut << 25);
  }
  function ke(at, ut) {
    return (at >>> 19 | ut << 13) ^ (ut >>> 29 | at << 3) ^ at >>> 6;
  }
  function Oe(at, ut) {
    return (at >>> 19 | ut << 13) ^ (ut >>> 29 | at << 3) ^ (at >>> 6 | ut << 26);
  }
  function it(at, ut) {
    return at >>> 0 < ut >>> 0 ? 1 : 0;
  }
  return W.prototype._update = function(at) {
    for (var ut = this._w, dt = this._ah | 0, ct = this._bh | 0, bt = this._ch | 0, vt = this._dh | 0, $t = this._eh | 0, xt = this._fh | 0, Ot = this._gh | 0, At = this._hh | 0, yt = this._al | 0, Bt = this._bl | 0, gt = this._cl | 0, rt = this._dl | 0, Ce = this._el | 0, pe = this._fl | 0, nt = this._gl | 0, st = this._hl | 0, ot = 0; ot < 32; ot += 2)
      ut[ot] = at.readInt32BE(ot * 4), ut[ot + 1] = at.readInt32BE(ot * 4 + 4);
    for (; ot < 160; ot += 2) {
      var ht = ut[ot - 30], pt = ut[ot - 15 * 2 + 1], ft = re(ht, pt), mt = oe(pt, ht);
      ht = ut[ot - 2 * 2], pt = ut[ot - 2 * 2 + 1];
      var lt = ke(ht, pt), St = Oe(pt, ht), Ft = ut[ot - 7 * 2], Gt = ut[ot - 7 * 2 + 1], qt = ut[ot - 16 * 2], Pt = ut[ot - 16 * 2 + 1], Tt = mt + Gt | 0, Ut = ft + Ft + it(Tt, mt) | 0;
      Tt = Tt + St | 0, Ut = Ut + lt + it(Tt, St) | 0, Tt = Tt + Pt | 0, Ut = Ut + qt + it(Tt, Pt) | 0, ut[ot] = Ut, ut[ot + 1] = Tt;
    }
    for (var Wt = 0; Wt < 160; Wt += 2) {
      Ut = ut[Wt], Tt = ut[Wt + 1];
      var It = ne(dt, ct, bt), Rt = ne(yt, Bt, gt), jt = ie(dt, yt), Jt = ie(yt, dt), er = ce($t, Ce), nr = ce(Ce, $t), fr = K[Wt], lr = K[Wt + 1], Yt = J($t, xt, Ot), Pr = J(Ce, pe, nt), or = st + nr | 0, Ar = At + er + it(or, st) | 0;
      or = or + Pr | 0, Ar = Ar + Yt + it(or, Pr) | 0, or = or + lr | 0, Ar = Ar + fr + it(or, lr) | 0, or = or + Tt | 0, Ar = Ar + Ut + it(or, Tt) | 0;
      var Br = Jt + Rt | 0, cr = jt + It + it(Br, Jt) | 0;
      At = Ot, st = nt, Ot = xt, nt = pe, xt = $t, pe = Ce, Ce = rt + or | 0, $t = vt + Ar + it(Ce, rt) | 0, vt = bt, rt = gt, bt = ct, gt = Bt, ct = dt, Bt = yt, yt = or + Br | 0, dt = Ar + cr + it(yt, or) | 0;
    }
    this._al = this._al + yt | 0, this._bl = this._bl + Bt | 0, this._cl = this._cl + gt | 0, this._dl = this._dl + rt | 0, this._el = this._el + Ce | 0, this._fl = this._fl + pe | 0, this._gl = this._gl + nt | 0, this._hl = this._hl + st | 0, this._ah = this._ah + dt + it(this._al, yt) | 0, this._bh = this._bh + ct + it(this._bl, Bt) | 0, this._ch = this._ch + bt + it(this._cl, gt) | 0, this._dh = this._dh + vt + it(this._dl, rt) | 0, this._eh = this._eh + $t + it(this._el, Ce) | 0, this._fh = this._fh + xt + it(this._fl, pe) | 0, this._gh = this._gh + Ot + it(this._gl, nt) | 0, this._hh = this._hh + At + it(this._hl, st) | 0;
  }, W.prototype._hash = function() {
    var at = L.allocUnsafe(64);
    function ut(dt, ct, bt) {
      at.writeInt32BE(dt, bt), at.writeInt32BE(ct, bt + 4);
    }
    return ut(this._ah, this._al, 0), ut(this._bh, this._bl, 8), ut(this._ch, this._cl, 16), ut(this._dh, this._dl, 24), ut(this._eh, this._el, 32), ut(this._fh, this._fl, 40), ut(this._gh, this._gl, 48), ut(this._hh, this._hl, 56), at;
  }, sha512$1 = W, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var A = requireInherits_browser(), B = requireSha512(), L = requireHash$1(), K = safeBufferExports.Buffer, V = new Array(160);
  function W() {
    this.init(), this._w = V, L.call(this, 128, 112);
  }
  return A(W, B), W.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, W.prototype._hash = function() {
    var J = K.allocUnsafe(48);
    function ne(ie, ce, re) {
      J.writeInt32BE(ie, re), J.writeInt32BE(ce, re + 4);
    }
    return ne(this._ah, this._al, 0), ne(this._bh, this._bl, 8), ne(this._ch, this._cl, 16), ne(this._dh, this._dl, 24), ne(this._eh, this._el, 32), ne(this._fh, this._fl, 40), J;
  }, sha384$1 = W, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var A = sha_js.exports = function(L) {
    L = L.toLowerCase();
    var K = A[L];
    if (!K) throw new Error(L + " is not supported (we accept pull requests)");
    return new K();
  };
  return A.sha = requireSha$1(), A.sha1 = requireSha1(), A.sha224 = requireSha224(), A.sha256 = requireSha256(), A.sha384 = requireSha384(), A.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = L;
  var A = requireEvents().EventEmitter, B = requireInherits_browser();
  B(L, A), L.Readable = require_stream_readable$1(), L.Writable = require_stream_writable$1(), L.Duplex = require_stream_duplex$1(), L.Transform = require_stream_transform$1(), L.PassThrough = require_stream_passthrough$1(), L.finished = requireEndOfStream(), L.pipeline = requirePipeline(), L.Stream = L;
  function L() {
    A.call(this);
  }
  return L.prototype.pipe = function(K, V) {
    var W = this;
    function J(Oe) {
      K.writable && K.write(Oe) === !1 && W.pause && W.pause();
    }
    W.on("data", J);
    function ne() {
      W.readable && W.resume && W.resume();
    }
    K.on("drain", ne), !K._isStdio && (!V || V.end !== !1) && (W.on("end", ce), W.on("close", re));
    var ie = !1;
    function ce() {
      ie || (ie = !0, K.end());
    }
    function re() {
      ie || (ie = !0, typeof K.destroy == "function" && K.destroy());
    }
    function oe(Oe) {
      if (ke(), A.listenerCount(this, "error") === 0)
        throw Oe;
    }
    W.on("error", oe), K.on("error", oe);
    function ke() {
      W.removeListener("data", J), K.removeListener("drain", ne), W.removeListener("end", ce), W.removeListener("close", re), W.removeListener("error", oe), K.removeListener("error", oe), W.removeListener("end", ke), W.removeListener("close", ke), K.removeListener("close", ke);
    }
    return W.on("end", ke), W.on("close", ke), K.on("close", ke), K.emit("pipe", W), K;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var A = safeBufferExports.Buffer, B = requireStreamBrowserify().Transform, L = requireString_decoder().StringDecoder, K = requireInherits_browser();
  function V(ie) {
    B.call(this), this.hashMode = typeof ie == "string", this.hashMode ? this[ie] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  K(V, B);
  var W = typeof Uint8Array < "u", J = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (A.prototype instanceof Uint8Array || A.TYPED_ARRAY_SUPPORT);
  function ne(ie, ce) {
    if (ie instanceof A)
      return ie;
    if (typeof ie == "string")
      return A.from(ie, ce);
    if (J && ArrayBuffer.isView(ie)) {
      if (ie.byteLength === 0)
        return A.alloc(0);
      var re = A.from(ie.buffer, ie.byteOffset, ie.byteLength);
      if (re.byteLength === ie.byteLength)
        return re;
    }
    if (W && ie instanceof Uint8Array || A.isBuffer(ie) && ie.constructor && typeof ie.constructor.isBuffer == "function" && ie.constructor.isBuffer(ie))
      return A.from(ie);
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  return V.prototype.update = function(ie, ce, re) {
    var oe = ne(ie, ce), ke = this._update(oe);
    return this.hashMode ? this : (re && (ke = this._toString(ke, re)), ke);
  }, V.prototype.setAutoPadding = function() {
  }, V.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, V.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, V.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, V.prototype._transform = function(ie, ce, re) {
    var oe;
    try {
      this.hashMode ? this._update(ie) : this.push(this._update(ie));
    } catch (ke) {
      oe = ke;
    } finally {
      re(oe);
    }
  }, V.prototype._flush = function(ie) {
    var ce;
    try {
      this.push(this.__final());
    } catch (re) {
      ce = re;
    }
    ie(ce);
  }, V.prototype._finalOrDigest = function(ie) {
    var ce = this.__final() || A.alloc(0);
    return ie && (ce = this._toString(ce, ie, !0)), ce;
  }, V.prototype._toString = function(ie, ce, re) {
    if (this._decoder || (this._decoder = new L(ce), this._encoding = ce), this._encoding !== ce)
      throw new Error("cant switch encodings");
    var oe = this._decoder.write(ie);
    return re && (oe += this._decoder.end()), oe;
  }, cipherBase = V, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var A = requireInherits_browser(), B = requireMd5_js(), L = requireRipemd160(), K = requireSha_js(), V = requireCipherBase();
  function W(J) {
    V.call(this, "digest"), this._hash = J;
  }
  return A(W, V), W.prototype._update = function(J) {
    this._hash.update(J);
  }, W.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(ne) {
    return ne = ne.toLowerCase(), ne === "md5" ? new B() : ne === "rmd160" || ne === "ripemd160" ? new L() : new W(K(ne));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var A = requireInherits_browser(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = B.alloc(128), V = 64;
  function W(J, ne) {
    L.call(this, "digest"), typeof ne == "string" && (ne = B.from(ne)), this._alg = J, this._key = ne, ne.length > V ? ne = J(ne) : ne.length < V && (ne = B.concat([ne, K], V));
    for (var ie = this._ipad = B.allocUnsafe(V), ce = this._opad = B.allocUnsafe(V), re = 0; re < V; re++)
      ie[re] = ne[re] ^ 54, ce[re] = ne[re] ^ 92;
    this._hash = [ie];
  }
  return A(W, L), W.prototype._update = function(J) {
    this._hash.push(J);
  }, W.prototype._final = function() {
    var J = this._alg(B.concat(this._hash));
    return this._alg(B.concat([this._opad, J]));
  }, legacy = W, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var A = requireMd5_js();
  return md5 = function(B) {
    return new A().update(B).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var A = requireInherits_browser(), B = requireLegacy(), L = requireCipherBase(), K = safeBufferExports.Buffer, V = requireMd5(), W = requireRipemd160(), J = requireSha_js(), ne = K.alloc(128);
  function ie(ce, re) {
    L.call(this, "digest"), typeof re == "string" && (re = K.from(re));
    var oe = ce === "sha512" || ce === "sha384" ? 128 : 64;
    if (this._alg = ce, this._key = re, re.length > oe) {
      var ke = ce === "rmd160" ? new W() : J(ce);
      re = ke.update(re).digest();
    } else re.length < oe && (re = K.concat([re, ne], oe));
    for (var Oe = this._ipad = K.allocUnsafe(oe), it = this._opad = K.allocUnsafe(oe), at = 0; at < oe; at++)
      Oe[at] = re[at] ^ 54, it[at] = re[at] ^ 92;
    this._hash = ce === "rmd160" ? new W() : J(ce), this._hash.update(Oe);
  }
  return A(ie, L), ie.prototype._update = function(ce) {
    this._hash.update(ce);
  }, ie.prototype._final = function() {
    var ce = this._hash.digest(), re = this._alg === "rmd160" ? new W() : J(this._alg);
    return re.update(this._opad).update(ce).digest();
  }, browser$8 = function(re, oe) {
    return re = re.toLowerCase(), re === "rmd160" || re === "ripemd160" ? new ie("rmd160", oe) : re === "md5" ? new B(V, oe) : new ie(re, oe);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var A = Math.pow(2, 30) - 1;
  return precondition = function(B, L) {
    if (typeof B != "number")
      throw new TypeError("Iterations not a number");
    if (B < 0)
      throw new TypeError("Bad iterations");
    if (typeof L != "number")
      throw new TypeError("Key length not a number");
    if (L < 0 || L > A || L !== L)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var A;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    A = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var B = parseInt(process$1.version.split(".")[0].slice(1), 10);
    A = B >= 6 ? "utf-8" : "binary";
  } else
    A = "utf-8";
  return defaultEncoding_1 = A, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var A = safeBufferExports.Buffer;
  return toBuffer$1 = function(B, L, K) {
    if (A.isBuffer(B))
      return B;
    if (typeof B == "string")
      return A.from(B, L);
    if (ArrayBuffer.isView(B))
      return A.from(B.buffer);
    throw new TypeError(K + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var A = requireMd5(), B = requireRipemd160(), L = requireSha_js(), K = safeBufferExports.Buffer, V = requirePrecondition(), W = requireDefaultEncoding(), J = requireToBuffer(), ne = K.alloc(128), ie = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function ce(ke, Oe, it) {
    var at = re(ke), ut = ke === "sha512" || ke === "sha384" ? 128 : 64;
    Oe.length > ut ? Oe = at(Oe) : Oe.length < ut && (Oe = K.concat([Oe, ne], ut));
    for (var dt = K.allocUnsafe(ut + ie[ke]), ct = K.allocUnsafe(ut + ie[ke]), bt = 0; bt < ut; bt++)
      dt[bt] = Oe[bt] ^ 54, ct[bt] = Oe[bt] ^ 92;
    var vt = K.allocUnsafe(ut + it + 4);
    dt.copy(vt, 0, 0, ut), this.ipad1 = vt, this.ipad2 = dt, this.opad = ct, this.alg = ke, this.blocksize = ut, this.hash = at, this.size = ie[ke];
  }
  ce.prototype.run = function(ke, Oe) {
    ke.copy(Oe, this.blocksize);
    var it = this.hash(Oe);
    return it.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function re(ke) {
    function Oe(at) {
      return L(ke).update(at).digest();
    }
    function it(at) {
      return new B().update(at).digest();
    }
    return ke === "rmd160" || ke === "ripemd160" ? it : ke === "md5" ? A : Oe;
  }
  function oe(ke, Oe, it, at, ut) {
    V(it, at), ke = J(ke, W, "Password"), Oe = J(Oe, W, "Salt"), ut = ut || "sha1";
    var dt = new ce(ut, ke, Oe.length), ct = K.allocUnsafe(at), bt = K.allocUnsafe(Oe.length + 4);
    Oe.copy(bt, 0, 0, Oe.length);
    for (var vt = 0, $t = ie[ut], xt = Math.ceil(at / $t), Ot = 1; Ot <= xt; Ot++) {
      bt.writeUInt32BE(Ot, Oe.length);
      for (var At = dt.run(bt, dt.ipad1), yt = At, Bt = 1; Bt < it; Bt++) {
        yt = dt.run(yt, dt.ipad2);
        for (var gt = 0; gt < $t; gt++) At[gt] ^= yt[gt];
      }
      At.copy(ct, vt), vt += $t;
    }
    return ct;
  }
  return syncBrowser = oe, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var A = safeBufferExports.Buffer, B = requirePrecondition(), L = requireDefaultEncoding(), K = requireSyncBrowser(), V = requireToBuffer(), W, J = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, ne = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ie = [];
  function ce(it) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !J || !J.importKey || !J.deriveBits)
      return Promise.resolve(!1);
    if (ie[it] !== void 0)
      return ie[it];
    W = W || A.alloc(8);
    var at = ke(W, W, 10, 128, it).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ie[it] = at, at;
  }
  var re;
  function oe() {
    return re || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? re = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? re = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? re = commonjsGlobal.setImmediate : re = commonjsGlobal.setTimeout, re);
  }
  function ke(it, at, ut, dt, ct) {
    return J.importKey(
      "raw",
      it,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(bt) {
      return J.deriveBits({
        name: "PBKDF2",
        salt: at,
        iterations: ut,
        hash: {
          name: ct
        }
      }, bt, dt << 3);
    }).then(function(bt) {
      return A.from(bt);
    });
  }
  function Oe(it, at) {
    it.then(function(ut) {
      oe()(function() {
        at(null, ut);
      });
    }, function(ut) {
      oe()(function() {
        at(ut);
      });
    });
  }
  return async = function(it, at, ut, dt, ct, bt) {
    typeof ct == "function" && (bt = ct, ct = void 0), ct = ct || "sha1";
    var vt = ne[ct.toLowerCase()];
    if (!vt || typeof commonjsGlobal.Promise != "function") {
      oe()(function() {
        var $t;
        try {
          $t = K(it, at, ut, dt, ct);
        } catch (xt) {
          return bt(xt);
        }
        bt(null, $t);
      });
      return;
    }
    if (B(ut, dt), it = V(it, L, "Password"), at = V(at, L, "Salt"), typeof bt != "function") throw new Error("No callback provided to pbkdf2");
    Oe(ce(vt).then(function($t) {
      return $t ? ke(it, at, ut, dt, vt) : K(it, at, ut, dt, ct);
    }), bt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(V, W) {
    var J = V[0 + W] << 24 | V[1 + W] << 16 | V[2 + W] << 8 | V[3 + W];
    return J >>> 0;
  }, utils$4.writeUInt32BE = function(V, W, J) {
    V[0 + J] = W >>> 24, V[1 + J] = W >>> 16 & 255, V[2 + J] = W >>> 8 & 255, V[3 + J] = W & 255;
  }, utils$4.ip = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = 6; re >= 0; re -= 2) {
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= W >>> oe + re & 1;
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= V >>> oe + re & 1;
    }
    for (var re = 6; re >= 0; re -= 2) {
      for (var oe = 1; oe <= 25; oe += 8)
        ce <<= 1, ce |= W >>> oe + re & 1;
      for (var oe = 1; oe <= 25; oe += 8)
        ce <<= 1, ce |= V >>> oe + re & 1;
    }
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.rip = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = 0; re < 4; re++)
      for (var oe = 24; oe >= 0; oe -= 8)
        ie <<= 1, ie |= W >>> oe + re & 1, ie <<= 1, ie |= V >>> oe + re & 1;
    for (var re = 4; re < 8; re++)
      for (var oe = 24; oe >= 0; oe -= 8)
        ce <<= 1, ce |= W >>> oe + re & 1, ce <<= 1, ce |= V >>> oe + re & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.pc1 = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = 7; re >= 5; re--) {
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= W >> oe + re & 1;
      for (var oe = 0; oe <= 24; oe += 8)
        ie <<= 1, ie |= V >> oe + re & 1;
    }
    for (var oe = 0; oe <= 24; oe += 8)
      ie <<= 1, ie |= W >> oe + re & 1;
    for (var re = 1; re <= 3; re++) {
      for (var oe = 0; oe <= 24; oe += 8)
        ce <<= 1, ce |= W >> oe + re & 1;
      for (var oe = 0; oe <= 24; oe += 8)
        ce <<= 1, ce |= V >> oe + re & 1;
    }
    for (var oe = 0; oe <= 24; oe += 8)
      ce <<= 1, ce |= V >> oe + re & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.r28shl = function(V, W) {
    return V << W & 268435455 | V >>> 28 - W;
  };
  var A = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(V, W, J, ne) {
    for (var ie = 0, ce = 0, re = A.length >>> 1, oe = 0; oe < re; oe++)
      ie <<= 1, ie |= V >>> A[oe] & 1;
    for (var oe = re; oe < A.length; oe++)
      ce <<= 1, ce |= W >>> A[oe] & 1;
    J[ne + 0] = ie >>> 0, J[ne + 1] = ce >>> 0;
  }, utils$4.expand = function(V, W, J) {
    var ne = 0, ie = 0;
    ne = (V & 1) << 5 | V >>> 27;
    for (var ce = 23; ce >= 15; ce -= 4)
      ne <<= 6, ne |= V >>> ce & 63;
    for (var ce = 11; ce >= 3; ce -= 4)
      ie |= V >>> ce & 63, ie <<= 6;
    ie |= (V & 31) << 1 | V >>> 31, W[J + 0] = ne >>> 0, W[J + 1] = ie >>> 0;
  };
  var B = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(V, W) {
    for (var J = 0, ne = 0; ne < 4; ne++) {
      var ie = V >>> 18 - ne * 6 & 63, ce = B[ne * 64 + ie];
      J <<= 4, J |= ce;
    }
    for (var ne = 0; ne < 4; ne++) {
      var ie = W >>> 18 - ne * 6 & 63, ce = B[4 * 64 + ne * 64 + ie];
      J <<= 4, J |= ce;
    }
    return J >>> 0;
  };
  var L = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(V) {
    for (var W = 0, J = 0; J < L.length; J++)
      W <<= 1, W |= V >>> L[J] & 1;
    return W >>> 0;
  }, utils$4.padSplit = function(V, W, J) {
    for (var ne = V.toString(2); ne.length < W; )
      ne = "0" + ne;
    for (var ie = [], ce = 0; ce < W; ce += J)
      ie.push(ne.slice(ce, ce + J));
    return ie.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = A;
  function A(B, L) {
    if (!B)
      throw new Error(L || "Assertion failed");
  }
  return A.equal = function(L, K, V) {
    if (L != K)
      throw new Error(V || "Assertion failed: " + L + " != " + K);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var A = requireMinimalisticAssert();
  function B(L) {
    this.options = L, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = L.padding !== !1;
  }
  return cipher = B, B.prototype._init = function() {
  }, B.prototype.update = function(K) {
    return K.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(K) : this._updateEncrypt(K);
  }, B.prototype._buffer = function(K, V) {
    for (var W = Math.min(this.buffer.length - this.bufferOff, K.length - V), J = 0; J < W; J++)
      this.buffer[this.bufferOff + J] = K[V + J];
    return this.bufferOff += W, W;
  }, B.prototype._flushBuffer = function(K, V) {
    return this._update(this.buffer, 0, K, V), this.bufferOff = 0, this.blockSize;
  }, B.prototype._updateEncrypt = function(K) {
    var V = 0, W = 0, J = (this.bufferOff + K.length) / this.blockSize | 0, ne = new Array(J * this.blockSize);
    this.bufferOff !== 0 && (V += this._buffer(K, V), this.bufferOff === this.buffer.length && (W += this._flushBuffer(ne, W)));
    for (var ie = K.length - (K.length - V) % this.blockSize; V < ie; V += this.blockSize)
      this._update(K, V, ne, W), W += this.blockSize;
    for (; V < K.length; V++, this.bufferOff++)
      this.buffer[this.bufferOff] = K[V];
    return ne;
  }, B.prototype._updateDecrypt = function(K) {
    for (var V = 0, W = 0, J = Math.ceil((this.bufferOff + K.length) / this.blockSize) - 1, ne = new Array(J * this.blockSize); J > 0; J--)
      V += this._buffer(K, V), W += this._flushBuffer(ne, W);
    return V += this._buffer(K, V), ne;
  }, B.prototype.final = function(K) {
    var V;
    K && (V = this.update(K));
    var W;
    return this.type === "encrypt" ? W = this._finalEncrypt() : W = this._finalDecrypt(), V ? V.concat(W) : W;
  }, B.prototype._pad = function(K, V) {
    if (V === 0)
      return !1;
    for (; V < K.length; )
      K[V++] = 0;
    return !0;
  }, B.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var K = new Array(this.blockSize);
    return this._update(this.buffer, 0, K, 0), K;
  }, B.prototype._unpad = function(K) {
    return K;
  }, B.prototype._finalDecrypt = function() {
    A.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var K = new Array(this.blockSize);
    return this._flushBuffer(K, 0), this._unpad(K);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireUtils$3(), K = requireCipher();
  function V() {
    this.tmp = new Array(2), this.keys = null;
  }
  function W(ne) {
    K.call(this, ne);
    var ie = new V();
    this._desState = ie, this.deriveKeys(ie, ne.key);
  }
  B(W, K), des = W, W.create = function(ie) {
    return new W(ie);
  };
  var J = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return W.prototype.deriveKeys = function(ie, ce) {
    ie.keys = new Array(16 * 2), A.equal(ce.length, this.blockSize, "Invalid key length");
    var re = L.readUInt32BE(ce, 0), oe = L.readUInt32BE(ce, 4);
    L.pc1(re, oe, ie.tmp, 0), re = ie.tmp[0], oe = ie.tmp[1];
    for (var ke = 0; ke < ie.keys.length; ke += 2) {
      var Oe = J[ke >>> 1];
      re = L.r28shl(re, Oe), oe = L.r28shl(oe, Oe), L.pc2(re, oe, ie.keys, ke);
    }
  }, W.prototype._update = function(ie, ce, re, oe) {
    var ke = this._desState, Oe = L.readUInt32BE(ie, ce), it = L.readUInt32BE(ie, ce + 4);
    L.ip(Oe, it, ke.tmp, 0), Oe = ke.tmp[0], it = ke.tmp[1], this.type === "encrypt" ? this._encrypt(ke, Oe, it, ke.tmp, 0) : this._decrypt(ke, Oe, it, ke.tmp, 0), Oe = ke.tmp[0], it = ke.tmp[1], L.writeUInt32BE(re, Oe, oe), L.writeUInt32BE(re, it, oe + 4);
  }, W.prototype._pad = function(ie, ce) {
    if (this.padding === !1)
      return !1;
    for (var re = ie.length - ce, oe = ce; oe < ie.length; oe++)
      ie[oe] = re;
    return !0;
  }, W.prototype._unpad = function(ie) {
    if (this.padding === !1)
      return ie;
    for (var ce = ie[ie.length - 1], re = ie.length - ce; re < ie.length; re++)
      A.equal(ie[re], ce);
    return ie.slice(0, ie.length - ce);
  }, W.prototype._encrypt = function(ie, ce, re, oe, ke) {
    for (var Oe = ce, it = re, at = 0; at < ie.keys.length; at += 2) {
      var ut = ie.keys[at], dt = ie.keys[at + 1];
      L.expand(it, ie.tmp, 0), ut ^= ie.tmp[0], dt ^= ie.tmp[1];
      var ct = L.substitute(ut, dt), bt = L.permute(ct), vt = it;
      it = (Oe ^ bt) >>> 0, Oe = vt;
    }
    L.rip(it, Oe, oe, ke);
  }, W.prototype._decrypt = function(ie, ce, re, oe, ke) {
    for (var Oe = re, it = ce, at = ie.keys.length - 2; at >= 0; at -= 2) {
      var ut = ie.keys[at], dt = ie.keys[at + 1];
      L.expand(Oe, ie.tmp, 0), ut ^= ie.tmp[0], dt ^= ie.tmp[1];
      var ct = L.substitute(ut, dt), bt = L.permute(ct), vt = Oe;
      Oe = (it ^ bt) >>> 0, it = vt;
    }
    L.rip(Oe, it, oe, ke);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = {};
  function K(W) {
    A.equal(W.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var J = 0; J < this.iv.length; J++)
      this.iv[J] = W[J];
  }
  function V(W) {
    function J(re) {
      W.call(this, re), this._cbcInit();
    }
    B(J, W);
    for (var ne = Object.keys(L), ie = 0; ie < ne.length; ie++) {
      var ce = ne[ie];
      J.prototype[ce] = L[ce];
    }
    return J.create = function(oe) {
      return new J(oe);
    }, J;
  }
  return cbc$1.instantiate = V, L._cbcInit = function() {
    var J = new K(this.options.iv);
    this._cbcState = J;
  }, L._update = function(J, ne, ie, ce) {
    var re = this._cbcState, oe = this.constructor.super_.prototype, ke = re.iv;
    if (this.type === "encrypt") {
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        ke[Oe] ^= J[ne + Oe];
      oe._update.call(this, ke, 0, ie, ce);
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        ke[Oe] = ie[ce + Oe];
    } else {
      oe._update.call(this, J, ne, ie, ce);
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        ie[ce + Oe] ^= ke[Oe];
      for (var Oe = 0; Oe < this.blockSize; Oe++)
        ke[Oe] = J[ne + Oe];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser(), L = requireCipher(), K = requireDes$1();
  function V(J, ne) {
    A.equal(ne.length, 24, "Invalid key length");
    var ie = ne.slice(0, 8), ce = ne.slice(8, 16), re = ne.slice(16, 24);
    J === "encrypt" ? this.ciphers = [
      K.create({ type: "encrypt", key: ie }),
      K.create({ type: "decrypt", key: ce }),
      K.create({ type: "encrypt", key: re })
    ] : this.ciphers = [
      K.create({ type: "decrypt", key: re }),
      K.create({ type: "encrypt", key: ce }),
      K.create({ type: "decrypt", key: ie })
    ];
  }
  function W(J) {
    L.call(this, J);
    var ne = new V(this.type, this.options.key);
    this._edeState = ne;
  }
  return B(W, L), ede = W, W.create = function(ne) {
    return new W(ne);
  }, W.prototype._update = function(ne, ie, ce, re) {
    var oe = this._edeState;
    oe.ciphers[0]._update(ne, ie, ce, re), oe.ciphers[1]._update(ce, re, ce, re), oe.ciphers[2]._update(ce, re, ce, re);
  }, W.prototype._pad = K.prototype._pad, W.prototype._unpad = K.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var A = requireCipherBase(), B = requireDes(), L = requireInherits_browser(), K = safeBufferExports.Buffer, V = {
    "des-ede3-cbc": B.CBC.instantiate(B.EDE),
    "des-ede3": B.EDE,
    "des-ede-cbc": B.CBC.instantiate(B.EDE),
    "des-ede": B.EDE,
    "des-cbc": B.CBC.instantiate(B.DES),
    "des-ecb": B.DES
  };
  V.des = V["des-cbc"], V.des3 = V["des-ede3-cbc"], browserifyDes = W, L(W, A);
  function W(J) {
    A.call(this);
    var ne = J.mode.toLowerCase(), ie = V[ne], ce;
    J.decrypt ? ce = "decrypt" : ce = "encrypt";
    var re = J.key;
    K.isBuffer(re) || (re = K.from(re)), (ne === "des-ede" || ne === "des-ede-cbc") && (re = K.concat([re, re.slice(0, 8)]));
    var oe = J.iv;
    K.isBuffer(oe) || (oe = K.from(oe)), this._des = ie.create({
      key: re,
      iv: oe,
      type: ce
    });
  }
  return W.prototype._update = function(J) {
    return K.from(this._des.update(J));
  }, W.prototype._final = function() {
    return K.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(A, B) {
    return A._cipher.encryptBlock(B);
  }, ecb.decrypt = function(A, B) {
    return A._cipher.decryptBlock(B);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(B, L) {
    for (var K = Math.min(B.length, L.length), V = new Buffer$1(K), W = 0; W < K; ++W)
      V[W] = B[W] ^ L[W];
    return V;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var A = requireBufferXor();
  return cbc.encrypt = function(B, L) {
    var K = A(L, B._prev);
    return B._prev = B._cipher.encryptBlock(K), B._prev;
  }, cbc.decrypt = function(B, L) {
    var K = B._prev;
    B._prev = L;
    var V = B._cipher.decryptBlock(L);
    return A(V, K);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var A = safeBufferExports.Buffer, B = requireBufferXor();
  function L(K, V, W) {
    var J = V.length, ne = B(V, K._cache);
    return K._cache = K._cache.slice(J), K._prev = A.concat([K._prev, W ? V : ne]), ne;
  }
  return cfb.encrypt = function(K, V, W) {
    for (var J = A.allocUnsafe(0), ne; V.length; )
      if (K._cache.length === 0 && (K._cache = K._cipher.encryptBlock(K._prev), K._prev = A.allocUnsafe(0)), K._cache.length <= V.length)
        ne = K._cache.length, J = A.concat([J, L(K, V.slice(0, ne), W)]), V = V.slice(ne);
      else {
        J = A.concat([J, L(K, V, W)]);
        break;
      }
    return J;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var A = safeBufferExports.Buffer;
  function B(L, K, V) {
    var W = L._cipher.encryptBlock(L._prev), J = W[0] ^ K;
    return L._prev = A.concat([
      L._prev.slice(1),
      A.from([V ? K : J])
    ]), J;
  }
  return cfb8.encrypt = function(L, K, V) {
    for (var W = K.length, J = A.allocUnsafe(W), ne = -1; ++ne < W; )
      J[ne] = B(L, K[ne], V);
    return J;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var A = safeBufferExports.Buffer;
  function B(K, V, W) {
    for (var J, ne = -1, ie = 8, ce = 0, re, oe; ++ne < ie; )
      J = K._cipher.encryptBlock(K._prev), re = V & 1 << 7 - ne ? 128 : 0, oe = J[0] ^ re, ce += (oe & 128) >> ne % 8, K._prev = L(K._prev, W ? re : oe);
    return ce;
  }
  function L(K, V) {
    var W = K.length, J = -1, ne = A.allocUnsafe(K.length);
    for (K = A.concat([K, A.from([V])]); ++J < W; )
      ne[J] = K[J] << 1 | K[J + 1] >> 7;
    return ne;
  }
  return cfb1.encrypt = function(K, V, W) {
    for (var J = V.length, ne = A.allocUnsafe(J), ie = -1; ++ie < J; )
      ne[ie] = B(K, V[ie], W);
    return ne;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var A = requireBufferXor();
  function B(L) {
    return L._prev = L._cipher.encryptBlock(L._prev), L._prev;
  }
  return ofb.encrypt = function(L, K) {
    for (; L._cache.length < K.length; )
      L._cache = Buffer$1.concat([L._cache, B(L)]);
    var V = L._cache.slice(0, K.length);
    return L._cache = L._cache.slice(K.length), A(K, V);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function A(B) {
    for (var L = B.length, K; L--; )
      if (K = B.readUInt8(L), K === 255)
        B.writeUInt8(0, L);
      else {
        K++, B.writeUInt8(K, L);
        break;
      }
  }
  return incr32_1 = A, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var A = requireBufferXor(), B = safeBufferExports.Buffer, L = requireIncr32();
  function K(W) {
    var J = W._cipher.encryptBlockRaw(W._prev);
    return L(W._prev), J;
  }
  var V = 16;
  return ctr.encrypt = function(W, J) {
    var ne = Math.ceil(J.length / V), ie = W._cache.length;
    W._cache = B.concat([
      W._cache,
      B.allocUnsafe(ne * V)
    ]);
    for (var ce = 0; ce < ne; ce++) {
      var re = K(W), oe = ie + ce * V;
      W._cache.writeUInt32BE(re[0], oe + 0), W._cache.writeUInt32BE(re[1], oe + 4), W._cache.writeUInt32BE(re[2], oe + 8), W._cache.writeUInt32BE(re[3], oe + 12);
    }
    var ke = W._cache.slice(0, J.length);
    return W._cache = W._cache.slice(J.length), A(J, ke);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var A = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, B = require$$2;
  for (var L in B)
    B[L].module = A[B[L].mode];
  return modes_1 = B, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var A = safeBufferExports.Buffer;
  function B(ne) {
    A.isBuffer(ne) || (ne = A.from(ne));
    for (var ie = ne.length / 4 | 0, ce = new Array(ie), re = 0; re < ie; re++)
      ce[re] = ne.readUInt32BE(re * 4);
    return ce;
  }
  function L(ne) {
    for (var ie = 0; ie < ne.length; ne++)
      ne[ie] = 0;
  }
  function K(ne, ie, ce, re, oe) {
    for (var ke = ce[0], Oe = ce[1], it = ce[2], at = ce[3], ut = ne[0] ^ ie[0], dt = ne[1] ^ ie[1], ct = ne[2] ^ ie[2], bt = ne[3] ^ ie[3], vt, $t, xt, Ot, At = 4, yt = 1; yt < oe; yt++)
      vt = ke[ut >>> 24] ^ Oe[dt >>> 16 & 255] ^ it[ct >>> 8 & 255] ^ at[bt & 255] ^ ie[At++], $t = ke[dt >>> 24] ^ Oe[ct >>> 16 & 255] ^ it[bt >>> 8 & 255] ^ at[ut & 255] ^ ie[At++], xt = ke[ct >>> 24] ^ Oe[bt >>> 16 & 255] ^ it[ut >>> 8 & 255] ^ at[dt & 255] ^ ie[At++], Ot = ke[bt >>> 24] ^ Oe[ut >>> 16 & 255] ^ it[dt >>> 8 & 255] ^ at[ct & 255] ^ ie[At++], ut = vt, dt = $t, ct = xt, bt = Ot;
    return vt = (re[ut >>> 24] << 24 | re[dt >>> 16 & 255] << 16 | re[ct >>> 8 & 255] << 8 | re[bt & 255]) ^ ie[At++], $t = (re[dt >>> 24] << 24 | re[ct >>> 16 & 255] << 16 | re[bt >>> 8 & 255] << 8 | re[ut & 255]) ^ ie[At++], xt = (re[ct >>> 24] << 24 | re[bt >>> 16 & 255] << 16 | re[ut >>> 8 & 255] << 8 | re[dt & 255]) ^ ie[At++], Ot = (re[bt >>> 24] << 24 | re[ut >>> 16 & 255] << 16 | re[dt >>> 8 & 255] << 8 | re[ct & 255]) ^ ie[At++], vt = vt >>> 0, $t = $t >>> 0, xt = xt >>> 0, Ot = Ot >>> 0, [vt, $t, xt, Ot];
  }
  var V = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], W = function() {
    for (var ne = new Array(256), ie = 0; ie < 256; ie++)
      ie < 128 ? ne[ie] = ie << 1 : ne[ie] = ie << 1 ^ 283;
    for (var ce = [], re = [], oe = [[], [], [], []], ke = [[], [], [], []], Oe = 0, it = 0, at = 0; at < 256; ++at) {
      var ut = it ^ it << 1 ^ it << 2 ^ it << 3 ^ it << 4;
      ut = ut >>> 8 ^ ut & 255 ^ 99, ce[Oe] = ut, re[ut] = Oe;
      var dt = ne[Oe], ct = ne[dt], bt = ne[ct], vt = ne[ut] * 257 ^ ut * 16843008;
      oe[0][Oe] = vt << 24 | vt >>> 8, oe[1][Oe] = vt << 16 | vt >>> 16, oe[2][Oe] = vt << 8 | vt >>> 24, oe[3][Oe] = vt, vt = bt * 16843009 ^ ct * 65537 ^ dt * 257 ^ Oe * 16843008, ke[0][ut] = vt << 24 | vt >>> 8, ke[1][ut] = vt << 16 | vt >>> 16, ke[2][ut] = vt << 8 | vt >>> 24, ke[3][ut] = vt, Oe === 0 ? Oe = it = 1 : (Oe = dt ^ ne[ne[ne[bt ^ dt]]], it ^= ne[ne[it]]);
    }
    return {
      SBOX: ce,
      INV_SBOX: re,
      SUB_MIX: oe,
      INV_SUB_MIX: ke
    };
  }();
  function J(ne) {
    this._key = B(ne), this._reset();
  }
  return J.blockSize = 4 * 4, J.keySize = 256 / 8, J.prototype.blockSize = J.blockSize, J.prototype.keySize = J.keySize, J.prototype._reset = function() {
    for (var ne = this._key, ie = ne.length, ce = ie + 6, re = (ce + 1) * 4, oe = [], ke = 0; ke < ie; ke++)
      oe[ke] = ne[ke];
    for (ke = ie; ke < re; ke++) {
      var Oe = oe[ke - 1];
      ke % ie === 0 ? (Oe = Oe << 8 | Oe >>> 24, Oe = W.SBOX[Oe >>> 24] << 24 | W.SBOX[Oe >>> 16 & 255] << 16 | W.SBOX[Oe >>> 8 & 255] << 8 | W.SBOX[Oe & 255], Oe ^= V[ke / ie | 0] << 24) : ie > 6 && ke % ie === 4 && (Oe = W.SBOX[Oe >>> 24] << 24 | W.SBOX[Oe >>> 16 & 255] << 16 | W.SBOX[Oe >>> 8 & 255] << 8 | W.SBOX[Oe & 255]), oe[ke] = oe[ke - ie] ^ Oe;
    }
    for (var it = [], at = 0; at < re; at++) {
      var ut = re - at, dt = oe[ut - (at % 4 ? 0 : 4)];
      at < 4 || ut <= 4 ? it[at] = dt : it[at] = W.INV_SUB_MIX[0][W.SBOX[dt >>> 24]] ^ W.INV_SUB_MIX[1][W.SBOX[dt >>> 16 & 255]] ^ W.INV_SUB_MIX[2][W.SBOX[dt >>> 8 & 255]] ^ W.INV_SUB_MIX[3][W.SBOX[dt & 255]];
    }
    this._nRounds = ce, this._keySchedule = oe, this._invKeySchedule = it;
  }, J.prototype.encryptBlockRaw = function(ne) {
    return ne = B(ne), K(ne, this._keySchedule, W.SUB_MIX, W.SBOX, this._nRounds);
  }, J.prototype.encryptBlock = function(ne) {
    var ie = this.encryptBlockRaw(ne), ce = A.allocUnsafe(16);
    return ce.writeUInt32BE(ie[0], 0), ce.writeUInt32BE(ie[1], 4), ce.writeUInt32BE(ie[2], 8), ce.writeUInt32BE(ie[3], 12), ce;
  }, J.prototype.decryptBlock = function(ne) {
    ne = B(ne);
    var ie = ne[1];
    ne[1] = ne[3], ne[3] = ie;
    var ce = K(ne, this._invKeySchedule, W.INV_SUB_MIX, W.INV_SBOX, this._nRounds), re = A.allocUnsafe(16);
    return re.writeUInt32BE(ce[0], 0), re.writeUInt32BE(ce[3], 4), re.writeUInt32BE(ce[2], 8), re.writeUInt32BE(ce[1], 12), re;
  }, J.prototype.scrub = function() {
    L(this._keySchedule), L(this._invKeySchedule), L(this._key);
  }, aes.AES = J, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var A = safeBufferExports.Buffer, B = A.alloc(16, 0);
  function L(W) {
    return [
      W.readUInt32BE(0),
      W.readUInt32BE(4),
      W.readUInt32BE(8),
      W.readUInt32BE(12)
    ];
  }
  function K(W) {
    var J = A.allocUnsafe(16);
    return J.writeUInt32BE(W[0] >>> 0, 0), J.writeUInt32BE(W[1] >>> 0, 4), J.writeUInt32BE(W[2] >>> 0, 8), J.writeUInt32BE(W[3] >>> 0, 12), J;
  }
  function V(W) {
    this.h = W, this.state = A.alloc(16, 0), this.cache = A.allocUnsafe(0);
  }
  return V.prototype.ghash = function(W) {
    for (var J = -1; ++J < W.length; )
      this.state[J] ^= W[J];
    this._multiply();
  }, V.prototype._multiply = function() {
    for (var W = L(this.h), J = [0, 0, 0, 0], ne, ie, ce, re = -1; ++re < 128; ) {
      for (ie = (this.state[~~(re / 8)] & 1 << 7 - re % 8) !== 0, ie && (J[0] ^= W[0], J[1] ^= W[1], J[2] ^= W[2], J[3] ^= W[3]), ce = (W[3] & 1) !== 0, ne = 3; ne > 0; ne--)
        W[ne] = W[ne] >>> 1 | (W[ne - 1] & 1) << 31;
      W[0] = W[0] >>> 1, ce && (W[0] = W[0] ^ 225 << 24);
    }
    this.state = K(J);
  }, V.prototype.update = function(W) {
    this.cache = A.concat([this.cache, W]);
    for (var J; this.cache.length >= 16; )
      J = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(J);
  }, V.prototype.final = function(W, J) {
    return this.cache.length && this.ghash(A.concat([this.cache, B], 16)), this.ghash(K([0, W, 0, J])), this.state;
  }, ghash = V, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser(), V = requireGhash(), W = requireBufferXor(), J = requireIncr32();
  function ne(re, oe) {
    var ke = 0;
    re.length !== oe.length && ke++;
    for (var Oe = Math.min(re.length, oe.length), it = 0; it < Oe; ++it)
      ke += re[it] ^ oe[it];
    return ke;
  }
  function ie(re, oe, ke) {
    if (oe.length === 12)
      return re._finID = B.concat([oe, B.from([0, 0, 0, 1])]), B.concat([oe, B.from([0, 0, 0, 2])]);
    var Oe = new V(ke), it = oe.length, at = it % 16;
    Oe.update(oe), at && (at = 16 - at, Oe.update(B.alloc(at, 0))), Oe.update(B.alloc(8, 0));
    var ut = it * 8, dt = B.alloc(8);
    dt.writeUIntBE(ut, 0, 8), Oe.update(dt), re._finID = Oe.state;
    var ct = B.from(re._finID);
    return J(ct), ct;
  }
  function ce(re, oe, ke, Oe) {
    L.call(this);
    var it = B.alloc(4, 0);
    this._cipher = new A.AES(oe);
    var at = this._cipher.encryptBlock(it);
    this._ghash = new V(at), ke = ie(this, ke, at), this._prev = B.from(ke), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = Oe, this._alen = 0, this._len = 0, this._mode = re, this._authTag = null, this._called = !1;
  }
  return K(ce, L), ce.prototype._update = function(re) {
    if (!this._called && this._alen) {
      var oe = 16 - this._alen % 16;
      oe < 16 && (oe = B.alloc(oe, 0), this._ghash.update(oe));
    }
    this._called = !0;
    var ke = this._mode.encrypt(this, re);
    return this._decrypt ? this._ghash.update(re) : this._ghash.update(ke), this._len += re.length, ke;
  }, ce.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var re = W(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && ne(re, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = re, this._cipher.scrub();
  }, ce.prototype.getAuthTag = function() {
    if (this._decrypt || !B.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ce.prototype.setAuthTag = function(oe) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = oe;
  }, ce.prototype.setAAD = function(oe) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(oe), this._alen += oe.length;
  }, authCipher = ce, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var A = requireAes(), B = safeBufferExports.Buffer, L = requireCipherBase(), K = requireInherits_browser();
  function V(W, J, ne, ie) {
    L.call(this), this._cipher = new A.AES(J), this._prev = B.from(ne), this._cache = B.allocUnsafe(0), this._secCache = B.allocUnsafe(0), this._decrypt = ie, this._mode = W;
  }
  return K(V, L), V.prototype._update = function(W) {
    return this._mode.encrypt(this, W, this._decrypt);
  }, V.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = V, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var A = safeBufferExports.Buffer, B = requireMd5_js();
  function L(K, V, W, J) {
    if (A.isBuffer(K) || (K = A.from(K, "binary")), V && (A.isBuffer(V) || (V = A.from(V, "binary")), V.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var ne = W / 8, ie = A.alloc(ne), ce = A.alloc(J || 0), re = A.alloc(0); ne > 0 || J > 0; ) {
      var oe = new B();
      oe.update(re), oe.update(K), V && oe.update(V), re = oe.digest();
      var ke = 0;
      if (ne > 0) {
        var Oe = ie.length - ne;
        ke = Math.min(ne, re.length), re.copy(ie, Oe, 0, ke), ne -= ke;
      }
      if (ke < re.length && J > 0) {
        var it = ce.length - J, at = Math.min(J, re.length - ke);
        re.copy(ce, it, ke, ke + at), J -= at;
      }
    }
    return re.fill(0), { key: ie, iv: ce };
  }
  return evp_bytestokey = L, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var A = requireModes$1(), B = requireAuthCipher(), L = safeBufferExports.Buffer, K = requireStreamCipher(), V = requireCipherBase(), W = requireAes(), J = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Oe, it, at) {
    V.call(this), this._cache = new re(), this._cipher = new W.AES(it), this._prev = L.from(at), this._mode = Oe, this._autopadding = !0;
  }
  ne(ie, V), ie.prototype._update = function(Oe) {
    this._cache.add(Oe);
    for (var it, at, ut = []; it = this._cache.get(); )
      at = this._mode.encrypt(this, it), ut.push(at);
    return L.concat(ut);
  };
  var ce = L.alloc(16, 16);
  ie.prototype._final = function() {
    var Oe = this._cache.flush();
    if (this._autopadding)
      return Oe = this._mode.encrypt(this, Oe), this._cipher.scrub(), Oe;
    if (!Oe.equals(ce))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Oe) {
    return this._autopadding = !!Oe, this;
  };
  function re() {
    this.cache = L.allocUnsafe(0);
  }
  re.prototype.add = function(Oe) {
    this.cache = L.concat([this.cache, Oe]);
  }, re.prototype.get = function() {
    if (this.cache.length > 15) {
      var Oe = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Oe;
    }
    return null;
  }, re.prototype.flush = function() {
    for (var Oe = 16 - this.cache.length, it = L.allocUnsafe(Oe), at = -1; ++at < Oe; )
      it.writeUInt8(Oe, at);
    return L.concat([this.cache, it]);
  };
  function oe(Oe, it, at) {
    var ut = A[Oe.toLowerCase()];
    if (!ut) throw new TypeError("invalid suite type");
    if (typeof it == "string" && (it = L.from(it)), it.length !== ut.key / 8) throw new TypeError("invalid key length " + it.length);
    if (typeof at == "string" && (at = L.from(at)), ut.mode !== "GCM" && at.length !== ut.iv) throw new TypeError("invalid iv length " + at.length);
    return ut.type === "stream" ? new K(ut.module, it, at) : ut.type === "auth" ? new B(ut.module, it, at) : new ie(ut.module, it, at);
  }
  function ke(Oe, it) {
    var at = A[Oe.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var ut = J(it, !1, at.key, at.iv);
    return oe(Oe, ut.key, ut.iv);
  }
  return encrypter.createCipheriv = oe, encrypter.createCipher = ke, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var A = requireAuthCipher(), B = safeBufferExports.Buffer, L = requireModes$1(), K = requireStreamCipher(), V = requireCipherBase(), W = requireAes(), J = requireEvp_bytestokey(), ne = requireInherits_browser();
  function ie(Oe, it, at) {
    V.call(this), this._cache = new ce(), this._last = void 0, this._cipher = new W.AES(it), this._prev = B.from(at), this._mode = Oe, this._autopadding = !0;
  }
  ne(ie, V), ie.prototype._update = function(Oe) {
    this._cache.add(Oe);
    for (var it, at, ut = []; it = this._cache.get(this._autopadding); )
      at = this._mode.decrypt(this, it), ut.push(at);
    return B.concat(ut);
  }, ie.prototype._final = function() {
    var Oe = this._cache.flush();
    if (this._autopadding)
      return re(this._mode.decrypt(this, Oe));
    if (Oe)
      throw new Error("data not multiple of block length");
  }, ie.prototype.setAutoPadding = function(Oe) {
    return this._autopadding = !!Oe, this;
  };
  function ce() {
    this.cache = B.allocUnsafe(0);
  }
  ce.prototype.add = function(Oe) {
    this.cache = B.concat([this.cache, Oe]);
  }, ce.prototype.get = function(Oe) {
    var it;
    if (Oe) {
      if (this.cache.length > 16)
        return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    } else if (this.cache.length >= 16)
      return it = this.cache.slice(0, 16), this.cache = this.cache.slice(16), it;
    return null;
  }, ce.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function re(Oe) {
    var it = Oe[15];
    if (it < 1 || it > 16)
      throw new Error("unable to decrypt data");
    for (var at = -1; ++at < it; )
      if (Oe[at + (16 - it)] !== it)
        throw new Error("unable to decrypt data");
    if (it !== 16)
      return Oe.slice(0, 16 - it);
  }
  function oe(Oe, it, at) {
    var ut = L[Oe.toLowerCase()];
    if (!ut) throw new TypeError("invalid suite type");
    if (typeof at == "string" && (at = B.from(at)), ut.mode !== "GCM" && at.length !== ut.iv) throw new TypeError("invalid iv length " + at.length);
    if (typeof it == "string" && (it = B.from(it)), it.length !== ut.key / 8) throw new TypeError("invalid key length " + it.length);
    return ut.type === "stream" ? new K(ut.module, it, at, !0) : ut.type === "auth" ? new A(ut.module, it, at, !0) : new ie(ut.module, it, at);
  }
  function ke(Oe, it) {
    var at = L[Oe.toLowerCase()];
    if (!at) throw new TypeError("invalid suite type");
    var ut = J(it, !1, at.key, at.iv);
    return oe(Oe, ut.key, ut.iv);
  }
  return decrypter.createDecipher = ke, decrypter.createDecipheriv = oe, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var A = requireEncrypter(), B = requireDecrypter(), L = require$$2;
  function K() {
    return Object.keys(L);
  }
  return browser$5.createCipher = browser$5.Cipher = A.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = A.createCipheriv, browser$5.createDecipher = browser$5.Decipher = B.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = B.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = K, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(A) {
    A["des-ecb"] = {
      key: 8,
      iv: 0
    }, A["des-cbc"] = A.des = {
      key: 8,
      iv: 8
    }, A["des-ede3-cbc"] = A.des3 = {
      key: 24,
      iv: 8
    }, A["des-ede3"] = {
      key: 24,
      iv: 0
    }, A["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, A["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var A = requireBrowserifyDes(), B = requireBrowser$6(), L = requireModes$1(), K = requireModes(), V = requireEvp_bytestokey();
  function W(re, oe) {
    re = re.toLowerCase();
    var ke, Oe;
    if (L[re])
      ke = L[re].key, Oe = L[re].iv;
    else if (K[re])
      ke = K[re].key * 8, Oe = K[re].iv;
    else
      throw new TypeError("invalid suite type");
    var it = V(oe, !1, ke, Oe);
    return ne(re, it.key, it.iv);
  }
  function J(re, oe) {
    re = re.toLowerCase();
    var ke, Oe;
    if (L[re])
      ke = L[re].key, Oe = L[re].iv;
    else if (K[re])
      ke = K[re].key * 8, Oe = K[re].iv;
    else
      throw new TypeError("invalid suite type");
    var it = V(oe, !1, ke, Oe);
    return ie(re, it.key, it.iv);
  }
  function ne(re, oe, ke) {
    if (re = re.toLowerCase(), L[re]) return B.createCipheriv(re, oe, ke);
    if (K[re]) return new A({ key: oe, iv: ke, mode: re });
    throw new TypeError("invalid suite type");
  }
  function ie(re, oe, ke) {
    if (re = re.toLowerCase(), L[re]) return B.createDecipheriv(re, oe, ke);
    if (K[re]) return new A({ key: oe, iv: ke, mode: re, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function ce() {
    return Object.keys(K).concat(B.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = W, browser$6.createCipheriv = browser$6.Cipheriv = ne, browser$6.createDecipher = browser$6.Decipher = J, browser$6.createDecipheriv = browser$6.Decipheriv = ie, browser$6.listCiphers = browser$6.getCiphers = ce, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(A) {
    (function(B, L) {
      function K(gt, rt) {
        if (!gt) throw new Error(rt || "Assertion failed");
      }
      function V(gt, rt) {
        gt.super_ = rt;
        var Ce = function() {
        };
        Ce.prototype = rt.prototype, gt.prototype = new Ce(), gt.prototype.constructor = gt;
      }
      function W(gt, rt, Ce) {
        if (W.isBN(gt))
          return gt;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, gt !== null && ((rt === "le" || rt === "be") && (Ce = rt, rt = 10), this._init(gt || 0, rt || 10, Ce || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var J;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? J = window.Buffer : J = require$$0$1.Buffer;
      } catch {
      }
      W.isBN = function(rt) {
        return rt instanceof W ? !0 : rt !== null && typeof rt == "object" && rt.constructor.wordSize === W.wordSize && Array.isArray(rt.words);
      }, W.max = function(rt, Ce) {
        return rt.cmp(Ce) > 0 ? rt : Ce;
      }, W.min = function(rt, Ce) {
        return rt.cmp(Ce) < 0 ? rt : Ce;
      }, W.prototype._init = function(rt, Ce, pe) {
        if (typeof rt == "number")
          return this._initNumber(rt, Ce, pe);
        if (typeof rt == "object")
          return this._initArray(rt, Ce, pe);
        Ce === "hex" && (Ce = 16), K(Ce === (Ce | 0) && Ce >= 2 && Ce <= 36), rt = rt.toString().replace(/\s+/g, "");
        var nt = 0;
        rt[0] === "-" && (nt++, this.negative = 1), nt < rt.length && (Ce === 16 ? this._parseHex(rt, nt, pe) : (this._parseBase(rt, Ce, nt), pe === "le" && this._initArray(this.toArray(), Ce, pe)));
      }, W.prototype._initNumber = function(rt, Ce, pe) {
        rt < 0 && (this.negative = 1, rt = -rt), rt < 67108864 ? (this.words = [rt & 67108863], this.length = 1) : rt < 4503599627370496 ? (this.words = [
          rt & 67108863,
          rt / 67108864 & 67108863
        ], this.length = 2) : (K(rt < 9007199254740992), this.words = [
          rt & 67108863,
          rt / 67108864 & 67108863,
          1
        ], this.length = 3), pe === "le" && this._initArray(this.toArray(), Ce, pe);
      }, W.prototype._initArray = function(rt, Ce, pe) {
        if (K(typeof rt.length == "number"), rt.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(rt.length / 3), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var st, ot, ht = 0;
        if (pe === "be")
          for (nt = rt.length - 1, st = 0; nt >= 0; nt -= 3)
            ot = rt[nt] | rt[nt - 1] << 8 | rt[nt - 2] << 16, this.words[st] |= ot << ht & 67108863, this.words[st + 1] = ot >>> 26 - ht & 67108863, ht += 24, ht >= 26 && (ht -= 26, st++);
        else if (pe === "le")
          for (nt = 0, st = 0; nt < rt.length; nt += 3)
            ot = rt[nt] | rt[nt + 1] << 8 | rt[nt + 2] << 16, this.words[st] |= ot << ht & 67108863, this.words[st + 1] = ot >>> 26 - ht & 67108863, ht += 24, ht >= 26 && (ht -= 26, st++);
        return this.strip();
      };
      function ne(gt, rt) {
        var Ce = gt.charCodeAt(rt);
        return Ce >= 65 && Ce <= 70 ? Ce - 55 : Ce >= 97 && Ce <= 102 ? Ce - 87 : Ce - 48 & 15;
      }
      function ie(gt, rt, Ce) {
        var pe = ne(gt, Ce);
        return Ce - 1 >= rt && (pe |= ne(gt, Ce - 1) << 4), pe;
      }
      W.prototype._parseHex = function(rt, Ce, pe) {
        this.length = Math.ceil((rt.length - Ce) / 6), this.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          this.words[nt] = 0;
        var st = 0, ot = 0, ht;
        if (pe === "be")
          for (nt = rt.length - 1; nt >= Ce; nt -= 2)
            ht = ie(rt, Ce, nt) << st, this.words[ot] |= ht & 67108863, st >= 18 ? (st -= 18, ot += 1, this.words[ot] |= ht >>> 26) : st += 8;
        else {
          var pt = rt.length - Ce;
          for (nt = pt % 2 === 0 ? Ce + 1 : Ce; nt < rt.length; nt += 2)
            ht = ie(rt, Ce, nt) << st, this.words[ot] |= ht & 67108863, st >= 18 ? (st -= 18, ot += 1, this.words[ot] |= ht >>> 26) : st += 8;
        }
        this.strip();
      };
      function ce(gt, rt, Ce, pe) {
        for (var nt = 0, st = Math.min(gt.length, Ce), ot = rt; ot < st; ot++) {
          var ht = gt.charCodeAt(ot) - 48;
          nt *= pe, ht >= 49 ? nt += ht - 49 + 10 : ht >= 17 ? nt += ht - 17 + 10 : nt += ht;
        }
        return nt;
      }
      W.prototype._parseBase = function(rt, Ce, pe) {
        this.words = [0], this.length = 1;
        for (var nt = 0, st = 1; st <= 67108863; st *= Ce)
          nt++;
        nt--, st = st / Ce | 0;
        for (var ot = rt.length - pe, ht = ot % nt, pt = Math.min(ot, ot - ht) + pe, ft = 0, mt = pe; mt < pt; mt += nt)
          ft = ce(rt, mt, mt + nt, Ce), this.imuln(st), this.words[0] + ft < 67108864 ? this.words[0] += ft : this._iaddn(ft);
        if (ht !== 0) {
          var lt = 1;
          for (ft = ce(rt, mt, rt.length, Ce), mt = 0; mt < ht; mt++)
            lt *= Ce;
          this.imuln(lt), this.words[0] + ft < 67108864 ? this.words[0] += ft : this._iaddn(ft);
        }
        this.strip();
      }, W.prototype.copy = function(rt) {
        rt.words = new Array(this.length);
        for (var Ce = 0; Ce < this.length; Ce++)
          rt.words[Ce] = this.words[Ce];
        rt.length = this.length, rt.negative = this.negative, rt.red = this.red;
      }, W.prototype.clone = function() {
        var rt = new W(null);
        return this.copy(rt), rt;
      }, W.prototype._expand = function(rt) {
        for (; this.length < rt; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, W.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var re = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], oe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ke = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(rt, Ce) {
        rt = rt || 10, Ce = Ce | 0 || 1;
        var pe;
        if (rt === 16 || rt === "hex") {
          pe = "";
          for (var nt = 0, st = 0, ot = 0; ot < this.length; ot++) {
            var ht = this.words[ot], pt = ((ht << nt | st) & 16777215).toString(16);
            st = ht >>> 24 - nt & 16777215, nt += 2, nt >= 26 && (nt -= 26, ot--), st !== 0 || ot !== this.length - 1 ? pe = re[6 - pt.length] + pt + pe : pe = pt + pe;
          }
          for (st !== 0 && (pe = st.toString(16) + pe); pe.length % Ce !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        if (rt === (rt | 0) && rt >= 2 && rt <= 36) {
          var ft = oe[rt], mt = ke[rt];
          pe = "";
          var lt = this.clone();
          for (lt.negative = 0; !lt.isZero(); ) {
            var St = lt.modn(mt).toString(rt);
            lt = lt.idivn(mt), lt.isZero() ? pe = St + pe : pe = re[ft - St.length] + St + pe;
          }
          for (this.isZero() && (pe = "0" + pe); pe.length % Ce !== 0; )
            pe = "0" + pe;
          return this.negative !== 0 && (pe = "-" + pe), pe;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var rt = this.words[0];
        return this.length === 2 ? rt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? rt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -rt : rt;
      }, W.prototype.toJSON = function() {
        return this.toString(16);
      }, W.prototype.toBuffer = function(rt, Ce) {
        return K(typeof J < "u"), this.toArrayLike(J, rt, Ce);
      }, W.prototype.toArray = function(rt, Ce) {
        return this.toArrayLike(Array, rt, Ce);
      }, W.prototype.toArrayLike = function(rt, Ce, pe) {
        var nt = this.byteLength(), st = pe || Math.max(1, nt);
        K(nt <= st, "byte array longer than desired length"), K(st > 0, "Requested array length <= 0"), this.strip();
        var ot = Ce === "le", ht = new rt(st), pt, ft, mt = this.clone();
        if (ot) {
          for (ft = 0; !mt.isZero(); ft++)
            pt = mt.andln(255), mt.iushrn(8), ht[ft] = pt;
          for (; ft < st; ft++)
            ht[ft] = 0;
        } else {
          for (ft = 0; ft < st - nt; ft++)
            ht[ft] = 0;
          for (ft = 0; !mt.isZero(); ft++)
            pt = mt.andln(255), mt.iushrn(8), ht[st - ft - 1] = pt;
        }
        return ht;
      }, Math.clz32 ? W.prototype._countBits = function(rt) {
        return 32 - Math.clz32(rt);
      } : W.prototype._countBits = function(rt) {
        var Ce = rt, pe = 0;
        return Ce >= 4096 && (pe += 13, Ce >>>= 13), Ce >= 64 && (pe += 7, Ce >>>= 7), Ce >= 8 && (pe += 4, Ce >>>= 4), Ce >= 2 && (pe += 2, Ce >>>= 2), pe + Ce;
      }, W.prototype._zeroBits = function(rt) {
        if (rt === 0) return 26;
        var Ce = rt, pe = 0;
        return Ce & 8191 || (pe += 13, Ce >>>= 13), Ce & 127 || (pe += 7, Ce >>>= 7), Ce & 15 || (pe += 4, Ce >>>= 4), Ce & 3 || (pe += 2, Ce >>>= 2), Ce & 1 || pe++, pe;
      }, W.prototype.bitLength = function() {
        var rt = this.words[this.length - 1], Ce = this._countBits(rt);
        return (this.length - 1) * 26 + Ce;
      };
      function Oe(gt) {
        for (var rt = new Array(gt.bitLength()), Ce = 0; Ce < rt.length; Ce++) {
          var pe = Ce / 26 | 0, nt = Ce % 26;
          rt[Ce] = (gt.words[pe] & 1 << nt) >>> nt;
        }
        return rt;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var rt = 0, Ce = 0; Ce < this.length; Ce++) {
          var pe = this._zeroBits(this.words[Ce]);
          if (rt += pe, pe !== 26) break;
        }
        return rt;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(rt) {
        return this.negative !== 0 ? this.abs().inotn(rt).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(rt) {
        return this.testn(rt - 1) ? this.notn(rt).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(rt) {
        for (; this.length < rt.length; )
          this.words[this.length++] = 0;
        for (var Ce = 0; Ce < rt.length; Ce++)
          this.words[Ce] = this.words[Ce] | rt.words[Ce];
        return this.strip();
      }, W.prototype.ior = function(rt) {
        return K((this.negative | rt.negative) === 0), this.iuor(rt);
      }, W.prototype.or = function(rt) {
        return this.length > rt.length ? this.clone().ior(rt) : rt.clone().ior(this);
      }, W.prototype.uor = function(rt) {
        return this.length > rt.length ? this.clone().iuor(rt) : rt.clone().iuor(this);
      }, W.prototype.iuand = function(rt) {
        var Ce;
        this.length > rt.length ? Ce = rt : Ce = this;
        for (var pe = 0; pe < Ce.length; pe++)
          this.words[pe] = this.words[pe] & rt.words[pe];
        return this.length = Ce.length, this.strip();
      }, W.prototype.iand = function(rt) {
        return K((this.negative | rt.negative) === 0), this.iuand(rt);
      }, W.prototype.and = function(rt) {
        return this.length > rt.length ? this.clone().iand(rt) : rt.clone().iand(this);
      }, W.prototype.uand = function(rt) {
        return this.length > rt.length ? this.clone().iuand(rt) : rt.clone().iuand(this);
      }, W.prototype.iuxor = function(rt) {
        var Ce, pe;
        this.length > rt.length ? (Ce = this, pe = rt) : (Ce = rt, pe = this);
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = Ce.words[nt] ^ pe.words[nt];
        if (this !== Ce)
          for (; nt < Ce.length; nt++)
            this.words[nt] = Ce.words[nt];
        return this.length = Ce.length, this.strip();
      }, W.prototype.ixor = function(rt) {
        return K((this.negative | rt.negative) === 0), this.iuxor(rt);
      }, W.prototype.xor = function(rt) {
        return this.length > rt.length ? this.clone().ixor(rt) : rt.clone().ixor(this);
      }, W.prototype.uxor = function(rt) {
        return this.length > rt.length ? this.clone().iuxor(rt) : rt.clone().iuxor(this);
      }, W.prototype.inotn = function(rt) {
        K(typeof rt == "number" && rt >= 0);
        var Ce = Math.ceil(rt / 26) | 0, pe = rt % 26;
        this._expand(Ce), pe > 0 && Ce--;
        for (var nt = 0; nt < Ce; nt++)
          this.words[nt] = ~this.words[nt] & 67108863;
        return pe > 0 && (this.words[nt] = ~this.words[nt] & 67108863 >> 26 - pe), this.strip();
      }, W.prototype.notn = function(rt) {
        return this.clone().inotn(rt);
      }, W.prototype.setn = function(rt, Ce) {
        K(typeof rt == "number" && rt >= 0);
        var pe = rt / 26 | 0, nt = rt % 26;
        return this._expand(pe + 1), Ce ? this.words[pe] = this.words[pe] | 1 << nt : this.words[pe] = this.words[pe] & ~(1 << nt), this.strip();
      }, W.prototype.iadd = function(rt) {
        var Ce;
        if (this.negative !== 0 && rt.negative === 0)
          return this.negative = 0, Ce = this.isub(rt), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && rt.negative !== 0)
          return rt.negative = 0, Ce = this.isub(rt), rt.negative = 1, Ce._normSign();
        var pe, nt;
        this.length > rt.length ? (pe = this, nt = rt) : (pe = rt, nt = this);
        for (var st = 0, ot = 0; ot < nt.length; ot++)
          Ce = (pe.words[ot] | 0) + (nt.words[ot] | 0) + st, this.words[ot] = Ce & 67108863, st = Ce >>> 26;
        for (; st !== 0 && ot < pe.length; ot++)
          Ce = (pe.words[ot] | 0) + st, this.words[ot] = Ce & 67108863, st = Ce >>> 26;
        if (this.length = pe.length, st !== 0)
          this.words[this.length] = st, this.length++;
        else if (pe !== this)
          for (; ot < pe.length; ot++)
            this.words[ot] = pe.words[ot];
        return this;
      }, W.prototype.add = function(rt) {
        var Ce;
        return rt.negative !== 0 && this.negative === 0 ? (rt.negative = 0, Ce = this.sub(rt), rt.negative ^= 1, Ce) : rt.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ce = rt.sub(this), this.negative = 1, Ce) : this.length > rt.length ? this.clone().iadd(rt) : rt.clone().iadd(this);
      }, W.prototype.isub = function(rt) {
        if (rt.negative !== 0) {
          rt.negative = 0;
          var Ce = this.iadd(rt);
          return rt.negative = 1, Ce._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(rt), this.negative = 1, this._normSign();
        var pe = this.cmp(rt);
        if (pe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var nt, st;
        pe > 0 ? (nt = this, st = rt) : (nt = rt, st = this);
        for (var ot = 0, ht = 0; ht < st.length; ht++)
          Ce = (nt.words[ht] | 0) - (st.words[ht] | 0) + ot, ot = Ce >> 26, this.words[ht] = Ce & 67108863;
        for (; ot !== 0 && ht < nt.length; ht++)
          Ce = (nt.words[ht] | 0) + ot, ot = Ce >> 26, this.words[ht] = Ce & 67108863;
        if (ot === 0 && ht < nt.length && nt !== this)
          for (; ht < nt.length; ht++)
            this.words[ht] = nt.words[ht];
        return this.length = Math.max(this.length, ht), nt !== this && (this.negative = 1), this.strip();
      }, W.prototype.sub = function(rt) {
        return this.clone().isub(rt);
      };
      function it(gt, rt, Ce) {
        Ce.negative = rt.negative ^ gt.negative;
        var pe = gt.length + rt.length | 0;
        Ce.length = pe, pe = pe - 1 | 0;
        var nt = gt.words[0] | 0, st = rt.words[0] | 0, ot = nt * st, ht = ot & 67108863, pt = ot / 67108864 | 0;
        Ce.words[0] = ht;
        for (var ft = 1; ft < pe; ft++) {
          for (var mt = pt >>> 26, lt = pt & 67108863, St = Math.min(ft, rt.length - 1), Ft = Math.max(0, ft - gt.length + 1); Ft <= St; Ft++) {
            var Gt = ft - Ft | 0;
            nt = gt.words[Gt] | 0, st = rt.words[Ft] | 0, ot = nt * st + lt, mt += ot / 67108864 | 0, lt = ot & 67108863;
          }
          Ce.words[ft] = lt | 0, pt = mt | 0;
        }
        return pt !== 0 ? Ce.words[ft] = pt | 0 : Ce.length--, Ce.strip();
      }
      var at = function(rt, Ce, pe) {
        var nt = rt.words, st = Ce.words, ot = pe.words, ht = 0, pt, ft, mt, lt = nt[0] | 0, St = lt & 8191, Ft = lt >>> 13, Gt = nt[1] | 0, qt = Gt & 8191, Pt = Gt >>> 13, Tt = nt[2] | 0, Ut = Tt & 8191, Wt = Tt >>> 13, It = nt[3] | 0, Rt = It & 8191, jt = It >>> 13, Jt = nt[4] | 0, er = Jt & 8191, nr = Jt >>> 13, fr = nt[5] | 0, lr = fr & 8191, Yt = fr >>> 13, Pr = nt[6] | 0, or = Pr & 8191, Ar = Pr >>> 13, Br = nt[7] | 0, cr = Br & 8191, xr = Br >>> 13, Ir = nt[8] | 0, gr = Ir & 8191, Rr = Ir >>> 13, Or = nt[9] | 0, Mt = Or & 8191, wt = Or >>> 13, Et = st[0] | 0, Ct = Et & 8191, Kt = Et >>> 13, Vt = st[1] | 0, zt = Vt & 8191, yr = Vt >>> 13, $r = st[2] | 0, hr = $r & 8191, Er = $r >>> 13, Sr = st[3] | 0, wr = Sr & 8191, Mr = Sr >>> 13, Cr = st[4] | 0, Lt = Cr & 8191, kt = Cr >>> 13, Dt = st[5] | 0, Ht = Dt & 8191, Xt = Dt >>> 13, Zt = st[6] | 0, tr = Zt & 8191, ir = Zt >>> 13, ur = st[7] | 0, sr = ur & 8191, dr = ur >>> 13, vr = st[8] | 0, Nt = vr & 8191, Qt = vr >>> 13, rr = st[9] | 0, ar = rr & 8191, br = rr >>> 13;
        pe.negative = rt.negative ^ Ce.negative, pe.length = 19, pt = Math.imul(St, Ct), ft = Math.imul(St, Kt), ft = ft + Math.imul(Ft, Ct) | 0, mt = Math.imul(Ft, Kt);
        var _r = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (_r >>> 26) | 0, _r &= 67108863, pt = Math.imul(qt, Ct), ft = Math.imul(qt, Kt), ft = ft + Math.imul(Pt, Ct) | 0, mt = Math.imul(Pt, Kt), pt = pt + Math.imul(St, zt) | 0, ft = ft + Math.imul(St, yr) | 0, ft = ft + Math.imul(Ft, zt) | 0, mt = mt + Math.imul(Ft, yr) | 0;
        var pr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (pr >>> 26) | 0, pr &= 67108863, pt = Math.imul(Ut, Ct), ft = Math.imul(Ut, Kt), ft = ft + Math.imul(Wt, Ct) | 0, mt = Math.imul(Wt, Kt), pt = pt + Math.imul(qt, zt) | 0, ft = ft + Math.imul(qt, yr) | 0, ft = ft + Math.imul(Pt, zt) | 0, mt = mt + Math.imul(Pt, yr) | 0, pt = pt + Math.imul(St, hr) | 0, ft = ft + Math.imul(St, Er) | 0, ft = ft + Math.imul(Ft, hr) | 0, mt = mt + Math.imul(Ft, Er) | 0;
        var Tr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, pt = Math.imul(Rt, Ct), ft = Math.imul(Rt, Kt), ft = ft + Math.imul(jt, Ct) | 0, mt = Math.imul(jt, Kt), pt = pt + Math.imul(Ut, zt) | 0, ft = ft + Math.imul(Ut, yr) | 0, ft = ft + Math.imul(Wt, zt) | 0, mt = mt + Math.imul(Wt, yr) | 0, pt = pt + Math.imul(qt, hr) | 0, ft = ft + Math.imul(qt, Er) | 0, ft = ft + Math.imul(Pt, hr) | 0, mt = mt + Math.imul(Pt, Er) | 0, pt = pt + Math.imul(St, wr) | 0, ft = ft + Math.imul(St, Mr) | 0, ft = ft + Math.imul(Ft, wr) | 0, mt = mt + Math.imul(Ft, Mr) | 0;
        var Nr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, pt = Math.imul(er, Ct), ft = Math.imul(er, Kt), ft = ft + Math.imul(nr, Ct) | 0, mt = Math.imul(nr, Kt), pt = pt + Math.imul(Rt, zt) | 0, ft = ft + Math.imul(Rt, yr) | 0, ft = ft + Math.imul(jt, zt) | 0, mt = mt + Math.imul(jt, yr) | 0, pt = pt + Math.imul(Ut, hr) | 0, ft = ft + Math.imul(Ut, Er) | 0, ft = ft + Math.imul(Wt, hr) | 0, mt = mt + Math.imul(Wt, Er) | 0, pt = pt + Math.imul(qt, wr) | 0, ft = ft + Math.imul(qt, Mr) | 0, ft = ft + Math.imul(Pt, wr) | 0, mt = mt + Math.imul(Pt, Mr) | 0, pt = pt + Math.imul(St, Lt) | 0, ft = ft + Math.imul(St, kt) | 0, ft = ft + Math.imul(Ft, Lt) | 0, mt = mt + Math.imul(Ft, kt) | 0;
        var kr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, pt = Math.imul(lr, Ct), ft = Math.imul(lr, Kt), ft = ft + Math.imul(Yt, Ct) | 0, mt = Math.imul(Yt, Kt), pt = pt + Math.imul(er, zt) | 0, ft = ft + Math.imul(er, yr) | 0, ft = ft + Math.imul(nr, zt) | 0, mt = mt + Math.imul(nr, yr) | 0, pt = pt + Math.imul(Rt, hr) | 0, ft = ft + Math.imul(Rt, Er) | 0, ft = ft + Math.imul(jt, hr) | 0, mt = mt + Math.imul(jt, Er) | 0, pt = pt + Math.imul(Ut, wr) | 0, ft = ft + Math.imul(Ut, Mr) | 0, ft = ft + Math.imul(Wt, wr) | 0, mt = mt + Math.imul(Wt, Mr) | 0, pt = pt + Math.imul(qt, Lt) | 0, ft = ft + Math.imul(qt, kt) | 0, ft = ft + Math.imul(Pt, Lt) | 0, mt = mt + Math.imul(Pt, kt) | 0, pt = pt + Math.imul(St, Ht) | 0, ft = ft + Math.imul(St, Xt) | 0, ft = ft + Math.imul(Ft, Ht) | 0, mt = mt + Math.imul(Ft, Xt) | 0;
        var qr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, pt = Math.imul(or, Ct), ft = Math.imul(or, Kt), ft = ft + Math.imul(Ar, Ct) | 0, mt = Math.imul(Ar, Kt), pt = pt + Math.imul(lr, zt) | 0, ft = ft + Math.imul(lr, yr) | 0, ft = ft + Math.imul(Yt, zt) | 0, mt = mt + Math.imul(Yt, yr) | 0, pt = pt + Math.imul(er, hr) | 0, ft = ft + Math.imul(er, Er) | 0, ft = ft + Math.imul(nr, hr) | 0, mt = mt + Math.imul(nr, Er) | 0, pt = pt + Math.imul(Rt, wr) | 0, ft = ft + Math.imul(Rt, Mr) | 0, ft = ft + Math.imul(jt, wr) | 0, mt = mt + Math.imul(jt, Mr) | 0, pt = pt + Math.imul(Ut, Lt) | 0, ft = ft + Math.imul(Ut, kt) | 0, ft = ft + Math.imul(Wt, Lt) | 0, mt = mt + Math.imul(Wt, kt) | 0, pt = pt + Math.imul(qt, Ht) | 0, ft = ft + Math.imul(qt, Xt) | 0, ft = ft + Math.imul(Pt, Ht) | 0, mt = mt + Math.imul(Pt, Xt) | 0, pt = pt + Math.imul(St, tr) | 0, ft = ft + Math.imul(St, ir) | 0, ft = ft + Math.imul(Ft, tr) | 0, mt = mt + Math.imul(Ft, ir) | 0;
        var Lr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, pt = Math.imul(cr, Ct), ft = Math.imul(cr, Kt), ft = ft + Math.imul(xr, Ct) | 0, mt = Math.imul(xr, Kt), pt = pt + Math.imul(or, zt) | 0, ft = ft + Math.imul(or, yr) | 0, ft = ft + Math.imul(Ar, zt) | 0, mt = mt + Math.imul(Ar, yr) | 0, pt = pt + Math.imul(lr, hr) | 0, ft = ft + Math.imul(lr, Er) | 0, ft = ft + Math.imul(Yt, hr) | 0, mt = mt + Math.imul(Yt, Er) | 0, pt = pt + Math.imul(er, wr) | 0, ft = ft + Math.imul(er, Mr) | 0, ft = ft + Math.imul(nr, wr) | 0, mt = mt + Math.imul(nr, Mr) | 0, pt = pt + Math.imul(Rt, Lt) | 0, ft = ft + Math.imul(Rt, kt) | 0, ft = ft + Math.imul(jt, Lt) | 0, mt = mt + Math.imul(jt, kt) | 0, pt = pt + Math.imul(Ut, Ht) | 0, ft = ft + Math.imul(Ut, Xt) | 0, ft = ft + Math.imul(Wt, Ht) | 0, mt = mt + Math.imul(Wt, Xt) | 0, pt = pt + Math.imul(qt, tr) | 0, ft = ft + Math.imul(qt, ir) | 0, ft = ft + Math.imul(Pt, tr) | 0, mt = mt + Math.imul(Pt, ir) | 0, pt = pt + Math.imul(St, sr) | 0, ft = ft + Math.imul(St, dr) | 0, ft = ft + Math.imul(Ft, sr) | 0, mt = mt + Math.imul(Ft, dr) | 0;
        var Dr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, pt = Math.imul(gr, Ct), ft = Math.imul(gr, Kt), ft = ft + Math.imul(Rr, Ct) | 0, mt = Math.imul(Rr, Kt), pt = pt + Math.imul(cr, zt) | 0, ft = ft + Math.imul(cr, yr) | 0, ft = ft + Math.imul(xr, zt) | 0, mt = mt + Math.imul(xr, yr) | 0, pt = pt + Math.imul(or, hr) | 0, ft = ft + Math.imul(or, Er) | 0, ft = ft + Math.imul(Ar, hr) | 0, mt = mt + Math.imul(Ar, Er) | 0, pt = pt + Math.imul(lr, wr) | 0, ft = ft + Math.imul(lr, Mr) | 0, ft = ft + Math.imul(Yt, wr) | 0, mt = mt + Math.imul(Yt, Mr) | 0, pt = pt + Math.imul(er, Lt) | 0, ft = ft + Math.imul(er, kt) | 0, ft = ft + Math.imul(nr, Lt) | 0, mt = mt + Math.imul(nr, kt) | 0, pt = pt + Math.imul(Rt, Ht) | 0, ft = ft + Math.imul(Rt, Xt) | 0, ft = ft + Math.imul(jt, Ht) | 0, mt = mt + Math.imul(jt, Xt) | 0, pt = pt + Math.imul(Ut, tr) | 0, ft = ft + Math.imul(Ut, ir) | 0, ft = ft + Math.imul(Wt, tr) | 0, mt = mt + Math.imul(Wt, ir) | 0, pt = pt + Math.imul(qt, sr) | 0, ft = ft + Math.imul(qt, dr) | 0, ft = ft + Math.imul(Pt, sr) | 0, mt = mt + Math.imul(Pt, dr) | 0, pt = pt + Math.imul(St, Nt) | 0, ft = ft + Math.imul(St, Qt) | 0, ft = ft + Math.imul(Ft, Nt) | 0, mt = mt + Math.imul(Ft, Qt) | 0;
        var Ur = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, pt = Math.imul(Mt, Ct), ft = Math.imul(Mt, Kt), ft = ft + Math.imul(wt, Ct) | 0, mt = Math.imul(wt, Kt), pt = pt + Math.imul(gr, zt) | 0, ft = ft + Math.imul(gr, yr) | 0, ft = ft + Math.imul(Rr, zt) | 0, mt = mt + Math.imul(Rr, yr) | 0, pt = pt + Math.imul(cr, hr) | 0, ft = ft + Math.imul(cr, Er) | 0, ft = ft + Math.imul(xr, hr) | 0, mt = mt + Math.imul(xr, Er) | 0, pt = pt + Math.imul(or, wr) | 0, ft = ft + Math.imul(or, Mr) | 0, ft = ft + Math.imul(Ar, wr) | 0, mt = mt + Math.imul(Ar, Mr) | 0, pt = pt + Math.imul(lr, Lt) | 0, ft = ft + Math.imul(lr, kt) | 0, ft = ft + Math.imul(Yt, Lt) | 0, mt = mt + Math.imul(Yt, kt) | 0, pt = pt + Math.imul(er, Ht) | 0, ft = ft + Math.imul(er, Xt) | 0, ft = ft + Math.imul(nr, Ht) | 0, mt = mt + Math.imul(nr, Xt) | 0, pt = pt + Math.imul(Rt, tr) | 0, ft = ft + Math.imul(Rt, ir) | 0, ft = ft + Math.imul(jt, tr) | 0, mt = mt + Math.imul(jt, ir) | 0, pt = pt + Math.imul(Ut, sr) | 0, ft = ft + Math.imul(Ut, dr) | 0, ft = ft + Math.imul(Wt, sr) | 0, mt = mt + Math.imul(Wt, dr) | 0, pt = pt + Math.imul(qt, Nt) | 0, ft = ft + Math.imul(qt, Qt) | 0, ft = ft + Math.imul(Pt, Nt) | 0, mt = mt + Math.imul(Pt, Qt) | 0, pt = pt + Math.imul(St, ar) | 0, ft = ft + Math.imul(St, br) | 0, ft = ft + Math.imul(Ft, ar) | 0, mt = mt + Math.imul(Ft, br) | 0;
        var Fr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, pt = Math.imul(Mt, zt), ft = Math.imul(Mt, yr), ft = ft + Math.imul(wt, zt) | 0, mt = Math.imul(wt, yr), pt = pt + Math.imul(gr, hr) | 0, ft = ft + Math.imul(gr, Er) | 0, ft = ft + Math.imul(Rr, hr) | 0, mt = mt + Math.imul(Rr, Er) | 0, pt = pt + Math.imul(cr, wr) | 0, ft = ft + Math.imul(cr, Mr) | 0, ft = ft + Math.imul(xr, wr) | 0, mt = mt + Math.imul(xr, Mr) | 0, pt = pt + Math.imul(or, Lt) | 0, ft = ft + Math.imul(or, kt) | 0, ft = ft + Math.imul(Ar, Lt) | 0, mt = mt + Math.imul(Ar, kt) | 0, pt = pt + Math.imul(lr, Ht) | 0, ft = ft + Math.imul(lr, Xt) | 0, ft = ft + Math.imul(Yt, Ht) | 0, mt = mt + Math.imul(Yt, Xt) | 0, pt = pt + Math.imul(er, tr) | 0, ft = ft + Math.imul(er, ir) | 0, ft = ft + Math.imul(nr, tr) | 0, mt = mt + Math.imul(nr, ir) | 0, pt = pt + Math.imul(Rt, sr) | 0, ft = ft + Math.imul(Rt, dr) | 0, ft = ft + Math.imul(jt, sr) | 0, mt = mt + Math.imul(jt, dr) | 0, pt = pt + Math.imul(Ut, Nt) | 0, ft = ft + Math.imul(Ut, Qt) | 0, ft = ft + Math.imul(Wt, Nt) | 0, mt = mt + Math.imul(Wt, Qt) | 0, pt = pt + Math.imul(qt, ar) | 0, ft = ft + Math.imul(qt, br) | 0, ft = ft + Math.imul(Pt, ar) | 0, mt = mt + Math.imul(Pt, br) | 0;
        var jr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, pt = Math.imul(Mt, hr), ft = Math.imul(Mt, Er), ft = ft + Math.imul(wt, hr) | 0, mt = Math.imul(wt, Er), pt = pt + Math.imul(gr, wr) | 0, ft = ft + Math.imul(gr, Mr) | 0, ft = ft + Math.imul(Rr, wr) | 0, mt = mt + Math.imul(Rr, Mr) | 0, pt = pt + Math.imul(cr, Lt) | 0, ft = ft + Math.imul(cr, kt) | 0, ft = ft + Math.imul(xr, Lt) | 0, mt = mt + Math.imul(xr, kt) | 0, pt = pt + Math.imul(or, Ht) | 0, ft = ft + Math.imul(or, Xt) | 0, ft = ft + Math.imul(Ar, Ht) | 0, mt = mt + Math.imul(Ar, Xt) | 0, pt = pt + Math.imul(lr, tr) | 0, ft = ft + Math.imul(lr, ir) | 0, ft = ft + Math.imul(Yt, tr) | 0, mt = mt + Math.imul(Yt, ir) | 0, pt = pt + Math.imul(er, sr) | 0, ft = ft + Math.imul(er, dr) | 0, ft = ft + Math.imul(nr, sr) | 0, mt = mt + Math.imul(nr, dr) | 0, pt = pt + Math.imul(Rt, Nt) | 0, ft = ft + Math.imul(Rt, Qt) | 0, ft = ft + Math.imul(jt, Nt) | 0, mt = mt + Math.imul(jt, Qt) | 0, pt = pt + Math.imul(Ut, ar) | 0, ft = ft + Math.imul(Ut, br) | 0, ft = ft + Math.imul(Wt, ar) | 0, mt = mt + Math.imul(Wt, br) | 0;
        var Hr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, pt = Math.imul(Mt, wr), ft = Math.imul(Mt, Mr), ft = ft + Math.imul(wt, wr) | 0, mt = Math.imul(wt, Mr), pt = pt + Math.imul(gr, Lt) | 0, ft = ft + Math.imul(gr, kt) | 0, ft = ft + Math.imul(Rr, Lt) | 0, mt = mt + Math.imul(Rr, kt) | 0, pt = pt + Math.imul(cr, Ht) | 0, ft = ft + Math.imul(cr, Xt) | 0, ft = ft + Math.imul(xr, Ht) | 0, mt = mt + Math.imul(xr, Xt) | 0, pt = pt + Math.imul(or, tr) | 0, ft = ft + Math.imul(or, ir) | 0, ft = ft + Math.imul(Ar, tr) | 0, mt = mt + Math.imul(Ar, ir) | 0, pt = pt + Math.imul(lr, sr) | 0, ft = ft + Math.imul(lr, dr) | 0, ft = ft + Math.imul(Yt, sr) | 0, mt = mt + Math.imul(Yt, dr) | 0, pt = pt + Math.imul(er, Nt) | 0, ft = ft + Math.imul(er, Qt) | 0, ft = ft + Math.imul(nr, Nt) | 0, mt = mt + Math.imul(nr, Qt) | 0, pt = pt + Math.imul(Rt, ar) | 0, ft = ft + Math.imul(Rt, br) | 0, ft = ft + Math.imul(jt, ar) | 0, mt = mt + Math.imul(jt, br) | 0;
        var Wr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, pt = Math.imul(Mt, Lt), ft = Math.imul(Mt, kt), ft = ft + Math.imul(wt, Lt) | 0, mt = Math.imul(wt, kt), pt = pt + Math.imul(gr, Ht) | 0, ft = ft + Math.imul(gr, Xt) | 0, ft = ft + Math.imul(Rr, Ht) | 0, mt = mt + Math.imul(Rr, Xt) | 0, pt = pt + Math.imul(cr, tr) | 0, ft = ft + Math.imul(cr, ir) | 0, ft = ft + Math.imul(xr, tr) | 0, mt = mt + Math.imul(xr, ir) | 0, pt = pt + Math.imul(or, sr) | 0, ft = ft + Math.imul(or, dr) | 0, ft = ft + Math.imul(Ar, sr) | 0, mt = mt + Math.imul(Ar, dr) | 0, pt = pt + Math.imul(lr, Nt) | 0, ft = ft + Math.imul(lr, Qt) | 0, ft = ft + Math.imul(Yt, Nt) | 0, mt = mt + Math.imul(Yt, Qt) | 0, pt = pt + Math.imul(er, ar) | 0, ft = ft + Math.imul(er, br) | 0, ft = ft + Math.imul(nr, ar) | 0, mt = mt + Math.imul(nr, br) | 0;
        var Gr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, pt = Math.imul(Mt, Ht), ft = Math.imul(Mt, Xt), ft = ft + Math.imul(wt, Ht) | 0, mt = Math.imul(wt, Xt), pt = pt + Math.imul(gr, tr) | 0, ft = ft + Math.imul(gr, ir) | 0, ft = ft + Math.imul(Rr, tr) | 0, mt = mt + Math.imul(Rr, ir) | 0, pt = pt + Math.imul(cr, sr) | 0, ft = ft + Math.imul(cr, dr) | 0, ft = ft + Math.imul(xr, sr) | 0, mt = mt + Math.imul(xr, dr) | 0, pt = pt + Math.imul(or, Nt) | 0, ft = ft + Math.imul(or, Qt) | 0, ft = ft + Math.imul(Ar, Nt) | 0, mt = mt + Math.imul(Ar, Qt) | 0, pt = pt + Math.imul(lr, ar) | 0, ft = ft + Math.imul(lr, br) | 0, ft = ft + Math.imul(Yt, ar) | 0, mt = mt + Math.imul(Yt, br) | 0;
        var Vr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, pt = Math.imul(Mt, tr), ft = Math.imul(Mt, ir), ft = ft + Math.imul(wt, tr) | 0, mt = Math.imul(wt, ir), pt = pt + Math.imul(gr, sr) | 0, ft = ft + Math.imul(gr, dr) | 0, ft = ft + Math.imul(Rr, sr) | 0, mt = mt + Math.imul(Rr, dr) | 0, pt = pt + Math.imul(cr, Nt) | 0, ft = ft + Math.imul(cr, Qt) | 0, ft = ft + Math.imul(xr, Nt) | 0, mt = mt + Math.imul(xr, Qt) | 0, pt = pt + Math.imul(or, ar) | 0, ft = ft + Math.imul(or, br) | 0, ft = ft + Math.imul(Ar, ar) | 0, mt = mt + Math.imul(Ar, br) | 0;
        var zr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, pt = Math.imul(Mt, sr), ft = Math.imul(Mt, dr), ft = ft + Math.imul(wt, sr) | 0, mt = Math.imul(wt, dr), pt = pt + Math.imul(gr, Nt) | 0, ft = ft + Math.imul(gr, Qt) | 0, ft = ft + Math.imul(Rr, Nt) | 0, mt = mt + Math.imul(Rr, Qt) | 0, pt = pt + Math.imul(cr, ar) | 0, ft = ft + Math.imul(cr, br) | 0, ft = ft + Math.imul(xr, ar) | 0, mt = mt + Math.imul(xr, br) | 0;
        var Xr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, pt = Math.imul(Mt, Nt), ft = Math.imul(Mt, Qt), ft = ft + Math.imul(wt, Nt) | 0, mt = Math.imul(wt, Qt), pt = pt + Math.imul(gr, ar) | 0, ft = ft + Math.imul(gr, br) | 0, ft = ft + Math.imul(Rr, ar) | 0, mt = mt + Math.imul(Rr, br) | 0;
        var Yr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        ht = (mt + (ft >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, pt = Math.imul(Mt, ar), ft = Math.imul(Mt, br), ft = ft + Math.imul(wt, ar) | 0, mt = Math.imul(wt, br);
        var Jr = (ht + pt | 0) + ((ft & 8191) << 13) | 0;
        return ht = (mt + (ft >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, ot[0] = _r, ot[1] = pr, ot[2] = Tr, ot[3] = Nr, ot[4] = kr, ot[5] = qr, ot[6] = Lr, ot[7] = Dr, ot[8] = Ur, ot[9] = Fr, ot[10] = jr, ot[11] = Hr, ot[12] = Wr, ot[13] = Gr, ot[14] = Vr, ot[15] = zr, ot[16] = Xr, ot[17] = Yr, ot[18] = Jr, ht !== 0 && (ot[19] = ht, pe.length++), pe;
      };
      Math.imul || (at = it);
      function ut(gt, rt, Ce) {
        Ce.negative = rt.negative ^ gt.negative, Ce.length = gt.length + rt.length;
        for (var pe = 0, nt = 0, st = 0; st < Ce.length - 1; st++) {
          var ot = nt;
          nt = 0;
          for (var ht = pe & 67108863, pt = Math.min(st, rt.length - 1), ft = Math.max(0, st - gt.length + 1); ft <= pt; ft++) {
            var mt = st - ft, lt = gt.words[mt] | 0, St = rt.words[ft] | 0, Ft = lt * St, Gt = Ft & 67108863;
            ot = ot + (Ft / 67108864 | 0) | 0, Gt = Gt + ht | 0, ht = Gt & 67108863, ot = ot + (Gt >>> 26) | 0, nt += ot >>> 26, ot &= 67108863;
          }
          Ce.words[st] = ht, pe = ot, ot = nt;
        }
        return pe !== 0 ? Ce.words[st] = pe : Ce.length--, Ce.strip();
      }
      function dt(gt, rt, Ce) {
        var pe = new ct();
        return pe.mulp(gt, rt, Ce);
      }
      W.prototype.mulTo = function(rt, Ce) {
        var pe, nt = this.length + rt.length;
        return this.length === 10 && rt.length === 10 ? pe = at(this, rt, Ce) : nt < 63 ? pe = it(this, rt, Ce) : nt < 1024 ? pe = ut(this, rt, Ce) : pe = dt(this, rt, Ce), pe;
      };
      function ct(gt, rt) {
        this.x = gt, this.y = rt;
      }
      ct.prototype.makeRBT = function(rt) {
        for (var Ce = new Array(rt), pe = W.prototype._countBits(rt) - 1, nt = 0; nt < rt; nt++)
          Ce[nt] = this.revBin(nt, pe, rt);
        return Ce;
      }, ct.prototype.revBin = function(rt, Ce, pe) {
        if (rt === 0 || rt === pe - 1) return rt;
        for (var nt = 0, st = 0; st < Ce; st++)
          nt |= (rt & 1) << Ce - st - 1, rt >>= 1;
        return nt;
      }, ct.prototype.permute = function(rt, Ce, pe, nt, st, ot) {
        for (var ht = 0; ht < ot; ht++)
          nt[ht] = Ce[rt[ht]], st[ht] = pe[rt[ht]];
      }, ct.prototype.transform = function(rt, Ce, pe, nt, st, ot) {
        this.permute(ot, rt, Ce, pe, nt, st);
        for (var ht = 1; ht < st; ht <<= 1)
          for (var pt = ht << 1, ft = Math.cos(2 * Math.PI / pt), mt = Math.sin(2 * Math.PI / pt), lt = 0; lt < st; lt += pt)
            for (var St = ft, Ft = mt, Gt = 0; Gt < ht; Gt++) {
              var qt = pe[lt + Gt], Pt = nt[lt + Gt], Tt = pe[lt + Gt + ht], Ut = nt[lt + Gt + ht], Wt = St * Tt - Ft * Ut;
              Ut = St * Ut + Ft * Tt, Tt = Wt, pe[lt + Gt] = qt + Tt, nt[lt + Gt] = Pt + Ut, pe[lt + Gt + ht] = qt - Tt, nt[lt + Gt + ht] = Pt - Ut, Gt !== pt && (Wt = ft * St - mt * Ft, Ft = ft * Ft + mt * St, St = Wt);
            }
      }, ct.prototype.guessLen13b = function(rt, Ce) {
        var pe = Math.max(Ce, rt) | 1, nt = pe & 1, st = 0;
        for (pe = pe / 2 | 0; pe; pe = pe >>> 1)
          st++;
        return 1 << st + 1 + nt;
      }, ct.prototype.conjugate = function(rt, Ce, pe) {
        if (!(pe <= 1))
          for (var nt = 0; nt < pe / 2; nt++) {
            var st = rt[nt];
            rt[nt] = rt[pe - nt - 1], rt[pe - nt - 1] = st, st = Ce[nt], Ce[nt] = -Ce[pe - nt - 1], Ce[pe - nt - 1] = -st;
          }
      }, ct.prototype.normalize13b = function(rt, Ce) {
        for (var pe = 0, nt = 0; nt < Ce / 2; nt++) {
          var st = Math.round(rt[2 * nt + 1] / Ce) * 8192 + Math.round(rt[2 * nt] / Ce) + pe;
          rt[nt] = st & 67108863, st < 67108864 ? pe = 0 : pe = st / 67108864 | 0;
        }
        return rt;
      }, ct.prototype.convert13b = function(rt, Ce, pe, nt) {
        for (var st = 0, ot = 0; ot < Ce; ot++)
          st = st + (rt[ot] | 0), pe[2 * ot] = st & 8191, st = st >>> 13, pe[2 * ot + 1] = st & 8191, st = st >>> 13;
        for (ot = 2 * Ce; ot < nt; ++ot)
          pe[ot] = 0;
        K(st === 0), K((st & -8192) === 0);
      }, ct.prototype.stub = function(rt) {
        for (var Ce = new Array(rt), pe = 0; pe < rt; pe++)
          Ce[pe] = 0;
        return Ce;
      }, ct.prototype.mulp = function(rt, Ce, pe) {
        var nt = 2 * this.guessLen13b(rt.length, Ce.length), st = this.makeRBT(nt), ot = this.stub(nt), ht = new Array(nt), pt = new Array(nt), ft = new Array(nt), mt = new Array(nt), lt = new Array(nt), St = new Array(nt), Ft = pe.words;
        Ft.length = nt, this.convert13b(rt.words, rt.length, ht, nt), this.convert13b(Ce.words, Ce.length, mt, nt), this.transform(ht, ot, pt, ft, nt, st), this.transform(mt, ot, lt, St, nt, st);
        for (var Gt = 0; Gt < nt; Gt++) {
          var qt = pt[Gt] * lt[Gt] - ft[Gt] * St[Gt];
          ft[Gt] = pt[Gt] * St[Gt] + ft[Gt] * lt[Gt], pt[Gt] = qt;
        }
        return this.conjugate(pt, ft, nt), this.transform(pt, ft, Ft, ot, nt, st), this.conjugate(Ft, ot, nt), this.normalize13b(Ft, nt), pe.negative = rt.negative ^ Ce.negative, pe.length = rt.length + Ce.length, pe.strip();
      }, W.prototype.mul = function(rt) {
        var Ce = new W(null);
        return Ce.words = new Array(this.length + rt.length), this.mulTo(rt, Ce);
      }, W.prototype.mulf = function(rt) {
        var Ce = new W(null);
        return Ce.words = new Array(this.length + rt.length), dt(this, rt, Ce);
      }, W.prototype.imul = function(rt) {
        return this.clone().mulTo(rt, this);
      }, W.prototype.imuln = function(rt) {
        K(typeof rt == "number"), K(rt < 67108864);
        for (var Ce = 0, pe = 0; pe < this.length; pe++) {
          var nt = (this.words[pe] | 0) * rt, st = (nt & 67108863) + (Ce & 67108863);
          Ce >>= 26, Ce += nt / 67108864 | 0, Ce += st >>> 26, this.words[pe] = st & 67108863;
        }
        return Ce !== 0 && (this.words[pe] = Ce, this.length++), this;
      }, W.prototype.muln = function(rt) {
        return this.clone().imuln(rt);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(rt) {
        var Ce = Oe(rt);
        if (Ce.length === 0) return new W(1);
        for (var pe = this, nt = 0; nt < Ce.length && Ce[nt] === 0; nt++, pe = pe.sqr())
          ;
        if (++nt < Ce.length)
          for (var st = pe.sqr(); nt < Ce.length; nt++, st = st.sqr())
            Ce[nt] !== 0 && (pe = pe.mul(st));
        return pe;
      }, W.prototype.iushln = function(rt) {
        K(typeof rt == "number" && rt >= 0);
        var Ce = rt % 26, pe = (rt - Ce) / 26, nt = 67108863 >>> 26 - Ce << 26 - Ce, st;
        if (Ce !== 0) {
          var ot = 0;
          for (st = 0; st < this.length; st++) {
            var ht = this.words[st] & nt, pt = (this.words[st] | 0) - ht << Ce;
            this.words[st] = pt | ot, ot = ht >>> 26 - Ce;
          }
          ot && (this.words[st] = ot, this.length++);
        }
        if (pe !== 0) {
          for (st = this.length - 1; st >= 0; st--)
            this.words[st + pe] = this.words[st];
          for (st = 0; st < pe; st++)
            this.words[st] = 0;
          this.length += pe;
        }
        return this.strip();
      }, W.prototype.ishln = function(rt) {
        return K(this.negative === 0), this.iushln(rt);
      }, W.prototype.iushrn = function(rt, Ce, pe) {
        K(typeof rt == "number" && rt >= 0);
        var nt;
        Ce ? nt = (Ce - Ce % 26) / 26 : nt = 0;
        var st = rt % 26, ot = Math.min((rt - st) / 26, this.length), ht = 67108863 ^ 67108863 >>> st << st, pt = pe;
        if (nt -= ot, nt = Math.max(0, nt), pt) {
          for (var ft = 0; ft < ot; ft++)
            pt.words[ft] = this.words[ft];
          pt.length = ot;
        }
        if (ot !== 0) if (this.length > ot)
          for (this.length -= ot, ft = 0; ft < this.length; ft++)
            this.words[ft] = this.words[ft + ot];
        else
          this.words[0] = 0, this.length = 1;
        var mt = 0;
        for (ft = this.length - 1; ft >= 0 && (mt !== 0 || ft >= nt); ft--) {
          var lt = this.words[ft] | 0;
          this.words[ft] = mt << 26 - st | lt >>> st, mt = lt & ht;
        }
        return pt && mt !== 0 && (pt.words[pt.length++] = mt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, W.prototype.ishrn = function(rt, Ce, pe) {
        return K(this.negative === 0), this.iushrn(rt, Ce, pe);
      }, W.prototype.shln = function(rt) {
        return this.clone().ishln(rt);
      }, W.prototype.ushln = function(rt) {
        return this.clone().iushln(rt);
      }, W.prototype.shrn = function(rt) {
        return this.clone().ishrn(rt);
      }, W.prototype.ushrn = function(rt) {
        return this.clone().iushrn(rt);
      }, W.prototype.testn = function(rt) {
        K(typeof rt == "number" && rt >= 0);
        var Ce = rt % 26, pe = (rt - Ce) / 26, nt = 1 << Ce;
        if (this.length <= pe) return !1;
        var st = this.words[pe];
        return !!(st & nt);
      }, W.prototype.imaskn = function(rt) {
        K(typeof rt == "number" && rt >= 0);
        var Ce = rt % 26, pe = (rt - Ce) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= pe)
          return this;
        if (Ce !== 0 && pe++, this.length = Math.min(pe, this.length), Ce !== 0) {
          var nt = 67108863 ^ 67108863 >>> Ce << Ce;
          this.words[this.length - 1] &= nt;
        }
        return this.strip();
      }, W.prototype.maskn = function(rt) {
        return this.clone().imaskn(rt);
      }, W.prototype.iaddn = function(rt) {
        return K(typeof rt == "number"), K(rt < 67108864), rt < 0 ? this.isubn(-rt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < rt ? (this.words[0] = rt - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(rt), this.negative = 1, this) : this._iaddn(rt);
      }, W.prototype._iaddn = function(rt) {
        this.words[0] += rt;
        for (var Ce = 0; Ce < this.length && this.words[Ce] >= 67108864; Ce++)
          this.words[Ce] -= 67108864, Ce === this.length - 1 ? this.words[Ce + 1] = 1 : this.words[Ce + 1]++;
        return this.length = Math.max(this.length, Ce + 1), this;
      }, W.prototype.isubn = function(rt) {
        if (K(typeof rt == "number"), K(rt < 67108864), rt < 0) return this.iaddn(-rt);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(rt), this.negative = 1, this;
        if (this.words[0] -= rt, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Ce = 0; Ce < this.length && this.words[Ce] < 0; Ce++)
            this.words[Ce] += 67108864, this.words[Ce + 1] -= 1;
        return this.strip();
      }, W.prototype.addn = function(rt) {
        return this.clone().iaddn(rt);
      }, W.prototype.subn = function(rt) {
        return this.clone().isubn(rt);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(rt, Ce, pe) {
        var nt = rt.length + pe, st;
        this._expand(nt);
        var ot, ht = 0;
        for (st = 0; st < rt.length; st++) {
          ot = (this.words[st + pe] | 0) + ht;
          var pt = (rt.words[st] | 0) * Ce;
          ot -= pt & 67108863, ht = (ot >> 26) - (pt / 67108864 | 0), this.words[st + pe] = ot & 67108863;
        }
        for (; st < this.length - pe; st++)
          ot = (this.words[st + pe] | 0) + ht, ht = ot >> 26, this.words[st + pe] = ot & 67108863;
        if (ht === 0) return this.strip();
        for (K(ht === -1), ht = 0, st = 0; st < this.length; st++)
          ot = -(this.words[st] | 0) + ht, ht = ot >> 26, this.words[st] = ot & 67108863;
        return this.negative = 1, this.strip();
      }, W.prototype._wordDiv = function(rt, Ce) {
        var pe = this.length - rt.length, nt = this.clone(), st = rt, ot = st.words[st.length - 1] | 0, ht = this._countBits(ot);
        pe = 26 - ht, pe !== 0 && (st = st.ushln(pe), nt.iushln(pe), ot = st.words[st.length - 1] | 0);
        var pt = nt.length - st.length, ft;
        if (Ce !== "mod") {
          ft = new W(null), ft.length = pt + 1, ft.words = new Array(ft.length);
          for (var mt = 0; mt < ft.length; mt++)
            ft.words[mt] = 0;
        }
        var lt = nt.clone()._ishlnsubmul(st, 1, pt);
        lt.negative === 0 && (nt = lt, ft && (ft.words[pt] = 1));
        for (var St = pt - 1; St >= 0; St--) {
          var Ft = (nt.words[st.length + St] | 0) * 67108864 + (nt.words[st.length + St - 1] | 0);
          for (Ft = Math.min(Ft / ot | 0, 67108863), nt._ishlnsubmul(st, Ft, St); nt.negative !== 0; )
            Ft--, nt.negative = 0, nt._ishlnsubmul(st, 1, St), nt.isZero() || (nt.negative ^= 1);
          ft && (ft.words[St] = Ft);
        }
        return ft && ft.strip(), nt.strip(), Ce !== "div" && pe !== 0 && nt.iushrn(pe), {
          div: ft || null,
          mod: nt
        };
      }, W.prototype.divmod = function(rt, Ce, pe) {
        if (K(!rt.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var nt, st, ot;
        return this.negative !== 0 && rt.negative === 0 ? (ot = this.neg().divmod(rt, Ce), Ce !== "mod" && (nt = ot.div.neg()), Ce !== "div" && (st = ot.mod.neg(), pe && st.negative !== 0 && st.iadd(rt)), {
          div: nt,
          mod: st
        }) : this.negative === 0 && rt.negative !== 0 ? (ot = this.divmod(rt.neg(), Ce), Ce !== "mod" && (nt = ot.div.neg()), {
          div: nt,
          mod: ot.mod
        }) : this.negative & rt.negative ? (ot = this.neg().divmod(rt.neg(), Ce), Ce !== "div" && (st = ot.mod.neg(), pe && st.negative !== 0 && st.isub(rt)), {
          div: ot.div,
          mod: st
        }) : rt.length > this.length || this.cmp(rt) < 0 ? {
          div: new W(0),
          mod: this
        } : rt.length === 1 ? Ce === "div" ? {
          div: this.divn(rt.words[0]),
          mod: null
        } : Ce === "mod" ? {
          div: null,
          mod: new W(this.modn(rt.words[0]))
        } : {
          div: this.divn(rt.words[0]),
          mod: new W(this.modn(rt.words[0]))
        } : this._wordDiv(rt, Ce);
      }, W.prototype.div = function(rt) {
        return this.divmod(rt, "div", !1).div;
      }, W.prototype.mod = function(rt) {
        return this.divmod(rt, "mod", !1).mod;
      }, W.prototype.umod = function(rt) {
        return this.divmod(rt, "mod", !0).mod;
      }, W.prototype.divRound = function(rt) {
        var Ce = this.divmod(rt);
        if (Ce.mod.isZero()) return Ce.div;
        var pe = Ce.div.negative !== 0 ? Ce.mod.isub(rt) : Ce.mod, nt = rt.ushrn(1), st = rt.andln(1), ot = pe.cmp(nt);
        return ot < 0 || st === 1 && ot === 0 ? Ce.div : Ce.div.negative !== 0 ? Ce.div.isubn(1) : Ce.div.iaddn(1);
      }, W.prototype.modn = function(rt) {
        K(rt <= 67108863);
        for (var Ce = (1 << 26) % rt, pe = 0, nt = this.length - 1; nt >= 0; nt--)
          pe = (Ce * pe + (this.words[nt] | 0)) % rt;
        return pe;
      }, W.prototype.idivn = function(rt) {
        K(rt <= 67108863);
        for (var Ce = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = (this.words[pe] | 0) + Ce * 67108864;
          this.words[pe] = nt / rt | 0, Ce = nt % rt;
        }
        return this.strip();
      }, W.prototype.divn = function(rt) {
        return this.clone().idivn(rt);
      }, W.prototype.egcd = function(rt) {
        K(rt.negative === 0), K(!rt.isZero());
        var Ce = this, pe = rt.clone();
        Ce.negative !== 0 ? Ce = Ce.umod(rt) : Ce = Ce.clone();
        for (var nt = new W(1), st = new W(0), ot = new W(0), ht = new W(1), pt = 0; Ce.isEven() && pe.isEven(); )
          Ce.iushrn(1), pe.iushrn(1), ++pt;
        for (var ft = pe.clone(), mt = Ce.clone(); !Ce.isZero(); ) {
          for (var lt = 0, St = 1; !(Ce.words[0] & St) && lt < 26; ++lt, St <<= 1) ;
          if (lt > 0)
            for (Ce.iushrn(lt); lt-- > 0; )
              (nt.isOdd() || st.isOdd()) && (nt.iadd(ft), st.isub(mt)), nt.iushrn(1), st.iushrn(1);
          for (var Ft = 0, Gt = 1; !(pe.words[0] & Gt) && Ft < 26; ++Ft, Gt <<= 1) ;
          if (Ft > 0)
            for (pe.iushrn(Ft); Ft-- > 0; )
              (ot.isOdd() || ht.isOdd()) && (ot.iadd(ft), ht.isub(mt)), ot.iushrn(1), ht.iushrn(1);
          Ce.cmp(pe) >= 0 ? (Ce.isub(pe), nt.isub(ot), st.isub(ht)) : (pe.isub(Ce), ot.isub(nt), ht.isub(st));
        }
        return {
          a: ot,
          b: ht,
          gcd: pe.iushln(pt)
        };
      }, W.prototype._invmp = function(rt) {
        K(rt.negative === 0), K(!rt.isZero());
        var Ce = this, pe = rt.clone();
        Ce.negative !== 0 ? Ce = Ce.umod(rt) : Ce = Ce.clone();
        for (var nt = new W(1), st = new W(0), ot = pe.clone(); Ce.cmpn(1) > 0 && pe.cmpn(1) > 0; ) {
          for (var ht = 0, pt = 1; !(Ce.words[0] & pt) && ht < 26; ++ht, pt <<= 1) ;
          if (ht > 0)
            for (Ce.iushrn(ht); ht-- > 0; )
              nt.isOdd() && nt.iadd(ot), nt.iushrn(1);
          for (var ft = 0, mt = 1; !(pe.words[0] & mt) && ft < 26; ++ft, mt <<= 1) ;
          if (ft > 0)
            for (pe.iushrn(ft); ft-- > 0; )
              st.isOdd() && st.iadd(ot), st.iushrn(1);
          Ce.cmp(pe) >= 0 ? (Ce.isub(pe), nt.isub(st)) : (pe.isub(Ce), st.isub(nt));
        }
        var lt;
        return Ce.cmpn(1) === 0 ? lt = nt : lt = st, lt.cmpn(0) < 0 && lt.iadd(rt), lt;
      }, W.prototype.gcd = function(rt) {
        if (this.isZero()) return rt.abs();
        if (rt.isZero()) return this.abs();
        var Ce = this.clone(), pe = rt.clone();
        Ce.negative = 0, pe.negative = 0;
        for (var nt = 0; Ce.isEven() && pe.isEven(); nt++)
          Ce.iushrn(1), pe.iushrn(1);
        do {
          for (; Ce.isEven(); )
            Ce.iushrn(1);
          for (; pe.isEven(); )
            pe.iushrn(1);
          var st = Ce.cmp(pe);
          if (st < 0) {
            var ot = Ce;
            Ce = pe, pe = ot;
          } else if (st === 0 || pe.cmpn(1) === 0)
            break;
          Ce.isub(pe);
        } while (!0);
        return pe.iushln(nt);
      }, W.prototype.invm = function(rt) {
        return this.egcd(rt).a.umod(rt);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(rt) {
        return this.words[0] & rt;
      }, W.prototype.bincn = function(rt) {
        K(typeof rt == "number");
        var Ce = rt % 26, pe = (rt - Ce) / 26, nt = 1 << Ce;
        if (this.length <= pe)
          return this._expand(pe + 1), this.words[pe] |= nt, this;
        for (var st = nt, ot = pe; st !== 0 && ot < this.length; ot++) {
          var ht = this.words[ot] | 0;
          ht += st, st = ht >>> 26, ht &= 67108863, this.words[ot] = ht;
        }
        return st !== 0 && (this.words[ot] = st, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(rt) {
        var Ce = rt < 0;
        if (this.negative !== 0 && !Ce) return -1;
        if (this.negative === 0 && Ce) return 1;
        this.strip();
        var pe;
        if (this.length > 1)
          pe = 1;
        else {
          Ce && (rt = -rt), K(rt <= 67108863, "Number is too big");
          var nt = this.words[0] | 0;
          pe = nt === rt ? 0 : nt < rt ? -1 : 1;
        }
        return this.negative !== 0 ? -pe | 0 : pe;
      }, W.prototype.cmp = function(rt) {
        if (this.negative !== 0 && rt.negative === 0) return -1;
        if (this.negative === 0 && rt.negative !== 0) return 1;
        var Ce = this.ucmp(rt);
        return this.negative !== 0 ? -Ce | 0 : Ce;
      }, W.prototype.ucmp = function(rt) {
        if (this.length > rt.length) return 1;
        if (this.length < rt.length) return -1;
        for (var Ce = 0, pe = this.length - 1; pe >= 0; pe--) {
          var nt = this.words[pe] | 0, st = rt.words[pe] | 0;
          if (nt !== st) {
            nt < st ? Ce = -1 : nt > st && (Ce = 1);
            break;
          }
        }
        return Ce;
      }, W.prototype.gtn = function(rt) {
        return this.cmpn(rt) === 1;
      }, W.prototype.gt = function(rt) {
        return this.cmp(rt) === 1;
      }, W.prototype.gten = function(rt) {
        return this.cmpn(rt) >= 0;
      }, W.prototype.gte = function(rt) {
        return this.cmp(rt) >= 0;
      }, W.prototype.ltn = function(rt) {
        return this.cmpn(rt) === -1;
      }, W.prototype.lt = function(rt) {
        return this.cmp(rt) === -1;
      }, W.prototype.lten = function(rt) {
        return this.cmpn(rt) <= 0;
      }, W.prototype.lte = function(rt) {
        return this.cmp(rt) <= 0;
      }, W.prototype.eqn = function(rt) {
        return this.cmpn(rt) === 0;
      }, W.prototype.eq = function(rt) {
        return this.cmp(rt) === 0;
      }, W.red = function(rt) {
        return new yt(rt);
      }, W.prototype.toRed = function(rt) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), rt.convertTo(this)._forceRed(rt);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(rt) {
        return this.red = rt, this;
      }, W.prototype.forceRed = function(rt) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(rt);
      }, W.prototype.redAdd = function(rt) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, rt);
      }, W.prototype.redIAdd = function(rt) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, rt);
      }, W.prototype.redSub = function(rt) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, rt);
      }, W.prototype.redISub = function(rt) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, rt);
      }, W.prototype.redShl = function(rt) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, rt);
      }, W.prototype.redMul = function(rt) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, rt), this.red.mul(this, rt);
      }, W.prototype.redIMul = function(rt) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, rt), this.red.imul(this, rt);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(rt) {
        return K(this.red && !rt.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, rt);
      };
      var bt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function vt(gt, rt) {
        this.name = gt, this.p = new W(rt, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      vt.prototype._tmp = function() {
        var rt = new W(null);
        return rt.words = new Array(Math.ceil(this.n / 13)), rt;
      }, vt.prototype.ireduce = function(rt) {
        var Ce = rt, pe;
        do
          this.split(Ce, this.tmp), Ce = this.imulK(Ce), Ce = Ce.iadd(this.tmp), pe = Ce.bitLength();
        while (pe > this.n);
        var nt = pe < this.n ? -1 : Ce.ucmp(this.p);
        return nt === 0 ? (Ce.words[0] = 0, Ce.length = 1) : nt > 0 ? Ce.isub(this.p) : Ce.strip !== void 0 ? Ce.strip() : Ce._strip(), Ce;
      }, vt.prototype.split = function(rt, Ce) {
        rt.iushrn(this.n, 0, Ce);
      }, vt.prototype.imulK = function(rt) {
        return rt.imul(this.k);
      };
      function $t() {
        vt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      V($t, vt), $t.prototype.split = function(rt, Ce) {
        for (var pe = 4194303, nt = Math.min(rt.length, 9), st = 0; st < nt; st++)
          Ce.words[st] = rt.words[st];
        if (Ce.length = nt, rt.length <= 9) {
          rt.words[0] = 0, rt.length = 1;
          return;
        }
        var ot = rt.words[9];
        for (Ce.words[Ce.length++] = ot & pe, st = 10; st < rt.length; st++) {
          var ht = rt.words[st] | 0;
          rt.words[st - 10] = (ht & pe) << 4 | ot >>> 22, ot = ht;
        }
        ot >>>= 22, rt.words[st - 10] = ot, ot === 0 && rt.length > 10 ? rt.length -= 10 : rt.length -= 9;
      }, $t.prototype.imulK = function(rt) {
        rt.words[rt.length] = 0, rt.words[rt.length + 1] = 0, rt.length += 2;
        for (var Ce = 0, pe = 0; pe < rt.length; pe++) {
          var nt = rt.words[pe] | 0;
          Ce += nt * 977, rt.words[pe] = Ce & 67108863, Ce = nt * 64 + (Ce / 67108864 | 0);
        }
        return rt.words[rt.length - 1] === 0 && (rt.length--, rt.words[rt.length - 1] === 0 && rt.length--), rt;
      };
      function xt() {
        vt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      V(xt, vt);
      function Ot() {
        vt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      V(Ot, vt);
      function At() {
        vt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      V(At, vt), At.prototype.imulK = function(rt) {
        for (var Ce = 0, pe = 0; pe < rt.length; pe++) {
          var nt = (rt.words[pe] | 0) * 19 + Ce, st = nt & 67108863;
          nt >>>= 26, rt.words[pe] = st, Ce = nt;
        }
        return Ce !== 0 && (rt.words[rt.length++] = Ce), rt;
      }, W._prime = function(rt) {
        if (bt[rt]) return bt[rt];
        var Ce;
        if (rt === "k256")
          Ce = new $t();
        else if (rt === "p224")
          Ce = new xt();
        else if (rt === "p192")
          Ce = new Ot();
        else if (rt === "p25519")
          Ce = new At();
        else
          throw new Error("Unknown prime " + rt);
        return bt[rt] = Ce, Ce;
      };
      function yt(gt) {
        if (typeof gt == "string") {
          var rt = W._prime(gt);
          this.m = rt.p, this.prime = rt;
        } else
          K(gt.gtn(1), "modulus must be greater than 1"), this.m = gt, this.prime = null;
      }
      yt.prototype._verify1 = function(rt) {
        K(rt.negative === 0, "red works only with positives"), K(rt.red, "red works only with red numbers");
      }, yt.prototype._verify2 = function(rt, Ce) {
        K((rt.negative | Ce.negative) === 0, "red works only with positives"), K(
          rt.red && rt.red === Ce.red,
          "red works only with red numbers"
        );
      }, yt.prototype.imod = function(rt) {
        return this.prime ? this.prime.ireduce(rt)._forceRed(this) : rt.umod(this.m)._forceRed(this);
      }, yt.prototype.neg = function(rt) {
        return rt.isZero() ? rt.clone() : this.m.sub(rt)._forceRed(this);
      }, yt.prototype.add = function(rt, Ce) {
        this._verify2(rt, Ce);
        var pe = rt.add(Ce);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe._forceRed(this);
      }, yt.prototype.iadd = function(rt, Ce) {
        this._verify2(rt, Ce);
        var pe = rt.iadd(Ce);
        return pe.cmp(this.m) >= 0 && pe.isub(this.m), pe;
      }, yt.prototype.sub = function(rt, Ce) {
        this._verify2(rt, Ce);
        var pe = rt.sub(Ce);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe._forceRed(this);
      }, yt.prototype.isub = function(rt, Ce) {
        this._verify2(rt, Ce);
        var pe = rt.isub(Ce);
        return pe.cmpn(0) < 0 && pe.iadd(this.m), pe;
      }, yt.prototype.shl = function(rt, Ce) {
        return this._verify1(rt), this.imod(rt.ushln(Ce));
      }, yt.prototype.imul = function(rt, Ce) {
        return this._verify2(rt, Ce), this.imod(rt.imul(Ce));
      }, yt.prototype.mul = function(rt, Ce) {
        return this._verify2(rt, Ce), this.imod(rt.mul(Ce));
      }, yt.prototype.isqr = function(rt) {
        return this.imul(rt, rt.clone());
      }, yt.prototype.sqr = function(rt) {
        return this.mul(rt, rt);
      }, yt.prototype.sqrt = function(rt) {
        if (rt.isZero()) return rt.clone();
        var Ce = this.m.andln(3);
        if (K(Ce % 2 === 1), Ce === 3) {
          var pe = this.m.add(new W(1)).iushrn(2);
          return this.pow(rt, pe);
        }
        for (var nt = this.m.subn(1), st = 0; !nt.isZero() && nt.andln(1) === 0; )
          st++, nt.iushrn(1);
        K(!nt.isZero());
        var ot = new W(1).toRed(this), ht = ot.redNeg(), pt = this.m.subn(1).iushrn(1), ft = this.m.bitLength();
        for (ft = new W(2 * ft * ft).toRed(this); this.pow(ft, pt).cmp(ht) !== 0; )
          ft.redIAdd(ht);
        for (var mt = this.pow(ft, nt), lt = this.pow(rt, nt.addn(1).iushrn(1)), St = this.pow(rt, nt), Ft = st; St.cmp(ot) !== 0; ) {
          for (var Gt = St, qt = 0; Gt.cmp(ot) !== 0; qt++)
            Gt = Gt.redSqr();
          K(qt < Ft);
          var Pt = this.pow(mt, new W(1).iushln(Ft - qt - 1));
          lt = lt.redMul(Pt), mt = Pt.redSqr(), St = St.redMul(mt), Ft = qt;
        }
        return lt;
      }, yt.prototype.invm = function(rt) {
        var Ce = rt._invmp(this.m);
        return Ce.negative !== 0 ? (Ce.negative = 0, this.imod(Ce).redNeg()) : this.imod(Ce);
      }, yt.prototype.pow = function(rt, Ce) {
        if (Ce.isZero()) return new W(1).toRed(this);
        if (Ce.cmpn(1) === 0) return rt.clone();
        var pe = 4, nt = new Array(1 << pe);
        nt[0] = new W(1).toRed(this), nt[1] = rt;
        for (var st = 2; st < nt.length; st++)
          nt[st] = this.mul(nt[st - 1], rt);
        var ot = nt[0], ht = 0, pt = 0, ft = Ce.bitLength() % 26;
        for (ft === 0 && (ft = 26), st = Ce.length - 1; st >= 0; st--) {
          for (var mt = Ce.words[st], lt = ft - 1; lt >= 0; lt--) {
            var St = mt >> lt & 1;
            if (ot !== nt[0] && (ot = this.sqr(ot)), St === 0 && ht === 0) {
              pt = 0;
              continue;
            }
            ht <<= 1, ht |= St, pt++, !(pt !== pe && (st !== 0 || lt !== 0)) && (ot = this.mul(ot, nt[ht]), pt = 0, ht = 0);
          }
          ft = 26;
        }
        return ot;
      }, yt.prototype.convertTo = function(rt) {
        var Ce = rt.umod(this.m);
        return Ce === rt ? Ce.clone() : Ce;
      }, yt.prototype.convertFrom = function(rt) {
        var Ce = rt.clone();
        return Ce.red = null, Ce;
      }, W.mont = function(rt) {
        return new Bt(rt);
      };
      function Bt(gt) {
        yt.call(this, gt), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      V(Bt, yt), Bt.prototype.convertTo = function(rt) {
        return this.imod(rt.ushln(this.shift));
      }, Bt.prototype.convertFrom = function(rt) {
        var Ce = this.imod(rt.mul(this.rinv));
        return Ce.red = null, Ce;
      }, Bt.prototype.imul = function(rt, Ce) {
        if (rt.isZero() || Ce.isZero())
          return rt.words[0] = 0, rt.length = 1, rt;
        var pe = rt.imul(Ce), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), st = pe.isub(nt).iushrn(this.shift), ot = st;
        return st.cmp(this.m) >= 0 ? ot = st.isub(this.m) : st.cmpn(0) < 0 && (ot = st.iadd(this.m)), ot._forceRed(this);
      }, Bt.prototype.mul = function(rt, Ce) {
        if (rt.isZero() || Ce.isZero()) return new W(0)._forceRed(this);
        var pe = rt.mul(Ce), nt = pe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), st = pe.isub(nt).iushrn(this.shift), ot = st;
        return st.cmp(this.m) >= 0 ? ot = st.isub(this.m) : st.cmpn(0) < 0 && (ot = st.iadd(this.m)), ot._forceRed(this);
      }, Bt.prototype.invm = function(rt) {
        var Ce = this.imod(rt._invmp(this.m).mul(this.r2));
        return Ce._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var A;
  brorand.exports = function(V) {
    return A || (A = new B(null)), A.generate(V);
  };
  function B(K) {
    this.rand = K;
  }
  if (brorand.exports.Rand = B, B.prototype.generate = function(V) {
    return this._rand(V);
  }, B.prototype._rand = function(V) {
    if (this.rand.getBytes)
      return this.rand.getBytes(V);
    for (var W = new Uint8Array(V), J = 0; J < W.length; J++)
      W[J] = this.rand.getByte();
    return W;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? B.prototype._rand = function(V) {
      var W = new Uint8Array(V);
      return self.crypto.getRandomValues(W), W;
    } : self.msCrypto && self.msCrypto.getRandomValues ? B.prototype._rand = function(V) {
      var W = new Uint8Array(V);
      return self.msCrypto.getRandomValues(W), W;
    } : typeof window == "object" && (B.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var L = requireCryptoBrowserify();
      if (typeof L.randomBytes != "function")
        throw new Error("Not supported");
      B.prototype._rand = function(V) {
        return L.randomBytes(V);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var A = requireBn$1(), B = requireBrorand();
  function L(K) {
    this.rand = K || new B.Rand();
  }
  return mr = L, L.create = function(V) {
    return new L(V);
  }, L.prototype._randbelow = function(V) {
    var W = V.bitLength(), J = Math.ceil(W / 8);
    do
      var ne = new A(this.rand.generate(J));
    while (ne.cmp(V) >= 0);
    return ne;
  }, L.prototype._randrange = function(V, W) {
    var J = W.sub(V);
    return V.add(this._randbelow(J));
  }, L.prototype.test = function(V, W, J) {
    var ne = V.bitLength(), ie = A.mont(V), ce = new A(1).toRed(ie);
    W || (W = Math.max(1, ne / 48 | 0));
    for (var re = V.subn(1), oe = 0; !re.testn(oe); oe++)
      ;
    for (var ke = V.shrn(oe), Oe = re.toRed(ie), it = !0; W > 0; W--) {
      var at = this._randrange(new A(2), re);
      J && J(at);
      var ut = at.toRed(ie).redPow(ke);
      if (!(ut.cmp(ce) === 0 || ut.cmp(Oe) === 0)) {
        for (var dt = 1; dt < oe; dt++) {
          if (ut = ut.redSqr(), ut.cmp(ce) === 0)
            return !1;
          if (ut.cmp(Oe) === 0)
            break;
        }
        if (dt === oe)
          return !1;
      }
    }
    return it;
  }, L.prototype.getDivisor = function(V, W) {
    var J = V.bitLength(), ne = A.mont(V), ie = new A(1).toRed(ne);
    W || (W = Math.max(1, J / 48 | 0));
    for (var ce = V.subn(1), re = 0; !ce.testn(re); re++)
      ;
    for (var oe = V.shrn(re), ke = ce.toRed(ne); W > 0; W--) {
      var Oe = this._randrange(new A(2), ce), it = V.gcd(Oe);
      if (it.cmpn(1) !== 0)
        return it;
      var at = Oe.toRed(ne).redPow(oe);
      if (!(at.cmp(ie) === 0 || at.cmp(ke) === 0)) {
        for (var ut = 1; ut < re; ut++) {
          if (at = at.redSqr(), at.cmp(ie) === 0)
            return at.fromRed().subn(1).gcd(V);
          if (at.cmp(ke) === 0)
            break;
        }
        if (ut === re)
          return at = at.redSqr(), at.fromRed().subn(1).gcd(V);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var A = requireBrowser$b();
  generatePrime = ut, ut.simpleSieve = it, ut.fermatTest = at;
  var B = requireBn$1(), L = new B(24), K = requireMr(), V = new K(), W = new B(1), J = new B(2), ne = new B(5);
  new B(16), new B(8);
  var ie = new B(10), ce = new B(3);
  new B(7);
  var re = new B(11), oe = new B(4);
  new B(12);
  var ke = null;
  function Oe() {
    if (ke !== null)
      return ke;
    var dt = 1048576, ct = [];
    ct[0] = 2;
    for (var bt = 1, vt = 3; vt < dt; vt += 2) {
      for (var $t = Math.ceil(Math.sqrt(vt)), xt = 0; xt < bt && ct[xt] <= $t && vt % ct[xt] !== 0; xt++)
        ;
      bt !== xt && ct[xt] <= $t || (ct[bt++] = vt);
    }
    return ke = ct, ct;
  }
  function it(dt) {
    for (var ct = Oe(), bt = 0; bt < ct.length; bt++)
      if (dt.modn(ct[bt]) === 0)
        return dt.cmpn(ct[bt]) === 0;
    return !0;
  }
  function at(dt) {
    var ct = B.mont(dt);
    return J.toRed(ct).redPow(dt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function ut(dt, ct) {
    if (dt < 16)
      return ct === 2 || ct === 5 ? new B([140, 123]) : new B([140, 39]);
    ct = new B(ct);
    for (var bt, vt; ; ) {
      for (bt = new B(A(Math.ceil(dt / 8))); bt.bitLength() > dt; )
        bt.ishrn(1);
      if (bt.isEven() && bt.iadd(W), bt.testn(1) || bt.iadd(J), ct.cmp(J)) {
        if (!ct.cmp(ne))
          for (; bt.mod(ie).cmp(ce); )
            bt.iadd(oe);
      } else for (; bt.mod(L).cmp(re); )
        bt.iadd(oe);
      if (vt = bt.shrn(1), it(vt) && it(bt) && at(vt) && at(bt) && V.test(vt) && V.test(bt))
        return bt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var A = requireBn$1(), B = requireMr(), L = new B(), K = new A(24), V = new A(11), W = new A(10), J = new A(3), ne = new A(7), ie = requireGeneratePrime(), ce = requireBrowser$b();
  dh = it;
  function re(ut, dt) {
    return dt = dt || "utf8", Buffer$1.isBuffer(ut) || (ut = new Buffer$1(ut, dt)), this._pub = new A(ut), this;
  }
  function oe(ut, dt) {
    return dt = dt || "utf8", Buffer$1.isBuffer(ut) || (ut = new Buffer$1(ut, dt)), this._priv = new A(ut), this;
  }
  var ke = {};
  function Oe(ut, dt) {
    var ct = dt.toString("hex"), bt = [ct, ut.toString(16)].join("_");
    if (bt in ke)
      return ke[bt];
    var vt = 0;
    if (ut.isEven() || !ie.simpleSieve || !ie.fermatTest(ut) || !L.test(ut))
      return vt += 1, ct === "02" || ct === "05" ? vt += 8 : vt += 4, ke[bt] = vt, vt;
    L.test(ut.shrn(1)) || (vt += 2);
    var $t;
    switch (ct) {
      case "02":
        ut.mod(K).cmp(V) && (vt += 8);
        break;
      case "05":
        $t = ut.mod(W), $t.cmp(J) && $t.cmp(ne) && (vt += 8);
        break;
      default:
        vt += 4;
    }
    return ke[bt] = vt, vt;
  }
  function it(ut, dt, ct) {
    this.setGenerator(dt), this.__prime = new A(ut), this._prime = A.mont(this.__prime), this._primeLen = ut.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ct ? (this.setPublicKey = re, this.setPrivateKey = oe) : this._primeCode = 8;
  }
  Object.defineProperty(it.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Oe(this.__prime, this.__gen)), this._primeCode;
    }
  }), it.prototype.generateKeys = function() {
    return this._priv || (this._priv = new A(ce(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, it.prototype.computeSecret = function(ut) {
    ut = new A(ut), ut = ut.toRed(this._prime);
    var dt = ut.redPow(this._priv).fromRed(), ct = new Buffer$1(dt.toArray()), bt = this.getPrime();
    if (ct.length < bt.length) {
      var vt = new Buffer$1(bt.length - ct.length);
      vt.fill(0), ct = Buffer$1.concat([vt, ct]);
    }
    return ct;
  }, it.prototype.getPublicKey = function(dt) {
    return at(this._pub, dt);
  }, it.prototype.getPrivateKey = function(dt) {
    return at(this._priv, dt);
  }, it.prototype.getPrime = function(ut) {
    return at(this.__prime, ut);
  }, it.prototype.getGenerator = function(ut) {
    return at(this._gen, ut);
  }, it.prototype.setGenerator = function(ut, dt) {
    return dt = dt || "utf8", Buffer$1.isBuffer(ut) || (ut = new Buffer$1(ut, dt)), this.__gen = ut, this._gen = new A(ut), this;
  };
  function at(ut, dt) {
    var ct = new Buffer$1(ut.toArray());
    return dt ? ct.toString(dt) : ct;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var A = requireGeneratePrime(), B = require$$1$1, L = requireDh();
  function K(J) {
    var ne = new Buffer$1(B[J].prime, "hex"), ie = new Buffer$1(B[J].gen, "hex");
    return new L(ne, ie);
  }
  var V = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function W(J, ne, ie, ce) {
    return Buffer$1.isBuffer(ne) || V[ne] === void 0 ? W(J, "binary", ne, ie) : (ne = ne || "binary", ce = ce || "binary", ie = ie || new Buffer$1([2]), Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, ce)), typeof J == "number" ? new L(A(J, ie), ie, !0) : (Buffer$1.isBuffer(J) || (J = new Buffer$1(J, ne)), new L(J, ie, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = K, browser$4.createDiffieHellman = browser$4.DiffieHellman = W, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: A } : processNextickArgs.exports = process$1;
  function A(B, L, K, V) {
    if (typeof B != "function")
      throw new TypeError('"callback" argument must be a function');
    var W = arguments.length, J, ne;
    switch (W) {
      case 0:
      case 1:
        return process$1.nextTick(B);
      case 2:
        return process$1.nextTick(function() {
          B.call(null, L);
        });
      case 3:
        return process$1.nextTick(function() {
          B.call(null, L, K);
        });
      case 4:
        return process$1.nextTick(function() {
          B.call(null, L, K, V);
        });
      default:
        for (J = new Array(W - 1), ne = 0; ne < J.length; )
          J[ne++] = arguments[ne];
        return process$1.nextTick(function() {
          B.apply(null, J);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var A = {}.toString;
  return isarray = Array.isArray || function(B) {
    return A.call(B) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(A, B) {
    var L = require$$0$1, K = L.Buffer;
    function V(J, ne) {
      for (var ie in J)
        ne[ie] = J[ie];
    }
    K.from && K.alloc && K.allocUnsafe && K.allocUnsafeSlow ? A.exports = L : (V(L, B), B.Buffer = W);
    function W(J, ne, ie) {
      return K(J, ne, ie);
    }
    V(K, W), W.from = function(J, ne, ie) {
      if (typeof J == "number")
        throw new TypeError("Argument must not be a number");
      return K(J, ne, ie);
    }, W.alloc = function(J, ne, ie) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      var ce = K(J);
      return ne !== void 0 ? typeof ie == "string" ? ce.fill(ne, ie) : ce.fill(ne) : ce.fill(0), ce;
    }, W.allocUnsafe = function(J) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      return K(J);
    }, W.allocUnsafeSlow = function(J) {
      if (typeof J != "number")
        throw new TypeError("Argument must be a number");
      return L.SlowBuffer(J);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function A(at) {
    return Array.isArray ? Array.isArray(at) : it(at) === "[object Array]";
  }
  util.isArray = A;
  function B(at) {
    return typeof at == "boolean";
  }
  util.isBoolean = B;
  function L(at) {
    return at === null;
  }
  util.isNull = L;
  function K(at) {
    return at == null;
  }
  util.isNullOrUndefined = K;
  function V(at) {
    return typeof at == "number";
  }
  util.isNumber = V;
  function W(at) {
    return typeof at == "string";
  }
  util.isString = W;
  function J(at) {
    return typeof at == "symbol";
  }
  util.isSymbol = J;
  function ne(at) {
    return at === void 0;
  }
  util.isUndefined = ne;
  function ie(at) {
    return it(at) === "[object RegExp]";
  }
  util.isRegExp = ie;
  function ce(at) {
    return typeof at == "object" && at !== null;
  }
  util.isObject = ce;
  function re(at) {
    return it(at) === "[object Date]";
  }
  util.isDate = re;
  function oe(at) {
    return it(at) === "[object Error]" || at instanceof Error;
  }
  util.isError = oe;
  function ke(at) {
    return typeof at == "function";
  }
  util.isFunction = ke;
  function Oe(at) {
    return at === null || typeof at == "boolean" || typeof at == "number" || typeof at == "string" || typeof at == "symbol" || // ES6 symbol
    typeof at > "u";
  }
  util.isPrimitive = Oe, util.isBuffer = require$$0$1.Buffer.isBuffer;
  function it(at) {
    return Object.prototype.toString.call(at);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(A) {
    function B(W, J) {
      if (!(W instanceof J))
        throw new TypeError("Cannot call a class as a function");
    }
    var L = requireSafeBuffer().Buffer, K = requireUtil$1();
    function V(W, J, ne) {
      W.copy(J, ne);
    }
    A.exports = function() {
      function W() {
        B(this, W), this.head = null, this.tail = null, this.length = 0;
      }
      return W.prototype.push = function(ne) {
        var ie = { data: ne, next: null };
        this.length > 0 ? this.tail.next = ie : this.head = ie, this.tail = ie, ++this.length;
      }, W.prototype.unshift = function(ne) {
        var ie = { data: ne, next: this.head };
        this.length === 0 && (this.tail = ie), this.head = ie, ++this.length;
      }, W.prototype.shift = function() {
        if (this.length !== 0) {
          var ne = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ne;
        }
      }, W.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, W.prototype.join = function(ne) {
        if (this.length === 0) return "";
        for (var ie = this.head, ce = "" + ie.data; ie = ie.next; )
          ce += ne + ie.data;
        return ce;
      }, W.prototype.concat = function(ne) {
        if (this.length === 0) return L.alloc(0);
        for (var ie = L.allocUnsafe(ne >>> 0), ce = this.head, re = 0; ce; )
          V(ce.data, ie, re), re += ce.data.length, ce = ce.next;
        return ie;
      }, W;
    }(), K && K.inspect && K.inspect.custom && (A.exports.prototype[K.inspect.custom] = function() {
      var W = K.inspect({ length: this.length });
      return this.constructor.name + " " + W;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var A = requireProcessNextickArgs();
  function B(V, W) {
    var J = this, ne = this._readableState && this._readableState.destroyed, ie = this._writableState && this._writableState.destroyed;
    return ne || ie ? (W ? W(V) : V && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, A.nextTick(K, this, V)) : A.nextTick(K, this, V)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(V || null, function(ce) {
      !W && ce ? J._writableState ? J._writableState.errorEmitted || (J._writableState.errorEmitted = !0, A.nextTick(K, J, ce)) : A.nextTick(K, J, ce) : W && W(ce);
    }), this);
  }
  function L() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function K(V, W) {
    V.emit("error", W);
  }
  return destroy_1 = {
    destroy: B,
    undestroy: L
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var A = requireProcessNextickArgs();
  _stream_writable = at;
  function B(ot) {
    var ht = this;
    this.next = null, this.entry = null, this.finish = function() {
      st(ht, ot);
    };
  }
  var L = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : A.nextTick, K;
  at.WritableState = Oe;
  var V = Object.create(requireUtil());
  V.inherits = requireInherits_browser();
  var W = {
    deprecate: requireBrowser$a()
  }, J = requireStreamBrowser(), ne = requireSafeBuffer().Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ce(ot) {
    return ne.from(ot);
  }
  function re(ot) {
    return ne.isBuffer(ot) || ot instanceof ie;
  }
  var oe = requireDestroy();
  V.inherits(at, J);
  function ke() {
  }
  function Oe(ot, ht) {
    K = K || require_stream_duplex(), ot = ot || {};
    var pt = ht instanceof K;
    this.objectMode = !!ot.objectMode, pt && (this.objectMode = this.objectMode || !!ot.writableObjectMode);
    var ft = ot.highWaterMark, mt = ot.writableHighWaterMark, lt = this.objectMode ? 16 : 16 * 1024;
    ft || ft === 0 ? this.highWaterMark = ft : pt && (mt || mt === 0) ? this.highWaterMark = mt : this.highWaterMark = lt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var St = ot.decodeStrings === !1;
    this.decodeStrings = !St, this.defaultEncoding = ot.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ft) {
      Ot(ht, Ft);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Oe.prototype.getBuffer = function() {
    for (var ht = this.bufferedRequest, pt = []; ht; )
      pt.push(ht), ht = ht.next;
    return pt;
  }, function() {
    try {
      Object.defineProperty(Oe.prototype, "buffer", {
        get: W.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var it;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (it = Function.prototype[Symbol.hasInstance], Object.defineProperty(at, Symbol.hasInstance, {
    value: function(ot) {
      return it.call(this, ot) ? !0 : this !== at ? !1 : ot && ot._writableState instanceof Oe;
    }
  })) : it = function(ot) {
    return ot instanceof this;
  };
  function at(ot) {
    if (K = K || require_stream_duplex(), !it.call(at, this) && !(this instanceof K))
      return new at(ot);
    this._writableState = new Oe(ot, this), this.writable = !0, ot && (typeof ot.write == "function" && (this._write = ot.write), typeof ot.writev == "function" && (this._writev = ot.writev), typeof ot.destroy == "function" && (this._destroy = ot.destroy), typeof ot.final == "function" && (this._final = ot.final)), J.call(this);
  }
  at.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function ut(ot, ht) {
    var pt = new Error("write after end");
    ot.emit("error", pt), A.nextTick(ht, pt);
  }
  function dt(ot, ht, pt, ft) {
    var mt = !0, lt = !1;
    return pt === null ? lt = new TypeError("May not write null values to stream") : typeof pt != "string" && pt !== void 0 && !ht.objectMode && (lt = new TypeError("Invalid non-string/buffer chunk")), lt && (ot.emit("error", lt), A.nextTick(ft, lt), mt = !1), mt;
  }
  at.prototype.write = function(ot, ht, pt) {
    var ft = this._writableState, mt = !1, lt = !ft.objectMode && re(ot);
    return lt && !ne.isBuffer(ot) && (ot = ce(ot)), typeof ht == "function" && (pt = ht, ht = null), lt ? ht = "buffer" : ht || (ht = ft.defaultEncoding), typeof pt != "function" && (pt = ke), ft.ended ? ut(this, pt) : (lt || dt(this, ft, ot, pt)) && (ft.pendingcb++, mt = bt(this, ft, lt, ot, ht, pt)), mt;
  }, at.prototype.cork = function() {
    var ot = this._writableState;
    ot.corked++;
  }, at.prototype.uncork = function() {
    var ot = this._writableState;
    ot.corked && (ot.corked--, !ot.writing && !ot.corked && !ot.bufferProcessing && ot.bufferedRequest && Bt(this, ot));
  }, at.prototype.setDefaultEncoding = function(ht) {
    if (typeof ht == "string" && (ht = ht.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ht + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + ht);
    return this._writableState.defaultEncoding = ht, this;
  };
  function ct(ot, ht, pt) {
    return !ot.objectMode && ot.decodeStrings !== !1 && typeof ht == "string" && (ht = ne.from(ht, pt)), ht;
  }
  Object.defineProperty(at.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function bt(ot, ht, pt, ft, mt, lt) {
    if (!pt) {
      var St = ct(ht, ft, mt);
      ft !== St && (pt = !0, mt = "buffer", ft = St);
    }
    var Ft = ht.objectMode ? 1 : ft.length;
    ht.length += Ft;
    var Gt = ht.length < ht.highWaterMark;
    if (Gt || (ht.needDrain = !0), ht.writing || ht.corked) {
      var qt = ht.lastBufferedRequest;
      ht.lastBufferedRequest = {
        chunk: ft,
        encoding: mt,
        isBuf: pt,
        callback: lt,
        next: null
      }, qt ? qt.next = ht.lastBufferedRequest : ht.bufferedRequest = ht.lastBufferedRequest, ht.bufferedRequestCount += 1;
    } else
      vt(ot, ht, !1, Ft, ft, mt, lt);
    return Gt;
  }
  function vt(ot, ht, pt, ft, mt, lt, St) {
    ht.writelen = ft, ht.writecb = St, ht.writing = !0, ht.sync = !0, pt ? ot._writev(mt, ht.onwrite) : ot._write(mt, lt, ht.onwrite), ht.sync = !1;
  }
  function $t(ot, ht, pt, ft, mt) {
    --ht.pendingcb, pt ? (A.nextTick(mt, ft), A.nextTick(pe, ot, ht), ot._writableState.errorEmitted = !0, ot.emit("error", ft)) : (mt(ft), ot._writableState.errorEmitted = !0, ot.emit("error", ft), pe(ot, ht));
  }
  function xt(ot) {
    ot.writing = !1, ot.writecb = null, ot.length -= ot.writelen, ot.writelen = 0;
  }
  function Ot(ot, ht) {
    var pt = ot._writableState, ft = pt.sync, mt = pt.writecb;
    if (xt(pt), ht) $t(ot, pt, ft, ht, mt);
    else {
      var lt = gt(pt);
      !lt && !pt.corked && !pt.bufferProcessing && pt.bufferedRequest && Bt(ot, pt), ft ? L(At, ot, pt, lt, mt) : At(ot, pt, lt, mt);
    }
  }
  function At(ot, ht, pt, ft) {
    pt || yt(ot, ht), ht.pendingcb--, ft(), pe(ot, ht);
  }
  function yt(ot, ht) {
    ht.length === 0 && ht.needDrain && (ht.needDrain = !1, ot.emit("drain"));
  }
  function Bt(ot, ht) {
    ht.bufferProcessing = !0;
    var pt = ht.bufferedRequest;
    if (ot._writev && pt && pt.next) {
      var ft = ht.bufferedRequestCount, mt = new Array(ft), lt = ht.corkedRequestsFree;
      lt.entry = pt;
      for (var St = 0, Ft = !0; pt; )
        mt[St] = pt, pt.isBuf || (Ft = !1), pt = pt.next, St += 1;
      mt.allBuffers = Ft, vt(ot, ht, !0, ht.length, mt, "", lt.finish), ht.pendingcb++, ht.lastBufferedRequest = null, lt.next ? (ht.corkedRequestsFree = lt.next, lt.next = null) : ht.corkedRequestsFree = new B(ht), ht.bufferedRequestCount = 0;
    } else {
      for (; pt; ) {
        var Gt = pt.chunk, qt = pt.encoding, Pt = pt.callback, Tt = ht.objectMode ? 1 : Gt.length;
        if (vt(ot, ht, !1, Tt, Gt, qt, Pt), pt = pt.next, ht.bufferedRequestCount--, ht.writing)
          break;
      }
      pt === null && (ht.lastBufferedRequest = null);
    }
    ht.bufferedRequest = pt, ht.bufferProcessing = !1;
  }
  at.prototype._write = function(ot, ht, pt) {
    pt(new Error("_write() is not implemented"));
  }, at.prototype._writev = null, at.prototype.end = function(ot, ht, pt) {
    var ft = this._writableState;
    typeof ot == "function" ? (pt = ot, ot = null, ht = null) : typeof ht == "function" && (pt = ht, ht = null), ot != null && this.write(ot, ht), ft.corked && (ft.corked = 1, this.uncork()), ft.ending || nt(this, ft, pt);
  };
  function gt(ot) {
    return ot.ending && ot.length === 0 && ot.bufferedRequest === null && !ot.finished && !ot.writing;
  }
  function rt(ot, ht) {
    ot._final(function(pt) {
      ht.pendingcb--, pt && ot.emit("error", pt), ht.prefinished = !0, ot.emit("prefinish"), pe(ot, ht);
    });
  }
  function Ce(ot, ht) {
    !ht.prefinished && !ht.finalCalled && (typeof ot._final == "function" ? (ht.pendingcb++, ht.finalCalled = !0, A.nextTick(rt, ot, ht)) : (ht.prefinished = !0, ot.emit("prefinish")));
  }
  function pe(ot, ht) {
    var pt = gt(ht);
    return pt && (Ce(ot, ht), ht.pendingcb === 0 && (ht.finished = !0, ot.emit("finish"))), pt;
  }
  function nt(ot, ht, pt) {
    ht.ending = !0, pe(ot, ht), pt && (ht.finished ? A.nextTick(pt) : ot.once("finish", pt)), ht.ended = !0, ot.writable = !1;
  }
  function st(ot, ht, pt) {
    var ft = ot.entry;
    for (ot.entry = null; ft; ) {
      var mt = ft.callback;
      ht.pendingcb--, mt(pt), ft = ft.next;
    }
    ht.corkedRequestsFree.next = ot;
  }
  return Object.defineProperty(at.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ot) {
      this._writableState && (this._writableState.destroyed = ot);
    }
  }), at.prototype.destroy = oe.destroy, at.prototype._undestroy = oe.undestroy, at.prototype._destroy = function(ot, ht) {
    this.end(), ht(ot);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var A = requireProcessNextickArgs(), B = Object.keys || function(oe) {
    var ke = [];
    for (var Oe in oe)
      ke.push(Oe);
    return ke;
  };
  _stream_duplex = ie;
  var L = Object.create(requireUtil());
  L.inherits = requireInherits_browser();
  var K = require_stream_readable(), V = require_stream_writable();
  L.inherits(ie, K);
  for (var W = B(V.prototype), J = 0; J < W.length; J++) {
    var ne = W[J];
    ie.prototype[ne] || (ie.prototype[ne] = V.prototype[ne]);
  }
  function ie(oe) {
    if (!(this instanceof ie)) return new ie(oe);
    K.call(this, oe), V.call(this, oe), oe && oe.readable === !1 && (this.readable = !1), oe && oe.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, oe && oe.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ce);
  }
  Object.defineProperty(ie.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ce() {
    this.allowHalfOpen || this._writableState.ended || A.nextTick(re, this);
  }
  function re(oe) {
    oe.end();
  }
  return Object.defineProperty(ie.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(oe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = oe, this._writableState.destroyed = oe);
    }
  }), ie.prototype._destroy = function(oe, ke) {
    this.push(null), this.end(), A.nextTick(ke, oe);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var A = requireProcessNextickArgs();
  _stream_readable = ct;
  var B = requireIsarray(), L;
  ct.ReadableState = dt, requireEvents().EventEmitter;
  var K = function(Pt, Tt) {
    return Pt.listeners(Tt).length;
  }, V = requireStreamBrowser(), W = requireSafeBuffer().Buffer, J = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ne(Pt) {
    return W.from(Pt);
  }
  function ie(Pt) {
    return W.isBuffer(Pt) || Pt instanceof J;
  }
  var ce = Object.create(requireUtil());
  ce.inherits = requireInherits_browser();
  var re = requireUtil$1(), oe = void 0;
  re && re.debuglog ? oe = re.debuglog("stream") : oe = function() {
  };
  var ke = requireBufferList(), Oe = requireDestroy(), it;
  ce.inherits(ct, V);
  var at = ["error", "close", "destroy", "pause", "resume"];
  function ut(Pt, Tt, Ut) {
    if (typeof Pt.prependListener == "function") return Pt.prependListener(Tt, Ut);
    !Pt._events || !Pt._events[Tt] ? Pt.on(Tt, Ut) : B(Pt._events[Tt]) ? Pt._events[Tt].unshift(Ut) : Pt._events[Tt] = [Ut, Pt._events[Tt]];
  }
  function dt(Pt, Tt) {
    L = L || require_stream_duplex(), Pt = Pt || {};
    var Ut = Tt instanceof L;
    this.objectMode = !!Pt.objectMode, Ut && (this.objectMode = this.objectMode || !!Pt.readableObjectMode);
    var Wt = Pt.highWaterMark, It = Pt.readableHighWaterMark, Rt = this.objectMode ? 16 : 16 * 1024;
    Wt || Wt === 0 ? this.highWaterMark = Wt : Ut && (It || It === 0) ? this.highWaterMark = It : this.highWaterMark = Rt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new ke(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Pt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Pt.encoding && (it || (it = requireString_decoder().StringDecoder), this.decoder = new it(Pt.encoding), this.encoding = Pt.encoding);
  }
  function ct(Pt) {
    if (L = L || require_stream_duplex(), !(this instanceof ct)) return new ct(Pt);
    this._readableState = new dt(Pt, this), this.readable = !0, Pt && (typeof Pt.read == "function" && (this._read = Pt.read), typeof Pt.destroy == "function" && (this._destroy = Pt.destroy)), V.call(this);
  }
  Object.defineProperty(ct.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Pt) {
      this._readableState && (this._readableState.destroyed = Pt);
    }
  }), ct.prototype.destroy = Oe.destroy, ct.prototype._undestroy = Oe.undestroy, ct.prototype._destroy = function(Pt, Tt) {
    this.push(null), Tt(Pt);
  }, ct.prototype.push = function(Pt, Tt) {
    var Ut = this._readableState, Wt;
    return Ut.objectMode ? Wt = !0 : typeof Pt == "string" && (Tt = Tt || Ut.defaultEncoding, Tt !== Ut.encoding && (Pt = W.from(Pt, Tt), Tt = ""), Wt = !0), bt(this, Pt, Tt, !1, Wt);
  }, ct.prototype.unshift = function(Pt) {
    return bt(this, Pt, null, !0, !1);
  };
  function bt(Pt, Tt, Ut, Wt, It) {
    var Rt = Pt._readableState;
    if (Tt === null)
      Rt.reading = !1, Bt(Pt, Rt);
    else {
      var jt;
      It || (jt = $t(Rt, Tt)), jt ? Pt.emit("error", jt) : Rt.objectMode || Tt && Tt.length > 0 ? (typeof Tt != "string" && !Rt.objectMode && Object.getPrototypeOf(Tt) !== W.prototype && (Tt = ne(Tt)), Wt ? Rt.endEmitted ? Pt.emit("error", new Error("stream.unshift() after end event")) : vt(Pt, Rt, Tt, !0) : Rt.ended ? Pt.emit("error", new Error("stream.push() after EOF")) : (Rt.reading = !1, Rt.decoder && !Ut ? (Tt = Rt.decoder.write(Tt), Rt.objectMode || Tt.length !== 0 ? vt(Pt, Rt, Tt, !1) : Ce(Pt, Rt)) : vt(Pt, Rt, Tt, !1))) : Wt || (Rt.reading = !1);
    }
    return xt(Rt);
  }
  function vt(Pt, Tt, Ut, Wt) {
    Tt.flowing && Tt.length === 0 && !Tt.sync ? (Pt.emit("data", Ut), Pt.read(0)) : (Tt.length += Tt.objectMode ? 1 : Ut.length, Wt ? Tt.buffer.unshift(Ut) : Tt.buffer.push(Ut), Tt.needReadable && gt(Pt)), Ce(Pt, Tt);
  }
  function $t(Pt, Tt) {
    var Ut;
    return !ie(Tt) && typeof Tt != "string" && Tt !== void 0 && !Pt.objectMode && (Ut = new TypeError("Invalid non-string/buffer chunk")), Ut;
  }
  function xt(Pt) {
    return !Pt.ended && (Pt.needReadable || Pt.length < Pt.highWaterMark || Pt.length === 0);
  }
  ct.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ct.prototype.setEncoding = function(Pt) {
    return it || (it = requireString_decoder().StringDecoder), this._readableState.decoder = new it(Pt), this._readableState.encoding = Pt, this;
  };
  var Ot = 8388608;
  function At(Pt) {
    return Pt >= Ot ? Pt = Ot : (Pt--, Pt |= Pt >>> 1, Pt |= Pt >>> 2, Pt |= Pt >>> 4, Pt |= Pt >>> 8, Pt |= Pt >>> 16, Pt++), Pt;
  }
  function yt(Pt, Tt) {
    return Pt <= 0 || Tt.length === 0 && Tt.ended ? 0 : Tt.objectMode ? 1 : Pt !== Pt ? Tt.flowing && Tt.length ? Tt.buffer.head.data.length : Tt.length : (Pt > Tt.highWaterMark && (Tt.highWaterMark = At(Pt)), Pt <= Tt.length ? Pt : Tt.ended ? Tt.length : (Tt.needReadable = !0, 0));
  }
  ct.prototype.read = function(Pt) {
    oe("read", Pt), Pt = parseInt(Pt, 10);
    var Tt = this._readableState, Ut = Pt;
    if (Pt !== 0 && (Tt.emittedReadable = !1), Pt === 0 && Tt.needReadable && (Tt.length >= Tt.highWaterMark || Tt.ended))
      return oe("read: emitReadable", Tt.length, Tt.ended), Tt.length === 0 && Tt.ended ? Ft(this) : gt(this), null;
    if (Pt = yt(Pt, Tt), Pt === 0 && Tt.ended)
      return Tt.length === 0 && Ft(this), null;
    var Wt = Tt.needReadable;
    oe("need readable", Wt), (Tt.length === 0 || Tt.length - Pt < Tt.highWaterMark) && (Wt = !0, oe("length less than watermark", Wt)), Tt.ended || Tt.reading ? (Wt = !1, oe("reading or ended", Wt)) : Wt && (oe("do read"), Tt.reading = !0, Tt.sync = !0, Tt.length === 0 && (Tt.needReadable = !0), this._read(Tt.highWaterMark), Tt.sync = !1, Tt.reading || (Pt = yt(Ut, Tt)));
    var It;
    return Pt > 0 ? It = ft(Pt, Tt) : It = null, It === null ? (Tt.needReadable = !0, Pt = 0) : Tt.length -= Pt, Tt.length === 0 && (Tt.ended || (Tt.needReadable = !0), Ut !== Pt && Tt.ended && Ft(this)), It !== null && this.emit("data", It), It;
  };
  function Bt(Pt, Tt) {
    if (!Tt.ended) {
      if (Tt.decoder) {
        var Ut = Tt.decoder.end();
        Ut && Ut.length && (Tt.buffer.push(Ut), Tt.length += Tt.objectMode ? 1 : Ut.length);
      }
      Tt.ended = !0, gt(Pt);
    }
  }
  function gt(Pt) {
    var Tt = Pt._readableState;
    Tt.needReadable = !1, Tt.emittedReadable || (oe("emitReadable", Tt.flowing), Tt.emittedReadable = !0, Tt.sync ? A.nextTick(rt, Pt) : rt(Pt));
  }
  function rt(Pt) {
    oe("emit readable"), Pt.emit("readable"), pt(Pt);
  }
  function Ce(Pt, Tt) {
    Tt.readingMore || (Tt.readingMore = !0, A.nextTick(pe, Pt, Tt));
  }
  function pe(Pt, Tt) {
    for (var Ut = Tt.length; !Tt.reading && !Tt.flowing && !Tt.ended && Tt.length < Tt.highWaterMark && (oe("maybeReadMore read 0"), Pt.read(0), Ut !== Tt.length); )
      Ut = Tt.length;
    Tt.readingMore = !1;
  }
  ct.prototype._read = function(Pt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ct.prototype.pipe = function(Pt, Tt) {
    var Ut = this, Wt = this._readableState;
    switch (Wt.pipesCount) {
      case 0:
        Wt.pipes = Pt;
        break;
      case 1:
        Wt.pipes = [Wt.pipes, Pt];
        break;
      default:
        Wt.pipes.push(Pt);
        break;
    }
    Wt.pipesCount += 1, oe("pipe count=%d opts=%j", Wt.pipesCount, Tt);
    var It = (!Tt || Tt.end !== !1) && Pt !== process$1.stdout && Pt !== process$1.stderr, Rt = It ? Jt : Br;
    Wt.endEmitted ? A.nextTick(Rt) : Ut.once("end", Rt), Pt.on("unpipe", jt);
    function jt(cr, xr) {
      oe("onunpipe"), cr === Ut && xr && xr.hasUnpiped === !1 && (xr.hasUnpiped = !0, fr());
    }
    function Jt() {
      oe("onend"), Pt.end();
    }
    var er = nt(Ut);
    Pt.on("drain", er);
    var nr = !1;
    function fr() {
      oe("cleanup"), Pt.removeListener("close", or), Pt.removeListener("finish", Ar), Pt.removeListener("drain", er), Pt.removeListener("error", Pr), Pt.removeListener("unpipe", jt), Ut.removeListener("end", Jt), Ut.removeListener("end", Br), Ut.removeListener("data", Yt), nr = !0, Wt.awaitDrain && (!Pt._writableState || Pt._writableState.needDrain) && er();
    }
    var lr = !1;
    Ut.on("data", Yt);
    function Yt(cr) {
      oe("ondata"), lr = !1;
      var xr = Pt.write(cr);
      xr === !1 && !lr && ((Wt.pipesCount === 1 && Wt.pipes === Pt || Wt.pipesCount > 1 && qt(Wt.pipes, Pt) !== -1) && !nr && (oe("false write response, pause", Wt.awaitDrain), Wt.awaitDrain++, lr = !0), Ut.pause());
    }
    function Pr(cr) {
      oe("onerror", cr), Br(), Pt.removeListener("error", Pr), K(Pt, "error") === 0 && Pt.emit("error", cr);
    }
    ut(Pt, "error", Pr);
    function or() {
      Pt.removeListener("finish", Ar), Br();
    }
    Pt.once("close", or);
    function Ar() {
      oe("onfinish"), Pt.removeListener("close", or), Br();
    }
    Pt.once("finish", Ar);
    function Br() {
      oe("unpipe"), Ut.unpipe(Pt);
    }
    return Pt.emit("pipe", Ut), Wt.flowing || (oe("pipe resume"), Ut.resume()), Pt;
  };
  function nt(Pt) {
    return function() {
      var Tt = Pt._readableState;
      oe("pipeOnDrain", Tt.awaitDrain), Tt.awaitDrain && Tt.awaitDrain--, Tt.awaitDrain === 0 && K(Pt, "data") && (Tt.flowing = !0, pt(Pt));
    };
  }
  ct.prototype.unpipe = function(Pt) {
    var Tt = this._readableState, Ut = { hasUnpiped: !1 };
    if (Tt.pipesCount === 0) return this;
    if (Tt.pipesCount === 1)
      return Pt && Pt !== Tt.pipes ? this : (Pt || (Pt = Tt.pipes), Tt.pipes = null, Tt.pipesCount = 0, Tt.flowing = !1, Pt && Pt.emit("unpipe", this, Ut), this);
    if (!Pt) {
      var Wt = Tt.pipes, It = Tt.pipesCount;
      Tt.pipes = null, Tt.pipesCount = 0, Tt.flowing = !1;
      for (var Rt = 0; Rt < It; Rt++)
        Wt[Rt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var jt = qt(Tt.pipes, Pt);
    return jt === -1 ? this : (Tt.pipes.splice(jt, 1), Tt.pipesCount -= 1, Tt.pipesCount === 1 && (Tt.pipes = Tt.pipes[0]), Pt.emit("unpipe", this, Ut), this);
  }, ct.prototype.on = function(Pt, Tt) {
    var Ut = V.prototype.on.call(this, Pt, Tt);
    if (Pt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Pt === "readable") {
      var Wt = this._readableState;
      !Wt.endEmitted && !Wt.readableListening && (Wt.readableListening = Wt.needReadable = !0, Wt.emittedReadable = !1, Wt.reading ? Wt.length && gt(this) : A.nextTick(st, this));
    }
    return Ut;
  }, ct.prototype.addListener = ct.prototype.on;
  function st(Pt) {
    oe("readable nexttick read 0"), Pt.read(0);
  }
  ct.prototype.resume = function() {
    var Pt = this._readableState;
    return Pt.flowing || (oe("resume"), Pt.flowing = !0, ot(this, Pt)), this;
  };
  function ot(Pt, Tt) {
    Tt.resumeScheduled || (Tt.resumeScheduled = !0, A.nextTick(ht, Pt, Tt));
  }
  function ht(Pt, Tt) {
    Tt.reading || (oe("resume read 0"), Pt.read(0)), Tt.resumeScheduled = !1, Tt.awaitDrain = 0, Pt.emit("resume"), pt(Pt), Tt.flowing && !Tt.reading && Pt.read(0);
  }
  ct.prototype.pause = function() {
    return oe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (oe("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function pt(Pt) {
    var Tt = Pt._readableState;
    for (oe("flow", Tt.flowing); Tt.flowing && Pt.read() !== null; )
      ;
  }
  ct.prototype.wrap = function(Pt) {
    var Tt = this, Ut = this._readableState, Wt = !1;
    Pt.on("end", function() {
      if (oe("wrapped end"), Ut.decoder && !Ut.ended) {
        var jt = Ut.decoder.end();
        jt && jt.length && Tt.push(jt);
      }
      Tt.push(null);
    }), Pt.on("data", function(jt) {
      if (oe("wrapped data"), Ut.decoder && (jt = Ut.decoder.write(jt)), !(Ut.objectMode && jt == null) && !(!Ut.objectMode && (!jt || !jt.length))) {
        var Jt = Tt.push(jt);
        Jt || (Wt = !0, Pt.pause());
      }
    });
    for (var It in Pt)
      this[It] === void 0 && typeof Pt[It] == "function" && (this[It] = /* @__PURE__ */ function(jt) {
        return function() {
          return Pt[jt].apply(Pt, arguments);
        };
      }(It));
    for (var Rt = 0; Rt < at.length; Rt++)
      Pt.on(at[Rt], this.emit.bind(this, at[Rt]));
    return this._read = function(jt) {
      oe("wrapped _read", jt), Wt && (Wt = !1, Pt.resume());
    }, this;
  }, Object.defineProperty(ct.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ct._fromList = ft;
  function ft(Pt, Tt) {
    if (Tt.length === 0) return null;
    var Ut;
    return Tt.objectMode ? Ut = Tt.buffer.shift() : !Pt || Pt >= Tt.length ? (Tt.decoder ? Ut = Tt.buffer.join("") : Tt.buffer.length === 1 ? Ut = Tt.buffer.head.data : Ut = Tt.buffer.concat(Tt.length), Tt.buffer.clear()) : Ut = mt(Pt, Tt.buffer, Tt.decoder), Ut;
  }
  function mt(Pt, Tt, Ut) {
    var Wt;
    return Pt < Tt.head.data.length ? (Wt = Tt.head.data.slice(0, Pt), Tt.head.data = Tt.head.data.slice(Pt)) : Pt === Tt.head.data.length ? Wt = Tt.shift() : Wt = Ut ? lt(Pt, Tt) : St(Pt, Tt), Wt;
  }
  function lt(Pt, Tt) {
    var Ut = Tt.head, Wt = 1, It = Ut.data;
    for (Pt -= It.length; Ut = Ut.next; ) {
      var Rt = Ut.data, jt = Pt > Rt.length ? Rt.length : Pt;
      if (jt === Rt.length ? It += Rt : It += Rt.slice(0, Pt), Pt -= jt, Pt === 0) {
        jt === Rt.length ? (++Wt, Ut.next ? Tt.head = Ut.next : Tt.head = Tt.tail = null) : (Tt.head = Ut, Ut.data = Rt.slice(jt));
        break;
      }
      ++Wt;
    }
    return Tt.length -= Wt, It;
  }
  function St(Pt, Tt) {
    var Ut = W.allocUnsafe(Pt), Wt = Tt.head, It = 1;
    for (Wt.data.copy(Ut), Pt -= Wt.data.length; Wt = Wt.next; ) {
      var Rt = Wt.data, jt = Pt > Rt.length ? Rt.length : Pt;
      if (Rt.copy(Ut, Ut.length - Pt, 0, jt), Pt -= jt, Pt === 0) {
        jt === Rt.length ? (++It, Wt.next ? Tt.head = Wt.next : Tt.head = Tt.tail = null) : (Tt.head = Wt, Wt.data = Rt.slice(jt));
        break;
      }
      ++It;
    }
    return Tt.length -= It, Ut;
  }
  function Ft(Pt) {
    var Tt = Pt._readableState;
    if (Tt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Tt.endEmitted || (Tt.ended = !0, A.nextTick(Gt, Tt, Pt));
  }
  function Gt(Pt, Tt) {
    !Pt.endEmitted && Pt.length === 0 && (Pt.endEmitted = !0, Tt.readable = !1, Tt.emit("end"));
  }
  function qt(Pt, Tt) {
    for (var Ut = 0, Wt = Pt.length; Ut < Wt; Ut++)
      if (Pt[Ut] === Tt) return Ut;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = K;
  var A = require_stream_duplex(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(K, A);
  function L(J, ne) {
    var ie = this._transformState;
    ie.transforming = !1;
    var ce = ie.writecb;
    if (!ce)
      return this.emit("error", new Error("write callback called multiple times"));
    ie.writechunk = null, ie.writecb = null, ne != null && this.push(ne), ce(J);
    var re = this._readableState;
    re.reading = !1, (re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark);
  }
  function K(J) {
    if (!(this instanceof K)) return new K(J);
    A.call(this, J), this._transformState = {
      afterTransform: L.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, J && (typeof J.transform == "function" && (this._transform = J.transform), typeof J.flush == "function" && (this._flush = J.flush)), this.on("prefinish", V);
  }
  function V() {
    var J = this;
    typeof this._flush == "function" ? this._flush(function(ne, ie) {
      W(J, ne, ie);
    }) : W(this, null, null);
  }
  K.prototype.push = function(J, ne) {
    return this._transformState.needTransform = !1, A.prototype.push.call(this, J, ne);
  }, K.prototype._transform = function(J, ne, ie) {
    throw new Error("_transform() is not implemented");
  }, K.prototype._write = function(J, ne, ie) {
    var ce = this._transformState;
    if (ce.writecb = ie, ce.writechunk = J, ce.writeencoding = ne, !ce.transforming) {
      var re = this._readableState;
      (ce.needTransform || re.needReadable || re.length < re.highWaterMark) && this._read(re.highWaterMark);
    }
  }, K.prototype._read = function(J) {
    var ne = this._transformState;
    ne.writechunk !== null && ne.writecb && !ne.transforming ? (ne.transforming = !0, this._transform(ne.writechunk, ne.writeencoding, ne.afterTransform)) : ne.needTransform = !0;
  }, K.prototype._destroy = function(J, ne) {
    var ie = this;
    A.prototype._destroy.call(this, J, function(ce) {
      ne(ce), ie.emit("close");
    });
  };
  function W(J, ne, ie) {
    if (ne) return J.emit("error", ne);
    if (ie != null && J.push(ie), J._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (J._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return J.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = L;
  var A = require_stream_transform(), B = Object.create(requireUtil());
  B.inherits = requireInherits_browser(), B.inherits(L, A);
  function L(K) {
    if (!(this instanceof L)) return new L(K);
    A.call(this, K);
  }
  return L.prototype._transform = function(K, V, W) {
    W(null, K);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(A, B) {
    B = A.exports = require_stream_readable(), B.Stream = B, B.Readable = B, B.Writable = require_stream_writable(), B.Duplex = require_stream_duplex(), B.Transform = require_stream_transform(), B.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(A) {
    (function(B, L) {
      function K(Ce, pe) {
        if (!Ce) throw new Error(pe || "Assertion failed");
      }
      function V(Ce, pe) {
        Ce.super_ = pe;
        var nt = function() {
        };
        nt.prototype = pe.prototype, Ce.prototype = new nt(), Ce.prototype.constructor = Ce;
      }
      function W(Ce, pe, nt) {
        if (W.isBN(Ce))
          return Ce;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Ce !== null && ((pe === "le" || pe === "be") && (nt = pe, pe = 10), this._init(Ce || 0, pe || 10, nt || "be"));
      }
      typeof B == "object" ? B.exports = W : L.BN = W, W.BN = W, W.wordSize = 26;
      var J;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? J = window.Buffer : J = require$$0$1.Buffer;
      } catch {
      }
      W.isBN = function(pe) {
        return pe instanceof W ? !0 : pe !== null && typeof pe == "object" && pe.constructor.wordSize === W.wordSize && Array.isArray(pe.words);
      }, W.max = function(pe, nt) {
        return pe.cmp(nt) > 0 ? pe : nt;
      }, W.min = function(pe, nt) {
        return pe.cmp(nt) < 0 ? pe : nt;
      }, W.prototype._init = function(pe, nt, st) {
        if (typeof pe == "number")
          return this._initNumber(pe, nt, st);
        if (typeof pe == "object")
          return this._initArray(pe, nt, st);
        nt === "hex" && (nt = 16), K(nt === (nt | 0) && nt >= 2 && nt <= 36), pe = pe.toString().replace(/\s+/g, "");
        var ot = 0;
        pe[0] === "-" && (ot++, this.negative = 1), ot < pe.length && (nt === 16 ? this._parseHex(pe, ot, st) : (this._parseBase(pe, nt, ot), st === "le" && this._initArray(this.toArray(), nt, st)));
      }, W.prototype._initNumber = function(pe, nt, st) {
        pe < 0 && (this.negative = 1, pe = -pe), pe < 67108864 ? (this.words = [pe & 67108863], this.length = 1) : pe < 4503599627370496 ? (this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863
        ], this.length = 2) : (K(pe < 9007199254740992), this.words = [
          pe & 67108863,
          pe / 67108864 & 67108863,
          1
        ], this.length = 3), st === "le" && this._initArray(this.toArray(), nt, st);
      }, W.prototype._initArray = function(pe, nt, st) {
        if (K(typeof pe.length == "number"), pe.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(pe.length / 3), this.words = new Array(this.length);
        for (var ot = 0; ot < this.length; ot++)
          this.words[ot] = 0;
        var ht, pt, ft = 0;
        if (st === "be")
          for (ot = pe.length - 1, ht = 0; ot >= 0; ot -= 3)
            pt = pe[ot] | pe[ot - 1] << 8 | pe[ot - 2] << 16, this.words[ht] |= pt << ft & 67108863, this.words[ht + 1] = pt >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, ht++);
        else if (st === "le")
          for (ot = 0, ht = 0; ot < pe.length; ot += 3)
            pt = pe[ot] | pe[ot + 1] << 8 | pe[ot + 2] << 16, this.words[ht] |= pt << ft & 67108863, this.words[ht + 1] = pt >>> 26 - ft & 67108863, ft += 24, ft >= 26 && (ft -= 26, ht++);
        return this._strip();
      };
      function ne(Ce, pe) {
        var nt = Ce.charCodeAt(pe);
        if (nt >= 48 && nt <= 57)
          return nt - 48;
        if (nt >= 65 && nt <= 70)
          return nt - 55;
        if (nt >= 97 && nt <= 102)
          return nt - 87;
        K(!1, "Invalid character in " + Ce);
      }
      function ie(Ce, pe, nt) {
        var st = ne(Ce, nt);
        return nt - 1 >= pe && (st |= ne(Ce, nt - 1) << 4), st;
      }
      W.prototype._parseHex = function(pe, nt, st) {
        this.length = Math.ceil((pe.length - nt) / 6), this.words = new Array(this.length);
        for (var ot = 0; ot < this.length; ot++)
          this.words[ot] = 0;
        var ht = 0, pt = 0, ft;
        if (st === "be")
          for (ot = pe.length - 1; ot >= nt; ot -= 2)
            ft = ie(pe, nt, ot) << ht, this.words[pt] |= ft & 67108863, ht >= 18 ? (ht -= 18, pt += 1, this.words[pt] |= ft >>> 26) : ht += 8;
        else {
          var mt = pe.length - nt;
          for (ot = mt % 2 === 0 ? nt + 1 : nt; ot < pe.length; ot += 2)
            ft = ie(pe, nt, ot) << ht, this.words[pt] |= ft & 67108863, ht >= 18 ? (ht -= 18, pt += 1, this.words[pt] |= ft >>> 26) : ht += 8;
        }
        this._strip();
      };
      function ce(Ce, pe, nt, st) {
        for (var ot = 0, ht = 0, pt = Math.min(Ce.length, nt), ft = pe; ft < pt; ft++) {
          var mt = Ce.charCodeAt(ft) - 48;
          ot *= st, mt >= 49 ? ht = mt - 49 + 10 : mt >= 17 ? ht = mt - 17 + 10 : ht = mt, K(mt >= 0 && ht < st, "Invalid character"), ot += ht;
        }
        return ot;
      }
      W.prototype._parseBase = function(pe, nt, st) {
        this.words = [0], this.length = 1;
        for (var ot = 0, ht = 1; ht <= 67108863; ht *= nt)
          ot++;
        ot--, ht = ht / nt | 0;
        for (var pt = pe.length - st, ft = pt % ot, mt = Math.min(pt, pt - ft) + st, lt = 0, St = st; St < mt; St += ot)
          lt = ce(pe, St, St + ot, nt), this.imuln(ht), this.words[0] + lt < 67108864 ? this.words[0] += lt : this._iaddn(lt);
        if (ft !== 0) {
          var Ft = 1;
          for (lt = ce(pe, St, pe.length, nt), St = 0; St < ft; St++)
            Ft *= nt;
          this.imuln(Ft), this.words[0] + lt < 67108864 ? this.words[0] += lt : this._iaddn(lt);
        }
        this._strip();
      }, W.prototype.copy = function(pe) {
        pe.words = new Array(this.length);
        for (var nt = 0; nt < this.length; nt++)
          pe.words[nt] = this.words[nt];
        pe.length = this.length, pe.negative = this.negative, pe.red = this.red;
      };
      function re(Ce, pe) {
        Ce.words = pe.words, Ce.length = pe.length, Ce.negative = pe.negative, Ce.red = pe.red;
      }
      if (W.prototype._move = function(pe) {
        re(pe, this);
      }, W.prototype.clone = function() {
        var pe = new W(null);
        return this.copy(pe), pe;
      }, W.prototype._expand = function(pe) {
        for (; this.length < pe; )
          this.words[this.length++] = 0;
        return this;
      }, W.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, W.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          W.prototype[Symbol.for("nodejs.util.inspect.custom")] = oe;
        } catch {
          W.prototype.inspect = oe;
        }
      else
        W.prototype.inspect = oe;
      function oe() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var ke = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Oe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], it = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      W.prototype.toString = function(pe, nt) {
        pe = pe || 10, nt = nt | 0 || 1;
        var st;
        if (pe === 16 || pe === "hex") {
          st = "";
          for (var ot = 0, ht = 0, pt = 0; pt < this.length; pt++) {
            var ft = this.words[pt], mt = ((ft << ot | ht) & 16777215).toString(16);
            ht = ft >>> 24 - ot & 16777215, ot += 2, ot >= 26 && (ot -= 26, pt--), ht !== 0 || pt !== this.length - 1 ? st = ke[6 - mt.length] + mt + st : st = mt + st;
          }
          for (ht !== 0 && (st = ht.toString(16) + st); st.length % nt !== 0; )
            st = "0" + st;
          return this.negative !== 0 && (st = "-" + st), st;
        }
        if (pe === (pe | 0) && pe >= 2 && pe <= 36) {
          var lt = Oe[pe], St = it[pe];
          st = "";
          var Ft = this.clone();
          for (Ft.negative = 0; !Ft.isZero(); ) {
            var Gt = Ft.modrn(St).toString(pe);
            Ft = Ft.idivn(St), Ft.isZero() ? st = Gt + st : st = ke[lt - Gt.length] + Gt + st;
          }
          for (this.isZero() && (st = "0" + st); st.length % nt !== 0; )
            st = "0" + st;
          return this.negative !== 0 && (st = "-" + st), st;
        }
        K(!1, "Base should be between 2 and 36");
      }, W.prototype.toNumber = function() {
        var pe = this.words[0];
        return this.length === 2 ? pe += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? pe += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && K(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -pe : pe;
      }, W.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, J && (W.prototype.toBuffer = function(pe, nt) {
        return this.toArrayLike(J, pe, nt);
      }), W.prototype.toArray = function(pe, nt) {
        return this.toArrayLike(Array, pe, nt);
      };
      var at = function(pe, nt) {
        return pe.allocUnsafe ? pe.allocUnsafe(nt) : new pe(nt);
      };
      W.prototype.toArrayLike = function(pe, nt, st) {
        this._strip();
        var ot = this.byteLength(), ht = st || Math.max(1, ot);
        K(ot <= ht, "byte array longer than desired length"), K(ht > 0, "Requested array length <= 0");
        var pt = at(pe, ht), ft = nt === "le" ? "LE" : "BE";
        return this["_toArrayLike" + ft](pt, ot), pt;
      }, W.prototype._toArrayLikeLE = function(pe, nt) {
        for (var st = 0, ot = 0, ht = 0, pt = 0; ht < this.length; ht++) {
          var ft = this.words[ht] << pt | ot;
          pe[st++] = ft & 255, st < pe.length && (pe[st++] = ft >> 8 & 255), st < pe.length && (pe[st++] = ft >> 16 & 255), pt === 6 ? (st < pe.length && (pe[st++] = ft >> 24 & 255), ot = 0, pt = 0) : (ot = ft >>> 24, pt += 2);
        }
        if (st < pe.length)
          for (pe[st++] = ot; st < pe.length; )
            pe[st++] = 0;
      }, W.prototype._toArrayLikeBE = function(pe, nt) {
        for (var st = pe.length - 1, ot = 0, ht = 0, pt = 0; ht < this.length; ht++) {
          var ft = this.words[ht] << pt | ot;
          pe[st--] = ft & 255, st >= 0 && (pe[st--] = ft >> 8 & 255), st >= 0 && (pe[st--] = ft >> 16 & 255), pt === 6 ? (st >= 0 && (pe[st--] = ft >> 24 & 255), ot = 0, pt = 0) : (ot = ft >>> 24, pt += 2);
        }
        if (st >= 0)
          for (pe[st--] = ot; st >= 0; )
            pe[st--] = 0;
      }, Math.clz32 ? W.prototype._countBits = function(pe) {
        return 32 - Math.clz32(pe);
      } : W.prototype._countBits = function(pe) {
        var nt = pe, st = 0;
        return nt >= 4096 && (st += 13, nt >>>= 13), nt >= 64 && (st += 7, nt >>>= 7), nt >= 8 && (st += 4, nt >>>= 4), nt >= 2 && (st += 2, nt >>>= 2), st + nt;
      }, W.prototype._zeroBits = function(pe) {
        if (pe === 0) return 26;
        var nt = pe, st = 0;
        return nt & 8191 || (st += 13, nt >>>= 13), nt & 127 || (st += 7, nt >>>= 7), nt & 15 || (st += 4, nt >>>= 4), nt & 3 || (st += 2, nt >>>= 2), nt & 1 || st++, st;
      }, W.prototype.bitLength = function() {
        var pe = this.words[this.length - 1], nt = this._countBits(pe);
        return (this.length - 1) * 26 + nt;
      };
      function ut(Ce) {
        for (var pe = new Array(Ce.bitLength()), nt = 0; nt < pe.length; nt++) {
          var st = nt / 26 | 0, ot = nt % 26;
          pe[nt] = Ce.words[st] >>> ot & 1;
        }
        return pe;
      }
      W.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var pe = 0, nt = 0; nt < this.length; nt++) {
          var st = this._zeroBits(this.words[nt]);
          if (pe += st, st !== 26) break;
        }
        return pe;
      }, W.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, W.prototype.toTwos = function(pe) {
        return this.negative !== 0 ? this.abs().inotn(pe).iaddn(1) : this.clone();
      }, W.prototype.fromTwos = function(pe) {
        return this.testn(pe - 1) ? this.notn(pe).iaddn(1).ineg() : this.clone();
      }, W.prototype.isNeg = function() {
        return this.negative !== 0;
      }, W.prototype.neg = function() {
        return this.clone().ineg();
      }, W.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, W.prototype.iuor = function(pe) {
        for (; this.length < pe.length; )
          this.words[this.length++] = 0;
        for (var nt = 0; nt < pe.length; nt++)
          this.words[nt] = this.words[nt] | pe.words[nt];
        return this._strip();
      }, W.prototype.ior = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuor(pe);
      }, W.prototype.or = function(pe) {
        return this.length > pe.length ? this.clone().ior(pe) : pe.clone().ior(this);
      }, W.prototype.uor = function(pe) {
        return this.length > pe.length ? this.clone().iuor(pe) : pe.clone().iuor(this);
      }, W.prototype.iuand = function(pe) {
        var nt;
        this.length > pe.length ? nt = pe : nt = this;
        for (var st = 0; st < nt.length; st++)
          this.words[st] = this.words[st] & pe.words[st];
        return this.length = nt.length, this._strip();
      }, W.prototype.iand = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuand(pe);
      }, W.prototype.and = function(pe) {
        return this.length > pe.length ? this.clone().iand(pe) : pe.clone().iand(this);
      }, W.prototype.uand = function(pe) {
        return this.length > pe.length ? this.clone().iuand(pe) : pe.clone().iuand(this);
      }, W.prototype.iuxor = function(pe) {
        var nt, st;
        this.length > pe.length ? (nt = this, st = pe) : (nt = pe, st = this);
        for (var ot = 0; ot < st.length; ot++)
          this.words[ot] = nt.words[ot] ^ st.words[ot];
        if (this !== nt)
          for (; ot < nt.length; ot++)
            this.words[ot] = nt.words[ot];
        return this.length = nt.length, this._strip();
      }, W.prototype.ixor = function(pe) {
        return K((this.negative | pe.negative) === 0), this.iuxor(pe);
      }, W.prototype.xor = function(pe) {
        return this.length > pe.length ? this.clone().ixor(pe) : pe.clone().ixor(this);
      }, W.prototype.uxor = function(pe) {
        return this.length > pe.length ? this.clone().iuxor(pe) : pe.clone().iuxor(this);
      }, W.prototype.inotn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = Math.ceil(pe / 26) | 0, st = pe % 26;
        this._expand(nt), st > 0 && nt--;
        for (var ot = 0; ot < nt; ot++)
          this.words[ot] = ~this.words[ot] & 67108863;
        return st > 0 && (this.words[ot] = ~this.words[ot] & 67108863 >> 26 - st), this._strip();
      }, W.prototype.notn = function(pe) {
        return this.clone().inotn(pe);
      }, W.prototype.setn = function(pe, nt) {
        K(typeof pe == "number" && pe >= 0);
        var st = pe / 26 | 0, ot = pe % 26;
        return this._expand(st + 1), nt ? this.words[st] = this.words[st] | 1 << ot : this.words[st] = this.words[st] & ~(1 << ot), this._strip();
      }, W.prototype.iadd = function(pe) {
        var nt;
        if (this.negative !== 0 && pe.negative === 0)
          return this.negative = 0, nt = this.isub(pe), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && pe.negative !== 0)
          return pe.negative = 0, nt = this.isub(pe), pe.negative = 1, nt._normSign();
        var st, ot;
        this.length > pe.length ? (st = this, ot = pe) : (st = pe, ot = this);
        for (var ht = 0, pt = 0; pt < ot.length; pt++)
          nt = (st.words[pt] | 0) + (ot.words[pt] | 0) + ht, this.words[pt] = nt & 67108863, ht = nt >>> 26;
        for (; ht !== 0 && pt < st.length; pt++)
          nt = (st.words[pt] | 0) + ht, this.words[pt] = nt & 67108863, ht = nt >>> 26;
        if (this.length = st.length, ht !== 0)
          this.words[this.length] = ht, this.length++;
        else if (st !== this)
          for (; pt < st.length; pt++)
            this.words[pt] = st.words[pt];
        return this;
      }, W.prototype.add = function(pe) {
        var nt;
        return pe.negative !== 0 && this.negative === 0 ? (pe.negative = 0, nt = this.sub(pe), pe.negative ^= 1, nt) : pe.negative === 0 && this.negative !== 0 ? (this.negative = 0, nt = pe.sub(this), this.negative = 1, nt) : this.length > pe.length ? this.clone().iadd(pe) : pe.clone().iadd(this);
      }, W.prototype.isub = function(pe) {
        if (pe.negative !== 0) {
          pe.negative = 0;
          var nt = this.iadd(pe);
          return pe.negative = 1, nt._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(pe), this.negative = 1, this._normSign();
        var st = this.cmp(pe);
        if (st === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var ot, ht;
        st > 0 ? (ot = this, ht = pe) : (ot = pe, ht = this);
        for (var pt = 0, ft = 0; ft < ht.length; ft++)
          nt = (ot.words[ft] | 0) - (ht.words[ft] | 0) + pt, pt = nt >> 26, this.words[ft] = nt & 67108863;
        for (; pt !== 0 && ft < ot.length; ft++)
          nt = (ot.words[ft] | 0) + pt, pt = nt >> 26, this.words[ft] = nt & 67108863;
        if (pt === 0 && ft < ot.length && ot !== this)
          for (; ft < ot.length; ft++)
            this.words[ft] = ot.words[ft];
        return this.length = Math.max(this.length, ft), ot !== this && (this.negative = 1), this._strip();
      }, W.prototype.sub = function(pe) {
        return this.clone().isub(pe);
      };
      function dt(Ce, pe, nt) {
        nt.negative = pe.negative ^ Ce.negative;
        var st = Ce.length + pe.length | 0;
        nt.length = st, st = st - 1 | 0;
        var ot = Ce.words[0] | 0, ht = pe.words[0] | 0, pt = ot * ht, ft = pt & 67108863, mt = pt / 67108864 | 0;
        nt.words[0] = ft;
        for (var lt = 1; lt < st; lt++) {
          for (var St = mt >>> 26, Ft = mt & 67108863, Gt = Math.min(lt, pe.length - 1), qt = Math.max(0, lt - Ce.length + 1); qt <= Gt; qt++) {
            var Pt = lt - qt | 0;
            ot = Ce.words[Pt] | 0, ht = pe.words[qt] | 0, pt = ot * ht + Ft, St += pt / 67108864 | 0, Ft = pt & 67108863;
          }
          nt.words[lt] = Ft | 0, mt = St | 0;
        }
        return mt !== 0 ? nt.words[lt] = mt | 0 : nt.length--, nt._strip();
      }
      var ct = function(pe, nt, st) {
        var ot = pe.words, ht = nt.words, pt = st.words, ft = 0, mt, lt, St, Ft = ot[0] | 0, Gt = Ft & 8191, qt = Ft >>> 13, Pt = ot[1] | 0, Tt = Pt & 8191, Ut = Pt >>> 13, Wt = ot[2] | 0, It = Wt & 8191, Rt = Wt >>> 13, jt = ot[3] | 0, Jt = jt & 8191, er = jt >>> 13, nr = ot[4] | 0, fr = nr & 8191, lr = nr >>> 13, Yt = ot[5] | 0, Pr = Yt & 8191, or = Yt >>> 13, Ar = ot[6] | 0, Br = Ar & 8191, cr = Ar >>> 13, xr = ot[7] | 0, Ir = xr & 8191, gr = xr >>> 13, Rr = ot[8] | 0, Or = Rr & 8191, Mt = Rr >>> 13, wt = ot[9] | 0, Et = wt & 8191, Ct = wt >>> 13, Kt = ht[0] | 0, Vt = Kt & 8191, zt = Kt >>> 13, yr = ht[1] | 0, $r = yr & 8191, hr = yr >>> 13, Er = ht[2] | 0, Sr = Er & 8191, wr = Er >>> 13, Mr = ht[3] | 0, Cr = Mr & 8191, Lt = Mr >>> 13, kt = ht[4] | 0, Dt = kt & 8191, Ht = kt >>> 13, Xt = ht[5] | 0, Zt = Xt & 8191, tr = Xt >>> 13, ir = ht[6] | 0, ur = ir & 8191, sr = ir >>> 13, dr = ht[7] | 0, vr = dr & 8191, Nt = dr >>> 13, Qt = ht[8] | 0, rr = Qt & 8191, ar = Qt >>> 13, br = ht[9] | 0, _r = br & 8191, pr = br >>> 13;
        st.negative = pe.negative ^ nt.negative, st.length = 19, mt = Math.imul(Gt, Vt), lt = Math.imul(Gt, zt), lt = lt + Math.imul(qt, Vt) | 0, St = Math.imul(qt, zt);
        var Tr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Tr >>> 26) | 0, Tr &= 67108863, mt = Math.imul(Tt, Vt), lt = Math.imul(Tt, zt), lt = lt + Math.imul(Ut, Vt) | 0, St = Math.imul(Ut, zt), mt = mt + Math.imul(Gt, $r) | 0, lt = lt + Math.imul(Gt, hr) | 0, lt = lt + Math.imul(qt, $r) | 0, St = St + Math.imul(qt, hr) | 0;
        var Nr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Nr >>> 26) | 0, Nr &= 67108863, mt = Math.imul(It, Vt), lt = Math.imul(It, zt), lt = lt + Math.imul(Rt, Vt) | 0, St = Math.imul(Rt, zt), mt = mt + Math.imul(Tt, $r) | 0, lt = lt + Math.imul(Tt, hr) | 0, lt = lt + Math.imul(Ut, $r) | 0, St = St + Math.imul(Ut, hr) | 0, mt = mt + Math.imul(Gt, Sr) | 0, lt = lt + Math.imul(Gt, wr) | 0, lt = lt + Math.imul(qt, Sr) | 0, St = St + Math.imul(qt, wr) | 0;
        var kr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (kr >>> 26) | 0, kr &= 67108863, mt = Math.imul(Jt, Vt), lt = Math.imul(Jt, zt), lt = lt + Math.imul(er, Vt) | 0, St = Math.imul(er, zt), mt = mt + Math.imul(It, $r) | 0, lt = lt + Math.imul(It, hr) | 0, lt = lt + Math.imul(Rt, $r) | 0, St = St + Math.imul(Rt, hr) | 0, mt = mt + Math.imul(Tt, Sr) | 0, lt = lt + Math.imul(Tt, wr) | 0, lt = lt + Math.imul(Ut, Sr) | 0, St = St + Math.imul(Ut, wr) | 0, mt = mt + Math.imul(Gt, Cr) | 0, lt = lt + Math.imul(Gt, Lt) | 0, lt = lt + Math.imul(qt, Cr) | 0, St = St + Math.imul(qt, Lt) | 0;
        var qr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, mt = Math.imul(fr, Vt), lt = Math.imul(fr, zt), lt = lt + Math.imul(lr, Vt) | 0, St = Math.imul(lr, zt), mt = mt + Math.imul(Jt, $r) | 0, lt = lt + Math.imul(Jt, hr) | 0, lt = lt + Math.imul(er, $r) | 0, St = St + Math.imul(er, hr) | 0, mt = mt + Math.imul(It, Sr) | 0, lt = lt + Math.imul(It, wr) | 0, lt = lt + Math.imul(Rt, Sr) | 0, St = St + Math.imul(Rt, wr) | 0, mt = mt + Math.imul(Tt, Cr) | 0, lt = lt + Math.imul(Tt, Lt) | 0, lt = lt + Math.imul(Ut, Cr) | 0, St = St + Math.imul(Ut, Lt) | 0, mt = mt + Math.imul(Gt, Dt) | 0, lt = lt + Math.imul(Gt, Ht) | 0, lt = lt + Math.imul(qt, Dt) | 0, St = St + Math.imul(qt, Ht) | 0;
        var Lr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Lr >>> 26) | 0, Lr &= 67108863, mt = Math.imul(Pr, Vt), lt = Math.imul(Pr, zt), lt = lt + Math.imul(or, Vt) | 0, St = Math.imul(or, zt), mt = mt + Math.imul(fr, $r) | 0, lt = lt + Math.imul(fr, hr) | 0, lt = lt + Math.imul(lr, $r) | 0, St = St + Math.imul(lr, hr) | 0, mt = mt + Math.imul(Jt, Sr) | 0, lt = lt + Math.imul(Jt, wr) | 0, lt = lt + Math.imul(er, Sr) | 0, St = St + Math.imul(er, wr) | 0, mt = mt + Math.imul(It, Cr) | 0, lt = lt + Math.imul(It, Lt) | 0, lt = lt + Math.imul(Rt, Cr) | 0, St = St + Math.imul(Rt, Lt) | 0, mt = mt + Math.imul(Tt, Dt) | 0, lt = lt + Math.imul(Tt, Ht) | 0, lt = lt + Math.imul(Ut, Dt) | 0, St = St + Math.imul(Ut, Ht) | 0, mt = mt + Math.imul(Gt, Zt) | 0, lt = lt + Math.imul(Gt, tr) | 0, lt = lt + Math.imul(qt, Zt) | 0, St = St + Math.imul(qt, tr) | 0;
        var Dr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, mt = Math.imul(Br, Vt), lt = Math.imul(Br, zt), lt = lt + Math.imul(cr, Vt) | 0, St = Math.imul(cr, zt), mt = mt + Math.imul(Pr, $r) | 0, lt = lt + Math.imul(Pr, hr) | 0, lt = lt + Math.imul(or, $r) | 0, St = St + Math.imul(or, hr) | 0, mt = mt + Math.imul(fr, Sr) | 0, lt = lt + Math.imul(fr, wr) | 0, lt = lt + Math.imul(lr, Sr) | 0, St = St + Math.imul(lr, wr) | 0, mt = mt + Math.imul(Jt, Cr) | 0, lt = lt + Math.imul(Jt, Lt) | 0, lt = lt + Math.imul(er, Cr) | 0, St = St + Math.imul(er, Lt) | 0, mt = mt + Math.imul(It, Dt) | 0, lt = lt + Math.imul(It, Ht) | 0, lt = lt + Math.imul(Rt, Dt) | 0, St = St + Math.imul(Rt, Ht) | 0, mt = mt + Math.imul(Tt, Zt) | 0, lt = lt + Math.imul(Tt, tr) | 0, lt = lt + Math.imul(Ut, Zt) | 0, St = St + Math.imul(Ut, tr) | 0, mt = mt + Math.imul(Gt, ur) | 0, lt = lt + Math.imul(Gt, sr) | 0, lt = lt + Math.imul(qt, ur) | 0, St = St + Math.imul(qt, sr) | 0;
        var Ur = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Ur >>> 26) | 0, Ur &= 67108863, mt = Math.imul(Ir, Vt), lt = Math.imul(Ir, zt), lt = lt + Math.imul(gr, Vt) | 0, St = Math.imul(gr, zt), mt = mt + Math.imul(Br, $r) | 0, lt = lt + Math.imul(Br, hr) | 0, lt = lt + Math.imul(cr, $r) | 0, St = St + Math.imul(cr, hr) | 0, mt = mt + Math.imul(Pr, Sr) | 0, lt = lt + Math.imul(Pr, wr) | 0, lt = lt + Math.imul(or, Sr) | 0, St = St + Math.imul(or, wr) | 0, mt = mt + Math.imul(fr, Cr) | 0, lt = lt + Math.imul(fr, Lt) | 0, lt = lt + Math.imul(lr, Cr) | 0, St = St + Math.imul(lr, Lt) | 0, mt = mt + Math.imul(Jt, Dt) | 0, lt = lt + Math.imul(Jt, Ht) | 0, lt = lt + Math.imul(er, Dt) | 0, St = St + Math.imul(er, Ht) | 0, mt = mt + Math.imul(It, Zt) | 0, lt = lt + Math.imul(It, tr) | 0, lt = lt + Math.imul(Rt, Zt) | 0, St = St + Math.imul(Rt, tr) | 0, mt = mt + Math.imul(Tt, ur) | 0, lt = lt + Math.imul(Tt, sr) | 0, lt = lt + Math.imul(Ut, ur) | 0, St = St + Math.imul(Ut, sr) | 0, mt = mt + Math.imul(Gt, vr) | 0, lt = lt + Math.imul(Gt, Nt) | 0, lt = lt + Math.imul(qt, vr) | 0, St = St + Math.imul(qt, Nt) | 0;
        var Fr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Fr >>> 26) | 0, Fr &= 67108863, mt = Math.imul(Or, Vt), lt = Math.imul(Or, zt), lt = lt + Math.imul(Mt, Vt) | 0, St = Math.imul(Mt, zt), mt = mt + Math.imul(Ir, $r) | 0, lt = lt + Math.imul(Ir, hr) | 0, lt = lt + Math.imul(gr, $r) | 0, St = St + Math.imul(gr, hr) | 0, mt = mt + Math.imul(Br, Sr) | 0, lt = lt + Math.imul(Br, wr) | 0, lt = lt + Math.imul(cr, Sr) | 0, St = St + Math.imul(cr, wr) | 0, mt = mt + Math.imul(Pr, Cr) | 0, lt = lt + Math.imul(Pr, Lt) | 0, lt = lt + Math.imul(or, Cr) | 0, St = St + Math.imul(or, Lt) | 0, mt = mt + Math.imul(fr, Dt) | 0, lt = lt + Math.imul(fr, Ht) | 0, lt = lt + Math.imul(lr, Dt) | 0, St = St + Math.imul(lr, Ht) | 0, mt = mt + Math.imul(Jt, Zt) | 0, lt = lt + Math.imul(Jt, tr) | 0, lt = lt + Math.imul(er, Zt) | 0, St = St + Math.imul(er, tr) | 0, mt = mt + Math.imul(It, ur) | 0, lt = lt + Math.imul(It, sr) | 0, lt = lt + Math.imul(Rt, ur) | 0, St = St + Math.imul(Rt, sr) | 0, mt = mt + Math.imul(Tt, vr) | 0, lt = lt + Math.imul(Tt, Nt) | 0, lt = lt + Math.imul(Ut, vr) | 0, St = St + Math.imul(Ut, Nt) | 0, mt = mt + Math.imul(Gt, rr) | 0, lt = lt + Math.imul(Gt, ar) | 0, lt = lt + Math.imul(qt, rr) | 0, St = St + Math.imul(qt, ar) | 0;
        var jr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (jr >>> 26) | 0, jr &= 67108863, mt = Math.imul(Et, Vt), lt = Math.imul(Et, zt), lt = lt + Math.imul(Ct, Vt) | 0, St = Math.imul(Ct, zt), mt = mt + Math.imul(Or, $r) | 0, lt = lt + Math.imul(Or, hr) | 0, lt = lt + Math.imul(Mt, $r) | 0, St = St + Math.imul(Mt, hr) | 0, mt = mt + Math.imul(Ir, Sr) | 0, lt = lt + Math.imul(Ir, wr) | 0, lt = lt + Math.imul(gr, Sr) | 0, St = St + Math.imul(gr, wr) | 0, mt = mt + Math.imul(Br, Cr) | 0, lt = lt + Math.imul(Br, Lt) | 0, lt = lt + Math.imul(cr, Cr) | 0, St = St + Math.imul(cr, Lt) | 0, mt = mt + Math.imul(Pr, Dt) | 0, lt = lt + Math.imul(Pr, Ht) | 0, lt = lt + Math.imul(or, Dt) | 0, St = St + Math.imul(or, Ht) | 0, mt = mt + Math.imul(fr, Zt) | 0, lt = lt + Math.imul(fr, tr) | 0, lt = lt + Math.imul(lr, Zt) | 0, St = St + Math.imul(lr, tr) | 0, mt = mt + Math.imul(Jt, ur) | 0, lt = lt + Math.imul(Jt, sr) | 0, lt = lt + Math.imul(er, ur) | 0, St = St + Math.imul(er, sr) | 0, mt = mt + Math.imul(It, vr) | 0, lt = lt + Math.imul(It, Nt) | 0, lt = lt + Math.imul(Rt, vr) | 0, St = St + Math.imul(Rt, Nt) | 0, mt = mt + Math.imul(Tt, rr) | 0, lt = lt + Math.imul(Tt, ar) | 0, lt = lt + Math.imul(Ut, rr) | 0, St = St + Math.imul(Ut, ar) | 0, mt = mt + Math.imul(Gt, _r) | 0, lt = lt + Math.imul(Gt, pr) | 0, lt = lt + Math.imul(qt, _r) | 0, St = St + Math.imul(qt, pr) | 0;
        var Hr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Hr >>> 26) | 0, Hr &= 67108863, mt = Math.imul(Et, $r), lt = Math.imul(Et, hr), lt = lt + Math.imul(Ct, $r) | 0, St = Math.imul(Ct, hr), mt = mt + Math.imul(Or, Sr) | 0, lt = lt + Math.imul(Or, wr) | 0, lt = lt + Math.imul(Mt, Sr) | 0, St = St + Math.imul(Mt, wr) | 0, mt = mt + Math.imul(Ir, Cr) | 0, lt = lt + Math.imul(Ir, Lt) | 0, lt = lt + Math.imul(gr, Cr) | 0, St = St + Math.imul(gr, Lt) | 0, mt = mt + Math.imul(Br, Dt) | 0, lt = lt + Math.imul(Br, Ht) | 0, lt = lt + Math.imul(cr, Dt) | 0, St = St + Math.imul(cr, Ht) | 0, mt = mt + Math.imul(Pr, Zt) | 0, lt = lt + Math.imul(Pr, tr) | 0, lt = lt + Math.imul(or, Zt) | 0, St = St + Math.imul(or, tr) | 0, mt = mt + Math.imul(fr, ur) | 0, lt = lt + Math.imul(fr, sr) | 0, lt = lt + Math.imul(lr, ur) | 0, St = St + Math.imul(lr, sr) | 0, mt = mt + Math.imul(Jt, vr) | 0, lt = lt + Math.imul(Jt, Nt) | 0, lt = lt + Math.imul(er, vr) | 0, St = St + Math.imul(er, Nt) | 0, mt = mt + Math.imul(It, rr) | 0, lt = lt + Math.imul(It, ar) | 0, lt = lt + Math.imul(Rt, rr) | 0, St = St + Math.imul(Rt, ar) | 0, mt = mt + Math.imul(Tt, _r) | 0, lt = lt + Math.imul(Tt, pr) | 0, lt = lt + Math.imul(Ut, _r) | 0, St = St + Math.imul(Ut, pr) | 0;
        var Wr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Wr >>> 26) | 0, Wr &= 67108863, mt = Math.imul(Et, Sr), lt = Math.imul(Et, wr), lt = lt + Math.imul(Ct, Sr) | 0, St = Math.imul(Ct, wr), mt = mt + Math.imul(Or, Cr) | 0, lt = lt + Math.imul(Or, Lt) | 0, lt = lt + Math.imul(Mt, Cr) | 0, St = St + Math.imul(Mt, Lt) | 0, mt = mt + Math.imul(Ir, Dt) | 0, lt = lt + Math.imul(Ir, Ht) | 0, lt = lt + Math.imul(gr, Dt) | 0, St = St + Math.imul(gr, Ht) | 0, mt = mt + Math.imul(Br, Zt) | 0, lt = lt + Math.imul(Br, tr) | 0, lt = lt + Math.imul(cr, Zt) | 0, St = St + Math.imul(cr, tr) | 0, mt = mt + Math.imul(Pr, ur) | 0, lt = lt + Math.imul(Pr, sr) | 0, lt = lt + Math.imul(or, ur) | 0, St = St + Math.imul(or, sr) | 0, mt = mt + Math.imul(fr, vr) | 0, lt = lt + Math.imul(fr, Nt) | 0, lt = lt + Math.imul(lr, vr) | 0, St = St + Math.imul(lr, Nt) | 0, mt = mt + Math.imul(Jt, rr) | 0, lt = lt + Math.imul(Jt, ar) | 0, lt = lt + Math.imul(er, rr) | 0, St = St + Math.imul(er, ar) | 0, mt = mt + Math.imul(It, _r) | 0, lt = lt + Math.imul(It, pr) | 0, lt = lt + Math.imul(Rt, _r) | 0, St = St + Math.imul(Rt, pr) | 0;
        var Gr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Gr >>> 26) | 0, Gr &= 67108863, mt = Math.imul(Et, Cr), lt = Math.imul(Et, Lt), lt = lt + Math.imul(Ct, Cr) | 0, St = Math.imul(Ct, Lt), mt = mt + Math.imul(Or, Dt) | 0, lt = lt + Math.imul(Or, Ht) | 0, lt = lt + Math.imul(Mt, Dt) | 0, St = St + Math.imul(Mt, Ht) | 0, mt = mt + Math.imul(Ir, Zt) | 0, lt = lt + Math.imul(Ir, tr) | 0, lt = lt + Math.imul(gr, Zt) | 0, St = St + Math.imul(gr, tr) | 0, mt = mt + Math.imul(Br, ur) | 0, lt = lt + Math.imul(Br, sr) | 0, lt = lt + Math.imul(cr, ur) | 0, St = St + Math.imul(cr, sr) | 0, mt = mt + Math.imul(Pr, vr) | 0, lt = lt + Math.imul(Pr, Nt) | 0, lt = lt + Math.imul(or, vr) | 0, St = St + Math.imul(or, Nt) | 0, mt = mt + Math.imul(fr, rr) | 0, lt = lt + Math.imul(fr, ar) | 0, lt = lt + Math.imul(lr, rr) | 0, St = St + Math.imul(lr, ar) | 0, mt = mt + Math.imul(Jt, _r) | 0, lt = lt + Math.imul(Jt, pr) | 0, lt = lt + Math.imul(er, _r) | 0, St = St + Math.imul(er, pr) | 0;
        var Vr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, mt = Math.imul(Et, Dt), lt = Math.imul(Et, Ht), lt = lt + Math.imul(Ct, Dt) | 0, St = Math.imul(Ct, Ht), mt = mt + Math.imul(Or, Zt) | 0, lt = lt + Math.imul(Or, tr) | 0, lt = lt + Math.imul(Mt, Zt) | 0, St = St + Math.imul(Mt, tr) | 0, mt = mt + Math.imul(Ir, ur) | 0, lt = lt + Math.imul(Ir, sr) | 0, lt = lt + Math.imul(gr, ur) | 0, St = St + Math.imul(gr, sr) | 0, mt = mt + Math.imul(Br, vr) | 0, lt = lt + Math.imul(Br, Nt) | 0, lt = lt + Math.imul(cr, vr) | 0, St = St + Math.imul(cr, Nt) | 0, mt = mt + Math.imul(Pr, rr) | 0, lt = lt + Math.imul(Pr, ar) | 0, lt = lt + Math.imul(or, rr) | 0, St = St + Math.imul(or, ar) | 0, mt = mt + Math.imul(fr, _r) | 0, lt = lt + Math.imul(fr, pr) | 0, lt = lt + Math.imul(lr, _r) | 0, St = St + Math.imul(lr, pr) | 0;
        var zr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, mt = Math.imul(Et, Zt), lt = Math.imul(Et, tr), lt = lt + Math.imul(Ct, Zt) | 0, St = Math.imul(Ct, tr), mt = mt + Math.imul(Or, ur) | 0, lt = lt + Math.imul(Or, sr) | 0, lt = lt + Math.imul(Mt, ur) | 0, St = St + Math.imul(Mt, sr) | 0, mt = mt + Math.imul(Ir, vr) | 0, lt = lt + Math.imul(Ir, Nt) | 0, lt = lt + Math.imul(gr, vr) | 0, St = St + Math.imul(gr, Nt) | 0, mt = mt + Math.imul(Br, rr) | 0, lt = lt + Math.imul(Br, ar) | 0, lt = lt + Math.imul(cr, rr) | 0, St = St + Math.imul(cr, ar) | 0, mt = mt + Math.imul(Pr, _r) | 0, lt = lt + Math.imul(Pr, pr) | 0, lt = lt + Math.imul(or, _r) | 0, St = St + Math.imul(or, pr) | 0;
        var Xr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, mt = Math.imul(Et, ur), lt = Math.imul(Et, sr), lt = lt + Math.imul(Ct, ur) | 0, St = Math.imul(Ct, sr), mt = mt + Math.imul(Or, vr) | 0, lt = lt + Math.imul(Or, Nt) | 0, lt = lt + Math.imul(Mt, vr) | 0, St = St + Math.imul(Mt, Nt) | 0, mt = mt + Math.imul(Ir, rr) | 0, lt = lt + Math.imul(Ir, ar) | 0, lt = lt + Math.imul(gr, rr) | 0, St = St + Math.imul(gr, ar) | 0, mt = mt + Math.imul(Br, _r) | 0, lt = lt + Math.imul(Br, pr) | 0, lt = lt + Math.imul(cr, _r) | 0, St = St + Math.imul(cr, pr) | 0;
        var Yr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, mt = Math.imul(Et, vr), lt = Math.imul(Et, Nt), lt = lt + Math.imul(Ct, vr) | 0, St = Math.imul(Ct, Nt), mt = mt + Math.imul(Or, rr) | 0, lt = lt + Math.imul(Or, ar) | 0, lt = lt + Math.imul(Mt, rr) | 0, St = St + Math.imul(Mt, ar) | 0, mt = mt + Math.imul(Ir, _r) | 0, lt = lt + Math.imul(Ir, pr) | 0, lt = lt + Math.imul(gr, _r) | 0, St = St + Math.imul(gr, pr) | 0;
        var Jr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Jr >>> 26) | 0, Jr &= 67108863, mt = Math.imul(Et, rr), lt = Math.imul(Et, ar), lt = lt + Math.imul(Ct, rr) | 0, St = Math.imul(Ct, ar), mt = mt + Math.imul(Or, _r) | 0, lt = lt + Math.imul(Or, pr) | 0, lt = lt + Math.imul(Mt, _r) | 0, St = St + Math.imul(Mt, pr) | 0;
        var Qr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        ft = (St + (lt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, mt = Math.imul(Et, _r), lt = Math.imul(Et, pr), lt = lt + Math.imul(Ct, _r) | 0, St = Math.imul(Ct, pr);
        var Zr = (ft + mt | 0) + ((lt & 8191) << 13) | 0;
        return ft = (St + (lt >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, pt[0] = Tr, pt[1] = Nr, pt[2] = kr, pt[3] = qr, pt[4] = Lr, pt[5] = Dr, pt[6] = Ur, pt[7] = Fr, pt[8] = jr, pt[9] = Hr, pt[10] = Wr, pt[11] = Gr, pt[12] = Vr, pt[13] = zr, pt[14] = Xr, pt[15] = Yr, pt[16] = Jr, pt[17] = Qr, pt[18] = Zr, ft !== 0 && (pt[19] = ft, st.length++), st;
      };
      Math.imul || (ct = dt);
      function bt(Ce, pe, nt) {
        nt.negative = pe.negative ^ Ce.negative, nt.length = Ce.length + pe.length;
        for (var st = 0, ot = 0, ht = 0; ht < nt.length - 1; ht++) {
          var pt = ot;
          ot = 0;
          for (var ft = st & 67108863, mt = Math.min(ht, pe.length - 1), lt = Math.max(0, ht - Ce.length + 1); lt <= mt; lt++) {
            var St = ht - lt, Ft = Ce.words[St] | 0, Gt = pe.words[lt] | 0, qt = Ft * Gt, Pt = qt & 67108863;
            pt = pt + (qt / 67108864 | 0) | 0, Pt = Pt + ft | 0, ft = Pt & 67108863, pt = pt + (Pt >>> 26) | 0, ot += pt >>> 26, pt &= 67108863;
          }
          nt.words[ht] = ft, st = pt, pt = ot;
        }
        return st !== 0 ? nt.words[ht] = st : nt.length--, nt._strip();
      }
      function vt(Ce, pe, nt) {
        return bt(Ce, pe, nt);
      }
      W.prototype.mulTo = function(pe, nt) {
        var st, ot = this.length + pe.length;
        return this.length === 10 && pe.length === 10 ? st = ct(this, pe, nt) : ot < 63 ? st = dt(this, pe, nt) : ot < 1024 ? st = bt(this, pe, nt) : st = vt(this, pe, nt), st;
      }, W.prototype.mul = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), this.mulTo(pe, nt);
      }, W.prototype.mulf = function(pe) {
        var nt = new W(null);
        return nt.words = new Array(this.length + pe.length), vt(this, pe, nt);
      }, W.prototype.imul = function(pe) {
        return this.clone().mulTo(pe, this);
      }, W.prototype.imuln = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(typeof pe == "number"), K(pe < 67108864);
        for (var st = 0, ot = 0; ot < this.length; ot++) {
          var ht = (this.words[ot] | 0) * pe, pt = (ht & 67108863) + (st & 67108863);
          st >>= 26, st += ht / 67108864 | 0, st += pt >>> 26, this.words[ot] = pt & 67108863;
        }
        return st !== 0 && (this.words[ot] = st, this.length++), nt ? this.ineg() : this;
      }, W.prototype.muln = function(pe) {
        return this.clone().imuln(pe);
      }, W.prototype.sqr = function() {
        return this.mul(this);
      }, W.prototype.isqr = function() {
        return this.imul(this.clone());
      }, W.prototype.pow = function(pe) {
        var nt = ut(pe);
        if (nt.length === 0) return new W(1);
        for (var st = this, ot = 0; ot < nt.length && nt[ot] === 0; ot++, st = st.sqr())
          ;
        if (++ot < nt.length)
          for (var ht = st.sqr(); ot < nt.length; ot++, ht = ht.sqr())
            nt[ot] !== 0 && (st = st.mul(ht));
        return st;
      }, W.prototype.iushln = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, st = (pe - nt) / 26, ot = 67108863 >>> 26 - nt << 26 - nt, ht;
        if (nt !== 0) {
          var pt = 0;
          for (ht = 0; ht < this.length; ht++) {
            var ft = this.words[ht] & ot, mt = (this.words[ht] | 0) - ft << nt;
            this.words[ht] = mt | pt, pt = ft >>> 26 - nt;
          }
          pt && (this.words[ht] = pt, this.length++);
        }
        if (st !== 0) {
          for (ht = this.length - 1; ht >= 0; ht--)
            this.words[ht + st] = this.words[ht];
          for (ht = 0; ht < st; ht++)
            this.words[ht] = 0;
          this.length += st;
        }
        return this._strip();
      }, W.prototype.ishln = function(pe) {
        return K(this.negative === 0), this.iushln(pe);
      }, W.prototype.iushrn = function(pe, nt, st) {
        K(typeof pe == "number" && pe >= 0);
        var ot;
        nt ? ot = (nt - nt % 26) / 26 : ot = 0;
        var ht = pe % 26, pt = Math.min((pe - ht) / 26, this.length), ft = 67108863 ^ 67108863 >>> ht << ht, mt = st;
        if (ot -= pt, ot = Math.max(0, ot), mt) {
          for (var lt = 0; lt < pt; lt++)
            mt.words[lt] = this.words[lt];
          mt.length = pt;
        }
        if (pt !== 0) if (this.length > pt)
          for (this.length -= pt, lt = 0; lt < this.length; lt++)
            this.words[lt] = this.words[lt + pt];
        else
          this.words[0] = 0, this.length = 1;
        var St = 0;
        for (lt = this.length - 1; lt >= 0 && (St !== 0 || lt >= ot); lt--) {
          var Ft = this.words[lt] | 0;
          this.words[lt] = St << 26 - ht | Ft >>> ht, St = Ft & ft;
        }
        return mt && St !== 0 && (mt.words[mt.length++] = St), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, W.prototype.ishrn = function(pe, nt, st) {
        return K(this.negative === 0), this.iushrn(pe, nt, st);
      }, W.prototype.shln = function(pe) {
        return this.clone().ishln(pe);
      }, W.prototype.ushln = function(pe) {
        return this.clone().iushln(pe);
      }, W.prototype.shrn = function(pe) {
        return this.clone().ishrn(pe);
      }, W.prototype.ushrn = function(pe) {
        return this.clone().iushrn(pe);
      }, W.prototype.testn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, st = (pe - nt) / 26, ot = 1 << nt;
        if (this.length <= st) return !1;
        var ht = this.words[st];
        return !!(ht & ot);
      }, W.prototype.imaskn = function(pe) {
        K(typeof pe == "number" && pe >= 0);
        var nt = pe % 26, st = (pe - nt) / 26;
        if (K(this.negative === 0, "imaskn works only with positive numbers"), this.length <= st)
          return this;
        if (nt !== 0 && st++, this.length = Math.min(st, this.length), nt !== 0) {
          var ot = 67108863 ^ 67108863 >>> nt << nt;
          this.words[this.length - 1] &= ot;
        }
        return this._strip();
      }, W.prototype.maskn = function(pe) {
        return this.clone().imaskn(pe);
      }, W.prototype.iaddn = function(pe) {
        return K(typeof pe == "number"), K(pe < 67108864), pe < 0 ? this.isubn(-pe) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= pe ? (this.words[0] = pe - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(pe), this.negative = 1, this) : this._iaddn(pe);
      }, W.prototype._iaddn = function(pe) {
        this.words[0] += pe;
        for (var nt = 0; nt < this.length && this.words[nt] >= 67108864; nt++)
          this.words[nt] -= 67108864, nt === this.length - 1 ? this.words[nt + 1] = 1 : this.words[nt + 1]++;
        return this.length = Math.max(this.length, nt + 1), this;
      }, W.prototype.isubn = function(pe) {
        if (K(typeof pe == "number"), K(pe < 67108864), pe < 0) return this.iaddn(-pe);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(pe), this.negative = 1, this;
        if (this.words[0] -= pe, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var nt = 0; nt < this.length && this.words[nt] < 0; nt++)
            this.words[nt] += 67108864, this.words[nt + 1] -= 1;
        return this._strip();
      }, W.prototype.addn = function(pe) {
        return this.clone().iaddn(pe);
      }, W.prototype.subn = function(pe) {
        return this.clone().isubn(pe);
      }, W.prototype.iabs = function() {
        return this.negative = 0, this;
      }, W.prototype.abs = function() {
        return this.clone().iabs();
      }, W.prototype._ishlnsubmul = function(pe, nt, st) {
        var ot = pe.length + st, ht;
        this._expand(ot);
        var pt, ft = 0;
        for (ht = 0; ht < pe.length; ht++) {
          pt = (this.words[ht + st] | 0) + ft;
          var mt = (pe.words[ht] | 0) * nt;
          pt -= mt & 67108863, ft = (pt >> 26) - (mt / 67108864 | 0), this.words[ht + st] = pt & 67108863;
        }
        for (; ht < this.length - st; ht++)
          pt = (this.words[ht + st] | 0) + ft, ft = pt >> 26, this.words[ht + st] = pt & 67108863;
        if (ft === 0) return this._strip();
        for (K(ft === -1), ft = 0, ht = 0; ht < this.length; ht++)
          pt = -(this.words[ht] | 0) + ft, ft = pt >> 26, this.words[ht] = pt & 67108863;
        return this.negative = 1, this._strip();
      }, W.prototype._wordDiv = function(pe, nt) {
        var st = this.length - pe.length, ot = this.clone(), ht = pe, pt = ht.words[ht.length - 1] | 0, ft = this._countBits(pt);
        st = 26 - ft, st !== 0 && (ht = ht.ushln(st), ot.iushln(st), pt = ht.words[ht.length - 1] | 0);
        var mt = ot.length - ht.length, lt;
        if (nt !== "mod") {
          lt = new W(null), lt.length = mt + 1, lt.words = new Array(lt.length);
          for (var St = 0; St < lt.length; St++)
            lt.words[St] = 0;
        }
        var Ft = ot.clone()._ishlnsubmul(ht, 1, mt);
        Ft.negative === 0 && (ot = Ft, lt && (lt.words[mt] = 1));
        for (var Gt = mt - 1; Gt >= 0; Gt--) {
          var qt = (ot.words[ht.length + Gt] | 0) * 67108864 + (ot.words[ht.length + Gt - 1] | 0);
          for (qt = Math.min(qt / pt | 0, 67108863), ot._ishlnsubmul(ht, qt, Gt); ot.negative !== 0; )
            qt--, ot.negative = 0, ot._ishlnsubmul(ht, 1, Gt), ot.isZero() || (ot.negative ^= 1);
          lt && (lt.words[Gt] = qt);
        }
        return lt && lt._strip(), ot._strip(), nt !== "div" && st !== 0 && ot.iushrn(st), {
          div: lt || null,
          mod: ot
        };
      }, W.prototype.divmod = function(pe, nt, st) {
        if (K(!pe.isZero()), this.isZero())
          return {
            div: new W(0),
            mod: new W(0)
          };
        var ot, ht, pt;
        return this.negative !== 0 && pe.negative === 0 ? (pt = this.neg().divmod(pe, nt), nt !== "mod" && (ot = pt.div.neg()), nt !== "div" && (ht = pt.mod.neg(), st && ht.negative !== 0 && ht.iadd(pe)), {
          div: ot,
          mod: ht
        }) : this.negative === 0 && pe.negative !== 0 ? (pt = this.divmod(pe.neg(), nt), nt !== "mod" && (ot = pt.div.neg()), {
          div: ot,
          mod: pt.mod
        }) : this.negative & pe.negative ? (pt = this.neg().divmod(pe.neg(), nt), nt !== "div" && (ht = pt.mod.neg(), st && ht.negative !== 0 && ht.isub(pe)), {
          div: pt.div,
          mod: ht
        }) : pe.length > this.length || this.cmp(pe) < 0 ? {
          div: new W(0),
          mod: this
        } : pe.length === 1 ? nt === "div" ? {
          div: this.divn(pe.words[0]),
          mod: null
        } : nt === "mod" ? {
          div: null,
          mod: new W(this.modrn(pe.words[0]))
        } : {
          div: this.divn(pe.words[0]),
          mod: new W(this.modrn(pe.words[0]))
        } : this._wordDiv(pe, nt);
      }, W.prototype.div = function(pe) {
        return this.divmod(pe, "div", !1).div;
      }, W.prototype.mod = function(pe) {
        return this.divmod(pe, "mod", !1).mod;
      }, W.prototype.umod = function(pe) {
        return this.divmod(pe, "mod", !0).mod;
      }, W.prototype.divRound = function(pe) {
        var nt = this.divmod(pe);
        if (nt.mod.isZero()) return nt.div;
        var st = nt.div.negative !== 0 ? nt.mod.isub(pe) : nt.mod, ot = pe.ushrn(1), ht = pe.andln(1), pt = st.cmp(ot);
        return pt < 0 || ht === 1 && pt === 0 ? nt.div : nt.div.negative !== 0 ? nt.div.isubn(1) : nt.div.iaddn(1);
      }, W.prototype.modrn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var st = (1 << 26) % pe, ot = 0, ht = this.length - 1; ht >= 0; ht--)
          ot = (st * ot + (this.words[ht] | 0)) % pe;
        return nt ? -ot : ot;
      }, W.prototype.modn = function(pe) {
        return this.modrn(pe);
      }, W.prototype.idivn = function(pe) {
        var nt = pe < 0;
        nt && (pe = -pe), K(pe <= 67108863);
        for (var st = 0, ot = this.length - 1; ot >= 0; ot--) {
          var ht = (this.words[ot] | 0) + st * 67108864;
          this.words[ot] = ht / pe | 0, st = ht % pe;
        }
        return this._strip(), nt ? this.ineg() : this;
      }, W.prototype.divn = function(pe) {
        return this.clone().idivn(pe);
      }, W.prototype.egcd = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, st = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var ot = new W(1), ht = new W(0), pt = new W(0), ft = new W(1), mt = 0; nt.isEven() && st.isEven(); )
          nt.iushrn(1), st.iushrn(1), ++mt;
        for (var lt = st.clone(), St = nt.clone(); !nt.isZero(); ) {
          for (var Ft = 0, Gt = 1; !(nt.words[0] & Gt) && Ft < 26; ++Ft, Gt <<= 1) ;
          if (Ft > 0)
            for (nt.iushrn(Ft); Ft-- > 0; )
              (ot.isOdd() || ht.isOdd()) && (ot.iadd(lt), ht.isub(St)), ot.iushrn(1), ht.iushrn(1);
          for (var qt = 0, Pt = 1; !(st.words[0] & Pt) && qt < 26; ++qt, Pt <<= 1) ;
          if (qt > 0)
            for (st.iushrn(qt); qt-- > 0; )
              (pt.isOdd() || ft.isOdd()) && (pt.iadd(lt), ft.isub(St)), pt.iushrn(1), ft.iushrn(1);
          nt.cmp(st) >= 0 ? (nt.isub(st), ot.isub(pt), ht.isub(ft)) : (st.isub(nt), pt.isub(ot), ft.isub(ht));
        }
        return {
          a: pt,
          b: ft,
          gcd: st.iushln(mt)
        };
      }, W.prototype._invmp = function(pe) {
        K(pe.negative === 0), K(!pe.isZero());
        var nt = this, st = pe.clone();
        nt.negative !== 0 ? nt = nt.umod(pe) : nt = nt.clone();
        for (var ot = new W(1), ht = new W(0), pt = st.clone(); nt.cmpn(1) > 0 && st.cmpn(1) > 0; ) {
          for (var ft = 0, mt = 1; !(nt.words[0] & mt) && ft < 26; ++ft, mt <<= 1) ;
          if (ft > 0)
            for (nt.iushrn(ft); ft-- > 0; )
              ot.isOdd() && ot.iadd(pt), ot.iushrn(1);
          for (var lt = 0, St = 1; !(st.words[0] & St) && lt < 26; ++lt, St <<= 1) ;
          if (lt > 0)
            for (st.iushrn(lt); lt-- > 0; )
              ht.isOdd() && ht.iadd(pt), ht.iushrn(1);
          nt.cmp(st) >= 0 ? (nt.isub(st), ot.isub(ht)) : (st.isub(nt), ht.isub(ot));
        }
        var Ft;
        return nt.cmpn(1) === 0 ? Ft = ot : Ft = ht, Ft.cmpn(0) < 0 && Ft.iadd(pe), Ft;
      }, W.prototype.gcd = function(pe) {
        if (this.isZero()) return pe.abs();
        if (pe.isZero()) return this.abs();
        var nt = this.clone(), st = pe.clone();
        nt.negative = 0, st.negative = 0;
        for (var ot = 0; nt.isEven() && st.isEven(); ot++)
          nt.iushrn(1), st.iushrn(1);
        do {
          for (; nt.isEven(); )
            nt.iushrn(1);
          for (; st.isEven(); )
            st.iushrn(1);
          var ht = nt.cmp(st);
          if (ht < 0) {
            var pt = nt;
            nt = st, st = pt;
          } else if (ht === 0 || st.cmpn(1) === 0)
            break;
          nt.isub(st);
        } while (!0);
        return st.iushln(ot);
      }, W.prototype.invm = function(pe) {
        return this.egcd(pe).a.umod(pe);
      }, W.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, W.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, W.prototype.andln = function(pe) {
        return this.words[0] & pe;
      }, W.prototype.bincn = function(pe) {
        K(typeof pe == "number");
        var nt = pe % 26, st = (pe - nt) / 26, ot = 1 << nt;
        if (this.length <= st)
          return this._expand(st + 1), this.words[st] |= ot, this;
        for (var ht = ot, pt = st; ht !== 0 && pt < this.length; pt++) {
          var ft = this.words[pt] | 0;
          ft += ht, ht = ft >>> 26, ft &= 67108863, this.words[pt] = ft;
        }
        return ht !== 0 && (this.words[pt] = ht, this.length++), this;
      }, W.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, W.prototype.cmpn = function(pe) {
        var nt = pe < 0;
        if (this.negative !== 0 && !nt) return -1;
        if (this.negative === 0 && nt) return 1;
        this._strip();
        var st;
        if (this.length > 1)
          st = 1;
        else {
          nt && (pe = -pe), K(pe <= 67108863, "Number is too big");
          var ot = this.words[0] | 0;
          st = ot === pe ? 0 : ot < pe ? -1 : 1;
        }
        return this.negative !== 0 ? -st | 0 : st;
      }, W.prototype.cmp = function(pe) {
        if (this.negative !== 0 && pe.negative === 0) return -1;
        if (this.negative === 0 && pe.negative !== 0) return 1;
        var nt = this.ucmp(pe);
        return this.negative !== 0 ? -nt | 0 : nt;
      }, W.prototype.ucmp = function(pe) {
        if (this.length > pe.length) return 1;
        if (this.length < pe.length) return -1;
        for (var nt = 0, st = this.length - 1; st >= 0; st--) {
          var ot = this.words[st] | 0, ht = pe.words[st] | 0;
          if (ot !== ht) {
            ot < ht ? nt = -1 : ot > ht && (nt = 1);
            break;
          }
        }
        return nt;
      }, W.prototype.gtn = function(pe) {
        return this.cmpn(pe) === 1;
      }, W.prototype.gt = function(pe) {
        return this.cmp(pe) === 1;
      }, W.prototype.gten = function(pe) {
        return this.cmpn(pe) >= 0;
      }, W.prototype.gte = function(pe) {
        return this.cmp(pe) >= 0;
      }, W.prototype.ltn = function(pe) {
        return this.cmpn(pe) === -1;
      }, W.prototype.lt = function(pe) {
        return this.cmp(pe) === -1;
      }, W.prototype.lten = function(pe) {
        return this.cmpn(pe) <= 0;
      }, W.prototype.lte = function(pe) {
        return this.cmp(pe) <= 0;
      }, W.prototype.eqn = function(pe) {
        return this.cmpn(pe) === 0;
      }, W.prototype.eq = function(pe) {
        return this.cmp(pe) === 0;
      }, W.red = function(pe) {
        return new gt(pe);
      }, W.prototype.toRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), K(this.negative === 0, "red works only with positives"), pe.convertTo(this)._forceRed(pe);
      }, W.prototype.fromRed = function() {
        return K(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, W.prototype._forceRed = function(pe) {
        return this.red = pe, this;
      }, W.prototype.forceRed = function(pe) {
        return K(!this.red, "Already a number in reduction context"), this._forceRed(pe);
      }, W.prototype.redAdd = function(pe) {
        return K(this.red, "redAdd works only with red numbers"), this.red.add(this, pe);
      }, W.prototype.redIAdd = function(pe) {
        return K(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, pe);
      }, W.prototype.redSub = function(pe) {
        return K(this.red, "redSub works only with red numbers"), this.red.sub(this, pe);
      }, W.prototype.redISub = function(pe) {
        return K(this.red, "redISub works only with red numbers"), this.red.isub(this, pe);
      }, W.prototype.redShl = function(pe) {
        return K(this.red, "redShl works only with red numbers"), this.red.shl(this, pe);
      }, W.prototype.redMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.mul(this, pe);
      }, W.prototype.redIMul = function(pe) {
        return K(this.red, "redMul works only with red numbers"), this.red._verify2(this, pe), this.red.imul(this, pe);
      }, W.prototype.redSqr = function() {
        return K(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, W.prototype.redISqr = function() {
        return K(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, W.prototype.redSqrt = function() {
        return K(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, W.prototype.redInvm = function() {
        return K(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, W.prototype.redNeg = function() {
        return K(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, W.prototype.redPow = function(pe) {
        return K(this.red && !pe.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, pe);
      };
      var $t = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function xt(Ce, pe) {
        this.name = Ce, this.p = new W(pe, 16), this.n = this.p.bitLength(), this.k = new W(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      xt.prototype._tmp = function() {
        var pe = new W(null);
        return pe.words = new Array(Math.ceil(this.n / 13)), pe;
      }, xt.prototype.ireduce = function(pe) {
        var nt = pe, st;
        do
          this.split(nt, this.tmp), nt = this.imulK(nt), nt = nt.iadd(this.tmp), st = nt.bitLength();
        while (st > this.n);
        var ot = st < this.n ? -1 : nt.ucmp(this.p);
        return ot === 0 ? (nt.words[0] = 0, nt.length = 1) : ot > 0 ? nt.isub(this.p) : nt.strip !== void 0 ? nt.strip() : nt._strip(), nt;
      }, xt.prototype.split = function(pe, nt) {
        pe.iushrn(this.n, 0, nt);
      }, xt.prototype.imulK = function(pe) {
        return pe.imul(this.k);
      };
      function Ot() {
        xt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      V(Ot, xt), Ot.prototype.split = function(pe, nt) {
        for (var st = 4194303, ot = Math.min(pe.length, 9), ht = 0; ht < ot; ht++)
          nt.words[ht] = pe.words[ht];
        if (nt.length = ot, pe.length <= 9) {
          pe.words[0] = 0, pe.length = 1;
          return;
        }
        var pt = pe.words[9];
        for (nt.words[nt.length++] = pt & st, ht = 10; ht < pe.length; ht++) {
          var ft = pe.words[ht] | 0;
          pe.words[ht - 10] = (ft & st) << 4 | pt >>> 22, pt = ft;
        }
        pt >>>= 22, pe.words[ht - 10] = pt, pt === 0 && pe.length > 10 ? pe.length -= 10 : pe.length -= 9;
      }, Ot.prototype.imulK = function(pe) {
        pe.words[pe.length] = 0, pe.words[pe.length + 1] = 0, pe.length += 2;
        for (var nt = 0, st = 0; st < pe.length; st++) {
          var ot = pe.words[st] | 0;
          nt += ot * 977, pe.words[st] = nt & 67108863, nt = ot * 64 + (nt / 67108864 | 0);
        }
        return pe.words[pe.length - 1] === 0 && (pe.length--, pe.words[pe.length - 1] === 0 && pe.length--), pe;
      };
      function At() {
        xt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      V(At, xt);
      function yt() {
        xt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      V(yt, xt);
      function Bt() {
        xt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      V(Bt, xt), Bt.prototype.imulK = function(pe) {
        for (var nt = 0, st = 0; st < pe.length; st++) {
          var ot = (pe.words[st] | 0) * 19 + nt, ht = ot & 67108863;
          ot >>>= 26, pe.words[st] = ht, nt = ot;
        }
        return nt !== 0 && (pe.words[pe.length++] = nt), pe;
      }, W._prime = function(pe) {
        if ($t[pe]) return $t[pe];
        var nt;
        if (pe === "k256")
          nt = new Ot();
        else if (pe === "p224")
          nt = new At();
        else if (pe === "p192")
          nt = new yt();
        else if (pe === "p25519")
          nt = new Bt();
        else
          throw new Error("Unknown prime " + pe);
        return $t[pe] = nt, nt;
      };
      function gt(Ce) {
        if (typeof Ce == "string") {
          var pe = W._prime(Ce);
          this.m = pe.p, this.prime = pe;
        } else
          K(Ce.gtn(1), "modulus must be greater than 1"), this.m = Ce, this.prime = null;
      }
      gt.prototype._verify1 = function(pe) {
        K(pe.negative === 0, "red works only with positives"), K(pe.red, "red works only with red numbers");
      }, gt.prototype._verify2 = function(pe, nt) {
        K((pe.negative | nt.negative) === 0, "red works only with positives"), K(
          pe.red && pe.red === nt.red,
          "red works only with red numbers"
        );
      }, gt.prototype.imod = function(pe) {
        return this.prime ? this.prime.ireduce(pe)._forceRed(this) : (re(pe, pe.umod(this.m)._forceRed(this)), pe);
      }, gt.prototype.neg = function(pe) {
        return pe.isZero() ? pe.clone() : this.m.sub(pe)._forceRed(this);
      }, gt.prototype.add = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.add(nt);
        return st.cmp(this.m) >= 0 && st.isub(this.m), st._forceRed(this);
      }, gt.prototype.iadd = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.iadd(nt);
        return st.cmp(this.m) >= 0 && st.isub(this.m), st;
      }, gt.prototype.sub = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.sub(nt);
        return st.cmpn(0) < 0 && st.iadd(this.m), st._forceRed(this);
      }, gt.prototype.isub = function(pe, nt) {
        this._verify2(pe, nt);
        var st = pe.isub(nt);
        return st.cmpn(0) < 0 && st.iadd(this.m), st;
      }, gt.prototype.shl = function(pe, nt) {
        return this._verify1(pe), this.imod(pe.ushln(nt));
      }, gt.prototype.imul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.imul(nt));
      }, gt.prototype.mul = function(pe, nt) {
        return this._verify2(pe, nt), this.imod(pe.mul(nt));
      }, gt.prototype.isqr = function(pe) {
        return this.imul(pe, pe.clone());
      }, gt.prototype.sqr = function(pe) {
        return this.mul(pe, pe);
      }, gt.prototype.sqrt = function(pe) {
        if (pe.isZero()) return pe.clone();
        var nt = this.m.andln(3);
        if (K(nt % 2 === 1), nt === 3) {
          var st = this.m.add(new W(1)).iushrn(2);
          return this.pow(pe, st);
        }
        for (var ot = this.m.subn(1), ht = 0; !ot.isZero() && ot.andln(1) === 0; )
          ht++, ot.iushrn(1);
        K(!ot.isZero());
        var pt = new W(1).toRed(this), ft = pt.redNeg(), mt = this.m.subn(1).iushrn(1), lt = this.m.bitLength();
        for (lt = new W(2 * lt * lt).toRed(this); this.pow(lt, mt).cmp(ft) !== 0; )
          lt.redIAdd(ft);
        for (var St = this.pow(lt, ot), Ft = this.pow(pe, ot.addn(1).iushrn(1)), Gt = this.pow(pe, ot), qt = ht; Gt.cmp(pt) !== 0; ) {
          for (var Pt = Gt, Tt = 0; Pt.cmp(pt) !== 0; Tt++)
            Pt = Pt.redSqr();
          K(Tt < qt);
          var Ut = this.pow(St, new W(1).iushln(qt - Tt - 1));
          Ft = Ft.redMul(Ut), St = Ut.redSqr(), Gt = Gt.redMul(St), qt = Tt;
        }
        return Ft;
      }, gt.prototype.invm = function(pe) {
        var nt = pe._invmp(this.m);
        return nt.negative !== 0 ? (nt.negative = 0, this.imod(nt).redNeg()) : this.imod(nt);
      }, gt.prototype.pow = function(pe, nt) {
        if (nt.isZero()) return new W(1).toRed(this);
        if (nt.cmpn(1) === 0) return pe.clone();
        var st = 4, ot = new Array(1 << st);
        ot[0] = new W(1).toRed(this), ot[1] = pe;
        for (var ht = 2; ht < ot.length; ht++)
          ot[ht] = this.mul(ot[ht - 1], pe);
        var pt = ot[0], ft = 0, mt = 0, lt = nt.bitLength() % 26;
        for (lt === 0 && (lt = 26), ht = nt.length - 1; ht >= 0; ht--) {
          for (var St = nt.words[ht], Ft = lt - 1; Ft >= 0; Ft--) {
            var Gt = St >> Ft & 1;
            if (pt !== ot[0] && (pt = this.sqr(pt)), Gt === 0 && ft === 0) {
              mt = 0;
              continue;
            }
            ft <<= 1, ft |= Gt, mt++, !(mt !== st && (ht !== 0 || Ft !== 0)) && (pt = this.mul(pt, ot[ft]), mt = 0, ft = 0);
          }
          lt = 26;
        }
        return pt;
      }, gt.prototype.convertTo = function(pe) {
        var nt = pe.umod(this.m);
        return nt === pe ? nt.clone() : nt;
      }, gt.prototype.convertFrom = function(pe) {
        var nt = pe.clone();
        return nt.red = null, nt;
      }, W.mont = function(pe) {
        return new rt(pe);
      };
      function rt(Ce) {
        gt.call(this, Ce), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new W(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      V(rt, gt), rt.prototype.convertTo = function(pe) {
        return this.imod(pe.ushln(this.shift));
      }, rt.prototype.convertFrom = function(pe) {
        var nt = this.imod(pe.mul(this.rinv));
        return nt.red = null, nt;
      }, rt.prototype.imul = function(pe, nt) {
        if (pe.isZero() || nt.isZero())
          return pe.words[0] = 0, pe.length = 1, pe;
        var st = pe.imul(nt), ot = st.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = st.isub(ot).iushrn(this.shift), pt = ht;
        return ht.cmp(this.m) >= 0 ? pt = ht.isub(this.m) : ht.cmpn(0) < 0 && (pt = ht.iadd(this.m)), pt._forceRed(this);
      }, rt.prototype.mul = function(pe, nt) {
        if (pe.isZero() || nt.isZero()) return new W(0)._forceRed(this);
        var st = pe.mul(nt), ot = st.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), ht = st.isub(ot).iushrn(this.shift), pt = ht;
        return ht.cmp(this.m) >= 0 ? pt = ht.isub(this.m) : ht.cmpn(0) < 0 && (pt = ht.iadd(this.m)), pt._forceRed(this);
      }, rt.prototype.invm = function(pe) {
        var nt = this.imod(pe._invmp(this.m).mul(this.r2));
        return nt._forceRed(this);
      };
    })(A, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var A = requireBn(), B = requireBrowser$b(), L = safeBufferExports.Buffer;
  function K(J) {
    var ne = J.modulus.byteLength(), ie;
    do
      ie = new A(B(ne));
    while (ie.cmp(J.modulus) >= 0 || !ie.umod(J.prime1) || !ie.umod(J.prime2));
    return ie;
  }
  function V(J) {
    var ne = K(J), ie = ne.toRed(A.mont(J.modulus)).redPow(new A(J.publicExponent)).fromRed();
    return { blinder: ie, unblinder: ne.invm(J.modulus) };
  }
  function W(J, ne) {
    var ie = V(ne), ce = ne.modulus.byteLength(), re = new A(J).mul(ie.blinder).umod(ne.modulus), oe = re.toRed(A.mont(ne.prime1)), ke = re.toRed(A.mont(ne.prime2)), Oe = ne.coefficient, it = ne.prime1, at = ne.prime2, ut = oe.redPow(ne.exponent1).fromRed(), dt = ke.redPow(ne.exponent2).fromRed(), ct = ut.isub(dt).imul(Oe).umod(it).imul(at);
    return dt.iadd(ct).imul(ie.unblinder).umod(ne.modulus).toArrayLike(L, "be", ce);
  }
  return W.getr = K, browserifyRsa = W, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(A) {
    var B = A;
    function L(W, J) {
      if (Array.isArray(W))
        return W.slice();
      if (!W)
        return [];
      var ne = [];
      if (typeof W != "string") {
        for (var ie = 0; ie < W.length; ie++)
          ne[ie] = W[ie] | 0;
        return ne;
      }
      if (J === "hex") {
        W = W.replace(/[^a-z0-9]+/ig, ""), W.length % 2 !== 0 && (W = "0" + W);
        for (var ie = 0; ie < W.length; ie += 2)
          ne.push(parseInt(W[ie] + W[ie + 1], 16));
      } else
        for (var ie = 0; ie < W.length; ie++) {
          var ce = W.charCodeAt(ie), re = ce >> 8, oe = ce & 255;
          re ? ne.push(re, oe) : ne.push(oe);
        }
      return ne;
    }
    B.toArray = L;
    function K(W) {
      return W.length === 1 ? "0" + W : W;
    }
    B.zero2 = K;
    function V(W) {
      for (var J = "", ne = 0; ne < W.length; ne++)
        J += K(W[ne].toString(16));
      return J;
    }
    B.toHex = V, B.encode = function(J, ne) {
      return ne === "hex" ? V(J) : J;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(A) {
    var B = A, L = requireBn$1(), K = requireMinimalisticAssert(), V = requireUtils$2();
    B.assert = K, B.toArray = V.toArray, B.zero2 = V.zero2, B.toHex = V.toHex, B.encode = V.encode;
    function W(re, oe, ke) {
      var Oe = new Array(Math.max(re.bitLength(), ke) + 1), it;
      for (it = 0; it < Oe.length; it += 1)
        Oe[it] = 0;
      var at = 1 << oe + 1, ut = re.clone();
      for (it = 0; it < Oe.length; it++) {
        var dt, ct = ut.andln(at - 1);
        ut.isOdd() ? (ct > (at >> 1) - 1 ? dt = (at >> 1) - ct : dt = ct, ut.isubn(dt)) : dt = 0, Oe[it] = dt, ut.iushrn(1);
      }
      return Oe;
    }
    B.getNAF = W;
    function J(re, oe) {
      var ke = [
        [],
        []
      ];
      re = re.clone(), oe = oe.clone();
      for (var Oe = 0, it = 0, at; re.cmpn(-Oe) > 0 || oe.cmpn(-it) > 0; ) {
        var ut = re.andln(3) + Oe & 3, dt = oe.andln(3) + it & 3;
        ut === 3 && (ut = -1), dt === 3 && (dt = -1);
        var ct;
        ut & 1 ? (at = re.andln(7) + Oe & 7, (at === 3 || at === 5) && dt === 2 ? ct = -ut : ct = ut) : ct = 0, ke[0].push(ct);
        var bt;
        dt & 1 ? (at = oe.andln(7) + it & 7, (at === 3 || at === 5) && ut === 2 ? bt = -dt : bt = dt) : bt = 0, ke[1].push(bt), 2 * Oe === ct + 1 && (Oe = 1 - Oe), 2 * it === bt + 1 && (it = 1 - it), re.iushrn(1), oe.iushrn(1);
      }
      return ke;
    }
    B.getJSF = J;
    function ne(re, oe, ke) {
      var Oe = "_" + oe;
      re.prototype[oe] = function() {
        return this[Oe] !== void 0 ? this[Oe] : this[Oe] = ke.call(this);
      };
    }
    B.cachedProperty = ne;
    function ie(re) {
      return typeof re == "string" ? B.toArray(re, "hex") : re;
    }
    B.parseBytes = ie;
    function ce(re) {
      return new L(re, "hex", "le");
    }
    B.intFromLE = ce;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.getNAF, K = B.getJSF, V = B.assert;
  function W(ne, ie) {
    this.type = ne, this.p = new A(ie.p, 16), this.red = ie.prime ? A.red(ie.prime) : A.mont(this.p), this.zero = new A(0).toRed(this.red), this.one = new A(1).toRed(this.red), this.two = new A(2).toRed(this.red), this.n = ie.n && new A(ie.n, 16), this.g = ie.g && this.pointFromJSON(ie.g, ie.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var ce = this.n && this.p.div(this.n);
    !ce || ce.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = W, W.prototype.point = function() {
    throw new Error("Not implemented");
  }, W.prototype.validate = function() {
    throw new Error("Not implemented");
  }, W.prototype._fixedNafMul = function(ie, ce) {
    V(ie.precomputed);
    var re = ie._getDoubles(), oe = L(ce, 1, this._bitLength), ke = (1 << re.step + 1) - (re.step % 2 === 0 ? 2 : 1);
    ke /= 3;
    var Oe = [], it, at;
    for (it = 0; it < oe.length; it += re.step) {
      at = 0;
      for (var ut = it + re.step - 1; ut >= it; ut--)
        at = (at << 1) + oe[ut];
      Oe.push(at);
    }
    for (var dt = this.jpoint(null, null, null), ct = this.jpoint(null, null, null), bt = ke; bt > 0; bt--) {
      for (it = 0; it < Oe.length; it++)
        at = Oe[it], at === bt ? ct = ct.mixedAdd(re.points[it]) : at === -bt && (ct = ct.mixedAdd(re.points[it].neg()));
      dt = dt.add(ct);
    }
    return dt.toP();
  }, W.prototype._wnafMul = function(ie, ce) {
    var re = 4, oe = ie._getNAFPoints(re);
    re = oe.wnd;
    for (var ke = oe.points, Oe = L(ce, re, this._bitLength), it = this.jpoint(null, null, null), at = Oe.length - 1; at >= 0; at--) {
      for (var ut = 0; at >= 0 && Oe[at] === 0; at--)
        ut++;
      if (at >= 0 && ut++, it = it.dblp(ut), at < 0)
        break;
      var dt = Oe[at];
      V(dt !== 0), ie.type === "affine" ? dt > 0 ? it = it.mixedAdd(ke[dt - 1 >> 1]) : it = it.mixedAdd(ke[-dt - 1 >> 1].neg()) : dt > 0 ? it = it.add(ke[dt - 1 >> 1]) : it = it.add(ke[-dt - 1 >> 1].neg());
    }
    return ie.type === "affine" ? it.toP() : it;
  }, W.prototype._wnafMulAdd = function(ie, ce, re, oe, ke) {
    var Oe = this._wnafT1, it = this._wnafT2, at = this._wnafT3, ut = 0, dt, ct, bt;
    for (dt = 0; dt < oe; dt++) {
      bt = ce[dt];
      var vt = bt._getNAFPoints(ie);
      Oe[dt] = vt.wnd, it[dt] = vt.points;
    }
    for (dt = oe - 1; dt >= 1; dt -= 2) {
      var $t = dt - 1, xt = dt;
      if (Oe[$t] !== 1 || Oe[xt] !== 1) {
        at[$t] = L(re[$t], Oe[$t], this._bitLength), at[xt] = L(re[xt], Oe[xt], this._bitLength), ut = Math.max(at[$t].length, ut), ut = Math.max(at[xt].length, ut);
        continue;
      }
      var Ot = [
        ce[$t],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        ce[xt]
        /* 7 */
      ];
      ce[$t].y.cmp(ce[xt].y) === 0 ? (Ot[1] = ce[$t].add(ce[xt]), Ot[2] = ce[$t].toJ().mixedAdd(ce[xt].neg())) : ce[$t].y.cmp(ce[xt].y.redNeg()) === 0 ? (Ot[1] = ce[$t].toJ().mixedAdd(ce[xt]), Ot[2] = ce[$t].add(ce[xt].neg())) : (Ot[1] = ce[$t].toJ().mixedAdd(ce[xt]), Ot[2] = ce[$t].toJ().mixedAdd(ce[xt].neg()));
      var At = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], yt = K(re[$t], re[xt]);
      for (ut = Math.max(yt[0].length, ut), at[$t] = new Array(ut), at[xt] = new Array(ut), ct = 0; ct < ut; ct++) {
        var Bt = yt[0][ct] | 0, gt = yt[1][ct] | 0;
        at[$t][ct] = At[(Bt + 1) * 3 + (gt + 1)], at[xt][ct] = 0, it[$t] = Ot;
      }
    }
    var rt = this.jpoint(null, null, null), Ce = this._wnafT4;
    for (dt = ut; dt >= 0; dt--) {
      for (var pe = 0; dt >= 0; ) {
        var nt = !0;
        for (ct = 0; ct < oe; ct++)
          Ce[ct] = at[ct][dt] | 0, Ce[ct] !== 0 && (nt = !1);
        if (!nt)
          break;
        pe++, dt--;
      }
      if (dt >= 0 && pe++, rt = rt.dblp(pe), dt < 0)
        break;
      for (ct = 0; ct < oe; ct++) {
        var st = Ce[ct];
        st !== 0 && (st > 0 ? bt = it[ct][st - 1 >> 1] : st < 0 && (bt = it[ct][-st - 1 >> 1].neg()), bt.type === "affine" ? rt = rt.mixedAdd(bt) : rt = rt.add(bt));
      }
    }
    for (dt = 0; dt < oe; dt++)
      it[dt] = null;
    return ke ? rt : rt.toP();
  };
  function J(ne, ie) {
    this.curve = ne, this.type = ie, this.precomputed = null;
  }
  return W.BasePoint = J, J.prototype.eq = function() {
    throw new Error("Not implemented");
  }, J.prototype.validate = function() {
    return this.curve.validate(this);
  }, W.prototype.decodePoint = function(ie, ce) {
    ie = B.toArray(ie, ce);
    var re = this.p.byteLength();
    if ((ie[0] === 4 || ie[0] === 6 || ie[0] === 7) && ie.length - 1 === 2 * re) {
      ie[0] === 6 ? V(ie[ie.length - 1] % 2 === 0) : ie[0] === 7 && V(ie[ie.length - 1] % 2 === 1);
      var oe = this.point(
        ie.slice(1, 1 + re),
        ie.slice(1 + re, 1 + 2 * re)
      );
      return oe;
    } else if ((ie[0] === 2 || ie[0] === 3) && ie.length - 1 === re)
      return this.pointFromX(ie.slice(1, 1 + re), ie[0] === 3);
    throw new Error("Unknown point format");
  }, J.prototype.encodeCompressed = function(ie) {
    return this.encode(ie, !0);
  }, J.prototype._encode = function(ie) {
    var ce = this.curve.p.byteLength(), re = this.getX().toArray("be", ce);
    return ie ? [this.getY().isEven() ? 2 : 3].concat(re) : [4].concat(re, this.getY().toArray("be", ce));
  }, J.prototype.encode = function(ie, ce) {
    return B.encode(this._encode(ce), ie);
  }, J.prototype.precompute = function(ie) {
    if (this.precomputed)
      return this;
    var ce = {
      doubles: null,
      naf: null,
      beta: null
    };
    return ce.naf = this._getNAFPoints(8), ce.doubles = this._getDoubles(4, ie), ce.beta = this._getBeta(), this.precomputed = ce, this;
  }, J.prototype._hasDoubles = function(ie) {
    if (!this.precomputed)
      return !1;
    var ce = this.precomputed.doubles;
    return ce ? ce.points.length >= Math.ceil((ie.bitLength() + 1) / ce.step) : !1;
  }, J.prototype._getDoubles = function(ie, ce) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var re = [this], oe = this, ke = 0; ke < ce; ke += ie) {
      for (var Oe = 0; Oe < ie; Oe++)
        oe = oe.dbl();
      re.push(oe);
    }
    return {
      step: ie,
      points: re
    };
  }, J.prototype._getNAFPoints = function(ie) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var ce = [this], re = (1 << ie) - 1, oe = re === 1 ? null : this.dbl(), ke = 1; ke < re; ke++)
      ce[ke] = ce[ke - 1].add(oe);
    return {
      wnd: ie,
      points: ce
    };
  }, J.prototype._getBeta = function() {
    return null;
  }, J.prototype.dblp = function(ie) {
    for (var ce = this, re = 0; re < ie; re++)
      ce = ce.dbl();
    return ce;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), V = A.assert;
  function W(ie) {
    K.call(this, "short", ie), this.a = new B(ie.a, 16).toRed(this.red), this.b = new B(ie.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ie), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  L(W, K), short = W, W.prototype._getEndomorphism = function(ce) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var re, oe;
      if (ce.beta)
        re = new B(ce.beta, 16).toRed(this.red);
      else {
        var ke = this._getEndoRoots(this.p);
        re = ke[0].cmp(ke[1]) < 0 ? ke[0] : ke[1], re = re.toRed(this.red);
      }
      if (ce.lambda)
        oe = new B(ce.lambda, 16);
      else {
        var Oe = this._getEndoRoots(this.n);
        this.g.mul(Oe[0]).x.cmp(this.g.x.redMul(re)) === 0 ? oe = Oe[0] : (oe = Oe[1], V(this.g.mul(oe).x.cmp(this.g.x.redMul(re)) === 0));
      }
      var it;
      return ce.basis ? it = ce.basis.map(function(at) {
        return {
          a: new B(at.a, 16),
          b: new B(at.b, 16)
        };
      }) : it = this._getEndoBasis(oe), {
        beta: re,
        lambda: oe,
        basis: it
      };
    }
  }, W.prototype._getEndoRoots = function(ce) {
    var re = ce === this.p ? this.red : B.mont(ce), oe = new B(2).toRed(re).redInvm(), ke = oe.redNeg(), Oe = new B(3).toRed(re).redNeg().redSqrt().redMul(oe), it = ke.redAdd(Oe).fromRed(), at = ke.redSub(Oe).fromRed();
    return [it, at];
  }, W.prototype._getEndoBasis = function(ce) {
    for (var re = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), oe = ce, ke = this.n.clone(), Oe = new B(1), it = new B(0), at = new B(0), ut = new B(1), dt, ct, bt, vt, $t, xt, Ot, At = 0, yt, Bt; oe.cmpn(0) !== 0; ) {
      var gt = ke.div(oe);
      yt = ke.sub(gt.mul(oe)), Bt = at.sub(gt.mul(Oe));
      var rt = ut.sub(gt.mul(it));
      if (!bt && yt.cmp(re) < 0)
        dt = Ot.neg(), ct = Oe, bt = yt.neg(), vt = Bt;
      else if (bt && ++At === 2)
        break;
      Ot = yt, ke = oe, oe = yt, at = Oe, Oe = Bt, ut = it, it = rt;
    }
    $t = yt.neg(), xt = Bt;
    var Ce = bt.sqr().add(vt.sqr()), pe = $t.sqr().add(xt.sqr());
    return pe.cmp(Ce) >= 0 && ($t = dt, xt = ct), bt.negative && (bt = bt.neg(), vt = vt.neg()), $t.negative && ($t = $t.neg(), xt = xt.neg()), [
      { a: bt, b: vt },
      { a: $t, b: xt }
    ];
  }, W.prototype._endoSplit = function(ce) {
    var re = this.endo.basis, oe = re[0], ke = re[1], Oe = ke.b.mul(ce).divRound(this.n), it = oe.b.neg().mul(ce).divRound(this.n), at = Oe.mul(oe.a), ut = it.mul(ke.a), dt = Oe.mul(oe.b), ct = it.mul(ke.b), bt = ce.sub(at).sub(ut), vt = dt.add(ct).neg();
    return { k1: bt, k2: vt };
  }, W.prototype.pointFromX = function(ce, re) {
    ce = new B(ce, 16), ce.red || (ce = ce.toRed(this.red));
    var oe = ce.redSqr().redMul(ce).redIAdd(ce.redMul(this.a)).redIAdd(this.b), ke = oe.redSqrt();
    if (ke.redSqr().redSub(oe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Oe = ke.fromRed().isOdd();
    return (re && !Oe || !re && Oe) && (ke = ke.redNeg()), this.point(ce, ke);
  }, W.prototype.validate = function(ce) {
    if (ce.inf)
      return !0;
    var re = ce.x, oe = ce.y, ke = this.a.redMul(re), Oe = re.redSqr().redMul(re).redIAdd(ke).redIAdd(this.b);
    return oe.redSqr().redISub(Oe).cmpn(0) === 0;
  }, W.prototype._endoWnafMulAdd = function(ce, re, oe) {
    for (var ke = this._endoWnafT1, Oe = this._endoWnafT2, it = 0; it < ce.length; it++) {
      var at = this._endoSplit(re[it]), ut = ce[it], dt = ut._getBeta();
      at.k1.negative && (at.k1.ineg(), ut = ut.neg(!0)), at.k2.negative && (at.k2.ineg(), dt = dt.neg(!0)), ke[it * 2] = ut, ke[it * 2 + 1] = dt, Oe[it * 2] = at.k1, Oe[it * 2 + 1] = at.k2;
    }
    for (var ct = this._wnafMulAdd(1, ke, Oe, it * 2, oe), bt = 0; bt < it * 2; bt++)
      ke[bt] = null, Oe[bt] = null;
    return ct;
  };
  function J(ie, ce, re, oe) {
    K.BasePoint.call(this, ie, "affine"), ce === null && re === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new B(ce, 16), this.y = new B(re, 16), oe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  L(J, K.BasePoint), W.prototype.point = function(ce, re, oe) {
    return new J(this, ce, re, oe);
  }, W.prototype.pointFromJSON = function(ce, re) {
    return J.fromJSON(this, ce, re);
  }, J.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ce = this.precomputed;
      if (ce && ce.beta)
        return ce.beta;
      var re = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ce) {
        var oe = this.curve, ke = function(Oe) {
          return oe.point(Oe.x.redMul(oe.endo.beta), Oe.y);
        };
        ce.beta = re, re.precomputed = {
          beta: null,
          naf: ce.naf && {
            wnd: ce.naf.wnd,
            points: ce.naf.points.map(ke)
          },
          doubles: ce.doubles && {
            step: ce.doubles.step,
            points: ce.doubles.points.map(ke)
          }
        };
      }
      return re;
    }
  }, J.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, J.fromJSON = function(ce, re, oe) {
    typeof re == "string" && (re = JSON.parse(re));
    var ke = ce.point(re[0], re[1], oe);
    if (!re[2])
      return ke;
    function Oe(at) {
      return ce.point(at[0], at[1], oe);
    }
    var it = re[2];
    return ke.precomputed = {
      beta: null,
      doubles: it.doubles && {
        step: it.doubles.step,
        points: [ke].concat(it.doubles.points.map(Oe))
      },
      naf: it.naf && {
        wnd: it.naf.wnd,
        points: [ke].concat(it.naf.points.map(Oe))
      }
    }, ke;
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.inf;
  }, J.prototype.add = function(ce) {
    if (this.inf)
      return ce;
    if (ce.inf)
      return this;
    if (this.eq(ce))
      return this.dbl();
    if (this.neg().eq(ce))
      return this.curve.point(null, null);
    if (this.x.cmp(ce.x) === 0)
      return this.curve.point(null, null);
    var re = this.y.redSub(ce.y);
    re.cmpn(0) !== 0 && (re = re.redMul(this.x.redSub(ce.x).redInvm()));
    var oe = re.redSqr().redISub(this.x).redISub(ce.x), ke = re.redMul(this.x.redSub(oe)).redISub(this.y);
    return this.curve.point(oe, ke);
  }, J.prototype.dbl = function() {
    if (this.inf)
      return this;
    var ce = this.y.redAdd(this.y);
    if (ce.cmpn(0) === 0)
      return this.curve.point(null, null);
    var re = this.curve.a, oe = this.x.redSqr(), ke = ce.redInvm(), Oe = oe.redAdd(oe).redIAdd(oe).redIAdd(re).redMul(ke), it = Oe.redSqr().redISub(this.x.redAdd(this.x)), at = Oe.redMul(this.x.redSub(it)).redISub(this.y);
    return this.curve.point(it, at);
  }, J.prototype.getX = function() {
    return this.x.fromRed();
  }, J.prototype.getY = function() {
    return this.y.fromRed();
  }, J.prototype.mul = function(ce) {
    return ce = new B(ce, 16), this.isInfinity() ? this : this._hasDoubles(ce) ? this.curve._fixedNafMul(this, ce) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ce]) : this.curve._wnafMul(this, ce);
  }, J.prototype.mulAdd = function(ce, re, oe) {
    var ke = [this, re], Oe = [ce, oe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Oe) : this.curve._wnafMulAdd(1, ke, Oe, 2);
  }, J.prototype.jmulAdd = function(ce, re, oe) {
    var ke = [this, re], Oe = [ce, oe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(ke, Oe, !0) : this.curve._wnafMulAdd(1, ke, Oe, 2, !0);
  }, J.prototype.eq = function(ce) {
    return this === ce || this.inf === ce.inf && (this.inf || this.x.cmp(ce.x) === 0 && this.y.cmp(ce.y) === 0);
  }, J.prototype.neg = function(ce) {
    if (this.inf)
      return this;
    var re = this.curve.point(this.x, this.y.redNeg());
    if (ce && this.precomputed) {
      var oe = this.precomputed, ke = function(Oe) {
        return Oe.neg();
      };
      re.precomputed = {
        naf: oe.naf && {
          wnd: oe.naf.wnd,
          points: oe.naf.points.map(ke)
        },
        doubles: oe.doubles && {
          step: oe.doubles.step,
          points: oe.doubles.points.map(ke)
        }
      };
    }
    return re;
  }, J.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var ce = this.curve.jpoint(this.x, this.y, this.curve.one);
    return ce;
  };
  function ne(ie, ce, re, oe) {
    K.BasePoint.call(this, ie, "jacobian"), ce === null && re === null && oe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new B(0)) : (this.x = new B(ce, 16), this.y = new B(re, 16), this.z = new B(oe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return L(ne, K.BasePoint), W.prototype.jpoint = function(ce, re, oe) {
    return new ne(this, ce, re, oe);
  }, ne.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var ce = this.z.redInvm(), re = ce.redSqr(), oe = this.x.redMul(re), ke = this.y.redMul(re).redMul(ce);
    return this.curve.point(oe, ke);
  }, ne.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, ne.prototype.add = function(ce) {
    if (this.isInfinity())
      return ce;
    if (ce.isInfinity())
      return this;
    var re = ce.z.redSqr(), oe = this.z.redSqr(), ke = this.x.redMul(re), Oe = ce.x.redMul(oe), it = this.y.redMul(re.redMul(ce.z)), at = ce.y.redMul(oe.redMul(this.z)), ut = ke.redSub(Oe), dt = it.redSub(at);
    if (ut.cmpn(0) === 0)
      return dt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var ct = ut.redSqr(), bt = ct.redMul(ut), vt = ke.redMul(ct), $t = dt.redSqr().redIAdd(bt).redISub(vt).redISub(vt), xt = dt.redMul(vt.redISub($t)).redISub(it.redMul(bt)), Ot = this.z.redMul(ce.z).redMul(ut);
    return this.curve.jpoint($t, xt, Ot);
  }, ne.prototype.mixedAdd = function(ce) {
    if (this.isInfinity())
      return ce.toJ();
    if (ce.isInfinity())
      return this;
    var re = this.z.redSqr(), oe = this.x, ke = ce.x.redMul(re), Oe = this.y, it = ce.y.redMul(re).redMul(this.z), at = oe.redSub(ke), ut = Oe.redSub(it);
    if (at.cmpn(0) === 0)
      return ut.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var dt = at.redSqr(), ct = dt.redMul(at), bt = oe.redMul(dt), vt = ut.redSqr().redIAdd(ct).redISub(bt).redISub(bt), $t = ut.redMul(bt.redISub(vt)).redISub(Oe.redMul(ct)), xt = this.z.redMul(at);
    return this.curve.jpoint(vt, $t, xt);
  }, ne.prototype.dblp = function(ce) {
    if (ce === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!ce)
      return this.dbl();
    var re;
    if (this.curve.zeroA || this.curve.threeA) {
      var oe = this;
      for (re = 0; re < ce; re++)
        oe = oe.dbl();
      return oe;
    }
    var ke = this.curve.a, Oe = this.curve.tinv, it = this.x, at = this.y, ut = this.z, dt = ut.redSqr().redSqr(), ct = at.redAdd(at);
    for (re = 0; re < ce; re++) {
      var bt = it.redSqr(), vt = ct.redSqr(), $t = vt.redSqr(), xt = bt.redAdd(bt).redIAdd(bt).redIAdd(ke.redMul(dt)), Ot = it.redMul(vt), At = xt.redSqr().redISub(Ot.redAdd(Ot)), yt = Ot.redISub(At), Bt = xt.redMul(yt);
      Bt = Bt.redIAdd(Bt).redISub($t);
      var gt = ct.redMul(ut);
      re + 1 < ce && (dt = dt.redMul($t)), it = At, ut = gt, ct = Bt;
    }
    return this.curve.jpoint(it, ct.redMul(Oe), ut);
  }, ne.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, ne.prototype._zeroDbl = function() {
    var ce, re, oe;
    if (this.zOne) {
      var ke = this.x.redSqr(), Oe = this.y.redSqr(), it = Oe.redSqr(), at = this.x.redAdd(Oe).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var ut = ke.redAdd(ke).redIAdd(ke), dt = ut.redSqr().redISub(at).redISub(at), ct = it.redIAdd(it);
      ct = ct.redIAdd(ct), ct = ct.redIAdd(ct), ce = dt, re = ut.redMul(at.redISub(dt)).redISub(ct), oe = this.y.redAdd(this.y);
    } else {
      var bt = this.x.redSqr(), vt = this.y.redSqr(), $t = vt.redSqr(), xt = this.x.redAdd(vt).redSqr().redISub(bt).redISub($t);
      xt = xt.redIAdd(xt);
      var Ot = bt.redAdd(bt).redIAdd(bt), At = Ot.redSqr(), yt = $t.redIAdd($t);
      yt = yt.redIAdd(yt), yt = yt.redIAdd(yt), ce = At.redISub(xt).redISub(xt), re = Ot.redMul(xt.redISub(ce)).redISub(yt), oe = this.y.redMul(this.z), oe = oe.redIAdd(oe);
    }
    return this.curve.jpoint(ce, re, oe);
  }, ne.prototype._threeDbl = function() {
    var ce, re, oe;
    if (this.zOne) {
      var ke = this.x.redSqr(), Oe = this.y.redSqr(), it = Oe.redSqr(), at = this.x.redAdd(Oe).redSqr().redISub(ke).redISub(it);
      at = at.redIAdd(at);
      var ut = ke.redAdd(ke).redIAdd(ke).redIAdd(this.curve.a), dt = ut.redSqr().redISub(at).redISub(at);
      ce = dt;
      var ct = it.redIAdd(it);
      ct = ct.redIAdd(ct), ct = ct.redIAdd(ct), re = ut.redMul(at.redISub(dt)).redISub(ct), oe = this.y.redAdd(this.y);
    } else {
      var bt = this.z.redSqr(), vt = this.y.redSqr(), $t = this.x.redMul(vt), xt = this.x.redSub(bt).redMul(this.x.redAdd(bt));
      xt = xt.redAdd(xt).redIAdd(xt);
      var Ot = $t.redIAdd($t);
      Ot = Ot.redIAdd(Ot);
      var At = Ot.redAdd(Ot);
      ce = xt.redSqr().redISub(At), oe = this.y.redAdd(this.z).redSqr().redISub(vt).redISub(bt);
      var yt = vt.redSqr();
      yt = yt.redIAdd(yt), yt = yt.redIAdd(yt), yt = yt.redIAdd(yt), re = xt.redMul(Ot.redISub(ce)).redISub(yt);
    }
    return this.curve.jpoint(ce, re, oe);
  }, ne.prototype._dbl = function() {
    var ce = this.curve.a, re = this.x, oe = this.y, ke = this.z, Oe = ke.redSqr().redSqr(), it = re.redSqr(), at = oe.redSqr(), ut = it.redAdd(it).redIAdd(it).redIAdd(ce.redMul(Oe)), dt = re.redAdd(re);
    dt = dt.redIAdd(dt);
    var ct = dt.redMul(at), bt = ut.redSqr().redISub(ct.redAdd(ct)), vt = ct.redISub(bt), $t = at.redSqr();
    $t = $t.redIAdd($t), $t = $t.redIAdd($t), $t = $t.redIAdd($t);
    var xt = ut.redMul(vt).redISub($t), Ot = oe.redAdd(oe).redMul(ke);
    return this.curve.jpoint(bt, xt, Ot);
  }, ne.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var ce = this.x.redSqr(), re = this.y.redSqr(), oe = this.z.redSqr(), ke = re.redSqr(), Oe = ce.redAdd(ce).redIAdd(ce), it = Oe.redSqr(), at = this.x.redAdd(re).redSqr().redISub(ce).redISub(ke);
    at = at.redIAdd(at), at = at.redAdd(at).redIAdd(at), at = at.redISub(it);
    var ut = at.redSqr(), dt = ke.redIAdd(ke);
    dt = dt.redIAdd(dt), dt = dt.redIAdd(dt), dt = dt.redIAdd(dt);
    var ct = Oe.redIAdd(at).redSqr().redISub(it).redISub(ut).redISub(dt), bt = re.redMul(ct);
    bt = bt.redIAdd(bt), bt = bt.redIAdd(bt);
    var vt = this.x.redMul(ut).redISub(bt);
    vt = vt.redIAdd(vt), vt = vt.redIAdd(vt);
    var $t = this.y.redMul(ct.redMul(dt.redISub(ct)).redISub(at.redMul(ut)));
    $t = $t.redIAdd($t), $t = $t.redIAdd($t), $t = $t.redIAdd($t);
    var xt = this.z.redAdd(at).redSqr().redISub(oe).redISub(ut);
    return this.curve.jpoint(vt, $t, xt);
  }, ne.prototype.mul = function(ce, re) {
    return ce = new B(ce, re), this.curve._wnafMul(this, ce);
  }, ne.prototype.eq = function(ce) {
    if (ce.type === "affine")
      return this.eq(ce.toJ());
    if (this === ce)
      return !0;
    var re = this.z.redSqr(), oe = ce.z.redSqr();
    if (this.x.redMul(oe).redISub(ce.x.redMul(re)).cmpn(0) !== 0)
      return !1;
    var ke = re.redMul(this.z), Oe = oe.redMul(ce.z);
    return this.y.redMul(Oe).redISub(ce.y.redMul(ke)).cmpn(0) === 0;
  }, ne.prototype.eqXToP = function(ce) {
    var re = this.z.redSqr(), oe = ce.toRed(this.curve.red).redMul(re);
    if (this.x.cmp(oe) === 0)
      return !0;
    for (var ke = ce.clone(), Oe = this.curve.redN.redMul(re); ; ) {
      if (ke.iadd(this.curve.n), ke.cmp(this.curve.p) >= 0)
        return !1;
      if (oe.redIAdd(Oe), this.x.cmp(oe) === 0)
        return !0;
    }
  }, ne.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, ne.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var A = requireBn$1(), B = requireInherits_browser(), L = requireBase$1(), K = requireUtils$1();
  function V(J) {
    L.call(this, "mont", J), this.a = new A(J.a, 16).toRed(this.red), this.b = new A(J.b, 16).toRed(this.red), this.i4 = new A(4).toRed(this.red).redInvm(), this.two = new A(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  B(V, L), mont = V, V.prototype.validate = function(ne) {
    var ie = ne.normalize().x, ce = ie.redSqr(), re = ce.redMul(ie).redAdd(ce.redMul(this.a)).redAdd(ie), oe = re.redSqrt();
    return oe.redSqr().cmp(re) === 0;
  };
  function W(J, ne, ie) {
    L.BasePoint.call(this, J, "projective"), ne === null && ie === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new A(ne, 16), this.z = new A(ie, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return B(W, L.BasePoint), V.prototype.decodePoint = function(ne, ie) {
    return this.point(K.toArray(ne, ie), 1);
  }, V.prototype.point = function(ne, ie) {
    return new W(this, ne, ie);
  }, V.prototype.pointFromJSON = function(ne) {
    return W.fromJSON(this, ne);
  }, W.prototype.precompute = function() {
  }, W.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, W.fromJSON = function(ne, ie) {
    return new W(ne, ie[0], ie[1] || ne.one);
  }, W.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, W.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, W.prototype.dbl = function() {
    var ne = this.x.redAdd(this.z), ie = ne.redSqr(), ce = this.x.redSub(this.z), re = ce.redSqr(), oe = ie.redSub(re), ke = ie.redMul(re), Oe = oe.redMul(re.redAdd(this.curve.a24.redMul(oe)));
    return this.curve.point(ke, Oe);
  }, W.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.diffAdd = function(ne, ie) {
    var ce = this.x.redAdd(this.z), re = this.x.redSub(this.z), oe = ne.x.redAdd(ne.z), ke = ne.x.redSub(ne.z), Oe = ke.redMul(ce), it = oe.redMul(re), at = ie.z.redMul(Oe.redAdd(it).redSqr()), ut = ie.x.redMul(Oe.redISub(it).redSqr());
    return this.curve.point(at, ut);
  }, W.prototype.mul = function(ne) {
    for (var ie = ne.clone(), ce = this, re = this.curve.point(null, null), oe = this, ke = []; ie.cmpn(0) !== 0; ie.iushrn(1))
      ke.push(ie.andln(1));
    for (var Oe = ke.length - 1; Oe >= 0; Oe--)
      ke[Oe] === 0 ? (ce = ce.diffAdd(re, oe), re = re.dbl()) : (re = ce.diffAdd(re, oe), ce = ce.dbl());
    return re;
  }, W.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, W.prototype.eq = function(ne) {
    return this.getX().cmp(ne.getX()) === 0;
  }, W.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, W.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var A = requireUtils$1(), B = requireBn$1(), L = requireInherits_browser(), K = requireBase$1(), V = A.assert;
  function W(ne) {
    this.twisted = (ne.a | 0) !== 1, this.mOneA = this.twisted && (ne.a | 0) === -1, this.extended = this.mOneA, K.call(this, "edwards", ne), this.a = new B(ne.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new B(ne.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new B(ne.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), V(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (ne.c | 0) === 1;
  }
  L(W, K), edwards = W, W.prototype._mulA = function(ie) {
    return this.mOneA ? ie.redNeg() : this.a.redMul(ie);
  }, W.prototype._mulC = function(ie) {
    return this.oneC ? ie : this.c.redMul(ie);
  }, W.prototype.jpoint = function(ie, ce, re, oe) {
    return this.point(ie, ce, re, oe);
  }, W.prototype.pointFromX = function(ie, ce) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var re = ie.redSqr(), oe = this.c2.redSub(this.a.redMul(re)), ke = this.one.redSub(this.c2.redMul(this.d).redMul(re)), Oe = oe.redMul(ke.redInvm()), it = Oe.redSqrt();
    if (it.redSqr().redSub(Oe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var at = it.fromRed().isOdd();
    return (ce && !at || !ce && at) && (it = it.redNeg()), this.point(ie, it);
  }, W.prototype.pointFromY = function(ie, ce) {
    ie = new B(ie, 16), ie.red || (ie = ie.toRed(this.red));
    var re = ie.redSqr(), oe = re.redSub(this.c2), ke = re.redMul(this.d).redMul(this.c2).redSub(this.a), Oe = oe.redMul(ke.redInvm());
    if (Oe.cmp(this.zero) === 0) {
      if (ce)
        throw new Error("invalid point");
      return this.point(this.zero, ie);
    }
    var it = Oe.redSqrt();
    if (it.redSqr().redSub(Oe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return it.fromRed().isOdd() !== ce && (it = it.redNeg()), this.point(it, ie);
  }, W.prototype.validate = function(ie) {
    if (ie.isInfinity())
      return !0;
    ie.normalize();
    var ce = ie.x.redSqr(), re = ie.y.redSqr(), oe = ce.redMul(this.a).redAdd(re), ke = this.c2.redMul(this.one.redAdd(this.d.redMul(ce).redMul(re)));
    return oe.cmp(ke) === 0;
  };
  function J(ne, ie, ce, re, oe) {
    K.BasePoint.call(this, ne, "projective"), ie === null && ce === null && re === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new B(ie, 16), this.y = new B(ce, 16), this.z = re ? new B(re, 16) : this.curve.one, this.t = oe && new B(oe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return L(J, K.BasePoint), W.prototype.pointFromJSON = function(ie) {
    return J.fromJSON(this, ie);
  }, W.prototype.point = function(ie, ce, re, oe) {
    return new J(this, ie, ce, re, oe);
  }, J.fromJSON = function(ie, ce) {
    return new J(ie, ce[0], ce[1], ce[2]);
  }, J.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, J.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, J.prototype._extDbl = function() {
    var ie = this.x.redSqr(), ce = this.y.redSqr(), re = this.z.redSqr();
    re = re.redIAdd(re);
    var oe = this.curve._mulA(ie), ke = this.x.redAdd(this.y).redSqr().redISub(ie).redISub(ce), Oe = oe.redAdd(ce), it = Oe.redSub(re), at = oe.redSub(ce), ut = ke.redMul(it), dt = Oe.redMul(at), ct = ke.redMul(at), bt = it.redMul(Oe);
    return this.curve.point(ut, dt, bt, ct);
  }, J.prototype._projDbl = function() {
    var ie = this.x.redAdd(this.y).redSqr(), ce = this.x.redSqr(), re = this.y.redSqr(), oe, ke, Oe, it, at, ut;
    if (this.curve.twisted) {
      it = this.curve._mulA(ce);
      var dt = it.redAdd(re);
      this.zOne ? (oe = ie.redSub(ce).redSub(re).redMul(dt.redSub(this.curve.two)), ke = dt.redMul(it.redSub(re)), Oe = dt.redSqr().redSub(dt).redSub(dt)) : (at = this.z.redSqr(), ut = dt.redSub(at).redISub(at), oe = ie.redSub(ce).redISub(re).redMul(ut), ke = dt.redMul(it.redSub(re)), Oe = dt.redMul(ut));
    } else
      it = ce.redAdd(re), at = this.curve._mulC(this.z).redSqr(), ut = it.redSub(at).redSub(at), oe = this.curve._mulC(ie.redISub(it)).redMul(ut), ke = this.curve._mulC(it).redMul(ce.redISub(re)), Oe = it.redMul(ut);
    return this.curve.point(oe, ke, Oe);
  }, J.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, J.prototype._extAdd = function(ie) {
    var ce = this.y.redSub(this.x).redMul(ie.y.redSub(ie.x)), re = this.y.redAdd(this.x).redMul(ie.y.redAdd(ie.x)), oe = this.t.redMul(this.curve.dd).redMul(ie.t), ke = this.z.redMul(ie.z.redAdd(ie.z)), Oe = re.redSub(ce), it = ke.redSub(oe), at = ke.redAdd(oe), ut = re.redAdd(ce), dt = Oe.redMul(it), ct = at.redMul(ut), bt = Oe.redMul(ut), vt = it.redMul(at);
    return this.curve.point(dt, ct, vt, bt);
  }, J.prototype._projAdd = function(ie) {
    var ce = this.z.redMul(ie.z), re = ce.redSqr(), oe = this.x.redMul(ie.x), ke = this.y.redMul(ie.y), Oe = this.curve.d.redMul(oe).redMul(ke), it = re.redSub(Oe), at = re.redAdd(Oe), ut = this.x.redAdd(this.y).redMul(ie.x.redAdd(ie.y)).redISub(oe).redISub(ke), dt = ce.redMul(it).redMul(ut), ct, bt;
    return this.curve.twisted ? (ct = ce.redMul(at).redMul(ke.redSub(this.curve._mulA(oe))), bt = it.redMul(at)) : (ct = ce.redMul(at).redMul(ke.redSub(oe)), bt = this.curve._mulC(it).redMul(at)), this.curve.point(dt, ct, bt);
  }, J.prototype.add = function(ie) {
    return this.isInfinity() ? ie : ie.isInfinity() ? this : this.curve.extended ? this._extAdd(ie) : this._projAdd(ie);
  }, J.prototype.mul = function(ie) {
    return this._hasDoubles(ie) ? this.curve._fixedNafMul(this, ie) : this.curve._wnafMul(this, ie);
  }, J.prototype.mulAdd = function(ie, ce, re) {
    return this.curve._wnafMulAdd(1, [this, ce], [ie, re], 2, !1);
  }, J.prototype.jmulAdd = function(ie, ce, re) {
    return this.curve._wnafMulAdd(1, [this, ce], [ie, re], 2, !0);
  }, J.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ie = this.z.redInvm();
    return this.x = this.x.redMul(ie), this.y = this.y.redMul(ie), this.t && (this.t = this.t.redMul(ie)), this.z = this.curve.one, this.zOne = !0, this;
  }, J.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, J.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, J.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, J.prototype.eq = function(ie) {
    return this === ie || this.getX().cmp(ie.getX()) === 0 && this.getY().cmp(ie.getY()) === 0;
  }, J.prototype.eqXToP = function(ie) {
    var ce = ie.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ce) === 0)
      return !0;
    for (var re = ie.clone(), oe = this.curve.redN.redMul(this.z); ; ) {
      if (re.iadd(this.curve.n), re.cmp(this.curve.p) >= 0)
        return !1;
      if (ce.redIAdd(oe), this.x.cmp(ce) === 0)
        return !0;
    }
  }, J.prototype.toP = J.prototype.normalize, J.prototype.mixedAdd = J.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(A) {
    var B = A;
    B.base = requireBase$1(), B.short = requireShort(), B.mont = requireMont(), B.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var A = requireMinimalisticAssert(), B = requireInherits_browser();
  utils$1.inherits = B;
  function L(rt, Ce) {
    return (rt.charCodeAt(Ce) & 64512) !== 55296 || Ce < 0 || Ce + 1 >= rt.length ? !1 : (rt.charCodeAt(Ce + 1) & 64512) === 56320;
  }
  function K(rt, Ce) {
    if (Array.isArray(rt))
      return rt.slice();
    if (!rt)
      return [];
    var pe = [];
    if (typeof rt == "string")
      if (Ce) {
        if (Ce === "hex")
          for (rt = rt.replace(/[^a-z0-9]+/ig, ""), rt.length % 2 !== 0 && (rt = "0" + rt), st = 0; st < rt.length; st += 2)
            pe.push(parseInt(rt[st] + rt[st + 1], 16));
      } else for (var nt = 0, st = 0; st < rt.length; st++) {
        var ot = rt.charCodeAt(st);
        ot < 128 ? pe[nt++] = ot : ot < 2048 ? (pe[nt++] = ot >> 6 | 192, pe[nt++] = ot & 63 | 128) : L(rt, st) ? (ot = 65536 + ((ot & 1023) << 10) + (rt.charCodeAt(++st) & 1023), pe[nt++] = ot >> 18 | 240, pe[nt++] = ot >> 12 & 63 | 128, pe[nt++] = ot >> 6 & 63 | 128, pe[nt++] = ot & 63 | 128) : (pe[nt++] = ot >> 12 | 224, pe[nt++] = ot >> 6 & 63 | 128, pe[nt++] = ot & 63 | 128);
      }
    else
      for (st = 0; st < rt.length; st++)
        pe[st] = rt[st] | 0;
    return pe;
  }
  utils$1.toArray = K;
  function V(rt) {
    for (var Ce = "", pe = 0; pe < rt.length; pe++)
      Ce += ne(rt[pe].toString(16));
    return Ce;
  }
  utils$1.toHex = V;
  function W(rt) {
    var Ce = rt >>> 24 | rt >>> 8 & 65280 | rt << 8 & 16711680 | (rt & 255) << 24;
    return Ce >>> 0;
  }
  utils$1.htonl = W;
  function J(rt, Ce) {
    for (var pe = "", nt = 0; nt < rt.length; nt++) {
      var st = rt[nt];
      Ce === "little" && (st = W(st)), pe += ie(st.toString(16));
    }
    return pe;
  }
  utils$1.toHex32 = J;
  function ne(rt) {
    return rt.length === 1 ? "0" + rt : rt;
  }
  utils$1.zero2 = ne;
  function ie(rt) {
    return rt.length === 7 ? "0" + rt : rt.length === 6 ? "00" + rt : rt.length === 5 ? "000" + rt : rt.length === 4 ? "0000" + rt : rt.length === 3 ? "00000" + rt : rt.length === 2 ? "000000" + rt : rt.length === 1 ? "0000000" + rt : rt;
  }
  utils$1.zero8 = ie;
  function ce(rt, Ce, pe, nt) {
    var st = pe - Ce;
    A(st % 4 === 0);
    for (var ot = new Array(st / 4), ht = 0, pt = Ce; ht < ot.length; ht++, pt += 4) {
      var ft;
      nt === "big" ? ft = rt[pt] << 24 | rt[pt + 1] << 16 | rt[pt + 2] << 8 | rt[pt + 3] : ft = rt[pt + 3] << 24 | rt[pt + 2] << 16 | rt[pt + 1] << 8 | rt[pt], ot[ht] = ft >>> 0;
    }
    return ot;
  }
  utils$1.join32 = ce;
  function re(rt, Ce) {
    for (var pe = new Array(rt.length * 4), nt = 0, st = 0; nt < rt.length; nt++, st += 4) {
      var ot = rt[nt];
      Ce === "big" ? (pe[st] = ot >>> 24, pe[st + 1] = ot >>> 16 & 255, pe[st + 2] = ot >>> 8 & 255, pe[st + 3] = ot & 255) : (pe[st + 3] = ot >>> 24, pe[st + 2] = ot >>> 16 & 255, pe[st + 1] = ot >>> 8 & 255, pe[st] = ot & 255);
    }
    return pe;
  }
  utils$1.split32 = re;
  function oe(rt, Ce) {
    return rt >>> Ce | rt << 32 - Ce;
  }
  utils$1.rotr32 = oe;
  function ke(rt, Ce) {
    return rt << Ce | rt >>> 32 - Ce;
  }
  utils$1.rotl32 = ke;
  function Oe(rt, Ce) {
    return rt + Ce >>> 0;
  }
  utils$1.sum32 = Oe;
  function it(rt, Ce, pe) {
    return rt + Ce + pe >>> 0;
  }
  utils$1.sum32_3 = it;
  function at(rt, Ce, pe, nt) {
    return rt + Ce + pe + nt >>> 0;
  }
  utils$1.sum32_4 = at;
  function ut(rt, Ce, pe, nt, st) {
    return rt + Ce + pe + nt + st >>> 0;
  }
  utils$1.sum32_5 = ut;
  function dt(rt, Ce, pe, nt) {
    var st = rt[Ce], ot = rt[Ce + 1], ht = nt + ot >>> 0, pt = (ht < nt ? 1 : 0) + pe + st;
    rt[Ce] = pt >>> 0, rt[Ce + 1] = ht;
  }
  utils$1.sum64 = dt;
  function ct(rt, Ce, pe, nt) {
    var st = Ce + nt >>> 0, ot = (st < Ce ? 1 : 0) + rt + pe;
    return ot >>> 0;
  }
  utils$1.sum64_hi = ct;
  function bt(rt, Ce, pe, nt) {
    var st = Ce + nt;
    return st >>> 0;
  }
  utils$1.sum64_lo = bt;
  function vt(rt, Ce, pe, nt, st, ot, ht, pt) {
    var ft = 0, mt = Ce;
    mt = mt + nt >>> 0, ft += mt < Ce ? 1 : 0, mt = mt + ot >>> 0, ft += mt < ot ? 1 : 0, mt = mt + pt >>> 0, ft += mt < pt ? 1 : 0;
    var lt = rt + pe + st + ht + ft;
    return lt >>> 0;
  }
  utils$1.sum64_4_hi = vt;
  function $t(rt, Ce, pe, nt, st, ot, ht, pt) {
    var ft = Ce + nt + ot + pt;
    return ft >>> 0;
  }
  utils$1.sum64_4_lo = $t;
  function xt(rt, Ce, pe, nt, st, ot, ht, pt, ft, mt) {
    var lt = 0, St = Ce;
    St = St + nt >>> 0, lt += St < Ce ? 1 : 0, St = St + ot >>> 0, lt += St < ot ? 1 : 0, St = St + pt >>> 0, lt += St < pt ? 1 : 0, St = St + mt >>> 0, lt += St < mt ? 1 : 0;
    var Ft = rt + pe + st + ht + ft + lt;
    return Ft >>> 0;
  }
  utils$1.sum64_5_hi = xt;
  function Ot(rt, Ce, pe, nt, st, ot, ht, pt, ft, mt) {
    var lt = Ce + nt + ot + pt + mt;
    return lt >>> 0;
  }
  utils$1.sum64_5_lo = Ot;
  function At(rt, Ce, pe) {
    var nt = Ce << 32 - pe | rt >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_hi = At;
  function yt(rt, Ce, pe) {
    var nt = rt << 32 - pe | Ce >>> pe;
    return nt >>> 0;
  }
  utils$1.rotr64_lo = yt;
  function Bt(rt, Ce, pe) {
    return rt >>> pe;
  }
  utils$1.shr64_hi = Bt;
  function gt(rt, Ce, pe) {
    var nt = rt << 32 - pe | Ce >>> pe;
    return nt >>> 0;
  }
  return utils$1.shr64_lo = gt, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = L, L.prototype.update = function(V, W) {
    if (V = A.toArray(V, W), this.pending ? this.pending = this.pending.concat(V) : this.pending = V, this.pendingTotal += V.length, this.pending.length >= this._delta8) {
      V = this.pending;
      var J = V.length % this._delta8;
      this.pending = V.slice(V.length - J, V.length), this.pending.length === 0 && (this.pending = null), V = A.join32(V, 0, V.length - J, this.endian);
      for (var ne = 0; ne < V.length; ne += this._delta32)
        this._update(V, ne, ne + this._delta32);
    }
    return this;
  }, L.prototype.digest = function(V) {
    return this.update(this._pad()), B(this.pending === null), this._digest(V);
  }, L.prototype._pad = function() {
    var V = this.pendingTotal, W = this._delta8, J = W - (V + this.padLength) % W, ne = new Array(J + this.padLength);
    ne[0] = 128;
    for (var ie = 1; ie < J; ie++)
      ne[ie] = 0;
    if (V <<= 3, this.endian === "big") {
      for (var ce = 8; ce < this.padLength; ce++)
        ne[ie++] = 0;
      ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = V >>> 24 & 255, ne[ie++] = V >>> 16 & 255, ne[ie++] = V >>> 8 & 255, ne[ie++] = V & 255;
    } else
      for (ne[ie++] = V & 255, ne[ie++] = V >>> 8 & 255, ne[ie++] = V >>> 16 & 255, ne[ie++] = V >>> 24 & 255, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ne[ie++] = 0, ce = 8; ce < this.padLength; ce++)
        ne[ie++] = 0;
    return ne;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var A = requireUtils(), B = A.rotr32;
  function L(re, oe, ke, Oe) {
    if (re === 0)
      return K(oe, ke, Oe);
    if (re === 1 || re === 3)
      return W(oe, ke, Oe);
    if (re === 2)
      return V(oe, ke, Oe);
  }
  common.ft_1 = L;
  function K(re, oe, ke) {
    return re & oe ^ ~re & ke;
  }
  common.ch32 = K;
  function V(re, oe, ke) {
    return re & oe ^ re & ke ^ oe & ke;
  }
  common.maj32 = V;
  function W(re, oe, ke) {
    return re ^ oe ^ ke;
  }
  common.p32 = W;
  function J(re) {
    return B(re, 2) ^ B(re, 13) ^ B(re, 22);
  }
  common.s0_256 = J;
  function ne(re) {
    return B(re, 6) ^ B(re, 11) ^ B(re, 25);
  }
  common.s1_256 = ne;
  function ie(re) {
    return B(re, 7) ^ B(re, 18) ^ re >>> 3;
  }
  common.g0_256 = ie;
  function ce(re) {
    return B(re, 17) ^ B(re, 19) ^ re >>> 10;
  }
  return common.g1_256 = ce, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = A.rotl32, V = A.sum32, W = A.sum32_5, J = L.ft_1, ne = B.BlockHash, ie = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ce() {
    if (!(this instanceof ce))
      return new ce();
    ne.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return A.inherits(ce, ne), _1 = ce, ce.blockSize = 512, ce.outSize = 160, ce.hmacStrength = 80, ce.padLength = 64, ce.prototype._update = function(oe, ke) {
    for (var Oe = this.W, it = 0; it < 16; it++)
      Oe[it] = oe[ke + it];
    for (; it < Oe.length; it++)
      Oe[it] = K(Oe[it - 3] ^ Oe[it - 8] ^ Oe[it - 14] ^ Oe[it - 16], 1);
    var at = this.h[0], ut = this.h[1], dt = this.h[2], ct = this.h[3], bt = this.h[4];
    for (it = 0; it < Oe.length; it++) {
      var vt = ~~(it / 20), $t = W(K(at, 5), J(vt, ut, dt, ct), bt, Oe[it], ie[vt]);
      bt = ct, ct = dt, dt = K(ut, 30), ut = at, at = $t;
    }
    this.h[0] = V(this.h[0], at), this.h[1] = V(this.h[1], ut), this.h[2] = V(this.h[2], dt), this.h[3] = V(this.h[3], ct), this.h[4] = V(this.h[4], bt);
  }, ce.prototype._digest = function(oe) {
    return oe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireCommon(), K = requireMinimalisticAssert(), V = A.sum32, W = A.sum32_4, J = A.sum32_5, ne = L.ch32, ie = L.maj32, ce = L.s0_256, re = L.s1_256, oe = L.g0_256, ke = L.g1_256, Oe = B.BlockHash, it = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function at() {
    if (!(this instanceof at))
      return new at();
    Oe.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = it, this.W = new Array(64);
  }
  return A.inherits(at, Oe), _256 = at, at.blockSize = 512, at.outSize = 256, at.hmacStrength = 192, at.padLength = 64, at.prototype._update = function(dt, ct) {
    for (var bt = this.W, vt = 0; vt < 16; vt++)
      bt[vt] = dt[ct + vt];
    for (; vt < bt.length; vt++)
      bt[vt] = W(ke(bt[vt - 2]), bt[vt - 7], oe(bt[vt - 15]), bt[vt - 16]);
    var $t = this.h[0], xt = this.h[1], Ot = this.h[2], At = this.h[3], yt = this.h[4], Bt = this.h[5], gt = this.h[6], rt = this.h[7];
    for (K(this.k.length === bt.length), vt = 0; vt < bt.length; vt++) {
      var Ce = J(rt, re(yt), ne(yt, Bt, gt), this.k[vt], bt[vt]), pe = V(ce($t), ie($t, xt, Ot));
      rt = gt, gt = Bt, Bt = yt, yt = V(At, Ce), At = Ot, Ot = xt, xt = $t, $t = V(Ce, pe);
    }
    this.h[0] = V(this.h[0], $t), this.h[1] = V(this.h[1], xt), this.h[2] = V(this.h[2], Ot), this.h[3] = V(this.h[3], At), this.h[4] = V(this.h[4], yt), this.h[5] = V(this.h[5], Bt), this.h[6] = V(this.h[6], gt), this.h[7] = V(this.h[7], rt);
  }, at.prototype._digest = function(dt) {
    return dt === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var A = requireUtils(), B = require_256();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return A.inherits(L, B), _224 = L, L.blockSize = 512, L.outSize = 224, L.hmacStrength = 192, L.padLength = 64, L.prototype._digest = function(V) {
    return V === "hex" ? A.toHex32(this.h.slice(0, 7), "big") : A.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var A = requireUtils(), B = requireCommon$1(), L = requireMinimalisticAssert(), K = A.rotr64_hi, V = A.rotr64_lo, W = A.shr64_hi, J = A.shr64_lo, ne = A.sum64, ie = A.sum64_hi, ce = A.sum64_lo, re = A.sum64_4_hi, oe = A.sum64_4_lo, ke = A.sum64_5_hi, Oe = A.sum64_5_lo, it = B.BlockHash, at = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function ut() {
    if (!(this instanceof ut))
      return new ut();
    it.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = at, this.W = new Array(160);
  }
  A.inherits(ut, it), _512 = ut, ut.blockSize = 1024, ut.outSize = 512, ut.hmacStrength = 192, ut.padLength = 128, ut.prototype._prepareBlock = function(pe, nt) {
    for (var st = this.W, ot = 0; ot < 32; ot++)
      st[ot] = pe[nt + ot];
    for (; ot < st.length; ot += 2) {
      var ht = gt(st[ot - 4], st[ot - 3]), pt = rt(st[ot - 4], st[ot - 3]), ft = st[ot - 14], mt = st[ot - 13], lt = yt(st[ot - 30], st[ot - 29]), St = Bt(st[ot - 30], st[ot - 29]), Ft = st[ot - 32], Gt = st[ot - 31];
      st[ot] = re(
        ht,
        pt,
        ft,
        mt,
        lt,
        St,
        Ft,
        Gt
      ), st[ot + 1] = oe(
        ht,
        pt,
        ft,
        mt,
        lt,
        St,
        Ft,
        Gt
      );
    }
  }, ut.prototype._update = function(pe, nt) {
    this._prepareBlock(pe, nt);
    var st = this.W, ot = this.h[0], ht = this.h[1], pt = this.h[2], ft = this.h[3], mt = this.h[4], lt = this.h[5], St = this.h[6], Ft = this.h[7], Gt = this.h[8], qt = this.h[9], Pt = this.h[10], Tt = this.h[11], Ut = this.h[12], Wt = this.h[13], It = this.h[14], Rt = this.h[15];
    L(this.k.length === st.length);
    for (var jt = 0; jt < st.length; jt += 2) {
      var Jt = It, er = Rt, nr = Ot(Gt, qt), fr = At(Gt, qt), lr = dt(Gt, qt, Pt, Tt, Ut), Yt = ct(Gt, qt, Pt, Tt, Ut, Wt), Pr = this.k[jt], or = this.k[jt + 1], Ar = st[jt], Br = st[jt + 1], cr = ke(
        Jt,
        er,
        nr,
        fr,
        lr,
        Yt,
        Pr,
        or,
        Ar,
        Br
      ), xr = Oe(
        Jt,
        er,
        nr,
        fr,
        lr,
        Yt,
        Pr,
        or,
        Ar,
        Br
      );
      Jt = $t(ot, ht), er = xt(ot, ht), nr = bt(ot, ht, pt, ft, mt), fr = vt(ot, ht, pt, ft, mt, lt);
      var Ir = ie(Jt, er, nr, fr), gr = ce(Jt, er, nr, fr);
      It = Ut, Rt = Wt, Ut = Pt, Wt = Tt, Pt = Gt, Tt = qt, Gt = ie(St, Ft, cr, xr), qt = ce(Ft, Ft, cr, xr), St = mt, Ft = lt, mt = pt, lt = ft, pt = ot, ft = ht, ot = ie(cr, xr, Ir, gr), ht = ce(cr, xr, Ir, gr);
    }
    ne(this.h, 0, ot, ht), ne(this.h, 2, pt, ft), ne(this.h, 4, mt, lt), ne(this.h, 6, St, Ft), ne(this.h, 8, Gt, qt), ne(this.h, 10, Pt, Tt), ne(this.h, 12, Ut, Wt), ne(this.h, 14, It, Rt);
  }, ut.prototype._digest = function(pe) {
    return pe === "hex" ? A.toHex32(this.h, "big") : A.split32(this.h, "big");
  };
  function dt(Ce, pe, nt, st, ot) {
    var ht = Ce & nt ^ ~Ce & ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function ct(Ce, pe, nt, st, ot, ht) {
    var pt = pe & st ^ ~pe & ht;
    return pt < 0 && (pt += 4294967296), pt;
  }
  function bt(Ce, pe, nt, st, ot) {
    var ht = Ce & nt ^ Ce & ot ^ nt & ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function vt(Ce, pe, nt, st, ot, ht) {
    var pt = pe & st ^ pe & ht ^ st & ht;
    return pt < 0 && (pt += 4294967296), pt;
  }
  function $t(Ce, pe) {
    var nt = K(Ce, pe, 28), st = K(pe, Ce, 2), ot = K(pe, Ce, 7), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function xt(Ce, pe) {
    var nt = V(Ce, pe, 28), st = V(pe, Ce, 2), ot = V(pe, Ce, 7), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function Ot(Ce, pe) {
    var nt = K(Ce, pe, 14), st = K(Ce, pe, 18), ot = K(pe, Ce, 9), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function At(Ce, pe) {
    var nt = V(Ce, pe, 14), st = V(Ce, pe, 18), ot = V(pe, Ce, 9), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function yt(Ce, pe) {
    var nt = K(Ce, pe, 1), st = K(Ce, pe, 8), ot = W(Ce, pe, 7), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function Bt(Ce, pe) {
    var nt = V(Ce, pe, 1), st = V(Ce, pe, 8), ot = J(Ce, pe, 7), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function gt(Ce, pe) {
    var nt = K(Ce, pe, 19), st = K(pe, Ce, 29), ot = W(Ce, pe, 6), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  function rt(Ce, pe) {
    var nt = V(Ce, pe, 19), st = V(pe, Ce, 29), ot = J(Ce, pe, 6), ht = nt ^ st ^ ot;
    return ht < 0 && (ht += 4294967296), ht;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var A = requireUtils(), B = require_512();
  function L() {
    if (!(this instanceof L))
      return new L();
    B.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return A.inherits(L, B), _384 = L, L.blockSize = 1024, L.outSize = 384, L.hmacStrength = 192, L.padLength = 128, L.prototype._digest = function(V) {
    return V === "hex" ? A.toHex32(this.h.slice(0, 12), "big") : A.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var A = requireUtils(), B = requireCommon$1(), L = A.rotl32, K = A.sum32, V = A.sum32_3, W = A.sum32_4, J = B.BlockHash;
  function ne() {
    if (!(this instanceof ne))
      return new ne();
    J.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  A.inherits(ne, J), ripemd.ripemd160 = ne, ne.blockSize = 512, ne.outSize = 160, ne.hmacStrength = 192, ne.padLength = 64, ne.prototype._update = function(ut, dt) {
    for (var ct = this.h[0], bt = this.h[1], vt = this.h[2], $t = this.h[3], xt = this.h[4], Ot = ct, At = bt, yt = vt, Bt = $t, gt = xt, rt = 0; rt < 80; rt++) {
      var Ce = K(
        L(
          W(ct, ie(rt, bt, vt, $t), ut[oe[rt] + dt], ce(rt)),
          Oe[rt]
        ),
        xt
      );
      ct = xt, xt = $t, $t = L(vt, 10), vt = bt, bt = Ce, Ce = K(
        L(
          W(Ot, ie(79 - rt, At, yt, Bt), ut[ke[rt] + dt], re(rt)),
          it[rt]
        ),
        gt
      ), Ot = gt, gt = Bt, Bt = L(yt, 10), yt = At, At = Ce;
    }
    Ce = V(this.h[1], vt, Bt), this.h[1] = V(this.h[2], $t, gt), this.h[2] = V(this.h[3], xt, Ot), this.h[3] = V(this.h[4], ct, At), this.h[4] = V(this.h[0], bt, yt), this.h[0] = Ce;
  }, ne.prototype._digest = function(ut) {
    return ut === "hex" ? A.toHex32(this.h, "little") : A.split32(this.h, "little");
  };
  function ie(at, ut, dt, ct) {
    return at <= 15 ? ut ^ dt ^ ct : at <= 31 ? ut & dt | ~ut & ct : at <= 47 ? (ut | ~dt) ^ ct : at <= 63 ? ut & ct | dt & ~ct : ut ^ (dt | ~ct);
  }
  function ce(at) {
    return at <= 15 ? 0 : at <= 31 ? 1518500249 : at <= 47 ? 1859775393 : at <= 63 ? 2400959708 : 2840853838;
  }
  function re(at) {
    return at <= 15 ? 1352829926 : at <= 31 ? 1548603684 : at <= 47 ? 1836072691 : at <= 63 ? 2053994217 : 0;
  }
  var oe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ke = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Oe = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], it = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var A = requireUtils(), B = requireMinimalisticAssert();
  function L(K, V, W) {
    if (!(this instanceof L))
      return new L(K, V, W);
    this.Hash = K, this.blockSize = K.blockSize / 8, this.outSize = K.outSize / 8, this.inner = null, this.outer = null, this._init(A.toArray(V, W));
  }
  return hmac = L, L.prototype._init = function(V) {
    V.length > this.blockSize && (V = new this.Hash().update(V).digest()), B(V.length <= this.blockSize);
    for (var W = V.length; W < this.blockSize; W++)
      V.push(0);
    for (W = 0; W < V.length; W++)
      V[W] ^= 54;
    for (this.inner = new this.Hash().update(V), W = 0; W < V.length; W++)
      V[W] ^= 106;
    this.outer = new this.Hash().update(V);
  }, L.prototype.update = function(V, W) {
    return this.inner.update(V, W), this;
  }, L.prototype.digest = function(V) {
    return this.outer.update(this.inner.digest()), this.outer.digest(V);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(A) {
    var B = A;
    B.utils = requireUtils(), B.common = requireCommon$1(), B.sha = requireSha(), B.ripemd = requireRipemd(), B.hmac = requireHmac(), B.sha1 = B.sha.sha1, B.sha256 = B.sha.sha256, B.sha224 = B.sha.sha224, B.sha384 = B.sha.sha384, B.sha512 = B.sha.sha512, B.ripemd160 = B.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(A) {
    var B = A, L = requireHash(), K = requireCurve(), V = requireUtils$1(), W = V.assert;
    function J(ce) {
      ce.type === "short" ? this.curve = new K.short(ce) : ce.type === "edwards" ? this.curve = new K.edwards(ce) : this.curve = new K.mont(ce), this.g = this.curve.g, this.n = this.curve.n, this.hash = ce.hash, W(this.g.validate(), "Invalid curve"), W(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    B.PresetCurve = J;
    function ne(ce, re) {
      Object.defineProperty(B, ce, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var oe = new J(re);
          return Object.defineProperty(B, ce, {
            configurable: !0,
            enumerable: !0,
            value: oe
          }), oe;
        }
      });
    }
    ne("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: L.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), ne("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: L.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), ne("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: L.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), ne("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: L.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), ne("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: L.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), ne("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), ne("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: L.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ie;
    try {
      ie = requireSecp256k1();
    } catch {
      ie = void 0;
    }
    ne("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: L.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ie
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var A = requireHash(), B = requireUtils$2(), L = requireMinimalisticAssert();
  function K(V) {
    if (!(this instanceof K))
      return new K(V);
    this.hash = V.hash, this.predResist = !!V.predResist, this.outLen = this.hash.outSize, this.minEntropy = V.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var W = B.toArray(V.entropy, V.entropyEnc || "hex"), J = B.toArray(V.nonce, V.nonceEnc || "hex"), ne = B.toArray(V.pers, V.persEnc || "hex");
    L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(W, J, ne);
  }
  return hmacDrbg = K, K.prototype._init = function(W, J, ne) {
    var ie = W.concat(J).concat(ne);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ce = 0; ce < this.V.length; ce++)
      this.K[ce] = 0, this.V[ce] = 1;
    this._update(ie), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, K.prototype._hmac = function() {
    return new A.hmac(this.hash, this.K);
  }, K.prototype._update = function(W) {
    var J = this._hmac().update(this.V).update([0]);
    W && (J = J.update(W)), this.K = J.digest(), this.V = this._hmac().update(this.V).digest(), W && (this.K = this._hmac().update(this.V).update([1]).update(W).digest(), this.V = this._hmac().update(this.V).digest());
  }, K.prototype.reseed = function(W, J, ne, ie) {
    typeof J != "string" && (ie = ne, ne = J, J = null), W = B.toArray(W, J), ne = B.toArray(ne, ie), L(
      W.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(W.concat(ne || [])), this._reseed = 1;
  }, K.prototype.generate = function(W, J, ne, ie) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof J != "string" && (ie = ne, ne = J, J = null), ne && (ne = B.toArray(ne, ie || "hex"), this._update(ne));
    for (var ce = []; ce.length < W; )
      this.V = this._hmac().update(this.V).digest(), ce = ce.concat(this.V);
    var re = ce.slice(0, W);
    return this._update(ne), this._reseed++, B.encode(re, J);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(V, W) {
    this.ec = V, this.priv = null, this.pub = null, W.priv && this._importPrivate(W.priv, W.privEnc), W.pub && this._importPublic(W.pub, W.pubEnc);
  }
  return key$1 = K, K.fromPublic = function(W, J, ne) {
    return J instanceof K ? J : new K(W, {
      pub: J,
      pubEnc: ne
    });
  }, K.fromPrivate = function(W, J, ne) {
    return J instanceof K ? J : new K(W, {
      priv: J,
      privEnc: ne
    });
  }, K.prototype.validate = function() {
    var W = this.getPublic();
    return W.isInfinity() ? { result: !1, reason: "Invalid public key" } : W.validate() ? W.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, K.prototype.getPublic = function(W, J) {
    return typeof W == "string" && (J = W, W = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), J ? this.pub.encode(J, W) : this.pub;
  }, K.prototype.getPrivate = function(W) {
    return W === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, K.prototype._importPrivate = function(W, J) {
    this.priv = new A(W, J || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, K.prototype._importPublic = function(W, J) {
    if (W.x || W.y) {
      this.ec.curve.type === "mont" ? L(W.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && L(W.x && W.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(W.x, W.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(W, J);
  }, K.prototype.derive = function(W) {
    return W.validate() || L(W.validate(), "public point not validated"), W.mul(this.priv).getX();
  }, K.prototype.sign = function(W, J, ne) {
    return this.ec.sign(W, this, J, ne);
  }, K.prototype.verify = function(W, J, ne) {
    return this.ec.verify(W, J, this, void 0, ne);
  }, K.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert;
  function K(ie, ce) {
    if (ie instanceof K)
      return ie;
    this._importDER(ie, ce) || (L(ie.r && ie.s, "Signature without r or s"), this.r = new A(ie.r, 16), this.s = new A(ie.s, 16), ie.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ie.recoveryParam);
  }
  signature$1 = K;
  function V() {
    this.place = 0;
  }
  function W(ie, ce) {
    var re = ie[ce.place++];
    if (!(re & 128))
      return re;
    var oe = re & 15;
    if (oe === 0 || oe > 4 || ie[ce.place] === 0)
      return !1;
    for (var ke = 0, Oe = 0, it = ce.place; Oe < oe; Oe++, it++)
      ke <<= 8, ke |= ie[it], ke >>>= 0;
    return ke <= 127 ? !1 : (ce.place = it, ke);
  }
  function J(ie) {
    for (var ce = 0, re = ie.length - 1; !ie[ce] && !(ie[ce + 1] & 128) && ce < re; )
      ce++;
    return ce === 0 ? ie : ie.slice(ce);
  }
  K.prototype._importDER = function(ce, re) {
    ce = B.toArray(ce, re);
    var oe = new V();
    if (ce[oe.place++] !== 48)
      return !1;
    var ke = W(ce, oe);
    if (ke === !1 || ke + oe.place !== ce.length || ce[oe.place++] !== 2)
      return !1;
    var Oe = W(ce, oe);
    if (Oe === !1 || ce[oe.place] & 128)
      return !1;
    var it = ce.slice(oe.place, Oe + oe.place);
    if (oe.place += Oe, ce[oe.place++] !== 2)
      return !1;
    var at = W(ce, oe);
    if (at === !1 || ce.length !== at + oe.place || ce[oe.place] & 128)
      return !1;
    var ut = ce.slice(oe.place, at + oe.place);
    if (it[0] === 0)
      if (it[1] & 128)
        it = it.slice(1);
      else
        return !1;
    if (ut[0] === 0)
      if (ut[1] & 128)
        ut = ut.slice(1);
      else
        return !1;
    return this.r = new A(it), this.s = new A(ut), this.recoveryParam = null, !0;
  };
  function ne(ie, ce) {
    if (ce < 128) {
      ie.push(ce);
      return;
    }
    var re = 1 + (Math.log(ce) / Math.LN2 >>> 3);
    for (ie.push(re | 128); --re; )
      ie.push(ce >>> (re << 3) & 255);
    ie.push(ce);
  }
  return K.prototype.toDER = function(ce) {
    var re = this.r.toArray(), oe = this.s.toArray();
    for (re[0] & 128 && (re = [0].concat(re)), oe[0] & 128 && (oe = [0].concat(oe)), re = J(re), oe = J(oe); !oe[0] && !(oe[1] & 128); )
      oe = oe.slice(1);
    var ke = [2];
    ne(ke, re.length), ke = ke.concat(re), ke.push(2), ne(ke, oe.length);
    var Oe = ke.concat(oe), it = [48];
    return ne(it, Oe.length), it = it.concat(Oe), B.encode(it, ce);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var A = requireBn$1(), B = requireHmacDrbg(), L = requireUtils$1(), K = requireCurves(), V = requireBrorand(), W = L.assert, J = requireKey$1(), ne = requireSignature$1();
  function ie(ce) {
    if (!(this instanceof ie))
      return new ie(ce);
    typeof ce == "string" && (W(
      Object.prototype.hasOwnProperty.call(K, ce),
      "Unknown curve " + ce
    ), ce = K[ce]), ce instanceof K.PresetCurve && (ce = { curve: ce }), this.curve = ce.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ce.curve.g, this.g.precompute(ce.curve.n.bitLength() + 1), this.hash = ce.hash || ce.curve.hash;
  }
  return ec = ie, ie.prototype.keyPair = function(re) {
    return new J(this, re);
  }, ie.prototype.keyFromPrivate = function(re, oe) {
    return J.fromPrivate(this, re, oe);
  }, ie.prototype.keyFromPublic = function(re, oe) {
    return J.fromPublic(this, re, oe);
  }, ie.prototype.genKeyPair = function(re) {
    re || (re = {});
    for (var oe = new B({
      hash: this.hash,
      pers: re.pers,
      persEnc: re.persEnc || "utf8",
      entropy: re.entropy || V(this.hash.hmacStrength),
      entropyEnc: re.entropy && re.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), ke = this.n.byteLength(), Oe = this.n.sub(new A(2)); ; ) {
      var it = new A(oe.generate(ke));
      if (!(it.cmp(Oe) > 0))
        return it.iaddn(1), this.keyFromPrivate(it);
    }
  }, ie.prototype._truncateToN = function(re, oe, ke) {
    var Oe;
    if (A.isBN(re) || typeof re == "number")
      re = new A(re, 16), Oe = re.byteLength();
    else if (typeof re == "object")
      Oe = re.length, re = new A(re, 16);
    else {
      var it = re.toString();
      Oe = it.length + 1 >>> 1, re = new A(it, 16);
    }
    typeof ke != "number" && (ke = Oe * 8);
    var at = ke - this.n.bitLength();
    return at > 0 && (re = re.ushrn(at)), !oe && re.cmp(this.n) >= 0 ? re.sub(this.n) : re;
  }, ie.prototype.sign = function(re, oe, ke, Oe) {
    if (typeof ke == "object" && (Oe = ke, ke = null), Oe || (Oe = {}), typeof re != "string" && typeof re != "number" && !A.isBN(re)) {
      W(
        typeof re == "object" && re && typeof re.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), W(re.length >>> 0 === re.length);
      for (var it = 0; it < re.length; it++) W((re[it] & 255) === re[it]);
    }
    oe = this.keyFromPrivate(oe, ke), re = this._truncateToN(re, !1, Oe.msgBitLength), W(!re.isNeg(), "Can not sign a negative message");
    var at = this.n.byteLength(), ut = oe.getPrivate().toArray("be", at), dt = re.toArray("be", at);
    W(new A(dt).eq(re), "Can not sign message");
    for (var ct = new B({
      hash: this.hash,
      entropy: ut,
      nonce: dt,
      pers: Oe.pers,
      persEnc: Oe.persEnc || "utf8"
    }), bt = this.n.sub(new A(1)), vt = 0; ; vt++) {
      var $t = Oe.k ? Oe.k(vt) : new A(ct.generate(this.n.byteLength()));
      if ($t = this._truncateToN($t, !0), !($t.cmpn(1) <= 0 || $t.cmp(bt) >= 0)) {
        var xt = this.g.mul($t);
        if (!xt.isInfinity()) {
          var Ot = xt.getX(), At = Ot.umod(this.n);
          if (At.cmpn(0) !== 0) {
            var yt = $t.invm(this.n).mul(At.mul(oe.getPrivate()).iadd(re));
            if (yt = yt.umod(this.n), yt.cmpn(0) !== 0) {
              var Bt = (xt.getY().isOdd() ? 1 : 0) | (Ot.cmp(At) !== 0 ? 2 : 0);
              return Oe.canonical && yt.cmp(this.nh) > 0 && (yt = this.n.sub(yt), Bt ^= 1), new ne({ r: At, s: yt, recoveryParam: Bt });
            }
          }
        }
      }
    }
  }, ie.prototype.verify = function(re, oe, ke, Oe, it) {
    it || (it = {}), re = this._truncateToN(re, !1, it.msgBitLength), ke = this.keyFromPublic(ke, Oe), oe = new ne(oe, "hex");
    var at = oe.r, ut = oe.s;
    if (at.cmpn(1) < 0 || at.cmp(this.n) >= 0 || ut.cmpn(1) < 0 || ut.cmp(this.n) >= 0)
      return !1;
    var dt = ut.invm(this.n), ct = dt.mul(re).umod(this.n), bt = dt.mul(at).umod(this.n), vt;
    return this.curve._maxwellTrick ? (vt = this.g.jmulAdd(ct, ke.getPublic(), bt), vt.isInfinity() ? !1 : vt.eqXToP(at)) : (vt = this.g.mulAdd(ct, ke.getPublic(), bt), vt.isInfinity() ? !1 : vt.getX().umod(this.n).cmp(at) === 0);
  }, ie.prototype.recoverPubKey = function(ce, re, oe, ke) {
    W((3 & oe) === oe, "The recovery param is more than two bits"), re = new ne(re, ke);
    var Oe = this.n, it = new A(ce), at = re.r, ut = re.s, dt = oe & 1, ct = oe >> 1;
    if (at.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ct)
      throw new Error("Unable to find sencond key candinate");
    ct ? at = this.curve.pointFromX(at.add(this.curve.n), dt) : at = this.curve.pointFromX(at, dt);
    var bt = re.r.invm(Oe), vt = Oe.sub(it).mul(bt).umod(Oe), $t = ut.mul(bt).umod(Oe);
    return this.g.mulAdd(vt, at, $t);
  }, ie.prototype.getKeyRecoveryParam = function(ce, re, oe, ke) {
    if (re = new ne(re, ke), re.recoveryParam !== null)
      return re.recoveryParam;
    for (var Oe = 0; Oe < 4; Oe++) {
      var it;
      try {
        it = this.recoverPubKey(ce, re, Oe);
      } catch {
        continue;
      }
      if (it.eq(oe))
        return Oe;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var A = requireUtils$1(), B = A.assert, L = A.parseBytes, K = A.cachedProperty;
  function V(W, J) {
    this.eddsa = W, this._secret = L(J.secret), W.isPoint(J.pub) ? this._pub = J.pub : this._pubBytes = L(J.pub);
  }
  return V.fromPublic = function(J, ne) {
    return ne instanceof V ? ne : new V(J, { pub: ne });
  }, V.fromSecret = function(J, ne) {
    return ne instanceof V ? ne : new V(J, { secret: ne });
  }, V.prototype.secret = function() {
    return this._secret;
  }, K(V, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), K(V, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), K(V, "privBytes", function() {
    var J = this.eddsa, ne = this.hash(), ie = J.encodingLength - 1, ce = ne.slice(0, J.encodingLength);
    return ce[0] &= 248, ce[ie] &= 127, ce[ie] |= 64, ce;
  }), K(V, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), K(V, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), K(V, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), V.prototype.sign = function(J) {
    return B(this._secret, "KeyPair can only verify"), this.eddsa.sign(J, this);
  }, V.prototype.verify = function(J, ne) {
    return this.eddsa.verify(J, ne, this);
  }, V.prototype.getSecret = function(J) {
    return B(this._secret, "KeyPair is public only"), A.encode(this.secret(), J);
  }, V.prototype.getPublic = function(J) {
    return A.encode(this.pubBytes(), J);
  }, key = V, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var A = requireBn$1(), B = requireUtils$1(), L = B.assert, K = B.cachedProperty, V = B.parseBytes;
  function W(J, ne) {
    this.eddsa = J, typeof ne != "object" && (ne = V(ne)), Array.isArray(ne) && (L(ne.length === J.encodingLength * 2, "Signature has invalid size"), ne = {
      R: ne.slice(0, J.encodingLength),
      S: ne.slice(J.encodingLength)
    }), L(ne.R && ne.S, "Signature without R or S"), J.isPoint(ne.R) && (this._R = ne.R), ne.S instanceof A && (this._S = ne.S), this._Rencoded = Array.isArray(ne.R) ? ne.R : ne.Rencoded, this._Sencoded = Array.isArray(ne.S) ? ne.S : ne.Sencoded;
  }
  return K(W, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), K(W, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), K(W, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), K(W, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), W.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, W.prototype.toHex = function() {
    return B.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = W, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var A = requireHash(), B = requireCurves(), L = requireUtils$1(), K = L.assert, V = L.parseBytes, W = requireKey(), J = requireSignature();
  function ne(ie) {
    if (K(ie === "ed25519", "only tested with ed25519 so far"), !(this instanceof ne))
      return new ne(ie);
    ie = B[ie].curve, this.curve = ie, this.g = ie.g, this.g.precompute(ie.n.bitLength() + 1), this.pointClass = ie.point().constructor, this.encodingLength = Math.ceil(ie.n.bitLength() / 8), this.hash = A.sha512;
  }
  return eddsa = ne, ne.prototype.sign = function(ce, re) {
    ce = V(ce);
    var oe = this.keyFromSecret(re), ke = this.hashInt(oe.messagePrefix(), ce), Oe = this.g.mul(ke), it = this.encodePoint(Oe), at = this.hashInt(it, oe.pubBytes(), ce).mul(oe.priv()), ut = ke.add(at).umod(this.curve.n);
    return this.makeSignature({ R: Oe, S: ut, Rencoded: it });
  }, ne.prototype.verify = function(ce, re, oe) {
    if (ce = V(ce), re = this.makeSignature(re), re.S().gte(re.eddsa.curve.n) || re.S().isNeg())
      return !1;
    var ke = this.keyFromPublic(oe), Oe = this.hashInt(re.Rencoded(), ke.pubBytes(), ce), it = this.g.mul(re.S()), at = re.R().add(ke.pub().mul(Oe));
    return at.eq(it);
  }, ne.prototype.hashInt = function() {
    for (var ce = this.hash(), re = 0; re < arguments.length; re++)
      ce.update(arguments[re]);
    return L.intFromLE(ce.digest()).umod(this.curve.n);
  }, ne.prototype.keyFromPublic = function(ce) {
    return W.fromPublic(this, ce);
  }, ne.prototype.keyFromSecret = function(ce) {
    return W.fromSecret(this, ce);
  }, ne.prototype.makeSignature = function(ce) {
    return ce instanceof J ? ce : new J(this, ce);
  }, ne.prototype.encodePoint = function(ce) {
    var re = ce.getY().toArray("le", this.encodingLength);
    return re[this.encodingLength - 1] |= ce.getX().isOdd() ? 128 : 0, re;
  }, ne.prototype.decodePoint = function(ce) {
    ce = L.parseBytes(ce);
    var re = ce.length - 1, oe = ce.slice(0, re).concat(ce[re] & -129), ke = (ce[re] & 128) !== 0, Oe = L.intFromLE(oe);
    return this.curve.pointFromY(Oe, ke);
  }, ne.prototype.encodeInt = function(ce) {
    return ce.toArray("le", this.encodingLength);
  }, ne.prototype.decodeInt = function(ce) {
    return L.intFromLE(ce);
  }, ne.prototype.isPoint = function(ce) {
    return ce instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(A) {
    var B = A;
    B.version = require$$0.version, B.utils = requireUtils$1(), B.rand = requireBrorand(), B.curve = requireCurve(), B.curves = requireCurves(), B.ec = requireEc(), B.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(A, B) {
      if (A.indexOf) return A.indexOf(B);
      for (var L = 0; L < A.length; L++)
        if (A[L] === B) return L;
      return -1;
    }, Object_keys = function(A) {
      if (Object.keys) return Object.keys(A);
      var B = [];
      for (var L in A) B.push(L);
      return B;
    }, forEach = function(A, B) {
      if (A.forEach) return A.forEach(B);
      for (var L = 0; L < A.length; L++)
        B(A[L], L, A);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(A, B, L) {
          Object.defineProperty(A, B, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: L
          });
        };
      } catch {
        return function(B, L, K) {
          B[L] = K;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(B) {
      if (!(this instanceof Script)) return new Script(B);
      this.code = B;
    };
    Script.prototype.runInContext = function(A) {
      if (!(A instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var B = document.createElement("iframe");
      B.style || (B.style = {}), B.style.display = "none", document.body.appendChild(B);
      var L = B.contentWindow, K = L.eval, V = L.execScript;
      !K && V && (V.call(L, "null"), K = L.eval), forEach(Object_keys(A), function(ne) {
        L[ne] = A[ne];
      }), forEach(globals, function(ne) {
        A[ne] && (L[ne] = A[ne]);
      });
      var W = Object_keys(L), J = K.call(L, this.code);
      return forEach(Object_keys(L), function(ne) {
        (ne in A || indexOf(W, ne) === -1) && (A[ne] = L[ne]);
      }), forEach(globals, function(ne) {
        ne in A || defineProp(A, ne, L[ne]);
      }), document.body.removeChild(B), J;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(A) {
      var B = Script.createContext(A), L = this.runInContext(B);
      return A && forEach(Object_keys(B), function(K) {
        A[K] = B[K];
      }), L;
    }, forEach(Object_keys(Script.prototype), function(A) {
      exports[A] = Script[A] = function(B) {
        var L = Script(B);
        return L[A].apply(L, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(A) {
      return A instanceof Context;
    }, exports.createScript = function(A) {
      return exports.Script(A);
    }, exports.createContext = Script.createContext = function(A) {
      var B = new Context();
      return typeof A == "object" && forEach(Object_keys(A), function(L) {
        B[L] = A[L];
      }), B;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(A) {
    var B = requireAsn1$1(), L = requireInherits_browser(), K = A;
    K.define = function(J, ne) {
      return new V(J, ne);
    };
    function V(W, J) {
      this.name = W, this.body = J, this.decoders = {}, this.encoders = {};
    }
    V.prototype._createNamed = function(J) {
      var ne;
      try {
        ne = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        ne = function(ce) {
          this._initNamed(ce);
        };
      }
      return L(ne, J), ne.prototype._initNamed = function(ce) {
        J.call(this, ce);
      }, new ne(this);
    }, V.prototype._getDecoder = function(J) {
      return J = J || "der", this.decoders.hasOwnProperty(J) || (this.decoders[J] = this._createNamed(B.decoders[J])), this.decoders[J];
    }, V.prototype.decode = function(J, ne, ie) {
      return this._getDecoder(ne).decode(J, ie);
    }, V.prototype._getEncoder = function(J) {
      return J = J || "der", this.encoders.hasOwnProperty(J) || (this.encoders[J] = this._createNamed(B.encoders[J])), this.encoders[J];
    }, V.prototype.encode = function(J, ne, ie) {
      return this._getEncoder(ne).encode(J, ie);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var A = requireInherits_browser();
  function B(K) {
    this._reporterState = {
      obj: null,
      path: [],
      options: K || {},
      errors: []
    };
  }
  reporter.Reporter = B, B.prototype.isError = function(V) {
    return V instanceof L;
  }, B.prototype.save = function() {
    var V = this._reporterState;
    return { obj: V.obj, pathLen: V.path.length };
  }, B.prototype.restore = function(V) {
    var W = this._reporterState;
    W.obj = V.obj, W.path = W.path.slice(0, V.pathLen);
  }, B.prototype.enterKey = function(V) {
    return this._reporterState.path.push(V);
  }, B.prototype.exitKey = function(V) {
    var W = this._reporterState;
    W.path = W.path.slice(0, V - 1);
  }, B.prototype.leaveKey = function(V, W, J) {
    var ne = this._reporterState;
    this.exitKey(V), ne.obj !== null && (ne.obj[W] = J);
  }, B.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, B.prototype.enterObject = function() {
    var V = this._reporterState, W = V.obj;
    return V.obj = {}, W;
  }, B.prototype.leaveObject = function(V) {
    var W = this._reporterState, J = W.obj;
    return W.obj = V, J;
  }, B.prototype.error = function(V) {
    var W, J = this._reporterState, ne = V instanceof L;
    if (ne ? W = V : W = new L(J.path.map(function(ie) {
      return "[" + JSON.stringify(ie) + "]";
    }).join(""), V.message || V, V.stack), !J.options.partial)
      throw W;
    return ne || J.errors.push(W), W;
  }, B.prototype.wrapResult = function(V) {
    var W = this._reporterState;
    return W.options.partial ? {
      result: this.isError(V) ? null : V,
      errors: W.errors
    } : V;
  };
  function L(K, V) {
    this.path = K, this.rethrow(V);
  }
  return A(L, Error), L.prototype.rethrow = function(V) {
    if (this.message = V + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, L), !this.stack)
      try {
        throw new Error(this.message);
      } catch (W) {
        this.stack = W.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var A = requireInherits_browser(), B = requireBase().Reporter, L = require$$0$1.Buffer;
  function K(W, J) {
    if (B.call(this, J), !L.isBuffer(W)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = W, this.offset = 0, this.length = W.length;
  }
  A(K, B), buffer.DecoderBuffer = K, K.prototype.save = function() {
    return { offset: this.offset, reporter: B.prototype.save.call(this) };
  }, K.prototype.restore = function(J) {
    var ne = new K(this.base);
    return ne.offset = J.offset, ne.length = this.offset, this.offset = J.offset, B.prototype.restore.call(this, J.reporter), ne;
  }, K.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, K.prototype.readUInt8 = function(J) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(J || "DecoderBuffer overrun");
  }, K.prototype.skip = function(J, ne) {
    if (!(this.offset + J <= this.length))
      return this.error(ne || "DecoderBuffer overrun");
    var ie = new K(this.base);
    return ie._reporterState = this._reporterState, ie.offset = this.offset, ie.length = this.offset + J, this.offset += J, ie;
  }, K.prototype.raw = function(J) {
    return this.base.slice(J ? J.offset : this.offset, this.length);
  };
  function V(W, J) {
    if (Array.isArray(W))
      this.length = 0, this.value = W.map(function(ne) {
        return ne instanceof V || (ne = new V(ne, J)), this.length += ne.length, ne;
      }, this);
    else if (typeof W == "number") {
      if (!(0 <= W && W <= 255))
        return J.error("non-byte EncoderBuffer value");
      this.value = W, this.length = 1;
    } else if (typeof W == "string")
      this.value = W, this.length = L.byteLength(W);
    else if (L.isBuffer(W))
      this.value = W, this.length = W.length;
    else
      return J.error("Unsupported type: " + typeof W);
  }
  return buffer.EncoderBuffer = V, V.prototype.join = function(J, ne) {
    return J || (J = new L(this.length)), ne || (ne = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ie) {
      ie.join(J, ne), ne += ie.length;
    }) : (typeof this.value == "number" ? J[ne] = this.value : typeof this.value == "string" ? J.write(this.value, ne) : L.isBuffer(this.value) && this.value.copy(J, ne), ne += this.length)), J;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var A = requireBase().Reporter, B = requireBase().EncoderBuffer, L = requireBase().DecoderBuffer, K = requireMinimalisticAssert(), V = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], W = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(V), J = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function ne(ce, re) {
    var oe = {};
    this._baseState = oe, oe.enc = ce, oe.parent = re || null, oe.children = null, oe.tag = null, oe.args = null, oe.reverseArgs = null, oe.choice = null, oe.optional = !1, oe.any = !1, oe.obj = !1, oe.use = null, oe.useDecoder = null, oe.key = null, oe.default = null, oe.explicit = null, oe.implicit = null, oe.contains = null, oe.parent || (oe.children = [], this._wrap());
  }
  node = ne;
  var ie = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return ne.prototype.clone = function() {
    var re = this._baseState, oe = {};
    ie.forEach(function(Oe) {
      oe[Oe] = re[Oe];
    });
    var ke = new this.constructor(oe.parent);
    return ke._baseState = oe, ke;
  }, ne.prototype._wrap = function() {
    var re = this._baseState;
    W.forEach(function(oe) {
      this[oe] = function() {
        var Oe = new this.constructor(this);
        return re.children.push(Oe), Oe[oe].apply(Oe, arguments);
      };
    }, this);
  }, ne.prototype._init = function(re) {
    var oe = this._baseState;
    K(oe.parent === null), re.call(this), oe.children = oe.children.filter(function(ke) {
      return ke._baseState.parent === this;
    }, this), K.equal(oe.children.length, 1, "Root node can have only one child");
  }, ne.prototype._useArgs = function(re) {
    var oe = this._baseState, ke = re.filter(function(Oe) {
      return Oe instanceof this.constructor;
    }, this);
    re = re.filter(function(Oe) {
      return !(Oe instanceof this.constructor);
    }, this), ke.length !== 0 && (K(oe.children === null), oe.children = ke, ke.forEach(function(Oe) {
      Oe._baseState.parent = this;
    }, this)), re.length !== 0 && (K(oe.args === null), oe.args = re, oe.reverseArgs = re.map(function(Oe) {
      if (typeof Oe != "object" || Oe.constructor !== Object)
        return Oe;
      var it = {};
      return Object.keys(Oe).forEach(function(at) {
        at == (at | 0) && (at |= 0);
        var ut = Oe[at];
        it[ut] = at;
      }), it;
    }));
  }, J.forEach(function(ce) {
    ne.prototype[ce] = function() {
      var oe = this._baseState;
      throw new Error(ce + " not implemented for encoding: " + oe.enc);
    };
  }), V.forEach(function(ce) {
    ne.prototype[ce] = function() {
      var oe = this._baseState, ke = Array.prototype.slice.call(arguments);
      return K(oe.tag === null), oe.tag = ce, this._useArgs(ke), this;
    };
  }), ne.prototype.use = function(re) {
    K(re);
    var oe = this._baseState;
    return K(oe.use === null), oe.use = re, this;
  }, ne.prototype.optional = function() {
    var re = this._baseState;
    return re.optional = !0, this;
  }, ne.prototype.def = function(re) {
    var oe = this._baseState;
    return K(oe.default === null), oe.default = re, oe.optional = !0, this;
  }, ne.prototype.explicit = function(re) {
    var oe = this._baseState;
    return K(oe.explicit === null && oe.implicit === null), oe.explicit = re, this;
  }, ne.prototype.implicit = function(re) {
    var oe = this._baseState;
    return K(oe.explicit === null && oe.implicit === null), oe.implicit = re, this;
  }, ne.prototype.obj = function() {
    var re = this._baseState, oe = Array.prototype.slice.call(arguments);
    return re.obj = !0, oe.length !== 0 && this._useArgs(oe), this;
  }, ne.prototype.key = function(re) {
    var oe = this._baseState;
    return K(oe.key === null), oe.key = re, this;
  }, ne.prototype.any = function() {
    var re = this._baseState;
    return re.any = !0, this;
  }, ne.prototype.choice = function(re) {
    var oe = this._baseState;
    return K(oe.choice === null), oe.choice = re, this._useArgs(Object.keys(re).map(function(ke) {
      return re[ke];
    })), this;
  }, ne.prototype.contains = function(re) {
    var oe = this._baseState;
    return K(oe.use === null), oe.contains = re, this;
  }, ne.prototype._decode = function(re, oe) {
    var ke = this._baseState;
    if (ke.parent === null)
      return re.wrapResult(ke.children[0]._decode(re, oe));
    var Oe = ke.default, it = !0, at = null;
    if (ke.key !== null && (at = re.enterKey(ke.key)), ke.optional) {
      var ut = null;
      if (ke.explicit !== null ? ut = ke.explicit : ke.implicit !== null ? ut = ke.implicit : ke.tag !== null && (ut = ke.tag), ut === null && !ke.any) {
        var dt = re.save();
        try {
          ke.choice === null ? this._decodeGeneric(ke.tag, re, oe) : this._decodeChoice(re, oe), it = !0;
        } catch {
          it = !1;
        }
        re.restore(dt);
      } else if (it = this._peekTag(re, ut, ke.any), re.isError(it))
        return it;
    }
    var ct;
    if (ke.obj && it && (ct = re.enterObject()), it) {
      if (ke.explicit !== null) {
        var bt = this._decodeTag(re, ke.explicit);
        if (re.isError(bt))
          return bt;
        re = bt;
      }
      var vt = re.offset;
      if (ke.use === null && ke.choice === null) {
        if (ke.any)
          var dt = re.save();
        var $t = this._decodeTag(
          re,
          ke.implicit !== null ? ke.implicit : ke.tag,
          ke.any
        );
        if (re.isError($t))
          return $t;
        ke.any ? Oe = re.raw(dt) : re = $t;
      }
      if (oe && oe.track && ke.tag !== null && oe.track(re.path(), vt, re.length, "tagged"), oe && oe.track && ke.tag !== null && oe.track(re.path(), re.offset, re.length, "content"), ke.any ? Oe = Oe : ke.choice === null ? Oe = this._decodeGeneric(ke.tag, re, oe) : Oe = this._decodeChoice(re, oe), re.isError(Oe))
        return Oe;
      if (!ke.any && ke.choice === null && ke.children !== null && ke.children.forEach(function(At) {
        At._decode(re, oe);
      }), ke.contains && (ke.tag === "octstr" || ke.tag === "bitstr")) {
        var xt = new L(Oe);
        Oe = this._getUse(ke.contains, re._reporterState.obj)._decode(xt, oe);
      }
    }
    return ke.obj && it && (Oe = re.leaveObject(ct)), ke.key !== null && (Oe !== null || it === !0) ? re.leaveKey(at, ke.key, Oe) : at !== null && re.exitKey(at), Oe;
  }, ne.prototype._decodeGeneric = function(re, oe, ke) {
    var Oe = this._baseState;
    return re === "seq" || re === "set" ? null : re === "seqof" || re === "setof" ? this._decodeList(oe, re, Oe.args[0], ke) : /str$/.test(re) ? this._decodeStr(oe, re, ke) : re === "objid" && Oe.args ? this._decodeObjid(oe, Oe.args[0], Oe.args[1], ke) : re === "objid" ? this._decodeObjid(oe, null, null, ke) : re === "gentime" || re === "utctime" ? this._decodeTime(oe, re, ke) : re === "null_" ? this._decodeNull(oe, ke) : re === "bool" ? this._decodeBool(oe, ke) : re === "objDesc" ? this._decodeStr(oe, re, ke) : re === "int" || re === "enum" ? this._decodeInt(oe, Oe.args && Oe.args[0], ke) : Oe.use !== null ? this._getUse(Oe.use, oe._reporterState.obj)._decode(oe, ke) : oe.error("unknown tag: " + re);
  }, ne.prototype._getUse = function(re, oe) {
    var ke = this._baseState;
    return ke.useDecoder = this._use(re, oe), K(ke.useDecoder._baseState.parent === null), ke.useDecoder = ke.useDecoder._baseState.children[0], ke.implicit !== ke.useDecoder._baseState.implicit && (ke.useDecoder = ke.useDecoder.clone(), ke.useDecoder._baseState.implicit = ke.implicit), ke.useDecoder;
  }, ne.prototype._decodeChoice = function(re, oe) {
    var ke = this._baseState, Oe = null, it = !1;
    return Object.keys(ke.choice).some(function(at) {
      var ut = re.save(), dt = ke.choice[at];
      try {
        var ct = dt._decode(re, oe);
        if (re.isError(ct))
          return !1;
        Oe = { type: at, value: ct }, it = !0;
      } catch {
        return re.restore(ut), !1;
      }
      return !0;
    }, this), it ? Oe : re.error("Choice not matched");
  }, ne.prototype._createEncoderBuffer = function(re) {
    return new B(re, this.reporter);
  }, ne.prototype._encode = function(re, oe, ke) {
    var Oe = this._baseState;
    if (!(Oe.default !== null && Oe.default === re)) {
      var it = this._encodeValue(re, oe, ke);
      if (it !== void 0 && !this._skipDefault(it, oe, ke))
        return it;
    }
  }, ne.prototype._encodeValue = function(re, oe, ke) {
    var Oe = this._baseState;
    if (Oe.parent === null)
      return Oe.children[0]._encode(re, oe || new A());
    var dt = null;
    if (this.reporter = oe, Oe.optional && re === void 0)
      if (Oe.default !== null)
        re = Oe.default;
      else
        return;
    var it = null, at = !1;
    if (Oe.any)
      dt = this._createEncoderBuffer(re);
    else if (Oe.choice)
      dt = this._encodeChoice(re, oe);
    else if (Oe.contains)
      it = this._getUse(Oe.contains, ke)._encode(re, oe), at = !0;
    else if (Oe.children)
      it = Oe.children.map(function(vt) {
        if (vt._baseState.tag === "null_")
          return vt._encode(null, oe, re);
        if (vt._baseState.key === null)
          return oe.error("Child should have a key");
        var $t = oe.enterKey(vt._baseState.key);
        if (typeof re != "object")
          return oe.error("Child expected, but input is not object");
        var xt = vt._encode(re[vt._baseState.key], oe, re);
        return oe.leaveKey($t), xt;
      }, this).filter(function(vt) {
        return vt;
      }), it = this._createEncoderBuffer(it);
    else if (Oe.tag === "seqof" || Oe.tag === "setof") {
      if (!(Oe.args && Oe.args.length === 1))
        return oe.error("Too many args for : " + Oe.tag);
      if (!Array.isArray(re))
        return oe.error("seqof/setof, but data is not Array");
      var ut = this.clone();
      ut._baseState.implicit = null, it = this._createEncoderBuffer(re.map(function(vt) {
        var $t = this._baseState;
        return this._getUse($t.args[0], re)._encode(vt, oe);
      }, ut));
    } else Oe.use !== null ? dt = this._getUse(Oe.use, ke)._encode(re, oe) : (it = this._encodePrimitive(Oe.tag, re), at = !0);
    var dt;
    if (!Oe.any && Oe.choice === null) {
      var ct = Oe.implicit !== null ? Oe.implicit : Oe.tag, bt = Oe.implicit === null ? "universal" : "context";
      ct === null ? Oe.use === null && oe.error("Tag could be omitted only for .use()") : Oe.use === null && (dt = this._encodeComposite(ct, at, bt, it));
    }
    return Oe.explicit !== null && (dt = this._encodeComposite(Oe.explicit, !1, "context", dt)), dt;
  }, ne.prototype._encodeChoice = function(re, oe) {
    var ke = this._baseState, Oe = ke.choice[re.type];
    return Oe || K(
      !1,
      re.type + " not found in " + JSON.stringify(Object.keys(ke.choice))
    ), Oe._encode(re.value, oe);
  }, ne.prototype._encodePrimitive = function(re, oe) {
    var ke = this._baseState;
    if (/str$/.test(re))
      return this._encodeStr(oe, re);
    if (re === "objid" && ke.args)
      return this._encodeObjid(oe, ke.reverseArgs[0], ke.args[1]);
    if (re === "objid")
      return this._encodeObjid(oe, null, null);
    if (re === "gentime" || re === "utctime")
      return this._encodeTime(oe, re);
    if (re === "null_")
      return this._encodeNull();
    if (re === "int" || re === "enum")
      return this._encodeInt(oe, ke.args && ke.reverseArgs[0]);
    if (re === "bool")
      return this._encodeBool(oe);
    if (re === "objDesc")
      return this._encodeStr(oe, re);
    throw new Error("Unsupported tag: " + re);
  }, ne.prototype._isNumstr = function(re) {
    return /^[0-9 ]*$/.test(re);
  }, ne.prototype._isPrintstr = function(re) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(re);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(A) {
    var B = A;
    B.Reporter = requireReporter().Reporter, B.DecoderBuffer = requireBuffer().DecoderBuffer, B.EncoderBuffer = requireBuffer().EncoderBuffer, B.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(A) {
    var B = requireConstants();
    A.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, A.tagClassByName = B._reverse(A.tagClass), A.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, A.tagByName = B._reverse(A.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(A) {
    var B = A;
    B._reverse = function(K) {
      var V = {};
      return Object.keys(K).forEach(function(W) {
        (W | 0) == W && (W = W | 0);
        var J = K[W];
        V[J] = W;
      }), V;
    }, B.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var A = requireInherits_browser(), B = requireAsn1$1(), L = B.base, K = B.bignum, V = B.constants.der;
  function W(ce) {
    this.enc = "der", this.name = ce.name, this.entity = ce, this.tree = new J(), this.tree._init(ce.body);
  }
  der_1$1 = W, W.prototype.decode = function(re, oe) {
    return re instanceof L.DecoderBuffer || (re = new L.DecoderBuffer(re, oe)), this.tree._decode(re, oe);
  };
  function J(ce) {
    L.Node.call(this, "der", ce);
  }
  A(J, L.Node), J.prototype._peekTag = function(re, oe, ke) {
    if (re.isEmpty())
      return !1;
    var Oe = re.save(), it = ne(re, 'Failed to peek tag: "' + oe + '"');
    return re.isError(it) ? it : (re.restore(Oe), it.tag === oe || it.tagStr === oe || it.tagStr + "of" === oe || ke);
  }, J.prototype._decodeTag = function(re, oe, ke) {
    var Oe = ne(
      re,
      'Failed to decode tag of "' + oe + '"'
    );
    if (re.isError(Oe))
      return Oe;
    var it = ie(
      re,
      Oe.primitive,
      'Failed to get length of "' + oe + '"'
    );
    if (re.isError(it))
      return it;
    if (!ke && Oe.tag !== oe && Oe.tagStr !== oe && Oe.tagStr + "of" !== oe)
      return re.error('Failed to match tag: "' + oe + '"');
    if (Oe.primitive || it !== null)
      return re.skip(it, 'Failed to match body of: "' + oe + '"');
    var at = re.save(), ut = this._skipUntilEnd(
      re,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return re.isError(ut) ? ut : (it = re.offset - at.offset, re.restore(at), re.skip(it, 'Failed to match body of: "' + oe + '"'));
  }, J.prototype._skipUntilEnd = function(re, oe) {
    for (; ; ) {
      var ke = ne(re, oe);
      if (re.isError(ke))
        return ke;
      var Oe = ie(re, ke.primitive, oe);
      if (re.isError(Oe))
        return Oe;
      var it;
      if (ke.primitive || Oe !== null ? it = re.skip(Oe) : it = this._skipUntilEnd(re, oe), re.isError(it))
        return it;
      if (ke.tagStr === "end")
        break;
    }
  }, J.prototype._decodeList = function(re, oe, ke, Oe) {
    for (var it = []; !re.isEmpty(); ) {
      var at = this._peekTag(re, "end");
      if (re.isError(at))
        return at;
      var ut = ke.decode(re, "der", Oe);
      if (re.isError(ut) && at)
        break;
      it.push(ut);
    }
    return it;
  }, J.prototype._decodeStr = function(re, oe) {
    if (oe === "bitstr") {
      var ke = re.readUInt8();
      return re.isError(ke) ? ke : { unused: ke, data: re.raw() };
    } else if (oe === "bmpstr") {
      var Oe = re.raw();
      if (Oe.length % 2 === 1)
        return re.error("Decoding of string type: bmpstr length mismatch");
      for (var it = "", at = 0; at < Oe.length / 2; at++)
        it += String.fromCharCode(Oe.readUInt16BE(at * 2));
      return it;
    } else if (oe === "numstr") {
      var ut = re.raw().toString("ascii");
      return this._isNumstr(ut) ? ut : re.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (oe === "octstr")
        return re.raw();
      if (oe === "objDesc")
        return re.raw();
      if (oe === "printstr") {
        var dt = re.raw().toString("ascii");
        return this._isPrintstr(dt) ? dt : re.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(oe) ? re.raw().toString() : re.error("Decoding of string type: " + oe + " unsupported");
    }
  }, J.prototype._decodeObjid = function(re, oe, ke) {
    for (var Oe, it = [], at = 0; !re.isEmpty(); ) {
      var ut = re.readUInt8();
      at <<= 7, at |= ut & 127, ut & 128 || (it.push(at), at = 0);
    }
    ut & 128 && it.push(at);
    var dt = it[0] / 40 | 0, ct = it[0] % 40;
    if (ke ? Oe = it : Oe = [dt, ct].concat(it.slice(1)), oe) {
      var bt = oe[Oe.join(" ")];
      bt === void 0 && (bt = oe[Oe.join(".")]), bt !== void 0 && (Oe = bt);
    }
    return Oe;
  }, J.prototype._decodeTime = function(re, oe) {
    var ke = re.raw().toString();
    if (oe === "gentime")
      var Oe = ke.slice(0, 4) | 0, it = ke.slice(4, 6) | 0, at = ke.slice(6, 8) | 0, ut = ke.slice(8, 10) | 0, dt = ke.slice(10, 12) | 0, ct = ke.slice(12, 14) | 0;
    else if (oe === "utctime") {
      var Oe = ke.slice(0, 2) | 0, it = ke.slice(2, 4) | 0, at = ke.slice(4, 6) | 0, ut = ke.slice(6, 8) | 0, dt = ke.slice(8, 10) | 0, ct = ke.slice(10, 12) | 0;
      Oe < 70 ? Oe = 2e3 + Oe : Oe = 1900 + Oe;
    } else
      return re.error("Decoding " + oe + " time is not supported yet");
    return Date.UTC(Oe, it - 1, at, ut, dt, ct, 0);
  }, J.prototype._decodeNull = function(re) {
    return null;
  }, J.prototype._decodeBool = function(re) {
    var oe = re.readUInt8();
    return re.isError(oe) ? oe : oe !== 0;
  }, J.prototype._decodeInt = function(re, oe) {
    var ke = re.raw(), Oe = new K(ke);
    return oe && (Oe = oe[Oe.toString(10)] || Oe), Oe;
  }, J.prototype._use = function(re, oe) {
    return typeof re == "function" && (re = re(oe)), re._getDecoder("der").tree;
  };
  function ne(ce, re) {
    var oe = ce.readUInt8(re);
    if (ce.isError(oe))
      return oe;
    var ke = V.tagClass[oe >> 6], Oe = (oe & 32) === 0;
    if ((oe & 31) === 31) {
      var it = oe;
      for (oe = 0; (it & 128) === 128; ) {
        if (it = ce.readUInt8(re), ce.isError(it))
          return it;
        oe <<= 7, oe |= it & 127;
      }
    } else
      oe &= 31;
    var at = V.tag[oe];
    return {
      cls: ke,
      primitive: Oe,
      tag: oe,
      tagStr: at
    };
  }
  function ie(ce, re, oe) {
    var ke = ce.readUInt8(oe);
    if (ce.isError(ke))
      return ke;
    if (!re && ke === 128)
      return null;
    if (!(ke & 128))
      return ke;
    var Oe = ke & 127;
    if (Oe > 4)
      return ce.error("length octect is too long");
    ke = 0;
    for (var it = 0; it < Oe; it++) {
      ke <<= 8;
      var at = ce.readUInt8(oe);
      if (ce.isError(at))
        return at;
      ke |= at;
    }
    return ke;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, L = requireDer$1();
  function K(V) {
    L.call(this, V), this.enc = "pem";
  }
  return A(K, L), pem$1 = K, K.prototype.decode = function(W, J) {
    for (var ne = W.toString().split(/[\r\n]+/g), ie = J.label.toUpperCase(), ce = /^-----(BEGIN|END) ([^-]+)-----$/, re = -1, oe = -1, ke = 0; ke < ne.length; ke++) {
      var Oe = ne[ke].match(ce);
      if (Oe !== null && Oe[2] === ie)
        if (re === -1) {
          if (Oe[1] !== "BEGIN")
            break;
          re = ke;
        } else {
          if (Oe[1] !== "END")
            break;
          oe = ke;
          break;
        }
    }
    if (re === -1 || oe === -1)
      throw new Error("PEM section not found for: " + ie);
    var it = ne.slice(re + 1, oe).join("");
    it.replace(/[^a-z0-9\+\/=]+/gi, "");
    var at = new B(it, "base64");
    return L.prototype.decode.call(this, at, J);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(A) {
    var B = A;
    B.der = requireDer$1(), B.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var A = requireInherits_browser(), B = require$$0$1.Buffer, L = requireAsn1$1(), K = L.base, V = L.constants.der;
  function W(ce) {
    this.enc = "der", this.name = ce.name, this.entity = ce, this.tree = new J(), this.tree._init(ce.body);
  }
  der_1 = W, W.prototype.encode = function(re, oe) {
    return this.tree._encode(re, oe).join();
  };
  function J(ce) {
    K.Node.call(this, "der", ce);
  }
  A(J, K.Node), J.prototype._encodeComposite = function(re, oe, ke, Oe) {
    var it = ie(re, oe, ke, this.reporter);
    if (Oe.length < 128) {
      var dt = new B(2);
      return dt[0] = it, dt[1] = Oe.length, this._createEncoderBuffer([dt, Oe]);
    }
    for (var at = 1, ut = Oe.length; ut >= 256; ut >>= 8)
      at++;
    var dt = new B(2 + at);
    dt[0] = it, dt[1] = 128 | at;
    for (var ut = 1 + at, ct = Oe.length; ct > 0; ut--, ct >>= 8)
      dt[ut] = ct & 255;
    return this._createEncoderBuffer([dt, Oe]);
  }, J.prototype._encodeStr = function(re, oe) {
    if (oe === "bitstr")
      return this._createEncoderBuffer([re.unused | 0, re.data]);
    if (oe === "bmpstr") {
      for (var ke = new B(re.length * 2), Oe = 0; Oe < re.length; Oe++)
        ke.writeUInt16BE(re.charCodeAt(Oe), Oe * 2);
      return this._createEncoderBuffer(ke);
    } else return oe === "numstr" ? this._isNumstr(re) ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : oe === "printstr" ? this._isPrintstr(re) ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(oe) ? this._createEncoderBuffer(re) : oe === "objDesc" ? this._createEncoderBuffer(re) : this.reporter.error("Encoding of string type: " + oe + " unsupported");
  }, J.prototype._encodeObjid = function(re, oe, ke) {
    if (typeof re == "string") {
      if (!oe)
        return this.reporter.error("string objid given, but no values map found");
      if (!oe.hasOwnProperty(re))
        return this.reporter.error("objid not found in values map");
      re = oe[re].split(/[\s\.]+/g);
      for (var Oe = 0; Oe < re.length; Oe++)
        re[Oe] |= 0;
    } else if (Array.isArray(re)) {
      re = re.slice();
      for (var Oe = 0; Oe < re.length; Oe++)
        re[Oe] |= 0;
    }
    if (!Array.isArray(re))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(re));
    if (!ke) {
      if (re[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      re.splice(0, 2, re[0] * 40 + re[1]);
    }
    for (var it = 0, Oe = 0; Oe < re.length; Oe++) {
      var at = re[Oe];
      for (it++; at >= 128; at >>= 7)
        it++;
    }
    for (var ut = new B(it), dt = ut.length - 1, Oe = re.length - 1; Oe >= 0; Oe--) {
      var at = re[Oe];
      for (ut[dt--] = at & 127; (at >>= 7) > 0; )
        ut[dt--] = 128 | at & 127;
    }
    return this._createEncoderBuffer(ut);
  };
  function ne(ce) {
    return ce < 10 ? "0" + ce : ce;
  }
  J.prototype._encodeTime = function(re, oe) {
    var ke, Oe = new Date(re);
    return oe === "gentime" ? ke = [
      ne(Oe.getFullYear()),
      ne(Oe.getUTCMonth() + 1),
      ne(Oe.getUTCDate()),
      ne(Oe.getUTCHours()),
      ne(Oe.getUTCMinutes()),
      ne(Oe.getUTCSeconds()),
      "Z"
    ].join("") : oe === "utctime" ? ke = [
      ne(Oe.getFullYear() % 100),
      ne(Oe.getUTCMonth() + 1),
      ne(Oe.getUTCDate()),
      ne(Oe.getUTCHours()),
      ne(Oe.getUTCMinutes()),
      ne(Oe.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + oe + " time is not supported yet"), this._encodeStr(ke, "octstr");
  }, J.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, J.prototype._encodeInt = function(re, oe) {
    if (typeof re == "string") {
      if (!oe)
        return this.reporter.error("String int or enum given, but no values map");
      if (!oe.hasOwnProperty(re))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(re));
      re = oe[re];
    }
    if (typeof re != "number" && !B.isBuffer(re)) {
      var ke = re.toArray();
      !re.sign && ke[0] & 128 && ke.unshift(0), re = new B(ke);
    }
    if (B.isBuffer(re)) {
      var Oe = re.length;
      re.length === 0 && Oe++;
      var at = new B(Oe);
      return re.copy(at), re.length === 0 && (at[0] = 0), this._createEncoderBuffer(at);
    }
    if (re < 128)
      return this._createEncoderBuffer(re);
    if (re < 256)
      return this._createEncoderBuffer([0, re]);
    for (var Oe = 1, it = re; it >= 256; it >>= 8)
      Oe++;
    for (var at = new Array(Oe), it = at.length - 1; it >= 0; it--)
      at[it] = re & 255, re >>= 8;
    return at[0] & 128 && at.unshift(0), this._createEncoderBuffer(new B(at));
  }, J.prototype._encodeBool = function(re) {
    return this._createEncoderBuffer(re ? 255 : 0);
  }, J.prototype._use = function(re, oe) {
    return typeof re == "function" && (re = re(oe)), re._getEncoder("der").tree;
  }, J.prototype._skipDefault = function(re, oe, ke) {
    var Oe = this._baseState, it;
    if (Oe.default === null)
      return !1;
    var at = re.join();
    if (Oe.defaultBuffer === void 0 && (Oe.defaultBuffer = this._encodeValue(Oe.default, oe, ke).join()), at.length !== Oe.defaultBuffer.length)
      return !1;
    for (it = 0; it < at.length; it++)
      if (at[it] !== Oe.defaultBuffer[it])
        return !1;
    return !0;
  };
  function ie(ce, re, oe, ke) {
    var Oe;
    if (ce === "seqof" ? ce = "seq" : ce === "setof" && (ce = "set"), V.tagByName.hasOwnProperty(ce))
      Oe = V.tagByName[ce];
    else if (typeof ce == "number" && (ce | 0) === ce)
      Oe = ce;
    else
      return ke.error("Unknown tag: " + ce);
    return Oe >= 31 ? ke.error("Multi-octet tag encoding unsupported") : (re || (Oe |= 32), Oe |= V.tagClassByName[oe || "universal"] << 6, Oe);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var A = requireInherits_browser(), B = requireDer();
  function L(K) {
    B.call(this, K), this.enc = "pem";
  }
  return A(L, B), pem = L, L.prototype.encode = function(V, W) {
    for (var J = B.prototype.encode.call(this, V), ne = J.toString("base64"), ie = ["-----BEGIN " + W.label + "-----"], ce = 0; ce < ne.length; ce += 64)
      ie.push(ne.slice(ce, ce + 64));
    return ie.push("-----END " + W.label + "-----"), ie.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(A) {
    var B = A;
    B.der = requireDer(), B.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(A) {
    var B = A;
    B.bignum = requireBn$1(), B.define = requireApi().define, B.base = requireBase(), B.constants = requireConstants(), B.decoders = requireDecoders(), B.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var A = requireAsn1$1(), B = A.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), L = A.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), V = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  }), W = A.define("RelativeDistinguishedName", function() {
    this.setof(L);
  }), J = A.define("RDNSequence", function() {
    this.seqof(W);
  }), ne = A.define("Name", function() {
    this.choice({
      rdnSequence: this.use(J)
    });
  }), ie = A.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(B),
      this.key("notAfter").use(B)
    );
  }), ce = A.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), re = A.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(K),
      this.key("issuer").use(ne),
      this.key("validity").use(ie),
      this.key("subject").use(ne),
      this.key("subjectPublicKeyInfo").use(V),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(ce).optional()
    );
  }), oe = A.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(re),
      this.key("signatureAlgorithm").use(K),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = oe, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var A = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var B = A.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = B;
  var L = A.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = L;
  var K = A.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), V = A.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(K),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = V;
  var W = A.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(K),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = W;
  var J = A.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = J;
  var ne = A.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = ne, asn1$1.DSAparam = A.define("DSAparam", function() {
    this.int();
  });
  var ie = A.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), ce = A.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ie),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = ce, asn1$1.signature = A.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var A = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, B = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, L = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, K = requireEvp_bytestokey(), V = requireBrowser$6(), W = safeBufferExports.Buffer;
  return fixProc = function(J, ne) {
    var ie = J.toString(), ce = ie.match(A), re;
    if (ce) {
      var ke = "aes" + ce[1], Oe = W.from(ce[2], "hex"), it = W.from(ce[3].replace(/[\r\n]/g, ""), "base64"), at = K(ne, Oe.slice(0, 8), parseInt(ce[1], 10)).key, ut = [], dt = V.createDecipheriv(ke, at, Oe);
      ut.push(dt.update(it)), ut.push(dt.final()), re = W.concat(ut);
    } else {
      var oe = ie.match(L);
      re = W.from(oe[2].replace(/[\r\n]/g, ""), "base64");
    }
    var ct = ie.match(B)[1];
    return {
      tag: ct,
      data: re
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var A = requireAsn1(), B = require$$1, L = requireFixProc(), K = requireBrowser$6(), V = requireBrowser$7(), W = safeBufferExports.Buffer;
  function J(ie, ce) {
    var re = ie.algorithm.decrypt.kde.kdeparams.salt, oe = parseInt(ie.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), ke = B[ie.algorithm.decrypt.cipher.algo.join(".")], Oe = ie.algorithm.decrypt.cipher.iv, it = ie.subjectPrivateKey, at = parseInt(ke.split("-")[1], 10) / 8, ut = V.pbkdf2Sync(ce, re, oe, at, "sha1"), dt = K.createDecipheriv(ke, ut, Oe), ct = [];
    return ct.push(dt.update(it)), ct.push(dt.final()), W.concat(ct);
  }
  function ne(ie) {
    var ce;
    typeof ie == "object" && !W.isBuffer(ie) && (ce = ie.passphrase, ie = ie.key), typeof ie == "string" && (ie = W.from(ie));
    var re = L(ie, ce), oe = re.tag, ke = re.data, Oe, it;
    switch (oe) {
      case "CERTIFICATE":
        it = A.certificate.decode(ke, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (it || (it = A.PublicKey.decode(ke, "der")), Oe = it.algorithm.algorithm.join("."), Oe) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPublicKey.decode(it.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return it.subjectPrivateKey = it.subjectPublicKey, {
              type: "ec",
              data: it
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.pub_key = A.DSAparam.decode(it.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Oe);
        }
      case "ENCRYPTED PRIVATE KEY":
        ke = A.EncryptedPrivateKey.decode(ke, "der"), ke = J(ke, ce);
      case "PRIVATE KEY":
        switch (it = A.PrivateKey.decode(ke, "der"), Oe = it.algorithm.algorithm.join("."), Oe) {
          case "1.2.840.113549.1.1.1":
            return A.RSAPrivateKey.decode(it.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: it.algorithm.curve,
              privateKey: A.ECPrivateKey.decode(it.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return it.algorithm.params.priv_key = A.DSAparam.decode(it.subjectPrivateKey, "der"), {
              type: "dsa",
              params: it.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Oe);
        }
      case "RSA PUBLIC KEY":
        return A.RSAPublicKey.decode(ke, "der");
      case "RSA PRIVATE KEY":
        return A.RSAPrivateKey.decode(ke, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: A.DSAPrivateKey.decode(ke, "der")
        };
      case "EC PRIVATE KEY":
        return ke = A.ECPrivateKey.decode(ke, "der"), {
          curve: ke.parameters.value,
          privateKey: ke.privateKey
        };
      default:
        throw new Error("unknown key type " + oe);
    }
  }
  return ne.signature = A.signature, parseAsn1 = ne, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$8(), L = requireBrowserifyRsa(), K = requireElliptic().ec, V = requireBn(), W = requireParseAsn1(), J = require$$4, ne = 1;
  function ie(dt, ct, bt, vt, $t) {
    var xt = W(ct);
    if (xt.curve) {
      if (vt !== "ecdsa" && vt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ce(dt, xt);
    } else if (xt.type === "dsa") {
      if (vt !== "dsa")
        throw new Error("wrong private key type");
      return re(dt, xt, bt);
    }
    if (vt !== "rsa" && vt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ct.padding !== void 0 && ct.padding !== ne)
      throw new Error("illegal or unsupported padding mode");
    dt = A.concat([$t, dt]);
    for (var Ot = xt.modulus.byteLength(), At = [0, 1]; dt.length + At.length + 1 < Ot; )
      At.push(255);
    At.push(0);
    for (var yt = -1; ++yt < dt.length; )
      At.push(dt[yt]);
    var Bt = L(At, xt);
    return Bt;
  }
  function ce(dt, ct) {
    var bt = J[ct.curve.join(".")];
    if (!bt)
      throw new Error("unknown curve " + ct.curve.join("."));
    var vt = new K(bt), $t = vt.keyFromPrivate(ct.privateKey), xt = $t.sign(dt);
    return A.from(xt.toDER());
  }
  function re(dt, ct, bt) {
    for (var vt = ct.params.priv_key, $t = ct.params.p, xt = ct.params.q, Ot = ct.params.g, At = new V(0), yt, Bt = Oe(dt, xt).mod(xt), gt = !1, rt = ke(vt, xt, dt, bt); gt === !1; )
      yt = at(xt, rt, bt), At = ut(Ot, yt, $t, xt), gt = yt.invm(xt).imul(Bt.add(vt.mul(At))).mod(xt), gt.cmpn(0) === 0 && (gt = !1, At = new V(0));
    return oe(At, gt);
  }
  function oe(dt, ct) {
    dt = dt.toArray(), ct = ct.toArray(), dt[0] & 128 && (dt = [0].concat(dt)), ct[0] & 128 && (ct = [0].concat(ct));
    var bt = dt.length + ct.length + 4, vt = [
      48,
      bt,
      2,
      dt.length
    ];
    return vt = vt.concat(dt, [2, ct.length], ct), A.from(vt);
  }
  function ke(dt, ct, bt, vt) {
    if (dt = A.from(dt.toArray()), dt.length < ct.byteLength()) {
      var $t = A.alloc(ct.byteLength() - dt.length);
      dt = A.concat([$t, dt]);
    }
    var xt = bt.length, Ot = it(bt, ct), At = A.alloc(xt);
    At.fill(1);
    var yt = A.alloc(xt);
    return yt = B(vt, yt).update(At).update(A.from([0])).update(dt).update(Ot).digest(), At = B(vt, yt).update(At).digest(), yt = B(vt, yt).update(At).update(A.from([1])).update(dt).update(Ot).digest(), At = B(vt, yt).update(At).digest(), { k: yt, v: At };
  }
  function Oe(dt, ct) {
    var bt = new V(dt), vt = (dt.length << 3) - ct.bitLength();
    return vt > 0 && bt.ishrn(vt), bt;
  }
  function it(dt, ct) {
    dt = Oe(dt, ct), dt = dt.mod(ct);
    var bt = A.from(dt.toArray());
    if (bt.length < ct.byteLength()) {
      var vt = A.alloc(ct.byteLength() - bt.length);
      bt = A.concat([vt, bt]);
    }
    return bt;
  }
  function at(dt, ct, bt) {
    var vt, $t;
    do {
      for (vt = A.alloc(0); vt.length * 8 < dt.bitLength(); )
        ct.v = B(bt, ct.k).update(ct.v).digest(), vt = A.concat([vt, ct.v]);
      $t = Oe(vt, dt), ct.k = B(bt, ct.k).update(ct.v).update(A.from([0])).digest(), ct.v = B(bt, ct.k).update(ct.v).digest();
    } while ($t.cmp(dt) !== -1);
    return $t;
  }
  function ut(dt, ct, bt, vt) {
    return dt.toRed(V.mont(bt)).redPow(ct).fromRed().mod(vt);
  }
  return sign.exports = ie, sign.exports.getKey = ke, sign.exports.makeKey = at, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var A = safeBufferExports.Buffer, B = requireBn(), L = requireElliptic().ec, K = requireParseAsn1(), V = require$$4;
  function W(ce, re, oe, ke, Oe) {
    var it = K(oe);
    if (it.type === "ec") {
      if (ke !== "ecdsa" && ke !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return J(ce, re, it);
    } else if (it.type === "dsa") {
      if (ke !== "dsa")
        throw new Error("wrong public key type");
      return ne(ce, re, it);
    }
    if (ke !== "rsa" && ke !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    re = A.concat([Oe, re]);
    for (var at = it.modulus.byteLength(), ut = [1], dt = 0; re.length + ut.length + 2 < at; )
      ut.push(255), dt += 1;
    ut.push(0);
    for (var ct = -1; ++ct < re.length; )
      ut.push(re[ct]);
    ut = A.from(ut);
    var bt = B.mont(it.modulus);
    ce = new B(ce).toRed(bt), ce = ce.redPow(new B(it.publicExponent)), ce = A.from(ce.fromRed().toArray());
    var vt = dt < 8 ? 1 : 0;
    for (at = Math.min(ce.length, ut.length), ce.length !== ut.length && (vt = 1), ct = -1; ++ct < at; )
      vt |= ce[ct] ^ ut[ct];
    return vt === 0;
  }
  function J(ce, re, oe) {
    var ke = V[oe.data.algorithm.curve.join(".")];
    if (!ke)
      throw new Error("unknown curve " + oe.data.algorithm.curve.join("."));
    var Oe = new L(ke), it = oe.data.subjectPrivateKey.data;
    return Oe.verify(re, ce, it);
  }
  function ne(ce, re, oe) {
    var ke = oe.data.p, Oe = oe.data.q, it = oe.data.g, at = oe.data.pub_key, ut = K.signature.decode(ce, "der"), dt = ut.s, ct = ut.r;
    ie(dt, Oe), ie(ct, Oe);
    var bt = B.mont(ke), vt = dt.invm(Oe), $t = it.toRed(bt).redPow(new B(re).mul(vt).mod(Oe)).fromRed().mul(at.toRed(bt).redPow(ct.mul(vt).mod(Oe)).fromRed()).mod(ke).mod(Oe);
    return $t.cmp(ct) === 0;
  }
  function ie(ce, re) {
    if (ce.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ce.cmp(re) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = W, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var A = safeBufferExports.Buffer, B = requireBrowser$9(), L = requireReadableBrowser(), K = requireInherits_browser(), V = requireSign(), W = requireVerify(), J = require$$6;
  Object.keys(J).forEach(function(oe) {
    J[oe].id = A.from(J[oe].id, "hex"), J[oe.toLowerCase()] = J[oe];
  });
  function ne(oe) {
    L.Writable.call(this);
    var ke = J[oe];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hashType = ke.hash, this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ne, L.Writable), ne.prototype._write = function(ke, Oe, it) {
    this._hash.update(ke), it();
  }, ne.prototype.update = function(ke, Oe) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Oe) : ke), this;
  }, ne.prototype.sign = function(ke, Oe) {
    this.end();
    var it = this._hash.digest(), at = V(it, ke, this._hashType, this._signType, this._tag);
    return Oe ? at.toString(Oe) : at;
  };
  function ie(oe) {
    L.Writable.call(this);
    var ke = J[oe];
    if (!ke)
      throw new Error("Unknown message digest");
    this._hash = B(ke.hash), this._tag = ke.id, this._signType = ke.sign;
  }
  K(ie, L.Writable), ie.prototype._write = function(ke, Oe, it) {
    this._hash.update(ke), it();
  }, ie.prototype.update = function(ke, Oe) {
    return this._hash.update(typeof ke == "string" ? A.from(ke, Oe) : ke), this;
  }, ie.prototype.verify = function(ke, Oe, it) {
    var at = typeof Oe == "string" ? A.from(Oe, it) : Oe;
    this.end();
    var ut = this._hash.digest();
    return W(at, ut, ke, this._signType, this._tag);
  };
  function ce(oe) {
    return new ne(oe);
  }
  function re(oe) {
    return new ie(oe);
  }
  return browser$3 = {
    Sign: ce,
    Verify: re,
    createSign: ce,
    createVerify: re
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var A = requireElliptic(), B = requireBn$1();
  browser$2 = function(J) {
    return new K(J);
  };
  var L = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  L.p224 = L.secp224r1, L.p256 = L.secp256r1 = L.prime256v1, L.p192 = L.secp192r1 = L.prime192v1, L.p384 = L.secp384r1, L.p521 = L.secp521r1;
  function K(W) {
    this.curveType = L[W], this.curveType || (this.curveType = {
      name: W
    }), this.curve = new A.ec(this.curveType.name), this.keys = void 0;
  }
  K.prototype.generateKeys = function(W, J) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(W, J);
  }, K.prototype.computeSecret = function(W, J, ne) {
    J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J));
    var ie = this.curve.keyFromPublic(W).getPublic(), ce = ie.mul(this.keys.getPrivate()).getX();
    return V(ce, ne, this.curveType.byteLength);
  }, K.prototype.getPublicKey = function(W, J) {
    var ne = this.keys.getPublic(J === "compressed", !0);
    return J === "hybrid" && (ne[ne.length - 1] % 2 ? ne[0] = 7 : ne[0] = 6), V(ne, W);
  }, K.prototype.getPrivateKey = function(W) {
    return V(this.keys.getPrivate(), W);
  }, K.prototype.setPublicKey = function(W, J) {
    return J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J)), this.keys._importPublic(W), this;
  }, K.prototype.setPrivateKey = function(W, J) {
    J = J || "utf8", Buffer$1.isBuffer(W) || (W = new Buffer$1(W, J));
    var ne = new B(W);
    return ne = ne.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(ne), this;
  };
  function V(W, J, ne) {
    Array.isArray(W) || (W = W.toArray());
    var ie = new Buffer$1(W);
    if (ne && ie.length < ne) {
      var ce = new Buffer$1(ne - ie.length);
      ce.fill(0), ie = Buffer$1.concat([ce, ie]);
    }
    return J ? ie.toString(J) : ie;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var A = requireBrowser$9(), B = safeBufferExports.Buffer;
  mgf = function(K, V) {
    for (var W = B.alloc(0), J = 0, ne; W.length < V; )
      ne = L(J++), W = B.concat([W, A("sha1").update(K).update(ne).digest()]);
    return W.slice(0, V);
  };
  function L(K) {
    var V = B.allocUnsafe(4);
    return V.writeUInt32BE(K, 0), V;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(B, L) {
    for (var K = B.length, V = -1; ++V < K; )
      B[V] ^= L[V];
    return B;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var A = requireBn$1(), B = safeBufferExports.Buffer;
  function L(K, V) {
    return B.from(K.toRed(A.mont(V.modulus)).redPow(new A(V.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = L, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var A = requireParseAsn1(), B = requireBrowser$b(), L = requireBrowser$9(), K = requireMgf(), V = requireXor(), W = requireBn$1(), J = requireWithPublic(), ne = requireBrowserifyRsa(), ie = safeBufferExports.Buffer;
  publicEncrypt = function(Oe, it, at) {
    var ut;
    Oe.padding ? ut = Oe.padding : at ? ut = 1 : ut = 4;
    var dt = A(Oe), ct;
    if (ut === 4)
      ct = ce(dt, it);
    else if (ut === 1)
      ct = re(dt, it, at);
    else if (ut === 3) {
      if (ct = new W(it), ct.cmp(dt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return at ? ne(ct, dt) : J(ct, dt);
  };
  function ce(ke, Oe) {
    var it = ke.modulus.byteLength(), at = Oe.length, ut = L("sha1").update(ie.alloc(0)).digest(), dt = ut.length, ct = 2 * dt;
    if (at > it - ct - 2)
      throw new Error("message too long");
    var bt = ie.alloc(it - at - ct - 2), vt = it - dt - 1, $t = B(dt), xt = V(ie.concat([ut, bt, ie.alloc(1, 1), Oe], vt), K($t, vt)), Ot = V($t, K(xt, dt));
    return new W(ie.concat([ie.alloc(1), Ot, xt], it));
  }
  function re(ke, Oe, it) {
    var at = Oe.length, ut = ke.modulus.byteLength();
    if (at > ut - 11)
      throw new Error("message too long");
    var dt;
    return it ? dt = ie.alloc(ut - at - 3, 255) : dt = oe(ut - at - 3), new W(ie.concat([ie.from([0, it ? 1 : 2]), dt, ie.alloc(1), Oe], ut));
  }
  function oe(ke) {
    for (var Oe = ie.allocUnsafe(ke), it = 0, at = B(ke * 2), ut = 0, dt; it < ke; )
      ut === at.length && (at = B(ke * 2), ut = 0), dt = at[ut++], dt && (Oe[it++] = dt);
    return Oe;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var A = requireParseAsn1(), B = requireMgf(), L = requireXor(), K = requireBn$1(), V = requireBrowserifyRsa(), W = requireBrowser$9(), J = requireWithPublic(), ne = safeBufferExports.Buffer;
  privateDecrypt = function(ke, Oe, it) {
    var at;
    ke.padding ? at = ke.padding : it ? at = 1 : at = 4;
    var ut = A(ke), dt = ut.modulus.byteLength();
    if (Oe.length > dt || new K(Oe).cmp(ut.modulus) >= 0)
      throw new Error("decryption error");
    var ct;
    it ? ct = J(new K(Oe), ut) : ct = V(Oe, ut);
    var bt = ne.alloc(dt - ct.length);
    if (ct = ne.concat([bt, ct], dt), at === 4)
      return ie(ut, ct);
    if (at === 1)
      return ce(ut, ct, it);
    if (at === 3)
      return ct;
    throw new Error("unknown padding");
  };
  function ie(oe, ke) {
    var Oe = oe.modulus.byteLength(), it = W("sha1").update(ne.alloc(0)).digest(), at = it.length;
    if (ke[0] !== 0)
      throw new Error("decryption error");
    var ut = ke.slice(1, at + 1), dt = ke.slice(at + 1), ct = L(ut, B(dt, at)), bt = L(dt, B(ct, Oe - at - 1));
    if (re(it, bt.slice(0, at)))
      throw new Error("decryption error");
    for (var vt = at; bt[vt] === 0; )
      vt++;
    if (bt[vt++] !== 1)
      throw new Error("decryption error");
    return bt.slice(vt);
  }
  function ce(oe, ke, Oe) {
    for (var it = ke.slice(0, 2), at = 2, ut = 0; ke[at++] !== 0; )
      if (at >= ke.length) {
        ut++;
        break;
      }
    var dt = ke.slice(2, at - 1);
    if ((it.toString("hex") !== "0002" && !Oe || it.toString("hex") !== "0001" && Oe) && ut++, dt.length < 8 && ut++, ut)
      throw new Error("decryption error");
    return ke.slice(at);
  }
  function re(oe, ke) {
    oe = ne.from(oe), ke = ne.from(ke);
    var Oe = 0, it = oe.length;
    oe.length !== ke.length && (Oe++, it = Math.min(oe.length, ke.length));
    for (var at = -1; ++at < it; )
      Oe += oe[at] ^ ke[at];
    return Oe;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(A) {
    A.publicEncrypt = requirePublicEncrypt(), A.privateDecrypt = requirePrivateDecrypt(), A.privateEncrypt = function(L, K) {
      return A.publicEncrypt(L, K, !0);
    }, A.publicDecrypt = function(L, K) {
      return A.privateDecrypt(L, K, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function A() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var B = safeBufferExports, L = requireBrowser$b(), K = B.Buffer, V = B.kMaxLength, W = commonjsGlobal.crypto || commonjsGlobal.msCrypto, J = Math.pow(2, 32) - 1;
  function ne(ke, Oe) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("offset must be a number");
    if (ke > J || ke < 0)
      throw new TypeError("offset must be a uint32");
    if (ke > V || ke > Oe)
      throw new RangeError("offset out of range");
  }
  function ie(ke, Oe, it) {
    if (typeof ke != "number" || ke !== ke)
      throw new TypeError("size must be a number");
    if (ke > J || ke < 0)
      throw new TypeError("size must be a uint32");
    if (ke + Oe > it || ke > V)
      throw new RangeError("buffer too small");
  }
  W && W.getRandomValues || !process$1.browser ? (browser.randomFill = ce, browser.randomFillSync = oe) : (browser.randomFill = A, browser.randomFillSync = A);
  function ce(ke, Oe, it, at) {
    if (!K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Oe == "function")
      at = Oe, Oe = 0, it = ke.length;
    else if (typeof it == "function")
      at = it, it = ke.length - Oe;
    else if (typeof at != "function")
      throw new TypeError('"cb" argument must be a function');
    return ne(Oe, ke.length), ie(it, Oe, ke.length), re(ke, Oe, it, at);
  }
  function re(ke, Oe, it, at) {
    if (process$1.browser) {
      var ut = ke.buffer, dt = new Uint8Array(ut, Oe, it);
      if (W.getRandomValues(dt), at) {
        process$1.nextTick(function() {
          at(null, ke);
        });
        return;
      }
      return ke;
    }
    if (at) {
      L(it, function(bt, vt) {
        if (bt)
          return at(bt);
        vt.copy(ke, Oe), at(null, ke);
      });
      return;
    }
    var ct = L(it);
    return ct.copy(ke, Oe), ke;
  }
  function oe(ke, Oe, it) {
    if (typeof Oe > "u" && (Oe = 0), !K.isBuffer(ke) && !(ke instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return ne(Oe, ke.length), it === void 0 && (it = ke.length - Oe), ie(it, Oe, ke.length), re(ke, Oe, it);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var A = requireAlgos(), B = Object.keys(A), L = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(B);
  cryptoBrowserify.getHashes = function() {
    return L;
  };
  var K = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = K.pbkdf2, cryptoBrowserify.pbkdf2Sync = K.pbkdf2Sync;
  var V = requireBrowser$5();
  cryptoBrowserify.Cipher = V.Cipher, cryptoBrowserify.createCipher = V.createCipher, cryptoBrowserify.Cipheriv = V.Cipheriv, cryptoBrowserify.createCipheriv = V.createCipheriv, cryptoBrowserify.Decipher = V.Decipher, cryptoBrowserify.createDecipher = V.createDecipher, cryptoBrowserify.Decipheriv = V.Decipheriv, cryptoBrowserify.createDecipheriv = V.createDecipheriv, cryptoBrowserify.getCiphers = V.getCiphers, cryptoBrowserify.listCiphers = V.listCiphers;
  var W = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = W.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = W.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = W.getDiffieHellman, cryptoBrowserify.createDiffieHellman = W.createDiffieHellman, cryptoBrowserify.DiffieHellman = W.DiffieHellman;
  var J = requireBrowser$3();
  cryptoBrowserify.createSign = J.createSign, cryptoBrowserify.Sign = J.Sign, cryptoBrowserify.createVerify = J.createVerify, cryptoBrowserify.Verify = J.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var ne = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = ne.publicEncrypt, cryptoBrowserify.privateEncrypt = ne.privateEncrypt, cryptoBrowserify.publicDecrypt = ne.publicDecrypt, cryptoBrowserify.privateDecrypt = ne.privateDecrypt;
  var ie = requireBrowser();
  return cryptoBrowserify.randomFill = ie.randomFill, cryptoBrowserify.randomFillSync = ie.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(A) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(A, "__esModule", { value: !0 }), A.utils = A.schnorr = A.verify = A.signSync = A.sign = A.getSharedSecret = A.recoverPublicKey = A.getPublicKey = A.Signature = A.Point = A.CURVE = void 0;
  const B = requireCryptoBrowserify(), L = BigInt(0), K = BigInt(1), V = BigInt(2), W = BigInt(3), J = BigInt(8), ne = Object.freeze({
    a: L,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: K,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  A.CURVE = ne;
  const ie = (Lt, kt) => (Lt + kt / V) / kt, ce = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(Lt) {
      const { n: kt } = ne, Dt = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), Ht = -K * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Xt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Zt = Dt, tr = BigInt("0x100000000000000000000000000000000"), ir = ie(Zt * Lt, kt), ur = ie(-Ht * Lt, kt);
      let sr = St(Lt - ir * Dt - ur * Xt, kt), dr = St(-ir * Ht - ur * Zt, kt);
      const vr = sr > tr, Nt = dr > tr;
      if (vr && (sr = kt - sr), Nt && (dr = kt - dr), sr > tr || dr > tr)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + Lt);
      return { k1neg: vr, k1: sr, k2neg: Nt, k2: dr };
    }
  }, re = 32, oe = 32, ke = 32, Oe = re + 1, it = 2 * re + 1;
  function at(Lt) {
    const { a: kt, b: Dt } = ne, Ht = St(Lt * Lt), Xt = St(Ht * Lt);
    return St(Xt + kt * Lt + Dt);
  }
  const ut = ne.a === L;
  class dt extends Error {
    constructor(kt) {
      super(kt);
    }
  }
  function ct(Lt) {
    if (!(Lt instanceof bt))
      throw new TypeError("JacobianPoint expected");
  }
  class bt {
    constructor(kt, Dt, Ht) {
      this.x = kt, this.y = Dt, this.z = Ht;
    }
    static fromAffine(kt) {
      if (!(kt instanceof xt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return kt.equals(xt.ZERO) ? bt.ZERO : new bt(kt.x, kt.y, K);
    }
    static toAffineBatch(kt) {
      const Dt = Pt(kt.map((Ht) => Ht.z));
      return kt.map((Ht, Xt) => Ht.toAffine(Dt[Xt]));
    }
    static normalizeZ(kt) {
      return bt.toAffineBatch(kt).map(bt.fromAffine);
    }
    equals(kt) {
      ct(kt);
      const { x: Dt, y: Ht, z: Xt } = this, { x: Zt, y: tr, z: ir } = kt, ur = St(Xt * Xt), sr = St(ir * ir), dr = St(Dt * sr), vr = St(Zt * ur), Nt = St(St(Ht * ir) * sr), Qt = St(St(tr * Xt) * ur);
      return dr === vr && Nt === Qt;
    }
    negate() {
      return new bt(this.x, St(-this.y), this.z);
    }
    double() {
      const { x: kt, y: Dt, z: Ht } = this, Xt = St(kt * kt), Zt = St(Dt * Dt), tr = St(Zt * Zt), ir = kt + Zt, ur = St(V * (St(ir * ir) - Xt - tr)), sr = St(W * Xt), dr = St(sr * sr), vr = St(dr - V * ur), Nt = St(sr * (ur - vr) - J * tr), Qt = St(V * Dt * Ht);
      return new bt(vr, Nt, Qt);
    }
    add(kt) {
      ct(kt);
      const { x: Dt, y: Ht, z: Xt } = this, { x: Zt, y: tr, z: ir } = kt;
      if (Zt === L || tr === L)
        return this;
      if (Dt === L || Ht === L)
        return kt;
      const ur = St(Xt * Xt), sr = St(ir * ir), dr = St(Dt * sr), vr = St(Zt * ur), Nt = St(St(Ht * ir) * sr), Qt = St(St(tr * Xt) * ur), rr = St(vr - dr), ar = St(Qt - Nt);
      if (rr === L)
        return ar === L ? this.double() : bt.ZERO;
      const br = St(rr * rr), _r = St(rr * br), pr = St(dr * br), Tr = St(ar * ar - _r - V * pr), Nr = St(ar * (pr - Tr) - Nt * _r), kr = St(Xt * ir * rr);
      return new bt(Tr, Nr, kr);
    }
    subtract(kt) {
      return this.add(kt.negate());
    }
    multiplyUnsafe(kt) {
      const Dt = bt.ZERO;
      if (typeof kt == "bigint" && kt === L)
        return Dt;
      let Ht = lt(kt);
      if (Ht === K)
        return this;
      if (!ut) {
        let vr = Dt, Nt = this;
        for (; Ht > L; )
          Ht & K && (vr = vr.add(Nt)), Nt = Nt.double(), Ht >>= K;
        return vr;
      }
      let { k1neg: Xt, k1: Zt, k2neg: tr, k2: ir } = ce.splitScalar(Ht), ur = Dt, sr = Dt, dr = this;
      for (; Zt > L || ir > L; )
        Zt & K && (ur = ur.add(dr)), ir & K && (sr = sr.add(dr)), dr = dr.double(), Zt >>= K, ir >>= K;
      return Xt && (ur = ur.negate()), tr && (sr = sr.negate()), sr = new bt(St(sr.x * ce.beta), sr.y, sr.z), ur.add(sr);
    }
    precomputeWindow(kt) {
      const Dt = ut ? 128 / kt + 1 : 256 / kt + 1, Ht = [];
      let Xt = this, Zt = Xt;
      for (let tr = 0; tr < Dt; tr++) {
        Zt = Xt, Ht.push(Zt);
        for (let ir = 1; ir < 2 ** (kt - 1); ir++)
          Zt = Zt.add(Xt), Ht.push(Zt);
        Xt = Zt.double();
      }
      return Ht;
    }
    wNAF(kt, Dt) {
      !Dt && this.equals(bt.BASE) && (Dt = xt.BASE);
      const Ht = Dt && Dt._WINDOW_SIZE || 1;
      if (256 % Ht)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Xt = Dt && $t.get(Dt);
      Xt || (Xt = this.precomputeWindow(Ht), Dt && Ht !== 1 && (Xt = bt.normalizeZ(Xt), $t.set(Dt, Xt)));
      let Zt = bt.ZERO, tr = bt.BASE;
      const ir = 1 + (ut ? 128 / Ht : 256 / Ht), ur = 2 ** (Ht - 1), sr = BigInt(2 ** Ht - 1), dr = 2 ** Ht, vr = BigInt(Ht);
      for (let Nt = 0; Nt < ir; Nt++) {
        const Qt = Nt * ur;
        let rr = Number(kt & sr);
        kt >>= vr, rr > ur && (rr -= dr, kt += K);
        const ar = Qt, br = Qt + Math.abs(rr) - 1, _r = Nt % 2 !== 0, pr = rr < 0;
        rr === 0 ? tr = tr.add(vt(_r, Xt[ar])) : Zt = Zt.add(vt(pr, Xt[br]));
      }
      return { p: Zt, f: tr };
    }
    multiply(kt, Dt) {
      let Ht = lt(kt), Xt, Zt;
      if (ut) {
        const { k1neg: tr, k1: ir, k2neg: ur, k2: sr } = ce.splitScalar(Ht);
        let { p: dr, f: vr } = this.wNAF(ir, Dt), { p: Nt, f: Qt } = this.wNAF(sr, Dt);
        dr = vt(tr, dr), Nt = vt(ur, Nt), Nt = new bt(St(Nt.x * ce.beta), Nt.y, Nt.z), Xt = dr.add(Nt), Zt = vr.add(Qt);
      } else {
        const { p: tr, f: ir } = this.wNAF(Ht, Dt);
        Xt = tr, Zt = ir;
      }
      return bt.normalizeZ([Xt, Zt])[0];
    }
    toAffine(kt) {
      const { x: Dt, y: Ht, z: Xt } = this, Zt = this.equals(bt.ZERO);
      kt == null && (kt = Zt ? J : qt(Xt));
      const tr = kt, ir = St(tr * tr), ur = St(ir * tr), sr = St(Dt * ir), dr = St(Ht * ur), vr = St(Xt * tr);
      if (Zt)
        return xt.ZERO;
      if (vr !== K)
        throw new Error("invZ was invalid");
      return new xt(sr, dr);
    }
  }
  bt.BASE = new bt(ne.Gx, ne.Gy, K), bt.ZERO = new bt(L, K, L);
  function vt(Lt, kt) {
    const Dt = kt.negate();
    return Lt ? Dt : kt;
  }
  const $t = /* @__PURE__ */ new WeakMap();
  class xt {
    constructor(kt, Dt) {
      this.x = kt, this.y = Dt;
    }
    _setWindowSize(kt) {
      this._WINDOW_SIZE = kt, $t.delete(this);
    }
    hasEvenY() {
      return this.y % V === L;
    }
    static fromCompressedHex(kt) {
      const Dt = kt.length === 32, Ht = ft(Dt ? kt : kt.subarray(1));
      if (!Jt(Ht))
        throw new Error("Point is not on curve");
      const Xt = at(Ht);
      let Zt = Gt(Xt);
      const tr = (Zt & K) === K;
      Dt ? tr && (Zt = St(-Zt)) : (kt[0] & 1) === 1 !== tr && (Zt = St(-Zt));
      const ir = new xt(Ht, Zt);
      return ir.assertValidity(), ir;
    }
    static fromUncompressedHex(kt) {
      const Dt = ft(kt.subarray(1, re + 1)), Ht = ft(kt.subarray(re + 1, re * 2 + 1)), Xt = new xt(Dt, Ht);
      return Xt.assertValidity(), Xt;
    }
    static fromHex(kt) {
      const Dt = mt(kt), Ht = Dt.length, Xt = Dt[0];
      if (Ht === re)
        return this.fromCompressedHex(Dt);
      if (Ht === Oe && (Xt === 2 || Xt === 3))
        return this.fromCompressedHex(Dt);
      if (Ht === it && Xt === 4)
        return this.fromUncompressedHex(Dt);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Oe} compressed bytes or ${it} uncompressed bytes, not ${Ht}`);
    }
    static fromPrivateKey(kt) {
      return xt.BASE.multiply(nr(kt));
    }
    static fromSignature(kt, Dt, Ht) {
      const { r: Xt, s: Zt } = lr(Dt);
      if (![0, 1, 2, 3].includes(Ht))
        throw new Error("Cannot recover: invalid recovery bit");
      const tr = Ut(mt(kt)), { n: ir } = ne, ur = Ht === 2 || Ht === 3 ? Xt + ir : Xt, sr = qt(ur, ir), dr = St(-tr * sr, ir), vr = St(Zt * sr, ir), Nt = Ht & 1 ? "03" : "02", Qt = xt.fromHex(Nt + nt(ur)), rr = xt.BASE.multiplyAndAddUnsafe(Qt, dr, vr);
      if (!rr)
        throw new Error("Cannot recover signature: point at infinify");
      return rr.assertValidity(), rr;
    }
    toRawBytes(kt = !1) {
      return pt(this.toHex(kt));
    }
    toHex(kt = !1) {
      const Dt = nt(this.x);
      return kt ? `${this.hasEvenY() ? "02" : "03"}${Dt}` : `04${Dt}${nt(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const kt = "Point is not on elliptic curve", { x: Dt, y: Ht } = this;
      if (!Jt(Dt) || !Jt(Ht))
        throw new Error(kt);
      const Xt = St(Ht * Ht), Zt = at(Dt);
      if (St(Xt - Zt) !== L)
        throw new Error(kt);
    }
    equals(kt) {
      return this.x === kt.x && this.y === kt.y;
    }
    negate() {
      return new xt(this.x, St(-this.y));
    }
    double() {
      return bt.fromAffine(this).double().toAffine();
    }
    add(kt) {
      return bt.fromAffine(this).add(bt.fromAffine(kt)).toAffine();
    }
    subtract(kt) {
      return this.add(kt.negate());
    }
    multiply(kt) {
      return bt.fromAffine(this).multiply(kt, this).toAffine();
    }
    multiplyAndAddUnsafe(kt, Dt, Ht) {
      const Xt = bt.fromAffine(this), Zt = Dt === L || Dt === K || this !== xt.BASE ? Xt.multiplyUnsafe(Dt) : Xt.multiply(Dt), tr = bt.fromAffine(kt).multiplyUnsafe(Ht), ir = Zt.add(tr);
      return ir.equals(bt.ZERO) ? void 0 : ir.toAffine();
    }
  }
  A.Point = xt, xt.BASE = new xt(ne.Gx, ne.Gy), xt.ZERO = new xt(L, L);
  function Ot(Lt) {
    return Number.parseInt(Lt[0], 16) >= 8 ? "00" + Lt : Lt;
  }
  function At(Lt) {
    if (Lt.length < 2 || Lt[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Ce(Lt)}`);
    const kt = Lt[1], Dt = Lt.subarray(2, kt + 2);
    if (!kt || Dt.length !== kt)
      throw new Error("Invalid signature integer: wrong length");
    if (Dt[0] === 0 && Dt[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: ft(Dt), left: Lt.subarray(kt + 2) };
  }
  function yt(Lt) {
    if (Lt.length < 2 || Lt[0] != 48)
      throw new Error(`Invalid signature tag: ${Ce(Lt)}`);
    if (Lt[1] !== Lt.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: kt, left: Dt } = At(Lt.subarray(2)), { data: Ht, left: Xt } = At(Dt);
    if (Xt.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Ce(Xt)}`);
    return { r: kt, s: Ht };
  }
  class Bt {
    constructor(kt, Dt) {
      this.r = kt, this.s = Dt, this.assertValidity();
    }
    static fromCompact(kt) {
      const Dt = kt instanceof Uint8Array, Ht = "Signature.fromCompact";
      if (typeof kt != "string" && !Dt)
        throw new TypeError(`${Ht}: Expected string or Uint8Array`);
      const Xt = Dt ? Ce(kt) : kt;
      if (Xt.length !== 128)
        throw new Error(`${Ht}: Expected 64-byte hex`);
      return new Bt(ht(Xt.slice(0, 64)), ht(Xt.slice(64, 128)));
    }
    static fromDER(kt) {
      const Dt = kt instanceof Uint8Array;
      if (typeof kt != "string" && !Dt)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: Ht, s: Xt } = yt(Dt ? kt : pt(kt));
      return new Bt(Ht, Xt);
    }
    static fromHex(kt) {
      return this.fromDER(kt);
    }
    assertValidity() {
      const { r: kt, s: Dt } = this;
      if (!jt(kt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!jt(Dt))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const kt = ne.n >> K;
      return this.s > kt;
    }
    normalizeS() {
      return this.hasHighS() ? new Bt(this.r, St(-this.s, ne.n)) : this;
    }
    toDERRawBytes() {
      return pt(this.toDERHex());
    }
    toDERHex() {
      const kt = Ot(ot(this.s)), Dt = Ot(ot(this.r)), Ht = kt.length / 2, Xt = Dt.length / 2, Zt = ot(Ht), tr = ot(Xt);
      return `30${ot(Xt + Ht + 4)}02${tr}${Dt}02${Zt}${kt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return pt(this.toCompactHex());
    }
    toCompactHex() {
      return nt(this.r) + nt(this.s);
    }
  }
  A.Signature = Bt;
  function gt(...Lt) {
    if (!Lt.every((Ht) => Ht instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (Lt.length === 1)
      return Lt[0];
    const kt = Lt.reduce((Ht, Xt) => Ht + Xt.length, 0), Dt = new Uint8Array(kt);
    for (let Ht = 0, Xt = 0; Ht < Lt.length; Ht++) {
      const Zt = Lt[Ht];
      Dt.set(Zt, Xt), Xt += Zt.length;
    }
    return Dt;
  }
  const rt = Array.from({ length: 256 }, (Lt, kt) => kt.toString(16).padStart(2, "0"));
  function Ce(Lt) {
    if (!(Lt instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let kt = "";
    for (let Dt = 0; Dt < Lt.length; Dt++)
      kt += rt[Lt[Dt]];
    return kt;
  }
  const pe = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function nt(Lt) {
    if (typeof Lt != "bigint")
      throw new Error("Expected bigint");
    if (!(L <= Lt && Lt < pe))
      throw new Error("Expected number 0 <= n < 2^256");
    return Lt.toString(16).padStart(64, "0");
  }
  function st(Lt) {
    const kt = pt(nt(Lt));
    if (kt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return kt;
  }
  function ot(Lt) {
    const kt = Lt.toString(16);
    return kt.length & 1 ? `0${kt}` : kt;
  }
  function ht(Lt) {
    if (typeof Lt != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof Lt);
    return BigInt(`0x${Lt}`);
  }
  function pt(Lt) {
    if (typeof Lt != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof Lt);
    if (Lt.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + Lt.length);
    const kt = new Uint8Array(Lt.length / 2);
    for (let Dt = 0; Dt < kt.length; Dt++) {
      const Ht = Dt * 2, Xt = Lt.slice(Ht, Ht + 2), Zt = Number.parseInt(Xt, 16);
      if (Number.isNaN(Zt) || Zt < 0)
        throw new Error("Invalid byte sequence");
      kt[Dt] = Zt;
    }
    return kt;
  }
  function ft(Lt) {
    return ht(Ce(Lt));
  }
  function mt(Lt) {
    return Lt instanceof Uint8Array ? Uint8Array.from(Lt) : pt(Lt);
  }
  function lt(Lt) {
    if (typeof Lt == "number" && Number.isSafeInteger(Lt) && Lt > 0)
      return BigInt(Lt);
    if (typeof Lt == "bigint" && jt(Lt))
      return Lt;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function St(Lt, kt = ne.P) {
    const Dt = Lt % kt;
    return Dt >= L ? Dt : kt + Dt;
  }
  function Ft(Lt, kt) {
    const { P: Dt } = ne;
    let Ht = Lt;
    for (; kt-- > L; )
      Ht *= Ht, Ht %= Dt;
    return Ht;
  }
  function Gt(Lt) {
    const { P: kt } = ne, Dt = BigInt(6), Ht = BigInt(11), Xt = BigInt(22), Zt = BigInt(23), tr = BigInt(44), ir = BigInt(88), ur = Lt * Lt * Lt % kt, sr = ur * ur * Lt % kt, dr = Ft(sr, W) * sr % kt, vr = Ft(dr, W) * sr % kt, Nt = Ft(vr, V) * ur % kt, Qt = Ft(Nt, Ht) * Nt % kt, rr = Ft(Qt, Xt) * Qt % kt, ar = Ft(rr, tr) * rr % kt, br = Ft(ar, ir) * ar % kt, _r = Ft(br, tr) * rr % kt, pr = Ft(_r, W) * sr % kt, Tr = Ft(pr, Zt) * Qt % kt, Nr = Ft(Tr, Dt) * ur % kt, kr = Ft(Nr, V);
    if (kr * kr % kt !== Lt)
      throw new Error("Cannot find square root");
    return kr;
  }
  function qt(Lt, kt = ne.P) {
    if (Lt === L || kt <= L)
      throw new Error(`invert: expected positive integers, got n=${Lt} mod=${kt}`);
    let Dt = St(Lt, kt), Ht = kt, Xt = L, Zt = K;
    for (; Dt !== L; ) {
      const ir = Ht / Dt, ur = Ht % Dt, sr = Xt - Zt * ir;
      Ht = Dt, Dt = ur, Xt = Zt, Zt = sr;
    }
    if (Ht !== K)
      throw new Error("invert: does not exist");
    return St(Xt, kt);
  }
  function Pt(Lt, kt = ne.P) {
    const Dt = new Array(Lt.length), Ht = Lt.reduce((Zt, tr, ir) => tr === L ? Zt : (Dt[ir] = Zt, St(Zt * tr, kt)), K), Xt = qt(Ht, kt);
    return Lt.reduceRight((Zt, tr, ir) => tr === L ? Zt : (Dt[ir] = St(Zt * Dt[ir], kt), St(Zt * tr, kt)), Xt), Dt;
  }
  function Tt(Lt) {
    const kt = Lt.length * 8 - oe * 8, Dt = ft(Lt);
    return kt > 0 ? Dt >> BigInt(kt) : Dt;
  }
  function Ut(Lt, kt = !1) {
    const Dt = Tt(Lt);
    if (kt)
      return Dt;
    const { n: Ht } = ne;
    return Dt >= Ht ? Dt - Ht : Dt;
  }
  let Wt, It;
  class Rt {
    constructor(kt, Dt) {
      if (this.hashLen = kt, this.qByteLen = Dt, typeof kt != "number" || kt < 2)
        throw new Error("hashLen must be a number");
      if (typeof Dt != "number" || Dt < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(kt).fill(1), this.k = new Uint8Array(kt).fill(0), this.counter = 0;
    }
    hmac(...kt) {
      return A.utils.hmacSha256(this.k, ...kt);
    }
    hmacSync(...kt) {
      return It(this.k, ...kt);
    }
    checkSync() {
      if (typeof It != "function")
        throw new dt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(kt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), kt), this.v = await this.hmac(this.v), kt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), kt), this.v = await this.hmac(this.v));
    }
    reseedSync(kt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), kt), this.v = this.hmacSync(this.v), kt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), kt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let kt = 0;
      const Dt = [];
      for (; kt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), kt += this.v.length;
      }
      return gt(...Dt);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let kt = 0;
      const Dt = [];
      for (; kt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const Ht = this.v.slice();
        Dt.push(Ht), kt += this.v.length;
      }
      return gt(...Dt);
    }
  }
  function jt(Lt) {
    return L < Lt && Lt < ne.n;
  }
  function Jt(Lt) {
    return L < Lt && Lt < ne.P;
  }
  function er(Lt, kt, Dt, Ht = !0) {
    const { n: Xt } = ne, Zt = Ut(Lt, !0);
    if (!jt(Zt))
      return;
    const tr = qt(Zt, Xt), ir = xt.BASE.multiply(Zt), ur = St(ir.x, Xt);
    if (ur === L)
      return;
    const sr = St(tr * St(kt + Dt * ur, Xt), Xt);
    if (sr === L)
      return;
    let dr = new Bt(ur, sr), vr = (ir.x === dr.r ? 0 : 2) | Number(ir.y & K);
    return Ht && dr.hasHighS() && (dr = dr.normalizeS(), vr ^= 1), { sig: dr, recovery: vr };
  }
  function nr(Lt) {
    let kt;
    if (typeof Lt == "bigint")
      kt = Lt;
    else if (typeof Lt == "number" && Number.isSafeInteger(Lt) && Lt > 0)
      kt = BigInt(Lt);
    else if (typeof Lt == "string") {
      if (Lt.length !== 2 * oe)
        throw new Error("Expected 32 bytes of private key");
      kt = ht(Lt);
    } else if (Lt instanceof Uint8Array) {
      if (Lt.length !== oe)
        throw new Error("Expected 32 bytes of private key");
      kt = ft(Lt);
    } else
      throw new TypeError("Expected valid private key");
    if (!jt(kt))
      throw new Error("Expected private key: 0 < key < n");
    return kt;
  }
  function fr(Lt) {
    return Lt instanceof xt ? (Lt.assertValidity(), Lt) : xt.fromHex(Lt);
  }
  function lr(Lt) {
    if (Lt instanceof Bt)
      return Lt.assertValidity(), Lt;
    try {
      return Bt.fromDER(Lt);
    } catch {
      return Bt.fromCompact(Lt);
    }
  }
  function Yt(Lt, kt = !1) {
    return xt.fromPrivateKey(Lt).toRawBytes(kt);
  }
  A.getPublicKey = Yt;
  function Pr(Lt, kt, Dt, Ht = !1) {
    return xt.fromSignature(Lt, kt, Dt).toRawBytes(Ht);
  }
  A.recoverPublicKey = Pr;
  function or(Lt) {
    const kt = Lt instanceof Uint8Array, Dt = typeof Lt == "string", Ht = (kt || Dt) && Lt.length;
    return kt ? Ht === Oe || Ht === it : Dt ? Ht === Oe * 2 || Ht === it * 2 : Lt instanceof xt;
  }
  function Ar(Lt, kt, Dt = !1) {
    if (or(Lt))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!or(kt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const Ht = fr(kt);
    return Ht.assertValidity(), Ht.multiply(nr(Lt)).toRawBytes(Dt);
  }
  A.getSharedSecret = Ar;
  function Br(Lt) {
    const kt = Lt.length > re ? Lt.slice(0, re) : Lt;
    return ft(kt);
  }
  function cr(Lt) {
    const kt = Br(Lt), Dt = St(kt, ne.n);
    return xr(Dt < L ? kt : Dt);
  }
  function xr(Lt) {
    return st(Lt);
  }
  function Ir(Lt, kt, Dt) {
    if (Lt == null)
      throw new Error(`sign: expected valid message hash, not "${Lt}"`);
    const Ht = mt(Lt), Xt = nr(kt), Zt = [xr(Xt), cr(Ht)];
    if (Dt != null) {
      Dt === !0 && (Dt = A.utils.randomBytes(re));
      const ur = mt(Dt);
      if (ur.length !== re)
        throw new Error(`sign: Expected ${re} bytes of extra data`);
      Zt.push(ur);
    }
    const tr = gt(...Zt), ir = Br(Ht);
    return { seed: tr, m: ir, d: Xt };
  }
  function gr(Lt, kt) {
    const { sig: Dt, recovery: Ht } = Lt, { der: Xt, recovered: Zt } = Object.assign({ canonical: !0, der: !0 }, kt), tr = Xt ? Dt.toDERRawBytes() : Dt.toCompactRawBytes();
    return Zt ? [tr, Ht] : tr;
  }
  async function Rr(Lt, kt, Dt = {}) {
    const { seed: Ht, m: Xt, d: Zt } = Ir(Lt, kt, Dt.extraEntropy), tr = new Rt(ke, oe);
    await tr.reseed(Ht);
    let ir;
    for (; !(ir = er(await tr.generate(), Xt, Zt, Dt.canonical)); )
      await tr.reseed();
    return gr(ir, Dt);
  }
  A.sign = Rr;
  function Or(Lt, kt, Dt = {}) {
    const { seed: Ht, m: Xt, d: Zt } = Ir(Lt, kt, Dt.extraEntropy), tr = new Rt(ke, oe);
    tr.reseedSync(Ht);
    let ir;
    for (; !(ir = er(tr.generateSync(), Xt, Zt, Dt.canonical)); )
      tr.reseedSync();
    return gr(ir, Dt);
  }
  A.signSync = Or;
  const Mt = { strict: !0 };
  function wt(Lt, kt, Dt, Ht = Mt) {
    let Xt;
    try {
      Xt = lr(Lt), kt = mt(kt);
    } catch {
      return !1;
    }
    const { r: Zt, s: tr } = Xt;
    if (Ht.strict && Xt.hasHighS())
      return !1;
    const ir = Ut(kt);
    let ur;
    try {
      ur = fr(Dt);
    } catch {
      return !1;
    }
    const { n: sr } = ne, dr = qt(tr, sr), vr = St(ir * dr, sr), Nt = St(Zt * dr, sr), Qt = xt.BASE.multiplyAndAddUnsafe(ur, vr, Nt);
    return Qt ? St(Qt.x, sr) === Zt : !1;
  }
  A.verify = wt;
  function Et(Lt) {
    return St(ft(Lt), ne.n);
  }
  class Ct {
    constructor(kt, Dt) {
      this.r = kt, this.s = Dt, this.assertValidity();
    }
    static fromHex(kt) {
      const Dt = mt(kt);
      if (Dt.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${Dt.length}`);
      const Ht = ft(Dt.subarray(0, 32)), Xt = ft(Dt.subarray(32, 64));
      return new Ct(Ht, Xt);
    }
    assertValidity() {
      const { r: kt, s: Dt } = this;
      if (!Jt(kt) || !jt(Dt))
        throw new Error("Invalid signature");
    }
    toHex() {
      return nt(this.r) + nt(this.s);
    }
    toRawBytes() {
      return pt(this.toHex());
    }
  }
  function Kt(Lt) {
    return xt.fromPrivateKey(Lt).toRawX();
  }
  class Vt {
    constructor(kt, Dt, Ht = A.utils.randomBytes()) {
      if (kt == null)
        throw new TypeError(`sign: Expected valid message, not "${kt}"`);
      this.m = mt(kt);
      const { x: Xt, scalar: Zt } = this.getScalar(nr(Dt));
      if (this.px = Xt, this.d = Zt, this.rand = mt(Ht), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(kt) {
      const Dt = xt.fromPrivateKey(kt), Ht = Dt.hasEvenY() ? kt : ne.n - kt;
      return { point: Dt, scalar: Ht, x: Dt.toRawX() };
    }
    initNonce(kt, Dt) {
      return st(kt ^ ft(Dt));
    }
    finalizeNonce(kt) {
      const Dt = St(ft(kt), ne.n);
      if (Dt === L)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: Ht, x: Xt, scalar: Zt } = this.getScalar(Dt);
      return { R: Ht, rx: Xt, k: Zt };
    }
    finalizeSig(kt, Dt, Ht, Xt) {
      return new Ct(kt.x, St(Dt + Ht * Xt, ne.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: kt, d: Dt, px: Ht, rand: Xt } = this, Zt = A.utils.taggedHash, tr = this.initNonce(Dt, await Zt(Mr.aux, Xt)), { R: ir, rx: ur, k: sr } = this.finalizeNonce(await Zt(Mr.nonce, tr, Ht, kt)), dr = Et(await Zt(Mr.challenge, ur, Ht, kt)), vr = this.finalizeSig(ir, sr, dr, Dt);
      return await Er(vr, kt, Ht) || this.error(), vr;
    }
    calcSync() {
      const { m: kt, d: Dt, px: Ht, rand: Xt } = this, Zt = A.utils.taggedHashSync, tr = this.initNonce(Dt, Zt(Mr.aux, Xt)), { R: ir, rx: ur, k: sr } = this.finalizeNonce(Zt(Mr.nonce, tr, Ht, kt)), dr = Et(Zt(Mr.challenge, ur, Ht, kt)), vr = this.finalizeSig(ir, sr, dr, Dt);
      return Sr(vr, kt, Ht) || this.error(), vr;
    }
  }
  async function zt(Lt, kt, Dt) {
    return new Vt(Lt, kt, Dt).calc();
  }
  function yr(Lt, kt, Dt) {
    return new Vt(Lt, kt, Dt).calcSync();
  }
  function $r(Lt, kt, Dt) {
    const Ht = Lt instanceof Ct, Xt = Ht ? Lt : Ct.fromHex(Lt);
    return Ht && Xt.assertValidity(), {
      ...Xt,
      m: mt(kt),
      P: fr(Dt)
    };
  }
  function hr(Lt, kt, Dt, Ht) {
    const Xt = xt.BASE.multiplyAndAddUnsafe(kt, nr(Dt), St(-Ht, ne.n));
    return !(!Xt || !Xt.hasEvenY() || Xt.x !== Lt);
  }
  async function Er(Lt, kt, Dt) {
    try {
      const { r: Ht, s: Xt, m: Zt, P: tr } = $r(Lt, kt, Dt), ir = Et(await A.utils.taggedHash(Mr.challenge, st(Ht), tr.toRawX(), Zt));
      return hr(Ht, tr, Xt, ir);
    } catch {
      return !1;
    }
  }
  function Sr(Lt, kt, Dt) {
    try {
      const { r: Ht, s: Xt, m: Zt, P: tr } = $r(Lt, kt, Dt), ir = Et(A.utils.taggedHashSync(Mr.challenge, st(Ht), tr.toRawX(), Zt));
      return hr(Ht, tr, Xt, ir);
    } catch (Ht) {
      if (Ht instanceof dt)
        throw Ht;
      return !1;
    }
  }
  A.schnorr = {
    Signature: Ct,
    getPublicKey: Kt,
    sign: zt,
    verify: Er,
    signSync: yr,
    verifySync: Sr
  }, xt.BASE._setWindowSize(8);
  const wr = {
    node: B,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Mr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Cr = {};
  A.utils = {
    bytesToHex: Ce,
    hexToBytes: pt,
    concatBytes: gt,
    mod: St,
    invert: qt,
    isValidPrivateKey(Lt) {
      try {
        return nr(Lt), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: st,
    _normalizePrivateKey: nr,
    hashToPrivateKey: (Lt) => {
      Lt = mt(Lt);
      const kt = oe + 8;
      if (Lt.length < kt || Lt.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const Dt = St(ft(Lt), ne.n - K) + K;
      return st(Dt);
    },
    randomBytes: (Lt = 32) => {
      if (wr.web)
        return wr.web.getRandomValues(new Uint8Array(Lt));
      if (wr.node) {
        const { randomBytes: kt } = wr.node;
        return Uint8Array.from(kt(Lt));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => A.utils.hashToPrivateKey(A.utils.randomBytes(oe + 8)),
    precompute(Lt = 8, kt = xt.BASE) {
      const Dt = kt === xt.BASE ? kt : new xt(kt.x, kt.y);
      return Dt._setWindowSize(Lt), Dt.multiply(W), Dt;
    },
    sha256: async (...Lt) => {
      if (wr.web) {
        const kt = await wr.web.subtle.digest("SHA-256", gt(...Lt));
        return new Uint8Array(kt);
      } else if (wr.node) {
        const { createHash: kt } = wr.node, Dt = kt("sha256");
        return Lt.forEach((Ht) => Dt.update(Ht)), Uint8Array.from(Dt.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (Lt, ...kt) => {
      if (wr.web) {
        const Dt = await wr.web.subtle.importKey("raw", Lt, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), Ht = gt(...kt), Xt = await wr.web.subtle.sign("HMAC", Dt, Ht);
        return new Uint8Array(Xt);
      } else if (wr.node) {
        const { createHmac: Dt } = wr.node, Ht = Dt("sha256", Lt);
        return kt.forEach((Xt) => Ht.update(Xt)), Uint8Array.from(Ht.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (Lt, ...kt) => {
      let Dt = Cr[Lt];
      if (Dt === void 0) {
        const Ht = await A.utils.sha256(Uint8Array.from(Lt, (Xt) => Xt.charCodeAt(0)));
        Dt = gt(Ht, Ht), Cr[Lt] = Dt;
      }
      return A.utils.sha256(Dt, ...kt);
    },
    taggedHashSync: (Lt, ...kt) => {
      if (typeof Wt != "function")
        throw new dt("sha256Sync is undefined, you need to set it");
      let Dt = Cr[Lt];
      if (Dt === void 0) {
        const Ht = Wt(Uint8Array.from(Lt, (Xt) => Xt.charCodeAt(0)));
        Dt = gt(Ht, Ht), Cr[Lt] = Dt;
      }
      return Wt(Dt, ...kt);
    },
    _JacobianPoint: bt
  }, Object.defineProperties(A.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return Wt;
      },
      set(Lt) {
        Wt || (Wt = Lt);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return It;
      },
      set(Lt) {
        It || (It = Lt);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(A) {
  return (A / 8 | 0) + (A % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(A) {
  const B = paramBytesForAlg[A];
  if (B)
    return B;
  throw new Error(`Unknown algorithm "${A}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(A) {
  if (A instanceof Uint8Array)
    return A;
  if (typeof A == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(A));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(A, B) {
  const L = signatureAsBytes(A), K = getParamBytesForAlg(B), V = K + 1, W = L.length;
  let J = 0;
  if (L[J++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let ne = L[J++];
  if (ne === (MAX_OCTET | 1) && (ne = L[J++]), W - J < ne)
    throw new Error(`"seq" specified length of "${ne}", only "${W - J}" remaining`);
  if (L[J++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ie = L[J++];
  if (W - J - 2 < ie)
    throw new Error(`"r" specified length of "${ie}", only "${W - J - 2}" available`);
  if (V < ie)
    throw new Error(`"r" specified length of "${ie}", max of "${V}" is acceptable`);
  const ce = J;
  if (J += ie, L[J++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const re = L[J++];
  if (W - J !== re)
    throw new Error(`"s" specified length of "${re}", expected "${W - J}"`);
  if (V < re)
    throw new Error(`"s" specified length of "${re}", max of "${V}" is acceptable`);
  const oe = J;
  if (J += re, J !== W)
    throw new Error(`Expected to consume entire array, but "${W - J}" bytes remain`);
  const ke = K - ie, Oe = K - re, it = new Uint8Array(ke + ie + Oe + re);
  for (J = 0; J < ke; ++J)
    it[J] = 0;
  it.set(L.subarray(ce + Math.max(-ke, 0), ce + ie), J), J = K;
  for (const at = J; J < at + Oe; ++J)
    it[J] = 0;
  return it.set(L.subarray(oe + Math.max(-Oe, 0), oe + re), J), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(it));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(A, B, L) {
  let K = 0;
  for (; B + K < L && A[B + K] === 0; )
    ++K;
  return A[B + K] >= MAX_OCTET && --K, K;
}
function joseToDer(A, B) {
  A = signatureAsBytes(A);
  const L = getParamBytesForAlg(B), K = A.length;
  if (K !== L * 2)
    throw new TypeError(`"${B}" signatures must be "${L * 2}" bytes, saw "${K}"`);
  const V = countPadding(A, 0, L), W = countPadding(A, L, A.length), J = L - V, ne = L - W, ie = 2 + J + 1 + 1 + ne, ce = ie < MAX_OCTET, re = new Uint8Array((ce ? 2 : 3) + ie);
  let oe = 0;
  return re[oe++] = ENCODED_TAG_SEQ, ce ? re[oe++] = ie : (re[oe++] = MAX_OCTET | 1, re[oe++] = ie & 255), re[oe++] = ENCODED_TAG_INT, re[oe++] = J, V < 0 ? (re[oe++] = 0, re.set(A.subarray(0, L), oe), oe += L) : (re.set(A.subarray(V, L), oe), oe += L - V), re[oe++] = ENCODED_TAG_INT, re[oe++] = ne, W < 0 ? (re[oe++] = 0, re.set(A.subarray(L), oe)) : re.set(A.subarray(L + W), oe), re;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(B) {
    super(), this.name = "MissingParametersError", this.message = B || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(B) {
    super(), this.name = "InvalidTokenError", this.message = B || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (A, ...B) => {
  const L = hmac_1.hmac.create(sha256_1$3.sha256, A);
  return B.forEach((K) => L.update(K)), L.digest();
};
class SECP256K1Client {
  static derivePublicKey(B, L = !0) {
    return B.length === 66 && (B = B.slice(0, 64)), B.length < 64 && (B = B.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(B, L));
  }
  static signHash(B, L, K = "jose") {
    if (!B || !L)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const V = secp.signSync(B, L.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (K === "der")
      return (0, utils_1$2.bytesToHex)(V);
    if (K === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(V, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(B) {
    return (0, ecdsaSigFormatter_1.joseToDer)(B, "ES256");
  }
  static verifyHash(B, L, K) {
    if (!B || !L || !K)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(L, B, K, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.cryptoClients = A.SECP256K1Client = void 0;
  const B = secp256k1$1;
  Object.defineProperty(A, "SECP256K1Client", { enumerable: !0, get: function() {
    return B.SECP256K1Client;
  } });
  const L = {
    ES256K: B.SECP256K1Client
  };
  A.cryptoClients = L;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function V(W) {
    return W instanceof L ? W : new L(function(J) {
      J(W);
    });
  }
  return new (L || (L = Promise))(function(W, J) {
    function ne(re) {
      try {
        ce(K.next(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ie(re) {
      try {
        ce(K.throw(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ce(re) {
      re.done ? W(re.value) : V(re.value).then(ne, ie);
    }
    ce((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(A) {
  return (0, sha256_1$2.sha256)(A);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(A) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const L = typeof A == "string" ? new TextEncoder().encode(A) : A, K = yield crypto.subtle.digest("SHA-256", L);
        return new Uint8Array(K);
      } else {
        const L = requireCryptoBrowserify();
        if (!L.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(L.createHash("sha256").update(A).digest());
      }
    } catch (B) {
      return console.log(B), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(A));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(A, B, L, K) {
  function V(W) {
    return W instanceof L ? W : new L(function(J) {
      J(W);
    });
  }
  return new (L || (L = Promise))(function(W, J) {
    function ne(re) {
      try {
        ce(K.next(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ie(re) {
      try {
        ce(K.throw(re));
      } catch (oe) {
        J(oe);
      }
    }
    function ce(re) {
      re.done ? W(re.value) : V(re.value).then(ne, ie);
    }
    ce((K = K.apply(A, B || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(A, B) {
  const L = [], K = base64url$2.encode(JSON.stringify(B));
  L.push(K);
  const V = base64url$2.encode(JSON.stringify(A));
  return L.push(V), L.join(".");
}
function createUnsecuredToken(A) {
  return createSigningInput(A, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof B != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (B = B.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(B))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[B], this.rawPrivateKey = L;
  }
  header(B = {}) {
    const L = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, L, B);
  }
  sign(B, L = !1, K = {}) {
    const V = this.header(K), W = createSigningInput(B, V), J = (0, sha256_1$1.hashSha256)(W);
    return this.createWithSignedHash(B, L, V, W, J);
  }
  signAsync(B, L = !1, K = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const V = this.header(K), W = createSigningInput(B, V), J = yield (0, sha256_1$1.hashSha256Async)(W);
      return this.createWithSignedHash(B, L, V, W, J);
    });
  }
  createWithSignedHash(B, L, K, V, W) {
    const J = this.cryptoClient.signHash(W, this.rawPrivateKey);
    return L ? {
      header: [base64url$2.encode(JSON.stringify(K))],
      payload: JSON.stringify(B),
      signature: [J]
    } : [V, J].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(B, L) {
    if (!(B && L))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof B != "string")
      throw "signing algorithm parameter must be a string";
    if (B = B.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(B))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[B], this.rawPublicKey = L;
  }
  verify(B) {
    return typeof B == "string" ? this.verifyCompact(B, !1) : typeof B == "object" ? this.verifyExpanded(B, !1) : !1;
  }
  verifyAsync(B) {
    return typeof B == "string" ? this.verifyCompact(B, !0) : typeof B == "object" ? this.verifyExpanded(B, !0) : Promise.resolve(!1);
  }
  verifyCompact(B, L) {
    const K = B.split("."), V = K[0] + "." + K[1], W = (J) => {
      const ne = this.cryptoClient.loadSignature(K[2]);
      return this.cryptoClient.verifyHash(J, ne, this.rawPublicKey);
    };
    if (L)
      return (0, sha256_1.hashSha256Async)(V).then((J) => W(J));
    {
      const J = (0, sha256_1.hashSha256)(V);
      return W(J);
    }
  }
  verifyExpanded(B, L) {
    const K = [B.header.join("."), base64url$1.encode(B.payload)].join(".");
    let V = !0;
    const W = (J) => (B.signature.map((ne) => {
      const ie = this.cryptoClient.loadSignature(ne);
      this.cryptoClient.verifyHash(J, ie, this.rawPublicKey) || (V = !1);
    }), V);
    if (L)
      return (0, sha256_1.hashSha256Async)(K).then((J) => W(J));
    {
      const J = (0, sha256_1.hashSha256)(K);
      return W(J);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(A) {
  if (typeof A == "string") {
    const B = A.split("."), L = JSON.parse(base64url.decode(B[0])), K = JSON.parse(base64url.decode(B[1])), V = B[2];
    return {
      header: L,
      payload: K,
      signature: V
    };
  } else if (typeof A == "object") {
    if (typeof A.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let B = A.payload;
    A.payload[0] !== "{" && (B = base64url.decode(B));
    const L = [];
    return A.header.map((K) => {
      const V = JSON.parse(base64url.decode(K));
      L.push(V);
    }), {
      header: L,
      payload: JSON.parse(B),
      signature: A.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(A) {
  var B = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(K, V, W, J) {
    J === void 0 && (J = W);
    var ne = Object.getOwnPropertyDescriptor(V, W);
    (!ne || ("get" in ne ? !V.__esModule : ne.writable || ne.configurable)) && (ne = { enumerable: !0, get: function() {
      return V[W];
    } }), Object.defineProperty(K, J, ne);
  } : function(K, V, W, J) {
    J === void 0 && (J = W), K[J] = V[W];
  }), L = commonjsGlobal && commonjsGlobal.__exportStar || function(K, V) {
    for (var W in K) W !== "default" && !Object.prototype.hasOwnProperty.call(V, W) && B(V, K, W);
  };
  Object.defineProperty(A, "__esModule", { value: !0 }), L(signer, A), L(verifier, A), L(decode$i, A), L(errors$1, A), L(cryptoClients, A);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const A = Array(256).fill(-1);
  for (let B = 0; B < r.length; ++B) A[r.charCodeAt(B)] = B;
})();
var s, i, o, h$1 = (s = function(A, B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.bech32m = B.bech32 = void 0;
  const L = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", K = {};
  for (let oe = 0; oe < 32; oe++) {
    const ke = L.charAt(oe);
    K[ke] = oe;
  }
  function V(oe) {
    const ke = oe >> 25;
    return (33554431 & oe) << 5 ^ 996825010 & -(ke >> 0 & 1) ^ 642813549 & -(ke >> 1 & 1) ^ 513874426 & -(ke >> 2 & 1) ^ 1027748829 & -(ke >> 3 & 1) ^ 705979059 & -(ke >> 4 & 1);
  }
  function W(oe) {
    let ke = 1;
    for (let Oe = 0; Oe < oe.length; ++Oe) {
      const it = oe.charCodeAt(Oe);
      if (it < 33 || it > 126) return "Invalid prefix (" + oe + ")";
      ke = V(ke) ^ it >> 5;
    }
    ke = V(ke);
    for (let Oe = 0; Oe < oe.length; ++Oe) {
      const it = oe.charCodeAt(Oe);
      ke = V(ke) ^ 31 & it;
    }
    return ke;
  }
  function J(oe, ke, Oe, it) {
    let at = 0, ut = 0;
    const dt = (1 << Oe) - 1, ct = [];
    for (let bt = 0; bt < oe.length; ++bt) for (at = at << ke | oe[bt], ut += ke; ut >= Oe; ) ut -= Oe, ct.push(at >> ut & dt);
    if (it) ut > 0 && ct.push(at << Oe - ut & dt);
    else {
      if (ut >= ke) return "Excess padding";
      if (at << Oe - ut & dt) return "Non-zero padding";
    }
    return ct;
  }
  function ne(oe) {
    return J(oe, 8, 5, !0);
  }
  function ie(oe) {
    const ke = J(oe, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
  }
  function ce(oe) {
    const ke = J(oe, 5, 8, !1);
    if (Array.isArray(ke)) return ke;
    throw new Error(ke);
  }
  function re(oe) {
    let ke;
    function Oe(it, at) {
      if (at = at || 90, it.length < 8) return it + " too short";
      if (it.length > at) return "Exceeds length limit";
      const ut = it.toLowerCase(), dt = it.toUpperCase();
      if (it !== ut && it !== dt) return "Mixed-case string " + it;
      const ct = (it = ut).lastIndexOf("1");
      if (ct === -1) return "No separator character for " + it;
      if (ct === 0) return "Missing prefix for " + it;
      const bt = it.slice(0, ct), vt = it.slice(ct + 1);
      if (vt.length < 6) return "Data too short";
      let $t = W(bt);
      if (typeof $t == "string") return $t;
      const xt = [];
      for (let Ot = 0; Ot < vt.length; ++Ot) {
        const At = vt.charAt(Ot), yt = K[At];
        if (yt === void 0) return "Unknown character " + At;
        $t = V($t) ^ yt, Ot + 6 >= vt.length || xt.push(yt);
      }
      return $t !== ke ? "Invalid checksum for " + it : { prefix: bt, words: xt };
    }
    return ke = oe === "bech32" ? 1 : 734539939, { decodeUnsafe: function(it, at) {
      const ut = Oe(it, at);
      if (typeof ut == "object") return ut;
    }, decode: function(it, at) {
      const ut = Oe(it, at);
      if (typeof ut == "object") return ut;
      throw new Error(ut);
    }, encode: function(it, at, ut) {
      if (ut = ut || 90, it.length + 7 + at.length > ut) throw new TypeError("Exceeds length limit");
      let dt = W(it = it.toLowerCase());
      if (typeof dt == "string") throw new Error(dt);
      let ct = it + "1";
      for (let bt = 0; bt < at.length; ++bt) {
        const vt = at[bt];
        if (vt >> 5) throw new Error("Non 5-bit word");
        dt = V(dt) ^ vt, ct += L.charAt(vt);
      }
      for (let bt = 0; bt < 6; ++bt) dt = V(dt);
      dt ^= ke;
      for (let bt = 0; bt < 6; ++bt) ct += L.charAt(dt >> 5 * (5 - bt) & 31);
      return ct;
    }, toWords: ne, fromWordsUnsafe: ie, fromWords: ce };
  }
  B.bech32 = re("bech32"), B.bech32m = re("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(A) {
  A.mainnet = "mainnet", A.testnet = "testnet", A.regtest = "regtest";
})(x || (x = {})), function(A) {
  A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
async function getProviderOrThrow(A) {
  var L;
  const B = await (A == null ? void 0 : A()) || ((L = window.XverseProviders) == null ? void 0 : L.BitcoinProvider) || window.BitcoinProvider;
  if (!B)
    throw new Error("No Bitcoin wallet installed");
  return B;
}
var BitcoinNetworkType = /* @__PURE__ */ ((A) => (A.Mainnet = "Mainnet", A.Testnet = "Testnet", A.Testnet4 = "Testnet4", A.Signet = "Signet", A.Regtest = "Regtest", A))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((A) => (A.Ordinals = "ordinals", A.Payment = "payment", A.Stacks = "stacks", A))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((A) => (A.p2pkh = "p2pkh", A.p2sh = "p2sh", A.p2wpkh = "p2wpkh", A.p2wsh = "p2wsh", A.p2tr = "p2tr", A.stacks = "stacks", A))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), getAddress = async (A) => {
  var K, V;
  const B = await getProviderOrThrow(A.getProvider), { purposes: L } = A.payload;
  if (!L)
    throw new Error("Address purposes are required");
  try {
    const W = lib$1.createUnsecuredToken(A.payload), J = await B.connect(W);
    (K = A.onFinish) == null || K.call(A, J);
  } catch (W) {
    console.error("[Connect] Error during address request", W), (V = A.onCancel) == null || V.call(A);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((A) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((A) => (A.ECDSA = "ECDSA", A.BIP322 = "BIP322", A))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
async function waitForUnisatExtensionReady() {
  let A = 0;
  const B = 20;
  for (; A < B; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const L = await window.unisat.getAccounts();
        if (L && L.length > 0)
          return !0;
      } catch {
        break;
      }
    A += 1, await new Promise((L) => {
      setTimeout(L, 100);
    });
  }
  return !1;
}
const NETWORK_TO_BITCOIN_NETWORK_TYPE = {
  mainnet: BitcoinNetworkType.Mainnet,
  testnet: BitcoinNetworkType.Testnet,
  signet: BitcoinNetworkType.Signet
}, getXverseAddresses = async (A) => {
  var W;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((W = window.XverseProviders) == null ? void 0 : W.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const L = async () => window.XverseProviders.BitcoinProvider, K = [], V = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: A === Network.TESTNET ? BitcoinNetworkType.Testnet4 : NETWORK_TO_BITCOIN_NETWORK_TYPE[A]
      }
    },
    getProvider: L,
    onFinish: (J) => {
      if (!J || !J.addresses || J.addresses.length !== 2)
        throw new BrowserWalletSigningError(
          "Failed to retrieve addresses using selected wallet"
        );
      J.addresses.forEach((ne) => {
        const ie = getAddressFormat(ne.address, A);
        let ce = ne.publicKey;
        ie === "taproot" && (ce = Buffer$1.from(ne.publicKey, "hex").length === 33 ? ce : `02${ce}`), K.push({
          publicKey: ce,
          address: ne.address,
          format: ie
        });
      });
    },
    onCancel: () => {
      throw new BrowserWalletRequestCancelledByUserError();
    }
  };
  return await getAddress(V), K;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: A,
  wallet: B,
  chain: L = Chain.BITCOIN
}, { readOnly: K = !1 } = {}) => {
  switch (B) {
    case Wallet.UNISAT: {
      const V = await getAddresses$3(A, L, { readOnly: K });
      if (!V || V.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const W = V[0];
      return {
        address: {
          ordinals: W.address,
          payments: W.address
        },
        publicKey: {
          ordinals: W.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: W.format,
          payments: W.format
        }
      };
    }
    case Wallet.XVERSE: {
      const V = await getXverseAddresses(A);
      if (!V || V.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const W = V.find(
        (ne) => ne.format === "p2sh-p2wpkh" || ne.format === "segwit"
      );
      if (!W)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const J = V.find(
        (ne) => ne.format === "taproot"
      );
      if (!J)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: J.address,
          payments: W.address
        },
        publicKey: {
          ordinals: J.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: J.format,
          payments: W.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const V = await getAddresses$2(A);
      if (!V || V.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const W = V.find(
        (ne) => ne.format === "segwit" || ne.format === "p2sh-p2wpkh"
      );
      if (!W)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const J = V.find(
        (ne) => ne.format === "taproot"
      );
      if (!J)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: J.address,
          payments: W.address
        },
        publicKey: {
          ordinals: J.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: J.format,
          payments: W.format
        }
      };
    }
    case Wallet.LEATHER: {
      const V = await getAddresses$1(A);
      if (!V || V.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const W = V.find(
        (ne) => ne.format === "segwit"
      );
      if (!W)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const J = V.find(
        (ne) => ne.format === "taproot"
      );
      if (!J)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: J.address,
          payments: W.address
        },
        publicKey: {
          ordinals: J.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: J.format,
          payments: W.format
        }
      };
    }
    case Wallet.OKX: {
      const V = await getAddresses(A);
      if (!V || V.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const W = V[0];
      return {
        address: {
          ordinals: W.address,
          payments: W.address
        },
        publicKey: {
          ordinals: W.publicKey,
          payments: W.publicKey
        },
        format: {
          ordinals: W.format,
          payments: W.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: A,
  onError: B
}) {
  const {
    updateAddress: L,
    network: K,
    updateWallet: V,
    updatePublicKey: W,
    updateFormat: J,
    disconnectWallet: ne,
    address: ie,
    publicKey: ce,
    format: re,
    wallet: oe,
    chain: ke
  } = useOrdConnect(), Oe = (at, ut) => {
    B(ut.message ?? ut.toString()), console.error(`Error while connecting to ${at} wallet`, ut), ne(), ut instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[at],
      "_blank",
      "noopener,noreferrer"
    );
  }, it = async (at, { readOnly: ut = !1 } = {}) => {
    try {
      const { address: dt, publicKey: ct, format: bt } = await connectWallet(
        { network: K, wallet: at, chain: ke },
        { readOnly: ut }
      );
      return L({
        ordinals: dt.ordinals,
        payments: dt.payments
      }), W({
        ordinals: ct.ordinals,
        payments: ct.payments
      }), V(at), J({
        ordinals: bt.ordinals,
        payments: bt.payments
      }), A(), !0;
    } catch (dt) {
      return Oe(at, dt), !1;
    }
  };
  return useEffect(() => {
    if (console.log("connectedWallet", oe), oe !== Wallet.UNISAT) {
      console.log("connectedWallet", oe);
      return;
    }
    let at = !0, ut = !1;
    const dt = () => it(Wallet.UNISAT);
    return ie && ce && re && (async () => {
      const bt = await waitForUnisatExtensionReady();
      if (at) {
        if (!bt) {
          ne();
          return;
        }
        ut = await it(Wallet.UNISAT, {
          readOnly: !0
        }), at && ut && window.unisat.addListener("accountsChanged", dt);
      }
    })(), () => {
      at = !1, ut && window.unisat.removeListener("accountsChanged", dt);
    };
  }, [oe]), { connectWallet: it };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: A,
  onConnect: B,
  icon: L,
  renderAvatar: K,
  isPreferred: V
}) {
  const W = isMobileUserAgent(), {
    network: J,
    wallet: ne,
    address: ie,
    updateNetwork: ce
  } = useOrdConnect(), [re, oe] = useState(!1), ke = WALLET_TO_NAME[A], Oe = async () => {
    oe(!0);
    try {
      console.log("network==>clicked", J);
      const at = A === Wallet.XVERSE && J === Network.TESTNET, ut = J === "testnet4";
      console.log("isXverseTestnet==>", at), ce(at || ut ? "testnet4" : Network.TESTNET), await B();
    } catch {
    }
    oe(!1);
  }, it = ne === A && ie.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Oe,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: L, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: ke }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: W ? "Available on app" : "" })
        ] }),
        ne === A && ie.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          K ? K(ie.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: W ? 12 : 16,
              variant: "beam",
              name: ie.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(ie.ordinals) })
        ] }) : null,
        !it && V ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        re ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: W ? 20 : 24,
            height: W ? 20 : 24,
            alt: `${ke} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: W ? 20 : 24,
            height: W ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: A,
  closeModal: B,
  renderAvatar: L,
  preferredWallet: K,
  walletsOrder: V,
  visibleWallets: W
}) {
  const [J, ne] = useState(""), { connectWallet: ie } = useConnect({
    onClose: B,
    onError: (Oe) => ne(Oe)
  }), { network: ce, chain: re } = useOrdConnect(), oe = isMobileUserAgent(), ke = useMemo(() => {
    const it = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ie(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: oe && ce !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ie(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: oe,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ie(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ie(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ie(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: oe,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((ut) => (W || []).includes(ut.wallet)).filter(
      (ut) => ut.chains.includes(re) && !ut.hidden
    );
    return V ? it.map((ut) => {
      const dt = V.findIndex(
        (ct) => ct === ut.wallet
      );
      return dt >= 0 ? { ...ut, order: dt } : ut;
    }).sort((ut, dt) => ut.order - dt.order) : it;
  }, [oe, ce, V, ie, re]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(qe, { appear: !0, show: A, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    _t,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: B,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          qe.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(_t.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[re],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: B,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: ke.map((Oe, it) => {
                  const at = it === ke.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Oe.wallet,
                        onConnect: async () => {
                          ne("");
                          const ut = Oe.onConnect().then((ct) => (ct && ne(""), ct)), dt = await Promise.race([
                            ut,
                            new Promise((ct) => {
                              setTimeout(() => ct("timeout"), 5e3);
                            })
                          ]);
                          return typeof dt == "string" ? (ne(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), ut) : dt;
                        },
                        icon: Oe.icon,
                        renderAvatar: L,
                        isPreferred: K === Oe.wallet
                      }
                    ),
                    !at && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Oe.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: J })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: A,
  onViewProfile: B,
  onChangeWalletClick: L,
  onDisconnectWalletClick: K,
  renderAvatar: V,
  preferredWallet: W,
  walletsOrder: J
}) {
  const {
    address: ne,
    disconnectWallet: ie,
    network: ce,
    isModalOpen: re,
    openModal: oe,
    closeModal: ke,
    visibleWallets: Oe
  } = useOrdConnect(), it = useHasMounted(), at = () => A ? null : ne != null && ne.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: ne.ordinals,
      network: ce,
      onViewProfile: B,
      onChangeWallet: () => {
        oe(), L == null || L();
      },
      onDisconnectWallet: () => {
        ie(), K == null || K();
      },
      renderAvatar: V
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !it, openModal: oe });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    at(),
    it ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: re,
        closeModal: ke,
        renderAvatar: V,
        preferredWallet: W,
        walletsOrder: J,
        visibleWallets: Oe
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(A) {
  var B, L, K, V = ct.prototype = { constructor: ct, toString: null, valueOf: null }, W = new ct(1), J = 20, ne = 4, ie = -7, ce = 21, re = -1e7, oe = 1e7, ke = !1, Oe = 1, it = 0, at = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, ut = "0123456789abcdefghijklmnopqrstuvwxyz", dt = !0;
  function ct(At, yt) {
    var Bt, gt, rt, Ce, pe, nt, st, ot, ht = this;
    if (!(ht instanceof ct)) return new ct(At, yt);
    if (yt == null) {
      if (At && At._isBigNumber === !0) {
        ht.s = At.s, !At.c || At.e > oe ? ht.c = ht.e = null : At.e < re ? ht.c = [ht.e = 0] : (ht.e = At.e, ht.c = At.c.slice());
        return;
      }
      if ((nt = typeof At == "number") && At * 0 == 0) {
        if (ht.s = 1 / At < 0 ? (At = -At, -1) : 1, At === ~~At) {
          for (Ce = 0, pe = At; pe >= 10; pe /= 10, Ce++) ;
          Ce > oe ? ht.c = ht.e = null : (ht.e = Ce, ht.c = [At]);
          return;
        }
        ot = String(At);
      } else {
        if (!isNumeric.test(ot = String(At))) return K(ht, ot, nt);
        ht.s = ot.charCodeAt(0) == 45 ? (ot = ot.slice(1), -1) : 1;
      }
      (Ce = ot.indexOf(".")) > -1 && (ot = ot.replace(".", "")), (pe = ot.search(/e/i)) > 0 ? (Ce < 0 && (Ce = pe), Ce += +ot.slice(pe + 1), ot = ot.substring(0, pe)) : Ce < 0 && (Ce = ot.length);
    } else {
      if (intCheck(yt, 2, ut.length, "Base"), yt == 10 && dt)
        return ht = new ct(At), xt(ht, J + ht.e + 1, ne);
      if (ot = String(At), nt = typeof At == "number") {
        if (At * 0 != 0) return K(ht, ot, nt, yt);
        if (ht.s = 1 / At < 0 ? (ot = ot.slice(1), -1) : 1, ct.DEBUG && ot.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + At);
      } else
        ht.s = ot.charCodeAt(0) === 45 ? (ot = ot.slice(1), -1) : 1;
      for (Bt = ut.slice(0, yt), Ce = pe = 0, st = ot.length; pe < st; pe++)
        if (Bt.indexOf(gt = ot.charAt(pe)) < 0) {
          if (gt == ".") {
            if (pe > Ce) {
              Ce = st;
              continue;
            }
          } else if (!rt && (ot == ot.toUpperCase() && (ot = ot.toLowerCase()) || ot == ot.toLowerCase() && (ot = ot.toUpperCase()))) {
            rt = !0, pe = -1, Ce = 0;
            continue;
          }
          return K(ht, String(At), nt, yt);
        }
      nt = !1, ot = L(ot, yt, 10, ht.s), (Ce = ot.indexOf(".")) > -1 ? ot = ot.replace(".", "") : Ce = ot.length;
    }
    for (pe = 0; ot.charCodeAt(pe) === 48; pe++) ;
    for (st = ot.length; ot.charCodeAt(--st) === 48; ) ;
    if (ot = ot.slice(pe, ++st)) {
      if (st -= pe, nt && ct.DEBUG && st > 15 && (At > MAX_SAFE_INTEGER$2 || At !== mathfloor(At)))
        throw Error(tooManyDigits + ht.s * At);
      if ((Ce = Ce - pe - 1) > oe)
        ht.c = ht.e = null;
      else if (Ce < re)
        ht.c = [ht.e = 0];
      else {
        if (ht.e = Ce, ht.c = [], pe = (Ce + 1) % LOG_BASE, Ce < 0 && (pe += LOG_BASE), pe < st) {
          for (pe && ht.c.push(+ot.slice(0, pe)), st -= LOG_BASE; pe < st; )
            ht.c.push(+ot.slice(pe, pe += LOG_BASE));
          pe = LOG_BASE - (ot = ot.slice(pe)).length;
        } else
          pe -= st;
        for (; pe--; ot += "0") ;
        ht.c.push(+ot);
      }
    } else
      ht.c = [ht.e = 0];
  }
  ct.clone = clone, ct.ROUND_UP = 0, ct.ROUND_DOWN = 1, ct.ROUND_CEIL = 2, ct.ROUND_FLOOR = 3, ct.ROUND_HALF_UP = 4, ct.ROUND_HALF_DOWN = 5, ct.ROUND_HALF_EVEN = 6, ct.ROUND_HALF_CEIL = 7, ct.ROUND_HALF_FLOOR = 8, ct.EUCLID = 9, ct.config = ct.set = function(At) {
    var yt, Bt;
    if (At != null)
      if (typeof At == "object") {
        if (At.hasOwnProperty(yt = "DECIMAL_PLACES") && (Bt = At[yt], intCheck(Bt, 0, MAX, yt), J = Bt), At.hasOwnProperty(yt = "ROUNDING_MODE") && (Bt = At[yt], intCheck(Bt, 0, 8, yt), ne = Bt), At.hasOwnProperty(yt = "EXPONENTIAL_AT") && (Bt = At[yt], Bt && Bt.pop ? (intCheck(Bt[0], -1e9, 0, yt), intCheck(Bt[1], 0, MAX, yt), ie = Bt[0], ce = Bt[1]) : (intCheck(Bt, -1e9, MAX, yt), ie = -(ce = Bt < 0 ? -Bt : Bt))), At.hasOwnProperty(yt = "RANGE"))
          if (Bt = At[yt], Bt && Bt.pop)
            intCheck(Bt[0], -1e9, -1, yt), intCheck(Bt[1], 1, MAX, yt), re = Bt[0], oe = Bt[1];
          else if (intCheck(Bt, -1e9, MAX, yt), Bt)
            re = -(oe = Bt < 0 ? -Bt : Bt);
          else
            throw Error(bignumberError + yt + " cannot be zero: " + Bt);
        if (At.hasOwnProperty(yt = "CRYPTO"))
          if (Bt = At[yt], Bt === !!Bt)
            if (Bt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                ke = Bt;
              else
                throw ke = !Bt, Error(bignumberError + "crypto unavailable");
            else
              ke = Bt;
          else
            throw Error(bignumberError + yt + " not true or false: " + Bt);
        if (At.hasOwnProperty(yt = "MODULO_MODE") && (Bt = At[yt], intCheck(Bt, 0, 9, yt), Oe = Bt), At.hasOwnProperty(yt = "POW_PRECISION") && (Bt = At[yt], intCheck(Bt, 0, MAX, yt), it = Bt), At.hasOwnProperty(yt = "FORMAT"))
          if (Bt = At[yt], typeof Bt == "object") at = Bt;
          else throw Error(bignumberError + yt + " not an object: " + Bt);
        if (At.hasOwnProperty(yt = "ALPHABET"))
          if (Bt = At[yt], typeof Bt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Bt))
            dt = Bt.slice(0, 10) == "0123456789", ut = Bt;
          else
            throw Error(bignumberError + yt + " invalid: " + Bt);
      } else
        throw Error(bignumberError + "Object expected: " + At);
    return {
      DECIMAL_PLACES: J,
      ROUNDING_MODE: ne,
      EXPONENTIAL_AT: [ie, ce],
      RANGE: [re, oe],
      CRYPTO: ke,
      MODULO_MODE: Oe,
      POW_PRECISION: it,
      FORMAT: at,
      ALPHABET: ut
    };
  }, ct.isBigNumber = function(At) {
    if (!At || At._isBigNumber !== !0) return !1;
    if (!ct.DEBUG) return !0;
    var yt, Bt, gt = At.c, rt = At.e, Ce = At.s;
    e: if ({}.toString.call(gt) == "[object Array]") {
      if ((Ce === 1 || Ce === -1) && rt >= -1e9 && rt <= MAX && rt === mathfloor(rt)) {
        if (gt[0] === 0) {
          if (rt === 0 && gt.length === 1) return !0;
          break e;
        }
        if (yt = (rt + 1) % LOG_BASE, yt < 1 && (yt += LOG_BASE), String(gt[0]).length == yt) {
          for (yt = 0; yt < gt.length; yt++)
            if (Bt = gt[yt], Bt < 0 || Bt >= BASE || Bt !== mathfloor(Bt)) break e;
          if (Bt !== 0) return !0;
        }
      }
    } else if (gt === null && rt === null && (Ce === null || Ce === 1 || Ce === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + At);
  }, ct.maximum = ct.max = function() {
    return vt(arguments, -1);
  }, ct.minimum = ct.min = function() {
    return vt(arguments, 1);
  }, ct.random = function() {
    var At = 9007199254740992, yt = Math.random() * At & 2097151 ? function() {
      return mathfloor(Math.random() * At);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Bt) {
      var gt, rt, Ce, pe, nt, st = 0, ot = [], ht = new ct(W);
      if (Bt == null ? Bt = J : intCheck(Bt, 0, MAX), pe = mathceil(Bt / LOG_BASE), ke)
        if (crypto.getRandomValues) {
          for (gt = crypto.getRandomValues(new Uint32Array(pe *= 2)); st < pe; )
            nt = gt[st] * 131072 + (gt[st + 1] >>> 11), nt >= 9e15 ? (rt = crypto.getRandomValues(new Uint32Array(2)), gt[st] = rt[0], gt[st + 1] = rt[1]) : (ot.push(nt % 1e14), st += 2);
          st = pe / 2;
        } else if (crypto.randomBytes) {
          for (gt = crypto.randomBytes(pe *= 7); st < pe; )
            nt = (gt[st] & 31) * 281474976710656 + gt[st + 1] * 1099511627776 + gt[st + 2] * 4294967296 + gt[st + 3] * 16777216 + (gt[st + 4] << 16) + (gt[st + 5] << 8) + gt[st + 6], nt >= 9e15 ? crypto.randomBytes(7).copy(gt, st) : (ot.push(nt % 1e14), st += 7);
          st = pe / 7;
        } else
          throw ke = !1, Error(bignumberError + "crypto unavailable");
      if (!ke)
        for (; st < pe; )
          nt = yt(), nt < 9e15 && (ot[st++] = nt % 1e14);
      for (pe = ot[--st], Bt %= LOG_BASE, pe && Bt && (nt = POWS_TEN[LOG_BASE - Bt], ot[st] = mathfloor(pe / nt) * nt); ot[st] === 0; ot.pop(), st--) ;
      if (st < 0)
        ot = [Ce = 0];
      else {
        for (Ce = -1; ot[0] === 0; ot.splice(0, 1), Ce -= LOG_BASE) ;
        for (st = 1, nt = ot[0]; nt >= 10; nt /= 10, st++) ;
        st < LOG_BASE && (Ce -= LOG_BASE - st);
      }
      return ht.e = Ce, ht.c = ot, ht;
    };
  }(), ct.sum = function() {
    for (var At = 1, yt = arguments, Bt = new ct(yt[0]); At < yt.length; ) Bt = Bt.plus(yt[At++]);
    return Bt;
  }, L = /* @__PURE__ */ function() {
    var At = "0123456789";
    function yt(Bt, gt, rt, Ce) {
      for (var pe, nt = [0], st, ot = 0, ht = Bt.length; ot < ht; ) {
        for (st = nt.length; st--; nt[st] *= gt) ;
        for (nt[0] += Ce.indexOf(Bt.charAt(ot++)), pe = 0; pe < nt.length; pe++)
          nt[pe] > rt - 1 && (nt[pe + 1] == null && (nt[pe + 1] = 0), nt[pe + 1] += nt[pe] / rt | 0, nt[pe] %= rt);
      }
      return nt.reverse();
    }
    return function(Bt, gt, rt, Ce, pe) {
      var nt, st, ot, ht, pt, ft, mt, lt, St = Bt.indexOf("."), Ft = J, Gt = ne;
      for (St >= 0 && (ht = it, it = 0, Bt = Bt.replace(".", ""), lt = new ct(gt), ft = lt.pow(Bt.length - St), it = ht, lt.c = yt(
        toFixedPoint(coeffToString(ft.c), ft.e, "0"),
        10,
        rt,
        At
      ), lt.e = lt.c.length), mt = yt(Bt, gt, rt, pe ? (nt = ut, At) : (nt = At, ut)), ot = ht = mt.length; mt[--ht] == 0; mt.pop()) ;
      if (!mt[0]) return nt.charAt(0);
      if (St < 0 ? --ot : (ft.c = mt, ft.e = ot, ft.s = Ce, ft = B(ft, lt, Ft, Gt, rt), mt = ft.c, pt = ft.r, ot = ft.e), st = ot + Ft + 1, St = mt[st], ht = rt / 2, pt = pt || st < 0 || mt[st + 1] != null, pt = Gt < 4 ? (St != null || pt) && (Gt == 0 || Gt == (ft.s < 0 ? 3 : 2)) : St > ht || St == ht && (Gt == 4 || pt || Gt == 6 && mt[st - 1] & 1 || Gt == (ft.s < 0 ? 8 : 7)), st < 1 || !mt[0])
        Bt = pt ? toFixedPoint(nt.charAt(1), -Ft, nt.charAt(0)) : nt.charAt(0);
      else {
        if (mt.length = st, pt)
          for (--rt; ++mt[--st] > rt; )
            mt[st] = 0, st || (++ot, mt = [1].concat(mt));
        for (ht = mt.length; !mt[--ht]; ) ;
        for (St = 0, Bt = ""; St <= ht; Bt += nt.charAt(mt[St++])) ;
        Bt = toFixedPoint(Bt, ot, nt.charAt(0));
      }
      return Bt;
    };
  }(), B = /* @__PURE__ */ function() {
    function At(gt, rt, Ce) {
      var pe, nt, st, ot, ht = 0, pt = gt.length, ft = rt % SQRT_BASE, mt = rt / SQRT_BASE | 0;
      for (gt = gt.slice(); pt--; )
        st = gt[pt] % SQRT_BASE, ot = gt[pt] / SQRT_BASE | 0, pe = mt * st + ot * ft, nt = ft * st + pe % SQRT_BASE * SQRT_BASE + ht, ht = (nt / Ce | 0) + (pe / SQRT_BASE | 0) + mt * ot, gt[pt] = nt % Ce;
      return ht && (gt = [ht].concat(gt)), gt;
    }
    function yt(gt, rt, Ce, pe) {
      var nt, st;
      if (Ce != pe)
        st = Ce > pe ? 1 : -1;
      else
        for (nt = st = 0; nt < Ce; nt++)
          if (gt[nt] != rt[nt]) {
            st = gt[nt] > rt[nt] ? 1 : -1;
            break;
          }
      return st;
    }
    function Bt(gt, rt, Ce, pe) {
      for (var nt = 0; Ce--; )
        gt[Ce] -= nt, nt = gt[Ce] < rt[Ce] ? 1 : 0, gt[Ce] = nt * pe + gt[Ce] - rt[Ce];
      for (; !gt[0] && gt.length > 1; gt.splice(0, 1)) ;
    }
    return function(gt, rt, Ce, pe, nt) {
      var st, ot, ht, pt, ft, mt, lt, St, Ft, Gt, qt, Pt, Tt, Ut, Wt, It, Rt, jt = gt.s == rt.s ? 1 : -1, Jt = gt.c, er = rt.c;
      if (!Jt || !Jt[0] || !er || !er[0])
        return new ct(
          // Return NaN if either NaN, or both Infinity or 0.
          !gt.s || !rt.s || (Jt ? er && Jt[0] == er[0] : !er) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            Jt && Jt[0] == 0 || !er ? jt * 0 : jt / 0
          )
        );
      for (St = new ct(jt), Ft = St.c = [], ot = gt.e - rt.e, jt = Ce + ot + 1, nt || (nt = BASE, ot = bitFloor(gt.e / LOG_BASE) - bitFloor(rt.e / LOG_BASE), jt = jt / LOG_BASE | 0), ht = 0; er[ht] == (Jt[ht] || 0); ht++) ;
      if (er[ht] > (Jt[ht] || 0) && ot--, jt < 0)
        Ft.push(1), pt = !0;
      else {
        for (Ut = Jt.length, It = er.length, ht = 0, jt += 2, ft = mathfloor(nt / (er[0] + 1)), ft > 1 && (er = At(er, ft, nt), Jt = At(Jt, ft, nt), It = er.length, Ut = Jt.length), Tt = It, Gt = Jt.slice(0, It), qt = Gt.length; qt < It; Gt[qt++] = 0) ;
        Rt = er.slice(), Rt = [0].concat(Rt), Wt = er[0], er[1] >= nt / 2 && Wt++;
        do {
          if (ft = 0, st = yt(er, Gt, It, qt), st < 0) {
            if (Pt = Gt[0], It != qt && (Pt = Pt * nt + (Gt[1] || 0)), ft = mathfloor(Pt / Wt), ft > 1)
              for (ft >= nt && (ft = nt - 1), mt = At(er, ft, nt), lt = mt.length, qt = Gt.length; yt(mt, Gt, lt, qt) == 1; )
                ft--, Bt(mt, It < lt ? Rt : er, lt, nt), lt = mt.length, st = 1;
            else
              ft == 0 && (st = ft = 1), mt = er.slice(), lt = mt.length;
            if (lt < qt && (mt = [0].concat(mt)), Bt(Gt, mt, qt, nt), qt = Gt.length, st == -1)
              for (; yt(er, Gt, It, qt) < 1; )
                ft++, Bt(Gt, It < qt ? Rt : er, qt, nt), qt = Gt.length;
          } else st === 0 && (ft++, Gt = [0]);
          Ft[ht++] = ft, Gt[0] ? Gt[qt++] = Jt[Tt] || 0 : (Gt = [Jt[Tt]], qt = 1);
        } while ((Tt++ < Ut || Gt[0] != null) && jt--);
        pt = Gt[0] != null, Ft[0] || Ft.splice(0, 1);
      }
      if (nt == BASE) {
        for (ht = 1, jt = Ft[0]; jt >= 10; jt /= 10, ht++) ;
        xt(St, Ce + (St.e = ht + ot * LOG_BASE - 1) + 1, pe, pt);
      } else
        St.e = ot, St.r = +pt;
      return St;
    };
  }();
  function bt(At, yt, Bt, gt) {
    var rt, Ce, pe, nt, st;
    if (Bt == null ? Bt = ne : intCheck(Bt, 0, 8), !At.c) return At.toString();
    if (rt = At.c[0], pe = At.e, yt == null)
      st = coeffToString(At.c), st = gt == 1 || gt == 2 && (pe <= ie || pe >= ce) ? toExponential(st, pe) : toFixedPoint(st, pe, "0");
    else if (At = xt(new ct(At), yt, Bt), Ce = At.e, st = coeffToString(At.c), nt = st.length, gt == 1 || gt == 2 && (yt <= Ce || Ce <= ie)) {
      for (; nt < yt; st += "0", nt++) ;
      st = toExponential(st, Ce);
    } else if (yt -= pe, st = toFixedPoint(st, Ce, "0"), Ce + 1 > nt) {
      if (--yt > 0) for (st += "."; yt--; st += "0") ;
    } else if (yt += Ce - nt, yt > 0)
      for (Ce + 1 == nt && (st += "."); yt--; st += "0") ;
    return At.s < 0 && rt ? "-" + st : st;
  }
  function vt(At, yt) {
    for (var Bt, gt, rt = 1, Ce = new ct(At[0]); rt < At.length; rt++)
      gt = new ct(At[rt]), (!gt.s || (Bt = compare(Ce, gt)) === yt || Bt === 0 && Ce.s === yt) && (Ce = gt);
    return Ce;
  }
  function $t(At, yt, Bt) {
    for (var gt = 1, rt = yt.length; !yt[--rt]; yt.pop()) ;
    for (rt = yt[0]; rt >= 10; rt /= 10, gt++) ;
    return (Bt = gt + Bt * LOG_BASE - 1) > oe ? At.c = At.e = null : Bt < re ? At.c = [At.e = 0] : (At.e = Bt, At.c = yt), At;
  }
  K = /* @__PURE__ */ function() {
    var At = /^(-?)0([xbo])(?=\w[\w.]*$)/i, yt = /^([^.]+)\.$/, Bt = /^\.([^.]+)$/, gt = /^-?(Infinity|NaN)$/, rt = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Ce, pe, nt, st) {
      var ot, ht = nt ? pe : pe.replace(rt, "");
      if (gt.test(ht))
        Ce.s = isNaN(ht) ? null : ht < 0 ? -1 : 1;
      else {
        if (!nt && (ht = ht.replace(At, function(pt, ft, mt) {
          return ot = (mt = mt.toLowerCase()) == "x" ? 16 : mt == "b" ? 2 : 8, !st || st == ot ? ft : pt;
        }), st && (ot = st, ht = ht.replace(yt, "$1").replace(Bt, "0.$1")), pe != ht))
          return new ct(ht, ot);
        if (ct.DEBUG)
          throw Error(bignumberError + "Not a" + (st ? " base " + st : "") + " number: " + pe);
        Ce.s = null;
      }
      Ce.c = Ce.e = null;
    };
  }();
  function xt(At, yt, Bt, gt) {
    var rt, Ce, pe, nt, st, ot, ht, pt = At.c, ft = POWS_TEN;
    if (pt) {
      e: {
        for (rt = 1, nt = pt[0]; nt >= 10; nt /= 10, rt++) ;
        if (Ce = yt - rt, Ce < 0)
          Ce += LOG_BASE, pe = yt, st = pt[ot = 0], ht = mathfloor(st / ft[rt - pe - 1] % 10);
        else if (ot = mathceil((Ce + 1) / LOG_BASE), ot >= pt.length)
          if (gt) {
            for (; pt.length <= ot; pt.push(0)) ;
            st = ht = 0, rt = 1, Ce %= LOG_BASE, pe = Ce - LOG_BASE + 1;
          } else
            break e;
        else {
          for (st = nt = pt[ot], rt = 1; nt >= 10; nt /= 10, rt++) ;
          Ce %= LOG_BASE, pe = Ce - LOG_BASE + rt, ht = pe < 0 ? 0 : mathfloor(st / ft[rt - pe - 1] % 10);
        }
        if (gt = gt || yt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        pt[ot + 1] != null || (pe < 0 ? st : st % ft[rt - pe - 1]), gt = Bt < 4 ? (ht || gt) && (Bt == 0 || Bt == (At.s < 0 ? 3 : 2)) : ht > 5 || ht == 5 && (Bt == 4 || gt || Bt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Ce > 0 ? pe > 0 ? st / ft[rt - pe] : 0 : pt[ot - 1]) % 10 & 1 || Bt == (At.s < 0 ? 8 : 7)), yt < 1 || !pt[0])
          return pt.length = 0, gt ? (yt -= At.e + 1, pt[0] = ft[(LOG_BASE - yt % LOG_BASE) % LOG_BASE], At.e = -yt || 0) : pt[0] = At.e = 0, At;
        if (Ce == 0 ? (pt.length = ot, nt = 1, ot--) : (pt.length = ot + 1, nt = ft[LOG_BASE - Ce], pt[ot] = pe > 0 ? mathfloor(st / ft[rt - pe] % ft[pe]) * nt : 0), gt)
          for (; ; )
            if (ot == 0) {
              for (Ce = 1, pe = pt[0]; pe >= 10; pe /= 10, Ce++) ;
              for (pe = pt[0] += nt, nt = 1; pe >= 10; pe /= 10, nt++) ;
              Ce != nt && (At.e++, pt[0] == BASE && (pt[0] = 1));
              break;
            } else {
              if (pt[ot] += nt, pt[ot] != BASE) break;
              pt[ot--] = 0, nt = 1;
            }
        for (Ce = pt.length; pt[--Ce] === 0; pt.pop()) ;
      }
      At.e > oe ? At.c = At.e = null : At.e < re && (At.c = [At.e = 0]);
    }
    return At;
  }
  function Ot(At) {
    var yt, Bt = At.e;
    return Bt === null ? At.toString() : (yt = coeffToString(At.c), yt = Bt <= ie || Bt >= ce ? toExponential(yt, Bt) : toFixedPoint(yt, Bt, "0"), At.s < 0 ? "-" + yt : yt);
  }
  return V.absoluteValue = V.abs = function() {
    var At = new ct(this);
    return At.s < 0 && (At.s = 1), At;
  }, V.comparedTo = function(At, yt) {
    return compare(this, new ct(At, yt));
  }, V.decimalPlaces = V.dp = function(At, yt) {
    var Bt, gt, rt, Ce = this;
    if (At != null)
      return intCheck(At, 0, MAX), yt == null ? yt = ne : intCheck(yt, 0, 8), xt(new ct(Ce), At + Ce.e + 1, yt);
    if (!(Bt = Ce.c)) return null;
    if (gt = ((rt = Bt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, rt = Bt[rt]) for (; rt % 10 == 0; rt /= 10, gt--) ;
    return gt < 0 && (gt = 0), gt;
  }, V.dividedBy = V.div = function(At, yt) {
    return B(this, new ct(At, yt), J, ne);
  }, V.dividedToIntegerBy = V.idiv = function(At, yt) {
    return B(this, new ct(At, yt), 0, 1);
  }, V.exponentiatedBy = V.pow = function(At, yt) {
    var Bt, gt, rt, Ce, pe, nt, st, ot, ht, pt = this;
    if (At = new ct(At), At.c && !At.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Ot(At));
    if (yt != null && (yt = new ct(yt)), nt = At.e > 14, !pt.c || !pt.c[0] || pt.c[0] == 1 && !pt.e && pt.c.length == 1 || !At.c || !At.c[0])
      return ht = new ct(Math.pow(+Ot(pt), nt ? At.s * (2 - isOdd(At)) : +Ot(At))), yt ? ht.mod(yt) : ht;
    if (st = At.s < 0, yt) {
      if (yt.c ? !yt.c[0] : !yt.s) return new ct(NaN);
      gt = !st && pt.isInteger() && yt.isInteger(), gt && (pt = pt.mod(yt));
    } else {
      if (At.e > 9 && (pt.e > 0 || pt.e < -1 || (pt.e == 0 ? pt.c[0] > 1 || nt && pt.c[1] >= 24e7 : pt.c[0] < 8e13 || nt && pt.c[0] <= 9999975e7)))
        return Ce = pt.s < 0 && isOdd(At) ? -0 : 0, pt.e > -1 && (Ce = 1 / Ce), new ct(st ? 1 / Ce : Ce);
      it && (Ce = mathceil(it / LOG_BASE + 2));
    }
    for (nt ? (Bt = new ct(0.5), st && (At.s = 1), ot = isOdd(At)) : (rt = Math.abs(+Ot(At)), ot = rt % 2), ht = new ct(W); ; ) {
      if (ot) {
        if (ht = ht.times(pt), !ht.c) break;
        Ce ? ht.c.length > Ce && (ht.c.length = Ce) : gt && (ht = ht.mod(yt));
      }
      if (rt) {
        if (rt = mathfloor(rt / 2), rt === 0) break;
        ot = rt % 2;
      } else if (At = At.times(Bt), xt(At, At.e + 1, 1), At.e > 14)
        ot = isOdd(At);
      else {
        if (rt = +Ot(At), rt === 0) break;
        ot = rt % 2;
      }
      pt = pt.times(pt), Ce ? pt.c && pt.c.length > Ce && (pt.c.length = Ce) : gt && (pt = pt.mod(yt));
    }
    return gt ? ht : (st && (ht = W.div(ht)), yt ? ht.mod(yt) : Ce ? xt(ht, it, ne, pe) : ht);
  }, V.integerValue = function(At) {
    var yt = new ct(this);
    return At == null ? At = ne : intCheck(At, 0, 8), xt(yt, yt.e + 1, At);
  }, V.isEqualTo = V.eq = function(At, yt) {
    return compare(this, new ct(At, yt)) === 0;
  }, V.isFinite = function() {
    return !!this.c;
  }, V.isGreaterThan = V.gt = function(At, yt) {
    return compare(this, new ct(At, yt)) > 0;
  }, V.isGreaterThanOrEqualTo = V.gte = function(At, yt) {
    return (yt = compare(this, new ct(At, yt))) === 1 || yt === 0;
  }, V.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, V.isLessThan = V.lt = function(At, yt) {
    return compare(this, new ct(At, yt)) < 0;
  }, V.isLessThanOrEqualTo = V.lte = function(At, yt) {
    return (yt = compare(this, new ct(At, yt))) === -1 || yt === 0;
  }, V.isNaN = function() {
    return !this.s;
  }, V.isNegative = function() {
    return this.s < 0;
  }, V.isPositive = function() {
    return this.s > 0;
  }, V.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, V.minus = function(At, yt) {
    var Bt, gt, rt, Ce, pe = this, nt = pe.s;
    if (At = new ct(At, yt), yt = At.s, !nt || !yt) return new ct(NaN);
    if (nt != yt)
      return At.s = -yt, pe.plus(At);
    var st = pe.e / LOG_BASE, ot = At.e / LOG_BASE, ht = pe.c, pt = At.c;
    if (!st || !ot) {
      if (!ht || !pt) return ht ? (At.s = -yt, At) : new ct(pt ? pe : NaN);
      if (!ht[0] || !pt[0])
        return pt[0] ? (At.s = -yt, At) : new ct(ht[0] ? pe : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ne == 3 ? -0 : 0
        ));
    }
    if (st = bitFloor(st), ot = bitFloor(ot), ht = ht.slice(), nt = st - ot) {
      for ((Ce = nt < 0) ? (nt = -nt, rt = ht) : (ot = st, rt = pt), rt.reverse(), yt = nt; yt--; rt.push(0)) ;
      rt.reverse();
    } else
      for (gt = (Ce = (nt = ht.length) < (yt = pt.length)) ? nt : yt, nt = yt = 0; yt < gt; yt++)
        if (ht[yt] != pt[yt]) {
          Ce = ht[yt] < pt[yt];
          break;
        }
    if (Ce && (rt = ht, ht = pt, pt = rt, At.s = -At.s), yt = (gt = pt.length) - (Bt = ht.length), yt > 0) for (; yt--; ht[Bt++] = 0) ;
    for (yt = BASE - 1; gt > nt; ) {
      if (ht[--gt] < pt[gt]) {
        for (Bt = gt; Bt && !ht[--Bt]; ht[Bt] = yt) ;
        --ht[Bt], ht[gt] += BASE;
      }
      ht[gt] -= pt[gt];
    }
    for (; ht[0] == 0; ht.splice(0, 1), --ot) ;
    return ht[0] ? $t(At, ht, ot) : (At.s = ne == 3 ? -1 : 1, At.c = [At.e = 0], At);
  }, V.modulo = V.mod = function(At, yt) {
    var Bt, gt, rt = this;
    return At = new ct(At, yt), !rt.c || !At.s || At.c && !At.c[0] ? new ct(NaN) : !At.c || rt.c && !rt.c[0] ? new ct(rt) : (Oe == 9 ? (gt = At.s, At.s = 1, Bt = B(rt, At, 0, 3), At.s = gt, Bt.s *= gt) : Bt = B(rt, At, 0, Oe), At = rt.minus(Bt.times(At)), !At.c[0] && Oe == 1 && (At.s = rt.s), At);
  }, V.multipliedBy = V.times = function(At, yt) {
    var Bt, gt, rt, Ce, pe, nt, st, ot, ht, pt, ft, mt, lt, St, Ft, Gt = this, qt = Gt.c, Pt = (At = new ct(At, yt)).c;
    if (!qt || !Pt || !qt[0] || !Pt[0])
      return !Gt.s || !At.s || qt && !qt[0] && !Pt || Pt && !Pt[0] && !qt ? At.c = At.e = At.s = null : (At.s *= Gt.s, !qt || !Pt ? At.c = At.e = null : (At.c = [0], At.e = 0)), At;
    for (gt = bitFloor(Gt.e / LOG_BASE) + bitFloor(At.e / LOG_BASE), At.s *= Gt.s, st = qt.length, pt = Pt.length, st < pt && (lt = qt, qt = Pt, Pt = lt, rt = st, st = pt, pt = rt), rt = st + pt, lt = []; rt--; lt.push(0)) ;
    for (St = BASE, Ft = SQRT_BASE, rt = pt; --rt >= 0; ) {
      for (Bt = 0, ft = Pt[rt] % Ft, mt = Pt[rt] / Ft | 0, pe = st, Ce = rt + pe; Ce > rt; )
        ot = qt[--pe] % Ft, ht = qt[pe] / Ft | 0, nt = mt * ot + ht * ft, ot = ft * ot + nt % Ft * Ft + lt[Ce] + Bt, Bt = (ot / St | 0) + (nt / Ft | 0) + mt * ht, lt[Ce--] = ot % St;
      lt[Ce] = Bt;
    }
    return Bt ? ++gt : lt.splice(0, 1), $t(At, lt, gt);
  }, V.negated = function() {
    var At = new ct(this);
    return At.s = -At.s || null, At;
  }, V.plus = function(At, yt) {
    var Bt, gt = this, rt = gt.s;
    if (At = new ct(At, yt), yt = At.s, !rt || !yt) return new ct(NaN);
    if (rt != yt)
      return At.s = -yt, gt.minus(At);
    var Ce = gt.e / LOG_BASE, pe = At.e / LOG_BASE, nt = gt.c, st = At.c;
    if (!Ce || !pe) {
      if (!nt || !st) return new ct(rt / 0);
      if (!nt[0] || !st[0]) return st[0] ? At : new ct(nt[0] ? gt : rt * 0);
    }
    if (Ce = bitFloor(Ce), pe = bitFloor(pe), nt = nt.slice(), rt = Ce - pe) {
      for (rt > 0 ? (pe = Ce, Bt = st) : (rt = -rt, Bt = nt), Bt.reverse(); rt--; Bt.push(0)) ;
      Bt.reverse();
    }
    for (rt = nt.length, yt = st.length, rt - yt < 0 && (Bt = st, st = nt, nt = Bt, yt = rt), rt = 0; yt; )
      rt = (nt[--yt] = nt[yt] + st[yt] + rt) / BASE | 0, nt[yt] = BASE === nt[yt] ? 0 : nt[yt] % BASE;
    return rt && (nt = [rt].concat(nt), ++pe), $t(At, nt, pe);
  }, V.precision = V.sd = function(At, yt) {
    var Bt, gt, rt, Ce = this;
    if (At != null && At !== !!At)
      return intCheck(At, 1, MAX), yt == null ? yt = ne : intCheck(yt, 0, 8), xt(new ct(Ce), At, yt);
    if (!(Bt = Ce.c)) return null;
    if (rt = Bt.length - 1, gt = rt * LOG_BASE + 1, rt = Bt[rt]) {
      for (; rt % 10 == 0; rt /= 10, gt--) ;
      for (rt = Bt[0]; rt >= 10; rt /= 10, gt++) ;
    }
    return At && Ce.e + 1 > gt && (gt = Ce.e + 1), gt;
  }, V.shiftedBy = function(At) {
    return intCheck(At, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + At);
  }, V.squareRoot = V.sqrt = function() {
    var At, yt, Bt, gt, rt, Ce = this, pe = Ce.c, nt = Ce.s, st = Ce.e, ot = J + 4, ht = new ct("0.5");
    if (nt !== 1 || !pe || !pe[0])
      return new ct(!nt || nt < 0 && (!pe || pe[0]) ? NaN : pe ? Ce : 1 / 0);
    if (nt = Math.sqrt(+Ot(Ce)), nt == 0 || nt == 1 / 0 ? (yt = coeffToString(pe), (yt.length + st) % 2 == 0 && (yt += "0"), nt = Math.sqrt(+yt), st = bitFloor((st + 1) / 2) - (st < 0 || st % 2), nt == 1 / 0 ? yt = "5e" + st : (yt = nt.toExponential(), yt = yt.slice(0, yt.indexOf("e") + 1) + st), Bt = new ct(yt)) : Bt = new ct(nt + ""), Bt.c[0]) {
      for (st = Bt.e, nt = st + ot, nt < 3 && (nt = 0); ; )
        if (rt = Bt, Bt = ht.times(rt.plus(B(Ce, rt, ot, 1))), coeffToString(rt.c).slice(0, nt) === (yt = coeffToString(Bt.c)).slice(0, nt))
          if (Bt.e < st && --nt, yt = yt.slice(nt - 3, nt + 1), yt == "9999" || !gt && yt == "4999") {
            if (!gt && (xt(rt, rt.e + J + 2, 0), rt.times(rt).eq(Ce))) {
              Bt = rt;
              break;
            }
            ot += 4, nt += 4, gt = 1;
          } else {
            (!+yt || !+yt.slice(1) && yt.charAt(0) == "5") && (xt(Bt, Bt.e + J + 2, 1), At = !Bt.times(Bt).eq(Ce));
            break;
          }
    }
    return xt(Bt, Bt.e + J + 1, ne, At);
  }, V.toExponential = function(At, yt) {
    return At != null && (intCheck(At, 0, MAX), At++), bt(this, At, yt, 1);
  }, V.toFixed = function(At, yt) {
    return At != null && (intCheck(At, 0, MAX), At = At + this.e + 1), bt(this, At, yt);
  }, V.toFormat = function(At, yt, Bt) {
    var gt, rt = this;
    if (Bt == null)
      At != null && yt && typeof yt == "object" ? (Bt = yt, yt = null) : At && typeof At == "object" ? (Bt = At, At = yt = null) : Bt = at;
    else if (typeof Bt != "object")
      throw Error(bignumberError + "Argument not an object: " + Bt);
    if (gt = rt.toFixed(At, yt), rt.c) {
      var Ce, pe = gt.split("."), nt = +Bt.groupSize, st = +Bt.secondaryGroupSize, ot = Bt.groupSeparator || "", ht = pe[0], pt = pe[1], ft = rt.s < 0, mt = ft ? ht.slice(1) : ht, lt = mt.length;
      if (st && (Ce = nt, nt = st, st = Ce, lt -= Ce), nt > 0 && lt > 0) {
        for (Ce = lt % nt || nt, ht = mt.substr(0, Ce); Ce < lt; Ce += nt) ht += ot + mt.substr(Ce, nt);
        st > 0 && (ht += ot + mt.slice(Ce)), ft && (ht = "-" + ht);
      }
      gt = pt ? ht + (Bt.decimalSeparator || "") + ((st = +Bt.fractionGroupSize) ? pt.replace(
        new RegExp("\\d{" + st + "}\\B", "g"),
        "$&" + (Bt.fractionGroupSeparator || "")
      ) : pt) : ht;
    }
    return (Bt.prefix || "") + gt + (Bt.suffix || "");
  }, V.toFraction = function(At) {
    var yt, Bt, gt, rt, Ce, pe, nt, st, ot, ht, pt, ft, mt = this, lt = mt.c;
    if (At != null && (nt = new ct(At), !nt.isInteger() && (nt.c || nt.s !== 1) || nt.lt(W)))
      throw Error(bignumberError + "Argument " + (nt.isInteger() ? "out of range: " : "not an integer: ") + Ot(nt));
    if (!lt) return new ct(mt);
    for (yt = new ct(W), ot = Bt = new ct(W), gt = st = new ct(W), ft = coeffToString(lt), Ce = yt.e = ft.length - mt.e - 1, yt.c[0] = POWS_TEN[(pe = Ce % LOG_BASE) < 0 ? LOG_BASE + pe : pe], At = !At || nt.comparedTo(yt) > 0 ? Ce > 0 ? yt : ot : nt, pe = oe, oe = 1 / 0, nt = new ct(ft), st.c[0] = 0; ht = B(nt, yt, 0, 1), rt = Bt.plus(ht.times(gt)), rt.comparedTo(At) != 1; )
      Bt = gt, gt = rt, ot = st.plus(ht.times(rt = ot)), st = rt, yt = nt.minus(ht.times(rt = yt)), nt = rt;
    return rt = B(At.minus(Bt), gt, 0, 1), st = st.plus(rt.times(ot)), Bt = Bt.plus(rt.times(gt)), st.s = ot.s = mt.s, Ce = Ce * 2, pt = B(ot, gt, Ce, ne).minus(mt).abs().comparedTo(
      B(st, Bt, Ce, ne).minus(mt).abs()
    ) < 1 ? [ot, gt] : [st, Bt], oe = pe, pt;
  }, V.toNumber = function() {
    return +Ot(this);
  }, V.toPrecision = function(At, yt) {
    return At != null && intCheck(At, 1, MAX), bt(this, At, yt, 2);
  }, V.toString = function(At) {
    var yt, Bt = this, gt = Bt.s, rt = Bt.e;
    return rt === null ? gt ? (yt = "Infinity", gt < 0 && (yt = "-" + yt)) : yt = "NaN" : (At == null ? yt = rt <= ie || rt >= ce ? toExponential(coeffToString(Bt.c), rt) : toFixedPoint(coeffToString(Bt.c), rt, "0") : At === 10 && dt ? (Bt = xt(new ct(Bt), J + rt + 1, ne), yt = toFixedPoint(coeffToString(Bt.c), Bt.e, "0")) : (intCheck(At, 2, ut.length, "Base"), yt = L(toFixedPoint(coeffToString(Bt.c), rt, "0"), 10, At, gt, !0)), gt < 0 && Bt.c[0] && (yt = "-" + yt)), yt;
  }, V.valueOf = V.toJSON = function() {
    return Ot(this);
  }, V._isBigNumber = !0, V[Symbol.toStringTag] = "BigNumber", V[Symbol.for("nodejs.util.inspect.custom")] = V.valueOf, A != null && ct.set(A), ct;
}
function bitFloor(A) {
  var B = A | 0;
  return A > 0 || A === B ? B : B - 1;
}
function coeffToString(A) {
  for (var B, L, K = 1, V = A.length, W = A[0] + ""; K < V; ) {
    for (B = A[K++] + "", L = LOG_BASE - B.length; L--; B = "0" + B) ;
    W += B;
  }
  for (V = W.length; W.charCodeAt(--V) === 48; ) ;
  return W.slice(0, V + 1 || 1);
}
function compare(A, B) {
  var L, K, V = A.c, W = B.c, J = A.s, ne = B.s, ie = A.e, ce = B.e;
  if (!J || !ne) return null;
  if (L = V && !V[0], K = W && !W[0], L || K) return L ? K ? 0 : -ne : J;
  if (J != ne) return J;
  if (L = J < 0, K = ie == ce, !V || !W) return K ? 0 : !V ^ L ? 1 : -1;
  if (!K) return ie > ce ^ L ? 1 : -1;
  for (ne = (ie = V.length) < (ce = W.length) ? ie : ce, J = 0; J < ne; J++) if (V[J] != W[J]) return V[J] > W[J] ^ L ? 1 : -1;
  return ie == ce ? 0 : ie > ce ^ L ? 1 : -1;
}
function intCheck(A, B, L, K) {
  if (A < B || A > L || A !== mathfloor(A))
    throw Error(bignumberError + (K || "Argument") + (typeof A == "number" ? A < B || A > L ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(A));
}
function isOdd(A) {
  var B = A.c.length - 1;
  return bitFloor(A.e / LOG_BASE) == B && A.c[B] % 2 != 0;
}
function toExponential(A, B) {
  return (A.length > 1 ? A.charAt(0) + "." + A.slice(1) : A) + (B < 0 ? "e" : "e+") + B;
}
function toFixedPoint(A, B, L) {
  var K, V;
  if (B < 0) {
    for (V = L + "."; ++B; V += L) ;
    A = V + A;
  } else if (K = A.length, ++B > K) {
    for (V = L, B -= K; --B; V += L) ;
    A += V;
  } else B < K && (A = A.slice(0, B) + "." + A.slice(B));
  return A;
}
var BigNumber = clone();
function useBalance() {
  const { network: A, publicKey: B, format: L } = useOrdConnect(), [K, V] = useState(null), [W, J] = useState(!1);
  return { getBalance: useCallback(async () => {
    J(!0);
    try {
      if (V(null), !L || !L.payments || !B || !B.payments)
        throw new Error("No wallet is connected");
      const { address: ie } = getAddressesFromPublicKey(
        B.payments,
        A,
        ADDRESS_FORMAT_TO_TYPE[L.payments]
      )[0], re = await new JsonRpcDatasource({ network: A }).getBalance({ address: ie }), oe = Number(
        new BigNumber(re).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return J(!1), oe;
    } catch (ie) {
      throw V(ie.message), J(!1), ie;
    }
  }, [L, A, B]), error: K, loading: W };
}
async function signPsbt({
  address: A,
  wallet: B,
  network: L,
  psbt: K,
  options: V
}) {
  var ie, ce;
  if ((ie = V == null ? void 0 : V.signingIndexes) != null && ie.length && ((ce = V == null ? void 0 : V.inputsToSign) != null && ce.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const W = (V == null ? void 0 : V.finalize) ?? !0, J = (V == null ? void 0 : V.extractTx) ?? !0, ne = () => K.data.inputs.map((re, oe) => oe);
  if (B === Wallet.MAGICEDEN)
    return await signPsbt$1(K, {
      network: L,
      inputsToSign: (V == null ? void 0 : V.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne(),
          sigHash: V == null ? void 0 : V.sigHash
        }
      ],
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.UNISAT)
    return await signPsbt$2(K, {
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.XVERSE)
    return await signPsbt$3(K, {
      network: L,
      inputsToSign: (V == null ? void 0 : V.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: V == null ? void 0 : V.sigHash
        }
      ],
      finalize: W,
      extractTx: J
    });
  if (B === Wallet.LEATHER)
    return await signPsbt$4(K, {
      network: L,
      finalize: W,
      extractTx: J,
      allowedSighash: V != null && V.sigHash ? [V == null ? void 0 : V.sigHash] : [],
      signAtIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne()
      // If signingIndexes is not provided, just sign everything
    });
  if (B === Wallet.OKX)
    return await signPsbt$5(K, {
      finalize: W,
      extractTx: J,
      network: L,
      inputsToSign: (V == null ? void 0 : V.inputsToSign) ?? [
        {
          address: A,
          signingIndexes: (V == null ? void 0 : V.signingIndexes) ?? ne(),
          // If signingIndexes is not provided, just sign everything
          sigHash: V == null ? void 0 : V.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: A, network: B, address: L, publicKey: K } = useOrdConnect(), [V, W] = useState(null), [J, ne] = useState(!1);
  return { send: useCallback(
    async (ce, re, oe, ke = !0) => {
      ne(!0);
      try {
        if (W(null), !L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const Oe = new PSBTBuilder({
          address: L.payments,
          feeRate: oe,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ce,
              value: re
            }
          ]
        });
        await Oe.prepare();
        const it = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: Oe.toPSBT()
        });
        if (ke) {
          const ut = await new JsonRpcDatasource({ network: B }).relay({ hex: it.hex });
          return ne(!1), ut;
        }
        return ne(!1), it.hex;
      } catch (Oe) {
        return W(Oe.message), ne(!1), null;
      }
    },
    [L, B, K, A]
  ), error: V, loading: J };
}
function useSendV2() {
  const { wallet: A, network: B, address: L, publicKey: K } = useOrdConnect(), [V, W] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ne,
      satoshis: ie,
      feeRate: ce,
      relay: re = !0,
      rbf: oe = !1
    }) => {
      W(!0);
      try {
        if (!L || !L.payments || !K || !K.payments || !A)
          throw new Error("No wallet is connected");
        const ke = new PSBTBuilder({
          address: L.payments,
          feeRate: ce,
          network: B,
          publicKey: K.payments,
          outputs: [
            {
              address: ne,
              value: ie
            }
          ]
        });
        ke.setRBF(oe), await ke.prepare();
        const Oe = await signPsbt({
          address: L.payments,
          wallet: A,
          network: B,
          psbt: ke.toPSBT()
        });
        if (re) {
          const at = await new JsonRpcDatasource({ network: B }).relay({ hex: Oe.hex });
          return W(!1), {
            txId: at
          };
        }
        return W(!1), {
          signedPsbtHex: Oe.hex
        };
      } catch (ke) {
        return W(!1), {
          error: ke.message
        };
      }
    },
    [L, B, K, A]
  ), isLoading: V };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(A) {
  if (A.length < 8 || A.length > 72 || A[0] !== 48 || A[1] !== A.length - 2 || A[2] !== 2) return !1;
  const B = A[3];
  if (B === 0 || 5 + B >= A.length || A[4 + B] !== 2) return !1;
  const L = A[5 + B];
  return !(L === 0 || 6 + B + L !== A.length || A[4] & 128 || B > 1 && A[4] === 0 && !(A[5] & 128) || A[B + 6] & 128 || L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128));
}
bip66.check = check$d;
function decode$h(A) {
  if (A.length < 8) throw new Error("DER sequence length is too short");
  if (A.length > 72) throw new Error("DER sequence length is too long");
  if (A[0] !== 48) throw new Error("Expected DER sequence");
  if (A[1] !== A.length - 2)
    throw new Error("DER sequence length is invalid");
  if (A[2] !== 2) throw new Error("Expected DER integer");
  const B = A[3];
  if (B === 0) throw new Error("R length is zero");
  if (5 + B >= A.length) throw new Error("R length is too long");
  if (A[4 + B] !== 2) throw new Error("Expected DER integer (2)");
  const L = A[5 + B];
  if (L === 0) throw new Error("S length is zero");
  if (6 + B + L !== A.length) throw new Error("S length is invalid");
  if (A[4] & 128) throw new Error("R value is negative");
  if (B > 1 && A[4] === 0 && !(A[5] & 128))
    throw new Error("R value excessively padded");
  if (A[B + 6] & 128) throw new Error("S value is negative");
  if (L > 1 && A[B + 6] === 0 && !(A[B + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: A.slice(4, 4 + B),
    s: A.slice(6 + B)
  };
}
bip66.decode = decode$h;
function encode$i(A, B) {
  const L = A.length, K = B.length;
  if (L === 0) throw new Error("R length is zero");
  if (K === 0) throw new Error("S length is zero");
  if (L > 33) throw new Error("R length is too long");
  if (K > 33) throw new Error("S length is too long");
  if (A[0] & 128) throw new Error("R value is negative");
  if (B[0] & 128) throw new Error("S value is negative");
  if (L > 1 && A[0] === 0 && !(A[1] & 128))
    throw new Error("R value excessively padded");
  if (K > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("S value excessively padded");
  const V = Buffer$1.allocUnsafe(6 + L + K);
  return V[0] = 48, V[1] = V.length - 2, V[2] = 2, V[3] = A.length, A.copy(V, 4), V[4 + L] = 2, V[5 + L] = B.length, B.copy(V, 6 + L), V;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const A of Object.keys(OPS$7)) {
  const B = OPS$7[A];
  REVERSE_OPS[B] = A;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(A) {
  return A < ops_1.OPS.OP_PUSHDATA1 ? 1 : A <= 255 ? 2 : A <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(A, B, L) {
  const K = encodingLength$2(B);
  return K === 1 ? A.writeUInt8(B, L) : K === 2 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA1, L), A.writeUInt8(B, L + 1)) : K === 3 ? (A.writeUInt8(ops_1.OPS.OP_PUSHDATA2, L), A.writeUInt16LE(B, L + 1)) : (A.writeUInt8(ops_1.OPS.OP_PUSHDATA4, L), A.writeUInt32LE(B, L + 1)), K;
}
push_data.encode = encode$h;
function decode$g(A, B) {
  const L = A.readUInt8(B);
  let K, V;
  if (L < ops_1.OPS.OP_PUSHDATA1)
    K = L, V = 1;
  else if (L === ops_1.OPS.OP_PUSHDATA1) {
    if (B + 2 > A.length) return null;
    K = A.readUInt8(B + 1), V = 2;
  } else if (L === ops_1.OPS.OP_PUSHDATA2) {
    if (B + 3 > A.length) return null;
    K = A.readUInt16LE(B + 1), V = 3;
  } else {
    if (B + 5 > A.length) return null;
    if (L !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    K = A.readUInt32LE(B + 1), V = 5;
  }
  return {
    opcode: L,
    number: K,
    size: V
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(A, B, L) {
  B = B || 4, L = L === void 0 ? !0 : L;
  const K = A.length;
  if (K === 0) return 0;
  if (K > B) throw new TypeError("Script number overflow");
  if (L && !(A[K - 1] & 127) && (K <= 1 || !(A[K - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (K === 5) {
    const W = A.readUInt32LE(0), J = A.readUInt8(4);
    return J & 128 ? -((J & -129) * 4294967296 + W) : J * 4294967296 + W;
  }
  let V = 0;
  for (let W = 0; W < K; ++W)
    V |= A[W] << 8 * W;
  return A[K - 1] & 128 ? -(V & ~(128 << 8 * (K - 1))) : V;
}
script_number.decode = decode$f;
function scriptNumSize(A) {
  return A > 2147483647 ? 5 : A > 8388607 ? 4 : A > 32767 ? 3 : A > 127 ? 2 : A > 0 ? 1 : 0;
}
function encode$g(A) {
  let B = Math.abs(A);
  const L = scriptNumSize(B), K = Buffer$1.allocUnsafe(L), V = A < 0;
  for (let W = 0; W < L; ++W)
    K.writeUInt8(B & 255, W), B >>= 8;
  return K[L - 1] & 128 ? K.writeUInt8(V ? 128 : 0, L - 1) : V && (K[L - 1] |= 128), K;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(A) {
    return A != null && A.constructor === Array;
  },
  Boolean: function(A) {
    return typeof A == "boolean";
  },
  Function: function(A) {
    return typeof A == "function";
  },
  Nil: function(A) {
    return A == null;
  },
  Number: function(A) {
    return typeof A == "number";
  },
  Object: function(A) {
    return typeof A == "object";
  },
  String: function(A) {
    return typeof A == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(A) {
    return A;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(A) {
  return A.name || A.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(A) {
  return native.Nil(A) ? "" : getTypeName(A.constructor);
}
function getValue(A) {
  return native.Function(A) ? "" : native.String(A) ? JSON.stringify(A) : A && native.Object(A) ? "" : A;
}
function captureStackTrace(A, B) {
  Error.captureStackTrace && Error.captureStackTrace(A, B);
}
function tfJSON$1(A) {
  return native.Function(A) ? A.toJSON ? A.toJSON() : getTypeName(A) : native.Array(A) ? "Array" : A && native.Object(A) ? "Object" : A !== void 0 ? A : "";
}
function tfErrorString(A, B, L) {
  var K = getValue(B);
  return "Expected " + tfJSON$1(A) + ", got" + (L !== "" ? " " + L : "") + (K !== "" ? " " + K : "");
}
function TfTypeError$1(A, B, L) {
  L = L || getValueTypeName$1(B), this.message = tfErrorString(A, B, L), captureStackTrace(this, TfTypeError$1), this.__type = A, this.__value = B, this.__valueTypeName = L;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(A, B, L, K, V) {
  var W = '" of type ';
  return B === "key" && (W = '" with key type '), tfErrorString('property "' + tfJSON$1(L) + W + tfJSON$1(A), K, V);
}
function TfPropertyTypeError$1(A, B, L, K, V) {
  A ? (V = V || getValueTypeName$1(K), this.message = tfPropertyErrorString(A, L, B, K, V)) : this.message = 'Unexpected property "' + B + '"', captureStackTrace(this, TfTypeError$1), this.__label = L, this.__property = B, this.__type = A, this.__value = K, this.__valueTypeName = V;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(A, B) {
  return new TfTypeError$1(A, {}, B);
}
function tfSubError$1(A, B, L) {
  return A instanceof TfPropertyTypeError$1 ? (B = B + "." + A.__property, A = new TfPropertyTypeError$1(
    A.__type,
    B,
    A.__label,
    A.__value,
    A.__valueTypeName
  )) : A instanceof TfTypeError$1 && (A = new TfPropertyTypeError$1(
    A.__type,
    B,
    L,
    A.__value,
    A.__valueTypeName
  )), captureStackTrace(A), A;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var A = native$1, B = errors;
  function L(xt) {
    return Buffer$1.isBuffer(xt);
  }
  function K(xt) {
    return typeof xt == "string" && /^([0-9a-f]{2})+$/i.test(xt);
  }
  function V(xt, Ot) {
    var At = xt.toJSON();
    function yt(Bt) {
      if (!xt(Bt)) return !1;
      if (Bt.length === Ot) return !0;
      throw B.tfCustomError(At + "(Length: " + Ot + ")", At + "(Length: " + Bt.length + ")");
    }
    return yt.toJSON = function() {
      return At;
    }, yt;
  }
  var W = V.bind(null, A.Array), J = V.bind(null, L), ne = V.bind(null, K), ie = V.bind(null, A.String);
  function ce(xt, Ot, At) {
    At = At || A.Number;
    function yt(Bt, gt) {
      return At(Bt, gt) && Bt > xt && Bt < Ot;
    }
    return yt.toJSON = function() {
      return `${At.toJSON()} between [${xt}, ${Ot}]`;
    }, yt;
  }
  var re = Math.pow(2, 53) - 1;
  function oe(xt) {
    return typeof xt == "number" && isFinite(xt);
  }
  function ke(xt) {
    return xt << 24 >> 24 === xt;
  }
  function Oe(xt) {
    return xt << 16 >> 16 === xt;
  }
  function it(xt) {
    return (xt | 0) === xt;
  }
  function at(xt) {
    return typeof xt == "number" && xt >= -re && xt <= re && Math.floor(xt) === xt;
  }
  function ut(xt) {
    return (xt & 255) === xt;
  }
  function dt(xt) {
    return (xt & 65535) === xt;
  }
  function ct(xt) {
    return xt >>> 0 === xt;
  }
  function bt(xt) {
    return typeof xt == "number" && xt >= 0 && xt <= re && Math.floor(xt) === xt;
  }
  var vt = {
    ArrayN: W,
    Buffer: L,
    BufferN: J,
    Finite: oe,
    Hex: K,
    HexN: ne,
    Int8: ke,
    Int16: Oe,
    Int32: it,
    Int53: at,
    Range: ce,
    StringN: ie,
    UInt8: ut,
    UInt16: dt,
    UInt32: ct,
    UInt53: bt
  };
  for (var $t in vt)
    vt[$t].toJSON = (function(xt) {
      return xt;
    }).bind(null, $t);
  return extra = vt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function A(B, L) {
    B = compile(B), L = L || {};
    function K(V, W) {
      return !NATIVE.Array(V) || NATIVE.Nil(V) || L.minLength !== void 0 && V.length < L.minLength || L.maxLength !== void 0 && V.length > L.maxLength || L.length !== void 0 && V.length !== L.length ? !1 : V.every(function(J, ne) {
        try {
          return typeforce$3(B, J, W);
        } catch (ie) {
          throw tfSubError(ie, ne);
        }
      });
    }
    return K.toJSON = function() {
      var V = "[" + tfJSON(B) + "]";
      return L.length !== void 0 ? V += "{" + L.length + "}" : (L.minLength !== void 0 || L.maxLength !== void 0) && (V += "{" + (L.minLength === void 0 ? 0 : L.minLength) + "," + (L.maxLength === void 0 ? 1 / 0 : L.maxLength) + "}"), V;
    }, K;
  },
  maybe: function A(B) {
    B = compile(B);
    function L(K, V) {
      return NATIVE.Nil(K) || B(K, V, A);
    }
    return L.toJSON = function() {
      return "?" + tfJSON(B);
    }, L;
  },
  map: function A(B, L) {
    B = compile(B), L && (L = compile(L));
    function K(V, W) {
      if (!NATIVE.Object(V) || NATIVE.Nil(V)) return !1;
      for (var J in V) {
        try {
          L && typeforce$3(L, J, W);
        } catch (ie) {
          throw tfSubError(ie, J, "key");
        }
        try {
          var ne = V[J];
          typeforce$3(B, ne, W);
        } catch (ie) {
          throw tfSubError(ie, J);
        }
      }
      return !0;
    }
    return L ? K.toJSON = function() {
      return "{" + tfJSON(L) + ": " + tfJSON(B) + "}";
    } : K.toJSON = function() {
      return "{" + tfJSON(B) + "}";
    }, K;
  },
  object: function A(B) {
    var L = {};
    for (var K in B)
      L[K] = compile(B[K]);
    function V(W, J) {
      if (!NATIVE.Object(W) || NATIVE.Nil(W)) return !1;
      var ne;
      try {
        for (ne in L) {
          var ie = L[ne], ce = W[ne];
          typeforce$3(ie, ce, J);
        }
      } catch (re) {
        throw tfSubError(re, ne);
      }
      if (J) {
        for (ne in W)
          if (!L[ne])
            throw new TfPropertyTypeError(void 0, ne);
      }
      return !0;
    }
    return V.toJSON = function() {
      return tfJSON(L);
    }, V;
  },
  anyOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, V) {
      return B.some(function(W) {
        try {
          return typeforce$3(W, K, V);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join("|");
    }, L;
  },
  allOf: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, V) {
      return B.every(function(W) {
        try {
          return typeforce$3(W, K, V);
        } catch {
          return !1;
        }
      });
    }
    return L.toJSON = function() {
      return B.map(tfJSON).join(" & ");
    }, L;
  },
  quacksLike: function A(B) {
    function L(K) {
      return B === getValueTypeName(K);
    }
    return L.toJSON = function() {
      return B;
    }, L;
  },
  tuple: function A() {
    var B = [].slice.call(arguments).map(compile);
    function L(K, V) {
      return NATIVE.Nil(K) || NATIVE.Nil(K.length) || V && K.length !== B.length ? !1 : B.every(function(W, J) {
        try {
          return typeforce$3(W, K[J], V);
        } catch (ne) {
          throw tfSubError(ne, J);
        }
      });
    }
    return L.toJSON = function() {
      return "(" + B.map(tfJSON).join(", ") + ")";
    }, L;
  },
  value: function A(B) {
    function L(K) {
      return K === B;
    }
    return L.toJSON = function() {
      return B;
    }, L;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(A) {
  if (NATIVE.String(A))
    return A[0] === "?" ? TYPES.maybe(A.slice(1)) : NATIVE[A] || TYPES.quacksLike(A);
  if (A && NATIVE.Object(A)) {
    if (NATIVE.Array(A)) {
      if (A.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(A[0]);
    }
    return TYPES.object(A);
  } else if (NATIVE.Function(A))
    return A;
  return TYPES.value(A);
}
function typeforce$3(A, B, L, K) {
  if (NATIVE.Function(A)) {
    if (A(B, L)) return !0;
    throw new TfTypeError(K || A, B);
  }
  return typeforce$3(compile(A), B, L);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.oneOf = A.Null = A.BufferN = A.Function = A.UInt32 = A.UInt8 = A.tuple = A.maybe = A.Hex = A.Buffer = A.String = A.Boolean = A.Array = A.Number = A.Hash256bit = A.Hash160bit = A.Buffer256bit = A.isTaptree = A.isTapleaf = A.TAPLEAF_VERSION_MASK = A.Satoshi = A.isPoint = A.stacksEqual = A.typeforce = void 0;
  const B = require$$0$1;
  A.typeforce = typeforce_1;
  const L = B.Buffer.alloc(32, 0), K = B.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function V(re, oe) {
    return re.length !== oe.length ? !1 : re.every((ke, Oe) => ke.equals(oe[Oe]));
  }
  A.stacksEqual = V;
  function W(re) {
    if (!B.Buffer.isBuffer(re) || re.length < 33) return !1;
    const oe = re[0], ke = re.slice(1, 33);
    if (ke.compare(L) === 0 || ke.compare(K) >= 0) return !1;
    if ((oe === 2 || oe === 3) && re.length === 33)
      return !0;
    const Oe = re.slice(33);
    return Oe.compare(L) === 0 || Oe.compare(K) >= 0 ? !1 : oe === 4 && re.length === 65;
  }
  A.isPoint = W;
  const J = 21 * 1e14;
  function ne(re) {
    return A.typeforce.UInt53(re) && re <= J;
  }
  A.Satoshi = ne, A.TAPLEAF_VERSION_MASK = 254;
  function ie(re) {
    return !re || !("output" in re) || !B.Buffer.isBuffer(re.output) ? !1 : re.version !== void 0 ? (re.version & A.TAPLEAF_VERSION_MASK) === re.version : !0;
  }
  A.isTapleaf = ie;
  function ce(re) {
    return (0, A.Array)(re) ? re.length !== 2 ? !1 : re.every((oe) => ce(oe)) : ie(re);
  }
  A.isTaptree = ce, A.Buffer256bit = A.typeforce.BufferN(32), A.Hash160bit = A.typeforce.BufferN(20), A.Hash256bit = A.typeforce.BufferN(32), A.Number = A.typeforce.Number, A.Array = A.typeforce.Array, A.Boolean = A.typeforce.Boolean, A.String = A.typeforce.String, A.Buffer = A.typeforce.Buffer, A.Hex = A.typeforce.Hex, A.maybe = A.typeforce.maybe, A.tuple = A.typeforce.tuple, A.UInt8 = A.typeforce.UInt8, A.UInt32 = A.typeforce.UInt32, A.Function = A.typeforce.Function, A.BufferN = A.typeforce.BufferN, A.Null = A.typeforce.Null, A.oneOf = A.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const A = bip66, B = requireScript(), L = types$4, { typeforce: K } = L, V = Buffer$1.alloc(1, 0);
  function W(ce) {
    let re = 0;
    for (; ce[re] === 0; ) ++re;
    return re === ce.length ? V : (ce = ce.slice(re), ce[0] & 128 ? Buffer$1.concat([V, ce], 1 + ce.length) : ce);
  }
  function J(ce) {
    ce[0] === 0 && (ce = ce.slice(1));
    const re = Buffer$1.alloc(32, 0), oe = Math.max(0, 32 - ce.length);
    return ce.copy(re, oe), re;
  }
  function ne(ce) {
    const re = ce.readUInt8(ce.length - 1);
    if (!(0, B.isDefinedHashType)(re))
      throw new Error("Invalid hashType " + re);
    const oe = A.decode(ce.slice(0, -1)), ke = J(oe.r), Oe = J(oe.s);
    return { signature: Buffer$1.concat([ke, Oe], 64), hashType: re };
  }
  script_signature.decode = ne;
  function ie(ce, re) {
    if (K(
      {
        signature: L.BufferN(64),
        hashType: L.UInt8
      },
      { signature: ce, hashType: re }
    ), !(0, B.isDefinedHashType)(re))
      throw new Error("Invalid hashType " + re);
    const oe = Buffer$1.allocUnsafe(1);
    oe.writeUInt8(re, 0);
    const ke = W(ce.slice(0, 32)), Oe = W(ce.slice(32, 64));
    return Buffer$1.concat([A.encode(ke, Oe), oe]);
  }
  return script_signature.encode = ie, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.signature = A.number = A.isCanonicalScriptSignature = A.isDefinedHashType = A.isCanonicalPubKey = A.toStack = A.fromASM = A.toASM = A.decompile = A.compile = A.countNonPushOnlyOPs = A.isPushOnly = A.OPS = void 0;
    const B = bip66, L = ops;
    Object.defineProperty(A, "OPS", {
      enumerable: !0,
      get: function() {
        return L.OPS;
      }
    });
    const K = push_data, V = script_number, W = requireScript_signature(), J = types$4, { typeforce: ne } = J, ie = L.OPS.OP_RESERVED;
    function ce(yt) {
      return J.Number(yt) && (yt === L.OPS.OP_0 || yt >= L.OPS.OP_1 && yt <= L.OPS.OP_16 || yt === L.OPS.OP_1NEGATE);
    }
    function re(yt) {
      return J.Buffer(yt) || ce(yt);
    }
    function oe(yt) {
      return J.Array(yt) && yt.every(re);
    }
    A.isPushOnly = oe;
    function ke(yt) {
      return yt.length - yt.filter(re).length;
    }
    A.countNonPushOnlyOPs = ke;
    function Oe(yt) {
      if (yt.length === 0) return L.OPS.OP_0;
      if (yt.length === 1) {
        if (yt[0] >= 1 && yt[0] <= 16) return ie + yt[0];
        if (yt[0] === 129) return L.OPS.OP_1NEGATE;
      }
    }
    function it(yt) {
      return Buffer$1.isBuffer(yt);
    }
    function at(yt) {
      return J.Array(yt);
    }
    function ut(yt) {
      return Buffer$1.isBuffer(yt);
    }
    function dt(yt) {
      if (it(yt)) return yt;
      ne(J.Array, yt);
      const Bt = yt.reduce((Ce, pe) => ut(pe) ? pe.length === 1 && Oe(pe) !== void 0 ? Ce + 1 : Ce + K.encodingLength(pe.length) + pe.length : Ce + 1, 0), gt = Buffer$1.allocUnsafe(Bt);
      let rt = 0;
      if (yt.forEach((Ce) => {
        if (ut(Ce)) {
          const pe = Oe(Ce);
          if (pe !== void 0) {
            gt.writeUInt8(pe, rt), rt += 1;
            return;
          }
          rt += K.encode(gt, Ce.length, rt), Ce.copy(gt, rt), rt += Ce.length;
        } else
          gt.writeUInt8(Ce, rt), rt += 1;
      }), rt !== gt.length) throw new Error("Could not decode chunks");
      return gt;
    }
    A.compile = dt;
    function ct(yt) {
      if (at(yt)) return yt;
      ne(J.Buffer, yt);
      const Bt = [];
      let gt = 0;
      for (; gt < yt.length; ) {
        const rt = yt[gt];
        if (rt > L.OPS.OP_0 && rt <= L.OPS.OP_PUSHDATA4) {
          const Ce = K.decode(yt, gt);
          if (Ce === null || (gt += Ce.size, gt + Ce.number > yt.length)) return null;
          const pe = yt.slice(gt, gt + Ce.number);
          gt += Ce.number;
          const nt = Oe(pe);
          nt !== void 0 ? Bt.push(nt) : Bt.push(pe);
        } else
          Bt.push(rt), gt += 1;
      }
      return Bt;
    }
    A.decompile = ct;
    function bt(yt) {
      if (it(yt) && (yt = ct(yt)), !yt)
        throw new Error("Could not convert invalid chunks to ASM");
      return yt.map((Bt) => {
        if (ut(Bt)) {
          const gt = Oe(Bt);
          if (gt === void 0) return Bt.toString("hex");
          Bt = gt;
        }
        return L.REVERSE_OPS[Bt];
      }).join(" ");
    }
    A.toASM = bt;
    function vt(yt) {
      return ne(J.String, yt), dt(
        yt.split(" ").map((Bt) => L.OPS[Bt] !== void 0 ? L.OPS[Bt] : (ne(J.Hex, Bt), Buffer$1.from(Bt, "hex")))
      );
    }
    A.fromASM = vt;
    function $t(yt) {
      return yt = ct(yt), ne(oe, yt), yt.map((Bt) => ut(Bt) ? Bt : Bt === L.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : V.encode(Bt - ie));
    }
    A.toStack = $t;
    function xt(yt) {
      return J.isPoint(yt);
    }
    A.isCanonicalPubKey = xt;
    function Ot(yt) {
      const Bt = yt & -129;
      return Bt > 0 && Bt < 4;
    }
    A.isDefinedHashType = Ot;
    function At(yt) {
      return !Buffer$1.isBuffer(yt) || !Ot(yt[yt.length - 1]) ? !1 : B.check(yt.slice(0, -1));
    }
    A.isCanonicalScriptSignature = At, A.number = V, A.signature = W;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(A, B, L) {
  Object.defineProperty(A, B, {
    configurable: !0,
    enumerable: !0,
    get() {
      const K = L.call(this);
      return this[B] = K, K;
    },
    set(K) {
      Object.defineProperty(this, B, {
        configurable: !0,
        enumerable: !0,
        value: K,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(A) {
  let B;
  return () => (B !== void 0 || (B = A()), B);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(A, B) {
  if (!A.data && !A.output) throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    A
  );
  const K = { name: "embed", network: A.network || networks_1$7.bitcoin };
  if (lazy$6.prop(K, "output", () => {
    if (A.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(A.data));
  }), lazy$6.prop(K, "data", () => {
    if (A.output)
      return bscript$9.decompile(A.output).slice(1);
  }), B.validate && A.output) {
    const V = bscript$9.decompile(A.output);
    if (V[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!V.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (A.data && !(0, types_1$7.stacksEqual)(A.data, K.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(K, A);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(A, B) {
  if (!A.input && !A.output && !(A.pubkeys && A.m !== void 0) && !A.signatures)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {});
  function L(ie) {
    return bscript$8.isCanonicalScriptSignature(ie) || (B.allowIncomplete && ie === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(L)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    A
  );
  const V = { network: A.network || networks_1$6.bitcoin };
  let W = [], J = !1;
  function ne(ie) {
    J || (J = !0, W = bscript$8.decompile(ie), V.m = W[0] - OP_INT_BASE, V.n = W[W.length - 2] - OP_INT_BASE, V.pubkeys = W.slice(1, -2));
  }
  if (lazy$5.prop(V, "output", () => {
    if (A.m && V.n && A.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + A.m,
          A.pubkeys,
          OP_INT_BASE + V.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(V, "m", () => {
    if (V.output)
      return ne(V.output), V.m;
  }), lazy$5.prop(V, "n", () => {
    if (V.pubkeys)
      return V.pubkeys.length;
  }), lazy$5.prop(V, "pubkeys", () => {
    if (A.output)
      return ne(A.output), V.pubkeys;
  }), lazy$5.prop(V, "signatures", () => {
    if (A.input)
      return bscript$8.decompile(A.input).slice(1);
  }), lazy$5.prop(V, "input", () => {
    if (A.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(A.signatures));
  }), lazy$5.prop(V, "witness", () => {
    if (V.input)
      return [];
  }), lazy$5.prop(V, "name", () => {
    if (!(!V.m || !V.n))
      return `p2ms(${V.m} of ${V.n})`;
  }), B.validate) {
    if (A.output) {
      if (ne(A.output), !types_1$6.typeforce.Number(W[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(W[W.length - 2]))
        throw new TypeError("Output is invalid");
      if (W[W.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (V.m <= 0 || V.n > 16 || V.m > V.n || V.n !== W.length - 3)
        throw new TypeError("Output is invalid");
      if (!V.pubkeys.every((ie) => (0, types_1$6.isPoint)(ie)))
        throw new TypeError("Output is invalid");
      if (A.m !== void 0 && A.m !== V.m) throw new TypeError("m mismatch");
      if (A.n !== void 0 && A.n !== V.n) throw new TypeError("n mismatch");
      if (A.pubkeys && !(0, types_1$6.stacksEqual)(A.pubkeys, V.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (A.pubkeys) {
      if (A.n !== void 0 && A.n !== A.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (V.n = A.pubkeys.length, V.n < V.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (A.signatures) {
      if (A.signatures.length < V.m)
        throw new TypeError("Not enough signatures provided");
      if (A.signatures.length > V.m)
        throw new TypeError("Too many signatures provided");
    }
    if (A.input) {
      if (A.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (V.signatures.length === 0 || !V.signatures.every(L))
        throw new TypeError("Input has invalid signature(s)");
      if (A.signatures && !(0, types_1$6.stacksEqual)(A.signatures, V.signatures))
        throw new TypeError("Signature mismatch");
      if (A.m !== void 0 && A.m !== A.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(V, A);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(A, B) {
  if (!A.input && !A.output && !A.pubkey && !A.input && !A.signature)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    A
  );
  const L = lazy$4.value(() => bscript$7.decompile(A.input)), V = { name: "p2pk", network: A.network || networks_1$5.bitcoin };
  if (lazy$4.prop(V, "output", () => {
    if (A.pubkey)
      return bscript$7.compile([A.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(V, "pubkey", () => {
    if (A.output)
      return A.output.slice(1, -1);
  }), lazy$4.prop(V, "signature", () => {
    if (A.input)
      return L()[0];
  }), lazy$4.prop(V, "input", () => {
    if (A.signature)
      return bscript$7.compile([A.signature]);
  }), lazy$4.prop(V, "witness", () => {
    if (V.input)
      return [];
  }), B.validate) {
    if (A.output) {
      if (A.output[A.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(V.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (A.pubkey && !A.pubkey.equals(V.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (A.signature && A.input && !A.input.equals(V.input))
      throw new TypeError("Signature mismatch");
    if (A.input) {
      if (L().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(V.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(V, A);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((A, B) => B)), Pi = /* @__PURE__ */ Id.map((A) => (9 * A + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let A = 0; A < 4; A++)
  for (let B of [idxL, idxR])
    B.push(B[A].map((L) => Rho[L]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((A) => new Uint8Array(A)), shiftsL = /* @__PURE__ */ idxL.map((A, B) => A.map((L) => shifts[B][L])), shiftsR = /* @__PURE__ */ idxR.map((A, B) => A.map((L) => shifts[B][L])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(A, B, L, K) {
  return A === 0 ? B ^ L ^ K : A === 1 ? B & L | ~B & K : A === 2 ? (B | ~L) ^ K : A === 3 ? B & K | L & ~K : B ^ (L | ~K);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: B, h1: L, h2: K, h3: V, h4: W } = this;
    return [B, L, K, V, W];
  }
  set(B, L, K, V, W) {
    this.h0 = B | 0, this.h1 = L | 0, this.h2 = K | 0, this.h3 = V | 0, this.h4 = W | 0;
  }
  process(B, L) {
    for (let Oe = 0; Oe < 16; Oe++, L += 4)
      R_BUF[Oe] = B.getUint32(L, !0);
    let K = this.h0 | 0, V = K, W = this.h1 | 0, J = W, ne = this.h2 | 0, ie = ne, ce = this.h3 | 0, re = ce, oe = this.h4 | 0, ke = oe;
    for (let Oe = 0; Oe < 5; Oe++) {
      const it = 4 - Oe, at = Kl[Oe], ut = Kr[Oe], dt = idxL[Oe], ct = idxR[Oe], bt = shiftsL[Oe], vt = shiftsR[Oe];
      for (let $t = 0; $t < 16; $t++) {
        const xt = (0, utils_js_1$1.rotl)(K + f(Oe, W, ne, ce) + R_BUF[dt[$t]] + at, bt[$t]) + oe | 0;
        K = oe, oe = ce, ce = (0, utils_js_1$1.rotl)(ne, 10) | 0, ne = W, W = xt;
      }
      for (let $t = 0; $t < 16; $t++) {
        const xt = (0, utils_js_1$1.rotl)(V + f(it, J, ie, re) + R_BUF[ct[$t]] + ut, vt[$t]) + ke | 0;
        V = ke, ke = re, re = (0, utils_js_1$1.rotl)(ie, 10) | 0, ie = J, J = xt;
      }
    }
    this.set(this.h1 + ne + re | 0, this.h2 + ce + ke | 0, this.h3 + oe + V | 0, this.h4 + K + J | 0, this.h0 + W + ie | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: B, B: L, C: K, D: V, E: W } = this;
    return [B, L, K, V, W];
  }
  set(B, L, K, V, W) {
    this.A = B | 0, this.B = L | 0, this.C = K | 0, this.D = V | 0, this.E = W | 0;
  }
  process(B, L) {
    for (let ie = 0; ie < 16; ie++, L += 4)
      SHA1_W[ie] = B.getUint32(L, !1);
    for (let ie = 16; ie < 80; ie++)
      SHA1_W[ie] = (0, utils_js_1.rotl)(SHA1_W[ie - 3] ^ SHA1_W[ie - 8] ^ SHA1_W[ie - 14] ^ SHA1_W[ie - 16], 1);
    let { A: K, B: V, C: W, D: J, E: ne } = this;
    for (let ie = 0; ie < 80; ie++) {
      let ce, re;
      ie < 20 ? (ce = (0, _md_js_1.Chi)(V, W, J), re = 1518500249) : ie < 40 ? (ce = V ^ W ^ J, re = 1859775393) : ie < 60 ? (ce = (0, _md_js_1.Maj)(V, W, J), re = 2400959708) : (ce = V ^ W ^ J, re = 3395469782);
      const oe = (0, utils_js_1.rotl)(K, 5) + ce + ne + re + SHA1_W[ie] | 0;
      ne = J, J = W, W = (0, utils_js_1.rotl)(V, 30), V = K, K = oe;
    }
    K = K + this.A | 0, V = V + this.B | 0, W = W + this.C | 0, J = J + this.D | 0, ne = ne + this.E | 0, this.set(K, V, W, J, ne);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.taggedHash = A.TAGGED_HASH_PREFIXES = A.TAGS = A.hash256 = A.hash160 = A.sha256 = A.sha1 = A.ripemd160 = void 0;
  const B = ripemd160, L = sha1, K = sha256$4;
  function V(re) {
    return Buffer$1.from((0, B.ripemd160)(Uint8Array.from(re)));
  }
  A.ripemd160 = V;
  function W(re) {
    return Buffer$1.from((0, L.sha1)(Uint8Array.from(re)));
  }
  A.sha1 = W;
  function J(re) {
    return Buffer$1.from((0, K.sha256)(Uint8Array.from(re)));
  }
  A.sha256 = J;
  function ne(re) {
    return Buffer$1.from(
      (0, B.ripemd160)((0, K.sha256)(Uint8Array.from(re)))
    );
  }
  A.hash160 = ne;
  function ie(re) {
    return Buffer$1.from(
      (0, K.sha256)((0, K.sha256)(Uint8Array.from(re)))
    );
  }
  A.hash256 = ie, A.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], A.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function ce(re, oe) {
    return J(Buffer$1.concat([A.TAGGED_HASH_PREFIXES[re], oe]));
  }
  A.taggedHash = ce;
})(crypto$1);
function base$1(A) {
  if (A.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var B = new Uint8Array(256), L = 0; L < B.length; L++)
    B[L] = 255;
  for (var K = 0; K < A.length; K++) {
    var V = A.charAt(K), W = V.charCodeAt(0);
    if (B[W] !== 255)
      throw new TypeError(V + " is ambiguous");
    B[W] = K;
  }
  var J = A.length, ne = A.charAt(0), ie = Math.log(J) / Math.log(256), ce = Math.log(256) / Math.log(J);
  function re(Oe) {
    if (Oe instanceof Uint8Array || (ArrayBuffer.isView(Oe) ? Oe = new Uint8Array(Oe.buffer, Oe.byteOffset, Oe.byteLength) : Array.isArray(Oe) && (Oe = Uint8Array.from(Oe))), !(Oe instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Oe.length === 0)
      return "";
    for (var it = 0, at = 0, ut = 0, dt = Oe.length; ut !== dt && Oe[ut] === 0; )
      ut++, it++;
    for (var ct = (dt - ut) * ce + 1 >>> 0, bt = new Uint8Array(ct); ut !== dt; ) {
      for (var vt = Oe[ut], $t = 0, xt = ct - 1; (vt !== 0 || $t < at) && xt !== -1; xt--, $t++)
        vt += 256 * bt[xt] >>> 0, bt[xt] = vt % J >>> 0, vt = vt / J >>> 0;
      if (vt !== 0)
        throw new Error("Non-zero carry");
      at = $t, ut++;
    }
    for (var Ot = ct - at; Ot !== ct && bt[Ot] === 0; )
      Ot++;
    for (var At = ne.repeat(it); Ot < ct; ++Ot)
      At += A.charAt(bt[Ot]);
    return At;
  }
  function oe(Oe) {
    if (typeof Oe != "string")
      throw new TypeError("Expected String");
    if (Oe.length === 0)
      return new Uint8Array();
    for (var it = 0, at = 0, ut = 0; Oe[it] === ne; )
      at++, it++;
    for (var dt = (Oe.length - it) * ie + 1 >>> 0, ct = new Uint8Array(dt); Oe[it]; ) {
      var bt = B[Oe.charCodeAt(it)];
      if (bt === 255)
        return;
      for (var vt = 0, $t = dt - 1; (bt !== 0 || vt < ut) && $t !== -1; $t--, vt++)
        bt += J * ct[$t] >>> 0, ct[$t] = bt % 256 >>> 0, bt = bt / 256 >>> 0;
      if (bt !== 0)
        throw new Error("Non-zero carry");
      ut = vt, it++;
    }
    for (var xt = dt - ut; xt !== dt && ct[xt] === 0; )
      xt++;
    for (var Ot = new Uint8Array(at + (dt - xt)), At = at; xt !== dt; )
      Ot[At++] = ct[xt++];
    return Ot;
  }
  function ke(Oe) {
    var it = oe(Oe);
    if (it)
      return it;
    throw new Error("Non-base" + J + " character");
  }
  return {
    encode: re,
    decodeUnsafe: oe,
    decode: ke
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(A) {
  function B(W) {
    var J = Uint8Array.from(W), ne = A(J), ie = J.length + 4, ce = new Uint8Array(ie);
    return ce.set(J, 0), ce.set(ne.subarray(0, 4), J.length), base58.encode(ce, ie);
  }
  function L(W) {
    var J = W.slice(0, -4), ne = W.slice(-4), ie = A(J);
    if (!(ne[0] ^ ie[0] | ne[1] ^ ie[1] | ne[2] ^ ie[2] | ne[3] ^ ie[3]))
      return J;
  }
  function K(W) {
    var J = base58.decodeUnsafe(W);
    if (J)
      return L(J);
  }
  function V(W) {
    var J = base58.decode(W), ne = L(J);
    if (!ne) throw new Error("Invalid checksum");
    return ne;
  }
  return {
    encode: B,
    decode: V,
    decodeUnsafe: K
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(A) {
  return sha256(sha256(A));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    A
  );
  const L = lazy$3.value(() => {
    const J = Buffer$1.from(bs58check$1.decode(A.address)), ne = J.readUInt8(0), ie = J.slice(1);
    return { version: ne, hash: ie };
  }), K = lazy$3.value(() => bscript$6.decompile(A.input)), V = A.network || networks_1$4.bitcoin, W = { name: "p2pkh", network: V };
  if (lazy$3.prop(W, "address", () => {
    if (!W.hash) return;
    const J = Buffer$1.allocUnsafe(21);
    return J.writeUInt8(V.pubKeyHash, 0), W.hash.copy(J, 1), bs58check$1.encode(J);
  }), lazy$3.prop(W, "hash", () => {
    if (A.output) return A.output.slice(3, 23);
    if (A.address) return L().hash;
    if (A.pubkey || W.pubkey) return bcrypto$5.hash160(A.pubkey || W.pubkey);
  }), lazy$3.prop(W, "output", () => {
    if (W.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        W.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(W, "pubkey", () => {
    if (A.input)
      return K()[1];
  }), lazy$3.prop(W, "signature", () => {
    if (A.input)
      return K()[0];
  }), lazy$3.prop(W, "input", () => {
    if (A.pubkey && A.signature)
      return bscript$6.compile([A.signature, A.pubkey]);
  }), lazy$3.prop(W, "witness", () => {
    if (W.input)
      return [];
  }), B.validate) {
    let J = Buffer$1.from([]);
    if (A.address) {
      if (L().version !== V.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (L().hash.length !== 20) throw new TypeError("Invalid address");
      J = L().hash;
    }
    if (A.hash) {
      if (J.length > 0 && !J.equals(A.hash))
        throw new TypeError("Hash mismatch");
      J = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 25 || A.output[0] !== OPS$3.OP_DUP || A.output[1] !== OPS$3.OP_HASH160 || A.output[2] !== 20 || A.output[23] !== OPS$3.OP_EQUALVERIFY || A.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(3, 23);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.pubkey) {
      const ne = bcrypto$5.hash160(A.pubkey);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.input) {
      const ne = K();
      if (ne.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(ne[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(ne[1]))
        throw new TypeError("Input has invalid pubkey");
      if (A.signature && !A.signature.equals(ne[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(ne[1]))
        throw new TypeError("Pubkey mismatch");
      const ie = bcrypto$5.hash160(ne[1]);
      if (J.length > 0 && !J.equals(ie))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(W, A);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.input)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    A
  );
  let L = A.network;
  L || (L = A.redeem && A.redeem.network || networks_1$3.bitcoin);
  const K = { network: L }, V = lazy$2.value(() => {
    const ne = Buffer$1.from(bs58check.decode(A.address)), ie = ne.readUInt8(0), ce = ne.slice(1);
    return { version: ie, hash: ce };
  }), W = lazy$2.value(() => bscript$5.decompile(A.input)), J = lazy$2.value(() => {
    const ne = W(), ie = ne[ne.length - 1];
    return {
      network: L,
      output: ie === OPS$2.OP_FALSE ? Buffer$1.from([]) : ie,
      input: bscript$5.compile(ne.slice(0, -1)),
      witness: A.witness || []
    };
  });
  if (lazy$2.prop(K, "address", () => {
    if (!K.hash) return;
    const ne = Buffer$1.allocUnsafe(21);
    return ne.writeUInt8(K.network.scriptHash, 0), K.hash.copy(ne, 1), bs58check.encode(ne);
  }), lazy$2.prop(K, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return V().hash;
    if (K.redeem && K.redeem.output) return bcrypto$4.hash160(K.redeem.output);
  }), lazy$2.prop(K, "output", () => {
    if (K.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, K.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(K, "redeem", () => {
    if (A.input)
      return J();
  }), lazy$2.prop(K, "input", () => {
    if (!(!A.redeem || !A.redeem.input || !A.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(A.redeem.input), A.redeem.output)
      );
  }), lazy$2.prop(K, "witness", () => {
    if (K.redeem && K.redeem.witness) return K.redeem.witness;
    if (K.input) return [];
  }), lazy$2.prop(K, "name", () => {
    const ne = ["p2sh"];
    return K.redeem !== void 0 && K.redeem.name !== void 0 && ne.push(K.redeem.name), ne.join("-");
  }), B.validate) {
    let ne = Buffer$1.from([]);
    if (A.address) {
      if (V().version !== L.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (V().hash.length !== 20) throw new TypeError("Invalid address");
      ne = V().hash;
    }
    if (A.hash) {
      if (ne.length > 0 && !ne.equals(A.hash))
        throw new TypeError("Hash mismatch");
      ne = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 23 || A.output[0] !== OPS$2.OP_HASH160 || A.output[1] !== 20 || A.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const ce = A.output.slice(2, 22);
      if (ne.length > 0 && !ne.equals(ce))
        throw new TypeError("Hash mismatch");
      ne = ce;
    }
    const ie = (ce) => {
      if (ce.output) {
        const re = bscript$5.decompile(ce.output);
        if (!re || re.length < 1)
          throw new TypeError("Redeem.output too short");
        if (ce.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(re) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const oe = bcrypto$4.hash160(ce.output);
        if (ne.length > 0 && !ne.equals(oe))
          throw new TypeError("Hash mismatch");
        ne = oe;
      }
      if (ce.input) {
        const re = ce.input.length > 0, oe = ce.witness && ce.witness.length > 0;
        if (!re && !oe) throw new TypeError("Empty input");
        if (re && oe)
          throw new TypeError("Input and witness provided");
        if (re) {
          const ke = bscript$5.decompile(ce.input);
          if (!bscript$5.isPushOnly(ke))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (A.input) {
      const ce = W();
      if (!ce || ce.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(J().output))
        throw new TypeError("Input is invalid");
      ie(J());
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== L)
        throw new TypeError("Network mismatch");
      if (A.input) {
        const ce = J();
        if (A.redeem.output && !A.redeem.output.equals(ce.output))
          throw new TypeError("Redeem.output mismatch");
        if (A.redeem.input && !A.redeem.input.equals(ce.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ie(A.redeem);
    }
    if (A.witness && A.redeem && A.redeem.witness && !(0, types_1$3.stacksEqual)(A.redeem.witness, A.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(K, A);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let A = 0; A < ALPHABET.length; A++) {
  const B = ALPHABET.charAt(A);
  ALPHABET_MAP[B] = A;
}
function polymodStep(A) {
  const B = A >> 25;
  return (A & 33554431) << 5 ^ -(B >> 0 & 1) & 996825010 ^ -(B >> 1 & 1) & 642813549 ^ -(B >> 2 & 1) & 513874426 ^ -(B >> 3 & 1) & 1027748829 ^ -(B >> 4 & 1) & 705979059;
}
function prefixChk(A) {
  let B = 1;
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    if (K < 33 || K > 126)
      return "Invalid prefix (" + A + ")";
    B = polymodStep(B) ^ K >> 5;
  }
  B = polymodStep(B);
  for (let L = 0; L < A.length; ++L) {
    const K = A.charCodeAt(L);
    B = polymodStep(B) ^ K & 31;
  }
  return B;
}
function convert$2(A, B, L, K) {
  let V = 0, W = 0;
  const J = (1 << L) - 1, ne = [];
  for (let ie = 0; ie < A.length; ++ie)
    for (V = V << B | A[ie], W += B; W >= L; )
      W -= L, ne.push(V >> W & J);
  if (K)
    W > 0 && ne.push(V << L - W & J);
  else {
    if (W >= B)
      return "Excess padding";
    if (V << L - W & J)
      return "Non-zero padding";
  }
  return ne;
}
function toWords(A) {
  return convert$2(A, 8, 5, !0);
}
function fromWordsUnsafe(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
}
function fromWords(A) {
  const B = convert$2(A, 5, 8, !1);
  if (Array.isArray(B))
    return B;
  throw new Error(B);
}
function getLibraryFromEncoding(A) {
  let B;
  A === "bech32" ? B = 1 : B = 734539939;
  function L(J, ne, ie) {
    if (ie = ie || 90, J.length + 7 + ne.length > ie)
      throw new TypeError("Exceeds length limit");
    J = J.toLowerCase();
    let ce = prefixChk(J);
    if (typeof ce == "string")
      throw new Error(ce);
    let re = J + "1";
    for (let oe = 0; oe < ne.length; ++oe) {
      const ke = ne[oe];
      if (ke >> 5)
        throw new Error("Non 5-bit word");
      ce = polymodStep(ce) ^ ke, re += ALPHABET.charAt(ke);
    }
    for (let oe = 0; oe < 6; ++oe)
      ce = polymodStep(ce);
    ce ^= B;
    for (let oe = 0; oe < 6; ++oe) {
      const ke = ce >> (5 - oe) * 5 & 31;
      re += ALPHABET.charAt(ke);
    }
    return re;
  }
  function K(J, ne) {
    if (ne = ne || 90, J.length < 8)
      return J + " too short";
    if (J.length > ne)
      return "Exceeds length limit";
    const ie = J.toLowerCase(), ce = J.toUpperCase();
    if (J !== ie && J !== ce)
      return "Mixed-case string " + J;
    J = ie;
    const re = J.lastIndexOf("1");
    if (re === -1)
      return "No separator character for " + J;
    if (re === 0)
      return "Missing prefix for " + J;
    const oe = J.slice(0, re), ke = J.slice(re + 1);
    if (ke.length < 6)
      return "Data too short";
    let Oe = prefixChk(oe);
    if (typeof Oe == "string")
      return Oe;
    const it = [];
    for (let at = 0; at < ke.length; ++at) {
      const ut = ke.charAt(at), dt = ALPHABET_MAP[ut];
      if (dt === void 0)
        return "Unknown character " + ut;
      Oe = polymodStep(Oe) ^ dt, !(at + 6 >= ke.length) && it.push(dt);
    }
    return Oe !== B ? "Invalid checksum for " + J : { prefix: oe, words: it };
  }
  function V(J, ne) {
    const ie = K(J, ne);
    if (typeof ie == "object")
      return ie;
  }
  function W(J, ne) {
    const ie = K(J, ne);
    if (typeof ie == "object")
      return ie;
    throw new Error(ie);
  }
  return {
    decodeUnsafe: V,
    decode: W,
    encode: L,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.pubkey && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy$1.value(() => {
    const W = bech32_1$1.bech32.decode(A.address), J = W.words.shift(), ne = bech32_1$1.bech32.fromWords(W.words);
    return {
      version: J,
      prefix: W.prefix,
      data: Buffer$1.from(ne)
    };
  }), K = A.network || networks_1$2.bitcoin, V = { name: "p2wpkh", network: K };
  if (lazy$1.prop(V, "address", () => {
    if (!V.hash) return;
    const W = bech32_1$1.bech32.toWords(V.hash);
    return W.unshift(0), bech32_1$1.bech32.encode(K.bech32, W);
  }), lazy$1.prop(V, "hash", () => {
    if (A.output) return A.output.slice(2, 22);
    if (A.address) return L().data;
    if (A.pubkey || V.pubkey) return bcrypto$3.hash160(A.pubkey || V.pubkey);
  }), lazy$1.prop(V, "output", () => {
    if (V.hash)
      return bscript$4.compile([OPS$1.OP_0, V.hash]);
  }), lazy$1.prop(V, "pubkey", () => {
    if (A.pubkey) return A.pubkey;
    if (A.witness)
      return A.witness[1];
  }), lazy$1.prop(V, "signature", () => {
    if (A.witness)
      return A.witness[0];
  }), lazy$1.prop(V, "input", () => {
    if (V.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(V, "witness", () => {
    if (A.pubkey && A.signature)
      return [A.signature, A.pubkey];
  }), B.validate) {
    let W = Buffer$1.from([]);
    if (A.address) {
      if (K && K.bech32 !== L().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 20)
        throw new TypeError("Invalid address data");
      W = L().data;
    }
    if (A.hash) {
      if (W.length > 0 && !W.equals(A.hash))
        throw new TypeError("Hash mismatch");
      W = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 22 || A.output[0] !== OPS$1.OP_0 || A.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (W.length > 0 && !W.equals(A.output.slice(2)))
        throw new TypeError("Hash mismatch");
      W = A.output.slice(2);
    }
    if (A.pubkey) {
      const J = bcrypto$3.hash160(A.pubkey);
      if (W.length > 0 && !W.equals(J))
        throw new TypeError("Hash mismatch");
      if (W = J, !(0, types_1$2.isPoint)(A.pubkey) || A.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (A.witness) {
      if (A.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(A.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(A.witness[1]) || A.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (A.signature && !A.signature.equals(A.witness[0]))
        throw new TypeError("Signature mismatch");
      if (A.pubkey && !A.pubkey.equals(A.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const J = bcrypto$3.hash160(A.witness[1]);
      if (W.length > 0 && !W.equals(J))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(V, A);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(A) {
  return !!(Buffer$1.isBuffer(A) && A.length === 65 && A[0] === 4 && (0, types_1$1.isPoint)(A));
}
function p2wsh(A, B) {
  if (!A.address && !A.hash && !A.output && !A.redeem && !A.witness)
    throw new TypeError("Not enough data");
  B = Object.assign({ validate: !0 }, B || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    A
  );
  const L = lazy.value(() => {
    const J = bech32_1.bech32.decode(A.address), ne = J.words.shift(), ie = bech32_1.bech32.fromWords(J.words);
    return {
      version: ne,
      prefix: J.prefix,
      data: Buffer$1.from(ie)
    };
  }), K = lazy.value(() => bscript$3.decompile(A.redeem.input));
  let V = A.network;
  V || (V = A.redeem && A.redeem.network || networks_1$1.bitcoin);
  const W = { network: V };
  if (lazy.prop(W, "address", () => {
    if (!W.hash) return;
    const J = bech32_1.bech32.toWords(W.hash);
    return J.unshift(0), bech32_1.bech32.encode(V.bech32, J);
  }), lazy.prop(W, "hash", () => {
    if (A.output) return A.output.slice(2);
    if (A.address) return L().data;
    if (W.redeem && W.redeem.output) return bcrypto$2.sha256(W.redeem.output);
  }), lazy.prop(W, "output", () => {
    if (W.hash)
      return bscript$3.compile([OPS.OP_0, W.hash]);
  }), lazy.prop(W, "redeem", () => {
    if (A.witness)
      return {
        output: A.witness[A.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: A.witness.slice(0, -1)
      };
  }), lazy.prop(W, "input", () => {
    if (W.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(W, "witness", () => {
    if (A.redeem && A.redeem.input && A.redeem.input.length > 0 && A.redeem.output && A.redeem.output.length > 0) {
      const J = bscript$3.toStack(K());
      return W.redeem = Object.assign({ witness: J }, A.redeem), W.redeem.input = EMPTY_BUFFER$1, [].concat(J, A.redeem.output);
    }
    if (A.redeem && A.redeem.output && A.redeem.witness)
      return [].concat(A.redeem.witness, A.redeem.output);
  }), lazy.prop(W, "name", () => {
    const J = ["p2wsh"];
    return W.redeem !== void 0 && W.redeem.name !== void 0 && J.push(W.redeem.name), J.join("-");
  }), B.validate) {
    let J = Buffer$1.from([]);
    if (A.address) {
      if (L().prefix !== V.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (L().version !== 0)
        throw new TypeError("Invalid address version");
      if (L().data.length !== 32)
        throw new TypeError("Invalid address data");
      J = L().data;
    }
    if (A.hash) {
      if (J.length > 0 && !J.equals(A.hash))
        throw new TypeError("Hash mismatch");
      J = A.hash;
    }
    if (A.output) {
      if (A.output.length !== 34 || A.output[0] !== OPS.OP_0 || A.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const ne = A.output.slice(2);
      if (J.length > 0 && !J.equals(ne))
        throw new TypeError("Hash mismatch");
      J = ne;
    }
    if (A.redeem) {
      if (A.redeem.network && A.redeem.network !== V)
        throw new TypeError("Network mismatch");
      if (A.redeem.input && A.redeem.input.length > 0 && A.redeem.witness && A.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (A.redeem.output) {
        const ne = bscript$3.decompile(A.redeem.output);
        if (!ne || ne.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (A.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(ne) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ie = bcrypto$2.sha256(A.redeem.output);
        if (J.length > 0 && !J.equals(ie))
          throw new TypeError("Hash mismatch");
        J = ie;
      }
      if (A.redeem.input && !bscript$3.isPushOnly(K()))
        throw new TypeError("Non push-only scriptSig");
      if (A.witness && A.redeem.witness && !(0, types_1$1.stacksEqual)(A.witness, A.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (A.redeem.input && K().some(chunkHasUncompressedPubkey) || A.redeem.output && (bscript$3.decompile(A.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (A.witness && A.witness.length > 0) {
      const ne = A.witness[A.witness.length - 1];
      if (A.redeem && A.redeem.output && !A.redeem.output.equals(ne))
        throw new TypeError("Witness and redeem.output mismatch");
      if (A.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(ne) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(W, A);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(A) {
  A ? A !== _ECCLIB_CACHE.eccLib && (verifyEcc(A), _ECCLIB_CACHE.eccLib = A) : _ECCLIB_CACHE.eccLib = A;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (A) => Buffer$1.from(A, "hex");
function verifyEcc(A) {
  assert(typeof A.isXOnlyPoint == "function"), assert(
    A.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    A.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !A.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof A.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((B) => {
    const L = A.xOnlyPointAddTweak(h(B.pubkey), h(B.tweak));
    B.result === null ? assert(L === null) : (assert(L !== null), assert(L.parity === B.parity), assert(Buffer$1.from(L.xOnlyPubkey).equals(h(B.result))));
  });
}
function assert(A) {
  if (!A) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER$1 || A % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(A, B, L) {
  if (checkUInt53$1(A), B || (B = Buffer.allocUnsafe(encodingLength$1(A))), !Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), encode$f.bytes = 1) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), encode$f.bytes = 3) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), encode$f.bytes = 5) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), encode$f.bytes = 9), B;
}
function decode$e(A, B) {
  if (!Buffer.isBuffer(A)) throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  var L = A.readUInt8(B);
  if (L < 253)
    return decode$e.bytes = 1, L;
  if (L === 253)
    return decode$e.bytes = 3, A.readUInt16LE(B + 1);
  if (L === 254)
    return decode$e.bytes = 5, A.readUInt32LE(B + 1);
  decode$e.bytes = 9;
  var K = A.readUInt32LE(B + 1), V = A.readUInt32LE(B + 5), W = V * 4294967296 + K;
  return checkUInt53$1(W), W;
}
function encodingLength$1(A) {
  return checkUInt53$1(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint$1(K + L, 9007199254740991), K + L;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(A, B, L) {
  return verifuint$1(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(A) {
  const B = Buffer$1.allocUnsafe(A.length);
  return A.copy(B), B;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(B) {
    return new BufferWriter(Buffer$1.alloc(B));
  }
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  writeUInt8(B) {
    this.offset = this.buffer.writeUInt8(B, this.offset);
  }
  writeInt32(B) {
    this.offset = this.buffer.writeInt32LE(B, this.offset);
  }
  writeUInt32(B) {
    this.offset = this.buffer.writeUInt32LE(B, this.offset);
  }
  writeUInt64(B) {
    this.offset = writeUInt64LE$1(this.buffer, B, this.offset);
  }
  writeVarInt(B) {
    varuint$7.encode(B, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(B) {
    if (this.buffer.length < this.offset + B.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += B.copy(this.buffer, this.offset);
  }
  writeVarSlice(B) {
    this.writeVarInt(B.length), this.writeSlice(B);
  }
  writeVector(B) {
    this.writeVarInt(B.length), B.forEach((L) => this.writeVarSlice(L));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(B, L = 0) {
    this.buffer = B, this.offset = L, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [B, L]);
  }
  readUInt8() {
    const B = this.buffer.readUInt8(this.offset);
    return this.offset++, B;
  }
  readInt32() {
    const B = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt32() {
    const B = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, B;
  }
  readUInt64() {
    const B = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, B;
  }
  readVarInt() {
    const B = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, B;
  }
  readSlice(B) {
    if (this.buffer.length < this.offset + B)
      throw new Error("Cannot read slice out of bounds");
    const L = this.buffer.slice(this.offset, this.offset + B);
    return this.offset += B, L;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const B = this.readVarInt(), L = [];
    for (let K = 0; K < B; K++) L.push(this.readVarSlice());
    return L;
  }
}
bufferutils.BufferReader = BufferReader;
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.tweakKey = A.tapTweakHash = A.tapleafHash = A.findScriptPath = A.toHashTree = A.rootHashFromPath = A.MAX_TAPTREE_DEPTH = A.LEAF_VERSION_TAPSCRIPT = void 0;
  const B = require$$0$1, L = ecc_lib, K = crypto$1, V = bufferutils, W = types$4;
  A.LEAF_VERSION_TAPSCRIPT = 192, A.MAX_TAPTREE_DEPTH = 128;
  const J = (at) => "left" in at && "right" in at;
  function ne(at, ut) {
    if (at.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${at.length}, expected min 33.`
      );
    const dt = (at.length - 33) / 32;
    let ct = ut;
    for (let bt = 0; bt < dt; bt++) {
      const vt = at.slice(33 + 32 * bt, 65 + 32 * bt);
      ct.compare(vt) < 0 ? ct = Oe(ct, vt) : ct = Oe(vt, ct);
    }
    return ct;
  }
  A.rootHashFromPath = ne;
  function ie(at) {
    if ((0, W.isTapleaf)(at))
      return { hash: re(at) };
    const ut = [ie(at[0]), ie(at[1])];
    ut.sort((bt, vt) => bt.hash.compare(vt.hash));
    const [dt, ct] = ut;
    return {
      hash: Oe(dt.hash, ct.hash),
      left: dt,
      right: ct
    };
  }
  A.toHashTree = ie;
  function ce(at, ut) {
    if (J(at)) {
      const dt = ce(at.left, ut);
      if (dt !== void 0) return [...dt, at.right.hash];
      const ct = ce(at.right, ut);
      if (ct !== void 0) return [...ct, at.left.hash];
    } else if (at.hash.equals(ut))
      return [];
  }
  A.findScriptPath = ce;
  function re(at) {
    const ut = at.version || A.LEAF_VERSION_TAPSCRIPT;
    return K.taggedHash(
      "TapLeaf",
      B.Buffer.concat([
        B.Buffer.from([ut]),
        it(at.output)
      ])
    );
  }
  A.tapleafHash = re;
  function oe(at, ut) {
    return K.taggedHash(
      "TapTweak",
      B.Buffer.concat(ut ? [at, ut] : [at])
    );
  }
  A.tapTweakHash = oe;
  function ke(at, ut) {
    if (!B.Buffer.isBuffer(at) || at.length !== 32 || ut && ut.length !== 32) return null;
    const dt = oe(at, ut), ct = (0, L.getEccLib)().xOnlyPointAddTweak(at, dt);
    return !ct || ct.xOnlyPubkey === null ? null : {
      parity: ct.parity,
      x: B.Buffer.from(ct.xOnlyPubkey)
    };
  }
  A.tweakKey = ke;
  function Oe(at, ut) {
    return K.taggedHash("TapBranch", B.Buffer.concat([at, ut]));
  }
  function it(at) {
    const ut = V.varuint.encodingLength(at.length), dt = B.Buffer.allocUnsafe(ut);
    return V.varuint.encode(at.length, dt), B.Buffer.concat([dt, at]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const A = require$$0$1, B = networks, L = requireScript(), K = types$4, V = ecc_lib, W = bip341, J = lazy$7, ne = dist, ie = requireAddress(), ce = L.OPS, re = 1, oe = 80;
  function ke(Oe, it) {
    if (!Oe.address && !Oe.output && !Oe.pubkey && !Oe.internalPubkey && !(Oe.witness && Oe.witness.length > 1))
      throw new TypeError("Not enough data");
    it = Object.assign({ validate: !0 }, it || {}), (0, K.typeforce)(
      {
        address: K.typeforce.maybe(K.typeforce.String),
        input: K.typeforce.maybe(K.typeforce.BufferN(0)),
        network: K.typeforce.maybe(K.typeforce.Object),
        output: K.typeforce.maybe(K.typeforce.BufferN(34)),
        internalPubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        hash: K.typeforce.maybe(K.typeforce.BufferN(32)),
        pubkey: K.typeforce.maybe(K.typeforce.BufferN(32)),
        signature: K.typeforce.maybe(
          K.typeforce.anyOf(
            K.typeforce.BufferN(64),
            K.typeforce.BufferN(65)
          )
        ),
        witness: K.typeforce.maybe(
          K.typeforce.arrayOf(K.typeforce.Buffer)
        ),
        scriptTree: K.typeforce.maybe(K.isTaptree),
        redeem: K.typeforce.maybe({
          output: K.typeforce.maybe(K.typeforce.Buffer),
          redeemVersion: K.typeforce.maybe(K.typeforce.Number),
          witness: K.typeforce.maybe(
            K.typeforce.arrayOf(K.typeforce.Buffer)
          )
        }),
        redeemVersion: K.typeforce.maybe(K.typeforce.Number)
      },
      Oe
    );
    const at = J.value(() => (0, ie.fromBech32)(Oe.address)), ut = J.value(() => {
      if (!(!Oe.witness || !Oe.witness.length))
        return Oe.witness.length >= 2 && Oe.witness[Oe.witness.length - 1][0] === oe ? Oe.witness.slice(0, -1) : Oe.witness.slice();
    }), dt = J.value(() => {
      if (Oe.scriptTree) return (0, W.toHashTree)(Oe.scriptTree);
      if (Oe.hash) return { hash: Oe.hash };
    }), ct = Oe.network || B.bitcoin, bt = { name: "p2tr", network: ct };
    if (J.prop(bt, "address", () => {
      if (!bt.pubkey) return;
      const vt = ne.bech32m.toWords(bt.pubkey);
      return vt.unshift(re), ne.bech32m.encode(ct.bech32, vt);
    }), J.prop(bt, "hash", () => {
      const vt = dt();
      if (vt) return vt.hash;
      const $t = ut();
      if ($t && $t.length > 1) {
        const xt = $t[$t.length - 1], Ot = xt[0] & K.TAPLEAF_VERSION_MASK, At = $t[$t.length - 2], yt = (0, W.tapleafHash)({
          output: At,
          version: Ot
        });
        return (0, W.rootHashFromPath)(xt, yt);
      }
      return null;
    }), J.prop(bt, "output", () => {
      if (bt.pubkey)
        return L.compile([ce.OP_1, bt.pubkey]);
    }), J.prop(bt, "redeemVersion", () => Oe.redeemVersion ? Oe.redeemVersion : Oe.redeem && Oe.redeem.redeemVersion !== void 0 && Oe.redeem.redeemVersion !== null ? Oe.redeem.redeemVersion : W.LEAF_VERSION_TAPSCRIPT), J.prop(bt, "redeem", () => {
      const vt = ut();
      if (!(!vt || vt.length < 2))
        return {
          output: vt[vt.length - 2],
          witness: vt.slice(0, -2),
          redeemVersion: vt[vt.length - 1][0] & K.TAPLEAF_VERSION_MASK
        };
    }), J.prop(bt, "pubkey", () => {
      if (Oe.pubkey) return Oe.pubkey;
      if (Oe.output) return Oe.output.slice(2);
      if (Oe.address) return at().data;
      if (bt.internalPubkey) {
        const vt = (0, W.tweakKey)(bt.internalPubkey, bt.hash);
        if (vt) return vt.x;
      }
    }), J.prop(bt, "internalPubkey", () => {
      if (Oe.internalPubkey) return Oe.internalPubkey;
      const vt = ut();
      if (vt && vt.length > 1)
        return vt[vt.length - 1].slice(1, 33);
    }), J.prop(bt, "signature", () => {
      if (Oe.signature) return Oe.signature;
      const vt = ut();
      if (!(!vt || vt.length !== 1))
        return vt[0];
    }), J.prop(bt, "witness", () => {
      if (Oe.witness) return Oe.witness;
      const vt = dt();
      if (vt && Oe.redeem && Oe.redeem.output && Oe.internalPubkey) {
        const $t = (0, W.tapleafHash)({
          output: Oe.redeem.output,
          version: bt.redeemVersion
        }), xt = (0, W.findScriptPath)(vt, $t);
        if (!xt) return;
        const Ot = (0, W.tweakKey)(Oe.internalPubkey, vt.hash);
        if (!Ot) return;
        const At = A.Buffer.concat(
          [
            A.Buffer.from([bt.redeemVersion | Ot.parity]),
            Oe.internalPubkey
          ].concat(xt)
        );
        return [Oe.redeem.output, At];
      }
      if (Oe.signature) return [Oe.signature];
    }), it.validate) {
      let vt = A.Buffer.from([]);
      if (Oe.address) {
        if (ct && ct.bech32 !== at().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (at().version !== re)
          throw new TypeError("Invalid address version");
        if (at().data.length !== 32)
          throw new TypeError("Invalid address data");
        vt = at().data;
      }
      if (Oe.pubkey) {
        if (vt.length > 0 && !vt.equals(Oe.pubkey))
          throw new TypeError("Pubkey mismatch");
        vt = Oe.pubkey;
      }
      if (Oe.output) {
        if (Oe.output.length !== 34 || Oe.output[0] !== ce.OP_1 || Oe.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (vt.length > 0 && !vt.equals(Oe.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        vt = Oe.output.slice(2);
      }
      if (Oe.internalPubkey) {
        const Ot = (0, W.tweakKey)(Oe.internalPubkey, bt.hash);
        if (vt.length > 0 && !vt.equals(Ot.x))
          throw new TypeError("Pubkey mismatch");
        vt = Ot.x;
      }
      if (vt && vt.length && !(0, V.getEccLib)().isXOnlyPoint(vt))
        throw new TypeError("Invalid pubkey for p2tr");
      const $t = dt();
      if (Oe.hash && $t && !Oe.hash.equals($t.hash))
        throw new TypeError("Hash mismatch");
      if (Oe.redeem && Oe.redeem.output && $t) {
        const Ot = (0, W.tapleafHash)({
          output: Oe.redeem.output,
          version: bt.redeemVersion
        });
        if (!(0, W.findScriptPath)($t, Ot))
          throw new TypeError("Redeem script not in tree");
      }
      const xt = ut();
      if (Oe.redeem && bt.redeem) {
        if (Oe.redeem.redeemVersion && Oe.redeem.redeemVersion !== bt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Oe.redeem.output) {
          if (L.decompile(Oe.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (bt.redeem.output && !Oe.redeem.output.equals(bt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Oe.redeem.witness && bt.redeem.witness && !(0, K.stacksEqual)(Oe.redeem.witness, bt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (xt && xt.length)
        if (xt.length === 1) {
          if (Oe.signature && !Oe.signature.equals(xt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Ot = xt[xt.length - 1];
          if (Ot.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Ot.length}, expected min 33.`
            );
          if ((Ot.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Ot.length} is incorrect!`
            );
          const At = (Ot.length - 33) / 32;
          if (At > 128)
            throw new TypeError(
              `The script path is too long. Got ${At}, expected max 128.`
            );
          const yt = Ot.slice(1, 33);
          if (Oe.internalPubkey && !Oe.internalPubkey.equals(yt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, V.getEccLib)().isXOnlyPoint(yt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Bt = Ot[0] & K.TAPLEAF_VERSION_MASK, gt = xt[xt.length - 2], rt = (0, W.tapleafHash)({
            output: gt,
            version: Bt
          }), Ce = (0, W.rootHashFromPath)(Ot, rt), pe = (0, W.tweakKey)(yt, Ce);
          if (!pe)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (vt.length && !vt.equals(pe.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (pe.parity !== (Ot[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(bt, Oe);
  }
  return p2tr.p2tr = ke, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(A) {
    Object.defineProperty(A, "__esModule", { value: !0 }), A.p2tr = A.p2wsh = A.p2wpkh = A.p2sh = A.p2pkh = A.p2pk = A.p2ms = A.embed = void 0;
    const B = embed;
    Object.defineProperty(A, "embed", {
      enumerable: !0,
      get: function() {
        return B.p2data;
      }
    });
    const L = p2ms$1;
    Object.defineProperty(A, "p2ms", {
      enumerable: !0,
      get: function() {
        return L.p2ms;
      }
    });
    const K = p2pk$1;
    Object.defineProperty(A, "p2pk", {
      enumerable: !0,
      get: function() {
        return K.p2pk;
      }
    });
    const V = p2pkh$1;
    Object.defineProperty(A, "p2pkh", {
      enumerable: !0,
      get: function() {
        return V.p2pkh;
      }
    });
    const W = p2sh$1;
    Object.defineProperty(A, "p2sh", {
      enumerable: !0,
      get: function() {
        return W.p2sh;
      }
    });
    const J = p2wpkh$1;
    Object.defineProperty(A, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return J.p2wpkh;
      }
    });
    const ne = p2wsh$1;
    Object.defineProperty(A, "p2wsh", {
      enumerable: !0,
      get: function() {
        return ne.p2wsh;
      }
    });
    const ie = requireP2tr();
    Object.defineProperty(A, "p2tr", {
      enumerable: !0,
      get: function() {
        return ie.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const A = networks, B = requirePayments(), L = requireScript(), K = types$4, V = dist, W = bs58check$2, J = 40, ne = 2, ie = 16, ce = 2, re = 80, oe = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function ke(bt, vt) {
    const $t = bt.slice(2);
    if ($t.length < ne || $t.length > J)
      throw new TypeError("Invalid program length for segwit address");
    const xt = bt[0] - re;
    if (xt < ce || xt > ie)
      throw new TypeError("Invalid version for segwit address");
    if (bt[1] !== $t.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(oe), ut($t, xt, vt.bech32);
  }
  function Oe(bt) {
    const vt = Buffer$1.from(W.decode(bt));
    if (vt.length < 21) throw new TypeError(bt + " is too short");
    if (vt.length > 21) throw new TypeError(bt + " is too long");
    const $t = vt.readUInt8(0), xt = vt.slice(1);
    return { version: $t, hash: xt };
  }
  address.fromBase58Check = Oe;
  function it(bt) {
    let vt, $t;
    try {
      vt = V.bech32.decode(bt);
    } catch {
    }
    if (vt) {
      if ($t = vt.words[0], $t !== 0) throw new TypeError(bt + " uses wrong encoding");
    } else if (vt = V.bech32m.decode(bt), $t = vt.words[0], $t === 0) throw new TypeError(bt + " uses wrong encoding");
    const xt = V.bech32.fromWords(vt.words.slice(1));
    return {
      version: $t,
      prefix: vt.prefix,
      data: Buffer$1.from(xt)
    };
  }
  address.fromBech32 = it;
  function at(bt, vt) {
    (0, K.typeforce)(
      (0, K.tuple)(K.Hash160bit, K.UInt8),
      arguments
    );
    const $t = Buffer$1.allocUnsafe(21);
    return $t.writeUInt8(vt, 0), bt.copy($t, 1), W.encode($t);
  }
  address.toBase58Check = at;
  function ut(bt, vt, $t) {
    const xt = V.bech32.toWords(bt);
    return xt.unshift(vt), vt === 0 ? V.bech32.encode($t, xt) : V.bech32m.encode($t, xt);
  }
  address.toBech32 = ut;
  function dt(bt, vt) {
    vt = vt || A.bitcoin;
    try {
      return B.p2pkh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2sh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2wpkh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2wsh({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return B.p2tr({ output: bt, network: vt }).address;
    } catch {
    }
    try {
      return ke(bt, vt);
    } catch {
    }
    throw new Error(L.toASM(bt) + " has no matching Address");
  }
  address.fromOutputScript = dt;
  function ct(bt, vt) {
    vt = vt || A.bitcoin;
    let $t, xt;
    try {
      $t = Oe(bt);
    } catch {
    }
    if ($t) {
      if ($t.version === vt.pubKeyHash)
        return B.p2pkh({ hash: $t.hash }).output;
      if ($t.version === vt.scriptHash)
        return B.p2sh({ hash: $t.hash }).output;
    } else {
      try {
        xt = it(bt);
      } catch {
      }
      if (xt) {
        if (xt.prefix !== vt.bech32)
          throw new Error(bt + " has an invalid prefix");
        if (xt.version === 0) {
          if (xt.data.length === 20)
            return B.p2wpkh({ hash: xt.data }).output;
          if (xt.data.length === 32)
            return B.p2wsh({ hash: xt.data }).output;
        } else if (xt.version === 1) {
          if (xt.data.length === 32)
            return B.p2tr({ pubkey: xt.data }).output;
        } else if (xt.version >= ce && xt.version <= ie && xt.data.length >= ne && xt.data.length <= J)
          return console.warn(oe), L.compile([
            xt.version + re,
            xt.data
          ]);
      }
    }
    throw new Error(bt + " has no matching Script");
  }
  return address.toOutputScript = ct, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(A, B) {
  if (!Array.isArray(A)) throw TypeError("Expected values Array");
  if (typeof B != "function")
    throw TypeError("Expected digest Function");
  let L = A.length;
  const K = A.concat();
  for (; L > 1; ) {
    let V = 0;
    for (let W = 0; W < L; W += 2, ++V) {
      const J = K[W], ne = W + 1 === L ? J : K[W + 1], ie = Buffer$1.concat([J, ne]);
      K[V] = B(ie);
    }
    L = V;
  }
  return K[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + B;
}
function vectorSize(A) {
  const B = A.length;
  return bufferutils_1$2.varuint.encodingLength(B) + A.reduce((L, K) => L + varSliceSize(K), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(A) {
  return A.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(B, L) {
    const K = new bufferutils_1$2.BufferReader(B), V = new Transaction();
    V.version = K.readInt32();
    const W = K.readUInt8(), J = K.readUInt8();
    let ne = !1;
    W === Transaction.ADVANCED_TRANSACTION_MARKER && J === Transaction.ADVANCED_TRANSACTION_FLAG ? ne = !0 : K.offset -= 2;
    const ie = K.readVarInt();
    for (let re = 0; re < ie; ++re)
      V.ins.push({
        hash: K.readSlice(32),
        index: K.readUInt32(),
        script: K.readVarSlice(),
        sequence: K.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const ce = K.readVarInt();
    for (let re = 0; re < ce; ++re)
      V.outs.push({
        value: K.readUInt64(),
        script: K.readVarSlice()
      });
    if (ne) {
      for (let re = 0; re < ie; ++re)
        V.ins[re].witness = K.readVector();
      if (!V.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (V.locktime = K.readUInt32(), L) return V;
    if (K.offset !== B.length)
      throw new Error("Transaction has unexpected data");
    return V;
  }
  static fromHex(B) {
    return Transaction.fromBuffer(Buffer$1.from(B, "hex"), !1);
  }
  static isCoinbaseHash(B) {
    typeforce$1(types$1.Hash256bit, B);
    for (let L = 0; L < 32; ++L)
      if (B[L] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(B, L, K, V) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(K) && (K = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: B,
      index: L,
      script: V || EMPTY_BUFFER,
      sequence: K,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(B, L) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: B,
      value: L
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((B) => B.witness.length !== 0);
  }
  weight() {
    const B = this.byteLength(!1), L = this.byteLength(!0);
    return B * 3 + L;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(B = !0) {
    const L = B && this.hasWitnesses();
    return (L ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((K, V) => K + 40 + varSliceSize(V.script), 0) + this.outs.reduce((K, V) => K + 8 + varSliceSize(V.script), 0) + (L ? this.ins.reduce((K, V) => K + vectorSize(V.witness), 0) : 0);
  }
  clone() {
    const B = new Transaction();
    return B.version = this.version, B.locktime = this.locktime, B.ins = this.ins.map((L) => ({
      hash: L.hash,
      index: L.index,
      script: L.script,
      sequence: L.sequence,
      witness: L.witness
    })), B.outs = this.outs.map((L) => ({
      script: L.script,
      value: L.value
    })), B;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(B, L, K) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), B >= this.ins.length) return ONE;
    const V = bscript$2.compile(
      bscript$2.decompile(L).filter((ne) => ne !== script_1.OPS.OP_CODESEPARATOR)
    ), W = this.clone();
    if ((K & 31) === Transaction.SIGHASH_NONE)
      W.outs = [], W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    else if ((K & 31) === Transaction.SIGHASH_SINGLE) {
      if (B >= this.outs.length) return ONE;
      W.outs.length = B + 1;
      for (let ne = 0; ne < B; ne++)
        W.outs[ne] = BLANK_OUTPUT;
      W.ins.forEach((ne, ie) => {
        ie !== B && (ne.sequence = 0);
      });
    }
    K & Transaction.SIGHASH_ANYONECANPAY ? (W.ins = [W.ins[B]], W.ins[0].script = V) : (W.ins.forEach((ne) => {
      ne.script = EMPTY_BUFFER;
    }), W.ins[B].script = V);
    const J = Buffer$1.allocUnsafe(W.byteLength(!1) + 4);
    return J.writeInt32LE(K, J.length - 4), W.__toBuffer(J, 0, !1), bcrypto$1.hash256(J);
  }
  hashForWitnessV1(B, L, K, V, W, J) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), K.length !== this.ins.length || L.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const ne = V === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : V & Transaction.SIGHASH_OUTPUT_MASK, ce = (V & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, re = ne === Transaction.SIGHASH_NONE, oe = ne === Transaction.SIGHASH_SINGLE;
    let ke = EMPTY_BUFFER, Oe = EMPTY_BUFFER, it = EMPTY_BUFFER, at = EMPTY_BUFFER, ut = EMPTY_BUFFER;
    if (!ce) {
      let vt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach(($t) => {
        vt.writeSlice($t.hash), vt.writeUInt32($t.index);
      }), ke = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), K.forEach(($t) => vt.writeUInt64($t)), Oe = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        L.map(varSliceSize).reduce(($t, xt) => $t + xt)
      ), L.forEach(
        ($t) => vt.writeVarSlice($t)
      ), it = bcrypto$1.sha256(vt.end()), vt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach(($t) => vt.writeUInt32($t.sequence)), at = bcrypto$1.sha256(vt.end());
    }
    if (re || oe) {
      if (oe && B < this.outs.length) {
        const vt = this.outs[B], $t = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(vt.script)
        );
        $t.writeUInt64(vt.value), $t.writeVarSlice(vt.script), ut = bcrypto$1.sha256($t.end());
      }
    } else {
      const vt = this.outs.map((xt) => 8 + varSliceSize(xt.script)).reduce((xt, Ot) => xt + Ot), $t = bufferutils_1$2.BufferWriter.withCapacity(vt);
      this.outs.forEach((xt) => {
        $t.writeUInt64(xt.value), $t.writeVarSlice(xt.script);
      }), ut = bcrypto$1.sha256($t.end());
    }
    const dt = (W ? 2 : 0) + (J ? 1 : 0), ct = 174 - (ce ? 49 : 0) - (re ? 32 : 0) + (J ? 32 : 0) + (W ? 37 : 0), bt = bufferutils_1$2.BufferWriter.withCapacity(ct);
    if (bt.writeUInt8(V), bt.writeInt32(this.version), bt.writeUInt32(this.locktime), bt.writeSlice(ke), bt.writeSlice(Oe), bt.writeSlice(it), bt.writeSlice(at), re || oe || bt.writeSlice(ut), bt.writeUInt8(dt), ce) {
      const vt = this.ins[B];
      bt.writeSlice(vt.hash), bt.writeUInt32(vt.index), bt.writeUInt64(K[B]), bt.writeVarSlice(L[B]), bt.writeUInt32(vt.sequence);
    } else
      bt.writeUInt32(B);
    if (J) {
      const vt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(J)
      );
      vt.writeVarSlice(J), bt.writeSlice(bcrypto$1.sha256(vt.end()));
    }
    return oe && bt.writeSlice(ut), W && (bt.writeSlice(W), bt.writeUInt8(0), bt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), bt.end()])
    );
  }
  hashForWitnessV0(B, L, K, V) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let W = Buffer$1.from([]), J, ne = ZERO, ie = ZERO, ce = ZERO;
    if (V & Transaction.SIGHASH_ANYONECANPAY || (W = Buffer$1.allocUnsafe(36 * this.ins.length), J = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((oe) => {
      J.writeSlice(oe.hash), J.writeUInt32(oe.index);
    }), ie = bcrypto$1.hash256(W)), !(V & Transaction.SIGHASH_ANYONECANPAY) && (V & 31) !== Transaction.SIGHASH_SINGLE && (V & 31) !== Transaction.SIGHASH_NONE && (W = Buffer$1.allocUnsafe(4 * this.ins.length), J = new bufferutils_1$2.BufferWriter(W, 0), this.ins.forEach((oe) => {
      J.writeUInt32(oe.sequence);
    }), ce = bcrypto$1.hash256(W)), (V & 31) !== Transaction.SIGHASH_SINGLE && (V & 31) !== Transaction.SIGHASH_NONE) {
      const oe = this.outs.reduce((ke, Oe) => ke + 8 + varSliceSize(Oe.script), 0);
      W = Buffer$1.allocUnsafe(oe), J = new bufferutils_1$2.BufferWriter(W, 0), this.outs.forEach((ke) => {
        J.writeUInt64(ke.value), J.writeVarSlice(ke.script);
      }), ne = bcrypto$1.hash256(W);
    } else if ((V & 31) === Transaction.SIGHASH_SINGLE && B < this.outs.length) {
      const oe = this.outs[B];
      W = Buffer$1.allocUnsafe(8 + varSliceSize(oe.script)), J = new bufferutils_1$2.BufferWriter(W, 0), J.writeUInt64(oe.value), J.writeVarSlice(oe.script), ne = bcrypto$1.hash256(W);
    }
    W = Buffer$1.allocUnsafe(156 + varSliceSize(L)), J = new bufferutils_1$2.BufferWriter(W, 0);
    const re = this.ins[B];
    return J.writeInt32(this.version), J.writeSlice(ie), J.writeSlice(ce), J.writeSlice(re.hash), J.writeUInt32(re.index), J.writeVarSlice(L), J.writeUInt64(K), J.writeUInt32(re.sequence), J.writeSlice(ne), J.writeUInt32(this.locktime), J.writeUInt32(V), bcrypto$1.hash256(W);
  }
  getHash(B) {
    return B && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, B));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(B, L) {
    return this.__toBuffer(B, L, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[B].script = L;
  }
  setWitness(B, L) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[B].witness = L;
  }
  __toBuffer(B, L, K = !1) {
    B || (B = Buffer$1.allocUnsafe(this.byteLength(K)));
    const V = new bufferutils_1$2.BufferWriter(
      B,
      L || 0
    );
    V.writeInt32(this.version);
    const W = K && this.hasWitnesses();
    return W && (V.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), V.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), V.writeVarInt(this.ins.length), this.ins.forEach((J) => {
      V.writeSlice(J.hash), V.writeUInt32(J.index), V.writeVarSlice(J.script), V.writeUInt32(J.sequence);
    }), V.writeVarInt(this.outs.length), this.outs.forEach((J) => {
      isOutput(J) ? V.writeUInt64(J.value) : V.writeSlice(J.valueBuffer), V.writeVarSlice(J.script);
    }), W && this.ins.forEach((J) => {
      V.writeVector(J.witness);
    }), V.writeUInt32(this.locktime), L !== void 0 ? B.slice(L, V.offset) : B;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(B) {
    if (B.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const L = new bufferutils_1$1.BufferReader(B), K = new Block();
    if (K.version = L.readInt32(), K.prevHash = L.readSlice(32), K.merkleRoot = L.readSlice(32), K.timestamp = L.readUInt32(), K.bits = L.readUInt32(), K.nonce = L.readUInt32(), B.length === 80) return K;
    const V = () => {
      const ne = transaction_1$3.Transaction.fromBuffer(
        L.buffer.slice(L.offset),
        !0
      );
      return L.offset += ne.byteLength(), ne;
    }, W = L.readVarInt();
    K.transactions = [];
    for (let ne = 0; ne < W; ++ne) {
      const ie = V();
      K.transactions.push(ie);
    }
    const J = K.getWitnessCommit();
    return J && (K.witnessCommit = J), K;
  }
  static fromHex(B) {
    return Block.fromBuffer(Buffer$1.from(B, "hex"));
  }
  static calculateTarget(B) {
    const L = ((B & 4278190080) >> 24) - 3, K = B & 8388607, V = Buffer$1.alloc(32, 0);
    return V.writeUIntBE(K, 29 - L, 3), V;
  }
  static calculateMerkleRoot(B, L) {
    if (typeforce([{ getHash: types.Function }], B), B.length === 0) throw errorMerkleNoTxes;
    if (L && !txesHaveWitnessCommit(B))
      throw errorWitnessNotSegwit;
    const K = B.map(
      (W) => W.getHash(L)
    ), V = (0, merkle_1.fastMerkleRoot)(K, bcrypto.hash256);
    return L ? bcrypto.hash256(
      Buffer$1.concat([V, B[0].ins[0].witness[0]])
    ) : V;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const B = this.transactions[0].outs.filter(
      (K) => K.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((K) => K.script.slice(6, 38));
    if (B.length === 0) return null;
    const L = B[B.length - 1];
    return L instanceof Buffer$1 && L.length === 32 ? L : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const B = this.byteLength(!1, !1), L = this.byteLength(!1, !0);
    return B * 3 + L;
  }
  byteLength(B, L = !0) {
    return B || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((K, V) => K + V.byteLength(L), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const B = /* @__PURE__ */ new Date(0);
    return B.setUTCSeconds(this.timestamp), B;
  }
  // TODO: buffer, offset compatibility
  toBuffer(B) {
    const L = Buffer$1.allocUnsafe(this.byteLength(B)), K = new bufferutils_1$1.BufferWriter(L);
    return K.writeInt32(this.version), K.writeSlice(this.prevHash), K.writeSlice(this.merkleRoot), K.writeUInt32(this.timestamp), K.writeUInt32(this.bits), K.writeUInt32(this.nonce), B || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      L,
      K.offset
    ), K.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((V) => {
      const W = V.byteLength();
      V.toBuffer(L, K.offset), K.offset += W;
    })), L;
  }
  toHex(B) {
    return this.toBuffer(B).toString("hex");
  }
  checkTxRoots() {
    const B = this.hasWitnessCommit();
    return !B && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (B ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const B = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), L = Block.calculateTarget(this.bits);
    return B.compare(L) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const B = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(B) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const B = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(B) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(A) {
  return A instanceof Array && A[0] && A[0].ins && A[0].ins instanceof Array && A[0].ins[0] && A[0].ins[0].witness && A[0].ins[0].witness instanceof Array && A[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(A) {
  return A instanceof Array && A.some(
    (B) => typeof B == "object" && B.ins instanceof Array && B.ins.some(
      (L) => typeof L == "object" && L.witness instanceof Array && L.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), function(B) {
    B[B.UNSIGNED_TX = 0] = "UNSIGNED_TX", B[B.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(A.GlobalTypes || (A.GlobalTypes = {})), A.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(B) {
    B[B.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", B[B.WITNESS_UTXO = 1] = "WITNESS_UTXO", B[B.PARTIAL_SIG = 2] = "PARTIAL_SIG", B[B.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", B[B.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", B[B.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", B[B.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", B[B.POR_COMMITMENT = 9] = "POR_COMMITMENT", B[B.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", B[B.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", B[B.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", B[B.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", B[B.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(A.InputTypes || (A.InputTypes = {})), A.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(B) {
    B[B.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", B[B.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", B[B.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", B[B.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", B[B.TAP_TREE = 6] = "TAP_TREE", B[B.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(A.OutputTypes || (A.OutputTypes = {})), A.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (A) => [...Array(A).keys()];
function decode$d(A) {
  if (A.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 79 || ![2, 3].includes(A.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + A.key.toString("hex")
    );
  if (A.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const B = A.key.slice(1), L = {
    masterFingerprint: A.value.slice(0, 4),
    extendedPubkey: B,
    path: "m"
  };
  for (const K of range$2(A.value.length / 4 - 1)) {
    const V = A.value.readUInt32LE(K * 4 + 4), W = !!(V & 2147483648), J = V & 2147483647;
    L.path += "/" + J.toString(10) + (W ? "'" : "");
  }
  return L;
}
globalXpub$1.decode = decode$d;
function encode$e(A) {
  const B = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), L = Buffer$1.concat([B, A.extendedPubkey]), K = A.path.split("/"), V = Buffer$1.allocUnsafe(K.length * 4);
  A.masterFingerprint.copy(V, 0);
  let W = 4;
  return K.slice(1).forEach((J) => {
    const ne = J.slice(-1) === "'";
    let ie = 2147483647 & parseInt(ne ? J.slice(0, -1) : J, 10);
    ne && (ie += 2147483648), V.writeUInt32LE(ie, W), W += 4;
  }), {
    key: L,
    value: V
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(A) {
  const B = A.extendedPubkey, L = A.masterFingerprint, K = A.path;
  return Buffer$1.isBuffer(B) && B.length === 78 && [2, 3].indexOf(B[45]) > -1 && Buffer$1.isBuffer(L) && L.length === 4 && typeof K == "string" && !!K.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(A, B, L) {
  const K = B.extendedPubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((V) => V.extendedPubkey.equals(B.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(A) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: A.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(A) {
  if (A.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(A) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: A
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptSig$1.check = check$b;
function canAdd$8(A, B) {
  return !!A && !!B && A.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(A) {
  if (A.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(A) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: A
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(A) {
  return Buffer$1.isBuffer(A);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(A, B) {
  return !!A && !!B && A.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(A) {
  if (A.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + A.key.toString("hex")
    );
  return A.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(A) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: A
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(A) {
  return Buffer$1.isBuffer(A);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(A, B) {
  return !!A && !!B && A.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(A) {
  if (A.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + A.key.toString("hex")
    );
  if (!(A.key.length === 34 || A.key.length === 66) || ![2, 3, 4].includes(A.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + A.key.toString("hex")
    );
  return {
    pubkey: A.key.slice(1),
    signature: A.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(A) {
  const B = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey]),
    value: A.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.signature) && [33, 65].includes(A.pubkey.length) && [2, 3, 4].includes(A.pubkey[0]) && isDerSigWithSighash(A.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(A) {
  if (!Buffer$1.isBuffer(A) || A.length < 9 || A[0] !== 48 || A.length !== A[1] + 3 || A[2] !== 2) return !1;
  const B = A[3];
  if (B > 33 || B < 1 || A[3 + B + 1] !== 2) return !1;
  const L = A[3 + B + 2];
  return !(L > 33 || L < 1 || A.length !== 3 + B + 2 + L + 2);
}
function canAddToArray$2(A, B, L) {
  const K = B.pubkey.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((V) => V.pubkey.equals(B.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(A) {
  if (A.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + A.key.toString("hex")
    );
  return A.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(A) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(A, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(A) {
  return typeof A == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(A, B) {
  return !!A && !!B && A.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(A) {
  if (A.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + A.key.toString("hex")
    );
  return A.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(A) {
  const B = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), L = Buffer$1.allocUnsafe(4);
  return L.writeUInt32LE(A, 0), {
    key: B,
    value: L
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(A) {
  return typeof A == "number";
}
sighashType$1.check = check$6;
function canAdd$4(A, B) {
  return !!A && !!B && A.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(A) {
  if (A.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + A.key.toString("hex")
    );
  if (!check$5(A.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return A.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(A) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: A };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(A) {
  return Buffer$1.isBuffer(A) && (A.length === 64 || A.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(A, B) {
  return !!A && !!B && A.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(A) {
  if (A.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + A.key.toString("hex")
    );
  if ((A.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + A.key.toString("hex")
    );
  const B = A.value[A.value.length - 1];
  if ((A.key[1] & 254) !== B)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + A.key.toString("hex")
    );
  const L = A.value.slice(0, -1);
  return { controlBlock: A.key.slice(1), script: L, leafVersion: B };
}
tapLeafScript$1.decode = decode$5;
function encode$5(A) {
  const B = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), L = Buffer$1.from([A.leafVersion]);
  return {
    key: Buffer$1.concat([B, A.controlBlock]),
    value: Buffer$1.concat([A.script, L])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(A) {
  return Buffer$1.isBuffer(A.controlBlock) && (A.controlBlock.length - 1) % 32 === 0 && (A.controlBlock[0] & 254) === A.leafVersion && Buffer$1.isBuffer(A.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(A, B, L) {
  const K = B.controlBlock.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter((V) => V.controlBlock.equals(B.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(A) {
  if (A.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + A.key.toString("hex")
    );
  if (!check$3(A.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return A.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(A) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: A };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(A) {
  return Buffer$1.isBuffer(A) && A.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(A, B) {
  return !!A && !!B && A.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(A) {
  if (A.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + A.key.toString("hex")
    );
  if (A.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + A.key.toString("hex")
    );
  if (A.value.length !== 64 && A.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + A.key.toString("hex")
    );
  const B = A.key.slice(1, 33), L = A.key.slice(33);
  return {
    pubkey: B,
    leafHash: L,
    signature: A.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(A) {
  const B = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([B, A.pubkey, A.leafHash]),
    value: A.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(A) {
  return Buffer$1.isBuffer(A.pubkey) && Buffer$1.isBuffer(A.leafHash) && Buffer$1.isBuffer(A.signature) && A.pubkey.length === 32 && A.leafHash.length === 32 && (A.signature.length === 64 || A.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(A, B, L) {
  const K = B.pubkey.toString("hex") + B.leafHash.toString("hex");
  return L.has(K) ? !1 : (L.add(K), A.filter(
    (V) => V.pubkey.equals(B.pubkey) && V.leafHash.equals(B.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(A) {
  if (A < 0 || A > MAX_SAFE_INTEGER || A % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(A, B, L) {
  if (checkUInt53(A), B || (B = Buffer$1.allocUnsafe(encodingLength(A))), !Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  return L || (L = 0), A < 253 ? (B.writeUInt8(A, L), Object.assign(encode$2, { bytes: 1 })) : A <= 65535 ? (B.writeUInt8(253, L), B.writeUInt16LE(A, L + 1), Object.assign(encode$2, { bytes: 3 })) : A <= 4294967295 ? (B.writeUInt8(254, L), B.writeUInt32LE(A, L + 1), Object.assign(encode$2, { bytes: 5 })) : (B.writeUInt8(255, L), B.writeUInt32LE(A >>> 0, L + 1), B.writeUInt32LE(A / 4294967296 | 0, L + 5), Object.assign(encode$2, { bytes: 9 })), B;
}
varint.encode = encode$2;
function decode$2(A, B) {
  if (!Buffer$1.isBuffer(A))
    throw new TypeError("buffer must be a Buffer instance");
  B || (B = 0);
  const L = A.readUInt8(B);
  if (L < 253)
    return Object.assign(decode$2, { bytes: 1 }), L;
  if (L === 253)
    return Object.assign(decode$2, { bytes: 3 }), A.readUInt16LE(B + 1);
  if (L === 254)
    return Object.assign(decode$2, { bytes: 5 }), A.readUInt32LE(B + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const K = A.readUInt32LE(B + 1), W = A.readUInt32LE(B + 5) * 4294967296 + K;
    return checkUInt53(W), W;
  }
}
varint.decode = decode$2;
function encodingLength(A) {
  return checkUInt53(A), A < 253 ? 1 : A <= 65535 ? 3 : A <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (A) => [...Array(A).keys()];
function reverseBuffer(A) {
  if (A.length < 1) return A;
  let B = A.length - 1, L = 0;
  for (let K = 0; K < A.length / 2; K++)
    L = A[K], A[K] = A[B], A[B] = L, B--;
  return A;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(A) {
  const B = A.map(keyValToBuffer);
  return B.push(Buffer$1.from([0])), Buffer$1.concat(B);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(A) {
  const B = A.key.length, L = A.value.length, K = varuint$6.encodingLength(B), V = varuint$6.encodingLength(L), W = Buffer$1.allocUnsafe(
    K + B + V + L
  );
  return varuint$6.encode(B, W, 0), A.key.copy(W, K), varuint$6.encode(L, W, K + B), A.value.copy(W, K + B + V), W;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(A, B) {
  if (typeof A != "number")
    throw new Error("cannot write a non-number as a number");
  if (A < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (A > B) throw new Error("RangeError: value out of range");
  if (Math.floor(A) !== A)
    throw new Error("value has a fractional component");
}
function readUInt64LE(A, B) {
  const L = A.readUInt32LE(B);
  let K = A.readUInt32LE(B + 4);
  return K *= 4294967296, verifuint(K + L, 9007199254740991), K + L;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(A, B, L) {
  return verifuint(B, 9007199254740991), A.writeInt32LE(B & -1, L), A.writeUInt32LE(Math.floor(B / 4294967296), L + 4), L + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(A) {
  if (A.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + A.key.toString("hex")
    );
  const B = tools_1$2.readUInt64LE(A.value, 0);
  let L = 8;
  const K = varuint$5.decode(A.value, L);
  L += varuint$5.encodingLength(K);
  const V = A.value.slice(L);
  if (V.length !== K)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: V,
    value: B
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(A) {
  const { script: B, value: L } = A, K = varuint$5.encodingLength(B.length), V = Buffer$1.allocUnsafe(8 + K + B.length);
  return tools_1$2.writeUInt64LE(V, L, 0), varuint$5.encode(B.length, V, 8), B.copy(V, 8 + K), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: V
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(A) {
  return Buffer$1.isBuffer(A.script) && typeof A.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(A, B) {
  return !!A && !!B && A.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(A) {
  if (A.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || A.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + A.key.toString("hex")
    );
  let B = 0;
  const L = [];
  for (; B < A.value.length; ) {
    const K = A.value[B++], V = A.value[B++], W = varuint$4.decode(A.value, B);
    B += varuint$4.encodingLength(W), L.push({
      depth: K,
      leafVersion: V,
      script: A.value.slice(B, B + W)
    }), B += W;
  }
  return { leaves: L };
}
tapTree$1.decode = decode;
function encode(A) {
  const B = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), L = [].concat(
    ...A.leaves.map((K) => [
      Buffer$1.of(K.depth, K.leafVersion),
      varuint$4.encode(K.script.length),
      K.script
    ])
  );
  return {
    key: B,
    value: Buffer$1.concat(L)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(A) {
  return Array.isArray(A.leaves) && A.leaves.every(
    (B) => B.depth >= 0 && B.depth <= 128 && (B.leafVersion & 254) === B.leafVersion && Buffer$1.isBuffer(B.script)
  );
}
tapTree$1.check = check;
function canAdd(A, B) {
  return !!A && !!B && A.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (A) => [...Array(A).keys()], isValidDERKey = (A) => A.length === 33 && [2, 3].includes(A[0]) || A.length === 65 && A[0] === 4;
function makeConverter$4(A, B = isValidDERKey) {
  function L(ne) {
    if (ne.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + ne.key.toString("hex")
      );
    const ie = ne.key.slice(1);
    if (!B(ie))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + ne.key.toString("hex")
      );
    if (ne.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const ce = {
      masterFingerprint: ne.value.slice(0, 4),
      pubkey: ie,
      path: "m"
    };
    for (const re of range$1(ne.value.length / 4 - 1)) {
      const oe = ne.value.readUInt32LE(re * 4 + 4), ke = !!(oe & 2147483648), Oe = oe & 2147483647;
      ce.path += "/" + Oe.toString(10) + (ke ? "'" : "");
    }
    return ce;
  }
  function K(ne) {
    const ie = Buffer$1.from([A]), ce = Buffer$1.concat([ie, ne.pubkey]), re = ne.path.split("/"), oe = Buffer$1.allocUnsafe(re.length * 4);
    ne.masterFingerprint.copy(oe, 0);
    let ke = 4;
    return re.slice(1).forEach((Oe) => {
      const it = Oe.slice(-1) === "'";
      let at = 2147483647 & parseInt(it ? Oe.slice(0, -1) : Oe, 10);
      it && (at += 2147483648), oe.writeUInt32LE(at, ke), ke += 4;
    }), {
      key: ce,
      value: oe
    };
  }
  const V = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function W(ne) {
    return Buffer$1.isBuffer(ne.pubkey) && Buffer$1.isBuffer(ne.masterFingerprint) && typeof ne.path == "string" && B(ne.pubkey) && ne.masterFingerprint.length === 4;
  }
  function J(ne, ie, ce) {
    const re = ie.pubkey.toString("hex");
    return ce.has(re) ? !1 : (ce.add(re), ne.filter((oe) => oe.pubkey.equals(ie.pubkey)).length === 0);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: V,
    canAddToArray: J
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(A) {
  return B;
  function B(L) {
    let K;
    if (A.includes(L.key[0]) && (K = L.key.slice(1), !(K.length === 33 || K.length === 65) || ![2, 3, 4].includes(K[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + L.key.toString("hex")
      );
    return K;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(A) {
  function B(J) {
    if (J.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + J.key.toString("hex")
      );
    return J.value;
  }
  function L(J) {
    return {
      key: Buffer$1.from([A]),
      value: J
    };
  }
  const K = "Buffer";
  function V(J) {
    return Buffer$1.isBuffer(J);
  }
  function W(J, ne) {
    return !!J && !!ne && J.redeemScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: V,
    expected: K,
    canAdd: W
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (A) => A.length === 32;
function makeConverter$2(A) {
  const B = bip32Derivation$1.makeConverter(A, isValidBIP340Key);
  function L(J) {
    const ne = varuint$3.decode(J.value), ie = varuint$3.encodingLength(ne), ce = B.decode({
      key: J.key,
      value: J.value.slice(ie + ne * 32)
    }), re = new Array(ne);
    for (let oe = 0, ke = ie; oe < ne; oe++, ke += 32)
      re[oe] = J.value.slice(ke, ke + 32);
    return Object.assign({}, ce, { leafHashes: re });
  }
  function K(J) {
    const ne = B.encode(J), ie = varuint$3.encodingLength(J.leafHashes.length), ce = Buffer$1.allocUnsafe(ie);
    varuint$3.encode(J.leafHashes.length, ce);
    const re = Buffer$1.concat([ce, ...J.leafHashes, ne.value]);
    return Object.assign({}, ne, { value: re });
  }
  const V = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function W(J) {
    return Array.isArray(J.leafHashes) && J.leafHashes.every(
      (ne) => Buffer$1.isBuffer(ne) && ne.length === 32
    ) && B.check(J);
  }
  return {
    decode: L,
    encode: K,
    check: W,
    expected: V,
    canAddToArray: B.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(A) {
  function B(J) {
    if (J.key[0] !== A || J.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + J.key.toString("hex")
      );
    if (J.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return J.value;
  }
  function L(J) {
    return { key: Buffer$1.from([A]), value: J };
  }
  const K = "Buffer";
  function V(J) {
    return Buffer$1.isBuffer(J) && J.length === 32;
  }
  function W(J, ne) {
    return !!J && !!ne && J.tapInternalKey === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: V,
    expected: K,
    canAdd: W
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(A) {
  function B(J) {
    if (J.key[0] !== A)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + J.key.toString("hex")
      );
    return J.value;
  }
  function L(J) {
    return {
      key: Buffer$1.from([A]),
      value: J
    };
  }
  const K = "Buffer";
  function V(J) {
    return Buffer$1.isBuffer(J);
  }
  function W(J, ne) {
    return !!J && !!ne && J.witnessScript === void 0;
  }
  return {
    decode: B,
    encode: L,
    check: V,
    expected: K,
    canAdd: W
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(A, B) {
  let L = 0;
  function K() {
    const ut = varuint$2.decode(A, L);
    L += varuint$2.encodingLength(ut);
    const dt = A.slice(L, L + ut);
    return L += ut, dt;
  }
  function V() {
    const ut = A.readUInt32BE(L);
    return L += 4, ut;
  }
  function W() {
    const ut = A.readUInt8(L);
    return L += 1, ut;
  }
  function J() {
    const ut = K(), dt = K();
    return {
      key: ut,
      value: dt
    };
  }
  function ne() {
    if (L >= A.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const ut = A.readUInt8(L) === 0;
    return ut && L++, ut;
  }
  if (V() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (W() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ie = [], ce = {};
  for (; !ne(); ) {
    const ut = J(), dt = ut.key.toString("hex");
    if (ce[dt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + dt
      );
    ce[dt] = 1, ie.push(ut);
  }
  const re = ie.filter(
    (ut) => ut.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (re.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const oe = B(re[0].value), { inputCount: ke, outputCount: Oe } = oe.getInputOutputCounts(), it = [], at = [];
  for (const ut of tools_1$1.range(ke)) {
    const dt = {}, ct = [];
    for (; !ne(); ) {
      const bt = J(), vt = bt.key.toString("hex");
      if (dt[vt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + ut + " key " + vt
        );
      dt[vt] = 1, ct.push(bt);
    }
    it.push(ct);
  }
  for (const ut of tools_1$1.range(Oe)) {
    const dt = {}, ct = [];
    for (; !ne(); ) {
      const bt = J(), vt = bt.key.toString("hex");
      if (dt[vt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + ut + " key " + vt
        );
      dt[vt] = 1, ct.push(bt);
    }
    at.push(ct);
  }
  return psbtFromKeyVals(oe, {
    globalMapKeyVals: ie,
    inputKeyVals: it,
    outputKeyVals: at
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(A, B, L) {
  if (!B.equals(Buffer$1.from([L])))
    throw new Error(
      `Format Error: Invalid ${A} key: ${B.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(A, { globalMapKeyVals: B, inputKeyVals: L, outputKeyVals: K }) {
  const V = {
    unsignedTx: A
  };
  let W = 0;
  for (const re of B)
    switch (re.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          re.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), W > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        W++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        V.globalXpub === void 0 && (V.globalXpub = []), V.globalXpub.push(convert$1.globals.globalXpub.decode(re));
        break;
      default:
        V.unknownKeyVals || (V.unknownKeyVals = []), V.unknownKeyVals.push(re);
    }
  const J = L.length, ne = K.length, ie = [], ce = [];
  for (const re of tools_1$1.range(J)) {
    const oe = {};
    for (const ke of L[re])
      switch (convert$1.inputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), oe.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          oe.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), oe.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          oe.witnessUtxo = convert$1.inputs.witnessUtxo.decode(ke);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          oe.partialSig === void 0 && (oe.partialSig = []), oe.partialSig.push(convert$1.inputs.partialSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), oe.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          oe.sighashType = convert$1.inputs.sighashType.decode(ke);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), oe.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          oe.redeemScript = convert$1.inputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), oe.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          oe.witnessScript = convert$1.inputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          oe.bip32Derivation === void 0 && (oe.bip32Derivation = []), oe.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), oe.finalScriptSig = convert$1.inputs.finalScriptSig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), oe.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            ke
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), oe.porCommitment = convert$1.inputs.porCommitment.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), oe.tapKeySig = convert$1.inputs.tapKeySig.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          oe.tapScriptSig === void 0 && (oe.tapScriptSig = []), oe.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          oe.tapLeafScript === void 0 && (oe.tapLeafScript = []), oe.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(ke));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          oe.tapBip32Derivation === void 0 && (oe.tapBip32Derivation = []), oe.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), oe.tapInternalKey = convert$1.inputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            ke.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), oe.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(ke);
          break;
        default:
          oe.unknownKeyVals || (oe.unknownKeyVals = []), oe.unknownKeyVals.push(ke);
      }
    ie.push(oe);
  }
  for (const re of tools_1$1.range(ne)) {
    const oe = {};
    for (const ke of K[re])
      switch (convert$1.outputs.checkPubkey(ke), ke.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), oe.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          oe.redeemScript = convert$1.outputs.redeemScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), oe.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          oe.witnessScript = convert$1.outputs.witnessScript.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          oe.bip32Derivation === void 0 && (oe.bip32Derivation = []), oe.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(ke)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), oe.tapInternalKey = convert$1.outputs.tapInternalKey.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            ke.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), oe.tapTree = convert$1.outputs.tapTree.decode(ke);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          oe.tapBip32Derivation === void 0 && (oe.tapBip32Derivation = []), oe.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(ke)
          );
          break;
        default:
          oe.unknownKeyVals || (oe.unknownKeyVals = []), oe.unknownKeyVals.push(ke);
      }
    ce.push(oe);
  }
  return { globalMap: V, inputs: ie, outputs: ce };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: A, inputs: B, outputs: L }) {
  const { globalKeyVals: K, inputKeyVals: V, outputKeyVals: W } = psbtToKeyVals({
    globalMap: A,
    inputs: B,
    outputs: L
  }), J = tools_1.keyValsToBuffer(K), ne = (oe) => oe.length === 0 ? [Buffer$1.from([0])] : oe.map(tools_1.keyValsToBuffer), ie = ne(V), ce = ne(W), re = Buffer$1.allocUnsafe(5);
  return re.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [re, J].concat(ie, ce)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (A, B) => A.key.compare(B.key);
function keyValsFromMap(A, B) {
  const L = /* @__PURE__ */ new Set(), K = Object.entries(A).reduce((W, [J, ne]) => {
    if (J === "unknownKeyVals") return W;
    const ie = B[J];
    if (ie === void 0) return W;
    const ce = (Array.isArray(ne) ? ne : [ne]).map(
      ie.encode
    );
    return ce.map((oe) => oe.key.toString("hex")).forEach((oe) => {
      if (L.has(oe))
        throw new Error("Serialize Error: Duplicate key: " + oe);
      L.add(oe);
    }), W.concat(ce);
  }, []), V = A.unknownKeyVals ? A.unknownKeyVals.filter((W) => !L.has(W.key.toString("hex"))) : [];
  return K.concat(V).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: A, inputs: B, outputs: L }) {
  return {
    globalKeyVals: keyValsFromMap(A, convert.globals),
    inputKeyVals: B.map((K) => keyValsFromMap(K, convert.inputs)),
    outputKeyVals: L.map((K) => keyValsFromMap(K, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(A) {
  function B(L) {
    for (var K in L) A.hasOwnProperty(K) || (A[K] = L[K]);
  }
  Object.defineProperty(A, "__esModule", { value: !0 }), B(fromBuffer), B(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(A) {
  const B = A[0], L = parser_1$1.psbtToKeyVals(B), K = A.slice(1);
  if (K.length === 0) throw new Error("Combine: Nothing to combine");
  const V = getTx(B);
  if (V === void 0)
    throw new Error("Combine: Self missing transaction");
  const W = getKeySet(L.globalKeyVals), J = L.inputKeyVals.map(getKeySet), ne = L.outputKeyVals.map(getKeySet);
  for (const ie of K) {
    const ce = getTx(ie);
    if (ce === void 0 || !ce.toBuffer().equals(V.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const re = parser_1$1.psbtToKeyVals(ie);
    getKeySet(re.globalKeyVals).forEach(
      keyPusher(
        W,
        L.globalKeyVals,
        re.globalKeyVals
      )
    ), re.inputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          J[at],
          L.inputKeyVals[at],
          re.inputKeyVals[at]
        )
      )
    ), re.outputKeyVals.map(getKeySet).forEach(
      (it, at) => it.forEach(
        keyPusher(
          ne[at],
          L.outputKeyVals[at],
          re.outputKeyVals[at]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(V, {
    globalMapKeyVals: L.globalKeyVals,
    inputKeyVals: L.inputKeyVals,
    outputKeyVals: L.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(A, B, L) {
  return (K) => {
    if (A.has(K)) return;
    const V = L.filter((W) => W.key.toString("hex") === K)[0];
    B.push(V), A.add(K);
  };
}
function getTx(A) {
  return A.globalMap.unsignedTx;
}
function getKeySet(A) {
  const B = /* @__PURE__ */ new Set();
  return A.forEach((L) => {
    const K = L.key.toString("hex");
    if (B.has(K))
      throw new Error("Combine: KeyValue Map keys should be unique");
    B.add(K);
  }), B;
}
var utils = {};
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 });
  const B = converter;
  function L(Oe, it) {
    const at = Oe[it];
    if (at === void 0) throw new Error(`No input #${it}`);
    return at;
  }
  A.checkForInput = L;
  function K(Oe, it) {
    const at = Oe[it];
    if (at === void 0) throw new Error(`No output #${it}`);
    return at;
  }
  A.checkForOutput = K;
  function V(Oe, it, at) {
    if (Oe.key[0] < at)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (it && it.filter((ut) => ut.key.equals(Oe.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Oe.key.toString("hex")}`);
  }
  A.checkHasKey = V;
  function W(Oe) {
    let it = 0;
    return Object.keys(Oe).forEach((at) => {
      Number(isNaN(Number(at))) && it++;
    }), it;
  }
  A.getEnumLength = W;
  function J(Oe, it) {
    let at = !1;
    if (it.nonWitnessUtxo || it.witnessUtxo) {
      const ut = !!it.redeemScript, dt = !!it.witnessScript, ct = !ut || !!it.finalScriptSig, bt = !dt || !!it.finalScriptWitness, vt = !!it.finalScriptSig || !!it.finalScriptWitness;
      at = ct && bt && vt;
    }
    if (at === !1)
      throw new Error(
        `Input #${Oe} has too much or too little data to clean`
      );
  }
  A.inputCheckUncleanFinalized = J;
  function ne(Oe, it, at, ut) {
    throw new Error(
      `Data for ${Oe} key ${it} is incorrect: Expected ${at} and got ${JSON.stringify(ut)}`
    );
  }
  function ie(Oe) {
    return (it, at) => {
      for (const ut of Object.keys(it)) {
        const dt = it[ut], { canAdd: ct, canAddToArray: bt, check: vt, expected: $t } = (
          // @ts-ignore
          B[Oe + "s"][ut] || {}
        ), xt = !!bt;
        if (vt)
          if (xt) {
            if (!Array.isArray(dt) || // @ts-ignore
            at[ut] && !Array.isArray(at[ut]))
              throw new Error(`Key type ${ut} must be an array`);
            dt.every(vt) || ne(Oe, ut, $t, dt);
            const Ot = at[ut] || [], At = /* @__PURE__ */ new Set();
            if (!dt.every((yt) => bt(Ot, yt, At)))
              throw new Error("Can not add duplicate data to array");
            at[ut] = Ot.concat(dt);
          } else {
            if (vt(dt) || ne(Oe, ut, $t, dt), !ct(at, dt))
              throw new Error(`Can not add duplicate data to ${Oe}`);
            at[ut] = dt;
          }
      }
    };
  }
  A.updateGlobal = ie("global"), A.updateInput = ie("input"), A.updateOutput = ie("output");
  function ce(Oe, it) {
    const at = Oe.length - 1, ut = L(Oe, at);
    A.updateInput(it, ut);
  }
  A.addInputAttributes = ce;
  function re(Oe, it) {
    const at = Oe.length - 1, ut = K(Oe, at);
    A.updateOutput(it, ut);
  }
  A.addOutputAttributes = re;
  function oe(Oe, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return it.writeUInt32LE(Oe, 0), it;
  }
  A.defaultVersionSetter = oe;
  function ke(Oe, it) {
    if (!Buffer$1.isBuffer(it) || it.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return it.writeUInt32LE(Oe, it.length - 4), it;
  }
  A.defaultLocktimeSetter = ke;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(B) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: B
    };
  }
  static fromBase64(B, L) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L) {
    const K = parser_1.psbtFromBuffer(B, L), V = new this(K.globalMap.unsignedTx);
    return Object.assign(V, K), V;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(B) {
    return utils_1$1.updateGlobal(B, this.globalMap), this;
  }
  updateInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.updateInput(L, K), this;
  }
  updateOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.updateOutput(L, K), this;
  }
  addUnknownKeyValToGlobal(B) {
    return utils_1$1.checkHasKey(
      B,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    const K = utils_1$1.checkForInput(this.inputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    const K = utils_1$1.checkForOutput(this.outputs, B);
    return utils_1$1.checkHasKey(
      L,
      K.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), K.unknownKeyVals || (K.unknownKeyVals = []), K.unknownKeyVals.push(L), this;
  }
  addInput(B) {
    this.globalMap.unsignedTx.addInput(B), this.inputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.inputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (V) => this.addUnknownKeyValToInput(K, V)
    ), utils_1$1.addInputAttributes(this.inputs, B), this;
  }
  addOutput(B) {
    this.globalMap.unsignedTx.addOutput(B), this.outputs.push({
      unknownKeyVals: []
    });
    const L = B.unknownKeyVals || [], K = this.outputs.length - 1;
    if (!Array.isArray(L))
      throw new Error("unknownKeyVals must be an Array");
    return L.forEach(
      (V) => this.addUnknownKeyValToOutput(K, V)
    ), utils_1$1.addOutputAttributes(this.outputs, B), this;
  }
  clearFinalizedInput(B) {
    const L = utils_1$1.checkForInput(this.inputs, B);
    utils_1$1.inputCheckUncleanFinalized(B, L);
    for (const K of Object.keys(L))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(K) || delete L[K];
    return this;
  }
  combine(...B) {
    const L = combiner_1.combine([this].concat(B));
    return Object.assign(this, L), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(A) {
  return (B) => {
    try {
      return A({ output: B }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(A) {
  let B = Buffer$1.allocUnsafe(0);
  function L(J) {
    B = Buffer$1.concat([B, Buffer$1.from(J)]);
  }
  function K(J) {
    const ne = B.length, ie = varuint$1.encodingLength(J);
    B = Buffer$1.concat([B, Buffer$1.allocUnsafe(ie)]), varuint$1.encode(J, B, ne);
  }
  function V(J) {
    K(J.length), L(J);
  }
  function W(J) {
    K(J.length), J.forEach(V);
  }
  return W(A), B;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(A, B) {
  const L = (0, crypto_1.hash160)(A), K = A.slice(1, 33), V = bscript$1.decompile(B);
  if (V === null) throw new Error("Unknown script error");
  return V.findIndex((W) => typeof W == "number" ? !1 : W.equals(A) || W.equals(L) || W.equals(K));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(A, B) {
  return pubkeyPositionInScript(A, B) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(A, B) {
  return extractPartialSigs(A).some(
    (K) => signatureBlocksAction(K, bscript$1.signature.decode, B)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(A, B, L) {
  const { hashType: K } = B(A), V = [];
  switch (K & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && V.push("addInput"), K & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      V.push("addOutput"), V.push("setInputSequence");
      break;
  }
  return V.indexOf(L) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(A) {
  let B = [];
  if ((A.partialSig || []).length === 0) {
    if (!A.finalScriptSig && !A.finalScriptWitness) return [];
    B = getPsigsFromInputFinalScripts(A);
  } else
    B = A.partialSig;
  return B.map((L) => L.signature);
}
function getPsigsFromInputFinalScripts(A) {
  const B = A.finalScriptSig ? bscript$1.decompile(A.finalScriptSig) || [] : [], L = A.finalScriptWitness ? bscript$1.decompile(A.finalScriptWitness) || [] : [];
  return B.concat(L).filter((K) => Buffer$1.isBuffer(K) && bscript$1.isCanonicalScriptSignature(K)).map((K) => ({ signature: K }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (A) => A.length === 32 ? A : A.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(A, B, L) {
  const K = findTapLeafToFinalize(
    B,
    A,
    L
  );
  try {
    const W = sortSignatures(B, K).concat(K.script).concat(K.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(W)
    };
  } catch (V) {
    throw new Error(`Can not finalize taproot input #${A}: ${V}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(A, B) {
  const L = B ? Buffer$1.from([B]) : Buffer$1.from([]);
  return Buffer$1.concat([A, L]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(A) {
  return A && !!(A.tapInternalKey || A.tapMerkleRoot || A.tapLeafScript && A.tapLeafScript.length || A.tapBip32Derivation && A.tapBip32Derivation.length || A.witnessUtxo && (0, psbtutils_1$1.isP2TR)(A.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(A, B) {
  return A && !!(A.tapInternalKey || A.tapTree || A.tapBip32Derivation && A.tapBip32Derivation.length || B && (0, psbtutils_1$1.isP2TR)(B));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootInputFields(A, B, L), checkIfTapLeafInTree(A, B, L);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(A, B, L) {
  checkMixedTaprootAndNonTaprootOutputFields(A, B, L), checkTaprootScriptPubkey(A, B);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(A, B) {
  if (!B.tapTree && !B.tapInternalKey) return;
  const L = B.tapInternalKey || A.tapInternalKey, K = B.tapTree || A.tapTree;
  if (L) {
    const { script: V } = A, W = getTaprootScripPubkey(L, K);
    if (V && !V.equals(W))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(A, B) {
  const L = B && tapTreeFromList(B.leaves), { output: K } = (0, payments_1.p2tr)({
    internalPubkey: A,
    scriptTree: L
  });
  return K;
}
function tweakInternalPubKey(A, B) {
  const L = B.tapInternalKey, K = L && (0, bip341_1$1.tweakKey)(L, B.tapMerkleRoot);
  if (!K)
    throw new Error(
      `Cannot tweak tap internal key for input #${A}. Public key: ${L && L.toString("hex")}`
    );
  return K.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(A) {
  if (!(0, types_1.isTaptree)(A))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(A);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(A = []) {
  return A.length === 1 && A[0].depth === 0 ? {
    output: A[0].script,
    version: A[0].leafVersion
  } : instertLeavesInTree(A);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(A, B) {
  return extractTaprootSigs(A).some(
    (K) => (0, psbtutils_2.signatureBlocksAction)(K, decodeSchnorrSignature, B)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(A) {
  return {
    signature: A.slice(0, 64),
    hashType: A.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(A) {
  const B = [];
  if (A.tapKeySig && B.push(A.tapKeySig), A.tapScriptSig && B.push(...A.tapScriptSig.map((L) => L.signature)), !B.length) {
    const L = getTapKeySigFromWithness(A.finalScriptWitness);
    L && B.push(L);
  }
  return B;
}
function getTapKeySigFromWithness(A) {
  if (!A) return;
  const B = A.slice(2);
  if (B.length === 64 || B.length === 65) return B;
}
function _tapTreeToList(A, B = [], L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return A ? (0, types_1.isTapleaf)(A) ? (B.push({
    depth: L,
    leafVersion: A.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: A.output
  }), B) : (A[0] && _tapTreeToList(A[0], B, L + 1), A[1] && _tapTreeToList(A[1], B, L + 1), B) : [];
}
function instertLeavesInTree(A) {
  let B;
  for (const L of A)
    if (B = instertLeafInTree(L, B), !B) throw new Error("No room left to insert tapleaf in tree");
  return B;
}
function instertLeafInTree(A, B, L = 0) {
  if (L > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (A.depth === L)
    return B ? void 0 : {
      output: A.script,
      version: A.leafVersion
    };
  if ((0, types_1.isTapleaf)(B)) return;
  const K = instertLeafInTree(A, B && B[0], L + 1);
  if (K) return [K, B && B[1]];
  const V = instertLeafInTree(A, B && B[1], L + 1);
  if (V) return [B && B[0], V];
}
function checkMixedTaprootAndNonTaprootInputFields(A, B, L) {
  const K = isTaprootInput(A) && hasNonTaprootFields(B), V = hasNonTaprootFields(A) && isTaprootInput(B), W = A === B && isTaprootInput(B) && hasNonTaprootFields(B);
  if (K || V || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(A, B, L) {
  const K = isTaprootOutput(A) && hasNonTaprootFields(B), V = hasNonTaprootFields(A) && isTaprootOutput(B), W = A === B && isTaprootOutput(B) && hasNonTaprootFields(B);
  if (K || V || W)
    throw new Error(
      `Invalid arguments for Psbt.${L}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(A, B, L) {
  if (B.tapMerkleRoot) {
    const K = (B.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    ), V = (A.tapLeafScript || []).every(
      (W) => isTapLeafInTree(W, B.tapMerkleRoot)
    );
    if (!K || !V)
      throw new Error(
        `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
      );
  } else if (A.tapMerkleRoot && !(B.tapLeafScript || []).every(
    (V) => isTapLeafInTree(V, A.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${L}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(A, B) {
  if (!B) return !0;
  const L = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    A.controlBlock,
    L
  ).equals(B);
}
function sortSignatures(A, B) {
  const L = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (A.tapScriptSig || []).filter((K) => K.leafHash.equals(L)).map((K) => addPubkeyPositionInScript(B.script, K)).sort((K, V) => V.positionInScript - K.positionInScript).map((K) => K.signature);
}
function addPubkeyPositionInScript(A, B) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        B.pubkey,
        A
      )
    },
    B
  );
}
function findTapLeafToFinalize(A, B, L) {
  if (!A.tapScriptSig || !A.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${B}. No tapleaf script signature provided.`
    );
  const K = (A.tapLeafScript || []).sort((V, W) => V.controlBlock.length - W.controlBlock.length).find(
    (V) => canFinalizeLeaf(V, A.tapScriptSig, L)
  );
  if (!K)
    throw new Error(
      `Can not finalize taproot input #${B}. Signature for tapleaf script not found.`
    );
  return K;
}
function canFinalizeLeaf(A, B, L) {
  const K = (0, bip341_1$1.tapleafHash)({
    output: A.script,
    version: A.leafVersion
  });
  return (!L || L.equals(K)) && B.find((W) => W.leafHash.equals(K)) !== void 0;
}
function hasNonTaprootFields(A) {
  return A && !!(A.redeemScript || A.witnessScript || A.bip32Derivation && A.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(B, L = {}) {
    const K = Buffer$1.from(B, "base64");
    return this.fromBuffer(K, L);
  }
  static fromHex(B, L = {}) {
    const K = Buffer$1.from(B, "hex");
    return this.fromBuffer(K, L);
  }
  static fromBuffer(B, L = {}) {
    const K = bip174_1.Psbt.fromBuffer(B, transactionFromBuffer), V = new Psbt(L, K);
    return checkTxForDupeIns(V.__CACHE.__TX, V.__CACHE), V;
  }
  constructor(B = {}, L = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = L, this.opts = Object.assign({}, DEFAULT_OPTS, B), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const K = (V, W, J, ne) => Object.defineProperty(V, W, {
      enumerable: J,
      writable: ne
    });
    K(this, "__CACHE", !1, !0), K(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(B) {
    this.setVersion(B);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(B) {
    this.setLocktime(B);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((B) => ({
      hash: (0, bufferutils_1.cloneBuffer)(B.hash),
      index: B.index,
      sequence: B.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((B) => {
      let L;
      try {
        L = (0, address_1.fromOutputScript)(
          B.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(B.script),
        value: B.value,
        address: L
      };
    });
  }
  combine(...B) {
    return this.data.combine(...B.map((L) => L.data)), this;
  }
  clone() {
    const B = Psbt.fromBuffer(this.data.toBuffer());
    return B.opts = JSON.parse(JSON.stringify(this.opts)), B;
  }
  setMaximumFeeRate(B) {
    check32Bit(B), this.opts.maximumFeeRate = B;
  }
  setVersion(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const L = this.__CACHE;
    return L.__TX.version = B, L.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(B) {
    check32Bit(B), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const L = this.__CACHE;
    return L.__TX.locktime = B, L.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(B, L) {
    check32Bit(L), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const K = this.__CACHE;
    if (K.__TX.ins.length <= B)
      throw new Error("Input index too high");
    return K.__TX.ins[B].sequence = L, K.__EXTRACTED_TX = void 0, this;
  }
  addInputs(B) {
    return B.forEach((L) => this.addInput(L)), this;
  }
  addInput(B) {
    if (arguments.length > 1 || !B || B.hash === void 0 || B.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(B, B, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), B.witnessScript && checkInvalidP2WSH(B.witnessScript);
    const L = this.__CACHE;
    this.data.addInput(B);
    const K = L.__TX.ins[L.__TX.ins.length - 1];
    checkTxInputCache(L, K);
    const V = this.data.inputs.length - 1, W = this.data.inputs[V];
    return W.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, W, V), L.__FEE = void 0, L.__FEE_RATE = void 0, L.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(B) {
    return B.forEach((L) => this.addOutput(L)), this;
  }
  addOutput(B) {
    if (arguments.length > 1 || !B || B.value === void 0 || B.address === void 0 && B.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: L } = B;
    if (typeof L == "string") {
      const { network: V } = this.opts, W = (0, address_1.toOutputScript)(L, V);
      B = Object.assign({}, B, { script: W });
    }
    (0, bip371_1.checkTaprootOutputFields)(B, B, "addOutput");
    const K = this.__CACHE;
    return this.data.addOutput(B), K.__FEE = void 0, K.__FEE_RATE = void 0, K.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(B) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const L = this.__CACHE;
    if (B || checkFees(this, L, this.opts), L.__EXTRACTED_TX) return L.__EXTRACTED_TX;
    const K = L.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, K, L, !0), K;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((B) => this.finalizeInput(B)), this;
  }
  finalizeInput(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(K) ? this._finalizeTaprootInput(
      B,
      K,
      void 0,
      L
    ) : this._finalizeInput(B, K, L);
  }
  finalizeTaprootInput(B, L, K = bip371_1.tapScriptFinalizer) {
    const V = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(V))
      return this._finalizeTaprootInput(
        B,
        V,
        L,
        K
      );
    throw new Error(`Cannot finalize input #${B}. Not Taproot.`);
  }
  _finalizeInput(B, L, K = getFinalScripts) {
    const { script: V, isP2SH: W, isP2WSH: J, isSegwit: ne } = getScriptFromInput(
      B,
      L,
      this.__CACHE
    );
    if (!V) throw new Error(`No script found for input #${B}`);
    checkPartialSigSighashes(L);
    const { finalScriptSig: ie, finalScriptWitness: ce } = K(
      B,
      L,
      V,
      ne,
      W,
      J
    );
    if (ie && this.data.updateInput(B, { finalScriptSig: ie }), ce && this.data.updateInput(B, { finalScriptWitness: ce }), !ie && !ce)
      throw new Error(`Unknown error finalizing input #${B}`);
    return this.data.clearFinalizedInput(B), this;
  }
  _finalizeTaprootInput(B, L, K, V = bip371_1.tapScriptFinalizer) {
    if (!L.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${B}. Missing withness utxo.`
      );
    if (L.tapKeySig) {
      const W = payments.p2tr({
        output: L.witnessUtxo.script,
        signature: L.tapKeySig
      }), J = (0, psbtutils_1.witnessStackToScriptWitness)(
        W.witness
      );
      this.data.updateInput(B, { finalScriptWitness: J });
    } else {
      const { finalScriptWitness: W } = V(
        B,
        L,
        K
      );
      this.data.updateInput(B, { finalScriptWitness: W });
    }
    return this.data.clearFinalizedInput(B), this;
  }
  getInputType(B) {
    const L = (0, utils_1.checkForInput)(this.data.inputs, B), K = getScriptFromUtxo(B, L, this.__CACHE), V = getMeaningfulScript(
      K,
      B,
      "input",
      L.redeemScript || redeemFromFinalScriptSig(L.finalScriptSig),
      L.witnessScript || redeemFromFinalWitnessScript(L.finalScriptWitness)
    ), W = V.type === "raw" ? "" : V.type + "-", J = classifyScript(V.meaningfulScript);
    return W + J;
  }
  inputHasPubkey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B);
    return pubkeyInInput(L, K, B, this.__CACHE);
  }
  inputHasHDKey(B, L) {
    const K = (0, utils_1.checkForInput)(this.data.inputs, B), V = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(V);
  }
  outputHasPubkey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B);
    return pubkeyInOutput(L, K, B, this.__CACHE);
  }
  outputHasHDKey(B, L) {
    const K = (0, utils_1.checkForOutput)(this.data.outputs, B), V = bip32DerivationIsMine(L);
    return !!K.bip32Derivation && K.bip32Derivation.some(V);
  }
  validateSignaturesOfAllInputs(B) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (K) => this.validateSignaturesOfInput(K, B)
    ).reduce((K, V) => V === !0 && K, !0);
  }
  validateSignaturesOfInput(B, L, K) {
    const V = this.data.inputs[B];
    return (0, bip371_1.isTaprootInput)(V) ? this.validateSignaturesOfTaprootInput(
      B,
      L,
      K
    ) : this._validateSignaturesOfInput(B, L, K);
  }
  _validateSignaturesOfInput(B, L, K) {
    const V = this.data.inputs[B], W = (V || {}).partialSig;
    if (!V || !W || W.length < 1)
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    const J = K ? W.filter((oe) => oe.pubkey.equals(K)) : W;
    if (J.length < 1) throw new Error("No signatures for this pubkey");
    const ne = [];
    let ie, ce, re;
    for (const oe of J) {
      const ke = bscript.signature.decode(oe.signature), { hash: Oe, script: it } = re !== ke.hashType ? getHashForSig(
        B,
        Object.assign({}, V, { sighashType: ke.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ie, script: ce };
      re = ke.hashType, ie = Oe, ce = it, checkScriptForPubkey(oe.pubkey, it, "verify"), ne.push(L(oe.pubkey, Oe, ke.signature));
    }
    return ne.every((oe) => oe === !0);
  }
  validateSignaturesOfTaprootInput(B, L, K) {
    const V = this.data.inputs[B], W = (V || {}).tapKeySig, J = (V || {}).tapScriptSig;
    if (!V && !W && !(J && !J.length))
      throw new Error("No signatures to validate");
    if (typeof L != "function")
      throw new Error("Need validator function to validate signatures");
    K = K && (0, bip371_1.toXOnly)(K);
    const ne = K ? getTaprootHashesForSig(
      B,
      V,
      this.data.inputs,
      K,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      B,
      V,
      this.data.inputs,
      this.__CACHE
    );
    if (!ne.length) throw new Error("No signatures for this pubkey");
    const ie = ne.find((re) => !re.leafHash);
    let ce = 0;
    if (W && ie) {
      if (!L(
        ie.pubkey,
        ie.hash,
        trimTaprootSig(W)
      )) return !1;
      ce++;
    }
    if (J)
      for (const re of J) {
        const oe = ne.find((ke) => re.pubkey.equals(ke.pubkey));
        if (oe) {
          if (!L(
            re.pubkey,
            oe.hash,
            trimTaprootSig(re.signature)
          )) return !1;
          ce++;
        }
      }
    return ce > 0;
  }
  signAllInputsHD(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!B || !B.publicKey || !B.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const K = [];
    for (const V of range(this.data.inputs.length))
      try {
        this.signInputHD(V, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((V) => V === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(B, L = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((K, V) => {
      if (!B || !B.publicKey || !B.fingerprint)
        return V(new Error("Need HDSigner to sign input"));
      const W = [], J = [];
      for (const ne of range(this.data.inputs.length))
        J.push(
          this.signInputHDAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(J).then(() => {
        if (W.every((ne) => ne === !1))
          return V(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInputHD(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!L || !L.publicKey || !L.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(B, this.data.inputs, L).forEach((W) => this.signInput(B, W, K)), this;
  }
  signInputHDAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((V, W) => {
      if (!L || !L.publicKey || !L.fingerprint)
        return W(new Error("Need HDSigner to sign input"));
      const ne = getSignersFromHD(B, this.data.inputs, L).map(
        (ie) => this.signInputAsync(B, ie, K)
      );
      return Promise.all(ne).then(() => {
        V();
      }).catch(W);
    });
  }
  signAllInputs(B, L) {
    if (!B || !B.publicKey)
      throw new Error("Need Signer to sign input");
    const K = [];
    for (const V of range(this.data.inputs.length))
      try {
        this.signInput(V, B, L), K.push(!0);
      } catch {
        K.push(!1);
      }
    if (K.every((V) => V === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(B, L) {
    return new Promise((K, V) => {
      if (!B || !B.publicKey)
        return V(new Error("Need Signer to sign input"));
      const W = [], J = [];
      for (const [ne] of this.data.inputs.entries())
        J.push(
          this.signInputAsync(ne, B, L).then(
            () => {
              W.push(!0);
            },
            () => {
              W.push(!1);
            }
          )
        );
      return Promise.all(J).then(() => {
        if (W.every((ne) => ne === !1))
          return V(new Error("No inputs were signed"));
        K();
      });
    });
  }
  signInput(B, L, K) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const V = (0, utils_1.checkForInput)(this.data.inputs, B);
    return (0, bip371_1.isTaprootInput)(V) ? this._signTaprootInput(
      B,
      V,
      L,
      void 0,
      K
    ) : this._signInput(B, L, K);
  }
  signTaprootInput(B, L, K, V) {
    if (!L || !L.publicKey)
      throw new Error("Need Signer to sign input");
    const W = (0, utils_1.checkForInput)(this.data.inputs, B);
    if ((0, bip371_1.isTaprootInput)(W))
      return this._signTaprootInput(
        B,
        W,
        L,
        K,
        V
      );
    throw new Error(`Input #${B} is not of type Taproot.`);
  }
  _signInput(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: V, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    ), J = [
      {
        pubkey: L.publicKey,
        signature: bscript.signature.encode(L.sign(V), W)
      }
    ];
    return this.data.updateInput(B, { partialSig: J }), this;
  }
  _signTaprootInput(B, L, K, V, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const J = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      V,
      W
    ), ne = J.filter((ce) => !ce.leafHash).map(
      (ce) => (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(ce.hash),
        L.sighashType
      )
    )[0], ie = J.filter((ce) => !!ce.leafHash).map((ce) => ({
      pubkey: (0, bip371_1.toXOnly)(K.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        K.signSchnorr(ce.hash),
        L.sighashType
      ),
      leafHash: ce.leafHash
    }));
    return ne && this.data.updateInput(B, { tapKeySig: ne }), ie.length && this.data.updateInput(B, { tapScriptSig: ie }), this;
  }
  signInputAsync(B, L, K) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const V = (0, utils_1.checkForInput)(this.data.inputs, B);
      return (0, bip371_1.isTaprootInput)(V) ? this._signTaprootInputAsync(
        B,
        V,
        L,
        void 0,
        K
      ) : this._signInputAsync(B, L, K);
    });
  }
  signTaprootInputAsync(B, L, K, V) {
    return Promise.resolve().then(() => {
      if (!L || !L.publicKey)
        throw new Error("Need Signer to sign input");
      const W = (0, utils_1.checkForInput)(this.data.inputs, B);
      if ((0, bip371_1.isTaprootInput)(W))
        return this._signTaprootInputAsync(
          B,
          W,
          L,
          K,
          V
        );
      throw new Error(`Input #${B} is not of type Taproot.`);
    });
  }
  _signInputAsync(B, L, K = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: V, sighashType: W } = getHashAndSighashType(
      this.data.inputs,
      B,
      L.publicKey,
      this.__CACHE,
      K
    );
    return Promise.resolve(L.sign(V)).then((J) => {
      const ne = [
        {
          pubkey: L.publicKey,
          signature: bscript.signature.encode(J, W)
        }
      ];
      this.data.updateInput(B, { partialSig: ne });
    });
  }
  async _signTaprootInputAsync(B, L, K, V, W = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const J = this.checkTaprootHashesForSig(
      B,
      L,
      K,
      V,
      W
    ), ne = [], ie = J.filter((re) => !re.leafHash)[0];
    if (ie) {
      const re = Promise.resolve(
        K.signSchnorr(ie.hash)
      ).then((oe) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          oe,
          L.sighashType
        )
      }));
      ne.push(re);
    }
    const ce = J.filter((re) => !!re.leafHash);
    if (ce.length) {
      const re = ce.map((oe) => Promise.resolve(K.signSchnorr(oe.hash)).then(
        (ke) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(K.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              ke,
              L.sighashType
            ),
            leafHash: oe.leafHash
          }
        ] })
      ));
      ne.push(...re);
    }
    return Promise.all(ne).then((re) => {
      re.forEach((oe) => this.data.updateInput(B, oe));
    });
  }
  checkTaprootHashesForSig(B, L, K, V, W) {
    if (typeof K.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${B}.`
      );
    const J = getTaprootHashesForSig(
      B,
      L,
      this.data.inputs,
      K.publicKey,
      this.__CACHE,
      V,
      W
    );
    if (!J || !J.length)
      throw new Error(
        `Can not sign for input #${B} with the key ${K.publicKey.toString(
          "hex"
        )}`
      );
    return J;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(B) {
    return this.data.updateGlobal(B), this;
  }
  updateInput(B, L) {
    return L.witnessScript && checkInvalidP2WSH(L.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[B],
      L,
      "updateInput"
    ), this.data.updateInput(B, L), L.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[B],
      B
    ), this;
  }
  updateOutput(B, L) {
    const K = this.data.outputs[B];
    return (0, bip371_1.checkTaprootOutputFields)(
      K,
      L,
      "updateOutput"
    ), this.data.updateOutput(B, L), this;
  }
  addUnknownKeyValToGlobal(B) {
    return this.data.addUnknownKeyValToGlobal(B), this;
  }
  addUnknownKeyValToInput(B, L) {
    return this.data.addUnknownKeyValToInput(B, L), this;
  }
  addUnknownKeyValToOutput(B, L) {
    return this.data.addUnknownKeyValToOutput(B, L), this;
  }
  clearFinalizedInput(B) {
    return this.data.clearFinalizedInput(B), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (A) => new PsbtTransaction(A);
class PsbtTransaction {
  constructor(B = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(B), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(B) {
    if (B.hash === void 0 || B.index === void 0 || !Buffer$1.isBuffer(B.hash) && typeof B.hash != "string" || typeof B.index != "number")
      throw new Error("Error adding input.");
    const L = typeof B.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash, "hex")) : B.hash;
    this.tx.addInput(L, B.index, B.sequence);
  }
  addOutput(B) {
    if (B.script === void 0 || B.value === void 0 || !Buffer$1.isBuffer(B.script) || typeof B.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(B.script, B.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(A, B, L) {
  switch (L) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, A.partialSig);
    case "multisig":
      const K = payments.p2ms({ output: B });
      return hasSigs(K.m, A.partialSig, K.pubkeys);
    default:
      return !1;
  }
}
function checkCache(A) {
  if (A.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(A, B, L) {
  if (!B) return !1;
  let K;
  if (L ? K = L.map((V) => {
    const W = compressPubkey(V);
    return B.find((J) => J.pubkey.equals(W));
  }).filter((V) => !!V) : K = B, K.length > A) throw new Error("Too many signatures");
  return K.length === A;
}
function isFinalized(A) {
  return !!A.finalScriptSig || !!A.finalScriptWitness;
}
function bip32DerivationIsMine(A) {
  return (B) => !(!B.masterFingerprint.equals(A.fingerprint) || !A.derivePath(B.path).publicKey.equals(B.pubkey));
}
function check32Bit(A) {
  if (typeof A != "number" || A !== Math.floor(A) || A > 4294967295 || A < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(A, B, L) {
  const K = B.__FEE_RATE || A.getFeeRate(), V = B.__EXTRACTED_TX.virtualSize(), W = K * V;
  if (K >= L.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(W / 1e8).toFixed(8)} in fees, which is ${K} satoshi per byte for a transaction with a VSize of ${V} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(A, B) {
  A.forEach((L) => {
    if ((0, bip371_1.isTaprootInput)(L) ? (0, bip371_1.checkTaprootInputForSigs)(L, B) : (0, psbtutils_1.checkInputForSig)(L, B))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(A) {
  if (!A.sighashType || !A.partialSig) return;
  const { partialSig: B, sighashType: L } = A;
  B.forEach((K) => {
    const { hashType: V } = bscript.signature.decode(K.signature);
    if (L !== V)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(A, B, L) {
  if (!(0, psbtutils_1.pubkeyInScript)(A, B))
    throw new Error(
      `Can not ${L} for this input with the key ${A.toString("hex")}`
    );
}
function checkTxEmpty(A) {
  if (!A.ins.every(
    (L) => L.script && L.script.length === 0 && L.witness && L.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(A, B) {
  A.ins.forEach((L) => {
    checkTxInputCache(B, L);
  });
}
function checkTxInputCache(A, B) {
  const L = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(B.hash)).toString("hex") + ":" + B.index;
  if (A.__TX_IN_CACHE[L]) throw new Error("Duplicate input detected.");
  A.__TX_IN_CACHE[L] = 1;
}
function scriptCheckerFactory(A, B) {
  return (L, K, V, W) => {
    const J = A({
      redeem: { output: V }
    }).output;
    if (!K.equals(J))
      throw new Error(
        `${B} for ${W} #${L} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(A, B, L, K) {
  if (!L.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${B}`);
  if (A === "__FEE_RATE" && K.__FEE_RATE) return K.__FEE_RATE;
  if (A === "__FEE" && K.__FEE) return K.__FEE;
  let V, W = !0;
  if (K.__EXTRACTED_TX ? (V = K.__EXTRACTED_TX, W = !1) : V = K.__TX.clone(), inputFinalizeGetAmts(L, V, K, W), A === "__FEE_RATE") return K.__FEE_RATE;
  if (A === "__FEE") return K.__FEE;
}
function getFinalScripts(A, B, L, K, V, W) {
  const J = classifyScript(L);
  if (!canFinalize(B, L, J))
    throw new Error(`Can not finalize input #${A}`);
  return prepareFinalScripts(
    L,
    J,
    B.partialSig,
    K,
    V,
    W
  );
}
function prepareFinalScripts(A, B, L, K, V, W) {
  let J, ne;
  const ie = getPayment(A, B, L), ce = W ? payments.p2wsh({ redeem: ie }) : null, re = V ? payments.p2sh({ redeem: ce || ie }) : null;
  return K ? (ce ? ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    ce.witness
  ) : ne = (0, psbtutils_1.witnessStackToScriptWitness)(
    ie.witness
  ), re && (J = re.input)) : re ? J = re.input : J = ie.input, {
    finalScriptSig: J,
    finalScriptWitness: ne
  };
}
function getHashAndSighashType(A, B, L, K, V) {
  const W = (0, utils_1.checkForInput)(A, B), { hash: J, sighashType: ne, script: ie } = getHashForSig(
    B,
    W,
    K,
    !1,
    V
  );
  return checkScriptForPubkey(L, ie, "sign"), {
    hash: J,
    sighashType: ne
  };
}
function getHashForSig(A, B, L, K, V) {
  const W = L.__TX, J = B.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(J, V);
  let ne, ie;
  if (B.nonWitnessUtxo) {
    const oe = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), ke = W.ins[A].hash, Oe = oe.getHash();
    if (!ke.equals(Oe))
      throw new Error(
        `Non-witness UTXO hash for input #${A} doesn't match the hash specified in the prevout`
      );
    const it = W.ins[A].index;
    ie = oe.outs[it];
  } else if (B.witnessUtxo)
    ie = B.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: ce, type: re } = getMeaningfulScript(
    ie.script,
    A,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(re) >= 0)
    ne = W.hashForWitnessV0(
      A,
      ce,
      ie.value,
      J
    );
  else if ((0, psbtutils_1.isP2WPKH)(ce)) {
    const oe = payments.p2pkh({
      hash: ce.slice(2)
    }).output;
    ne = W.hashForWitnessV0(
      A,
      oe,
      ie.value,
      J
    );
  } else {
    if (B.nonWitnessUtxo === void 0 && L.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${A} has witnessUtxo but non-segwit script: ${ce.toString("hex")}`
      );
    !K && L.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), ne = W.hashForSignature(
      A,
      ce,
      J
    );
  }
  return {
    script: ce,
    sighashType: J,
    hash: ne
  };
}
function getAllTaprootHashesForSig(A, B, L, K) {
  const V = [];
  if (B.tapInternalKey) {
    const J = getPrevoutTaprootKey(A, B, K);
    J && V.push(J);
  }
  if (B.tapScriptSig) {
    const J = B.tapScriptSig.map((ne) => ne.pubkey);
    V.push(...J);
  }
  return V.map(
    (J) => getTaprootHashesForSig(A, B, L, J, K)
  ).flat();
}
function getPrevoutTaprootKey(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return (0, psbtutils_1.isP2TR)(K) ? K.subarray(2, 34) : null;
}
function trimTaprootSig(A) {
  return A.length === 64 ? A : A.subarray(0, 64);
}
function getTaprootHashesForSig(A, B, L, K, V, W, J) {
  const ne = V.__TX, ie = B.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ie, J);
  const ce = L.map(
    (it, at) => getScriptAndAmountFromUtxo(at, it, V)
  ), re = ce.map((it) => it.script), oe = ce.map((it) => it.value), ke = [];
  if (B.tapInternalKey && !W) {
    const it = getPrevoutTaprootKey(A, B, V) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(K).equals(it)) {
      const at = ne.hashForWitnessV1(
        A,
        re,
        oe,
        ie
      );
      ke.push({ pubkey: K, hash: at });
    }
  }
  const Oe = (B.tapLeafScript || []).filter((it) => (0, psbtutils_1.pubkeyInScript)(K, it.script)).map((it) => {
    const at = (0, bip341_1.tapleafHash)({
      output: it.script,
      version: it.leafVersion
    });
    return Object.assign({ hash: at }, it);
  }).filter(
    (it) => !W || W.equals(it.hash)
  ).map((it) => {
    const at = ne.hashForWitnessV1(
      A,
      re,
      oe,
      ie,
      it.hash
    );
    return {
      pubkey: K,
      hash: at,
      leafHash: it.hash
    };
  });
  return ke.concat(Oe);
}
function checkSighashTypeAllowed(A, B) {
  if (B && B.indexOf(A) < 0) {
    const L = sighashTypeToString(A);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${L}`
    );
  }
}
function getPayment(A, B, L) {
  let K;
  switch (B) {
    case "multisig":
      const V = getSortedSigs(A, L);
      K = payments.p2ms({
        output: A,
        signatures: V
      });
      break;
    case "pubkey":
      K = payments.p2pk({
        output: A,
        signature: L[0].signature
      });
      break;
    case "pubkeyhash":
      K = payments.p2pkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
    case "witnesspubkeyhash":
      K = payments.p2wpkh({
        output: A,
        pubkey: L[0].pubkey,
        signature: L[0].signature
      });
      break;
  }
  return K;
}
function getScriptFromInput(A, B, L) {
  const K = L.__TX, V = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (V.isP2SH = !!B.redeemScript, V.isP2WSH = !!B.witnessScript, B.witnessScript)
    V.script = B.witnessScript;
  else if (B.redeemScript)
    V.script = B.redeemScript;
  else if (B.nonWitnessUtxo) {
    const W = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ), J = K.ins[A].index;
    V.script = W.outs[J].script;
  } else B.witnessUtxo && (V.script = B.witnessUtxo.script);
  return (B.witnessScript || (0, psbtutils_1.isP2WPKH)(V.script)) && (V.isSegwit = !0), V;
}
function getSignersFromHD(A, B, L) {
  const K = (0, utils_1.checkForInput)(B, A);
  if (!K.bip32Derivation || K.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const V = K.bip32Derivation.map((J) => {
    if (J.masterFingerprint.equals(L.fingerprint))
      return J;
  }).filter((J) => !!J);
  if (V.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return V.map((J) => {
    const ne = L.derivePath(J.path);
    if (!J.pubkey.equals(ne.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return ne;
  });
}
function getSortedSigs(A, B) {
  return payments.p2ms({ output: A }).pubkeys.map((K) => (B.filter((V) => V.pubkey.equals(K))[0] || {}).signature).filter((K) => !!K);
}
function scriptWitnessToWitnessStack(A) {
  let B = 0;
  function L(J) {
    return B += J, A.slice(B - J, B);
  }
  function K() {
    const J = varuint.decode(A, B);
    return B += varuint.decode.bytes, J;
  }
  function V() {
    return L(K());
  }
  function W() {
    const J = K(), ne = [];
    for (let ie = 0; ie < J; ie++) ne.push(V());
    return ne;
  }
  return W();
}
function sighashTypeToString(A) {
  let B = A & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (A & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      B += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      B += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      B += "SIGHASH_NONE";
      break;
  }
  return B;
}
function addNonWitnessTxCache(A, B, L) {
  A.__NON_WITNESS_UTXO_BUF_CACHE[L] = B.nonWitnessUtxo;
  const K = transaction_1.Transaction.fromBuffer(B.nonWitnessUtxo);
  A.__NON_WITNESS_UTXO_TX_CACHE[L] = K;
  const V = A, W = L;
  delete B.nonWitnessUtxo, Object.defineProperty(B, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const J = V.__NON_WITNESS_UTXO_BUF_CACHE[W], ne = V.__NON_WITNESS_UTXO_TX_CACHE[W];
      if (J !== void 0)
        return J;
      {
        const ie = ne.toBuffer();
        return V.__NON_WITNESS_UTXO_BUF_CACHE[W] = ie, ie;
      }
    },
    set(J) {
      V.__NON_WITNESS_UTXO_BUF_CACHE[W] = J;
    }
  });
}
function inputFinalizeGetAmts(A, B, L, K) {
  let V = 0;
  A.forEach((ie, ce) => {
    if (K && ie.finalScriptSig && (B.ins[ce].script = ie.finalScriptSig), K && ie.finalScriptWitness && (B.ins[ce].witness = scriptWitnessToWitnessStack(
      ie.finalScriptWitness
    )), ie.witnessUtxo)
      V += ie.witnessUtxo.value;
    else if (ie.nonWitnessUtxo) {
      const re = nonWitnessUtxoTxFromCache(L, ie, ce), oe = B.ins[ce].index, ke = re.outs[oe];
      V += ke.value;
    }
  });
  const W = B.outs.reduce((ie, ce) => ie + ce.value, 0), J = V - W;
  if (J < 0)
    throw new Error("Outputs are spending more than Inputs");
  const ne = B.virtualSize();
  L.__FEE = J, L.__EXTRACTED_TX = B, L.__FEE_RATE = Math.floor(J / ne);
}
function nonWitnessUtxoTxFromCache(A, B, L) {
  const K = A.__NON_WITNESS_UTXO_TX_CACHE;
  return K[L] || addNonWitnessTxCache(A, B, L), K[L];
}
function getScriptFromUtxo(A, B, L) {
  const { script: K } = getScriptAndAmountFromUtxo(A, B, L);
  return K;
}
function getScriptAndAmountFromUtxo(A, B, L) {
  if (B.witnessUtxo !== void 0)
    return {
      script: B.witnessUtxo.script,
      value: B.witnessUtxo.value
    };
  if (B.nonWitnessUtxo !== void 0) {
    const V = nonWitnessUtxoTxFromCache(
      L,
      B,
      A
    ).outs[L.__TX.ins[A].index];
    return { script: V.script, value: V.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(A, B, L, K) {
  const V = getScriptFromUtxo(L, B, K), { meaningfulScript: W } = getMeaningfulScript(
    V,
    L,
    "input",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function pubkeyInOutput(A, B, L, K) {
  const V = K.__TX.outs[L].script, { meaningfulScript: W } = getMeaningfulScript(
    V,
    L,
    "output",
    B.redeemScript,
    B.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(A, W);
}
function redeemFromFinalScriptSig(A) {
  if (!A) return;
  const B = bscript.decompile(A);
  if (!B) return;
  const L = B[B.length - 1];
  if (!(!Buffer$1.isBuffer(L) || isPubkeyLike(L) || isSigLike(L) || !bscript.decompile(L)))
    return L;
}
function redeemFromFinalWitnessScript(A) {
  if (!A) return;
  const B = scriptWitnessToWitnessStack(A), L = B[B.length - 1];
  if (!(isPubkeyLike(L) || !bscript.decompile(L)))
    return L;
}
function compressPubkey(A) {
  if (A.length === 65) {
    const B = A[64] & 1, L = A.slice(0, 33);
    return L[0] = 2 | B, L;
  }
  return A.slice();
}
function isPubkeyLike(A) {
  return A.length === 33 && bscript.isCanonicalPubKey(A);
}
function isSigLike(A) {
  return bscript.isCanonicalScriptSignature(A);
}
function getMeaningfulScript(A, B, L, K, V) {
  const W = (0, psbtutils_1.isP2SHScript)(A), J = W && K && (0, psbtutils_1.isP2WSHScript)(K), ne = (0, psbtutils_1.isP2WSHScript)(A);
  if (W && K === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((ne || J) && V === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ie;
  return J ? (ie = V, checkRedeemScript(B, A, K, L), checkWitnessScript(B, K, V, L), checkInvalidP2WSH(ie)) : ne ? (ie = V, checkWitnessScript(B, A, V, L), checkInvalidP2WSH(ie)) : W ? (ie = K, checkRedeemScript(B, A, K, L)) : ie = A, {
    meaningfulScript: ie,
    type: J ? "p2sh-p2wsh" : W ? "p2sh" : ne ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(A) {
  if ((0, psbtutils_1.isP2WPKH)(A) || (0, psbtutils_1.isP2SHScript)(A))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(A) {
  return (0, psbtutils_1.isP2WPKH)(A) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(A) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(A) ? "multisig" : (0, psbtutils_1.isP2PK)(A) ? "pubkey" : "nonstandard";
}
function range(A) {
  return [...Array(A).keys()];
}
(function(A) {
  Object.defineProperty(A, "__esModule", { value: !0 }), A.initEccLib = A.Transaction = A.opcodes = A.Psbt = A.Block = A.script = A.payments = A.networks = A.crypto = A.address = void 0;
  const B = requireAddress();
  A.address = B;
  const L = crypto$1;
  A.crypto = L;
  const K = networks;
  A.networks = K;
  const V = requirePayments();
  A.payments = V;
  const W = requireScript();
  A.script = W;
  var J = block;
  Object.defineProperty(A, "Block", {
    enumerable: !0,
    get: function() {
      return J.Block;
    }
  });
  var ne = psbt$1;
  Object.defineProperty(A, "Psbt", {
    enumerable: !0,
    get: function() {
      return ne.Psbt;
    }
  });
  var ie = ops;
  Object.defineProperty(A, "opcodes", {
    enumerable: !0,
    get: function() {
      return ie.OPS;
    }
  });
  var ce = transaction;
  Object.defineProperty(A, "Transaction", {
    enumerable: !0,
    get: function() {
      return ce.Transaction;
    }
  });
  var re = ecc_lib;
  Object.defineProperty(A, "initEccLib", {
    enumerable: !0,
    get: function() {
      return re.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: A, publicKey: B, format: L, wallet: K } = useOrdConnect(), [V, W] = useState(null), [J, ne] = useState(!1);
  return { sign: useCallback(
    async (ce, re, oe) => {
      ne(!0);
      try {
        if (W(null), !L || !B || !K)
          throw new Error("No wallet is connected");
        const ke = src$1.Psbt.fromBase64(re), Oe = await signPsbt({
          address: ce,
          wallet: K,
          network: A,
          psbt: ke,
          options: oe
        });
        return ne(!1), Oe;
      } catch (ke) {
        throw W(ke.message), ne(!1), ke;
      }
    },
    [L, A, B, K]
  ), error: V, loading: J };
}
function leatherPaymentTypeFromFormat(A) {
  if (A === "segwit")
    return LeatherAddressType.P2WPKH;
  if (A === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: A,
  wallet: B,
  address: L,
  network: K,
  format: V
}) {
  if (B === Wallet.MAGICEDEN) {
    const { base64: W } = await signMessage$1(A, L, K);
    return W;
  }
  if (B === Wallet.UNISAT) {
    const { base64: W } = await signMessage$2(A, "bip322-simple");
    return W;
  }
  if (B === Wallet.XVERSE) {
    const { base64: W } = await signMessage$3(A, L, K);
    return W;
  }
  if (B === Wallet.LEATHER) {
    const W = leatherPaymentTypeFromFormat(V), { base64: J } = await signMessage$4(A, {
      paymentType: W,
      network: K
    });
    return J;
  }
  if (B === Wallet.OKX) {
    const { base64: W } = await signMessage$5(A, "bip322-simple", K);
    return W;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: A,
    wallet: B,
    publicKey: L,
    format: K,
    address: V
  } = useOrdConnect(), [W, J] = useState(null), [ne, ie] = useState(!1);
  return { signMsg: useCallback(
    async (re, oe) => {
      ie(!0);
      try {
        if (J(null), !K || !L || !B)
          throw new Error("No wallet is connected");
        if (V.ordinals !== re && V.payments !== re)
          throw new Error("Address supplied is not connected address");
        const ke = await signMessage({
          address: re,
          wallet: B,
          message: oe,
          network: A,
          format: V.ordinals === re ? K.ordinals : K.payments
        });
        return ie(!1), ke;
      } catch (ke) {
        throw J(ke.message), ie(!1), ke;
      }
    },
    [K, A, L, B, V]
  ), error: W, isLoading: ne };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
