(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as React from "react";
import React__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useRef, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, useReducer, useSyncExternalStore, createRef } from "react";
import * as ReactDOM from "react-dom";
import { createPortal, flushSync } from "react-dom";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletRequestCancelledByUserError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$4, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$5 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { signPsbt as signPsbt$3, signMessage as signMessage$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var z = queue.length; z; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < z; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, z = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var z = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var Y = 1; Y < arguments.length; Y++)
      z[Y - 1] = arguments[Y];
  queue.push(new Item(B, z)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, z) {
  this.fun = B, this.array = z;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.fragment"), ne = Object.prototype.hasOwnProperty, oe = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ie = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ae(se, ve, ge) {
    var le, Ee = {}, Ce = null, Pe = null;
    ge !== void 0 && (Ce = "" + ge), ve.key !== void 0 && (Ce = "" + ve.key), ve.ref !== void 0 && (Pe = ve.ref);
    for (le in ve) ne.call(ve, le) && !ie.hasOwnProperty(le) && (Ee[le] = ve[le]);
    if (se && se.defaultProps) for (le in ve = se.defaultProps, ve) Ee[le] === void 0 && (Ee[le] = ve[le]);
    return { $$typeof: z, type: se, key: Ce, ref: Pe, props: Ee, _owner: oe.current };
  }
  return reactJsxRuntime_production_min.Fragment = Y, reactJsxRuntime_production_min.jsx = ae, reactJsxRuntime_production_min.jsxs = ae, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.portal"), ne = Symbol.for("react.fragment"), oe = Symbol.for("react.strict_mode"), ie = Symbol.for("react.profiler"), ae = Symbol.for("react.provider"), se = Symbol.for("react.context"), ve = Symbol.for("react.forward_ref"), ge = Symbol.for("react.suspense"), le = Symbol.for("react.suspense_list"), Ee = Symbol.for("react.memo"), Ce = Symbol.for("react.lazy"), Pe = Symbol.for("react.offscreen"), Xe = Symbol.iterator, ht = "@@iterator";
    function wt(ir) {
      if (ir === null || typeof ir != "object")
        return null;
      var vr = Xe && ir[Xe] || ir[ht];
      return typeof vr == "function" ? vr : null;
    }
    var Pt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function vt(ir) {
      {
        for (var vr = arguments.length, Er = new Array(vr > 1 ? vr - 1 : 0), $r = 1; $r < vr; $r++)
          Er[$r - 1] = arguments[$r];
        Bt("error", ir, Er);
      }
    }
    function Bt(ir, vr, Er) {
      {
        var $r = Pt.ReactDebugCurrentFrame, Ur = $r.getStackAddendum();
        Ur !== "" && (vr += "%s", Er = Er.concat([Ur]));
        var Dr = Er.map(function(qr) {
          return String(qr);
        });
        Dr.unshift("Warning: " + vr), Function.prototype.apply.call(console[ir], console, Dr);
      }
    }
    var Ct = !1, Wt = !1, Kt = !1, Yt = !1, Ut = !1, qt;
    qt = Symbol.for("react.module.reference");
    function zt(ir) {
      return !!(typeof ir == "string" || typeof ir == "function" || ir === ne || ir === ie || Ut || ir === oe || ir === ge || ir === le || Yt || ir === Pe || Ct || Wt || Kt || typeof ir == "object" && ir !== null && (ir.$$typeof === Ce || ir.$$typeof === Ee || ir.$$typeof === ae || ir.$$typeof === se || ir.$$typeof === ve || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ir.$$typeof === qt || ir.getModuleId !== void 0));
    }
    function Ft(ir, vr, Er) {
      var $r = ir.displayName;
      if ($r)
        return $r;
      var Ur = vr.displayName || vr.name || "";
      return Ur !== "" ? Er + "(" + Ur + ")" : Er;
    }
    function Ve(ir) {
      return ir.displayName || "Context";
    }
    function Je(ir) {
      if (ir == null)
        return null;
      if (typeof ir.tag == "number" && vt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ir == "function")
        return ir.displayName || ir.name || null;
      if (typeof ir == "string")
        return ir;
      switch (ir) {
        case ne:
          return "Fragment";
        case Y:
          return "Portal";
        case ie:
          return "Profiler";
        case oe:
          return "StrictMode";
        case ge:
          return "Suspense";
        case le:
          return "SuspenseList";
      }
      if (typeof ir == "object")
        switch (ir.$$typeof) {
          case se:
            var vr = ir;
            return Ve(vr) + ".Consumer";
          case ae:
            var Er = ir;
            return Ve(Er._context) + ".Provider";
          case ve:
            return Ft(ir, ir.render, "ForwardRef");
          case Ee:
            var $r = ir.displayName || null;
            return $r !== null ? $r : Je(ir.type) || "Memo";
          case Ce: {
            var Ur = ir, Dr = Ur._payload, qr = Ur._init;
            try {
              return Je(qr(Dr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ke = Object.assign, Qe = 0, bt, _t, $t, kt, xt, Nt, Rt;
    function Ht() {
    }
    Ht.__reactDisabledLog = !0;
    function ar() {
      {
        if (Qe === 0) {
          bt = console.log, _t = console.info, $t = console.warn, kt = console.error, xt = console.group, Nt = console.groupCollapsed, Rt = console.groupEnd;
          var ir = {
            configurable: !0,
            enumerable: !0,
            value: Ht,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ir,
            log: ir,
            warn: ir,
            error: ir,
            group: ir,
            groupCollapsed: ir,
            groupEnd: ir
          });
        }
        Qe++;
      }
    }
    function lr() {
      {
        if (Qe--, Qe === 0) {
          var ir = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ke({}, ir, {
              value: bt
            }),
            info: Ke({}, ir, {
              value: _t
            }),
            warn: Ke({}, ir, {
              value: $t
            }),
            error: Ke({}, ir, {
              value: kt
            }),
            group: Ke({}, ir, {
              value: xt
            }),
            groupCollapsed: Ke({}, ir, {
              value: Nt
            }),
            groupEnd: Ke({}, ir, {
              value: Rt
            })
          });
        }
        Qe < 0 && vt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var nr = Pt.ReactCurrentDispatcher, Vt;
    function Xt(ir, vr, Er) {
      {
        if (Vt === void 0)
          try {
            throw Error();
          } catch (Ur) {
            var $r = Ur.stack.trim().match(/\n( *(at )?)/);
            Vt = $r && $r[1] || "";
          }
        return `
` + Vt + ir;
      }
    }
    var sr = !1, dr;
    {
      var er = typeof WeakMap == "function" ? WeakMap : Map;
      dr = new er();
    }
    function Zt(ir, vr) {
      if (!ir || sr)
        return "";
      {
        var Er = dr.get(ir);
        if (Er !== void 0)
          return Er;
      }
      var $r;
      sr = !0;
      var Ur = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Dr;
      Dr = nr.current, nr.current = null, ar();
      try {
        if (vr) {
          var qr = function() {
            throw Error();
          };
          if (Object.defineProperty(qr.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(qr, []);
            } catch (nn) {
              $r = nn;
            }
            Reflect.construct(ir, [], qr);
          } else {
            try {
              qr.call();
            } catch (nn) {
              $r = nn;
            }
            ir.call(qr.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (nn) {
            $r = nn;
          }
          ir();
        }
      } catch (nn) {
        if (nn && $r && typeof nn.stack == "string") {
          for (var Vr = nn.stack.split(`
`), tn = $r.stack.split(`
`), Qr = Vr.length - 1, en = tn.length - 1; Qr >= 1 && en >= 0 && Vr[Qr] !== tn[en]; )
            en--;
          for (; Qr >= 1 && en >= 0; Qr--, en--)
            if (Vr[Qr] !== tn[en]) {
              if (Qr !== 1 || en !== 1)
                do
                  if (Qr--, en--, en < 0 || Vr[Qr] !== tn[en]) {
                    var on = `
` + Vr[Qr].replace(" at new ", " at ");
                    return ir.displayName && on.includes("<anonymous>") && (on = on.replace("<anonymous>", ir.displayName)), typeof ir == "function" && dr.set(ir, on), on;
                  }
                while (Qr >= 1 && en >= 0);
              break;
            }
        }
      } finally {
        sr = !1, nr.current = Dr, lr(), Error.prepareStackTrace = Ur;
      }
      var sn = ir ? ir.displayName || ir.name : "", an = sn ? Xt(sn) : "";
      return typeof ir == "function" && dr.set(ir, an), an;
    }
    function pr(ir, vr, Er) {
      return Zt(ir, !1);
    }
    function _r(ir) {
      var vr = ir.prototype;
      return !!(vr && vr.isReactComponent);
    }
    function Ar(ir, vr, Er) {
      if (ir == null)
        return "";
      if (typeof ir == "function")
        return Zt(ir, _r(ir));
      if (typeof ir == "string")
        return Xt(ir);
      switch (ir) {
        case ge:
          return Xt("Suspense");
        case le:
          return Xt("SuspenseList");
      }
      if (typeof ir == "object")
        switch (ir.$$typeof) {
          case ve:
            return pr(ir.render);
          case Ee:
            return Ar(ir.type, vr, Er);
          case Ce: {
            var $r = ir, Ur = $r._payload, Dr = $r._init;
            try {
              return Ar(Dr(Ur), vr, Er);
            } catch {
            }
          }
        }
      return "";
    }
    var Sr = Object.prototype.hasOwnProperty, Br = {}, Ir = Pt.ReactDebugCurrentFrame;
    function wr(ir) {
      if (ir) {
        var vr = ir._owner, Er = Ar(ir.type, ir._source, vr ? vr.type : null);
        Ir.setExtraStackFrame(Er);
      } else
        Ir.setExtraStackFrame(null);
    }
    function Gr(ir, vr, Er, $r, Ur) {
      {
        var Dr = Function.call.bind(Sr);
        for (var qr in ir)
          if (Dr(ir, qr)) {
            var Vr = void 0;
            try {
              if (typeof ir[qr] != "function") {
                var tn = Error(($r || "React class") + ": " + Er + " type `" + qr + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ir[qr] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw tn.name = "Invariant Violation", tn;
              }
              Vr = ir[qr](vr, qr, $r, Er, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qr) {
              Vr = Qr;
            }
            Vr && !(Vr instanceof Error) && (wr(Ur), vt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", $r || "React class", Er, qr, typeof Vr), wr(null)), Vr instanceof Error && !(Vr.message in Br) && (Br[Vr.message] = !0, wr(Ur), vt("Failed %s type: %s", Er, Vr.message), wr(null));
          }
      }
    }
    var Pr = Array.isArray;
    function Mr(ir) {
      return Pr(ir);
    }
    function Cr(ir) {
      {
        var vr = typeof Symbol == "function" && Symbol.toStringTag, Er = vr && ir[Symbol.toStringTag] || ir.constructor.name || "Object";
        return Er;
      }
    }
    function Tr(ir) {
      try {
        return Hr(ir), !1;
      } catch {
        return !0;
      }
    }
    function Hr(ir) {
      return "" + ir;
    }
    function Yr(ir) {
      if (Tr(ir))
        return vt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Cr(ir)), Hr(ir);
    }
    var Nr = Pt.ReactCurrentOwner, zr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Jr, Jt;
    function Dt(ir) {
      if (Sr.call(ir, "ref")) {
        var vr = Object.getOwnPropertyDescriptor(ir, "ref").get;
        if (vr && vr.isReactWarning)
          return !1;
      }
      return ir.ref !== void 0;
    }
    function Gt(ir) {
      if (Sr.call(ir, "key")) {
        var vr = Object.getOwnPropertyDescriptor(ir, "key").get;
        if (vr && vr.isReactWarning)
          return !1;
      }
      return ir.key !== void 0;
    }
    function rr(ir, vr) {
      typeof ir.ref == "string" && Nr.current;
    }
    function cr(ir, vr) {
      {
        var Er = function() {
          Jr || (Jr = !0, vt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", vr));
        };
        Er.isReactWarning = !0, Object.defineProperty(ir, "key", {
          get: Er,
          configurable: !0
        });
      }
    }
    function br(ir, vr) {
      {
        var Er = function() {
          Jt || (Jt = !0, vt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", vr));
        };
        Er.isReactWarning = !0, Object.defineProperty(ir, "ref", {
          get: Er,
          configurable: !0
        });
      }
    }
    var gr = function(ir, vr, Er, $r, Ur, Dr, qr) {
      var Vr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: z,
        // Built-in properties that belong on the element
        type: ir,
        key: vr,
        ref: Er,
        props: qr,
        // Record the component responsible for creating this element.
        _owner: Dr
      };
      return Vr._store = {}, Object.defineProperty(Vr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Vr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: $r
      }), Object.defineProperty(Vr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ur
      }), Object.freeze && (Object.freeze(Vr.props), Object.freeze(Vr)), Vr;
    };
    function Or(ir, vr, Er, $r, Ur) {
      {
        var Dr, qr = {}, Vr = null, tn = null;
        Er !== void 0 && (Yr(Er), Vr = "" + Er), Gt(vr) && (Yr(vr.key), Vr = "" + vr.key), Dt(vr) && (tn = vr.ref, rr(vr, Ur));
        for (Dr in vr)
          Sr.call(vr, Dr) && !zr.hasOwnProperty(Dr) && (qr[Dr] = vr[Dr]);
        if (ir && ir.defaultProps) {
          var Qr = ir.defaultProps;
          for (Dr in Qr)
            qr[Dr] === void 0 && (qr[Dr] = Qr[Dr]);
        }
        if (Vr || tn) {
          var en = typeof ir == "function" ? ir.displayName || ir.name || "Unknown" : ir;
          Vr && cr(qr, en), tn && br(qr, en);
        }
        return gr(ir, Vr, tn, Ur, $r, Nr.current, qr);
      }
    }
    var Wr = Pt.ReactCurrentOwner, kr = Pt.ReactDebugCurrentFrame;
    function jr(ir) {
      if (ir) {
        var vr = ir._owner, Er = Ar(ir.type, ir._source, vr ? vr.type : null);
        kr.setExtraStackFrame(Er);
      } else
        kr.setExtraStackFrame(null);
    }
    var Lr;
    Lr = !1;
    function Fr(ir) {
      return typeof ir == "object" && ir !== null && ir.$$typeof === z;
    }
    function Xr() {
      {
        if (Wr.current) {
          var ir = Je(Wr.current.type);
          if (ir)
            return `

Check the render method of \`` + ir + "`.";
        }
        return "";
      }
    }
    function Zr(ir) {
      return "";
    }
    var fr = {};
    function tr(ir) {
      {
        var vr = Xr();
        if (!vr) {
          var Er = typeof ir == "string" ? ir : ir.displayName || ir.name;
          Er && (vr = `

Check the top-level render call using <` + Er + ">.");
        }
        return vr;
      }
    }
    function ur(ir, vr) {
      {
        if (!ir._store || ir._store.validated || ir.key != null)
          return;
        ir._store.validated = !0;
        var Er = tr(vr);
        if (fr[Er])
          return;
        fr[Er] = !0;
        var $r = "";
        ir && ir._owner && ir._owner !== Wr.current && ($r = " It was passed a child from " + Je(ir._owner.type) + "."), jr(ir), vt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Er, $r), jr(null);
      }
    }
    function jt(ir, vr) {
      {
        if (typeof ir != "object")
          return;
        if (Mr(ir))
          for (var Er = 0; Er < ir.length; Er++) {
            var $r = ir[Er];
            Fr($r) && ur($r, vr);
          }
        else if (Fr(ir))
          ir._store && (ir._store.validated = !0);
        else if (ir) {
          var Ur = wt(ir);
          if (typeof Ur == "function" && Ur !== ir.entries)
            for (var Dr = Ur.call(ir), qr; !(qr = Dr.next()).done; )
              Fr(qr.value) && ur(qr.value, vr);
        }
      }
    }
    function Ot(ir) {
      {
        var vr = ir.type;
        if (vr == null || typeof vr == "string")
          return;
        var Er;
        if (typeof vr == "function")
          Er = vr.propTypes;
        else if (typeof vr == "object" && (vr.$$typeof === ve || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        vr.$$typeof === Ee))
          Er = vr.propTypes;
        else
          return;
        if (Er) {
          var $r = Je(vr);
          Gr(Er, ir.props, "prop", $r, ir);
        } else if (vr.PropTypes !== void 0 && !Lr) {
          Lr = !0;
          var Ur = Je(vr);
          vt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ur || "Unknown");
        }
        typeof vr.getDefaultProps == "function" && !vr.getDefaultProps.isReactClassApproved && vt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Lt(ir) {
      {
        for (var vr = Object.keys(ir.props), Er = 0; Er < vr.length; Er++) {
          var $r = vr[Er];
          if ($r !== "children" && $r !== "key") {
            jr(ir), vt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", $r), jr(null);
            break;
          }
        }
        ir.ref !== null && (jr(ir), vt("Invalid attribute `ref` supplied to `React.Fragment`."), jr(null));
      }
    }
    var Qt = {};
    function or(ir, vr, Er, $r, Ur, Dr) {
      {
        var qr = zt(ir);
        if (!qr) {
          var Vr = "";
          (ir === void 0 || typeof ir == "object" && ir !== null && Object.keys(ir).length === 0) && (Vr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var tn = Zr();
          tn ? Vr += tn : Vr += Xr();
          var Qr;
          ir === null ? Qr = "null" : Mr(ir) ? Qr = "array" : ir !== void 0 && ir.$$typeof === z ? (Qr = "<" + (Je(ir.type) || "Unknown") + " />", Vr = " Did you accidentally export a JSX literal instead of a component?") : Qr = typeof ir, vt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Qr, Vr);
        }
        var en = Or(ir, vr, Er, Ur, Dr);
        if (en == null)
          return en;
        if (qr) {
          var on = vr.children;
          if (on !== void 0)
            if ($r)
              if (Mr(on)) {
                for (var sn = 0; sn < on.length; sn++)
                  jt(on[sn], ir);
                Object.freeze && Object.freeze(on);
              } else
                vt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              jt(on, ir);
        }
        if (Sr.call(vr, "key")) {
          var an = Je(ir), nn = Object.keys(vr).filter(function(cn) {
            return cn !== "key";
          }), fn = nn.length > 0 ? "{key: someKey, " + nn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Qt[an + fn]) {
            var un = nn.length > 0 ? "{" + nn.join(": ..., ") + ": ...}" : "{}";
            vt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fn, an, un, an), Qt[an + fn] = !0;
          }
        }
        return ir === ne ? Lt(en) : Ot(en), en;
      }
    }
    function hr(ir, vr, Er) {
      return or(ir, vr, Er, !0);
    }
    function yr(ir, vr, Er) {
      return or(ir, vr, Er, !1);
    }
    var xr = yr, Rr = hr;
    reactJsxRuntime_development.Fragment = ne, reactJsxRuntime_development.jsx = xr, reactJsxRuntime_development.jsxs = Rr;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, z] = useState(!1);
  return useEffect(() => {
    z(!0);
  }, []), B;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(B) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const z = `${KEY_PREFIX}_${B}`;
  try {
    const Y = window.localStorage.getItem(z);
    return Y != null ? JSON.parse(Y) : null;
  } catch (Y) {
    return console.error(`Error retrieving ${z} from localStorage`, Y), null;
  }
}
function setItemToLocalStorage(B, z) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const Y = `${KEY_PREFIX}_${B}`;
  try {
    z ? window.localStorage.setItem(Y, JSON.stringify(z)) : window.localStorage.removeItem(Y);
  } catch (ne) {
    console.error(`Error saving ${Y} to localStorage`, ne);
  }
}
function useLocalStorage(B, z, Y = {}) {
  const { initializeWithValue: ne = !0 } = Y, oe = useCallback(() => {
    const ve = getItemFromLocalStorage(B);
    return ve || (setItemToLocalStorage(B, z), z);
  }, [z, B]), [ie, ae] = useState(() => ne ? oe() : z), se = useCallback(
    (ve) => {
      setItemToLocalStorage(B, ve), ae(ve);
    },
    [B]
  );
  return useEffect(() => {
    ae(oe());
  }, [B]), [ie, se];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {}), Chain = /* @__PURE__ */ ((B) => (B.BITCOIN = "bitcoin", B.FRACTAL_BITCOIN = "fractal-bitcoin", B))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: B,
  network: z,
  visibleWallets: Y,
  chain: ne = "bitcoin",
  ssr: oe = !1
}) {
  if (!z)
    throw new Error("Network cannot be empty");
  if (!Y || Y.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [ie, ae] = useState(z), [se, ve] = useState(Y), [ge, le] = useState(ne), [Ee, Ce] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !oe }
  ), [Pe, Xe] = useLocalStorage(WALLET, null, {
    initializeWithValue: !oe
  }), [ht, wt] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !oe }
  ), [Pt, vt] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !oe }
  ), [Bt, Ct] = useState(!1), Wt = useCallback(() => Ct(!0), []), Kt = useCallback(() => Ct(!1), []), Yt = useCallback(() => {
    Ce(EMPTY_BIADDRESS_OBJECT), wt(EMPTY_BIADDRESS_OBJECT), vt(EMPTY_BIADDRESS_OBJECT), Xe(null);
  }, [Ce, vt, wt, Xe]), Ut = useMemo(
    () => ({
      address: Ee,
      updateAddress: Ce,
      publicKey: ht,
      updatePublicKey: wt,
      network: ie,
      updateNetwork: (qt) => {
        console.log("updateNetwork", qt), ae(qt);
      },
      wallet: Pe,
      updateWallet: Xe,
      isModalOpen: Bt,
      openModal: Wt,
      closeModal: Kt,
      format: Pt,
      updateFormat: vt,
      disconnectWallet: Yt,
      chain: ge,
      updateChain: le,
      visibleWallets: se,
      updateVisibleWallets: ve
    }),
    [
      Ee,
      Ce,
      ht,
      wt,
      ie,
      Pe,
      Bt,
      Wt,
      Kt,
      Pt,
      vt,
      Yt,
      ge,
      se,
      Xe
    ]
  );
  return useEffect(() => {
    ae(z);
  }, [z]), useEffect(() => {
    ge !== ne && (Yt(), le(ne));
  }, [ne, ge, Yt]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: Ut, children: B });
}
function useOrdConnect() {
  const B = useContext(OrdConnectContext);
  if (!B)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return B;
}
var build = { exports: {} };
(function(B, z) {
  (function(Y, ne) {
    B.exports = ne(React__default);
  })(commonjsGlobal, function(Y) {
    return function(ne) {
      var oe = {};
      function ie(ae) {
        if (oe[ae]) return oe[ae].exports;
        var se = oe[ae] = { i: ae, l: !1, exports: {} };
        return ne[ae].call(se.exports, se, se.exports, ie), se.l = !0, se.exports;
      }
      return ie.m = ne, ie.c = oe, ie.d = function(ae, se, ve) {
        ie.o(ae, se) || Object.defineProperty(ae, se, { enumerable: !0, get: ve });
      }, ie.r = function(ae) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(ae, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(ae, "__esModule", { value: !0 });
      }, ie.t = function(ae, se) {
        if (1 & se && (ae = ie(ae)), 8 & se || 4 & se && typeof ae == "object" && ae && ae.__esModule) return ae;
        var ve = /* @__PURE__ */ Object.create(null);
        if (ie.r(ve), Object.defineProperty(ve, "default", { enumerable: !0, value: ae }), 2 & se && typeof ae != "string") for (var ge in ae) ie.d(ve, ge, (function(le) {
          return ae[le];
        }).bind(null, ge));
        return ve;
      }, ie.n = function(ae) {
        var se = ae && ae.__esModule ? function() {
          return ae.default;
        } : function() {
          return ae;
        };
        return ie.d(se, "a", se), se;
      }, ie.o = function(ae, se) {
        return Object.prototype.hasOwnProperty.call(ae, se);
      }, ie.p = "/", ie(ie.s = 1);
    }([function(ne, oe) {
      ne.exports = Y;
    }, function(ne, oe, ie) {
      ne.exports = ie(2);
    }, function(ne, oe, ie) {
      function ae(vt, Bt) {
        if (vt == null) return {};
        var Ct, Wt, Kt = function(Ut, qt) {
          if (Ut == null) return {};
          var zt, Ft, Ve = {}, Je = Object.keys(Ut);
          for (Ft = 0; Ft < Je.length; Ft++) zt = Je[Ft], qt.indexOf(zt) >= 0 || (Ve[zt] = Ut[zt]);
          return Ve;
        }(vt, Bt);
        if (Object.getOwnPropertySymbols) {
          var Yt = Object.getOwnPropertySymbols(vt);
          for (Wt = 0; Wt < Yt.length; Wt++) Ct = Yt[Wt], Bt.indexOf(Ct) >= 0 || Object.prototype.propertyIsEnumerable.call(vt, Ct) && (Kt[Ct] = vt[Ct]);
        }
        return Kt;
      }
      ie.r(oe);
      var se = ie(0), ve = ie.n(se), ge = function(vt) {
        for (var Bt = 0, Ct = 0; Ct < vt.length; Ct++)
          Bt = (Bt << 5) - Bt + vt.charCodeAt(Ct), Bt &= Bt;
        return Math.abs(Bt);
      }, le = function(vt, Bt) {
        return Math.floor(vt / Math.pow(10, Bt) % 10);
      }, Ee = function(vt, Bt) {
        return !(le(vt, Bt) % 2);
      }, Ce = function(vt, Bt, Ct) {
        var Wt = vt % Bt;
        return Ct && le(vt, Ct) % 2 === 0 ? -Wt : Wt;
      }, Pe = function(vt, Bt, Ct) {
        return Bt[vt % Ct];
      }, Xe = function(vt) {
        var Bt = vt.name, Ct = vt.colors, Wt = vt.title, Kt = vt.square, Yt = vt.size, Ut = ae(vt, ["name", "colors", "title", "square", "size"]), qt = function(Ft, Ve) {
          var Je = ge(Ft), Ke = Ve && Ve.length;
          return Array.from({ length: 3 }, function(Qe, bt) {
            return { color: Pe(Je + bt, Ve, Ke), translateX: Ce(Je * (bt + 1), 8, 1), translateY: Ce(Je * (bt + 1), 8, 2), scale: 1.2 + Ce(Je * (bt + 1), 4) / 10, rotate: Ce(Je * (bt + 1), 360, 1) };
          });
        }(Bt, Ct), zt = se.useId();
        return se.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), Wt && se.createElement("title", null, Bt), se.createElement("mask", { id: zt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, se.createElement("rect", { width: 80, height: 80, rx: Kt ? void 0 : 160, fill: "#FFFFFF" })), se.createElement("g", { mask: "url(#".concat(zt, ")") }, se.createElement("rect", { width: 80, height: 80, fill: qt[0].color }), se.createElement("path", { filter: "url(#filter_".concat(zt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: qt[1].color, transform: "translate(" + qt[1].translateX + " " + qt[1].translateY + ") rotate(" + qt[1].rotate + " 40 40) scale(" + qt[2].scale + ")" }), se.createElement("path", { filter: "url(#filter_".concat(zt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: qt[2].color, transform: "translate(" + qt[2].translateX + " " + qt[2].translateY + ") rotate(" + qt[2].rotate + " 40 40) scale(" + qt[2].scale + ")" })), se.createElement("defs", null, se.createElement("filter", { id: "filter_".concat(zt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, se.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), se.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), se.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, ht = { pixel: function(vt) {
        var Bt = vt.name, Ct = vt.colors, Wt = vt.title, Kt = vt.square, Yt = vt.size, Ut = ae(vt, ["name", "colors", "title", "square", "size"]), qt = function(Ft, Ve) {
          var Je = ge(Ft), Ke = Ve && Ve.length;
          return Array.from({ length: 64 }, function(Qe, bt) {
            return Pe(Je % (bt + 1), Ve, Ke);
          });
        }(Bt, Ct), zt = se.useId();
        return se.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), Wt && se.createElement("title", null, Bt), se.createElement("mask", { id: zt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, se.createElement("rect", { width: 80, height: 80, rx: Kt ? void 0 : 160, fill: "#FFFFFF" })), se.createElement("g", { mask: "url(#".concat(zt, ")") }, se.createElement("rect", { width: 10, height: 10, fill: qt[0] }), se.createElement("rect", { x: 20, width: 10, height: 10, fill: qt[1] }), se.createElement("rect", { x: 40, width: 10, height: 10, fill: qt[2] }), se.createElement("rect", { x: 60, width: 10, height: 10, fill: qt[3] }), se.createElement("rect", { x: 10, width: 10, height: 10, fill: qt[4] }), se.createElement("rect", { x: 30, width: 10, height: 10, fill: qt[5] }), se.createElement("rect", { x: 50, width: 10, height: 10, fill: qt[6] }), se.createElement("rect", { x: 70, width: 10, height: 10, fill: qt[7] }), se.createElement("rect", { y: 10, width: 10, height: 10, fill: qt[8] }), se.createElement("rect", { y: 20, width: 10, height: 10, fill: qt[9] }), se.createElement("rect", { y: 30, width: 10, height: 10, fill: qt[10] }), se.createElement("rect", { y: 40, width: 10, height: 10, fill: qt[11] }), se.createElement("rect", { y: 50, width: 10, height: 10, fill: qt[12] }), se.createElement("rect", { y: 60, width: 10, height: 10, fill: qt[13] }), se.createElement("rect", { y: 70, width: 10, height: 10, fill: qt[14] }), se.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: qt[15] }), se.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: qt[16] }), se.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: qt[17] }), se.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: qt[18] }), se.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: qt[19] }), se.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: qt[20] }), se.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: qt[21] }), se.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: qt[22] }), se.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: qt[23] }), se.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: qt[24] }), se.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: qt[25] }), se.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: qt[26] }), se.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: qt[27] }), se.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: qt[28] }), se.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: qt[29] }), se.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: qt[30] }), se.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: qt[31] }), se.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: qt[32] }), se.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: qt[33] }), se.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: qt[34] }), se.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: qt[35] }), se.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: qt[36] }), se.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: qt[37] }), se.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: qt[38] }), se.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: qt[39] }), se.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: qt[40] }), se.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: qt[41] }), se.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: qt[42] }), se.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: qt[43] }), se.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: qt[44] }), se.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: qt[45] }), se.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: qt[46] }), se.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: qt[47] }), se.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: qt[48] }), se.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: qt[49] }), se.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: qt[50] }), se.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: qt[51] }), se.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: qt[52] }), se.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: qt[53] }), se.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: qt[54] }), se.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: qt[55] }), se.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: qt[56] }), se.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: qt[57] }), se.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: qt[58] }), se.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: qt[59] }), se.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: qt[60] }), se.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: qt[61] }), se.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: qt[62] }), se.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: qt[63] })));
      }, bauhaus: function(vt) {
        var Bt = vt.name, Ct = vt.colors, Wt = vt.title, Kt = vt.square, Yt = vt.size, Ut = ae(vt, ["name", "colors", "title", "square", "size"]), qt = function(Ft, Ve) {
          var Je = ge(Ft), Ke = Ve && Ve.length;
          return Array.from({ length: 4 }, function(Qe, bt) {
            return { color: Pe(Je + bt, Ve, Ke), translateX: Ce(Je * (bt + 1), 40 - (bt + 17), 1), translateY: Ce(Je * (bt + 1), 40 - (bt + 17), 2), rotate: Ce(Je * (bt + 1), 360), isSquare: Ee(Je, 2) };
          });
        }(Bt, Ct), zt = se.useId();
        return se.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), Wt && se.createElement("title", null, Bt), se.createElement("mask", { id: zt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, se.createElement("rect", { width: 80, height: 80, rx: Kt ? void 0 : 160, fill: "#FFFFFF" })), se.createElement("g", { mask: "url(#".concat(zt, ")") }, se.createElement("rect", { width: 80, height: 80, fill: qt[0].color }), se.createElement("rect", { x: 10, y: 30, width: 80, height: qt[1].isSquare ? 80 : 10, fill: qt[1].color, transform: "translate(" + qt[1].translateX + " " + qt[1].translateY + ") rotate(" + qt[1].rotate + " 40 40)" }), se.createElement("circle", { cx: 40, cy: 40, fill: qt[2].color, r: 16, transform: "translate(" + qt[2].translateX + " " + qt[2].translateY + ")" }), se.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: qt[3].color, transform: "translate(" + qt[3].translateX + " " + qt[3].translateY + ") rotate(" + qt[3].rotate + " 40 40)" })));
      }, ring: function(vt) {
        var Bt = vt.name, Ct = vt.colors, Wt = vt.title, Kt = vt.square, Yt = vt.size, Ut = ae(vt, ["name", "colors", "title", "square", "size"]), qt = function(Ft, Ve) {
          var Je = ge(Ve), Ke = Ft && Ft.length, Qe = Array.from({ length: 5 }, function(_t, $t) {
            return Pe(Je + $t, Ft, Ke);
          }), bt = [];
          return bt[0] = Qe[0], bt[1] = Qe[1], bt[2] = Qe[1], bt[3] = Qe[2], bt[4] = Qe[2], bt[5] = Qe[3], bt[6] = Qe[3], bt[7] = Qe[0], bt[8] = Qe[4], bt;
        }(Ct, Bt), zt = ve.a.useId();
        return ve.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), Wt && ve.a.createElement("title", null, Bt), ve.a.createElement("mask", { id: zt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ve.a.createElement("rect", { width: 90, height: 90, rx: Kt ? void 0 : 180, fill: "#FFFFFF" })), ve.a.createElement("g", { mask: "url(#".concat(zt, ")") }, ve.a.createElement("path", { d: "M0 0h90v45H0z", fill: qt[0] }), ve.a.createElement("path", { d: "M0 45h90v45H0z", fill: qt[1] }), ve.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: qt[2] }), ve.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: qt[3] }), ve.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: qt[4] }), ve.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: qt[5] }), ve.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: qt[6] }), ve.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: qt[7] }), ve.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: qt[8] })));
      }, beam: function(vt) {
        var Bt = vt.name, Ct = vt.colors, Wt = vt.title, Kt = vt.square, Yt = vt.size, Ut = ae(vt, ["name", "colors", "title", "square", "size"]), qt = function(Ft, Ve) {
          var Je, Ke = ge(Ft), Qe = Ve && Ve.length, bt = Pe(Ke, Ve, Qe), _t = Ce(Ke, 10, 1), $t = _t < 5 ? _t + 4 : _t, kt = Ce(Ke, 10, 2), xt = kt < 5 ? kt + 4 : kt;
          return { wrapperColor: bt, faceColor: (Je = bt, Je.slice(0, 1) === "#" && (Je = Je.slice(1)), (299 * parseInt(Je.substr(0, 2), 16) + 587 * parseInt(Je.substr(2, 2), 16) + 114 * parseInt(Je.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Pe(Ke + 13, Ve, Qe), wrapperTranslateX: $t, wrapperTranslateY: xt, wrapperRotate: Ce(Ke, 360), wrapperScale: 1 + Ce(Ke, 3) / 10, isMouthOpen: Ee(Ke, 2), isCircle: Ee(Ke, 1), eyeSpread: Ce(Ke, 5), mouthSpread: Ce(Ke, 3), faceRotate: Ce(Ke, 10, 3), faceTranslateX: $t > 6 ? $t / 2 : Ce(Ke, 8, 1), faceTranslateY: xt > 6 ? xt / 2 : Ce(Ke, 7, 2) };
        }(Bt, Ct), zt = se.useId();
        return se.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), Wt && se.createElement("title", null, Bt), se.createElement("mask", { id: zt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, se.createElement("rect", { width: 36, height: 36, rx: Kt ? void 0 : 72, fill: "#FFFFFF" })), se.createElement("g", { mask: "url(#".concat(zt, ")") }, se.createElement("rect", { width: 36, height: 36, fill: qt.backgroundColor }), se.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + qt.wrapperTranslateX + " " + qt.wrapperTranslateY + ") rotate(" + qt.wrapperRotate + " 18 18) scale(" + qt.wrapperScale + ")", fill: qt.wrapperColor, rx: qt.isCircle ? 36 : 6 }), se.createElement("g", { transform: "translate(" + qt.faceTranslateX + " " + qt.faceTranslateY + ") rotate(" + qt.faceRotate + " 18 18)" }, qt.isMouthOpen ? se.createElement("path", { d: "M15 " + (19 + qt.mouthSpread) + "c2 1 4 1 6 0", stroke: qt.faceColor, fill: "none", strokeLinecap: "round" }) : se.createElement("path", { d: "M13," + (19 + qt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: qt.faceColor }), se.createElement("rect", { x: 14 - qt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: qt.faceColor }), se.createElement("rect", { x: 20 + qt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: qt.faceColor }))));
      }, sunset: function(vt) {
        var Bt = vt.name, Ct = vt.colors, Wt = vt.title, Kt = vt.square, Yt = vt.size, Ut = ae(vt, ["name", "colors", "title", "square", "size"]), qt = function(Ve, Je) {
          var Ke = ge(Ve), Qe = Je && Je.length;
          return Array.from({ length: 4 }, function(bt, _t) {
            return Pe(Ke + _t, Je, Qe);
          });
        }(Bt, Ct), zt = Bt.replace(/\s/g, ""), Ft = se.useId();
        return se.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), Wt && se.createElement("title", null, Bt), se.createElement("mask", { id: Ft, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, se.createElement("rect", { width: 80, height: 80, rx: Kt ? void 0 : 160, fill: "#FFFFFF" })), se.createElement("g", { mask: "url(#".concat(Ft, ")") }, se.createElement("path", { fill: "url(#gradient_paint0_linear_" + zt + ")", d: "M0 0h80v40H0z" }), se.createElement("path", { fill: "url(#gradient_paint1_linear_" + zt + ")", d: "M0 40h80v40H0z" })), se.createElement("defs", null, se.createElement("linearGradient", { id: "gradient_paint0_linear_" + zt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, se.createElement("stop", { stopColor: qt[0] }), se.createElement("stop", { offset: 1, stopColor: qt[1] })), se.createElement("linearGradient", { id: "gradient_paint1_linear_" + zt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, se.createElement("stop", { stopColor: qt[2] }), se.createElement("stop", { offset: 1, stopColor: qt[3] }))));
      }, marble: Xe }, wt = { geometric: "beam", abstract: "bauhaus" }, Pt = function(vt) {
        var Bt = vt.variant, Ct = Bt === void 0 ? "marble" : Bt, Wt = vt.colors, Kt = Wt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : Wt, Yt = vt.name, Ut = Yt === void 0 ? "Clara Barton" : Yt, qt = vt.title, zt = qt !== void 0 && qt, Ft = vt.size, Ve = vt.square, Je = Ve !== void 0 && Ve, Ke = ae(vt, ["variant", "colors", "name", "title", "size", "square"]), Qe = ht[wt[Ct] || Ct] || Xe;
        return ve.a.createElement(Qe, Object.assign({ colors: Kt, name: Ut, title: zt, size: Ft, square: Je }, Ke));
      };
      oe.default = Pt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports), $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(B) {
  const z = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    z.current = B;
  }, [
    B
  ]), useCallback((...Y) => {
    const ne = z.current;
    return ne == null ? void 0 : ne(...Y);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (B) => {
  var z;
  return (z = B == null ? void 0 : B.ownerDocument) !== null && z !== void 0 ? z : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (B) => B && "window" in B && B.window === B ? B : $431fbd86ca7dc216$export$b204af158042fbac(B).defaultView || window;
function $c87311424ea30a05$var$testUserAgent(B) {
  var z;
  return typeof window > "u" || window.navigator == null ? !1 : ((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.brands.some((Y) => B.test(Y.brand))) || B.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(B) {
  var z;
  return typeof window < "u" && window.navigator != null ? B.test(((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(B) {
  let z = null;
  return () => (z == null && (z = B()), z);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $6a7db85432448f7f$export$60278871457622de(B) {
  return B.mozInputSource === 0 && B.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && B.pointerType ? B.type === "click" && B.buttons === 1 : B.detail === 0 && !B.pointerType;
}
class $8a9cb279dc87e130$export$905e7fc544a71f36 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(z, Y) {
    this.nativeEvent = Y, this.target = Y.target, this.currentTarget = Y.currentTarget, this.relatedTarget = Y.relatedTarget, this.bubbles = Y.bubbles, this.cancelable = Y.cancelable, this.defaultPrevented = Y.defaultPrevented, this.eventPhase = Y.eventPhase, this.isTrusted = Y.isTrusted, this.timeStamp = Y.timeStamp, this.type = z;
  }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(B) {
  let z = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const ne = z.current;
    return () => {
      ne.observer && (ne.observer.disconnect(), ne.observer = null);
    };
  }, []);
  let Y = $8ae05eaa5c114e9c$export$7f54fc3180508a52((ne) => {
    B == null || B(ne);
  });
  return useCallback((ne) => {
    if (ne.target instanceof HTMLButtonElement || ne.target instanceof HTMLInputElement || ne.target instanceof HTMLTextAreaElement || ne.target instanceof HTMLSelectElement) {
      z.current.isFocused = !0;
      let oe = ne.target, ie = (ae) => {
        z.current.isFocused = !1, oe.disabled && Y(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", ae)), z.current.observer && (z.current.observer.disconnect(), z.current.observer = null);
      };
      oe.addEventListener("focusout", ie, {
        once: !0
      }), z.current.observer = new MutationObserver(() => {
        if (z.current.isFocused && oe.disabled) {
          var ae;
          (ae = z.current.observer) === null || ae === void 0 || ae.disconnect();
          let se = oe === document.activeElement ? null : document.activeElement;
          oe.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: se
          })), oe.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: se
          }));
        }
      }), z.current.observer.observe(oe, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    Y
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(B) {
  let { isDisabled: z, onFocus: Y, onBlur: ne, onFocusChange: oe } = B;
  const ie = useCallback((ve) => {
    if (ve.target === ve.currentTarget)
      return ne && ne(ve), oe && oe(!1), !0;
  }, [
    ne,
    oe
  ]), ae = $8a9cb279dc87e130$export$715c682d09d639cc(ie), se = useCallback((ve) => {
    const ge = $431fbd86ca7dc216$export$b204af158042fbac(ve.target);
    ve.target === ve.currentTarget && ge.activeElement === ve.target && (Y && Y(ve), oe && oe(!0), ae(ve));
  }, [
    oe,
    Y,
    ae
  ]);
  return {
    focusProps: {
      onFocus: !z && (Y || oe || ne) ? se : void 0,
      onBlur: !z && (ne || oe) ? ie : void 0
    }
  };
}
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(B, z) {
  for (let Y of $507fabe10e71c6fb$var$changeHandlers) Y(B, z);
}
function $507fabe10e71c6fb$var$isValidKey(B) {
  return !(B.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && B.altKey || B.ctrlKey || B.key === "Control" || B.key === "Shift" || B.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(B) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(B) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", B));
}
function $507fabe10e71c6fb$var$handlePointerEvent(B) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (B.type === "mousedown" || B.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", B));
}
function $507fabe10e71c6fb$var$handleClickEvent(B) {
  $6a7db85432448f7f$export$60278871457622de(B) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(B) {
  B.target === window || B.target === document || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", B)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(B))) return;
  const z = $431fbd86ca7dc216$export$f21a1ffae260145a(B), Y = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let ne = z.HTMLElement.prototype.focus;
  z.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, ne.apply(this, arguments);
  }, Y.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), z.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), z.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (Y.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (Y.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), z.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(z, {
    focus: ne
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (B, z) => {
  const Y = $431fbd86ca7dc216$export$f21a1ffae260145a(B), ne = $431fbd86ca7dc216$export$b204af158042fbac(B);
  z && ne.removeEventListener("DOMContentLoaded", z), $507fabe10e71c6fb$export$d90243b58daecda7.has(Y) && (Y.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(Y).focus, ne.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ne.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), Y.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), Y.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (ne.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (ne.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ne.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(Y));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(B) {
  const z = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let Y;
  return z.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) : (Y = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(B);
  }, z.addEventListener("DOMContentLoaded", Y)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B, Y);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(B, z, Y) {
  var ne;
  const oe = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLInputElement : HTMLInputElement, ie = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLTextAreaElement : HTMLTextAreaElement, ae = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLElement : HTMLElement, se = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).KeyboardEvent : KeyboardEvent;
  return B = B || (Y == null ? void 0 : Y.target) instanceof oe && !$507fabe10e71c6fb$var$nonTextInputTypes.has(Y == null || (ne = Y.target) === null || ne === void 0 ? void 0 : ne.type) || (Y == null ? void 0 : Y.target) instanceof ie || (Y == null ? void 0 : Y.target) instanceof ae && (Y == null ? void 0 : Y.target.isContentEditable), !(B && z === "keyboard" && Y instanceof se && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[Y.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(B, z, Y) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let ne = (oe, ie) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(Y != null && Y.isTextInput), oe, ie) && B($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(ne), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(ne);
    };
  }, z);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(B) {
  let { isDisabled: z, onBlurWithin: Y, onFocusWithin: ne, onFocusWithinChange: oe } = B, ie = useRef({
    isFocusWithin: !1
  }), ae = useCallback((ge) => {
    ie.current.isFocusWithin && !ge.currentTarget.contains(ge.relatedTarget) && (ie.current.isFocusWithin = !1, Y && Y(ge), oe && oe(!1));
  }, [
    Y,
    oe,
    ie
  ]), se = $8a9cb279dc87e130$export$715c682d09d639cc(ae), ve = useCallback((ge) => {
    !ie.current.isFocusWithin && document.activeElement === ge.target && (ne && ne(ge), oe && oe(!0), ie.current.isFocusWithin = !0, se(ge));
  }, [
    ne,
    oe,
    se
  ]);
  return z ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: ve,
      onBlur: ae
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(B) {
  B.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(B) {
  let { onHoverStart: z, onHoverChange: Y, onHoverEnd: ne, isDisabled: oe } = B, [ie, ae] = useState(!1), se = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps: ve, triggerHoverEnd: ge } = useMemo(() => {
    let le = (Pe, Xe) => {
      if (se.pointerType = Xe, oe || Xe === "touch" || se.isHovered || !Pe.currentTarget.contains(Pe.target)) return;
      se.isHovered = !0;
      let ht = Pe.currentTarget;
      se.target = ht, z && z({
        type: "hoverstart",
        target: ht,
        pointerType: Xe
      }), Y && Y(!0), ae(!0);
    }, Ee = (Pe, Xe) => {
      if (se.pointerType = "", se.target = null, Xe === "touch" || !se.isHovered) return;
      se.isHovered = !1;
      let ht = Pe.currentTarget;
      ne && ne({
        type: "hoverend",
        target: ht,
        pointerType: Xe
      }), Y && Y(!1), ae(!1);
    }, Ce = {};
    return typeof PointerEvent < "u" ? (Ce.onPointerEnter = (Pe) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && Pe.pointerType === "mouse" || le(Pe, Pe.pointerType);
    }, Ce.onPointerLeave = (Pe) => {
      !oe && Pe.currentTarget.contains(Pe.target) && Ee(Pe, Pe.pointerType);
    }) : (Ce.onTouchStart = () => {
      se.ignoreEmulatedMouseEvents = !0;
    }, Ce.onMouseEnter = (Pe) => {
      !se.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && le(Pe, "mouse"), se.ignoreEmulatedMouseEvents = !1;
    }, Ce.onMouseLeave = (Pe) => {
      !oe && Pe.currentTarget.contains(Pe.target) && Ee(Pe, "mouse");
    }), {
      hoverProps: Ce,
      triggerHoverEnd: Ee
    };
  }, [
    z,
    Y,
    ne,
    oe,
    se
  ]);
  return useEffect(() => {
    oe && ge({
      currentTarget: se.target
    }, se.pointerType);
  }, [
    oe
  ]), {
    hoverProps: ve,
    isHovered: ie
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(B = {}) {
  let { autoFocus: z = !1, isTextInput: Y, within: ne } = B, oe = useRef({
    isFocused: !1,
    isFocusVisible: z || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [ie, ae] = useState(!1), [se, ve] = useState(() => oe.current.isFocused && oe.current.isFocusVisible), ge = useCallback(() => ve(oe.current.isFocused && oe.current.isFocusVisible), []), le = useCallback((Pe) => {
    oe.current.isFocused = Pe, ae(Pe), ge();
  }, [
    ge
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((Pe) => {
    oe.current.isFocusVisible = Pe, ge();
  }, [], {
    isTextInput: Y
  });
  let { focusProps: Ee } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: ne,
    onFocusChange: le
  }), { focusWithinProps: Ce } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !ne,
    onFocusWithinChange: le
  });
  return {
    isFocused: ie,
    isFocusVisible: se,
    focusProps: ne ? Ce : Ee
  };
}
var i$7 = Object.defineProperty, d$3 = (B, z, Y) => z in B ? i$7(B, z, { enumerable: !0, configurable: !0, writable: !0, value: Y }) : B[z] = Y, r$4 = (B, z, Y) => (d$3(B, typeof z != "symbol" ? z + "" : z, Y), Y);
let o$6 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(z) {
    this.current !== z && (this.handoffState = "pending", this.currentId = 0, this.current = z);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$8 = new o$6();
function u$8(B) {
  return s$8.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
function t$4(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((z) => setTimeout(() => {
    throw z;
  }));
}
function o$5() {
  let B = [], z = { addEventListener(Y, ne, oe, ie) {
    return Y.addEventListener(ne, oe, ie), z.add(() => Y.removeEventListener(ne, oe, ie));
  }, requestAnimationFrame(...Y) {
    let ne = requestAnimationFrame(...Y);
    return z.add(() => cancelAnimationFrame(ne));
  }, nextFrame(...Y) {
    return z.requestAnimationFrame(() => z.requestAnimationFrame(...Y));
  }, setTimeout(...Y) {
    let ne = setTimeout(...Y);
    return z.add(() => clearTimeout(ne));
  }, microTask(...Y) {
    let ne = { current: !0 };
    return t$4(() => {
      ne.current && Y[0]();
    }), z.add(() => {
      ne.current = !1;
    });
  }, style(Y, ne, oe) {
    let ie = Y.style.getPropertyValue(ne);
    return Object.assign(Y.style, { [ne]: oe }), this.add(() => {
      Object.assign(Y.style, { [ne]: ie });
    });
  }, group(Y) {
    let ne = o$5();
    return Y(ne), this.add(() => ne.dispose());
  }, add(Y) {
    return B.includes(Y) || B.push(Y), () => {
      let ne = B.indexOf(Y);
      if (ne >= 0) for (let oe of B.splice(ne, 1)) oe();
    };
  }, dispose() {
    for (let Y of B.splice(0)) Y();
  } };
  return z;
}
function p$2() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
let n$3 = (B, z) => {
  s$8.isServer ? useEffect(B, z) : useLayoutEffect(B, z);
};
function s$7(B) {
  let z = useRef(B);
  return n$3(() => {
    z.current = B;
  }, [B]), z;
}
let o$4 = function(B) {
  let z = s$7(B);
  return React__default.useCallback((...Y) => z.current(...Y), [z]);
};
function E$2(B) {
  let z = B.width / 2, Y = B.height / 2;
  return { top: B.clientY - Y, right: B.clientX + z, bottom: B.clientY + Y, left: B.clientX - z };
}
function P$3(B, z) {
  return !(!B || !z || B.right < z.left || B.left > z.right || B.bottom < z.top || B.top > z.bottom);
}
function w$5({ disabled: B = !1 } = {}) {
  let z = useRef(null), [Y, ne] = useState(!1), oe = p$2(), ie = o$4(() => {
    z.current = null, ne(!1), oe.dispose();
  }), ae = o$4((se) => {
    if (oe.dispose(), z.current === null) {
      z.current = se.currentTarget, ne(!0);
      {
        let ve = u$8(se.currentTarget);
        oe.addEventListener(ve, "pointerup", ie, !1), oe.addEventListener(ve, "pointermove", (ge) => {
          if (z.current) {
            let le = E$2(ge);
            ne(P$3(le, z.current.getBoundingClientRect()));
          }
        }, !1), oe.addEventListener(ve, "pointercancel", ie, !1);
      }
    }
  });
  return { pressed: Y, pressProps: B ? {} : { onPointerDown: ae, onPointerUp: ie, onClick: ie } };
}
let e$4 = createContext(void 0);
function a$b() {
  return useContext(e$4);
}
function t$3(...B) {
  return Array.from(new Set(B.flatMap((z) => typeof z == "string" ? z.split(" ") : []))).filter(Boolean).join(" ");
}
function u$7(B, z, ...Y) {
  if (B in z) {
    let oe = z[B];
    return typeof oe == "function" ? oe(...Y) : oe;
  }
  let ne = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(z).map((oe) => `"${oe}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(ne, u$7), ne;
}
var O$3 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$3 || {}), A$1 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(A$1 || {});
function L$1() {
  let B = U$3();
  return useCallback((z) => C$3({ mergeRefs: B, ...z }), [B]);
}
function C$3({ ourProps: B, theirProps: z, slot: Y, defaultTag: ne, features: oe, visible: ie = !0, name: ae, mergeRefs: se }) {
  se = se ?? $$1;
  let ve = P$2(z, B);
  if (ie) return F$2(ve, Y, ne, ae, se);
  let ge = oe ?? 0;
  if (ge & 2) {
    let { static: le = !1, ...Ee } = ve;
    if (le) return F$2(Ee, Y, ne, ae, se);
  }
  if (ge & 1) {
    let { unmount: le = !0, ...Ee } = ve;
    return u$7(le ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F$2({ ...Ee, hidden: !0, style: { display: "none" } }, Y, ne, ae, se);
    } });
  }
  return F$2(ve, Y, ne, ae, se);
}
function F$2(B, z = {}, Y, ne, oe) {
  let { as: ie = Y, children: ae, refName: se = "ref", ...ve } = h$4(B, ["unmount", "static"]), ge = B.ref !== void 0 ? { [se]: B.ref } : {}, le = typeof ae == "function" ? ae(z) : ae;
  "className" in ve && ve.className && typeof ve.className == "function" && (ve.className = ve.className(z)), ve["aria-labelledby"] && ve["aria-labelledby"] === ve.id && (ve["aria-labelledby"] = void 0);
  let Ee = {};
  if (z) {
    let Ce = !1, Pe = [];
    for (let [Xe, ht] of Object.entries(z)) typeof ht == "boolean" && (Ce = !0), ht === !0 && Pe.push(Xe.replace(/([A-Z])/g, (wt) => `-${wt.toLowerCase()}`));
    if (Ce) {
      Ee["data-headlessui-state"] = Pe.join(" ");
      for (let Xe of Pe) Ee[`data-${Xe}`] = "";
    }
  }
  if (ie === Fragment && (Object.keys(m$4(ve)).length > 0 || Object.keys(m$4(Ee)).length > 0)) if (!isValidElement(le) || Array.isArray(le) && le.length > 1) {
    if (Object.keys(m$4(ve)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${ne} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(ve)).concat(Object.keys(m$4(Ee))).map((Ce) => `  - ${Ce}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((Ce) => `  - ${Ce}`).join(`
`)].join(`
`));
  } else {
    let Ce = le.props, Pe = Ce == null ? void 0 : Ce.className, Xe = typeof Pe == "function" ? (...Pt) => t$3(Pe(...Pt), ve.className) : t$3(Pe, ve.className), ht = Xe ? { className: Xe } : {}, wt = P$2(le.props, m$4(h$4(ve, ["ref"])));
    for (let Pt in Ee) Pt in wt && delete Ee[Pt];
    return cloneElement(le, Object.assign({}, wt, Ee, ge, { ref: oe(H$3(le), ge.ref) }, ht));
  }
  return createElement(ie, Object.assign({}, h$4(ve, ["ref"]), ie !== Fragment && ge, ie !== Fragment && Ee), le);
}
function U$3() {
  let B = useRef([]), z = useCallback((Y) => {
    for (let ne of B.current) ne != null && (typeof ne == "function" ? ne(Y) : ne.current = Y);
  }, []);
  return (...Y) => {
    if (!Y.every((ne) => ne == null)) return B.current = Y, z;
  };
}
function $$1(...B) {
  return B.every((z) => z == null) ? void 0 : (z) => {
    for (let Y of B) Y != null && (typeof Y == "function" ? Y(z) : Y.current = z);
  };
}
function P$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let oe in ne) oe.startsWith("on") && typeof ne[oe] == "function" ? (Y[oe] != null || (Y[oe] = []), Y[oe].push(ne[oe])) : z[oe] = ne[oe];
  if (z.disabled || z["aria-disabled"]) for (let ne in Y) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(ne) && (Y[ne] = [(oe) => {
    var ie;
    return (ie = oe == null ? void 0 : oe.preventDefault) == null ? void 0 : ie.call(oe);
  }]);
  for (let ne in Y) Object.assign(z, { [ne](oe, ...ie) {
    let ae = Y[ne];
    for (let se of ae) {
      if ((oe instanceof Event || (oe == null ? void 0 : oe.nativeEvent) instanceof Event) && oe.defaultPrevented) return;
      se(oe, ...ie);
    }
  } });
  return z;
}
function _$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ne of B) for (let oe in ne) oe.startsWith("on") && typeof ne[oe] == "function" ? (Y[oe] != null || (Y[oe] = []), Y[oe].push(ne[oe])) : z[oe] = ne[oe];
  for (let ne in Y) Object.assign(z, { [ne](...oe) {
    let ie = Y[ne];
    for (let ae of ie) ae == null || ae(...oe);
  } });
  return z;
}
function K$1(B) {
  var z;
  return Object.assign(forwardRef(B), { displayName: (z = B.displayName) != null ? z : B.name });
}
function m$4(B) {
  let z = Object.assign({}, B);
  for (let Y in z) z[Y] === void 0 && delete z[Y];
  return z;
}
function h$4(B, z = []) {
  let Y = Object.assign({}, B);
  for (let ne of z) ne in Y && delete Y[ne];
  return Y;
}
function H$3(B) {
  return React__default.version.split(".")[0] >= "19" ? B.props.ref : B.ref;
}
let a$a = "span";
var s$6 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$6 || {});
function l$2(B, z) {
  var Y;
  let { features: ne = 1, ...oe } = B, ie = { ref: z, "aria-hidden": (ne & 2) === 2 ? !0 : (Y = oe["aria-hidden"]) != null ? Y : void 0, hidden: (ne & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ne & 4) === 4 && (ne & 2) !== 2 && { display: "none" } } };
  return L$1()({ ourProps: ie, theirProps: oe, slot: {}, defaultTag: a$a, name: "Hidden" });
}
let f$9 = K$1(l$2), e$3 = createContext(void 0);
function u$6() {
  return useContext(e$3);
}
function r$3(B) {
  let z = B.parentElement, Y = null;
  for (; z && !(z instanceof HTMLFieldSetElement); ) z instanceof HTMLLegendElement && (Y = z), z = z.parentElement;
  let ne = (z == null ? void 0 : z.getAttribute("disabled")) === "";
  return ne && i$6(Y) ? !1 : ne;
}
function i$6(B) {
  if (!B) return !1;
  let z = B.previousElementSibling;
  for (; z !== null; ) {
    if (z instanceof HTMLLegendElement) return !1;
    z = z.previousElementSibling;
  }
  return !0;
}
let u$5 = Symbol();
function T$2(B, z = !0) {
  return Object.assign(B, { [u$5]: z });
}
function y$4(...B) {
  let z = useRef(B);
  useEffect(() => {
    z.current = B;
  }, [B]);
  let Y = o$4((ne) => {
    for (let oe of z.current) oe != null && (typeof oe == "function" ? oe(ne) : oe.current = ne);
  });
  return B.every((ne) => ne == null || (ne == null ? void 0 : ne[u$5])) ? void 0 : Y;
}
let a$9 = createContext(null);
a$9.displayName = "DescriptionContext";
function f$8() {
  let B = useContext(a$9);
  if (B === null) {
    let z = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, f$8), z;
  }
  return B;
}
function w$4() {
  let [B, z] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(Y) {
    let ne = o$4((ie) => (z((ae) => [...ae, ie]), () => z((ae) => {
      let se = ae.slice(), ve = se.indexOf(ie);
      return ve !== -1 && se.splice(ve, 1), se;
    }))), oe = useMemo(() => ({ register: ne, slot: Y.slot, name: Y.name, props: Y.props, value: Y.value }), [ne, Y.slot, Y.name, Y.props, Y.value]);
    return React__default.createElement(a$9.Provider, { value: oe }, Y.children);
  }, [z])];
}
let S$2 = "p";
function C$2(B, z) {
  let Y = useId$1(), ne = a$b(), { id: oe = `headlessui-description-${Y}`, ...ie } = B, ae = f$8(), se = y$4(z);
  n$3(() => ae.register(oe), [oe, ae.register]);
  let ve = ne || !1, ge = useMemo(() => ({ ...ae.slot, disabled: ve }), [ae.slot, ve]), le = { ref: se, ...ae.props, id: oe };
  return L$1()({ ourProps: le, theirProps: ie, slot: ge, defaultTag: S$2, name: ae.name || "Description" });
}
let _$1 = K$1(C$2), H$2 = Object.assign(_$1, {});
var o$3 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$3 || {});
let c$4 = createContext(null);
c$4.displayName = "LabelContext";
function P$1() {
  let B = useContext(c$4);
  if (B === null) {
    let z = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, P$1), z;
  }
  return B;
}
function I$3(B) {
  var z, Y, ne;
  let oe = (Y = (z = useContext(c$4)) == null ? void 0 : z.value) != null ? Y : void 0;
  return ((ne = void 0) != null ? ne : 0) > 0 ? [oe, ...B].filter(Boolean).join(" ") : oe;
}
function K({ inherit: B = !1 } = {}) {
  let z = I$3(), [Y, ne] = useState([]), oe = B ? [z, ...Y].filter(Boolean) : Y;
  return [oe.length > 0 ? oe.join(" ") : void 0, useMemo(() => function(ie) {
    let ae = o$4((ve) => (ne((ge) => [...ge, ve]), () => ne((ge) => {
      let le = ge.slice(), Ee = le.indexOf(ve);
      return Ee !== -1 && le.splice(Ee, 1), le;
    }))), se = useMemo(() => ({ register: ae, slot: ie.slot, name: ie.name, props: ie.props, value: ie.value }), [ae, ie.slot, ie.name, ie.props, ie.value]);
    return React__default.createElement(c$4.Provider, { value: se }, ie.children);
  }, [ne])];
}
let N$1 = "label";
function G$1(B, z) {
  var Y;
  let ne = useId$1(), oe = P$1(), ie = u$6(), ae = a$b(), { id: se = `headlessui-label-${ne}`, htmlFor: ve = ie ?? ((Y = oe.props) == null ? void 0 : Y.htmlFor), passive: ge = !1, ...le } = B, Ee = y$4(z);
  n$3(() => oe.register(se), [se, oe.register]);
  let Ce = o$4((wt) => {
    let Pt = wt.currentTarget;
    if (Pt instanceof HTMLLabelElement && wt.preventDefault(), oe.props && "onClick" in oe.props && typeof oe.props.onClick == "function" && oe.props.onClick(wt), Pt instanceof HTMLLabelElement) {
      let vt = document.getElementById(Pt.htmlFor);
      if (vt) {
        let Bt = vt.getAttribute("disabled");
        if (Bt === "true" || Bt === "") return;
        let Ct = vt.getAttribute("aria-disabled");
        if (Ct === "true" || Ct === "") return;
        (vt instanceof HTMLInputElement && (vt.type === "radio" || vt.type === "checkbox") || vt.role === "radio" || vt.role === "checkbox" || vt.role === "switch") && vt.click(), vt.focus({ preventScroll: !0 });
      }
    }
  }), Pe = ae || !1, Xe = useMemo(() => ({ ...oe.slot, disabled: Pe }), [oe.slot, Pe]), ht = { ref: Ee, ...oe.props, id: se, htmlFor: ve, onClick: Ce };
  return ge && ("onClick" in ht && (delete ht.htmlFor, delete ht.onClick), "onClick" in le && delete le.onClick), L$1()({ ourProps: ht, theirProps: le, slot: Xe, defaultTag: ve ? N$1 : "div", name: oe.name || "Label" });
}
let U$2 = K$1(G$1);
Object.assign(U$2, {});
let e$2 = createContext(() => {
});
function C$1({ value: B, children: z }) {
  return React__default.createElement(e$2.Provider, { value: B }, z);
}
function f$7(B) {
  if (B === null) return { width: 0, height: 0 };
  let { width: z, height: Y } = B.getBoundingClientRect();
  return { width: z, height: Y };
}
function d$2(B, z = !1) {
  let [Y, ne] = useReducer(() => ({}), {}), oe = useMemo(() => f$7(B), [B, Y]);
  return n$3(() => {
    if (!B) return;
    let ie = new ResizeObserver(ne);
    return ie.observe(B), () => {
      ie.disconnect();
    };
  }, [B]), z ? { width: `${oe.width}px`, height: `${oe.height}px` } : oe;
}
let a$8 = class extends Map {
  constructor(z) {
    super(), this.factory = z;
  }
  get(z) {
    let Y = super.get(z);
    return Y === void 0 && (Y = this.factory(z), this.set(z, Y)), Y;
  }
};
function a$7(B, z) {
  let Y = B(), ne = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return Y;
  }, subscribe(oe) {
    return ne.add(oe), () => ne.delete(oe);
  }, dispatch(oe, ...ie) {
    let ae = z[oe].call(Y, ...ie);
    ae && (Y = ae, ne.forEach((se) => se()));
  } };
}
function o$2(B) {
  return useSyncExternalStore(B.subscribe, B.getSnapshot, B.getSnapshot);
}
let p$1 = new a$8(() => a$7(() => [], { ADD(B) {
  return this.includes(B) ? this : [...this, B];
}, REMOVE(B) {
  let z = this.indexOf(B);
  if (z === -1) return this;
  let Y = this.slice();
  return Y.splice(z, 1), Y;
} }));
function x$3(B, z) {
  let Y = p$1.get(z), ne = useId$1(), oe = o$2(Y);
  if (n$3(() => {
    if (B) return Y.dispatch("ADD", ne), () => Y.dispatch("REMOVE", ne);
  }, [Y, B]), !B) return !1;
  let ie = oe.indexOf(ne), ae = oe.length;
  return ie === -1 && (ie = ae, ae += 1), ie === ae - 1;
}
let f$6 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();
function h$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 0;
  return u$4.set(B, Y + 1), Y !== 0 ? () => m$3(B) : (f$6.set(B, { "aria-hidden": B.getAttribute("aria-hidden"), inert: B.inert }), B.setAttribute("aria-hidden", "true"), B.inert = !0, () => m$3(B));
}
function m$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 1;
  if (Y === 1 ? u$4.delete(B) : u$4.set(B, Y - 1), Y !== 1) return;
  let ne = f$6.get(B);
  ne && (ne["aria-hidden"] === null ? B.removeAttribute("aria-hidden") : B.setAttribute("aria-hidden", ne["aria-hidden"]), B.inert = ne.inert, f$6.delete(B));
}
function y$3(B, { allowed: z, disallowed: Y } = {}) {
  let ne = x$3(B, "inert-others");
  n$3(() => {
    var oe, ie;
    if (!ne) return;
    let ae = o$5();
    for (let ve of (oe = Y == null ? void 0 : Y()) != null ? oe : []) ve && ae.add(h$3(ve));
    let se = (ie = z == null ? void 0 : z()) != null ? ie : [];
    for (let ve of se) {
      if (!ve) continue;
      let ge = u$8(ve);
      if (!ge) continue;
      let le = ve.parentElement;
      for (; le && le !== ge.body; ) {
        for (let Ee of le.children) se.some((Ce) => Ee.contains(Ce)) || ae.add(h$3(Ee));
        le = le.parentElement;
      }
    }
    return ae.dispose;
  }, [ne, z, Y]);
}
function m$2(B, z, Y) {
  let ne = s$7((oe) => {
    let ie = oe.getBoundingClientRect();
    ie.x === 0 && ie.y === 0 && ie.width === 0 && ie.height === 0 && Y();
  });
  useEffect(() => {
    if (!B) return;
    let oe = z === null ? null : z instanceof HTMLElement ? z : z.current;
    if (!oe) return;
    let ie = o$5();
    if (typeof ResizeObserver < "u") {
      let ae = new ResizeObserver(() => ne.current(oe));
      ae.observe(oe), ie.add(() => ae.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let ae = new IntersectionObserver(() => ne.current(oe));
      ae.observe(oe), ie.add(() => ae.disconnect());
    }
    return () => ie.dispose();
  }, [z, ne, B]);
}
let f$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var F$1 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B[B.AutoFocus = 64] = "AutoFocus", B))(F$1 || {}), T$1 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(T$1 || {}), y$2 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(y$2 || {});
function b$2(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(f$5)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$1(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(p)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(h$2 || {});
function A(B, z = 0) {
  var Y;
  return B === ((Y = u$8(B)) == null ? void 0 : Y.body) ? !1 : u$7(z, { 0() {
    return B.matches(f$5);
  }, 1() {
    let ne = B;
    for (; ne !== null; ) {
      if (ne.matches(f$5)) return !0;
      ne = ne.parentElement;
    }
    return !1;
  } });
}
function G(B) {
  let z = u$8(B);
  o$5().nextFrame(() => {
    z && !A(z.activeElement, 0) && I$2(B);
  });
}
var H$1 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(H$1 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I$2(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let w$3 = ["textarea", "input"].join(",");
function O$2(B) {
  var z, Y;
  return (Y = (z = B == null ? void 0 : B.matches) == null ? void 0 : z.call(B, w$3)) != null ? Y : !1;
}
function _(B, z = (Y) => Y) {
  return B.slice().sort((Y, ne) => {
    let oe = z(Y), ie = z(ne);
    if (oe === null || ie === null) return 0;
    let ae = oe.compareDocumentPosition(ie);
    return ae & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : ae & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$3(B, z) {
  return P(b$2(), z, { relativeTo: B });
}
function P(B, z, { sorted: Y = !0, relativeTo: ne = null, skipElements: oe = [] } = {}) {
  let ie = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, ae = Array.isArray(B) ? Y ? _(B) : B : z & 64 ? S$1(B) : b$2(B);
  oe.length > 0 && ae.length > 1 && (ae = ae.filter((Pe) => !oe.some((Xe) => Xe != null && "current" in Xe ? (Xe == null ? void 0 : Xe.current) === Pe : Xe === Pe))), ne = ne ?? ie.activeElement;
  let se = (() => {
    if (z & 5) return 1;
    if (z & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ve = (() => {
    if (z & 1) return 0;
    if (z & 2) return Math.max(0, ae.indexOf(ne)) - 1;
    if (z & 4) return Math.max(0, ae.indexOf(ne)) + 1;
    if (z & 8) return ae.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ge = z & 32 ? { preventScroll: !0 } : {}, le = 0, Ee = ae.length, Ce;
  do {
    if (le >= Ee || le + Ee <= 0) return 0;
    let Pe = ve + le;
    if (z & 16) Pe = (Pe + Ee) % Ee;
    else {
      if (Pe < 0) return 3;
      if (Pe >= Ee) return 1;
    }
    Ce = ae[Pe], Ce == null || Ce.focus(ge), le += se;
  } while (Ce !== ie.activeElement);
  return z & 6 && O$2(Ce) && Ce.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$5() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$5();
}
function i$4(B, z, Y, ne) {
  let oe = s$7(Y);
  useEffect(() => {
    if (!B) return;
    function ie(ae) {
      oe.current(ae);
    }
    return document.addEventListener(z, ie, ne), () => document.removeEventListener(z, ie, ne);
  }, [B, z, ne]);
}
function s$5(B, z, Y, ne) {
  let oe = s$7(Y);
  useEffect(() => {
    if (!B) return;
    function ie(ae) {
      oe.current(ae);
    }
    return window.addEventListener(z, ie, ne), () => window.removeEventListener(z, ie, ne);
  }, [B, z, ne]);
}
const E$1 = 30;
function R$2(B, z, Y) {
  let ne = x$3(B, "outside-click"), oe = s$7(Y), ie = useCallback(function(ve, ge) {
    if (ve.defaultPrevented) return;
    let le = ge(ve);
    if (le === null || !le.getRootNode().contains(le) || !le.isConnected) return;
    let Ee = function Ce(Pe) {
      return typeof Pe == "function" ? Ce(Pe()) : Array.isArray(Pe) || Pe instanceof Set ? Pe : [Pe];
    }(z);
    for (let Ce of Ee) if (Ce !== null && (Ce.contains(le) || ve.composed && ve.composedPath().includes(Ce))) return;
    return !A(le, h$2.Loose) && le.tabIndex !== -1 && ve.preventDefault(), oe.current(ve, le);
  }, [oe, z]), ae = useRef(null);
  i$4(ne, "pointerdown", (ve) => {
    var ge, le;
    ae.current = ((le = (ge = ve.composedPath) == null ? void 0 : ge.call(ve)) == null ? void 0 : le[0]) || ve.target;
  }, !0), i$4(ne, "mousedown", (ve) => {
    var ge, le;
    ae.current = ((le = (ge = ve.composedPath) == null ? void 0 : ge.call(ve)) == null ? void 0 : le[0]) || ve.target;
  }, !0), i$4(ne, "click", (ve) => {
    n$2() || ae.current && (ie(ve, () => ae.current), ae.current = null);
  }, !0);
  let se = useRef({ x: 0, y: 0 });
  i$4(ne, "touchstart", (ve) => {
    se.current.x = ve.touches[0].clientX, se.current.y = ve.touches[0].clientY;
  }, !0), i$4(ne, "touchend", (ve) => {
    let ge = { x: ve.changedTouches[0].clientX, y: ve.changedTouches[0].clientY };
    if (!(Math.abs(ge.x - se.current.x) >= E$1 || Math.abs(ge.y - se.current.y) >= E$1)) return ie(ve, () => ve.target instanceof HTMLElement ? ve.target : null);
  }, !0), s$5(ne, "blur", (ve) => ie(ve, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$1(...B) {
  return useMemo(() => u$8(...B), [...B]);
}
function E(B, z, Y, ne) {
  let oe = s$7(Y);
  useEffect(() => {
    B = B ?? window;
    function ie(ae) {
      oe.current(ae);
    }
    return B.addEventListener(z, ie, ne), () => B.removeEventListener(z, ie, ne);
  }, [B, z, ne]);
}
function e$1(B, z) {
  return useMemo(() => {
    var Y;
    if (B.type) return B.type;
    let ne = (Y = B.as) != null ? Y : "button";
    if (typeof ne == "string" && ne.toLowerCase() === "button" || (z == null ? void 0 : z.tagName) === "BUTTON" && !z.hasAttribute("type")) return "button";
  }, [B.type, B.as, z]);
}
function d$1() {
  let B;
  return { before({ doc: z }) {
    var Y;
    let ne = z.documentElement, oe = (Y = z.defaultView) != null ? Y : window;
    B = Math.max(0, oe.innerWidth - ne.clientWidth);
  }, after({ doc: z, d: Y }) {
    let ne = z.documentElement, oe = Math.max(0, ne.clientWidth - ne.offsetWidth), ie = Math.max(0, B - oe);
    Y.style(ne, "paddingRight", `${ie}px`);
  } };
}
function d() {
  return t$2() ? { before({ doc: B, d: z, meta: Y }) {
    function ne(oe) {
      return Y.containers.flatMap((ie) => ie()).some((ie) => ie.contains(oe));
    }
    z.microTask(() => {
      var oe;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let se = o$5();
        se.style(B.documentElement, "scrollBehavior", "auto"), z.add(() => z.microTask(() => se.dispose()));
      }
      let ie = (oe = window.scrollY) != null ? oe : window.pageYOffset, ae = null;
      z.addEventListener(B, "click", (se) => {
        if (se.target instanceof HTMLElement) try {
          let ve = se.target.closest("a");
          if (!ve) return;
          let { hash: ge } = new URL(ve.href), le = B.querySelector(ge);
          le && !ne(le) && (ae = le);
        } catch {
        }
      }, !0), z.addEventListener(B, "touchstart", (se) => {
        if (se.target instanceof HTMLElement) if (ne(se.target)) {
          let ve = se.target;
          for (; ve.parentElement && ne(ve.parentElement); ) ve = ve.parentElement;
          z.style(ve, "overscrollBehavior", "contain");
        } else z.style(se.target, "touchAction", "none");
      }), z.addEventListener(B, "touchmove", (se) => {
        if (se.target instanceof HTMLElement) {
          if (se.target.tagName === "INPUT") return;
          if (ne(se.target)) {
            let ve = se.target;
            for (; ve.parentElement && ve.dataset.headlessuiPortal !== "" && !(ve.scrollHeight > ve.clientHeight || ve.scrollWidth > ve.clientWidth); ) ve = ve.parentElement;
            ve.dataset.headlessuiPortal === "" && se.preventDefault();
          } else se.preventDefault();
        }
      }, { passive: !1 }), z.add(() => {
        var se;
        let ve = (se = window.scrollY) != null ? se : window.pageYOffset;
        ie !== ve && window.scrollTo(0, ie), ae && ae.isConnected && (ae.scrollIntoView({ block: "nearest" }), ae = null);
      });
    });
  } } : {};
}
function r$2() {
  return { before({ doc: B, d: z }) {
    z.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let z = {};
  for (let Y of B) Object.assign(z, Y(z));
  return z;
}
let a$6 = a$7(() => /* @__PURE__ */ new Map(), { PUSH(B, z) {
  var Y;
  let ne = (Y = this.get(B)) != null ? Y : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return ne.count++, ne.meta.add(z), this.set(B, ne), this;
}, POP(B, z) {
  let Y = this.get(B);
  return Y && (Y.count--, Y.meta.delete(z)), this;
}, SCROLL_PREVENT({ doc: B, d: z, meta: Y }) {
  let ne = { doc: B, d: z, meta: m$1(Y) }, oe = [d(), d$1(), r$2()];
  oe.forEach(({ before: ie }) => ie == null ? void 0 : ie(ne)), oe.forEach(({ after: ie }) => ie == null ? void 0 : ie(ne));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$6.subscribe(() => {
  let B = a$6.getSnapshot(), z = /* @__PURE__ */ new Map();
  for (let [Y] of B) z.set(Y, Y.documentElement.style.overflow);
  for (let Y of B.values()) {
    let ne = z.get(Y.doc) === "hidden", oe = Y.count !== 0;
    (oe && !ne || !oe && ne) && a$6.dispatch(Y.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", Y), Y.count === 0 && a$6.dispatch("TEARDOWN", Y);
  }
});
function a$5(B, z, Y = () => ({ containers: [] })) {
  let ne = o$2(a$6), oe = z ? ne.get(z) : void 0, ie = oe ? oe.count > 0 : !1;
  return n$3(() => {
    if (!(!z || !B)) return a$6.dispatch("PUSH", z, Y), () => a$6.dispatch("POP", z, Y);
  }, [B, z]), ie;
}
function f$4(B, z, Y = () => [document.body]) {
  let ne = x$3(B, "scroll-lock");
  a$5(ne, z, (oe) => {
    var ie;
    return { containers: [...(ie = oe.containers) != null ? ie : [], Y] };
  });
}
function t$1(B) {
  return [B.screenX, B.screenY];
}
function u$3() {
  let B = useRef([-1, -1]);
  return { wasMoved(z) {
    let Y = t$1(z);
    return B.current[0] === Y[0] && B.current[1] === Y[1] ? !1 : (B.current = Y, !0);
  }, update(z) {
    B.current = t$1(z);
  } };
}
function c$3(B = 0) {
  let [z, Y] = useState(B), ne = useCallback((ve) => Y(ve), [z]), oe = useCallback((ve) => Y((ge) => ge | ve), [z]), ie = useCallback((ve) => (z & ve) === ve, [z]), ae = useCallback((ve) => Y((ge) => ge & ~ve), [Y]), se = useCallback((ve) => Y((ge) => ge ^ ve), [Y]);
  return { flags: z, setFlag: ne, addFlag: oe, hasFlag: ie, removeFlag: ae, toggleFlag: se };
}
var T, b$1;
typeof process$1 < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T = process$1 == null ? void 0 : process$1.env) == null ? void 0 : T.NODE_ENV) === "test" && typeof ((b$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$1.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L = ((B) => (B[B.None = 0] = "None", B[B.Closed = 1] = "Closed", B[B.Enter = 2] = "Enter", B[B.Leave = 4] = "Leave", B))(L || {});
function R$1(B) {
  let z = {};
  for (let Y in B) B[Y] === !0 && (z[`data-${Y}`] = "");
  return z;
}
function x$2(B, z, Y, ne) {
  let [oe, ie] = useState(Y), { hasFlag: ae, addFlag: se, removeFlag: ve } = c$3(B && oe ? 3 : 0), ge = useRef(!1), le = useRef(!1), Ee = p$2();
  return n$3(() => {
    var Ce;
    if (B) {
      if (Y && ie(!0), !z) {
        Y && se(3);
        return;
      }
      return (Ce = ne == null ? void 0 : ne.start) == null || Ce.call(ne, Y), C(z, { inFlight: ge, prepare() {
        le.current ? le.current = !1 : le.current = ge.current, ge.current = !0, !le.current && (Y ? (se(3), ve(4)) : (se(4), ve(2)));
      }, run() {
        le.current ? Y ? (ve(3), se(4)) : (ve(4), se(3)) : Y ? ve(1) : se(1);
      }, done() {
        var Pe;
        le.current && typeof z.getAnimations == "function" && z.getAnimations().length > 0 || (ge.current = !1, ve(7), Y || ie(!1), (Pe = ne == null ? void 0 : ne.end) == null || Pe.call(ne, Y));
      } });
    }
  }, [B, Y, z, Ee]), B ? [oe, { closed: ae(1), enter: ae(2), leave: ae(4), transition: ae(2) || ae(4) }] : [Y, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(B, { prepare: z, run: Y, done: ne, inFlight: oe }) {
  let ie = o$5();
  return j$2(B, { prepare: z, inFlight: oe }), ie.nextFrame(() => {
    Y(), ie.requestAnimationFrame(() => {
      ie.add(M$2(B, ne));
    });
  }), ie.dispose;
}
function M$2(B, z) {
  var Y, ne;
  let oe = o$5();
  if (!B) return oe.dispose;
  let ie = !1;
  oe.add(() => {
    ie = !0;
  });
  let ae = (ne = (Y = B.getAnimations) == null ? void 0 : Y.call(B).filter((se) => se instanceof CSSTransition)) != null ? ne : [];
  return ae.length === 0 ? (z(), oe.dispose) : (Promise.allSettled(ae.map((se) => se.finished)).then(() => {
    ie || z();
  }), oe.dispose);
}
function j$2(B, { inFlight: z, prepare: Y }) {
  if (z != null && z.current) {
    Y();
    return;
  }
  let ne = B.style.transition;
  B.style.transition = "none", Y(), B.offsetHeight, B.style.transition = ne;
}
function F(B, { container: z, accept: Y, walk: ne }) {
  let oe = useRef(Y), ie = useRef(ne);
  useEffect(() => {
    oe.current = Y, ie.current = ne;
  }, [Y, ne]), n$3(() => {
    if (!z || !B) return;
    let ae = u$8(z);
    if (!ae) return;
    let se = oe.current, ve = ie.current, ge = Object.assign((Ee) => se(Ee), { acceptNode: se }), le = ae.createTreeWalker(z, NodeFilter.SHOW_ELEMENT, ge, !1);
    for (; le.nextNode(); ) ve(le.currentNode);
  }, [z, B, oe, ie]);
}
function m(B, z) {
  let Y = useRef([]), ne = o$4(B);
  useEffect(() => {
    let oe = [...Y.current];
    for (let [ie, ae] of z.entries()) if (Y.current[ie] !== ae) {
      let se = ne(z, oe);
      return Y.current = z, se;
    }
  }, [ne, ...z]);
}
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(B) {
  return isNode(B) ? (B.nodeName || "").toLowerCase() : "#document";
}
function getWindow(B) {
  var z;
  return (B == null || (z = B.ownerDocument) == null ? void 0 : z.defaultView) || window;
}
function getDocumentElement(B) {
  var z;
  return (z = (isNode(B) ? B.ownerDocument : B.document) || window.document) == null ? void 0 : z.documentElement;
}
function isNode(B) {
  return hasWindow() ? B instanceof Node || B instanceof getWindow(B).Node : !1;
}
function isElement(B) {
  return hasWindow() ? B instanceof Element || B instanceof getWindow(B).Element : !1;
}
function isHTMLElement(B) {
  return hasWindow() ? B instanceof HTMLElement || B instanceof getWindow(B).HTMLElement : !1;
}
function isShadowRoot(B) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : B instanceof ShadowRoot || B instanceof getWindow(B).ShadowRoot;
}
function isOverflowElement(B) {
  const {
    overflow: z,
    overflowX: Y,
    overflowY: ne,
    display: oe
  } = getComputedStyle$1(B);
  return /auto|scroll|overlay|hidden|clip/.test(z + ne + Y) && !["inline", "contents"].includes(oe);
}
function isTableElement(B) {
  return ["table", "td", "th"].includes(getNodeName(B));
}
function isTopLayer(B) {
  return [":popover-open", ":modal"].some((z) => {
    try {
      return B.matches(z);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(B) {
  const z = isWebKit(), Y = isElement(B) ? getComputedStyle$1(B) : B;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((ne) => Y[ne] ? Y[ne] !== "none" : !1) || (Y.containerType ? Y.containerType !== "normal" : !1) || !z && (Y.backdropFilter ? Y.backdropFilter !== "none" : !1) || !z && (Y.filter ? Y.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((ne) => (Y.willChange || "").includes(ne)) || ["paint", "layout", "strict", "content"].some((ne) => (Y.contain || "").includes(ne));
}
function getContainingBlock(B) {
  let z = getParentNode(B);
  for (; isHTMLElement(z) && !isLastTraversableNode(z); ) {
    if (isContainingBlock(z))
      return z;
    if (isTopLayer(z))
      return null;
    z = getParentNode(z);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(B) {
  return ["html", "body", "#document"].includes(getNodeName(B));
}
function getComputedStyle$1(B) {
  return getWindow(B).getComputedStyle(B);
}
function getNodeScroll(B) {
  return isElement(B) ? {
    scrollLeft: B.scrollLeft,
    scrollTop: B.scrollTop
  } : {
    scrollLeft: B.scrollX,
    scrollTop: B.scrollY
  };
}
function getParentNode(B) {
  if (getNodeName(B) === "html")
    return B;
  const z = (
    // Step into the shadow DOM of the parent of a slotted node.
    B.assignedSlot || // DOM Element detected.
    B.parentNode || // ShadowRoot detected.
    isShadowRoot(B) && B.host || // Fallback.
    getDocumentElement(B)
  );
  return isShadowRoot(z) ? z.host : z;
}
function getNearestOverflowAncestor(B) {
  const z = getParentNode(B);
  return isLastTraversableNode(z) ? B.ownerDocument ? B.ownerDocument.body : B.body : isHTMLElement(z) && isOverflowElement(z) ? z : getNearestOverflowAncestor(z);
}
function getOverflowAncestors(B, z, Y) {
  var ne;
  z === void 0 && (z = []), Y === void 0 && (Y = !0);
  const oe = getNearestOverflowAncestor(B), ie = oe === ((ne = B.ownerDocument) == null ? void 0 : ne.body), ae = getWindow(oe);
  if (ie) {
    const se = getFrameElement(ae);
    return z.concat(ae, ae.visualViewport || [], isOverflowElement(oe) ? oe : [], se && Y ? getOverflowAncestors(se) : []);
  }
  return z.concat(oe, getOverflowAncestors(oe, [], Y));
}
function getFrameElement(B) {
  return B.parent && Object.getPrototypeOf(B.parent) ? B.frameElement : null;
}
function getUserAgent() {
  const B = navigator.userAgentData;
  return B && Array.isArray(B.brands) ? B.brands.map((z) => {
    let {
      brand: Y,
      version: ne
    } = z;
    return Y + "/" + ne;
  }).join(" ") : navigator.userAgent;
}
const min$1 = Math.min, max$1 = Math.max, round$1 = Math.round, floor$1 = Math.floor, createCoords = (B) => ({
  x: B,
  y: B
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(B, z, Y) {
  return max$1(B, min$1(z, Y));
}
function evaluate(B, z) {
  return typeof B == "function" ? B(z) : B;
}
function getSide(B) {
  return B.split("-")[0];
}
function getAlignment(B) {
  return B.split("-")[1];
}
function getOppositeAxis(B) {
  return B === "x" ? "y" : "x";
}
function getAxisLength(B) {
  return B === "y" ? "height" : "width";
}
function getSideAxis(B) {
  return ["top", "bottom"].includes(getSide(B)) ? "y" : "x";
}
function getAlignmentAxis(B) {
  return getOppositeAxis(getSideAxis(B));
}
function getAlignmentSides(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = getAlignment(B), oe = getAlignmentAxis(B), ie = getAxisLength(oe);
  let ae = oe === "x" ? ne === (Y ? "end" : "start") ? "right" : "left" : ne === "start" ? "bottom" : "top";
  return z.reference[ie] > z.floating[ie] && (ae = getOppositePlacement(ae)), [ae, getOppositePlacement(ae)];
}
function getExpandedPlacements(B) {
  const z = getOppositePlacement(B);
  return [getOppositeAlignmentPlacement(B), z, getOppositeAlignmentPlacement(z)];
}
function getOppositeAlignmentPlacement(B) {
  return B.replace(/start|end/g, (z) => oppositeAlignmentMap[z]);
}
function getSideList(B, z, Y) {
  const ne = ["left", "right"], oe = ["right", "left"], ie = ["top", "bottom"], ae = ["bottom", "top"];
  switch (B) {
    case "top":
    case "bottom":
      return Y ? z ? oe : ne : z ? ne : oe;
    case "left":
    case "right":
      return z ? ie : ae;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(B, z, Y, ne) {
  const oe = getAlignment(B);
  let ie = getSideList(getSide(B), Y === "start", ne);
  return oe && (ie = ie.map((ae) => ae + "-" + oe), z && (ie = ie.concat(ie.map(getOppositeAlignmentPlacement)))), ie;
}
function getOppositePlacement(B) {
  return B.replace(/left|right|bottom|top/g, (z) => oppositeSideMap[z]);
}
function expandPaddingObject(B) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...B
  };
}
function getPaddingObject(B) {
  return typeof B != "number" ? expandPaddingObject(B) : {
    top: B,
    right: B,
    bottom: B,
    left: B
  };
}
function rectToClientRect(B) {
  const {
    x: z,
    y: Y,
    width: ne,
    height: oe
  } = B;
  return {
    width: ne,
    height: oe,
    top: Y,
    left: z,
    right: z + ne,
    bottom: Y + oe,
    x: z,
    y: Y
  };
}
function computeCoordsFromPlacement(B, z, Y) {
  let {
    reference: ne,
    floating: oe
  } = B;
  const ie = getSideAxis(z), ae = getAlignmentAxis(z), se = getAxisLength(ae), ve = getSide(z), ge = ie === "y", le = ne.x + ne.width / 2 - oe.width / 2, Ee = ne.y + ne.height / 2 - oe.height / 2, Ce = ne[se] / 2 - oe[se] / 2;
  let Pe;
  switch (ve) {
    case "top":
      Pe = {
        x: le,
        y: ne.y - oe.height
      };
      break;
    case "bottom":
      Pe = {
        x: le,
        y: ne.y + ne.height
      };
      break;
    case "right":
      Pe = {
        x: ne.x + ne.width,
        y: Ee
      };
      break;
    case "left":
      Pe = {
        x: ne.x - oe.width,
        y: Ee
      };
      break;
    default:
      Pe = {
        x: ne.x,
        y: ne.y
      };
  }
  switch (getAlignment(z)) {
    case "start":
      Pe[ae] -= Ce * (Y && ge ? -1 : 1);
      break;
    case "end":
      Pe[ae] += Ce * (Y && ge ? -1 : 1);
      break;
  }
  return Pe;
}
const computePosition$1 = async (B, z, Y) => {
  const {
    placement: ne = "bottom",
    strategy: oe = "absolute",
    middleware: ie = [],
    platform: ae
  } = Y, se = ie.filter(Boolean), ve = await (ae.isRTL == null ? void 0 : ae.isRTL(z));
  let ge = await ae.getElementRects({
    reference: B,
    floating: z,
    strategy: oe
  }), {
    x: le,
    y: Ee
  } = computeCoordsFromPlacement(ge, ne, ve), Ce = ne, Pe = {}, Xe = 0;
  for (let ht = 0; ht < se.length; ht++) {
    const {
      name: wt,
      fn: Pt
    } = se[ht], {
      x: vt,
      y: Bt,
      data: Ct,
      reset: Wt
    } = await Pt({
      x: le,
      y: Ee,
      initialPlacement: ne,
      placement: Ce,
      strategy: oe,
      middlewareData: Pe,
      rects: ge,
      platform: ae,
      elements: {
        reference: B,
        floating: z
      }
    });
    le = vt ?? le, Ee = Bt ?? Ee, Pe = {
      ...Pe,
      [wt]: {
        ...Pe[wt],
        ...Ct
      }
    }, Wt && Xe <= 50 && (Xe++, typeof Wt == "object" && (Wt.placement && (Ce = Wt.placement), Wt.rects && (ge = Wt.rects === !0 ? await ae.getElementRects({
      reference: B,
      floating: z,
      strategy: oe
    }) : Wt.rects), {
      x: le,
      y: Ee
    } = computeCoordsFromPlacement(ge, Ce, ve)), ht = -1);
  }
  return {
    x: le,
    y: Ee,
    placement: Ce,
    strategy: oe,
    middlewareData: Pe
  };
};
async function detectOverflow$1(B, z) {
  var Y;
  z === void 0 && (z = {});
  const {
    x: ne,
    y: oe,
    platform: ie,
    rects: ae,
    elements: se,
    strategy: ve
  } = B, {
    boundary: ge = "clippingAncestors",
    rootBoundary: le = "viewport",
    elementContext: Ee = "floating",
    altBoundary: Ce = !1,
    padding: Pe = 0
  } = evaluate(z, B), Xe = getPaddingObject(Pe), wt = se[Ce ? Ee === "floating" ? "reference" : "floating" : Ee], Pt = rectToClientRect(await ie.getClippingRect({
    element: (Y = await (ie.isElement == null ? void 0 : ie.isElement(wt))) == null || Y ? wt : wt.contextElement || await (ie.getDocumentElement == null ? void 0 : ie.getDocumentElement(se.floating)),
    boundary: ge,
    rootBoundary: le,
    strategy: ve
  })), vt = Ee === "floating" ? {
    x: ne,
    y: oe,
    width: ae.floating.width,
    height: ae.floating.height
  } : ae.reference, Bt = await (ie.getOffsetParent == null ? void 0 : ie.getOffsetParent(se.floating)), Ct = await (ie.isElement == null ? void 0 : ie.isElement(Bt)) ? await (ie.getScale == null ? void 0 : ie.getScale(Bt)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, Wt = rectToClientRect(ie.convertOffsetParentRelativeRectToViewportRelativeRect ? await ie.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: se,
    rect: vt,
    offsetParent: Bt,
    strategy: ve
  }) : vt);
  return {
    top: (Pt.top - Wt.top + Xe.top) / Ct.y,
    bottom: (Wt.bottom - Pt.bottom + Xe.bottom) / Ct.y,
    left: (Pt.left - Wt.left + Xe.left) / Ct.x,
    right: (Wt.right - Pt.right + Xe.right) / Ct.x
  };
}
const flip$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "flip",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: oe,
        middlewareData: ie,
        rects: ae,
        initialPlacement: se,
        platform: ve,
        elements: ge
      } = z, {
        mainAxis: le = !0,
        crossAxis: Ee = !0,
        fallbackPlacements: Ce,
        fallbackStrategy: Pe = "bestFit",
        fallbackAxisSideDirection: Xe = "none",
        flipAlignment: ht = !0,
        ...wt
      } = evaluate(B, z);
      if ((Y = ie.arrow) != null && Y.alignmentOffset)
        return {};
      const Pt = getSide(oe), vt = getSideAxis(se), Bt = getSide(se) === se, Ct = await (ve.isRTL == null ? void 0 : ve.isRTL(ge.floating)), Wt = Ce || (Bt || !ht ? [getOppositePlacement(se)] : getExpandedPlacements(se)), Kt = Xe !== "none";
      !Ce && Kt && Wt.push(...getOppositeAxisPlacements(se, ht, Xe, Ct));
      const Yt = [se, ...Wt], Ut = await detectOverflow$1(z, wt), qt = [];
      let zt = ((ne = ie.flip) == null ? void 0 : ne.overflows) || [];
      if (le && qt.push(Ut[Pt]), Ee) {
        const Ke = getAlignmentSides(oe, ae, Ct);
        qt.push(Ut[Ke[0]], Ut[Ke[1]]);
      }
      if (zt = [...zt, {
        placement: oe,
        overflows: qt
      }], !qt.every((Ke) => Ke <= 0)) {
        var Ft, Ve;
        const Ke = (((Ft = ie.flip) == null ? void 0 : Ft.index) || 0) + 1, Qe = Yt[Ke];
        if (Qe)
          return {
            data: {
              index: Ke,
              overflows: zt
            },
            reset: {
              placement: Qe
            }
          };
        let bt = (Ve = zt.filter((_t) => _t.overflows[0] <= 0).sort((_t, $t) => _t.overflows[1] - $t.overflows[1])[0]) == null ? void 0 : Ve.placement;
        if (!bt)
          switch (Pe) {
            case "bestFit": {
              var Je;
              const _t = (Je = zt.filter(($t) => {
                if (Kt) {
                  const kt = getSideAxis($t.placement);
                  return kt === vt || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  kt === "y";
                }
                return !0;
              }).map(($t) => [$t.placement, $t.overflows.filter((kt) => kt > 0).reduce((kt, xt) => kt + xt, 0)]).sort(($t, kt) => $t[1] - kt[1])[0]) == null ? void 0 : Je[0];
              _t && (bt = _t);
              break;
            }
            case "initialPlacement":
              bt = se;
              break;
          }
        if (oe !== bt)
          return {
            reset: {
              placement: bt
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(B, z) {
  const {
    placement: Y,
    platform: ne,
    elements: oe
  } = B, ie = await (ne.isRTL == null ? void 0 : ne.isRTL(oe.floating)), ae = getSide(Y), se = getAlignment(Y), ve = getSideAxis(Y) === "y", ge = ["left", "top"].includes(ae) ? -1 : 1, le = ie && ve ? -1 : 1, Ee = evaluate(z, B);
  let {
    mainAxis: Ce,
    crossAxis: Pe,
    alignmentAxis: Xe
  } = typeof Ee == "number" ? {
    mainAxis: Ee,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: Ee.mainAxis || 0,
    crossAxis: Ee.crossAxis || 0,
    alignmentAxis: Ee.alignmentAxis
  };
  return se && typeof Xe == "number" && (Pe = se === "end" ? Xe * -1 : Xe), ve ? {
    x: Pe * le,
    y: Ce * ge
  } : {
    x: Ce * ge,
    y: Pe * le
  };
}
const offset$2 = function(B) {
  return B === void 0 && (B = 0), {
    name: "offset",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        x: oe,
        y: ie,
        placement: ae,
        middlewareData: se
      } = z, ve = await convertValueToCoords(z, B);
      return ae === ((Y = se.offset) == null ? void 0 : Y.placement) && (ne = se.arrow) != null && ne.alignmentOffset ? {} : {
        x: oe + ve.x,
        y: ie + ve.y,
        data: {
          ...ve,
          placement: ae
        }
      };
    }
  };
}, shift$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "shift",
    options: B,
    async fn(z) {
      const {
        x: Y,
        y: ne,
        placement: oe
      } = z, {
        mainAxis: ie = !0,
        crossAxis: ae = !1,
        limiter: se = {
          fn: (wt) => {
            let {
              x: Pt,
              y: vt
            } = wt;
            return {
              x: Pt,
              y: vt
            };
          }
        },
        ...ve
      } = evaluate(B, z), ge = {
        x: Y,
        y: ne
      }, le = await detectOverflow$1(z, ve), Ee = getSideAxis(getSide(oe)), Ce = getOppositeAxis(Ee);
      let Pe = ge[Ce], Xe = ge[Ee];
      if (ie) {
        const wt = Ce === "y" ? "top" : "left", Pt = Ce === "y" ? "bottom" : "right", vt = Pe + le[wt], Bt = Pe - le[Pt];
        Pe = clamp(vt, Pe, Bt);
      }
      if (ae) {
        const wt = Ee === "y" ? "top" : "left", Pt = Ee === "y" ? "bottom" : "right", vt = Xe + le[wt], Bt = Xe - le[Pt];
        Xe = clamp(vt, Xe, Bt);
      }
      const ht = se.fn({
        ...z,
        [Ce]: Pe,
        [Ee]: Xe
      });
      return {
        ...ht,
        data: {
          x: ht.x - Y,
          y: ht.y - ne,
          enabled: {
            [Ce]: ie,
            [Ee]: ae
          }
        }
      };
    }
  };
}, size$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "size",
    options: B,
    async fn(z) {
      var Y, ne;
      const {
        placement: oe,
        rects: ie,
        platform: ae,
        elements: se
      } = z, {
        apply: ve = () => {
        },
        ...ge
      } = evaluate(B, z), le = await detectOverflow$1(z, ge), Ee = getSide(oe), Ce = getAlignment(oe), Pe = getSideAxis(oe) === "y", {
        width: Xe,
        height: ht
      } = ie.floating;
      let wt, Pt;
      Ee === "top" || Ee === "bottom" ? (wt = Ee, Pt = Ce === (await (ae.isRTL == null ? void 0 : ae.isRTL(se.floating)) ? "start" : "end") ? "left" : "right") : (Pt = Ee, wt = Ce === "end" ? "top" : "bottom");
      const vt = ht - le.top - le.bottom, Bt = Xe - le.left - le.right, Ct = min$1(ht - le[wt], vt), Wt = min$1(Xe - le[Pt], Bt), Kt = !z.middlewareData.shift;
      let Yt = Ct, Ut = Wt;
      if ((Y = z.middlewareData.shift) != null && Y.enabled.x && (Ut = Bt), (ne = z.middlewareData.shift) != null && ne.enabled.y && (Yt = vt), Kt && !Ce) {
        const zt = max$1(le.left, 0), Ft = max$1(le.right, 0), Ve = max$1(le.top, 0), Je = max$1(le.bottom, 0);
        Pe ? Ut = Xe - 2 * (zt !== 0 || Ft !== 0 ? zt + Ft : max$1(le.left, le.right)) : Yt = ht - 2 * (Ve !== 0 || Je !== 0 ? Ve + Je : max$1(le.top, le.bottom));
      }
      await ve({
        ...z,
        availableWidth: Ut,
        availableHeight: Yt
      });
      const qt = await ae.getDimensions(se.floating);
      return Xe !== qt.width || ht !== qt.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(B) {
  const z = getComputedStyle$1(B);
  let Y = parseFloat(z.width) || 0, ne = parseFloat(z.height) || 0;
  const oe = isHTMLElement(B), ie = oe ? B.offsetWidth : Y, ae = oe ? B.offsetHeight : ne, se = round$1(Y) !== ie || round$1(ne) !== ae;
  return se && (Y = ie, ne = ae), {
    width: Y,
    height: ne,
    $: se
  };
}
function unwrapElement(B) {
  return isElement(B) ? B : B.contextElement;
}
function getScale(B) {
  const z = unwrapElement(B);
  if (!isHTMLElement(z))
    return createCoords(1);
  const Y = z.getBoundingClientRect(), {
    width: ne,
    height: oe,
    $: ie
  } = getCssDimensions(z);
  let ae = (ie ? round$1(Y.width) : Y.width) / ne, se = (ie ? round$1(Y.height) : Y.height) / oe;
  return (!ae || !Number.isFinite(ae)) && (ae = 1), (!se || !Number.isFinite(se)) && (se = 1), {
    x: ae,
    y: se
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(B) {
  const z = getWindow(B);
  return !isWebKit() || !z.visualViewport ? noOffsets : {
    x: z.visualViewport.offsetLeft,
    y: z.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(B, z, Y) {
  return z === void 0 && (z = !1), !Y || z && Y !== getWindow(B) ? !1 : z;
}
function getBoundingClientRect(B, z, Y, ne) {
  z === void 0 && (z = !1), Y === void 0 && (Y = !1);
  const oe = B.getBoundingClientRect(), ie = unwrapElement(B);
  let ae = createCoords(1);
  z && (ne ? isElement(ne) && (ae = getScale(ne)) : ae = getScale(B));
  const se = shouldAddVisualOffsets(ie, Y, ne) ? getVisualOffsets(ie) : createCoords(0);
  let ve = (oe.left + se.x) / ae.x, ge = (oe.top + se.y) / ae.y, le = oe.width / ae.x, Ee = oe.height / ae.y;
  if (ie) {
    const Ce = getWindow(ie), Pe = ne && isElement(ne) ? getWindow(ne) : ne;
    let Xe = Ce, ht = getFrameElement(Xe);
    for (; ht && ne && Pe !== Xe; ) {
      const wt = getScale(ht), Pt = ht.getBoundingClientRect(), vt = getComputedStyle$1(ht), Bt = Pt.left + (ht.clientLeft + parseFloat(vt.paddingLeft)) * wt.x, Ct = Pt.top + (ht.clientTop + parseFloat(vt.paddingTop)) * wt.y;
      ve *= wt.x, ge *= wt.y, le *= wt.x, Ee *= wt.y, ve += Bt, ge += Ct, Xe = getWindow(ht), ht = getFrameElement(Xe);
    }
  }
  return rectToClientRect({
    width: le,
    height: Ee,
    x: ve,
    y: ge
  });
}
function getWindowScrollBarX(B, z) {
  const Y = getNodeScroll(B).scrollLeft;
  return z ? z.left + Y : getBoundingClientRect(getDocumentElement(B)).left + Y;
}
function getHTMLOffset(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ne = B.getBoundingClientRect(), oe = ne.left + z.scrollLeft - (Y ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(B, ne)
  )), ie = ne.top + z.scrollTop;
  return {
    x: oe,
    y: ie
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(B) {
  let {
    elements: z,
    rect: Y,
    offsetParent: ne,
    strategy: oe
  } = B;
  const ie = oe === "fixed", ae = getDocumentElement(ne), se = z ? isTopLayer(z.floating) : !1;
  if (ne === ae || se && ie)
    return Y;
  let ve = {
    scrollLeft: 0,
    scrollTop: 0
  }, ge = createCoords(1);
  const le = createCoords(0), Ee = isHTMLElement(ne);
  if ((Ee || !Ee && !ie) && ((getNodeName(ne) !== "body" || isOverflowElement(ae)) && (ve = getNodeScroll(ne)), isHTMLElement(ne))) {
    const Pe = getBoundingClientRect(ne);
    ge = getScale(ne), le.x = Pe.x + ne.clientLeft, le.y = Pe.y + ne.clientTop;
  }
  const Ce = ae && !Ee && !ie ? getHTMLOffset(ae, ve, !0) : createCoords(0);
  return {
    width: Y.width * ge.x,
    height: Y.height * ge.y,
    x: Y.x * ge.x - ve.scrollLeft * ge.x + le.x + Ce.x,
    y: Y.y * ge.y - ve.scrollTop * ge.y + le.y + Ce.y
  };
}
function getClientRects(B) {
  return Array.from(B.getClientRects());
}
function getDocumentRect(B) {
  const z = getDocumentElement(B), Y = getNodeScroll(B), ne = B.ownerDocument.body, oe = max$1(z.scrollWidth, z.clientWidth, ne.scrollWidth, ne.clientWidth), ie = max$1(z.scrollHeight, z.clientHeight, ne.scrollHeight, ne.clientHeight);
  let ae = -Y.scrollLeft + getWindowScrollBarX(B);
  const se = -Y.scrollTop;
  return getComputedStyle$1(ne).direction === "rtl" && (ae += max$1(z.clientWidth, ne.clientWidth) - oe), {
    width: oe,
    height: ie,
    x: ae,
    y: se
  };
}
function getViewportRect(B, z) {
  const Y = getWindow(B), ne = getDocumentElement(B), oe = Y.visualViewport;
  let ie = ne.clientWidth, ae = ne.clientHeight, se = 0, ve = 0;
  if (oe) {
    ie = oe.width, ae = oe.height;
    const ge = isWebKit();
    (!ge || ge && z === "fixed") && (se = oe.offsetLeft, ve = oe.offsetTop);
  }
  return {
    width: ie,
    height: ae,
    x: se,
    y: ve
  };
}
function getInnerBoundingClientRect(B, z) {
  const Y = getBoundingClientRect(B, !0, z === "fixed"), ne = Y.top + B.clientTop, oe = Y.left + B.clientLeft, ie = isHTMLElement(B) ? getScale(B) : createCoords(1), ae = B.clientWidth * ie.x, se = B.clientHeight * ie.y, ve = oe * ie.x, ge = ne * ie.y;
  return {
    width: ae,
    height: se,
    x: ve,
    y: ge
  };
}
function getClientRectFromClippingAncestor(B, z, Y) {
  let ne;
  if (z === "viewport")
    ne = getViewportRect(B, Y);
  else if (z === "document")
    ne = getDocumentRect(getDocumentElement(B));
  else if (isElement(z))
    ne = getInnerBoundingClientRect(z, Y);
  else {
    const oe = getVisualOffsets(B);
    ne = {
      x: z.x - oe.x,
      y: z.y - oe.y,
      width: z.width,
      height: z.height
    };
  }
  return rectToClientRect(ne);
}
function hasFixedPositionAncestor(B, z) {
  const Y = getParentNode(B);
  return Y === z || !isElement(Y) || isLastTraversableNode(Y) ? !1 : getComputedStyle$1(Y).position === "fixed" || hasFixedPositionAncestor(Y, z);
}
function getClippingElementAncestors(B, z) {
  const Y = z.get(B);
  if (Y)
    return Y;
  let ne = getOverflowAncestors(B, [], !1).filter((se) => isElement(se) && getNodeName(se) !== "body"), oe = null;
  const ie = getComputedStyle$1(B).position === "fixed";
  let ae = ie ? getParentNode(B) : B;
  for (; isElement(ae) && !isLastTraversableNode(ae); ) {
    const se = getComputedStyle$1(ae), ve = isContainingBlock(ae);
    !ve && se.position === "fixed" && (oe = null), (ie ? !ve && !oe : !ve && se.position === "static" && !!oe && ["absolute", "fixed"].includes(oe.position) || isOverflowElement(ae) && !ve && hasFixedPositionAncestor(B, ae)) ? ne = ne.filter((le) => le !== ae) : oe = se, ae = getParentNode(ae);
  }
  return z.set(B, ne), ne;
}
function getClippingRect(B) {
  let {
    element: z,
    boundary: Y,
    rootBoundary: ne,
    strategy: oe
  } = B;
  const ae = [...Y === "clippingAncestors" ? isTopLayer(z) ? [] : getClippingElementAncestors(z, this._c) : [].concat(Y), ne], se = ae[0], ve = ae.reduce((ge, le) => {
    const Ee = getClientRectFromClippingAncestor(z, le, oe);
    return ge.top = max$1(Ee.top, ge.top), ge.right = min$1(Ee.right, ge.right), ge.bottom = min$1(Ee.bottom, ge.bottom), ge.left = max$1(Ee.left, ge.left), ge;
  }, getClientRectFromClippingAncestor(z, se, oe));
  return {
    width: ve.right - ve.left,
    height: ve.bottom - ve.top,
    x: ve.left,
    y: ve.top
  };
}
function getDimensions(B) {
  const {
    width: z,
    height: Y
  } = getCssDimensions(B);
  return {
    width: z,
    height: Y
  };
}
function getRectRelativeToOffsetParent(B, z, Y) {
  const ne = isHTMLElement(z), oe = getDocumentElement(z), ie = Y === "fixed", ae = getBoundingClientRect(B, !0, ie, z);
  let se = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ve = createCoords(0);
  if (ne || !ne && !ie)
    if ((getNodeName(z) !== "body" || isOverflowElement(oe)) && (se = getNodeScroll(z)), ne) {
      const Ce = getBoundingClientRect(z, !0, ie, z);
      ve.x = Ce.x + z.clientLeft, ve.y = Ce.y + z.clientTop;
    } else oe && (ve.x = getWindowScrollBarX(oe));
  const ge = oe && !ne && !ie ? getHTMLOffset(oe, se) : createCoords(0), le = ae.left + se.scrollLeft - ve.x - ge.x, Ee = ae.top + se.scrollTop - ve.y - ge.y;
  return {
    x: le,
    y: Ee,
    width: ae.width,
    height: ae.height
  };
}
function isStaticPositioned(B) {
  return getComputedStyle$1(B).position === "static";
}
function getTrueOffsetParent(B, z) {
  if (!isHTMLElement(B) || getComputedStyle$1(B).position === "fixed")
    return null;
  if (z)
    return z(B);
  let Y = B.offsetParent;
  return getDocumentElement(B) === Y && (Y = Y.ownerDocument.body), Y;
}
function getOffsetParent(B, z) {
  const Y = getWindow(B);
  if (isTopLayer(B))
    return Y;
  if (!isHTMLElement(B)) {
    let oe = getParentNode(B);
    for (; oe && !isLastTraversableNode(oe); ) {
      if (isElement(oe) && !isStaticPositioned(oe))
        return oe;
      oe = getParentNode(oe);
    }
    return Y;
  }
  let ne = getTrueOffsetParent(B, z);
  for (; ne && isTableElement(ne) && isStaticPositioned(ne); )
    ne = getTrueOffsetParent(ne, z);
  return ne && isLastTraversableNode(ne) && isStaticPositioned(ne) && !isContainingBlock(ne) ? Y : ne || getContainingBlock(B) || Y;
}
const getElementRects = async function(B) {
  const z = this.getOffsetParent || getOffsetParent, Y = this.getDimensions, ne = await Y(B.floating);
  return {
    reference: getRectRelativeToOffsetParent(B.reference, await z(B.floating), B.strategy),
    floating: {
      x: 0,
      y: 0,
      width: ne.width,
      height: ne.height
    }
  };
};
function isRTL(B) {
  return getComputedStyle$1(B).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(B, z) {
  return B.x === z.x && B.y === z.y && B.width === z.width && B.height === z.height;
}
function observeMove(B, z) {
  let Y = null, ne;
  const oe = getDocumentElement(B);
  function ie() {
    var se;
    clearTimeout(ne), (se = Y) == null || se.disconnect(), Y = null;
  }
  function ae(se, ve) {
    se === void 0 && (se = !1), ve === void 0 && (ve = 1), ie();
    const ge = B.getBoundingClientRect(), {
      left: le,
      top: Ee,
      width: Ce,
      height: Pe
    } = ge;
    if (se || z(), !Ce || !Pe)
      return;
    const Xe = floor$1(Ee), ht = floor$1(oe.clientWidth - (le + Ce)), wt = floor$1(oe.clientHeight - (Ee + Pe)), Pt = floor$1(le), Bt = {
      rootMargin: -Xe + "px " + -ht + "px " + -wt + "px " + -Pt + "px",
      threshold: max$1(0, min$1(1, ve)) || 1
    };
    let Ct = !0;
    function Wt(Kt) {
      const Yt = Kt[0].intersectionRatio;
      if (Yt !== ve) {
        if (!Ct)
          return ae();
        Yt ? ae(!1, Yt) : ne = setTimeout(() => {
          ae(!1, 1e-7);
        }, 1e3);
      }
      Yt === 1 && !rectsAreEqual(ge, B.getBoundingClientRect()) && ae(), Ct = !1;
    }
    try {
      Y = new IntersectionObserver(Wt, {
        ...Bt,
        // Handle <iframe>s
        root: oe.ownerDocument
      });
    } catch {
      Y = new IntersectionObserver(Wt, Bt);
    }
    Y.observe(B);
  }
  return ae(!0), ie;
}
function autoUpdate(B, z, Y, ne) {
  ne === void 0 && (ne = {});
  const {
    ancestorScroll: oe = !0,
    ancestorResize: ie = !0,
    elementResize: ae = typeof ResizeObserver == "function",
    layoutShift: se = typeof IntersectionObserver == "function",
    animationFrame: ve = !1
  } = ne, ge = unwrapElement(B), le = oe || ie ? [...ge ? getOverflowAncestors(ge) : [], ...getOverflowAncestors(z)] : [];
  le.forEach((Pt) => {
    oe && Pt.addEventListener("scroll", Y, {
      passive: !0
    }), ie && Pt.addEventListener("resize", Y);
  });
  const Ee = ge && se ? observeMove(ge, Y) : null;
  let Ce = -1, Pe = null;
  ae && (Pe = new ResizeObserver((Pt) => {
    let [vt] = Pt;
    vt && vt.target === ge && Pe && (Pe.unobserve(z), cancelAnimationFrame(Ce), Ce = requestAnimationFrame(() => {
      var Bt;
      (Bt = Pe) == null || Bt.observe(z);
    })), Y();
  }), ge && !ve && Pe.observe(ge), Pe.observe(z));
  let Xe, ht = ve ? getBoundingClientRect(B) : null;
  ve && wt();
  function wt() {
    const Pt = getBoundingClientRect(B);
    ht && !rectsAreEqual(ht, Pt) && Y(), ht = Pt, Xe = requestAnimationFrame(wt);
  }
  return Y(), () => {
    var Pt;
    le.forEach((vt) => {
      oe && vt.removeEventListener("scroll", Y), ie && vt.removeEventListener("resize", Y);
    }), Ee == null || Ee(), (Pt = Pe) == null || Pt.disconnect(), Pe = null, ve && cancelAnimationFrame(Xe);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, computePosition = (B, z, Y) => {
  const ne = /* @__PURE__ */ new Map(), oe = {
    platform,
    ...Y
  }, ie = {
    ...oe.platform,
    _c: ne
  };
  return computePosition$1(B, z, {
    ...oe,
    platform: ie
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(B, z) {
  if (B === z)
    return !0;
  if (typeof B != typeof z)
    return !1;
  if (typeof B == "function" && B.toString() === z.toString())
    return !0;
  let Y, ne, oe;
  if (B && z && typeof B == "object") {
    if (Array.isArray(B)) {
      if (Y = B.length, Y !== z.length) return !1;
      for (ne = Y; ne-- !== 0; )
        if (!deepEqual(B[ne], z[ne]))
          return !1;
      return !0;
    }
    if (oe = Object.keys(B), Y = oe.length, Y !== Object.keys(z).length)
      return !1;
    for (ne = Y; ne-- !== 0; )
      if (!{}.hasOwnProperty.call(z, oe[ne]))
        return !1;
    for (ne = Y; ne-- !== 0; ) {
      const ie = oe[ne];
      if (!(ie === "_owner" && B.$$typeof) && !deepEqual(B[ie], z[ie]))
        return !1;
    }
    return !0;
  }
  return B !== B && z !== z;
}
function getDPR(B) {
  return typeof window > "u" ? 1 : (B.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(B, z) {
  const Y = getDPR(B);
  return Math.round(z * Y) / Y;
}
function useLatestRef(B) {
  const z = React.useRef(B);
  return index$1(() => {
    z.current = B;
  }), z;
}
function useFloating$1(B) {
  B === void 0 && (B = {});
  const {
    placement: z = "bottom",
    strategy: Y = "absolute",
    middleware: ne = [],
    platform: oe,
    elements: {
      reference: ie,
      floating: ae
    } = {},
    transform: se = !0,
    whileElementsMounted: ve,
    open: ge
  } = B, [le, Ee] = React.useState({
    x: 0,
    y: 0,
    strategy: Y,
    placement: z,
    middlewareData: {},
    isPositioned: !1
  }), [Ce, Pe] = React.useState(ne);
  deepEqual(Ce, ne) || Pe(ne);
  const [Xe, ht] = React.useState(null), [wt, Pt] = React.useState(null), vt = React.useCallback(($t) => {
    $t !== Kt.current && (Kt.current = $t, ht($t));
  }, []), Bt = React.useCallback(($t) => {
    $t !== Yt.current && (Yt.current = $t, Pt($t));
  }, []), Ct = ie || Xe, Wt = ae || wt, Kt = React.useRef(null), Yt = React.useRef(null), Ut = React.useRef(le), qt = ve != null, zt = useLatestRef(ve), Ft = useLatestRef(oe), Ve = useLatestRef(ge), Je = React.useCallback(() => {
    if (!Kt.current || !Yt.current)
      return;
    const $t = {
      placement: z,
      strategy: Y,
      middleware: Ce
    };
    Ft.current && ($t.platform = Ft.current), computePosition(Kt.current, Yt.current, $t).then((kt) => {
      const xt = {
        ...kt,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: Ve.current !== !1
      };
      Ke.current && !deepEqual(Ut.current, xt) && (Ut.current = xt, ReactDOM.flushSync(() => {
        Ee(xt);
      }));
    });
  }, [Ce, z, Y, Ft, Ve]);
  index$1(() => {
    ge === !1 && Ut.current.isPositioned && (Ut.current.isPositioned = !1, Ee(($t) => ({
      ...$t,
      isPositioned: !1
    })));
  }, [ge]);
  const Ke = React.useRef(!1);
  index$1(() => (Ke.current = !0, () => {
    Ke.current = !1;
  }), []), index$1(() => {
    if (Ct && (Kt.current = Ct), Wt && (Yt.current = Wt), Ct && Wt) {
      if (zt.current)
        return zt.current(Ct, Wt, Je);
      Je();
    }
  }, [Ct, Wt, Je, zt, qt]);
  const Qe = React.useMemo(() => ({
    reference: Kt,
    floating: Yt,
    setReference: vt,
    setFloating: Bt
  }), [vt, Bt]), bt = React.useMemo(() => ({
    reference: Ct,
    floating: Wt
  }), [Ct, Wt]), _t = React.useMemo(() => {
    const $t = {
      position: Y,
      left: 0,
      top: 0
    };
    if (!bt.floating)
      return $t;
    const kt = roundByDPR(bt.floating, le.x), xt = roundByDPR(bt.floating, le.y);
    return se ? {
      ...$t,
      transform: "translate(" + kt + "px, " + xt + "px)",
      ...getDPR(bt.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: Y,
      left: kt,
      top: xt
    };
  }, [Y, se, bt.floating, le.x, le.y]);
  return React.useMemo(() => ({
    ...le,
    update: Je,
    refs: Qe,
    elements: bt,
    floatingStyles: _t
  }), [le, Je, Qe, bt, _t]);
}
const offset = (B, z) => ({
  ...offset$1(B),
  options: [B, z]
}), shift = (B, z) => ({
  ...shift$1(B),
  options: [B, z]
}), flip = (B, z) => ({
  ...flip$1(B),
  options: [B, z]
}), size = (B, z) => ({
  ...size$1(B),
  options: [B, z]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((B) => B());
function useEffectEvent(B) {
  const z = React.useRef(() => {
    if (process$1.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    z.current = B;
  }), React.useCallback(function() {
    for (var Y = arguments.length, ne = new Array(Y), oe = 0; oe < Y; oe++)
      ne[oe] = arguments[oe];
    return z.current == null ? void 0 : z.current(...ne);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [B, z] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    B == null && z(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), B;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
process$1.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const oe = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(oe))) {
    var ie;
    (ie = devMessageSet) == null || ie.add(oe), console.warn(oe);
  }
}
function error() {
  for (var B, z = arguments.length, Y = new Array(z), ne = 0; ne < z; ne++)
    Y[ne] = arguments[ne];
  const oe = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(oe))) {
    var ie;
    (ie = devMessageSet) == null || ie.add(oe), console.error(oe);
  }
}
function createPubSub() {
  const B = /* @__PURE__ */ new Map();
  return {
    emit(z, Y) {
      var ne;
      (ne = B.get(z)) == null || ne.forEach((oe) => oe(Y));
    },
    on(z, Y) {
      B.set(z, [...B.get(z) || [], Y]);
    },
    off(z, Y) {
      var ne;
      B.set(z, ((ne = B.get(z)) == null ? void 0 : ne.filter((oe) => oe !== Y)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var B;
  return ((B = React.useContext(FloatingNodeContext)) == null ? void 0 : B.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(B) {
  const {
    open: z = !1,
    onOpenChange: Y,
    elements: ne
  } = B, oe = useId(), ie = React.useRef({}), [ae] = React.useState(() => createPubSub()), se = useFloatingParentNodeId() != null;
  if (process$1.env.NODE_ENV !== "production") {
    const Pe = ne.reference;
    Pe && !isElement(Pe) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [ve, ge] = React.useState(ne.reference), le = useEffectEvent((Pe, Xe, ht) => {
    ie.current.openEvent = Pe ? Xe : void 0, ae.emit("openchange", {
      open: Pe,
      event: Xe,
      reason: ht,
      nested: se
    }), Y == null || Y(Pe, Xe, ht);
  }), Ee = React.useMemo(() => ({
    setPositionReference: ge
  }), []), Ce = React.useMemo(() => ({
    reference: ve || ne.reference || null,
    floating: ne.floating || null,
    domReference: ne.reference
  }), [ve, ne.reference, ne.floating]);
  return React.useMemo(() => ({
    dataRef: ie,
    open: z,
    onOpenChange: le,
    elements: Ce,
    events: ae,
    floatingId: oe,
    refs: Ee
  }), [z, le, Ce, ae, oe, Ee]);
}
function useFloating(B) {
  B === void 0 && (B = {});
  const {
    nodeId: z
  } = B, Y = useFloatingRootContext({
    ...B,
    elements: {
      reference: null,
      floating: null,
      ...B.elements
    }
  }), ne = B.rootContext || Y, oe = ne.elements, [ie, ae] = React.useState(null), [se, ve] = React.useState(null), le = (oe == null ? void 0 : oe.domReference) || ie, Ee = React.useRef(null), Ce = useFloatingTree();
  index(() => {
    le && (Ee.current = le);
  }, [le]);
  const Pe = useFloating$1({
    ...B,
    elements: {
      ...oe,
      ...se && {
        reference: se
      }
    }
  }), Xe = React.useCallback((Bt) => {
    const Ct = isElement(Bt) ? {
      getBoundingClientRect: () => Bt.getBoundingClientRect(),
      contextElement: Bt
    } : Bt;
    ve(Ct), Pe.refs.setReference(Ct);
  }, [Pe.refs]), ht = React.useCallback((Bt) => {
    (isElement(Bt) || Bt === null) && (Ee.current = Bt, ae(Bt)), (isElement(Pe.refs.reference.current) || Pe.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    Bt !== null && !isElement(Bt)) && Pe.refs.setReference(Bt);
  }, [Pe.refs]), wt = React.useMemo(() => ({
    ...Pe.refs,
    setReference: ht,
    setPositionReference: Xe,
    domReference: Ee
  }), [Pe.refs, ht, Xe]), Pt = React.useMemo(() => ({
    ...Pe.elements,
    domReference: le
  }), [Pe.elements, le]), vt = React.useMemo(() => ({
    ...Pe,
    ...ne,
    refs: wt,
    elements: Pt,
    nodeId: z
  }), [Pe, wt, Pt, z, ne]);
  return index(() => {
    ne.dataRef.current.floatingContext = vt;
    const Bt = Ce == null ? void 0 : Ce.nodesRef.current.find((Ct) => Ct.id === z);
    Bt && (Bt.context = vt);
  }), React.useMemo(() => ({
    ...Pe,
    context: vt,
    refs: wt,
    elements: Pt
  }), [Pe, wt, Pt, vt]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(B, z, Y) {
  const ne = /* @__PURE__ */ new Map(), oe = Y === "item";
  let ie = B;
  if (oe && B) {
    const {
      [ACTIVE_KEY]: ae,
      [SELECTED_KEY]: se,
      ...ve
    } = B;
    ie = ve;
  }
  return {
    ...Y === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...ie,
    ...z.map((ae) => {
      const se = ae ? ae[Y] : null;
      return typeof se == "function" ? B ? se(B) : null : se;
    }).concat(B).reduce((ae, se) => (se && Object.entries(se).forEach((ve) => {
      let [ge, le] = ve;
      if (!(oe && [ACTIVE_KEY, SELECTED_KEY].includes(ge)))
        if (ge.indexOf("on") === 0) {
          if (ne.has(ge) || ne.set(ge, []), typeof le == "function") {
            var Ee;
            (Ee = ne.get(ge)) == null || Ee.push(le), ae[ge] = function() {
              for (var Ce, Pe = arguments.length, Xe = new Array(Pe), ht = 0; ht < Pe; ht++)
                Xe[ht] = arguments[ht];
              return (Ce = ne.get(ge)) == null ? void 0 : Ce.map((wt) => wt(...Xe)).find((wt) => wt !== void 0);
            };
          }
        } else
          ae[ge] = le;
    }), ae), {})
  };
}
function useInteractions(B) {
  B === void 0 && (B = []);
  const z = B.map((se) => se == null ? void 0 : se.reference), Y = B.map((se) => se == null ? void 0 : se.floating), ne = B.map((se) => se == null ? void 0 : se.item), oe = React.useCallback(
    (se) => mergeProps(se, B, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    z
  ), ie = React.useCallback(
    (se) => mergeProps(se, B, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Y
  ), ae = React.useCallback(
    (se) => mergeProps(se, B, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    ne
  );
  return React.useMemo(() => ({
    getReferenceProps: oe,
    getFloatingProps: ie,
    getItemProps: ae
  }), [oe, ie, ae]);
}
function getArgsWithCustomFloatingHeight(B, z) {
  return {
    ...B,
    rects: {
      ...B.rects,
      floating: {
        ...B.rects.floating,
        height: z
      }
    }
  };
}
const inner = (B) => ({
  name: "inner",
  options: B,
  async fn(z) {
    const {
      listRef: Y,
      overflowRef: ne,
      onFallbackChange: oe,
      offset: ie = 0,
      index: ae = 0,
      minItemsVisible: se = 4,
      referenceOverflowThreshold: ve = 0,
      scrollRef: ge,
      ...le
    } = evaluate(B, z), {
      rects: Ee,
      elements: {
        floating: Ce
      }
    } = z, Pe = Y.current[ae], Xe = (ge == null ? void 0 : ge.current) || Ce, ht = Ce.clientTop || Xe.clientTop, wt = Ce.clientTop !== 0, Pt = Xe.clientTop !== 0, vt = Ce === Xe;
    if (process$1.env.NODE_ENV !== "production" && (z.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.")), !Pe)
      return {};
    const Bt = {
      ...z,
      ...await offset(-Pe.offsetTop - Ce.clientTop - Ee.reference.height / 2 - Pe.offsetHeight / 2 - ie).fn(z)
    }, Ct = await detectOverflow(getArgsWithCustomFloatingHeight(Bt, Xe.scrollHeight + ht + Ce.clientTop), le), Wt = await detectOverflow(Bt, {
      ...le,
      elementContext: "reference"
    }), Kt = max$1(0, Ct.top), Yt = Bt.y + Kt, zt = (Xe.scrollHeight > Xe.clientHeight ? (Ft) => Ft : round$1)(max$1(0, Xe.scrollHeight + (wt && vt || Pt ? ht * 2 : 0) - Kt - max$1(0, Ct.bottom)));
    if (Xe.style.maxHeight = zt + "px", Xe.scrollTop = Kt, oe) {
      const Ft = Xe.offsetHeight < Pe.offsetHeight * min$1(se, Y.current.length) - 1 || Wt.top >= -ve || Wt.bottom >= -ve;
      ReactDOM.flushSync(() => oe(Ft));
    }
    return ne && (ne.current = await detectOverflow(getArgsWithCustomFloatingHeight({
      ...Bt,
      y: Yt
    }, Xe.offsetHeight + ht + Ce.clientTop), le)), {
      y: Yt
    };
  }
});
function useInnerOffset(B, z) {
  const {
    open: Y,
    elements: ne
  } = B, {
    enabled: oe = !0,
    overflowRef: ie,
    scrollRef: ae,
    onChange: se
  } = z, ve = useEffectEvent(se), ge = React.useRef(!1), le = React.useRef(null), Ee = React.useRef(null);
  React.useEffect(() => {
    if (!oe) return;
    function Pe(ht) {
      if (ht.ctrlKey || !Xe || ie.current == null)
        return;
      const wt = ht.deltaY, Pt = ie.current.top >= -0.5, vt = ie.current.bottom >= -0.5, Bt = Xe.scrollHeight - Xe.clientHeight, Ct = wt < 0 ? -1 : 1, Wt = wt < 0 ? "max" : "min";
      Xe.scrollHeight <= Xe.clientHeight || (!Pt && wt > 0 || !vt && wt < 0 ? (ht.preventDefault(), ReactDOM.flushSync(() => {
        ve((Kt) => Kt + Math[Wt](wt, Bt * Ct));
      })) : /firefox/i.test(getUserAgent()) && (Xe.scrollTop += wt));
    }
    const Xe = (ae == null ? void 0 : ae.current) || ne.floating;
    if (Y && Xe)
      return Xe.addEventListener("wheel", Pe), requestAnimationFrame(() => {
        le.current = Xe.scrollTop, ie.current != null && (Ee.current = {
          ...ie.current
        });
      }), () => {
        le.current = null, Ee.current = null, Xe.removeEventListener("wheel", Pe);
      };
  }, [oe, Y, ne.floating, ie, ae, ve]);
  const Ce = React.useMemo(() => ({
    onKeyDown() {
      ge.current = !0;
    },
    onWheel() {
      ge.current = !1;
    },
    onPointerMove() {
      ge.current = !1;
    },
    onScroll() {
      const Pe = (ae == null ? void 0 : ae.current) || ne.floating;
      if (!(!ie.current || !Pe || !ge.current)) {
        if (le.current !== null) {
          const Xe = Pe.scrollTop - le.current;
          (ie.current.bottom < -0.5 && Xe < -1 || ie.current.top < -0.5 && Xe > 1) && ReactDOM.flushSync(() => ve((ht) => ht + Xe));
        }
        requestAnimationFrame(() => {
          le.current = Pe.scrollTop;
        });
      }
    }
  }), [ne.floating, ve, ie, ae]);
  return React.useMemo(() => oe ? {
    floating: Ce
  } : {}, [oe, Ce]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let H = createContext(null);
H.displayName = "PlacementContext";
function xe(B) {
  return useMemo(() => B ? typeof B == "string" ? { to: B } : B : null, [B]);
}
function ye$1() {
  return useContext(y$1).setReference;
}
function Fe$1() {
  return useContext(y$1).getReferenceProps;
}
function be() {
  let { getFloatingProps: B, slot: z } = useContext(y$1);
  return useCallback((...Y) => Object.assign({}, B(...Y), { "data-anchor": z.anchor }), [B, z]);
}
function Re(B = null) {
  B === !1 && (B = null), typeof B == "string" && (B = { to: B });
  let z = useContext(H), Y = useMemo(() => B, [JSON.stringify(B, (oe, ie) => {
    var ae;
    return (ae = ie == null ? void 0 : ie.outerHTML) != null ? ae : ie;
  })]);
  n$3(() => {
    z == null || z(Y ?? null);
  }, [z, Y]);
  let ne = useContext(y$1);
  return useMemo(() => [ne.setFloating, B ? ne.styles : {}], [ne.setFloating, B, ne.styles]);
}
let q = 4;
function Me$1({ children: B, enabled: z = !0 }) {
  let [Y, ne] = useState(null), [oe, ie] = useState(0), ae = useRef(null), [se, ve] = useState(null);
  pe(se);
  let ge = z && Y !== null && se !== null, { to: le = "bottom", gap: Ee = 0, offset: Ce = 0, padding: Pe = 0, inner: Xe } = ce(Y, se), [ht, wt = "center"] = le.split(" ");
  n$3(() => {
    ge && ie(0);
  }, [ge]);
  let { refs: Pt, floatingStyles: vt, context: Bt } = useFloating({ open: ge, placement: ht === "selection" ? wt === "center" ? "bottom" : `bottom-${wt}` : wt === "center" ? `${ht}` : `${ht}-${wt}`, strategy: "absolute", transform: !1, middleware: [offset({ mainAxis: ht === "selection" ? 0 : Ee, crossAxis: Ce }), shift({ padding: Pe }), ht !== "selection" && flip({ padding: Pe }), ht === "selection" && Xe ? inner({ ...Xe, padding: Pe, overflowRef: ae, offset: oe, minItemsVisible: q, referenceOverflowThreshold: Pe, onFallbackChange(Ft) {
    var Ve, Je;
    if (!Ft) return;
    let Ke = Bt.elements.floating;
    if (!Ke) return;
    let Qe = parseFloat(getComputedStyle(Ke).scrollPaddingBottom) || 0, bt = Math.min(q, Ke.childElementCount), _t = 0, $t = 0;
    for (let kt of (Je = (Ve = Bt.elements.floating) == null ? void 0 : Ve.childNodes) != null ? Je : []) if (kt instanceof HTMLElement) {
      let xt = kt.offsetTop, Nt = xt + kt.clientHeight + Qe, Rt = Ke.scrollTop, Ht = Rt + Ke.clientHeight;
      if (xt >= Rt && Nt <= Ht) bt--;
      else {
        $t = Math.max(0, Math.min(Nt, Ht) - Math.max(xt, Rt)), _t = kt.clientHeight;
        break;
      }
    }
    bt >= 1 && ie((kt) => {
      let xt = _t * bt - $t + Qe;
      return kt >= xt ? kt : xt;
    });
  } }) : null, size({ padding: Pe, apply({ availableWidth: Ft, availableHeight: Ve, elements: Je }) {
    Object.assign(Je.floating.style, { overflow: "auto", maxWidth: `${Ft}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${Ve}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [Ct = ht, Wt = wt] = Bt.placement.split("-");
  ht === "selection" && (Ct = "selection");
  let Kt = useMemo(() => ({ anchor: [Ct, Wt].filter(Boolean).join(" ") }), [Ct, Wt]), Yt = useInnerOffset(Bt, { overflowRef: ae, onChange: ie }), { getReferenceProps: Ut, getFloatingProps: qt } = useInteractions([Yt]), zt = o$4((Ft) => {
    ve(Ft), Pt.setFloating(Ft);
  });
  return React.createElement(H.Provider, { value: ne }, React.createElement(y$1.Provider, { value: { setFloating: zt, setReference: Pt.setReference, styles: vt, getReferenceProps: Ut, getFloatingProps: qt, slot: Kt } }, B));
}
function pe(B) {
  n$3(() => {
    if (!B) return;
    let z = new MutationObserver(() => {
      let Y = window.getComputedStyle(B).maxHeight, ne = parseFloat(Y);
      if (isNaN(ne)) return;
      let oe = parseInt(Y);
      isNaN(oe) || ne !== oe && (B.style.maxHeight = `${Math.ceil(ne)}px`);
    });
    return z.observe(B, { attributes: !0, attributeFilter: ["style"] }), () => {
      z.disconnect();
    };
  }, [B]);
}
function ce(B, z) {
  var Y, ne, oe;
  let ie = V$1((Y = B == null ? void 0 : B.gap) != null ? Y : "var(--anchor-gap, 0)", z), ae = V$1((ne = B == null ? void 0 : B.offset) != null ? ne : "var(--anchor-offset, 0)", z), se = V$1((oe = B == null ? void 0 : B.padding) != null ? oe : "var(--anchor-padding, 0)", z);
  return { ...B, gap: ie, offset: ae, padding: se };
}
function V$1(B, z, Y = void 0) {
  let ne = p$2(), oe = o$4((ve, ge) => {
    if (ve == null) return [Y, null];
    if (typeof ve == "number") return [ve, null];
    if (typeof ve == "string") {
      if (!ge) return [Y, null];
      let le = J$1(ve, ge);
      return [le, (Ee) => {
        let Ce = D$1(ve);
        {
          let Pe = Ce.map((Xe) => window.getComputedStyle(ge).getPropertyValue(Xe));
          ne.requestAnimationFrame(function Xe() {
            ne.nextFrame(Xe);
            let ht = !1;
            for (let [Pt, vt] of Ce.entries()) {
              let Bt = window.getComputedStyle(ge).getPropertyValue(vt);
              if (Pe[Pt] !== Bt) {
                Pe[Pt] = Bt, ht = !0;
                break;
              }
            }
            if (!ht) return;
            let wt = J$1(ve, ge);
            le !== wt && (Ee(wt), le = wt);
          });
        }
        return ne.dispose;
      }];
    }
    return [Y, null];
  }), ie = useMemo(() => oe(B, z)[0], [B, z]), [ae = ie, se] = useState();
  return n$3(() => {
    let [ve, ge] = oe(B, z);
    if (se(ve), !!ge) return ge(se);
  }, [B, z]), ae;
}
function D$1(B) {
  let z = /var\((.*)\)/.exec(B);
  if (z) {
    let Y = z[1].indexOf(",");
    if (Y === -1) return [z[1]];
    let ne = z[1].slice(0, Y).trim(), oe = z[1].slice(Y + 1).trim();
    return oe ? [ne, ...D$1(oe)] : [ne];
  }
  return [];
}
function J$1(B, z) {
  let Y = document.createElement("div");
  z.appendChild(Y), Y.style.setProperty("margin-top", "0px", "important"), Y.style.setProperty("margin-top", B, "important");
  let ne = parseFloat(window.getComputedStyle(Y).marginTop) || 0;
  return z.removeChild(Y), ne;
}
let n = createContext(null);
n.displayName = "OpenClosedContext";
var i$3 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(i$3 || {});
function u$2() {
  return useContext(n);
}
function c$2({ value: B, children: z }) {
  return React__default.createElement(n.Provider, { value: B }, z);
}
function s$4({ children: B }) {
  return React__default.createElement(n.Provider, { value: null }, B);
}
function t(B) {
  function z() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", z));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", z), z());
}
let r$1 = [];
t(() => {
  function B(z) {
    if (!(z.target instanceof HTMLElement) || z.target === document.body || r$1[0] === z.target) return;
    let Y = z.target;
    Y = Y.closest(f$5), r$1.unshift(Y ?? z.target), r$1 = r$1.filter((ne) => ne != null && ne.isConnected), r$1.splice(10);
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function u$1(B) {
  throw new Error("Unexpected object: " + B);
}
var c$1 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$1 || {});
function f$3(B, z) {
  let Y = z.resolveItems();
  if (Y.length <= 0) return null;
  let ne = z.resolveActiveIndex(), oe = ne ?? -1;
  switch (B.focus) {
    case 0: {
      for (let ie = 0; ie < Y.length; ++ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 1: {
      oe === -1 && (oe = Y.length);
      for (let ie = oe - 1; ie >= 0; --ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 2: {
      for (let ie = oe + 1; ie < Y.length; ++ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 3: {
      for (let ie = Y.length - 1; ie >= 0; --ie) if (!z.resolveDisabled(Y[ie], ie, Y)) return ie;
      return ne;
    }
    case 4: {
      for (let ie = 0; ie < Y.length; ++ie) if (z.resolveId(Y[ie], ie, Y) === B.id) return ie;
      return ne;
    }
    case 5:
      return null;
    default:
      u$1(B);
  }
}
function c(B) {
  let z = o$4(B), Y = useRef(!1);
  useEffect(() => (Y.current = !1, () => {
    Y.current = !0, t$4(() => {
      Y.current && z();
    });
  }), [z]);
}
function s$3() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in React ? ((z) => z.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$1() {
  let B = s$3(), [z, Y] = React.useState(s$8.isHandoffComplete);
  return z && s$8.isHandoffComplete === !1 && Y(!1), React.useEffect(() => {
    z !== !0 && Y(!0);
  }, [z]), React.useEffect(() => s$8.handoff(), []), B ? !1 : z;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l(B) {
  return React__default.createElement(e.Provider, { value: B.force }, B.children);
}
function N(B) {
  let z = a$4(), Y = useContext(v), ne = n$1(B), [oe, ie] = useState(() => {
    var ae;
    if (!z && Y !== null) return (ae = Y.current) != null ? ae : null;
    if (s$8.isServer) return null;
    let se = ne == null ? void 0 : ne.getElementById("headlessui-portal-root");
    if (se) return se;
    if (ne === null) return null;
    let ve = ne.createElement("div");
    return ve.setAttribute("id", "headlessui-portal-root"), ne.body.appendChild(ve);
  });
  return useEffect(() => {
    oe !== null && (ne != null && ne.body.contains(oe) || ne == null || ne.body.appendChild(oe));
  }, [oe, ne]), useEffect(() => {
    z || Y !== null && ie(Y.current);
  }, [Y, ie, z]), oe;
}
let M$1 = Fragment, S = K$1(function(B, z) {
  let Y = B, ne = useRef(null), oe = y$4(T$2((Ee) => {
    ne.current = Ee;
  }), z), ie = n$1(ne), ae = N(ne), [se] = useState(() => {
    var Ee;
    return s$8.isServer ? null : (Ee = ie == null ? void 0 : ie.createElement("div")) != null ? Ee : null;
  }), ve = useContext(y), ge = l$1();
  n$3(() => {
    !ae || !se || ae.contains(se) || (se.setAttribute("data-headlessui-portal", ""), ae.appendChild(se));
  }, [ae, se]), n$3(() => {
    if (se && ve) return ve.register(se);
  }, [ve, se]), c(() => {
    var Ee;
    !ae || !se || (se instanceof Node && ae.contains(se) && ae.removeChild(se), ae.childNodes.length <= 0 && ((Ee = ae.parentElement) == null || Ee.removeChild(ae)));
  });
  let le = L$1();
  return ge ? !ae || !se ? null : createPortal(le({ ourProps: { ref: oe }, theirProps: Y, slot: {}, defaultTag: M$1, name: "Portal" }), se) : null;
});
function j$1(B, z) {
  let Y = y$4(z), { enabled: ne = !0, ...oe } = B, ie = L$1();
  return ne ? React__default.createElement(S, { ...oe, ref: Y }) : ie({ ourProps: { ref: Y }, theirProps: oe, slot: {}, defaultTag: M$1, name: "Portal" });
}
let W = Fragment, v = createContext(null);
function I$1(B, z) {
  let { target: Y, ...ne } = B, oe = { ref: y$4(z) }, ie = L$1();
  return React__default.createElement(v.Provider, { value: Y }, ie({ ourProps: oe, theirProps: ne, defaultTag: W, name: "Popover.Group" }));
}
let y = createContext(null);
function te$1() {
  let B = useContext(y), z = useRef([]), Y = o$4((ie) => (z.current.push(ie), B && B.register(ie), () => ne(ie))), ne = o$4((ie) => {
    let ae = z.current.indexOf(ie);
    ae !== -1 && z.current.splice(ae, 1), B && B.unregister(ie);
  }), oe = useMemo(() => ({ register: Y, unregister: ne, portals: z }), [Y, ne, z]);
  return [z, useMemo(() => function({ children: ie }) {
    return React__default.createElement(y.Provider, { value: oe }, ie);
  }, [oe])];
}
let J = K$1(j$1), X$1 = K$1(I$1), re$1 = Object.assign(J, { Group: X$1 });
function a$3(B, z = typeof document < "u" ? document.defaultView : null, Y) {
  let ne = x$3(B, "escape");
  E(z, "keydown", (oe) => {
    ne && (oe.defaultPrevented || oe.key === o$3.Escape && Y(oe));
  });
}
function f$2() {
  var B;
  let [z] = useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [Y, ne] = useState((B = z == null ? void 0 : z.matches) != null ? B : !1);
  return n$3(() => {
    if (!z) return;
    function oe(ie) {
      ne(ie.matches);
    }
    return z.addEventListener("change", oe), () => z.removeEventListener("change", oe);
  }, [z]), Y;
}
function R({ defaultContainers: B = [], portals: z, mainTreeNode: Y } = {}) {
  let ne = n$1(Y), oe = o$4(() => {
    var ie, ae;
    let se = [];
    for (let ve of B) ve !== null && (ve instanceof HTMLElement ? se.push(ve) : "current" in ve && ve.current instanceof HTMLElement && se.push(ve.current));
    if (z != null && z.current) for (let ve of z.current) se.push(ve);
    for (let ve of (ie = ne == null ? void 0 : ne.querySelectorAll("html > *, body > *")) != null ? ie : []) ve !== document.body && ve !== document.head && ve instanceof HTMLElement && ve.id !== "headlessui-portal-root" && (Y && (ve.contains(Y) || ve.contains((ae = Y == null ? void 0 : Y.getRootNode()) == null ? void 0 : ae.host)) || se.some((ge) => ve.contains(ge)) || se.push(ve));
    return se;
  });
  return { resolveContainers: oe, contains: o$4((ie) => oe().some((ae) => ae.contains(ie))) };
}
let a$2 = createContext(null);
function O$1({ children: B, node: z }) {
  let [Y, ne] = useState(null), oe = b(z ?? Y);
  return React__default.createElement(a$2.Provider, { value: oe }, B, oe === null && React__default.createElement(f$9, { features: s$6.Hidden, ref: (ie) => {
    var ae, se;
    if (ie) {
      for (let ve of (se = (ae = u$8(ie)) == null ? void 0 : ae.querySelectorAll("html > *, body > *")) != null ? se : []) if (ve !== document.body && ve !== document.head && ve instanceof HTMLElement && ve != null && ve.contains(ie)) {
        ne(ve);
        break;
      }
    }
  } }));
}
function b(B = null) {
  var z;
  return (z = useContext(a$2)) != null ? z : B;
}
function f$1() {
  let B = useRef(!1);
  return n$3(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
var a$1 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(a$1 || {});
function u() {
  let B = useRef(0);
  return s$5(!0, "keydown", (z) => {
    z.key === "Tab" && (B.current = z.shiftKey ? 1 : 0);
  }, !0), B;
}
function U$1(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let z = /* @__PURE__ */ new Set();
  for (let Y of B.current) Y.current instanceof HTMLElement && z.add(Y.current);
  return z;
}
let Z = "div";
var x$1 = ((B) => (B[B.None = 0] = "None", B[B.InitialFocus = 1] = "InitialFocus", B[B.TabLock = 2] = "TabLock", B[B.FocusLock = 4] = "FocusLock", B[B.RestoreFocus = 8] = "RestoreFocus", B[B.AutoFocus = 16] = "AutoFocus", B))(x$1 || {});
function $(B, z) {
  let Y = useRef(null), ne = y$4(Y, z), { initialFocus: oe, initialFocusFallback: ie, containers: ae, features: se = 15, ...ve } = B;
  l$1() || (se = 0);
  let ge = n$1(Y);
  ee(se, { ownerDocument: ge });
  let le = te(se, { ownerDocument: ge, container: Y, initialFocus: oe, initialFocusFallback: ie });
  re(se, { ownerDocument: ge, container: Y, containers: ae, previousActiveElement: le });
  let Ee = u(), Ce = o$4((vt) => {
    let Bt = Y.current;
    Bt && ((Ct) => Ct())(() => {
      u$7(Ee.current, { [a$1.Forwards]: () => {
        P(Bt, F$1.First, { skipElements: [vt.relatedTarget, ie] });
      }, [a$1.Backwards]: () => {
        P(Bt, F$1.Last, { skipElements: [vt.relatedTarget, ie] });
      } });
    });
  }), Pe = x$3(!!(se & 2), "focus-trap#tab-lock"), Xe = p$2(), ht = useRef(!1), wt = { ref: ne, onKeyDown(vt) {
    vt.key == "Tab" && (ht.current = !0, Xe.requestAnimationFrame(() => {
      ht.current = !1;
    }));
  }, onBlur(vt) {
    if (!(se & 4)) return;
    let Bt = U$1(ae);
    Y.current instanceof HTMLElement && Bt.add(Y.current);
    let Ct = vt.relatedTarget;
    Ct instanceof HTMLElement && Ct.dataset.headlessuiFocusGuard !== "true" && (I(Bt, Ct) || (ht.current ? P(Y.current, u$7(Ee.current, { [a$1.Forwards]: () => F$1.Next, [a$1.Backwards]: () => F$1.Previous }) | F$1.WrapAround, { relativeTo: vt.target }) : vt.target instanceof HTMLElement && I$2(vt.target)));
  } }, Pt = L$1();
  return React__default.createElement(React__default.Fragment, null, Pe && React__default.createElement(f$9, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ce, features: s$6.Focusable }), Pt({ ourProps: wt, theirProps: ve, defaultTag: Z, name: "FocusTrap" }), Pe && React__default.createElement(f$9, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ce, features: s$6.Focusable }));
}
let D = K$1($), ye = Object.assign(D, { features: x$1 });
function w$2(B = !0) {
  let z = useRef(r$1.slice());
  return m(([Y], [ne]) => {
    ne === !0 && Y === !1 && t$4(() => {
      z.current.splice(0);
    }), ne === !1 && Y === !0 && (z.current = r$1.slice());
  }, [B, r$1, z]), o$4(() => {
    var Y;
    return (Y = z.current.find((ne) => ne != null && ne.isConnected)) != null ? Y : null;
  });
}
function ee(B, { ownerDocument: z }) {
  let Y = !!(B & 8), ne = w$2(Y);
  m(() => {
    Y || (z == null ? void 0 : z.activeElement) === (z == null ? void 0 : z.body) && I$2(ne());
  }, [Y]), c(() => {
    Y && I$2(ne());
  });
}
function te(B, { ownerDocument: z, container: Y, initialFocus: ne, initialFocusFallback: oe }) {
  let ie = useRef(null), ae = x$3(!!(B & 1), "focus-trap#initial-focus"), se = f$1();
  return m(() => {
    if (B === 0) return;
    if (!ae) {
      oe != null && oe.current && I$2(oe.current);
      return;
    }
    let ve = Y.current;
    ve && t$4(() => {
      if (!se.current) return;
      let ge = z == null ? void 0 : z.activeElement;
      if (ne != null && ne.current) {
        if ((ne == null ? void 0 : ne.current) === ge) {
          ie.current = ge;
          return;
        }
      } else if (ve.contains(ge)) {
        ie.current = ge;
        return;
      }
      if (ne != null && ne.current) I$2(ne.current);
      else {
        if (B & 16) {
          if (P(ve, F$1.First | F$1.AutoFocus) !== T$1.Error) return;
        } else if (P(ve, F$1.First) !== T$1.Error) return;
        if (oe != null && oe.current && (I$2(oe.current), (z == null ? void 0 : z.activeElement) === oe.current)) return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      ie.current = z == null ? void 0 : z.activeElement;
    });
  }, [oe, ae, B]), ie;
}
function re(B, { ownerDocument: z, container: Y, containers: ne, previousActiveElement: oe }) {
  let ie = f$1(), ae = !!(B & 4);
  E(z == null ? void 0 : z.defaultView, "focus", (se) => {
    if (!ae || !ie.current) return;
    let ve = U$1(ne);
    Y.current instanceof HTMLElement && ve.add(Y.current);
    let ge = oe.current;
    if (!ge) return;
    let le = se.target;
    le && le instanceof HTMLElement ? I(ve, le) ? (oe.current = le, I$2(le)) : (se.preventDefault(), se.stopPropagation(), I$2(ge)) : I$2(oe.current);
  }, !0);
}
function I(B, z) {
  for (let Y of B) if (Y.contains(z)) return !0;
  return !1;
}
function ue(B) {
  var z;
  return !!(B.enter || B.enterFrom || B.enterTo || B.leave || B.leaveFrom || B.leaveTo) || ((z = B.as) != null ? z : de) !== Fragment || React__default.Children.count(B.children) === 1;
}
let w$1 = createContext(null);
w$1.displayName = "TransitionContext";
var _e = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(_e || {});
function De() {
  let B = useContext(w$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function He$1() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: z }) => z.current !== null).filter(({ state: z }) => z === "visible").length > 0;
}
function Te(B, z) {
  let Y = s$7(B), ne = useRef([]), oe = f$1(), ie = p$2(), ae = o$4((Pe, Xe = A$1.Hidden) => {
    let ht = ne.current.findIndex(({ el: wt }) => wt === Pe);
    ht !== -1 && (u$7(Xe, { [A$1.Unmount]() {
      ne.current.splice(ht, 1);
    }, [A$1.Hidden]() {
      ne.current[ht].state = "hidden";
    } }), ie.microTask(() => {
      var wt;
      !U(ne) && oe.current && ((wt = Y.current) == null || wt.call(Y));
    }));
  }), se = o$4((Pe) => {
    let Xe = ne.current.find(({ el: ht }) => ht === Pe);
    return Xe ? Xe.state !== "visible" && (Xe.state = "visible") : ne.current.push({ el: Pe, state: "visible" }), () => ae(Pe, A$1.Unmount);
  }), ve = useRef([]), ge = useRef(Promise.resolve()), le = useRef({ enter: [], leave: [] }), Ee = o$4((Pe, Xe, ht) => {
    ve.current.splice(0), z && (z.chains.current[Xe] = z.chains.current[Xe].filter(([wt]) => wt !== Pe)), z == null || z.chains.current[Xe].push([Pe, new Promise((wt) => {
      ve.current.push(wt);
    })]), z == null || z.chains.current[Xe].push([Pe, new Promise((wt) => {
      Promise.all(le.current[Xe].map(([Pt, vt]) => vt)).then(() => wt());
    })]), Xe === "enter" ? ge.current = ge.current.then(() => z == null ? void 0 : z.wait.current).then(() => ht(Xe)) : ht(Xe);
  }), Ce = o$4((Pe, Xe, ht) => {
    Promise.all(le.current[Xe].splice(0).map(([wt, Pt]) => Pt)).then(() => {
      var wt;
      (wt = ve.current.shift()) == null || wt();
    }).then(() => ht(Xe));
  });
  return useMemo(() => ({ children: ne, register: se, unregister: ae, onStart: Ee, onStop: Ce, wait: ge, chains: le }), [se, ae, ne, Ee, Ce, le, ge]);
}
let de = Fragment, fe = O$3.RenderStrategy;
function Ae(B, z) {
  var Y, ne;
  let { transition: oe = !0, beforeEnter: ie, afterEnter: ae, beforeLeave: se, afterLeave: ve, enter: ge, enterFrom: le, enterTo: Ee, entered: Ce, leave: Pe, leaveFrom: Xe, leaveTo: ht, ...wt } = B, [Pt, vt] = useState(null), Bt = useRef(null), Ct = ue(B), Wt = y$4(...Ct ? [Bt, z, vt] : z === null ? [] : [z]), Kt = (Y = wt.unmount) == null || Y ? A$1.Unmount : A$1.Hidden, { show: Yt, appear: Ut, initial: qt } = De(), [zt, Ft] = useState(Yt ? "visible" : "hidden"), Ve = He$1(), { register: Je, unregister: Ke } = Ve;
  n$3(() => Je(Bt), [Je, Bt]), n$3(() => {
    if (Kt === A$1.Hidden && Bt.current) {
      if (Yt && zt !== "visible") {
        Ft("visible");
        return;
      }
      return u$7(zt, { hidden: () => Ke(Bt), visible: () => Je(Bt) });
    }
  }, [zt, Bt, Je, Ke, Yt, Kt]);
  let Qe = l$1();
  n$3(() => {
    if (Ct && Qe && zt === "visible" && Bt.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [Bt, zt, Qe, Ct]);
  let bt = qt && !Ut, _t = Ut && Yt && qt, $t = useRef(!1), kt = Te(() => {
    $t.current || (Ft("hidden"), Ke(Bt));
  }, Ve), xt = o$4((Vt) => {
    $t.current = !0;
    let Xt = Vt ? "enter" : "leave";
    kt.onStart(Bt, Xt, (sr) => {
      sr === "enter" ? ie == null || ie() : sr === "leave" && (se == null || se());
    });
  }), Nt = o$4((Vt) => {
    let Xt = Vt ? "enter" : "leave";
    $t.current = !1, kt.onStop(Bt, Xt, (sr) => {
      sr === "enter" ? ae == null || ae() : sr === "leave" && (ve == null || ve());
    }), Xt === "leave" && !U(kt) && (Ft("hidden"), Ke(Bt));
  });
  useEffect(() => {
    Ct && oe || (xt(Yt), Nt(Yt));
  }, [Yt, Ct, oe]);
  let Rt = !(!oe || !Ct || !Qe || bt), [, Ht] = x$2(Rt, Pt, Yt, { start: xt, end: Nt }), ar = m$4({ ref: Wt, className: ((ne = t$3(wt.className, _t && ge, _t && le, Ht.enter && ge, Ht.enter && Ht.closed && le, Ht.enter && !Ht.closed && Ee, Ht.leave && Pe, Ht.leave && !Ht.closed && Xe, Ht.leave && Ht.closed && ht, !Ht.transition && Yt && Ce)) == null ? void 0 : ne.trim()) || void 0, ...R$1(Ht) }), lr = 0;
  zt === "visible" && (lr |= i$3.Open), zt === "hidden" && (lr |= i$3.Closed), Ht.enter && (lr |= i$3.Opening), Ht.leave && (lr |= i$3.Closing);
  let nr = L$1();
  return React__default.createElement(M.Provider, { value: kt }, React__default.createElement(c$2, { value: lr }, nr({ ourProps: ar, theirProps: wt, defaultTag: de, features: fe, visible: zt === "visible", name: "Transition.Child" })));
}
function Ie$1(B, z) {
  let { show: Y, appear: ne = !1, unmount: oe = !0, ...ie } = B, ae = useRef(null), se = ue(B), ve = y$4(...se ? [ae, z] : z === null ? [] : [z]);
  l$1();
  let ge = u$2();
  if (Y === void 0 && ge !== null && (Y = (ge & i$3.Open) === i$3.Open), Y === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [le, Ee] = useState(Y ? "visible" : "hidden"), Ce = Te(() => {
    Y || Ee("hidden");
  }), [Pe, Xe] = useState(!0), ht = useRef([Y]);
  n$3(() => {
    Pe !== !1 && ht.current[ht.current.length - 1] !== Y && (ht.current.push(Y), Xe(!1));
  }, [ht, Y]);
  let wt = useMemo(() => ({ show: Y, appear: ne, initial: Pe }), [Y, ne, Pe]);
  n$3(() => {
    Y ? Ee("visible") : !U(Ce) && ae.current !== null && Ee("hidden");
  }, [Y, Ce]);
  let Pt = { unmount: oe }, vt = o$4(() => {
    var Wt;
    Pe && Xe(!1), (Wt = B.beforeEnter) == null || Wt.call(B);
  }), Bt = o$4(() => {
    var Wt;
    Pe && Xe(!1), (Wt = B.beforeLeave) == null || Wt.call(B);
  }), Ct = L$1();
  return React__default.createElement(M.Provider, { value: Ce }, React__default.createElement(w$1.Provider, { value: wt }, Ct({ ourProps: { ...Pt, as: Fragment, children: React__default.createElement(me, { ref: ve, ...Pt, ...ie, beforeEnter: vt, beforeLeave: Bt }) }, theirProps: {}, defaultTag: Fragment, features: fe, visible: le === "visible", name: "Transition" })));
}
function Le(B, z) {
  let Y = useContext(w$1) !== null, ne = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !Y && ne ? React__default.createElement(X, { ref: z, ...B }) : React__default.createElement(me, { ref: z, ...B }));
}
let X = K$1(Ie$1), me = K$1(Ae), Fe = K$1(Le), ze$1 = Object.assign(X, { Child: Fe, Root: X });
var Oe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Oe || {}), he = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(he || {});
let Se = { 0(B, z) {
  return B.titleId === z.id ? B : { ...B, titleId: z.id };
} }, k$1 = createContext(null);
k$1.displayName = "DialogContext";
function O(B) {
  let z = useContext(k$1);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, O), Y;
  }
  return z;
}
function Ie(B, z) {
  return u$7(z.type, Se, B, z);
}
let V = K$1(function(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-${Y}`, open: oe, onClose: ie, initialFocus: ae, role: se = "dialog", autoFocus: ve = !0, __demoMode: ge = !1, unmount: le = !1, ...Ee } = B, Ce = useRef(!1);
  se = function() {
    return se === "dialog" || se === "alertdialog" ? se : (Ce.current || (Ce.current = !0, console.warn(`Invalid role [${se}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Pe = u$2();
  oe === void 0 && Pe !== null && (oe = (Pe & i$3.Open) === i$3.Open);
  let Xe = useRef(null), ht = y$4(Xe, z), wt = n$1(Xe), Pt = oe ? 0 : 1, [vt, Bt] = useReducer(Ie, { titleId: null, descriptionId: null, panelRef: createRef() }), Ct = o$4(() => ie(!1)), Wt = o$4((Nt) => Bt({ type: 0, id: Nt })), Kt = l$1() ? Pt === 0 : !1, [Yt, Ut] = te$1(), qt = { get current() {
    var Nt;
    return (Nt = vt.panelRef.current) != null ? Nt : Xe.current;
  } }, zt = b(), { resolveContainers: Ft } = R({ mainTreeNode: zt, portals: Yt, defaultContainers: [qt] }), Ve = Pe !== null ? (Pe & i$3.Closing) === i$3.Closing : !1;
  y$3(ge || Ve ? !1 : Kt, { allowed: o$4(() => {
    var Nt, Rt;
    return [(Rt = (Nt = Xe.current) == null ? void 0 : Nt.closest("[data-headlessui-portal]")) != null ? Rt : null];
  }), disallowed: o$4(() => {
    var Nt;
    return [(Nt = zt == null ? void 0 : zt.closest("body > *:not(#headlessui-portal-root)")) != null ? Nt : null];
  }) }), R$2(Kt, Ft, (Nt) => {
    Nt.preventDefault(), Ct();
  }), a$3(Kt, wt == null ? void 0 : wt.defaultView, (Nt) => {
    Nt.preventDefault(), Nt.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), Ct();
  }), f$4(ge || Ve ? !1 : Kt, wt, Ft), m$2(Kt, Xe, Ct);
  let [Je, Ke] = w$4(), Qe = useMemo(() => [{ dialogState: Pt, close: Ct, setTitleId: Wt, unmount: le }, vt], [Pt, vt, Ct, Wt, le]), bt = useMemo(() => ({ open: Pt === 0 }), [Pt]), _t = { ref: ht, id: ne, role: se, tabIndex: -1, "aria-modal": ge ? void 0 : Pt === 0 ? !0 : void 0, "aria-labelledby": vt.titleId, "aria-describedby": Je, unmount: le }, $t = !f$2(), kt = x$1.None;
  Kt && !ge && (kt |= x$1.RestoreFocus, kt |= x$1.TabLock, ve && (kt |= x$1.AutoFocus), $t && (kt |= x$1.InitialFocus));
  let xt = L$1();
  return React__default.createElement(s$4, null, React__default.createElement(l, { force: !0 }, React__default.createElement(re$1, null, React__default.createElement(k$1.Provider, { value: Qe }, React__default.createElement(X$1, { target: Xe }, React__default.createElement(l, { force: !1 }, React__default.createElement(Ke, { slot: bt }, React__default.createElement(Ut, null, React__default.createElement(ye, { initialFocus: ae, initialFocusFallback: Xe, containers: Ft, features: kt }, React__default.createElement(C$1, { value: Ct }, xt({ ourProps: _t, theirProps: Ee, slot: bt, defaultTag: Me, features: Ge, visible: Pt === 0, name: "Dialog" })))))))))));
}), Me = "div", Ge = O$3.RenderStrategy | O$3.Static;
function ke(B, z) {
  let { transition: Y = !1, open: ne, ...oe } = B, ie = u$2(), ae = B.hasOwnProperty("open") || ie !== null, se = B.hasOwnProperty("onClose");
  if (!ae && !se) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!ae) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!se) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!ie && typeof B.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${B.open}`);
  if (typeof B.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${B.onClose}`);
  return (ne !== void 0 || Y) && !oe.static ? React__default.createElement(O$1, null, React__default.createElement(ze$1, { show: ne, transition: Y, unmount: oe.unmount }, React__default.createElement(V, { ref: z, ...oe }))) : React__default.createElement(O$1, null, React__default.createElement(V, { ref: z, open: ne, ...oe }));
}
let we = "div";
function Be(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-panel-${Y}`, transition: oe = !1, ...ie } = B, [{ dialogState: ae, unmount: se }, ve] = O("Dialog.Panel"), ge = y$4(z, ve.panelRef), le = useMemo(() => ({ open: ae === 0 }), [ae]), Ee = o$4((wt) => {
    wt.stopPropagation();
  }), Ce = { ref: ge, id: ne, onClick: Ee }, Pe = oe ? Fe : Fragment, Xe = oe ? { unmount: se } : {}, ht = L$1();
  return React__default.createElement(Pe, { ...Xe }, ht({ ourProps: Ce, theirProps: ie, slot: le, defaultTag: we, name: "Dialog.Panel" }));
}
let Ue = "div";
function He(B, z) {
  let { transition: Y = !1, ...ne } = B, [{ dialogState: oe, unmount: ie }] = O("Dialog.Backdrop"), ae = useMemo(() => ({ open: oe === 0 }), [oe]), se = { ref: z, "aria-hidden": !0 }, ve = Y ? Fe : Fragment, ge = Y ? { unmount: ie } : {}, le = L$1();
  return React__default.createElement(ve, { ...ge }, le({ ourProps: se, theirProps: ne, slot: ae, defaultTag: Ue, name: "Dialog.Backdrop" }));
}
let Ne = "h2";
function We(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-dialog-title-${Y}`, ...oe } = B, [{ dialogState: ie, setTitleId: ae }] = O("Dialog.Title"), se = y$4(z);
  useEffect(() => (ae(ne), () => ae(null)), [ne, ae]);
  let ve = useMemo(() => ({ open: ie === 0 }), [ie]), ge = { ref: se, id: ne };
  return L$1()({ ourProps: ge, theirProps: oe, slot: ve, defaultTag: Ne, name: "Dialog.Title" });
}
let $e = K$1(ke), je = K$1(Be);
K$1(He);
let Ye$1 = K$1(We), yt$1 = Object.assign($e, { Panel: je, Title: Ye$1, Description: H$2 });
function s$2(B, z) {
  let Y = useRef({ left: 0, top: 0 });
  if (n$3(() => {
    if (!z) return;
    let oe = z.getBoundingClientRect();
    oe && (Y.current = oe);
  }, [B, z]), z == null || !B || z === document.activeElement) return !1;
  let ne = z.getBoundingClientRect();
  return ne.top !== Y.current.top || ne.left !== Y.current.left;
}
let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var z, Y;
  let ne = (z = B.innerText) != null ? z : "", oe = B.cloneNode(!0);
  if (!(oe instanceof HTMLElement)) return ne;
  let ie = !1;
  for (let se of oe.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) se.remove(), ie = !0;
  let ae = ie ? (Y = oe.innerText) != null ? Y : "" : ne;
  return a.test(ae) && (ae = ae.replace(a, "")), ae;
}
function g(B) {
  let z = B.getAttribute("aria-label");
  if (typeof z == "string") return z.trim();
  let Y = B.getAttribute("aria-labelledby");
  if (Y) {
    let ne = Y.split(" ").map((oe) => {
      let ie = document.getElementById(oe);
      if (ie) {
        let ae = ie.getAttribute("aria-label");
        return typeof ae == "string" ? ae.trim() : o$1(ie).trim();
      }
      return null;
    }).filter(Boolean);
    if (ne.length > 0) return ne.join(", ");
  }
  return o$1(B).trim();
}
function s$1(B) {
  let z = useRef(""), Y = useRef("");
  return o$4(() => {
    let ne = B.current;
    if (!ne) return "";
    let oe = ne.innerText;
    if (z.current === oe) return Y.current;
    let ie = g(ne).trim().toLowerCase();
    return z.current = oe, Y.current = ie, ie;
  });
}
var qe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(qe || {}), ze = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(ze || {}), Ye = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B[B.SetButtonElement = 7] = "SetButtonElement", B[B.SetItemsElement = 8] = "SetItemsElement", B))(Ye || {});
function j(B, z = (Y) => Y) {
  let Y = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, ne = _(z(B.items.slice()), (ie) => ie.dataRef.current.domRef.current), oe = Y ? ne.indexOf(Y) : null;
  return oe === -1 && (oe = null), { items: ne, activeItemIndex: oe };
}
let Ze = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, z) => {
  var Y, ne, oe, ie, ae;
  if (B.menuState === 1) return B;
  let se = { ...B, searchQuery: "", activationTrigger: (Y = z.trigger) != null ? Y : 1, __demoMode: !1 };
  if (z.focus === c$1.Nothing) return { ...se, activeItemIndex: null };
  if (z.focus === c$1.Specific) return { ...se, activeItemIndex: B.items.findIndex((le) => le.id === z.id) };
  if (z.focus === c$1.Previous) {
    let le = B.activeItemIndex;
    if (le !== null) {
      let Ee = B.items[le].dataRef.current.domRef, Ce = f$3(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Pe) => Pe.id, resolveDisabled: (Pe) => Pe.dataRef.current.disabled });
      if (Ce !== null) {
        let Pe = B.items[Ce].dataRef.current.domRef;
        if (((ne = Ee.current) == null ? void 0 : ne.previousElementSibling) === Pe.current || ((oe = Pe.current) == null ? void 0 : oe.previousElementSibling) === null) return { ...se, activeItemIndex: Ce };
      }
    }
  } else if (z.focus === c$1.Next) {
    let le = B.activeItemIndex;
    if (le !== null) {
      let Ee = B.items[le].dataRef.current.domRef, Ce = f$3(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Pe) => Pe.id, resolveDisabled: (Pe) => Pe.dataRef.current.disabled });
      if (Ce !== null) {
        let Pe = B.items[Ce].dataRef.current.domRef;
        if (((ie = Ee.current) == null ? void 0 : ie.nextElementSibling) === Pe.current || ((ae = Pe.current) == null ? void 0 : ae.nextElementSibling) === null) return { ...se, activeItemIndex: Ce };
      }
    }
  }
  let ve = j(B), ge = f$3(z, { resolveItems: () => ve.items, resolveActiveIndex: () => ve.activeItemIndex, resolveId: (le) => le.id, resolveDisabled: (le) => le.dataRef.current.disabled });
  return { ...se, ...ve, activeItemIndex: ge };
}, 3: (B, z) => {
  let Y = B.searchQuery !== "" ? 0 : 1, ne = B.searchQuery + z.value.toLowerCase(), oe = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + Y).concat(B.items.slice(0, B.activeItemIndex + Y)) : B.items).find((ae) => {
    var se;
    return ((se = ae.dataRef.current.textValue) == null ? void 0 : se.startsWith(ne)) && !ae.dataRef.current.disabled;
  }), ie = oe ? B.items.indexOf(oe) : -1;
  return ie === -1 || ie === B.activeItemIndex ? { ...B, searchQuery: ne } : { ...B, searchQuery: ne, activeItemIndex: ie, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, z) => {
  let Y = j(B, (ne) => [...ne, { id: z.id, dataRef: z.dataRef }]);
  return { ...B, ...Y };
}, 6: (B, z) => {
  let Y = j(B, (ne) => {
    let oe = ne.findIndex((ie) => ie.id === z.id);
    return oe !== -1 && ne.splice(oe, 1), ne;
  });
  return { ...B, ...Y, activationTrigger: 1 };
}, 7: (B, z) => B.buttonElement === z.element ? B : { ...B, buttonElement: z.element }, 8: (B, z) => B.itemsElement === z.element ? B : { ...B, itemsElement: z.element } }, Q = createContext(null);
Q.displayName = "MenuContext";
function w(B) {
  let z = useContext(Q);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, w), Y;
  }
  return z;
}
function et(B, z) {
  return u$7(z.type, Ze, B, z);
}
let tt = Fragment;
function nt(B, z) {
  let { __demoMode: Y = !1, ...ne } = B, oe = useReducer(et, { __demoMode: Y, menuState: Y ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: ie, itemsElement: ae, buttonElement: se }, ve] = oe, ge = y$4(z);
  R$2(ie === 0, [se, ae], (Xe, ht) => {
    ve({ type: 1 }), A(ht, h$2.Loose) || (Xe.preventDefault(), se == null || se.focus());
  });
  let le = o$4(() => {
    ve({ type: 1 });
  }), Ee = useMemo(() => ({ open: ie === 0, close: le }), [ie, le]), Ce = { ref: ge }, Pe = L$1();
  return React__default.createElement(Me$1, null, React__default.createElement(Q.Provider, { value: oe }, React__default.createElement(c$2, { value: u$7(ie, { 0: i$3.Open, 1: i$3.Closed }) }, Pe({ ourProps: Ce, theirProps: ne, slot: Ee, defaultTag: tt, name: "Menu" }))));
}
let rt = "button";
function ot(B, z) {
  var Y;
  let ne = useId$1(), { id: oe = `headlessui-menu-button-${ne}`, disabled: ie = !1, autoFocus: ae = !1, ...se } = B, [ve, ge] = w("Menu.Button"), le = Fe$1(), Ee = y$4(z, ye$1(), o$4((Yt) => ge({ type: 7, element: Yt }))), Ce = o$4((Yt) => {
    switch (Yt.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        Yt.preventDefault(), Yt.stopPropagation(), flushSync(() => ge({ type: 0 })), ge({ type: 2, focus: c$1.First });
        break;
      case o$3.ArrowUp:
        Yt.preventDefault(), Yt.stopPropagation(), flushSync(() => ge({ type: 0 })), ge({ type: 2, focus: c$1.Last });
        break;
    }
  }), Pe = o$4((Yt) => {
    switch (Yt.key) {
      case o$3.Space:
        Yt.preventDefault();
        break;
    }
  }), Xe = o$4((Yt) => {
    var Ut;
    if (r$3(Yt.currentTarget)) return Yt.preventDefault();
    ie || (ve.menuState === 0 ? (flushSync(() => ge({ type: 1 })), (Ut = ve.buttonElement) == null || Ut.focus({ preventScroll: !0 })) : (Yt.preventDefault(), ge({ type: 0 })));
  }), { isFocusVisible: ht, focusProps: wt } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: ae }), { isHovered: Pt, hoverProps: vt } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: ie }), { pressed: Bt, pressProps: Ct } = w$5({ disabled: ie }), Wt = useMemo(() => ({ open: ve.menuState === 0, active: Bt || ve.menuState === 0, disabled: ie, hover: Pt, focus: ht, autofocus: ae }), [ve, Pt, ht, Bt, ie, ae]), Kt = _$2(le(), { ref: Ee, id: oe, type: e$1(B, ve.buttonElement), "aria-haspopup": "menu", "aria-controls": (Y = ve.itemsElement) == null ? void 0 : Y.id, "aria-expanded": ve.menuState === 0, disabled: ie || void 0, autoFocus: ae, onKeyDown: Ce, onKeyUp: Pe, onClick: Xe }, wt, vt, Ct);
  return L$1()({ ourProps: Kt, theirProps: se, slot: Wt, defaultTag: rt, name: "Menu.Button" });
}
let at = "div", lt = O$3.RenderStrategy | O$3.Static;
function it(B, z) {
  var Y, ne;
  let oe = useId$1(), { id: ie = `headlessui-menu-items-${oe}`, anchor: ae, portal: se = !1, modal: ve = !0, transition: ge = !1, ...le } = B, Ee = xe(ae), [Ce, Pe] = w("Menu.Items"), [Xe, ht] = Re(Ee), wt = be(), [Pt, vt] = useState(null), Bt = y$4(z, Ee ? Xe : null, o$4(($t) => Pe({ type: 8, element: $t })), vt), Ct = n$1(Ce.itemsElement);
  Ee && (se = !0);
  let Wt = u$2(), [Kt, Yt] = x$2(ge, Pt, Wt !== null ? (Wt & i$3.Open) === i$3.Open : Ce.menuState === 0);
  m$2(Kt, Ce.buttonElement, () => {
    Pe({ type: 1 });
  });
  let Ut = Ce.__demoMode ? !1 : ve && Ce.menuState === 0;
  f$4(Ut, Ct);
  let qt = Ce.__demoMode ? !1 : ve && Ce.menuState === 0;
  y$3(qt, { allowed: useCallback(() => [Ce.buttonElement, Ce.itemsElement], [Ce.buttonElement, Ce.itemsElement]) });
  let zt = Ce.menuState !== 0, Ft = s$2(zt, Ce.buttonElement) ? !1 : Kt;
  useEffect(() => {
    let $t = Ce.itemsElement;
    $t && Ce.menuState === 0 && $t !== (Ct == null ? void 0 : Ct.activeElement) && $t.focus({ preventScroll: !0 });
  }, [Ce.menuState, Ce.itemsElement, Ct]), F(Ce.menuState === 0, { container: Ce.itemsElement, accept($t) {
    return $t.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : $t.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk($t) {
    $t.setAttribute("role", "none");
  } });
  let Ve = p$2(), Je = o$4(($t) => {
    var kt, xt, Nt;
    switch (Ve.dispose(), $t.key) {
      case o$3.Space:
        if (Ce.searchQuery !== "") return $t.preventDefault(), $t.stopPropagation(), Pe({ type: 3, value: $t.key });
      case o$3.Enter:
        if ($t.preventDefault(), $t.stopPropagation(), Pe({ type: 1 }), Ce.activeItemIndex !== null) {
          let { dataRef: Rt } = Ce.items[Ce.activeItemIndex];
          (xt = (kt = Rt.current) == null ? void 0 : kt.domRef.current) == null || xt.click();
        }
        G(Ce.buttonElement);
        break;
      case o$3.ArrowDown:
        return $t.preventDefault(), $t.stopPropagation(), Pe({ type: 2, focus: c$1.Next });
      case o$3.ArrowUp:
        return $t.preventDefault(), $t.stopPropagation(), Pe({ type: 2, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return $t.preventDefault(), $t.stopPropagation(), Pe({ type: 2, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return $t.preventDefault(), $t.stopPropagation(), Pe({ type: 2, focus: c$1.Last });
      case o$3.Escape:
        $t.preventDefault(), $t.stopPropagation(), flushSync(() => Pe({ type: 1 })), (Nt = Ce.buttonElement) == null || Nt.focus({ preventScroll: !0 });
        break;
      case o$3.Tab:
        $t.preventDefault(), $t.stopPropagation(), flushSync(() => Pe({ type: 1 })), j$3(Ce.buttonElement, $t.shiftKey ? F$1.Previous : F$1.Next);
        break;
      default:
        $t.key.length === 1 && (Pe({ type: 3, value: $t.key }), Ve.setTimeout(() => Pe({ type: 4 }), 350));
        break;
    }
  }), Ke = o$4(($t) => {
    switch ($t.key) {
      case o$3.Space:
        $t.preventDefault();
        break;
    }
  }), Qe = useMemo(() => ({ open: Ce.menuState === 0 }), [Ce.menuState]), bt = _$2(Ee ? wt() : {}, { "aria-activedescendant": Ce.activeItemIndex === null || (Y = Ce.items[Ce.activeItemIndex]) == null ? void 0 : Y.id, "aria-labelledby": (ne = Ce.buttonElement) == null ? void 0 : ne.id, id: ie, onKeyDown: Je, onKeyUp: Ke, role: "menu", tabIndex: Ce.menuState === 0 ? 0 : void 0, ref: Bt, style: { ...le.style, ...ht, "--button-width": d$2(Ce.buttonElement, !0).width }, ...R$1(Yt) }), _t = L$1();
  return React__default.createElement(re$1, { enabled: se ? B.static || Kt : !1 }, _t({ ourProps: bt, theirProps: le, slot: Qe, defaultTag: at, features: lt, visible: Ft, name: "Menu.Items" }));
}
let st = Fragment;
function ut(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-item-${Y}`, disabled: oe = !1, ...ie } = B, [ae, se] = w("Menu.Item"), ve = ae.activeItemIndex !== null ? ae.items[ae.activeItemIndex].id === ne : !1, ge = useRef(null), le = y$4(z, ge);
  n$3(() => {
    if (!ae.__demoMode && ae.menuState === 0 && ve && ae.activationTrigger !== 0) return o$5().requestAnimationFrame(() => {
      var Ft, Ve;
      (Ve = (Ft = ge.current) == null ? void 0 : Ft.scrollIntoView) == null || Ve.call(Ft, { block: "nearest" });
    });
  }, [ae.__demoMode, ge, ve, ae.menuState, ae.activationTrigger, ae.activeItemIndex]);
  let Ee = s$1(ge), Ce = useRef({ disabled: oe, domRef: ge, get textValue() {
    return Ee();
  } });
  n$3(() => {
    Ce.current.disabled = oe;
  }, [Ce, oe]), n$3(() => (se({ type: 5, id: ne, dataRef: Ce }), () => se({ type: 6, id: ne })), [Ce, ne]);
  let Pe = o$4(() => {
    se({ type: 1 });
  }), Xe = o$4((Ft) => {
    if (oe) return Ft.preventDefault();
    se({ type: 1 }), G(ae.buttonElement);
  }), ht = o$4(() => {
    if (oe) return se({ type: 2, focus: c$1.Nothing });
    se({ type: 2, focus: c$1.Specific, id: ne });
  }), wt = u$3(), Pt = o$4((Ft) => {
    wt.update(Ft), !oe && (ve || se({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), vt = o$4((Ft) => {
    wt.wasMoved(Ft) && (oe || ve || se({ type: 2, focus: c$1.Specific, id: ne, trigger: 0 }));
  }), Bt = o$4((Ft) => {
    wt.wasMoved(Ft) && (oe || ve && se({ type: 2, focus: c$1.Nothing }));
  }), [Ct, Wt] = K(), [Kt, Yt] = w$4(), Ut = useMemo(() => ({ active: ve, focus: ve, disabled: oe, close: Pe }), [ve, oe, Pe]), qt = { id: ne, ref: le, role: "menuitem", tabIndex: oe === !0 ? void 0 : -1, "aria-disabled": oe === !0 ? !0 : void 0, "aria-labelledby": Ct, "aria-describedby": Kt, disabled: void 0, onClick: Xe, onFocus: ht, onPointerEnter: Pt, onMouseEnter: Pt, onPointerMove: vt, onMouseMove: vt, onPointerLeave: Bt, onMouseLeave: Bt }, zt = L$1();
  return React__default.createElement(Wt, null, React__default.createElement(Yt, null, zt({ ourProps: qt, theirProps: ie, slot: Ut, defaultTag: st, name: "Menu.Item" })));
}
let pt = "div";
function mt(B, z) {
  let [Y, ne] = K(), oe = B, ie = { ref: z, "aria-labelledby": Y, role: "group" }, ae = L$1();
  return React__default.createElement(ne, null, ae({ ourProps: ie, theirProps: oe, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
let dt = "header";
function ct(B, z) {
  let Y = useId$1(), { id: ne = `headlessui-menu-heading-${Y}`, ...oe } = B, ie = P$1();
  n$3(() => ie.register(ne), [ne, ie.register]);
  let ae = { id: ne, ref: z, role: "presentation", ...ie.props };
  return L$1()({ ourProps: ae, theirProps: oe, slot: {}, defaultTag: dt, name: "Menu.Heading" });
}
let ft = "div";
function Tt(B, z) {
  let Y = B, ne = { ref: z, role: "separator" };
  return L$1()({ ourProps: ne, theirProps: Y, slot: {}, defaultTag: ft, name: "Menu.Separator" });
}
let yt = K$1(nt), It = K$1(ot), gt = K$1(it), Et = K$1(ut), Mt = K$1(mt), St = K$1(ct), At = K$1(Tt), rn = Object.assign(yt, { Button: It, Items: gt, Item: Et, Section: Mt, Heading: St, Separator: At });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, z = 4, Y = 5) {
  if (B.length <= z + Y)
    return B;
  const ne = B.slice(0, z), oe = B.slice(B.length - Y);
  return `${ne}...${oe}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: z,
  onViewProfile: Y,
  onChangeWallet: ne,
  onDisconnectWallet: oe,
  renderAvatar: ie
}) {
  const { wallet: ae } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    rn,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: se }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            ie ? ie(B, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: B,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[ae],
                alt: `${ae} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[z] ?? z })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${se ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => Y == null ? void 0 : Y(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ne == null ? void 0 : ne(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => oe == null ? void 0 : oe(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: B,
  disabled: z
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: z,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength$1(B) {
  var z = getLens$1(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength$1(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray$1(B) {
  var z, Y = getLens$1(B), ne = Y[0], oe = Y[1], ie = new Arr$1(_byteLength$1(B, ne, oe)), ae = 0, se = oe > 0 ? ne - 4 : ne, ve;
  for (ve = 0; ve < se; ve += 4)
    z = revLookup$1[B.charCodeAt(ve)] << 18 | revLookup$1[B.charCodeAt(ve + 1)] << 12 | revLookup$1[B.charCodeAt(ve + 2)] << 6 | revLookup$1[B.charCodeAt(ve + 3)], ie[ae++] = z >> 16 & 255, ie[ae++] = z >> 8 & 255, ie[ae++] = z & 255;
  return oe === 2 && (z = revLookup$1[B.charCodeAt(ve)] << 2 | revLookup$1[B.charCodeAt(ve + 1)] >> 4, ie[ae++] = z & 255), oe === 1 && (z = revLookup$1[B.charCodeAt(ve)] << 10 | revLookup$1[B.charCodeAt(ve + 1)] << 4 | revLookup$1[B.charCodeAt(ve + 2)] >> 2, ie[ae++] = z >> 8 & 255, ie[ae++] = z & 255), ie;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, z, Y) {
  for (var ne, oe = [], ie = z; ie < Y; ie += 3)
    ne = (B[ie] << 16 & 16711680) + (B[ie + 1] << 8 & 65280) + (B[ie + 2] & 255), oe.push(tripletToBase64$1(ne));
  return oe.join("");
}
function fromByteArray$1(B) {
  for (var z, Y = B.length, ne = Y % 3, oe = [], ie = 16383, ae = 0, se = Y - ne; ae < se; ae += ie)
    oe.push(encodeChunk$1(B, ae, ae + ie > se ? se : ae + ie));
  return ne === 1 ? (z = B[Y - 1], oe.push(
    lookup$1[z >> 2] + lookup$1[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], oe.push(
    lookup$1[z >> 10] + lookup$1[z >> 4 & 63] + lookup$1[z << 2 & 63] + "="
  )), oe.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, z, Y, ne, oe) {
  var ie, ae, se = oe * 8 - ne - 1, ve = (1 << se) - 1, ge = ve >> 1, le = -7, Ee = Y ? oe - 1 : 0, Ce = Y ? -1 : 1, Pe = B[z + Ee];
  for (Ee += Ce, ie = Pe & (1 << -le) - 1, Pe >>= -le, le += se; le > 0; ie = ie * 256 + B[z + Ee], Ee += Ce, le -= 8)
    ;
  for (ae = ie & (1 << -le) - 1, ie >>= -le, le += ne; le > 0; ae = ae * 256 + B[z + Ee], Ee += Ce, le -= 8)
    ;
  if (ie === 0)
    ie = 1 - ge;
  else {
    if (ie === ve)
      return ae ? NaN : (Pe ? -1 : 1) * (1 / 0);
    ae = ae + Math.pow(2, ne), ie = ie - ge;
  }
  return (Pe ? -1 : 1) * ae * Math.pow(2, ie - ne);
};
ieee754.write = function(B, z, Y, ne, oe, ie) {
  var ae, se, ve, ge = ie * 8 - oe - 1, le = (1 << ge) - 1, Ee = le >> 1, Ce = oe === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Pe = ne ? 0 : ie - 1, Xe = ne ? 1 : -1, ht = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
  for (z = Math.abs(z), isNaN(z) || z === 1 / 0 ? (se = isNaN(z) ? 1 : 0, ae = le) : (ae = Math.floor(Math.log(z) / Math.LN2), z * (ve = Math.pow(2, -ae)) < 1 && (ae--, ve *= 2), ae + Ee >= 1 ? z += Ce / ve : z += Ce * Math.pow(2, 1 - Ee), z * ve >= 2 && (ae++, ve /= 2), ae + Ee >= le ? (se = 0, ae = le) : ae + Ee >= 1 ? (se = (z * ve - 1) * Math.pow(2, oe), ae = ae + Ee) : (se = z * Math.pow(2, Ee - 1) * Math.pow(2, oe), ae = 0)); oe >= 8; B[Y + Pe] = se & 255, Pe += Xe, se /= 256, oe -= 8)
    ;
  for (ae = ae << oe | se, ge += oe; ge > 0; B[Y + Pe] = ae & 255, Pe += Xe, ae /= 256, ge -= 8)
    ;
  B[Y + Pe - Xe] |= ht * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const z = base64Js$1, Y = ieee754, ne = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = le, B.SlowBuffer = Wt, B.INSPECT_MAX_BYTES = 50;
  const oe = 2147483647;
  B.kMaxLength = oe;
  const { Uint8Array: ie, ArrayBuffer: ae, SharedArrayBuffer: se } = globalThis;
  le.TYPED_ARRAY_SUPPORT = ve(), !le.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ve() {
    try {
      const Jt = new ie(1), Dt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Dt, ie.prototype), Object.setPrototypeOf(Jt, Dt), Jt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(le.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(le.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (le.isBuffer(this))
        return this.byteOffset;
    }
  });
  function ge(Jt) {
    if (Jt > oe)
      throw new RangeError('The value "' + Jt + '" is invalid for option "size"');
    const Dt = new ie(Jt);
    return Object.setPrototypeOf(Dt, le.prototype), Dt;
  }
  function le(Jt, Dt, Gt) {
    if (typeof Jt == "number") {
      if (typeof Dt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Xe(Jt);
    }
    return Ee(Jt, Dt, Gt);
  }
  le.poolSize = 8192;
  function Ee(Jt, Dt, Gt) {
    if (typeof Jt == "string")
      return ht(Jt, Dt);
    if (ae.isView(Jt))
      return Pt(Jt);
    if (Jt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Jt
      );
    if (Hr(Jt, ae) || Jt && Hr(Jt.buffer, ae) || typeof se < "u" && (Hr(Jt, se) || Jt && Hr(Jt.buffer, se)))
      return vt(Jt, Dt, Gt);
    if (typeof Jt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const rr = Jt.valueOf && Jt.valueOf();
    if (rr != null && rr !== Jt)
      return le.from(rr, Dt, Gt);
    const cr = Bt(Jt);
    if (cr) return cr;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Jt[Symbol.toPrimitive] == "function")
      return le.from(Jt[Symbol.toPrimitive]("string"), Dt, Gt);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Jt
    );
  }
  le.from = function(Jt, Dt, Gt) {
    return Ee(Jt, Dt, Gt);
  }, Object.setPrototypeOf(le.prototype, ie.prototype), Object.setPrototypeOf(le, ie);
  function Ce(Jt) {
    if (typeof Jt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Jt < 0)
      throw new RangeError('The value "' + Jt + '" is invalid for option "size"');
  }
  function Pe(Jt, Dt, Gt) {
    return Ce(Jt), Jt <= 0 ? ge(Jt) : Dt !== void 0 ? typeof Gt == "string" ? ge(Jt).fill(Dt, Gt) : ge(Jt).fill(Dt) : ge(Jt);
  }
  le.alloc = function(Jt, Dt, Gt) {
    return Pe(Jt, Dt, Gt);
  };
  function Xe(Jt) {
    return Ce(Jt), ge(Jt < 0 ? 0 : Ct(Jt) | 0);
  }
  le.allocUnsafe = function(Jt) {
    return Xe(Jt);
  }, le.allocUnsafeSlow = function(Jt) {
    return Xe(Jt);
  };
  function ht(Jt, Dt) {
    if ((typeof Dt != "string" || Dt === "") && (Dt = "utf8"), !le.isEncoding(Dt))
      throw new TypeError("Unknown encoding: " + Dt);
    const Gt = Kt(Jt, Dt) | 0;
    let rr = ge(Gt);
    const cr = rr.write(Jt, Dt);
    return cr !== Gt && (rr = rr.slice(0, cr)), rr;
  }
  function wt(Jt) {
    const Dt = Jt.length < 0 ? 0 : Ct(Jt.length) | 0, Gt = ge(Dt);
    for (let rr = 0; rr < Dt; rr += 1)
      Gt[rr] = Jt[rr] & 255;
    return Gt;
  }
  function Pt(Jt) {
    if (Hr(Jt, ie)) {
      const Dt = new ie(Jt);
      return vt(Dt.buffer, Dt.byteOffset, Dt.byteLength);
    }
    return wt(Jt);
  }
  function vt(Jt, Dt, Gt) {
    if (Dt < 0 || Jt.byteLength < Dt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Jt.byteLength < Dt + (Gt || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let rr;
    return Dt === void 0 && Gt === void 0 ? rr = new ie(Jt) : Gt === void 0 ? rr = new ie(Jt, Dt) : rr = new ie(Jt, Dt, Gt), Object.setPrototypeOf(rr, le.prototype), rr;
  }
  function Bt(Jt) {
    if (le.isBuffer(Jt)) {
      const Dt = Ct(Jt.length) | 0, Gt = ge(Dt);
      return Gt.length === 0 || Jt.copy(Gt, 0, 0, Dt), Gt;
    }
    if (Jt.length !== void 0)
      return typeof Jt.length != "number" || Yr(Jt.length) ? ge(0) : wt(Jt);
    if (Jt.type === "Buffer" && Array.isArray(Jt.data))
      return wt(Jt.data);
  }
  function Ct(Jt) {
    if (Jt >= oe)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + oe.toString(16) + " bytes");
    return Jt | 0;
  }
  function Wt(Jt) {
    return +Jt != Jt && (Jt = 0), le.alloc(+Jt);
  }
  le.isBuffer = function(Dt) {
    return Dt != null && Dt._isBuffer === !0 && Dt !== le.prototype;
  }, le.compare = function(Dt, Gt) {
    if (Hr(Dt, ie) && (Dt = le.from(Dt, Dt.offset, Dt.byteLength)), Hr(Gt, ie) && (Gt = le.from(Gt, Gt.offset, Gt.byteLength)), !le.isBuffer(Dt) || !le.isBuffer(Gt))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Dt === Gt) return 0;
    let rr = Dt.length, cr = Gt.length;
    for (let br = 0, gr = Math.min(rr, cr); br < gr; ++br)
      if (Dt[br] !== Gt[br]) {
        rr = Dt[br], cr = Gt[br];
        break;
      }
    return rr < cr ? -1 : cr < rr ? 1 : 0;
  }, le.isEncoding = function(Dt) {
    switch (String(Dt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, le.concat = function(Dt, Gt) {
    if (!Array.isArray(Dt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Dt.length === 0)
      return le.alloc(0);
    let rr;
    if (Gt === void 0)
      for (Gt = 0, rr = 0; rr < Dt.length; ++rr)
        Gt += Dt[rr].length;
    const cr = le.allocUnsafe(Gt);
    let br = 0;
    for (rr = 0; rr < Dt.length; ++rr) {
      let gr = Dt[rr];
      if (Hr(gr, ie))
        br + gr.length > cr.length ? (le.isBuffer(gr) || (gr = le.from(gr)), gr.copy(cr, br)) : ie.prototype.set.call(
          cr,
          gr,
          br
        );
      else if (le.isBuffer(gr))
        gr.copy(cr, br);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      br += gr.length;
    }
    return cr;
  };
  function Kt(Jt, Dt) {
    if (le.isBuffer(Jt))
      return Jt.length;
    if (ae.isView(Jt) || Hr(Jt, ae))
      return Jt.byteLength;
    if (typeof Jt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Jt
      );
    const Gt = Jt.length, rr = arguments.length > 2 && arguments[2] === !0;
    if (!rr && Gt === 0) return 0;
    let cr = !1;
    for (; ; )
      switch (Dt) {
        case "ascii":
        case "latin1":
        case "binary":
          return Gt;
        case "utf8":
        case "utf-8":
          return Gr(Jt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Gt * 2;
        case "hex":
          return Gt >>> 1;
        case "base64":
          return Cr(Jt).length;
        default:
          if (cr)
            return rr ? -1 : Gr(Jt).length;
          Dt = ("" + Dt).toLowerCase(), cr = !0;
      }
  }
  le.byteLength = Kt;
  function Yt(Jt, Dt, Gt) {
    let rr = !1;
    if ((Dt === void 0 || Dt < 0) && (Dt = 0), Dt > this.length || ((Gt === void 0 || Gt > this.length) && (Gt = this.length), Gt <= 0) || (Gt >>>= 0, Dt >>>= 0, Gt <= Dt))
      return "";
    for (Jt || (Jt = "utf8"); ; )
      switch (Jt) {
        case "hex":
          return Rt(this, Dt, Gt);
        case "utf8":
        case "utf-8":
          return _t(this, Dt, Gt);
        case "ascii":
          return xt(this, Dt, Gt);
        case "latin1":
        case "binary":
          return Nt(this, Dt, Gt);
        case "base64":
          return bt(this, Dt, Gt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ht(this, Dt, Gt);
        default:
          if (rr) throw new TypeError("Unknown encoding: " + Jt);
          Jt = (Jt + "").toLowerCase(), rr = !0;
      }
  }
  le.prototype._isBuffer = !0;
  function Ut(Jt, Dt, Gt) {
    const rr = Jt[Dt];
    Jt[Dt] = Jt[Gt], Jt[Gt] = rr;
  }
  le.prototype.swap16 = function() {
    const Dt = this.length;
    if (Dt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Gt = 0; Gt < Dt; Gt += 2)
      Ut(this, Gt, Gt + 1);
    return this;
  }, le.prototype.swap32 = function() {
    const Dt = this.length;
    if (Dt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Gt = 0; Gt < Dt; Gt += 4)
      Ut(this, Gt, Gt + 3), Ut(this, Gt + 1, Gt + 2);
    return this;
  }, le.prototype.swap64 = function() {
    const Dt = this.length;
    if (Dt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Gt = 0; Gt < Dt; Gt += 8)
      Ut(this, Gt, Gt + 7), Ut(this, Gt + 1, Gt + 6), Ut(this, Gt + 2, Gt + 5), Ut(this, Gt + 3, Gt + 4);
    return this;
  }, le.prototype.toString = function() {
    const Dt = this.length;
    return Dt === 0 ? "" : arguments.length === 0 ? _t(this, 0, Dt) : Yt.apply(this, arguments);
  }, le.prototype.toLocaleString = le.prototype.toString, le.prototype.equals = function(Dt) {
    if (!le.isBuffer(Dt)) throw new TypeError("Argument must be a Buffer");
    return this === Dt ? !0 : le.compare(this, Dt) === 0;
  }, le.prototype.inspect = function() {
    let Dt = "";
    const Gt = B.INSPECT_MAX_BYTES;
    return Dt = this.toString("hex", 0, Gt).replace(/(.{2})/g, "$1 ").trim(), this.length > Gt && (Dt += " ... "), "<Buffer " + Dt + ">";
  }, ne && (le.prototype[ne] = le.prototype.inspect), le.prototype.compare = function(Dt, Gt, rr, cr, br) {
    if (Hr(Dt, ie) && (Dt = le.from(Dt, Dt.offset, Dt.byteLength)), !le.isBuffer(Dt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Dt
      );
    if (Gt === void 0 && (Gt = 0), rr === void 0 && (rr = Dt ? Dt.length : 0), cr === void 0 && (cr = 0), br === void 0 && (br = this.length), Gt < 0 || rr > Dt.length || cr < 0 || br > this.length)
      throw new RangeError("out of range index");
    if (cr >= br && Gt >= rr)
      return 0;
    if (cr >= br)
      return -1;
    if (Gt >= rr)
      return 1;
    if (Gt >>>= 0, rr >>>= 0, cr >>>= 0, br >>>= 0, this === Dt) return 0;
    let gr = br - cr, Or = rr - Gt;
    const Wr = Math.min(gr, Or), kr = this.slice(cr, br), jr = Dt.slice(Gt, rr);
    for (let Lr = 0; Lr < Wr; ++Lr)
      if (kr[Lr] !== jr[Lr]) {
        gr = kr[Lr], Or = jr[Lr];
        break;
      }
    return gr < Or ? -1 : Or < gr ? 1 : 0;
  };
  function qt(Jt, Dt, Gt, rr, cr) {
    if (Jt.length === 0) return -1;
    if (typeof Gt == "string" ? (rr = Gt, Gt = 0) : Gt > 2147483647 ? Gt = 2147483647 : Gt < -2147483648 && (Gt = -2147483648), Gt = +Gt, Yr(Gt) && (Gt = cr ? 0 : Jt.length - 1), Gt < 0 && (Gt = Jt.length + Gt), Gt >= Jt.length) {
      if (cr) return -1;
      Gt = Jt.length - 1;
    } else if (Gt < 0)
      if (cr) Gt = 0;
      else return -1;
    if (typeof Dt == "string" && (Dt = le.from(Dt, rr)), le.isBuffer(Dt))
      return Dt.length === 0 ? -1 : zt(Jt, Dt, Gt, rr, cr);
    if (typeof Dt == "number")
      return Dt = Dt & 255, typeof ie.prototype.indexOf == "function" ? cr ? ie.prototype.indexOf.call(Jt, Dt, Gt) : ie.prototype.lastIndexOf.call(Jt, Dt, Gt) : zt(Jt, [Dt], Gt, rr, cr);
    throw new TypeError("val must be string, number or Buffer");
  }
  function zt(Jt, Dt, Gt, rr, cr) {
    let br = 1, gr = Jt.length, Or = Dt.length;
    if (rr !== void 0 && (rr = String(rr).toLowerCase(), rr === "ucs2" || rr === "ucs-2" || rr === "utf16le" || rr === "utf-16le")) {
      if (Jt.length < 2 || Dt.length < 2)
        return -1;
      br = 2, gr /= 2, Or /= 2, Gt /= 2;
    }
    function Wr(jr, Lr) {
      return br === 1 ? jr[Lr] : jr.readUInt16BE(Lr * br);
    }
    let kr;
    if (cr) {
      let jr = -1;
      for (kr = Gt; kr < gr; kr++)
        if (Wr(Jt, kr) === Wr(Dt, jr === -1 ? 0 : kr - jr)) {
          if (jr === -1 && (jr = kr), kr - jr + 1 === Or) return jr * br;
        } else
          jr !== -1 && (kr -= kr - jr), jr = -1;
    } else
      for (Gt + Or > gr && (Gt = gr - Or), kr = Gt; kr >= 0; kr--) {
        let jr = !0;
        for (let Lr = 0; Lr < Or; Lr++)
          if (Wr(Jt, kr + Lr) !== Wr(Dt, Lr)) {
            jr = !1;
            break;
          }
        if (jr) return kr;
      }
    return -1;
  }
  le.prototype.includes = function(Dt, Gt, rr) {
    return this.indexOf(Dt, Gt, rr) !== -1;
  }, le.prototype.indexOf = function(Dt, Gt, rr) {
    return qt(this, Dt, Gt, rr, !0);
  }, le.prototype.lastIndexOf = function(Dt, Gt, rr) {
    return qt(this, Dt, Gt, rr, !1);
  };
  function Ft(Jt, Dt, Gt, rr) {
    Gt = Number(Gt) || 0;
    const cr = Jt.length - Gt;
    rr ? (rr = Number(rr), rr > cr && (rr = cr)) : rr = cr;
    const br = Dt.length;
    rr > br / 2 && (rr = br / 2);
    let gr;
    for (gr = 0; gr < rr; ++gr) {
      const Or = parseInt(Dt.substr(gr * 2, 2), 16);
      if (Yr(Or)) return gr;
      Jt[Gt + gr] = Or;
    }
    return gr;
  }
  function Ve(Jt, Dt, Gt, rr) {
    return Tr(Gr(Dt, Jt.length - Gt), Jt, Gt, rr);
  }
  function Je(Jt, Dt, Gt, rr) {
    return Tr(Pr(Dt), Jt, Gt, rr);
  }
  function Ke(Jt, Dt, Gt, rr) {
    return Tr(Cr(Dt), Jt, Gt, rr);
  }
  function Qe(Jt, Dt, Gt, rr) {
    return Tr(Mr(Dt, Jt.length - Gt), Jt, Gt, rr);
  }
  le.prototype.write = function(Dt, Gt, rr, cr) {
    if (Gt === void 0)
      cr = "utf8", rr = this.length, Gt = 0;
    else if (rr === void 0 && typeof Gt == "string")
      cr = Gt, rr = this.length, Gt = 0;
    else if (isFinite(Gt))
      Gt = Gt >>> 0, isFinite(rr) ? (rr = rr >>> 0, cr === void 0 && (cr = "utf8")) : (cr = rr, rr = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const br = this.length - Gt;
    if ((rr === void 0 || rr > br) && (rr = br), Dt.length > 0 && (rr < 0 || Gt < 0) || Gt > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    cr || (cr = "utf8");
    let gr = !1;
    for (; ; )
      switch (cr) {
        case "hex":
          return Ft(this, Dt, Gt, rr);
        case "utf8":
        case "utf-8":
          return Ve(this, Dt, Gt, rr);
        case "ascii":
        case "latin1":
        case "binary":
          return Je(this, Dt, Gt, rr);
        case "base64":
          return Ke(this, Dt, Gt, rr);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Qe(this, Dt, Gt, rr);
        default:
          if (gr) throw new TypeError("Unknown encoding: " + cr);
          cr = ("" + cr).toLowerCase(), gr = !0;
      }
  }, le.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function bt(Jt, Dt, Gt) {
    return Dt === 0 && Gt === Jt.length ? z.fromByteArray(Jt) : z.fromByteArray(Jt.slice(Dt, Gt));
  }
  function _t(Jt, Dt, Gt) {
    Gt = Math.min(Jt.length, Gt);
    const rr = [];
    let cr = Dt;
    for (; cr < Gt; ) {
      const br = Jt[cr];
      let gr = null, Or = br > 239 ? 4 : br > 223 ? 3 : br > 191 ? 2 : 1;
      if (cr + Or <= Gt) {
        let Wr, kr, jr, Lr;
        switch (Or) {
          case 1:
            br < 128 && (gr = br);
            break;
          case 2:
            Wr = Jt[cr + 1], (Wr & 192) === 128 && (Lr = (br & 31) << 6 | Wr & 63, Lr > 127 && (gr = Lr));
            break;
          case 3:
            Wr = Jt[cr + 1], kr = Jt[cr + 2], (Wr & 192) === 128 && (kr & 192) === 128 && (Lr = (br & 15) << 12 | (Wr & 63) << 6 | kr & 63, Lr > 2047 && (Lr < 55296 || Lr > 57343) && (gr = Lr));
            break;
          case 4:
            Wr = Jt[cr + 1], kr = Jt[cr + 2], jr = Jt[cr + 3], (Wr & 192) === 128 && (kr & 192) === 128 && (jr & 192) === 128 && (Lr = (br & 15) << 18 | (Wr & 63) << 12 | (kr & 63) << 6 | jr & 63, Lr > 65535 && Lr < 1114112 && (gr = Lr));
        }
      }
      gr === null ? (gr = 65533, Or = 1) : gr > 65535 && (gr -= 65536, rr.push(gr >>> 10 & 1023 | 55296), gr = 56320 | gr & 1023), rr.push(gr), cr += Or;
    }
    return kt(rr);
  }
  const $t = 4096;
  function kt(Jt) {
    const Dt = Jt.length;
    if (Dt <= $t)
      return String.fromCharCode.apply(String, Jt);
    let Gt = "", rr = 0;
    for (; rr < Dt; )
      Gt += String.fromCharCode.apply(
        String,
        Jt.slice(rr, rr += $t)
      );
    return Gt;
  }
  function xt(Jt, Dt, Gt) {
    let rr = "";
    Gt = Math.min(Jt.length, Gt);
    for (let cr = Dt; cr < Gt; ++cr)
      rr += String.fromCharCode(Jt[cr] & 127);
    return rr;
  }
  function Nt(Jt, Dt, Gt) {
    let rr = "";
    Gt = Math.min(Jt.length, Gt);
    for (let cr = Dt; cr < Gt; ++cr)
      rr += String.fromCharCode(Jt[cr]);
    return rr;
  }
  function Rt(Jt, Dt, Gt) {
    const rr = Jt.length;
    (!Dt || Dt < 0) && (Dt = 0), (!Gt || Gt < 0 || Gt > rr) && (Gt = rr);
    let cr = "";
    for (let br = Dt; br < Gt; ++br)
      cr += Nr[Jt[br]];
    return cr;
  }
  function Ht(Jt, Dt, Gt) {
    const rr = Jt.slice(Dt, Gt);
    let cr = "";
    for (let br = 0; br < rr.length - 1; br += 2)
      cr += String.fromCharCode(rr[br] + rr[br + 1] * 256);
    return cr;
  }
  le.prototype.slice = function(Dt, Gt) {
    const rr = this.length;
    Dt = ~~Dt, Gt = Gt === void 0 ? rr : ~~Gt, Dt < 0 ? (Dt += rr, Dt < 0 && (Dt = 0)) : Dt > rr && (Dt = rr), Gt < 0 ? (Gt += rr, Gt < 0 && (Gt = 0)) : Gt > rr && (Gt = rr), Gt < Dt && (Gt = Dt);
    const cr = this.subarray(Dt, Gt);
    return Object.setPrototypeOf(cr, le.prototype), cr;
  };
  function ar(Jt, Dt, Gt) {
    if (Jt % 1 !== 0 || Jt < 0) throw new RangeError("offset is not uint");
    if (Jt + Dt > Gt) throw new RangeError("Trying to access beyond buffer length");
  }
  le.prototype.readUintLE = le.prototype.readUIntLE = function(Dt, Gt, rr) {
    Dt = Dt >>> 0, Gt = Gt >>> 0, rr || ar(Dt, Gt, this.length);
    let cr = this[Dt], br = 1, gr = 0;
    for (; ++gr < Gt && (br *= 256); )
      cr += this[Dt + gr] * br;
    return cr;
  }, le.prototype.readUintBE = le.prototype.readUIntBE = function(Dt, Gt, rr) {
    Dt = Dt >>> 0, Gt = Gt >>> 0, rr || ar(Dt, Gt, this.length);
    let cr = this[Dt + --Gt], br = 1;
    for (; Gt > 0 && (br *= 256); )
      cr += this[Dt + --Gt] * br;
    return cr;
  }, le.prototype.readUint8 = le.prototype.readUInt8 = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 1, this.length), this[Dt];
  }, le.prototype.readUint16LE = le.prototype.readUInt16LE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 2, this.length), this[Dt] | this[Dt + 1] << 8;
  }, le.prototype.readUint16BE = le.prototype.readUInt16BE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 2, this.length), this[Dt] << 8 | this[Dt + 1];
  }, le.prototype.readUint32LE = le.prototype.readUInt32LE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 4, this.length), (this[Dt] | this[Dt + 1] << 8 | this[Dt + 2] << 16) + this[Dt + 3] * 16777216;
  }, le.prototype.readUint32BE = le.prototype.readUInt32BE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 4, this.length), this[Dt] * 16777216 + (this[Dt + 1] << 16 | this[Dt + 2] << 8 | this[Dt + 3]);
  }, le.prototype.readBigUInt64LE = zr(function(Dt) {
    Dt = Dt >>> 0, Sr(Dt, "offset");
    const Gt = this[Dt], rr = this[Dt + 7];
    (Gt === void 0 || rr === void 0) && Br(Dt, this.length - 8);
    const cr = Gt + this[++Dt] * 2 ** 8 + this[++Dt] * 2 ** 16 + this[++Dt] * 2 ** 24, br = this[++Dt] + this[++Dt] * 2 ** 8 + this[++Dt] * 2 ** 16 + rr * 2 ** 24;
    return BigInt(cr) + (BigInt(br) << BigInt(32));
  }), le.prototype.readBigUInt64BE = zr(function(Dt) {
    Dt = Dt >>> 0, Sr(Dt, "offset");
    const Gt = this[Dt], rr = this[Dt + 7];
    (Gt === void 0 || rr === void 0) && Br(Dt, this.length - 8);
    const cr = Gt * 2 ** 24 + this[++Dt] * 2 ** 16 + this[++Dt] * 2 ** 8 + this[++Dt], br = this[++Dt] * 2 ** 24 + this[++Dt] * 2 ** 16 + this[++Dt] * 2 ** 8 + rr;
    return (BigInt(cr) << BigInt(32)) + BigInt(br);
  }), le.prototype.readIntLE = function(Dt, Gt, rr) {
    Dt = Dt >>> 0, Gt = Gt >>> 0, rr || ar(Dt, Gt, this.length);
    let cr = this[Dt], br = 1, gr = 0;
    for (; ++gr < Gt && (br *= 256); )
      cr += this[Dt + gr] * br;
    return br *= 128, cr >= br && (cr -= Math.pow(2, 8 * Gt)), cr;
  }, le.prototype.readIntBE = function(Dt, Gt, rr) {
    Dt = Dt >>> 0, Gt = Gt >>> 0, rr || ar(Dt, Gt, this.length);
    let cr = Gt, br = 1, gr = this[Dt + --cr];
    for (; cr > 0 && (br *= 256); )
      gr += this[Dt + --cr] * br;
    return br *= 128, gr >= br && (gr -= Math.pow(2, 8 * Gt)), gr;
  }, le.prototype.readInt8 = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 1, this.length), this[Dt] & 128 ? (255 - this[Dt] + 1) * -1 : this[Dt];
  }, le.prototype.readInt16LE = function(Dt, Gt) {
    Dt = Dt >>> 0, Gt || ar(Dt, 2, this.length);
    const rr = this[Dt] | this[Dt + 1] << 8;
    return rr & 32768 ? rr | 4294901760 : rr;
  }, le.prototype.readInt16BE = function(Dt, Gt) {
    Dt = Dt >>> 0, Gt || ar(Dt, 2, this.length);
    const rr = this[Dt + 1] | this[Dt] << 8;
    return rr & 32768 ? rr | 4294901760 : rr;
  }, le.prototype.readInt32LE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 4, this.length), this[Dt] | this[Dt + 1] << 8 | this[Dt + 2] << 16 | this[Dt + 3] << 24;
  }, le.prototype.readInt32BE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 4, this.length), this[Dt] << 24 | this[Dt + 1] << 16 | this[Dt + 2] << 8 | this[Dt + 3];
  }, le.prototype.readBigInt64LE = zr(function(Dt) {
    Dt = Dt >>> 0, Sr(Dt, "offset");
    const Gt = this[Dt], rr = this[Dt + 7];
    (Gt === void 0 || rr === void 0) && Br(Dt, this.length - 8);
    const cr = this[Dt + 4] + this[Dt + 5] * 2 ** 8 + this[Dt + 6] * 2 ** 16 + (rr << 24);
    return (BigInt(cr) << BigInt(32)) + BigInt(Gt + this[++Dt] * 2 ** 8 + this[++Dt] * 2 ** 16 + this[++Dt] * 2 ** 24);
  }), le.prototype.readBigInt64BE = zr(function(Dt) {
    Dt = Dt >>> 0, Sr(Dt, "offset");
    const Gt = this[Dt], rr = this[Dt + 7];
    (Gt === void 0 || rr === void 0) && Br(Dt, this.length - 8);
    const cr = (Gt << 24) + // Overflow
    this[++Dt] * 2 ** 16 + this[++Dt] * 2 ** 8 + this[++Dt];
    return (BigInt(cr) << BigInt(32)) + BigInt(this[++Dt] * 2 ** 24 + this[++Dt] * 2 ** 16 + this[++Dt] * 2 ** 8 + rr);
  }), le.prototype.readFloatLE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 4, this.length), Y.read(this, Dt, !0, 23, 4);
  }, le.prototype.readFloatBE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 4, this.length), Y.read(this, Dt, !1, 23, 4);
  }, le.prototype.readDoubleLE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 8, this.length), Y.read(this, Dt, !0, 52, 8);
  }, le.prototype.readDoubleBE = function(Dt, Gt) {
    return Dt = Dt >>> 0, Gt || ar(Dt, 8, this.length), Y.read(this, Dt, !1, 52, 8);
  };
  function lr(Jt, Dt, Gt, rr, cr, br) {
    if (!le.isBuffer(Jt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Dt > cr || Dt < br) throw new RangeError('"value" argument is out of bounds');
    if (Gt + rr > Jt.length) throw new RangeError("Index out of range");
  }
  le.prototype.writeUintLE = le.prototype.writeUIntLE = function(Dt, Gt, rr, cr) {
    if (Dt = +Dt, Gt = Gt >>> 0, rr = rr >>> 0, !cr) {
      const Or = Math.pow(2, 8 * rr) - 1;
      lr(this, Dt, Gt, rr, Or, 0);
    }
    let br = 1, gr = 0;
    for (this[Gt] = Dt & 255; ++gr < rr && (br *= 256); )
      this[Gt + gr] = Dt / br & 255;
    return Gt + rr;
  }, le.prototype.writeUintBE = le.prototype.writeUIntBE = function(Dt, Gt, rr, cr) {
    if (Dt = +Dt, Gt = Gt >>> 0, rr = rr >>> 0, !cr) {
      const Or = Math.pow(2, 8 * rr) - 1;
      lr(this, Dt, Gt, rr, Or, 0);
    }
    let br = rr - 1, gr = 1;
    for (this[Gt + br] = Dt & 255; --br >= 0 && (gr *= 256); )
      this[Gt + br] = Dt / gr & 255;
    return Gt + rr;
  }, le.prototype.writeUint8 = le.prototype.writeUInt8 = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 1, 255, 0), this[Gt] = Dt & 255, Gt + 1;
  }, le.prototype.writeUint16LE = le.prototype.writeUInt16LE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 2, 65535, 0), this[Gt] = Dt & 255, this[Gt + 1] = Dt >>> 8, Gt + 2;
  }, le.prototype.writeUint16BE = le.prototype.writeUInt16BE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 2, 65535, 0), this[Gt] = Dt >>> 8, this[Gt + 1] = Dt & 255, Gt + 2;
  }, le.prototype.writeUint32LE = le.prototype.writeUInt32LE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 4, 4294967295, 0), this[Gt + 3] = Dt >>> 24, this[Gt + 2] = Dt >>> 16, this[Gt + 1] = Dt >>> 8, this[Gt] = Dt & 255, Gt + 4;
  }, le.prototype.writeUint32BE = le.prototype.writeUInt32BE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 4, 4294967295, 0), this[Gt] = Dt >>> 24, this[Gt + 1] = Dt >>> 16, this[Gt + 2] = Dt >>> 8, this[Gt + 3] = Dt & 255, Gt + 4;
  };
  function nr(Jt, Dt, Gt, rr, cr) {
    Ar(Dt, rr, cr, Jt, Gt, 7);
    let br = Number(Dt & BigInt(4294967295));
    Jt[Gt++] = br, br = br >> 8, Jt[Gt++] = br, br = br >> 8, Jt[Gt++] = br, br = br >> 8, Jt[Gt++] = br;
    let gr = Number(Dt >> BigInt(32) & BigInt(4294967295));
    return Jt[Gt++] = gr, gr = gr >> 8, Jt[Gt++] = gr, gr = gr >> 8, Jt[Gt++] = gr, gr = gr >> 8, Jt[Gt++] = gr, Gt;
  }
  function Vt(Jt, Dt, Gt, rr, cr) {
    Ar(Dt, rr, cr, Jt, Gt, 7);
    let br = Number(Dt & BigInt(4294967295));
    Jt[Gt + 7] = br, br = br >> 8, Jt[Gt + 6] = br, br = br >> 8, Jt[Gt + 5] = br, br = br >> 8, Jt[Gt + 4] = br;
    let gr = Number(Dt >> BigInt(32) & BigInt(4294967295));
    return Jt[Gt + 3] = gr, gr = gr >> 8, Jt[Gt + 2] = gr, gr = gr >> 8, Jt[Gt + 1] = gr, gr = gr >> 8, Jt[Gt] = gr, Gt + 8;
  }
  le.prototype.writeBigUInt64LE = zr(function(Dt, Gt = 0) {
    return nr(this, Dt, Gt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeBigUInt64BE = zr(function(Dt, Gt = 0) {
    return Vt(this, Dt, Gt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), le.prototype.writeIntLE = function(Dt, Gt, rr, cr) {
    if (Dt = +Dt, Gt = Gt >>> 0, !cr) {
      const Wr = Math.pow(2, 8 * rr - 1);
      lr(this, Dt, Gt, rr, Wr - 1, -Wr);
    }
    let br = 0, gr = 1, Or = 0;
    for (this[Gt] = Dt & 255; ++br < rr && (gr *= 256); )
      Dt < 0 && Or === 0 && this[Gt + br - 1] !== 0 && (Or = 1), this[Gt + br] = (Dt / gr >> 0) - Or & 255;
    return Gt + rr;
  }, le.prototype.writeIntBE = function(Dt, Gt, rr, cr) {
    if (Dt = +Dt, Gt = Gt >>> 0, !cr) {
      const Wr = Math.pow(2, 8 * rr - 1);
      lr(this, Dt, Gt, rr, Wr - 1, -Wr);
    }
    let br = rr - 1, gr = 1, Or = 0;
    for (this[Gt + br] = Dt & 255; --br >= 0 && (gr *= 256); )
      Dt < 0 && Or === 0 && this[Gt + br + 1] !== 0 && (Or = 1), this[Gt + br] = (Dt / gr >> 0) - Or & 255;
    return Gt + rr;
  }, le.prototype.writeInt8 = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 1, 127, -128), Dt < 0 && (Dt = 255 + Dt + 1), this[Gt] = Dt & 255, Gt + 1;
  }, le.prototype.writeInt16LE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 2, 32767, -32768), this[Gt] = Dt & 255, this[Gt + 1] = Dt >>> 8, Gt + 2;
  }, le.prototype.writeInt16BE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 2, 32767, -32768), this[Gt] = Dt >>> 8, this[Gt + 1] = Dt & 255, Gt + 2;
  }, le.prototype.writeInt32LE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 4, 2147483647, -2147483648), this[Gt] = Dt & 255, this[Gt + 1] = Dt >>> 8, this[Gt + 2] = Dt >>> 16, this[Gt + 3] = Dt >>> 24, Gt + 4;
  }, le.prototype.writeInt32BE = function(Dt, Gt, rr) {
    return Dt = +Dt, Gt = Gt >>> 0, rr || lr(this, Dt, Gt, 4, 2147483647, -2147483648), Dt < 0 && (Dt = 4294967295 + Dt + 1), this[Gt] = Dt >>> 24, this[Gt + 1] = Dt >>> 16, this[Gt + 2] = Dt >>> 8, this[Gt + 3] = Dt & 255, Gt + 4;
  }, le.prototype.writeBigInt64LE = zr(function(Dt, Gt = 0) {
    return nr(this, Dt, Gt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), le.prototype.writeBigInt64BE = zr(function(Dt, Gt = 0) {
    return Vt(this, Dt, Gt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Xt(Jt, Dt, Gt, rr, cr, br) {
    if (Gt + rr > Jt.length) throw new RangeError("Index out of range");
    if (Gt < 0) throw new RangeError("Index out of range");
  }
  function sr(Jt, Dt, Gt, rr, cr) {
    return Dt = +Dt, Gt = Gt >>> 0, cr || Xt(Jt, Dt, Gt, 4), Y.write(Jt, Dt, Gt, rr, 23, 4), Gt + 4;
  }
  le.prototype.writeFloatLE = function(Dt, Gt, rr) {
    return sr(this, Dt, Gt, !0, rr);
  }, le.prototype.writeFloatBE = function(Dt, Gt, rr) {
    return sr(this, Dt, Gt, !1, rr);
  };
  function dr(Jt, Dt, Gt, rr, cr) {
    return Dt = +Dt, Gt = Gt >>> 0, cr || Xt(Jt, Dt, Gt, 8), Y.write(Jt, Dt, Gt, rr, 52, 8), Gt + 8;
  }
  le.prototype.writeDoubleLE = function(Dt, Gt, rr) {
    return dr(this, Dt, Gt, !0, rr);
  }, le.prototype.writeDoubleBE = function(Dt, Gt, rr) {
    return dr(this, Dt, Gt, !1, rr);
  }, le.prototype.copy = function(Dt, Gt, rr, cr) {
    if (!le.isBuffer(Dt)) throw new TypeError("argument should be a Buffer");
    if (rr || (rr = 0), !cr && cr !== 0 && (cr = this.length), Gt >= Dt.length && (Gt = Dt.length), Gt || (Gt = 0), cr > 0 && cr < rr && (cr = rr), cr === rr || Dt.length === 0 || this.length === 0) return 0;
    if (Gt < 0)
      throw new RangeError("targetStart out of bounds");
    if (rr < 0 || rr >= this.length) throw new RangeError("Index out of range");
    if (cr < 0) throw new RangeError("sourceEnd out of bounds");
    cr > this.length && (cr = this.length), Dt.length - Gt < cr - rr && (cr = Dt.length - Gt + rr);
    const br = cr - rr;
    return this === Dt && typeof ie.prototype.copyWithin == "function" ? this.copyWithin(Gt, rr, cr) : ie.prototype.set.call(
      Dt,
      this.subarray(rr, cr),
      Gt
    ), br;
  }, le.prototype.fill = function(Dt, Gt, rr, cr) {
    if (typeof Dt == "string") {
      if (typeof Gt == "string" ? (cr = Gt, Gt = 0, rr = this.length) : typeof rr == "string" && (cr = rr, rr = this.length), cr !== void 0 && typeof cr != "string")
        throw new TypeError("encoding must be a string");
      if (typeof cr == "string" && !le.isEncoding(cr))
        throw new TypeError("Unknown encoding: " + cr);
      if (Dt.length === 1) {
        const gr = Dt.charCodeAt(0);
        (cr === "utf8" && gr < 128 || cr === "latin1") && (Dt = gr);
      }
    } else typeof Dt == "number" ? Dt = Dt & 255 : typeof Dt == "boolean" && (Dt = Number(Dt));
    if (Gt < 0 || this.length < Gt || this.length < rr)
      throw new RangeError("Out of range index");
    if (rr <= Gt)
      return this;
    Gt = Gt >>> 0, rr = rr === void 0 ? this.length : rr >>> 0, Dt || (Dt = 0);
    let br;
    if (typeof Dt == "number")
      for (br = Gt; br < rr; ++br)
        this[br] = Dt;
    else {
      const gr = le.isBuffer(Dt) ? Dt : le.from(Dt, cr), Or = gr.length;
      if (Or === 0)
        throw new TypeError('The value "' + Dt + '" is invalid for argument "value"');
      for (br = 0; br < rr - Gt; ++br)
        this[br + Gt] = gr[br % Or];
    }
    return this;
  };
  const er = {};
  function Zt(Jt, Dt, Gt) {
    er[Jt] = class extends Gt {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Dt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Jt}]`, this.stack, delete this.name;
      }
      get code() {
        return Jt;
      }
      set code(cr) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: cr,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Jt}]: ${this.message}`;
      }
    };
  }
  Zt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Jt) {
      return Jt ? `${Jt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), Zt(
    "ERR_INVALID_ARG_TYPE",
    function(Jt, Dt) {
      return `The "${Jt}" argument must be of type number. Received type ${typeof Dt}`;
    },
    TypeError
  ), Zt(
    "ERR_OUT_OF_RANGE",
    function(Jt, Dt, Gt) {
      let rr = `The value of "${Jt}" is out of range.`, cr = Gt;
      return Number.isInteger(Gt) && Math.abs(Gt) > 2 ** 32 ? cr = pr(String(Gt)) : typeof Gt == "bigint" && (cr = String(Gt), (Gt > BigInt(2) ** BigInt(32) || Gt < -(BigInt(2) ** BigInt(32))) && (cr = pr(cr)), cr += "n"), rr += ` It must be ${Dt}. Received ${cr}`, rr;
    },
    RangeError
  );
  function pr(Jt) {
    let Dt = "", Gt = Jt.length;
    const rr = Jt[0] === "-" ? 1 : 0;
    for (; Gt >= rr + 4; Gt -= 3)
      Dt = `_${Jt.slice(Gt - 3, Gt)}${Dt}`;
    return `${Jt.slice(0, Gt)}${Dt}`;
  }
  function _r(Jt, Dt, Gt) {
    Sr(Dt, "offset"), (Jt[Dt] === void 0 || Jt[Dt + Gt] === void 0) && Br(Dt, Jt.length - (Gt + 1));
  }
  function Ar(Jt, Dt, Gt, rr, cr, br) {
    if (Jt > Gt || Jt < Dt) {
      const gr = typeof Dt == "bigint" ? "n" : "";
      let Or;
      throw Dt === 0 || Dt === BigInt(0) ? Or = `>= 0${gr} and < 2${gr} ** ${(br + 1) * 8}${gr}` : Or = `>= -(2${gr} ** ${(br + 1) * 8 - 1}${gr}) and < 2 ** ${(br + 1) * 8 - 1}${gr}`, new er.ERR_OUT_OF_RANGE("value", Or, Jt);
    }
    _r(rr, cr, br);
  }
  function Sr(Jt, Dt) {
    if (typeof Jt != "number")
      throw new er.ERR_INVALID_ARG_TYPE(Dt, "number", Jt);
  }
  function Br(Jt, Dt, Gt) {
    throw Math.floor(Jt) !== Jt ? (Sr(Jt, Gt), new er.ERR_OUT_OF_RANGE("offset", "an integer", Jt)) : Dt < 0 ? new er.ERR_BUFFER_OUT_OF_BOUNDS() : new er.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Dt}`,
      Jt
    );
  }
  const Ir = /[^+/0-9A-Za-z-_]/g;
  function wr(Jt) {
    if (Jt = Jt.split("=")[0], Jt = Jt.trim().replace(Ir, ""), Jt.length < 2) return "";
    for (; Jt.length % 4 !== 0; )
      Jt = Jt + "=";
    return Jt;
  }
  function Gr(Jt, Dt) {
    Dt = Dt || 1 / 0;
    let Gt;
    const rr = Jt.length;
    let cr = null;
    const br = [];
    for (let gr = 0; gr < rr; ++gr) {
      if (Gt = Jt.charCodeAt(gr), Gt > 55295 && Gt < 57344) {
        if (!cr) {
          if (Gt > 56319) {
            (Dt -= 3) > -1 && br.push(239, 191, 189);
            continue;
          } else if (gr + 1 === rr) {
            (Dt -= 3) > -1 && br.push(239, 191, 189);
            continue;
          }
          cr = Gt;
          continue;
        }
        if (Gt < 56320) {
          (Dt -= 3) > -1 && br.push(239, 191, 189), cr = Gt;
          continue;
        }
        Gt = (cr - 55296 << 10 | Gt - 56320) + 65536;
      } else cr && (Dt -= 3) > -1 && br.push(239, 191, 189);
      if (cr = null, Gt < 128) {
        if ((Dt -= 1) < 0) break;
        br.push(Gt);
      } else if (Gt < 2048) {
        if ((Dt -= 2) < 0) break;
        br.push(
          Gt >> 6 | 192,
          Gt & 63 | 128
        );
      } else if (Gt < 65536) {
        if ((Dt -= 3) < 0) break;
        br.push(
          Gt >> 12 | 224,
          Gt >> 6 & 63 | 128,
          Gt & 63 | 128
        );
      } else if (Gt < 1114112) {
        if ((Dt -= 4) < 0) break;
        br.push(
          Gt >> 18 | 240,
          Gt >> 12 & 63 | 128,
          Gt >> 6 & 63 | 128,
          Gt & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return br;
  }
  function Pr(Jt) {
    const Dt = [];
    for (let Gt = 0; Gt < Jt.length; ++Gt)
      Dt.push(Jt.charCodeAt(Gt) & 255);
    return Dt;
  }
  function Mr(Jt, Dt) {
    let Gt, rr, cr;
    const br = [];
    for (let gr = 0; gr < Jt.length && !((Dt -= 2) < 0); ++gr)
      Gt = Jt.charCodeAt(gr), rr = Gt >> 8, cr = Gt % 256, br.push(cr), br.push(rr);
    return br;
  }
  function Cr(Jt) {
    return z.toByteArray(wr(Jt));
  }
  function Tr(Jt, Dt, Gt, rr) {
    let cr;
    for (cr = 0; cr < rr && !(cr + Gt >= Dt.length || cr >= Jt.length); ++cr)
      Dt[cr + Gt] = Jt[cr];
    return cr;
  }
  function Hr(Jt, Dt) {
    return Jt instanceof Dt || Jt != null && Jt.constructor != null && Jt.constructor.name != null && Jt.constructor.name === Dt.name;
  }
  function Yr(Jt) {
    return Jt !== Jt;
  }
  const Nr = function() {
    const Jt = "0123456789abcdef", Dt = new Array(256);
    for (let Gt = 0; Gt < 16; ++Gt) {
      const rr = Gt * 16;
      for (let cr = 0; cr < 16; ++cr)
        Dt[rr + cr] = Jt[Gt] + Jt[cr];
    }
    return Dt;
  }();
  function zr(Jt) {
    return typeof BigInt > "u" ? Jr : Jt;
  }
  function Jr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$2 = buffer$1.Buffer;
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, z) {
  var Y;
  return (Y = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : Y.get(z);
}
function _stringify(B) {
  var Y, ne;
  const z = typeof B;
  return z === "string" ? `"${B}"` : z === "number" || z === "bigint" || z === "boolean" ? `${B}` : z === "object" || z === "function" ? (B && ((ne = (Y = Object.getPrototypeOf(B)) == null ? void 0 : Y.constructor) == null ? void 0 : ne.name)) ?? "null" : z;
}
function _addIssue(B, z, Y, ne, oe) {
  const ie = oe && "input" in oe ? oe.input : Y.value, ae = (oe == null ? void 0 : oe.expected) ?? B.expects ?? null, se = (oe == null ? void 0 : oe.received) ?? _stringify(ie), ve = {
    kind: B.kind,
    type: B.type,
    input: ie,
    expected: ae,
    received: se,
    message: `Invalid ${z}: ${ae ? `Expected ${ae} but r` : "R"}eceived ${se}`,
    requirement: B.requirement,
    path: oe == null ? void 0 : oe.path,
    issues: oe == null ? void 0 : oe.issues,
    lang: ne.lang,
    abortEarly: ne.abortEarly,
    abortPipeEarly: ne.abortPipeEarly
  }, ge = B.kind === "schema", le = (oe == null ? void 0 : oe.message) ?? B.message ?? getSpecificMessage(B.reference, ve.lang) ?? (ge ? getSchemaMessage(ve.lang) : null) ?? ne.message ?? getGlobalMessage(ve.lang);
  le && (ve.message = typeof le == "function" ? (
    // @ts-expect-error
    le(ve)
  ) : le), ge && (Y.typed = !1), Y.issues ? Y.issues.push(ve) : Y.issues = [ve];
}
function _isValidObjectKey(B, z) {
  return Object.hasOwn(B, z) && z !== "__proto__" && z !== "prototype" && z !== "constructor";
}
function _joinExpects(B, z) {
  const Y = [...new Set(B)];
  return Y.length > 1 ? `(${Y.join(` ${z} `)})` : Y[0] ?? "never";
}
function check$e(B, z) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && !this.requirement(Y.value) && _addIssue(this, "input", Y, ne), Y;
    }
  };
}
function maxLength(B, z) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length > this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function minLength(B, z) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${B}`,
    requirement: B,
    message: z,
    _run(Y, ne) {
      return Y.typed && Y.value.length < this.requirement && _addIssue(this, "length", Y, ne, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function getDefault(B, z, Y) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(z, Y)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function array(B, z) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: z,
    _run(Y, ne) {
      var ie;
      const oe = Y.value;
      if (Array.isArray(oe)) {
        Y.typed = !0, Y.value = [];
        for (let ae = 0; ae < oe.length; ae++) {
          const se = oe[ae], ve = this.item._run({ typed: !1, value: se }, ne);
          if (ve.issues) {
            const ge = {
              type: "array",
              origin: "value",
              input: oe,
              key: ae,
              value: se
            };
            for (const le of ve.issues)
              le.path ? le.path.unshift(ge) : le.path = [ge], (ie = Y.issues) == null || ie.push(le);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), Y.value.push(ve.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "boolean" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function enum_(B, z) {
  const Y = Object.entries(B).filter(([ne]) => isNaN(+ne)).map(([, ne]) => ne);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(Y.map(_stringify), "|"),
    async: !1,
    enum: B,
    options: Y,
    message: z,
    _run(ne, oe) {
      return this.options.includes(ne.value) ? ne.typed = !0 : _addIssue(this, "type", ne, oe), ne;
    }
  };
}
function literal(B, z) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: z,
    _run(Y, ne) {
      return Y.value === this.literal ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function looseObject(B, z) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var ie;
      const oe = Y.value;
      if (oe && typeof oe == "object") {
        Y.typed = !0, Y.value = {};
        for (const ae in this.entries) {
          const se = oe[ae], ve = this.entries[ae]._run(
            { typed: !1, value: se },
            ne
          );
          if (ve.issues) {
            const ge = {
              type: "object",
              origin: "value",
              input: oe,
              key: ae,
              value: se
            };
            for (const le of ve.issues)
              le.path ? le.path.unshift(ge) : le.path = [ge], (ie = Y.issues) == null || ie.push(le);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), (ve.value !== void 0 || ae in oe) && (Y.value[ae] = ve.value);
        }
        if (!Y.issues || !ne.abortEarly)
          for (const ae in oe)
            _isValidObjectKey(oe, ae) && !(ae in this.entries) && (Y.value[ae] = oe[ae]);
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function nonOptional(B, z) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: z,
    _run(Y, ne) {
      return Y.value === void 0 ? (_addIssue(this, "type", Y, ne), Y) : this.wrapped._run(Y, ne);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(z, Y) {
      return z.value === null ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function nullish(B, ...z) {
  const Y = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${B.expects} | null | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, oe) {
      return (ne.value === null || ne.value === void 0) && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        oe
      )), ne.value === null || ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, oe);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "number" && !isNaN(z.value) ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function object(B, z) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ne) {
      var ie;
      const oe = Y.value;
      if (oe && typeof oe == "object") {
        Y.typed = !0, Y.value = {};
        for (const ae in this.entries) {
          const se = oe[ae], ve = this.entries[ae]._run(
            { typed: !1, value: se },
            ne
          );
          if (ve.issues) {
            const ge = {
              type: "object",
              origin: "value",
              input: oe,
              key: ae,
              value: se
            };
            for (const le of ve.issues)
              le.path ? le.path.unshift(ge) : le.path = [ge], (ie = Y.issues) == null || ie.push(le);
            if (Y.issues || (Y.issues = ve.issues), ne.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ve.typed || (Y.typed = !1), (ve.value !== void 0 || ae in oe) && (Y.value[ae] = ve.value);
        }
      } else
        _addIssue(this, "type", Y, ne);
      return Y;
    }
  };
}
function optional(B, ...z) {
  const Y = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${B.expects} | undefined)`,
    async: !1,
    wrapped: B,
    _run(ne, oe) {
      return ne.value === void 0 && ("default" in this && (ne.value = getDefault(
        this,
        ne,
        oe
      )), ne.value === void 0) ? (ne.typed = !0, ne) : this.wrapped._run(ne, oe);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function picklist(B, z) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(B.map(_stringify), "|"),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      return this.options.includes(Y.value) ? Y.typed = !0 : _addIssue(this, "type", Y, ne), Y;
    }
  };
}
function record(B, z, Y) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: B,
    value: z,
    message: Y,
    _run(ne, oe) {
      var ae, se;
      const ie = ne.value;
      if (ie && typeof ie == "object") {
        ne.typed = !0, ne.value = {};
        for (const ve in ie)
          if (_isValidObjectKey(ie, ve)) {
            const ge = ie[ve], le = this.key._run(
              { typed: !1, value: ve },
              oe
            );
            if (le.issues) {
              const Ce = {
                type: "object",
                origin: "key",
                input: ie,
                key: ve,
                value: ge
              };
              for (const Pe of le.issues)
                Pe.path = [Ce], (ae = ne.issues) == null || ae.push(Pe);
              if (ne.issues || (ne.issues = le.issues), oe.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            const Ee = this.value._run(
              { typed: !1, value: ge },
              oe
            );
            if (Ee.issues) {
              const Ce = {
                type: "object",
                origin: "value",
                input: ie,
                key: ve,
                value: ge
              };
              for (const Pe of Ee.issues)
                Pe.path ? Pe.path.unshift(Ce) : Pe.path = [Ce], (se = ne.issues) == null || se.push(Pe);
              if (ne.issues || (ne.issues = Ee.issues), oe.abortEarly) {
                ne.typed = !1;
                break;
              }
            }
            (!le.typed || !Ee.typed) && (ne.typed = !1), le.typed && (ne.value[le.value] = Ee.value);
          }
      } else
        _addIssue(this, "type", ne, oe);
      return ne;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "string" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function _subIssues(B) {
  let z;
  if (B)
    for (const Y of B)
      z ? z.push(...Y.issues) : z = Y.issues;
  return z;
}
function union(B, z) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      B.map((Y) => Y.expects),
      "|"
    ),
    async: !1,
    options: B,
    message: z,
    _run(Y, ne) {
      let oe, ie, ae;
      for (const se of this.options) {
        const ve = se._run(
          { typed: !1, value: Y.value },
          ne
        );
        if (ve.typed)
          if (ve.issues)
            ie ? ie.push(ve) : ie = [ve];
          else {
            oe = ve;
            break;
          }
        else
          ae ? ae.push(ve) : ae = [ve];
      }
      if (oe)
        return oe;
      if (ie) {
        if (ie.length === 1)
          return ie[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(ie)
        }), Y.typed = !0;
      } else {
        if ((ae == null ? void 0 : ae.length) === 1)
          return ae[0];
        _addIssue(this, "type", Y, ne, {
          issues: _subIssues(ae)
        });
      }
      return Y;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
function variant(B, z, Y) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: B,
    options: z,
    message: Y,
    _run(ne, oe) {
      const ie = ne.value;
      if (ie && typeof ie == "object") {
        let ae, se = 0, ve = this.key, ge = [];
        const le = (Ee, Ce) => {
          for (const Pe of Ee.options) {
            if (Pe.type === "variant")
              le(Pe, new Set(Ce).add(Pe.key));
            else {
              let Xe = !0, ht = 0;
              for (const wt of Ce) {
                if (Pe.entries[wt]._run(
                  // @ts-expect-error
                  { typed: !1, value: ie[wt] },
                  oe
                ).issues) {
                  Xe = !1, ve !== wt && (se < ht || se === ht && wt in ie && !(ve in ie)) && (se = ht, ve = wt, ge = []), ve === wt && ge.push(
                    Pe.entries[wt].expects
                  );
                  break;
                }
                ht++;
              }
              if (Xe) {
                const wt = Pe._run(
                  { typed: !1, value: ie },
                  oe
                );
                (!ae || !ae.typed && wt.typed) && (ae = wt);
              }
            }
            if (ae && !ae.issues)
              break;
          }
        };
        if (le(this, /* @__PURE__ */ new Set([this.key])), ae)
          return ae;
        _addIssue(this, "type", ne, oe, {
          // @ts-expect-error
          input: ie[ve],
          expected: _joinExpects(ge, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: ie,
              key: ve,
              // @ts-expect-error
              value: ie[ve]
            }
          ]
        });
      } else
        _addIssue(this, "type", ne, oe);
      return ne;
    }
  };
}
function omit(B, z) {
  const Y = {
    ...B.entries
  };
  for (const ne of z)
    delete Y[ne];
  return { ...B, entries: Y };
}
function pipe(...B) {
  return {
    ...B[0],
    pipe: B,
    _run(z, Y) {
      for (const ne of B)
        if (ne.kind !== "metadata") {
          if (z.issues && (ne.kind === "schema" || ne.kind === "transformation")) {
            z.typed = !1;
            break;
          }
          (!z.issues || !Y.abortEarly && !Y.abortPipeEarly) && (z = ne._run(z, Y));
        }
      return z;
    }
  };
}
function unwrap(B) {
  return B.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ne = Y === z ? 0 : 4 - Y % 4;
  return [Y, ne];
}
function byteLength(B) {
  var z = getLens(B), Y = z[0], ne = z[1];
  return (Y + ne) * 3 / 4 - ne;
}
function _byteLength(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray(B) {
  var z, Y = getLens(B), ne = Y[0], oe = Y[1], ie = new Arr(_byteLength(B, ne, oe)), ae = 0, se = oe > 0 ? ne - 4 : ne, ve;
  for (ve = 0; ve < se; ve += 4)
    z = revLookup[B.charCodeAt(ve)] << 18 | revLookup[B.charCodeAt(ve + 1)] << 12 | revLookup[B.charCodeAt(ve + 2)] << 6 | revLookup[B.charCodeAt(ve + 3)], ie[ae++] = z >> 16 & 255, ie[ae++] = z >> 8 & 255, ie[ae++] = z & 255;
  return oe === 2 && (z = revLookup[B.charCodeAt(ve)] << 2 | revLookup[B.charCodeAt(ve + 1)] >> 4, ie[ae++] = z & 255), oe === 1 && (z = revLookup[B.charCodeAt(ve)] << 10 | revLookup[B.charCodeAt(ve + 1)] << 4 | revLookup[B.charCodeAt(ve + 2)] >> 2, ie[ae++] = z >> 8 & 255, ie[ae++] = z & 255), ie;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, z, Y) {
  for (var ne, oe = [], ie = z; ie < Y; ie += 3)
    ne = (B[ie] << 16 & 16711680) + (B[ie + 1] << 8 & 65280) + (B[ie + 2] & 255), oe.push(tripletToBase64(ne));
  return oe.join("");
}
function fromByteArray(B) {
  for (var z, Y = B.length, ne = Y % 3, oe = [], ie = 16383, ae = 0, se = Y - ne; ae < se; ae += ie)
    oe.push(encodeChunk(B, ae, ae + ie > se ? se : ae + ie));
  return ne === 1 ? (z = B[Y - 1], oe.push(
    lookup[z >> 2] + lookup[z << 4 & 63] + "=="
  )) : ne === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], oe.push(
    lookup[z >> 10] + lookup[z >> 4 & 63] + lookup[z << 2 & 63] + "="
  )), oe.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode$j;
function decode$j(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error("positive integer expected, got " + B);
}
function isBytes(B) {
  return B instanceof Uint8Array || ArrayBuffer.isView(B) && B.constructor.name === "Uint8Array";
}
function abytes(B, ...z) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (z.length > 0 && !z.includes(B.length))
    throw new Error("Uint8Array expected of length " + z + ", got length=" + B.length);
}
function ahash(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(B.outputLen), anumber(B.blockLen);
}
function aexists(B, z = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (z && B.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(B, z) {
  abytes(B);
  const Y = z.outputLen;
  if (B.length < Y)
    throw new Error("digestInto() expects output buffer of length at least " + Y);
}
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.isLE = void 0, B.isBytes = ne, B.u8 = oe, B.u32 = ie, B.createView = ae, B.rotr = se, B.rotl = ve, B.byteSwap = ge, B.byteSwap32 = le, B.bytesToHex = Ce, B.hexToBytes = ht, B.asyncLoop = Pt, B.utf8ToBytes = vt, B.toBytes = Bt, B.concatBytes = Ct, B.checkOpts = Kt, B.wrapConstructor = Yt, B.wrapConstructorWithOpts = Ut, B.wrapXOFConstructorWithOpts = qt, B.randomBytes = zt;
  const z = crypto$2, Y = _assert;
  function ne(Ft) {
    return Ft instanceof Uint8Array || ArrayBuffer.isView(Ft) && Ft.constructor.name === "Uint8Array";
  }
  function oe(Ft) {
    return new Uint8Array(Ft.buffer, Ft.byteOffset, Ft.byteLength);
  }
  function ie(Ft) {
    return new Uint32Array(Ft.buffer, Ft.byteOffset, Math.floor(Ft.byteLength / 4));
  }
  function ae(Ft) {
    return new DataView(Ft.buffer, Ft.byteOffset, Ft.byteLength);
  }
  function se(Ft, Ve) {
    return Ft << 32 - Ve | Ft >>> Ve;
  }
  function ve(Ft, Ve) {
    return Ft << Ve | Ft >>> 32 - Ve >>> 0;
  }
  B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function ge(Ft) {
    return Ft << 24 & 4278190080 | Ft << 8 & 16711680 | Ft >>> 8 & 65280 | Ft >>> 24 & 255;
  }
  B.byteSwapIfBE = B.isLE ? (Ft) => Ft : (Ft) => ge(Ft);
  function le(Ft) {
    for (let Ve = 0; Ve < Ft.length; Ve++)
      Ft[Ve] = ge(Ft[Ve]);
  }
  const Ee = /* @__PURE__ */ Array.from({ length: 256 }, (Ft, Ve) => Ve.toString(16).padStart(2, "0"));
  function Ce(Ft) {
    (0, Y.abytes)(Ft);
    let Ve = "";
    for (let Je = 0; Je < Ft.length; Je++)
      Ve += Ee[Ft[Je]];
    return Ve;
  }
  const Pe = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function Xe(Ft) {
    if (Ft >= Pe._0 && Ft <= Pe._9)
      return Ft - Pe._0;
    if (Ft >= Pe.A && Ft <= Pe.F)
      return Ft - (Pe.A - 10);
    if (Ft >= Pe.a && Ft <= Pe.f)
      return Ft - (Pe.a - 10);
  }
  function ht(Ft) {
    if (typeof Ft != "string")
      throw new Error("hex string expected, got " + typeof Ft);
    const Ve = Ft.length, Je = Ve / 2;
    if (Ve % 2)
      throw new Error("hex string expected, got unpadded hex of length " + Ve);
    const Ke = new Uint8Array(Je);
    for (let Qe = 0, bt = 0; Qe < Je; Qe++, bt += 2) {
      const _t = Xe(Ft.charCodeAt(bt)), $t = Xe(Ft.charCodeAt(bt + 1));
      if (_t === void 0 || $t === void 0) {
        const kt = Ft[bt] + Ft[bt + 1];
        throw new Error('hex string expected, got non-hex character "' + kt + '" at index ' + bt);
      }
      Ke[Qe] = _t * 16 + $t;
    }
    return Ke;
  }
  const wt = async () => {
  };
  B.nextTick = wt;
  async function Pt(Ft, Ve, Je) {
    let Ke = Date.now();
    for (let Qe = 0; Qe < Ft; Qe++) {
      Je(Qe);
      const bt = Date.now() - Ke;
      bt >= 0 && bt < Ve || (await (0, B.nextTick)(), Ke += bt);
    }
  }
  function vt(Ft) {
    if (typeof Ft != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof Ft);
    return new Uint8Array(new TextEncoder().encode(Ft));
  }
  function Bt(Ft) {
    return typeof Ft == "string" && (Ft = vt(Ft)), (0, Y.abytes)(Ft), Ft;
  }
  function Ct(...Ft) {
    let Ve = 0;
    for (let Ke = 0; Ke < Ft.length; Ke++) {
      const Qe = Ft[Ke];
      (0, Y.abytes)(Qe), Ve += Qe.length;
    }
    const Je = new Uint8Array(Ve);
    for (let Ke = 0, Qe = 0; Ke < Ft.length; Ke++) {
      const bt = Ft[Ke];
      Je.set(bt, Qe), Qe += bt.length;
    }
    return Je;
  }
  class Wt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = Wt;
  function Kt(Ft, Ve) {
    if (Ve !== void 0 && {}.toString.call(Ve) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Ft, Ve);
  }
  function Yt(Ft) {
    const Ve = (Ke) => Ft().update(Bt(Ke)).digest(), Je = Ft();
    return Ve.outputLen = Je.outputLen, Ve.blockLen = Je.blockLen, Ve.create = () => Ft(), Ve;
  }
  function Ut(Ft) {
    const Ve = (Ke, Qe) => Ft(Qe).update(Bt(Ke)).digest(), Je = Ft({});
    return Ve.outputLen = Je.outputLen, Ve.blockLen = Je.blockLen, Ve.create = (Ke) => Ft(Ke), Ve;
  }
  function qt(Ft) {
    const Ve = (Ke, Qe) => Ft(Qe).update(Bt(Ke)).digest(), Je = Ft({});
    return Ve.outputLen = Je.outputLen, Ve.blockLen = Je.blockLen, Ve.create = (Ke) => Ft(Ke), Ve;
  }
  function zt(Ft = 32) {
    if (z.crypto && typeof z.crypto.getRandomValues == "function")
      return z.crypto.getRandomValues(new Uint8Array(Ft));
    if (z.crypto && typeof z.crypto.randomBytes == "function")
      return z.crypto.randomBytes(Ft);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const z = _assert, Y = utils$5;
  class ne extends Y.Hash {
    constructor(ae, se) {
      super(), this.finished = !1, this.destroyed = !1, (0, z.ahash)(ae);
      const ve = (0, Y.toBytes)(se);
      if (this.iHash = ae.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const ge = this.blockLen, le = new Uint8Array(ge);
      le.set(ve.length > ge ? ae.create().update(ve).digest() : ve);
      for (let Ee = 0; Ee < le.length; Ee++)
        le[Ee] ^= 54;
      this.iHash.update(le), this.oHash = ae.create();
      for (let Ee = 0; Ee < le.length; Ee++)
        le[Ee] ^= 106;
      this.oHash.update(le), le.fill(0);
    }
    update(ae) {
      return (0, z.aexists)(this), this.iHash.update(ae), this;
    }
    digestInto(ae) {
      (0, z.aexists)(this), (0, z.abytes)(ae, this.outputLen), this.finished = !0, this.iHash.digestInto(ae), this.oHash.update(ae), this.oHash.digestInto(ae), this.destroy();
    }
    digest() {
      const ae = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(ae), ae;
    }
    _cloneInto(ae) {
      ae || (ae = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: se, iHash: ve, finished: ge, destroyed: le, blockLen: Ee, outputLen: Ce } = this;
      return ae = ae, ae.finished = ge, ae.destroyed = le, ae.blockLen = Ee, ae.outputLen = Ce, ae.oHash = se._cloneInto(ae.oHash), ae.iHash = ve._cloneInto(ae.iHash), ae;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = ne;
  const oe = (ie, ae, se) => new ne(ie, ae).update(se).digest();
  B.hmac = oe, B.hmac.create = (ie, ae) => new ne(ie, ae);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(B, z, Y, ne) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(z, Y, ne);
  const oe = BigInt(32), ie = BigInt(4294967295), ae = Number(Y >> oe & ie), se = Number(Y & ie), ve = ne ? 4 : 0, ge = ne ? 0 : 4;
  B.setUint32(z + ve, ae, ne), B.setUint32(z + ge, se, ne);
}
function Chi(B, z, Y) {
  return B & z ^ ~B & Y;
}
function Maj(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(z, Y, ne, oe) {
    super(), this.blockLen = z, this.outputLen = Y, this.padOffset = ne, this.isLE = oe, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(z), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(z) {
    (0, _assert_js_1.aexists)(this);
    const { view: Y, buffer: ne, blockLen: oe } = this;
    z = (0, utils_js_1$3.toBytes)(z);
    const ie = z.length;
    for (let ae = 0; ae < ie; ) {
      const se = Math.min(oe - this.pos, ie - ae);
      if (se === oe) {
        const ve = (0, utils_js_1$3.createView)(z);
        for (; oe <= ie - ae; ae += oe)
          this.process(ve, ae);
        continue;
      }
      ne.set(z.subarray(ae, ae + se), this.pos), this.pos += se, ae += se, this.pos === oe && (this.process(Y, 0), this.pos = 0);
    }
    return this.length += z.length, this.roundClean(), this;
  }
  digestInto(z) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(z, this), this.finished = !0;
    const { buffer: Y, view: ne, blockLen: oe, isLE: ie } = this;
    let { pos: ae } = this;
    Y[ae++] = 128, this.buffer.subarray(ae).fill(0), this.padOffset > oe - ae && (this.process(ne, 0), ae = 0);
    for (let Ee = ae; Ee < oe; Ee++)
      Y[Ee] = 0;
    setBigUint64(ne, oe - 8, BigInt(this.length * 8), ie), this.process(ne, 0);
    const se = (0, utils_js_1$3.createView)(z), ve = this.outputLen;
    if (ve % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const ge = ve / 4, le = this.get();
    if (ge > le.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Ee = 0; Ee < ge; Ee++)
      se.setUint32(4 * Ee, le[Ee], ie);
  }
  digest() {
    const { buffer: z, outputLen: Y } = this;
    this.digestInto(z);
    const ne = z.slice(0, Y);
    return this.destroy(), ne;
  }
  _cloneInto(z) {
    z || (z = new this.constructor()), z.set(...this.get());
    const { blockLen: Y, buffer: ne, length: oe, finished: ie, destroyed: ae, pos: se } = this;
    return z.length = oe, z.pos = se, z.finished = ie, z.destroyed = ae, oe % Y && z.buffer.set(ne), z;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: oe, E: ie, F: ae, G: se, H: ve } = this;
    return [z, Y, ne, oe, ie, ae, se, ve];
  }
  // prettier-ignore
  set(z, Y, ne, oe, ie, ae, se, ve) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = oe | 0, this.E = ie | 0, this.F = ae | 0, this.G = se | 0, this.H = ve | 0;
  }
  process(z, Y) {
    for (let Ee = 0; Ee < 16; Ee++, Y += 4)
      SHA256_W[Ee] = z.getUint32(Y, !1);
    for (let Ee = 16; Ee < 64; Ee++) {
      const Ce = SHA256_W[Ee - 15], Pe = SHA256_W[Ee - 2], Xe = (0, utils_js_1$2.rotr)(Ce, 7) ^ (0, utils_js_1$2.rotr)(Ce, 18) ^ Ce >>> 3, ht = (0, utils_js_1$2.rotr)(Pe, 17) ^ (0, utils_js_1$2.rotr)(Pe, 19) ^ Pe >>> 10;
      SHA256_W[Ee] = ht + SHA256_W[Ee - 7] + Xe + SHA256_W[Ee - 16] | 0;
    }
    let { A: ne, B: oe, C: ie, D: ae, E: se, F: ve, G: ge, H: le } = this;
    for (let Ee = 0; Ee < 64; Ee++) {
      const Ce = (0, utils_js_1$2.rotr)(se, 6) ^ (0, utils_js_1$2.rotr)(se, 11) ^ (0, utils_js_1$2.rotr)(se, 25), Pe = le + Ce + (0, _md_js_1$2.Chi)(se, ve, ge) + SHA256_K[Ee] + SHA256_W[Ee] | 0, ht = ((0, utils_js_1$2.rotr)(ne, 2) ^ (0, utils_js_1$2.rotr)(ne, 13) ^ (0, utils_js_1$2.rotr)(ne, 22)) + (0, _md_js_1$2.Maj)(ne, oe, ie) | 0;
      le = ge, ge = ve, ve = se, se = ae + Pe | 0, ae = ie, ie = oe, oe = ne, ne = Pe + ht | 0;
    }
    ne = ne + this.A | 0, oe = oe + this.B | 0, ie = ie + this.C | 0, ae = ae + this.D | 0, se = se + this.E | 0, ve = ve + this.F | 0, ge = ge + this.G | 0, le = le + this.H | 0, this.set(ne, oe, ie, ae, se, ve, ge, le);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$4.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} }, dist$1 = {};
(function(B) {
  Object.defineProperties(B, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  var z = {}, Y = {};
  Y.byteLength = le, Y.toByteArray = Ce, Y.fromByteArray = ht;
  for (var ne = [], oe = [], ie = typeof Uint8Array < "u" ? Uint8Array : Array, ae = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", se = 0, ve = ae.length; se < ve; ++se)
    ne[se] = ae[se], oe[ae.charCodeAt(se)] = se;
  oe[45] = 62, oe[95] = 63;
  function ge(vt) {
    var Bt = vt.length;
    if (Bt % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var Ct = vt.indexOf("=");
    Ct === -1 && (Ct = Bt);
    var Wt = Ct === Bt ? 0 : 4 - Ct % 4;
    return [Ct, Wt];
  }
  function le(vt) {
    var Bt = ge(vt), Ct = Bt[0], Wt = Bt[1];
    return (Ct + Wt) * 3 / 4 - Wt;
  }
  function Ee(vt, Bt, Ct) {
    return (Bt + Ct) * 3 / 4 - Ct;
  }
  function Ce(vt) {
    var Bt, Ct = ge(vt), Wt = Ct[0], Kt = Ct[1], Yt = new ie(Ee(vt, Wt, Kt)), Ut = 0, qt = Kt > 0 ? Wt - 4 : Wt, zt;
    for (zt = 0; zt < qt; zt += 4)
      Bt = oe[vt.charCodeAt(zt)] << 18 | oe[vt.charCodeAt(zt + 1)] << 12 | oe[vt.charCodeAt(zt + 2)] << 6 | oe[vt.charCodeAt(zt + 3)], Yt[Ut++] = Bt >> 16 & 255, Yt[Ut++] = Bt >> 8 & 255, Yt[Ut++] = Bt & 255;
    return Kt === 2 && (Bt = oe[vt.charCodeAt(zt)] << 2 | oe[vt.charCodeAt(zt + 1)] >> 4, Yt[Ut++] = Bt & 255), Kt === 1 && (Bt = oe[vt.charCodeAt(zt)] << 10 | oe[vt.charCodeAt(zt + 1)] << 4 | oe[vt.charCodeAt(zt + 2)] >> 2, Yt[Ut++] = Bt >> 8 & 255, Yt[Ut++] = Bt & 255), Yt;
  }
  function Pe(vt) {
    return ne[vt >> 18 & 63] + ne[vt >> 12 & 63] + ne[vt >> 6 & 63] + ne[vt & 63];
  }
  function Xe(vt, Bt, Ct) {
    for (var Wt, Kt = [], Yt = Bt; Yt < Ct; Yt += 3)
      Wt = (vt[Yt] << 16 & 16711680) + (vt[Yt + 1] << 8 & 65280) + (vt[Yt + 2] & 255), Kt.push(Pe(Wt));
    return Kt.join("");
  }
  function ht(vt) {
    for (var Bt, Ct = vt.length, Wt = Ct % 3, Kt = [], Yt = 16383, Ut = 0, qt = Ct - Wt; Ut < qt; Ut += Yt)
      Kt.push(Xe(vt, Ut, Ut + Yt > qt ? qt : Ut + Yt));
    return Wt === 1 ? (Bt = vt[Ct - 1], Kt.push(
      ne[Bt >> 2] + ne[Bt << 4 & 63] + "=="
    )) : Wt === 2 && (Bt = (vt[Ct - 2] << 8) + vt[Ct - 1], Kt.push(
      ne[Bt >> 10] + ne[Bt >> 4 & 63] + ne[Bt << 2 & 63] + "="
    )), Kt.join("");
  }
  var wt = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  wt.read = function(vt, Bt, Ct, Wt, Kt) {
    var Yt, Ut, qt = Kt * 8 - Wt - 1, zt = (1 << qt) - 1, Ft = zt >> 1, Ve = -7, Je = Ct ? Kt - 1 : 0, Ke = Ct ? -1 : 1, Qe = vt[Bt + Je];
    for (Je += Ke, Yt = Qe & (1 << -Ve) - 1, Qe >>= -Ve, Ve += qt; Ve > 0; Yt = Yt * 256 + vt[Bt + Je], Je += Ke, Ve -= 8)
      ;
    for (Ut = Yt & (1 << -Ve) - 1, Yt >>= -Ve, Ve += Wt; Ve > 0; Ut = Ut * 256 + vt[Bt + Je], Je += Ke, Ve -= 8)
      ;
    if (Yt === 0)
      Yt = 1 - Ft;
    else {
      if (Yt === zt)
        return Ut ? NaN : (Qe ? -1 : 1) * (1 / 0);
      Ut = Ut + Math.pow(2, Wt), Yt = Yt - Ft;
    }
    return (Qe ? -1 : 1) * Ut * Math.pow(2, Yt - Wt);
  }, wt.write = function(vt, Bt, Ct, Wt, Kt, Yt) {
    var Ut, qt, zt, Ft = Yt * 8 - Kt - 1, Ve = (1 << Ft) - 1, Je = Ve >> 1, Ke = Kt === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Qe = Wt ? 0 : Yt - 1, bt = Wt ? 1 : -1, _t = Bt < 0 || Bt === 0 && 1 / Bt < 0 ? 1 : 0;
    for (Bt = Math.abs(Bt), isNaN(Bt) || Bt === 1 / 0 ? (qt = isNaN(Bt) ? 1 : 0, Ut = Ve) : (Ut = Math.floor(Math.log(Bt) / Math.LN2), Bt * (zt = Math.pow(2, -Ut)) < 1 && (Ut--, zt *= 2), Ut + Je >= 1 ? Bt += Ke / zt : Bt += Ke * Math.pow(2, 1 - Je), Bt * zt >= 2 && (Ut++, zt /= 2), Ut + Je >= Ve ? (qt = 0, Ut = Ve) : Ut + Je >= 1 ? (qt = (Bt * zt - 1) * Math.pow(2, Kt), Ut = Ut + Je) : (qt = Bt * Math.pow(2, Je - 1) * Math.pow(2, Kt), Ut = 0)); Kt >= 8; vt[Ct + Qe] = qt & 255, Qe += bt, qt /= 256, Kt -= 8)
      ;
    for (Ut = Ut << Kt | qt, Ft += Kt; Ft > 0; vt[Ct + Qe] = Ut & 255, Qe += bt, Ut /= 256, Ft -= 8)
      ;
    vt[Ct + Qe - bt] |= _t * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(vt) {
    const Bt = Y, Ct = wt, Wt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    vt.Buffer = Ve, vt.SlowBuffer = Ht, vt.INSPECT_MAX_BYTES = 50;
    const Kt = 2147483647;
    vt.kMaxLength = Kt;
    const { Uint8Array: Yt, ArrayBuffer: Ut, SharedArrayBuffer: qt } = globalThis;
    Ve.TYPED_ARRAY_SUPPORT = zt(), !Ve.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function zt() {
      try {
        const jt = new Yt(1), Ot = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(Ot, Yt.prototype), Object.setPrototypeOf(jt, Ot), jt.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(Ve.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (Ve.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(Ve.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (Ve.isBuffer(this))
          return this.byteOffset;
      }
    });
    function Ft(jt) {
      if (jt > Kt)
        throw new RangeError('The value "' + jt + '" is invalid for option "size"');
      const Ot = new Yt(jt);
      return Object.setPrototypeOf(Ot, Ve.prototype), Ot;
    }
    function Ve(jt, Ot, Lt) {
      if (typeof jt == "number") {
        if (typeof Ot == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return bt(jt);
      }
      return Je(jt, Ot, Lt);
    }
    Ve.poolSize = 8192;
    function Je(jt, Ot, Lt) {
      if (typeof jt == "string")
        return _t(jt, Ot);
      if (Ut.isView(jt))
        return kt(jt);
      if (jt == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof jt
        );
      if (Xr(jt, Ut) || jt && Xr(jt.buffer, Ut) || typeof qt < "u" && (Xr(jt, qt) || jt && Xr(jt.buffer, qt)))
        return xt(jt, Ot, Lt);
      if (typeof jt == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const Qt = jt.valueOf && jt.valueOf();
      if (Qt != null && Qt !== jt)
        return Ve.from(Qt, Ot, Lt);
      const or = Nt(jt);
      if (or) return or;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof jt[Symbol.toPrimitive] == "function")
        return Ve.from(jt[Symbol.toPrimitive]("string"), Ot, Lt);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof jt
      );
    }
    Ve.from = function(jt, Ot, Lt) {
      return Je(jt, Ot, Lt);
    }, Object.setPrototypeOf(Ve.prototype, Yt.prototype), Object.setPrototypeOf(Ve, Yt);
    function Ke(jt) {
      if (typeof jt != "number")
        throw new TypeError('"size" argument must be of type number');
      if (jt < 0)
        throw new RangeError('The value "' + jt + '" is invalid for option "size"');
    }
    function Qe(jt, Ot, Lt) {
      return Ke(jt), jt <= 0 ? Ft(jt) : Ot !== void 0 ? typeof Lt == "string" ? Ft(jt).fill(Ot, Lt) : Ft(jt).fill(Ot) : Ft(jt);
    }
    Ve.alloc = function(jt, Ot, Lt) {
      return Qe(jt, Ot, Lt);
    };
    function bt(jt) {
      return Ke(jt), Ft(jt < 0 ? 0 : Rt(jt) | 0);
    }
    Ve.allocUnsafe = function(jt) {
      return bt(jt);
    }, Ve.allocUnsafeSlow = function(jt) {
      return bt(jt);
    };
    function _t(jt, Ot) {
      if ((typeof Ot != "string" || Ot === "") && (Ot = "utf8"), !Ve.isEncoding(Ot))
        throw new TypeError("Unknown encoding: " + Ot);
      const Lt = ar(jt, Ot) | 0;
      let Qt = Ft(Lt);
      const or = Qt.write(jt, Ot);
      return or !== Lt && (Qt = Qt.slice(0, or)), Qt;
    }
    function $t(jt) {
      const Ot = jt.length < 0 ? 0 : Rt(jt.length) | 0, Lt = Ft(Ot);
      for (let Qt = 0; Qt < Ot; Qt += 1)
        Lt[Qt] = jt[Qt] & 255;
      return Lt;
    }
    function kt(jt) {
      if (Xr(jt, Yt)) {
        const Ot = new Yt(jt);
        return xt(Ot.buffer, Ot.byteOffset, Ot.byteLength);
      }
      return $t(jt);
    }
    function xt(jt, Ot, Lt) {
      if (Ot < 0 || jt.byteLength < Ot)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (jt.byteLength < Ot + (Lt || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let Qt;
      return Ot === void 0 && Lt === void 0 ? Qt = new Yt(jt) : Lt === void 0 ? Qt = new Yt(jt, Ot) : Qt = new Yt(jt, Ot, Lt), Object.setPrototypeOf(Qt, Ve.prototype), Qt;
    }
    function Nt(jt) {
      if (Ve.isBuffer(jt)) {
        const Ot = Rt(jt.length) | 0, Lt = Ft(Ot);
        return Lt.length === 0 || jt.copy(Lt, 0, 0, Ot), Lt;
      }
      if (jt.length !== void 0)
        return typeof jt.length != "number" || Zr(jt.length) ? Ft(0) : $t(jt);
      if (jt.type === "Buffer" && Array.isArray(jt.data))
        return $t(jt.data);
    }
    function Rt(jt) {
      if (jt >= Kt)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Kt.toString(16) + " bytes");
      return jt | 0;
    }
    function Ht(jt) {
      return +jt != jt && (jt = 0), Ve.alloc(+jt);
    }
    Ve.isBuffer = function(Ot) {
      return Ot != null && Ot._isBuffer === !0 && Ot !== Ve.prototype;
    }, Ve.compare = function(Ot, Lt) {
      if (Xr(Ot, Yt) && (Ot = Ve.from(Ot, Ot.offset, Ot.byteLength)), Xr(Lt, Yt) && (Lt = Ve.from(Lt, Lt.offset, Lt.byteLength)), !Ve.isBuffer(Ot) || !Ve.isBuffer(Lt))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (Ot === Lt) return 0;
      let Qt = Ot.length, or = Lt.length;
      for (let hr = 0, yr = Math.min(Qt, or); hr < yr; ++hr)
        if (Ot[hr] !== Lt[hr]) {
          Qt = Ot[hr], or = Lt[hr];
          break;
        }
      return Qt < or ? -1 : or < Qt ? 1 : 0;
    }, Ve.isEncoding = function(Ot) {
      switch (String(Ot).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, Ve.concat = function(Ot, Lt) {
      if (!Array.isArray(Ot))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (Ot.length === 0)
        return Ve.alloc(0);
      let Qt;
      if (Lt === void 0)
        for (Lt = 0, Qt = 0; Qt < Ot.length; ++Qt)
          Lt += Ot[Qt].length;
      const or = Ve.allocUnsafe(Lt);
      let hr = 0;
      for (Qt = 0; Qt < Ot.length; ++Qt) {
        let yr = Ot[Qt];
        if (Xr(yr, Yt))
          hr + yr.length > or.length ? (Ve.isBuffer(yr) || (yr = Ve.from(yr)), yr.copy(or, hr)) : Yt.prototype.set.call(
            or,
            yr,
            hr
          );
        else if (Ve.isBuffer(yr))
          yr.copy(or, hr);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        hr += yr.length;
      }
      return or;
    };
    function ar(jt, Ot) {
      if (Ve.isBuffer(jt))
        return jt.length;
      if (Ut.isView(jt) || Xr(jt, Ut))
        return jt.byteLength;
      if (typeof jt != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof jt
        );
      const Lt = jt.length, Qt = arguments.length > 2 && arguments[2] === !0;
      if (!Qt && Lt === 0) return 0;
      let or = !1;
      for (; ; )
        switch (Ot) {
          case "ascii":
          case "latin1":
          case "binary":
            return Lt;
          case "utf8":
          case "utf-8":
            return Wr(jt).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Lt * 2;
          case "hex":
            return Lt >>> 1;
          case "base64":
            return Lr(jt).length;
          default:
            if (or)
              return Qt ? -1 : Wr(jt).length;
            Ot = ("" + Ot).toLowerCase(), or = !0;
        }
    }
    Ve.byteLength = ar;
    function lr(jt, Ot, Lt) {
      let Qt = !1;
      if ((Ot === void 0 || Ot < 0) && (Ot = 0), Ot > this.length || ((Lt === void 0 || Lt > this.length) && (Lt = this.length), Lt <= 0) || (Lt >>>= 0, Ot >>>= 0, Lt <= Ot))
        return "";
      for (jt || (jt = "utf8"); ; )
        switch (jt) {
          case "hex":
            return Gr(this, Ot, Lt);
          case "utf8":
          case "utf-8":
            return Ar(this, Ot, Lt);
          case "ascii":
            return Ir(this, Ot, Lt);
          case "latin1":
          case "binary":
            return wr(this, Ot, Lt);
          case "base64":
            return _r(this, Ot, Lt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Pr(this, Ot, Lt);
          default:
            if (Qt) throw new TypeError("Unknown encoding: " + jt);
            jt = (jt + "").toLowerCase(), Qt = !0;
        }
    }
    Ve.prototype._isBuffer = !0;
    function nr(jt, Ot, Lt) {
      const Qt = jt[Ot];
      jt[Ot] = jt[Lt], jt[Lt] = Qt;
    }
    Ve.prototype.swap16 = function() {
      const Ot = this.length;
      if (Ot % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let Lt = 0; Lt < Ot; Lt += 2)
        nr(this, Lt, Lt + 1);
      return this;
    }, Ve.prototype.swap32 = function() {
      const Ot = this.length;
      if (Ot % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let Lt = 0; Lt < Ot; Lt += 4)
        nr(this, Lt, Lt + 3), nr(this, Lt + 1, Lt + 2);
      return this;
    }, Ve.prototype.swap64 = function() {
      const Ot = this.length;
      if (Ot % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let Lt = 0; Lt < Ot; Lt += 8)
        nr(this, Lt, Lt + 7), nr(this, Lt + 1, Lt + 6), nr(this, Lt + 2, Lt + 5), nr(this, Lt + 3, Lt + 4);
      return this;
    }, Ve.prototype.toString = function() {
      const Ot = this.length;
      return Ot === 0 ? "" : arguments.length === 0 ? Ar(this, 0, Ot) : lr.apply(this, arguments);
    }, Ve.prototype.toLocaleString = Ve.prototype.toString, Ve.prototype.equals = function(Ot) {
      if (!Ve.isBuffer(Ot)) throw new TypeError("Argument must be a Buffer");
      return this === Ot ? !0 : Ve.compare(this, Ot) === 0;
    }, Ve.prototype.inspect = function() {
      let Ot = "";
      const Lt = vt.INSPECT_MAX_BYTES;
      return Ot = this.toString("hex", 0, Lt).replace(/(.{2})/g, "$1 ").trim(), this.length > Lt && (Ot += " ... "), "<Buffer " + Ot + ">";
    }, Wt && (Ve.prototype[Wt] = Ve.prototype.inspect), Ve.prototype.compare = function(Ot, Lt, Qt, or, hr) {
      if (Xr(Ot, Yt) && (Ot = Ve.from(Ot, Ot.offset, Ot.byteLength)), !Ve.isBuffer(Ot))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Ot
        );
      if (Lt === void 0 && (Lt = 0), Qt === void 0 && (Qt = Ot ? Ot.length : 0), or === void 0 && (or = 0), hr === void 0 && (hr = this.length), Lt < 0 || Qt > Ot.length || or < 0 || hr > this.length)
        throw new RangeError("out of range index");
      if (or >= hr && Lt >= Qt)
        return 0;
      if (or >= hr)
        return -1;
      if (Lt >= Qt)
        return 1;
      if (Lt >>>= 0, Qt >>>= 0, or >>>= 0, hr >>>= 0, this === Ot) return 0;
      let yr = hr - or, xr = Qt - Lt;
      const Rr = Math.min(yr, xr), ir = this.slice(or, hr), vr = Ot.slice(Lt, Qt);
      for (let Er = 0; Er < Rr; ++Er)
        if (ir[Er] !== vr[Er]) {
          yr = ir[Er], xr = vr[Er];
          break;
        }
      return yr < xr ? -1 : xr < yr ? 1 : 0;
    };
    function Vt(jt, Ot, Lt, Qt, or) {
      if (jt.length === 0) return -1;
      if (typeof Lt == "string" ? (Qt = Lt, Lt = 0) : Lt > 2147483647 ? Lt = 2147483647 : Lt < -2147483648 && (Lt = -2147483648), Lt = +Lt, Zr(Lt) && (Lt = or ? 0 : jt.length - 1), Lt < 0 && (Lt = jt.length + Lt), Lt >= jt.length) {
        if (or) return -1;
        Lt = jt.length - 1;
      } else if (Lt < 0)
        if (or) Lt = 0;
        else return -1;
      if (typeof Ot == "string" && (Ot = Ve.from(Ot, Qt)), Ve.isBuffer(Ot))
        return Ot.length === 0 ? -1 : Xt(jt, Ot, Lt, Qt, or);
      if (typeof Ot == "number")
        return Ot = Ot & 255, typeof Yt.prototype.indexOf == "function" ? or ? Yt.prototype.indexOf.call(jt, Ot, Lt) : Yt.prototype.lastIndexOf.call(jt, Ot, Lt) : Xt(jt, [Ot], Lt, Qt, or);
      throw new TypeError("val must be string, number or Buffer");
    }
    function Xt(jt, Ot, Lt, Qt, or) {
      let hr = 1, yr = jt.length, xr = Ot.length;
      if (Qt !== void 0 && (Qt = String(Qt).toLowerCase(), Qt === "ucs2" || Qt === "ucs-2" || Qt === "utf16le" || Qt === "utf-16le")) {
        if (jt.length < 2 || Ot.length < 2)
          return -1;
        hr = 2, yr /= 2, xr /= 2, Lt /= 2;
      }
      function Rr(vr, Er) {
        return hr === 1 ? vr[Er] : vr.readUInt16BE(Er * hr);
      }
      let ir;
      if (or) {
        let vr = -1;
        for (ir = Lt; ir < yr; ir++)
          if (Rr(jt, ir) === Rr(Ot, vr === -1 ? 0 : ir - vr)) {
            if (vr === -1 && (vr = ir), ir - vr + 1 === xr) return vr * hr;
          } else
            vr !== -1 && (ir -= ir - vr), vr = -1;
      } else
        for (Lt + xr > yr && (Lt = yr - xr), ir = Lt; ir >= 0; ir--) {
          let vr = !0;
          for (let Er = 0; Er < xr; Er++)
            if (Rr(jt, ir + Er) !== Rr(Ot, Er)) {
              vr = !1;
              break;
            }
          if (vr) return ir;
        }
      return -1;
    }
    Ve.prototype.includes = function(Ot, Lt, Qt) {
      return this.indexOf(Ot, Lt, Qt) !== -1;
    }, Ve.prototype.indexOf = function(Ot, Lt, Qt) {
      return Vt(this, Ot, Lt, Qt, !0);
    }, Ve.prototype.lastIndexOf = function(Ot, Lt, Qt) {
      return Vt(this, Ot, Lt, Qt, !1);
    };
    function sr(jt, Ot, Lt, Qt) {
      Lt = Number(Lt) || 0;
      const or = jt.length - Lt;
      Qt ? (Qt = Number(Qt), Qt > or && (Qt = or)) : Qt = or;
      const hr = Ot.length;
      Qt > hr / 2 && (Qt = hr / 2);
      let yr;
      for (yr = 0; yr < Qt; ++yr) {
        const xr = parseInt(Ot.substr(yr * 2, 2), 16);
        if (Zr(xr)) return yr;
        jt[Lt + yr] = xr;
      }
      return yr;
    }
    function dr(jt, Ot, Lt, Qt) {
      return Fr(Wr(Ot, jt.length - Lt), jt, Lt, Qt);
    }
    function er(jt, Ot, Lt, Qt) {
      return Fr(kr(Ot), jt, Lt, Qt);
    }
    function Zt(jt, Ot, Lt, Qt) {
      return Fr(Lr(Ot), jt, Lt, Qt);
    }
    function pr(jt, Ot, Lt, Qt) {
      return Fr(jr(Ot, jt.length - Lt), jt, Lt, Qt);
    }
    Ve.prototype.write = function(Ot, Lt, Qt, or) {
      if (Lt === void 0)
        or = "utf8", Qt = this.length, Lt = 0;
      else if (Qt === void 0 && typeof Lt == "string")
        or = Lt, Qt = this.length, Lt = 0;
      else if (isFinite(Lt))
        Lt = Lt >>> 0, isFinite(Qt) ? (Qt = Qt >>> 0, or === void 0 && (or = "utf8")) : (or = Qt, Qt = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const hr = this.length - Lt;
      if ((Qt === void 0 || Qt > hr) && (Qt = hr), Ot.length > 0 && (Qt < 0 || Lt < 0) || Lt > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      or || (or = "utf8");
      let yr = !1;
      for (; ; )
        switch (or) {
          case "hex":
            return sr(this, Ot, Lt, Qt);
          case "utf8":
          case "utf-8":
            return dr(this, Ot, Lt, Qt);
          case "ascii":
          case "latin1":
          case "binary":
            return er(this, Ot, Lt, Qt);
          case "base64":
            return Zt(this, Ot, Lt, Qt);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return pr(this, Ot, Lt, Qt);
          default:
            if (yr) throw new TypeError("Unknown encoding: " + or);
            or = ("" + or).toLowerCase(), yr = !0;
        }
    }, Ve.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function _r(jt, Ot, Lt) {
      return Ot === 0 && Lt === jt.length ? Bt.fromByteArray(jt) : Bt.fromByteArray(jt.slice(Ot, Lt));
    }
    function Ar(jt, Ot, Lt) {
      Lt = Math.min(jt.length, Lt);
      const Qt = [];
      let or = Ot;
      for (; or < Lt; ) {
        const hr = jt[or];
        let yr = null, xr = hr > 239 ? 4 : hr > 223 ? 3 : hr > 191 ? 2 : 1;
        if (or + xr <= Lt) {
          let Rr, ir, vr, Er;
          switch (xr) {
            case 1:
              hr < 128 && (yr = hr);
              break;
            case 2:
              Rr = jt[or + 1], (Rr & 192) === 128 && (Er = (hr & 31) << 6 | Rr & 63, Er > 127 && (yr = Er));
              break;
            case 3:
              Rr = jt[or + 1], ir = jt[or + 2], (Rr & 192) === 128 && (ir & 192) === 128 && (Er = (hr & 15) << 12 | (Rr & 63) << 6 | ir & 63, Er > 2047 && (Er < 55296 || Er > 57343) && (yr = Er));
              break;
            case 4:
              Rr = jt[or + 1], ir = jt[or + 2], vr = jt[or + 3], (Rr & 192) === 128 && (ir & 192) === 128 && (vr & 192) === 128 && (Er = (hr & 15) << 18 | (Rr & 63) << 12 | (ir & 63) << 6 | vr & 63, Er > 65535 && Er < 1114112 && (yr = Er));
          }
        }
        yr === null ? (yr = 65533, xr = 1) : yr > 65535 && (yr -= 65536, Qt.push(yr >>> 10 & 1023 | 55296), yr = 56320 | yr & 1023), Qt.push(yr), or += xr;
      }
      return Br(Qt);
    }
    const Sr = 4096;
    function Br(jt) {
      const Ot = jt.length;
      if (Ot <= Sr)
        return String.fromCharCode.apply(String, jt);
      let Lt = "", Qt = 0;
      for (; Qt < Ot; )
        Lt += String.fromCharCode.apply(
          String,
          jt.slice(Qt, Qt += Sr)
        );
      return Lt;
    }
    function Ir(jt, Ot, Lt) {
      let Qt = "";
      Lt = Math.min(jt.length, Lt);
      for (let or = Ot; or < Lt; ++or)
        Qt += String.fromCharCode(jt[or] & 127);
      return Qt;
    }
    function wr(jt, Ot, Lt) {
      let Qt = "";
      Lt = Math.min(jt.length, Lt);
      for (let or = Ot; or < Lt; ++or)
        Qt += String.fromCharCode(jt[or]);
      return Qt;
    }
    function Gr(jt, Ot, Lt) {
      const Qt = jt.length;
      (!Ot || Ot < 0) && (Ot = 0), (!Lt || Lt < 0 || Lt > Qt) && (Lt = Qt);
      let or = "";
      for (let hr = Ot; hr < Lt; ++hr)
        or += fr[jt[hr]];
      return or;
    }
    function Pr(jt, Ot, Lt) {
      const Qt = jt.slice(Ot, Lt);
      let or = "";
      for (let hr = 0; hr < Qt.length - 1; hr += 2)
        or += String.fromCharCode(Qt[hr] + Qt[hr + 1] * 256);
      return or;
    }
    Ve.prototype.slice = function(Ot, Lt) {
      const Qt = this.length;
      Ot = ~~Ot, Lt = Lt === void 0 ? Qt : ~~Lt, Ot < 0 ? (Ot += Qt, Ot < 0 && (Ot = 0)) : Ot > Qt && (Ot = Qt), Lt < 0 ? (Lt += Qt, Lt < 0 && (Lt = 0)) : Lt > Qt && (Lt = Qt), Lt < Ot && (Lt = Ot);
      const or = this.subarray(Ot, Lt);
      return Object.setPrototypeOf(or, Ve.prototype), or;
    };
    function Mr(jt, Ot, Lt) {
      if (jt % 1 !== 0 || jt < 0) throw new RangeError("offset is not uint");
      if (jt + Ot > Lt) throw new RangeError("Trying to access beyond buffer length");
    }
    Ve.prototype.readUintLE = Ve.prototype.readUIntLE = function(Ot, Lt, Qt) {
      Ot = Ot >>> 0, Lt = Lt >>> 0, Qt || Mr(Ot, Lt, this.length);
      let or = this[Ot], hr = 1, yr = 0;
      for (; ++yr < Lt && (hr *= 256); )
        or += this[Ot + yr] * hr;
      return or;
    }, Ve.prototype.readUintBE = Ve.prototype.readUIntBE = function(Ot, Lt, Qt) {
      Ot = Ot >>> 0, Lt = Lt >>> 0, Qt || Mr(Ot, Lt, this.length);
      let or = this[Ot + --Lt], hr = 1;
      for (; Lt > 0 && (hr *= 256); )
        or += this[Ot + --Lt] * hr;
      return or;
    }, Ve.prototype.readUint8 = Ve.prototype.readUInt8 = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 1, this.length), this[Ot];
    }, Ve.prototype.readUint16LE = Ve.prototype.readUInt16LE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 2, this.length), this[Ot] | this[Ot + 1] << 8;
    }, Ve.prototype.readUint16BE = Ve.prototype.readUInt16BE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 2, this.length), this[Ot] << 8 | this[Ot + 1];
    }, Ve.prototype.readUint32LE = Ve.prototype.readUInt32LE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 4, this.length), (this[Ot] | this[Ot + 1] << 8 | this[Ot + 2] << 16) + this[Ot + 3] * 16777216;
    }, Ve.prototype.readUint32BE = Ve.prototype.readUInt32BE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 4, this.length), this[Ot] * 16777216 + (this[Ot + 1] << 16 | this[Ot + 2] << 8 | this[Ot + 3]);
    }, Ve.prototype.readBigUInt64LE = tr(function(Ot) {
      Ot = Ot >>> 0, cr(Ot, "offset");
      const Lt = this[Ot], Qt = this[Ot + 7];
      (Lt === void 0 || Qt === void 0) && br(Ot, this.length - 8);
      const or = Lt + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 24, hr = this[++Ot] + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + Qt * 2 ** 24;
      return BigInt(or) + (BigInt(hr) << BigInt(32));
    }), Ve.prototype.readBigUInt64BE = tr(function(Ot) {
      Ot = Ot >>> 0, cr(Ot, "offset");
      const Lt = this[Ot], Qt = this[Ot + 7];
      (Lt === void 0 || Qt === void 0) && br(Ot, this.length - 8);
      const or = Lt * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + this[++Ot], hr = this[++Ot] * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + Qt;
      return (BigInt(or) << BigInt(32)) + BigInt(hr);
    }), Ve.prototype.readIntLE = function(Ot, Lt, Qt) {
      Ot = Ot >>> 0, Lt = Lt >>> 0, Qt || Mr(Ot, Lt, this.length);
      let or = this[Ot], hr = 1, yr = 0;
      for (; ++yr < Lt && (hr *= 256); )
        or += this[Ot + yr] * hr;
      return hr *= 128, or >= hr && (or -= Math.pow(2, 8 * Lt)), or;
    }, Ve.prototype.readIntBE = function(Ot, Lt, Qt) {
      Ot = Ot >>> 0, Lt = Lt >>> 0, Qt || Mr(Ot, Lt, this.length);
      let or = Lt, hr = 1, yr = this[Ot + --or];
      for (; or > 0 && (hr *= 256); )
        yr += this[Ot + --or] * hr;
      return hr *= 128, yr >= hr && (yr -= Math.pow(2, 8 * Lt)), yr;
    }, Ve.prototype.readInt8 = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 1, this.length), this[Ot] & 128 ? (255 - this[Ot] + 1) * -1 : this[Ot];
    }, Ve.prototype.readInt16LE = function(Ot, Lt) {
      Ot = Ot >>> 0, Lt || Mr(Ot, 2, this.length);
      const Qt = this[Ot] | this[Ot + 1] << 8;
      return Qt & 32768 ? Qt | 4294901760 : Qt;
    }, Ve.prototype.readInt16BE = function(Ot, Lt) {
      Ot = Ot >>> 0, Lt || Mr(Ot, 2, this.length);
      const Qt = this[Ot + 1] | this[Ot] << 8;
      return Qt & 32768 ? Qt | 4294901760 : Qt;
    }, Ve.prototype.readInt32LE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 4, this.length), this[Ot] | this[Ot + 1] << 8 | this[Ot + 2] << 16 | this[Ot + 3] << 24;
    }, Ve.prototype.readInt32BE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 4, this.length), this[Ot] << 24 | this[Ot + 1] << 16 | this[Ot + 2] << 8 | this[Ot + 3];
    }, Ve.prototype.readBigInt64LE = tr(function(Ot) {
      Ot = Ot >>> 0, cr(Ot, "offset");
      const Lt = this[Ot], Qt = this[Ot + 7];
      (Lt === void 0 || Qt === void 0) && br(Ot, this.length - 8);
      const or = this[Ot + 4] + this[Ot + 5] * 2 ** 8 + this[Ot + 6] * 2 ** 16 + (Qt << 24);
      return (BigInt(or) << BigInt(32)) + BigInt(Lt + this[++Ot] * 2 ** 8 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 24);
    }), Ve.prototype.readBigInt64BE = tr(function(Ot) {
      Ot = Ot >>> 0, cr(Ot, "offset");
      const Lt = this[Ot], Qt = this[Ot + 7];
      (Lt === void 0 || Qt === void 0) && br(Ot, this.length - 8);
      const or = (Lt << 24) + // Overflow
      this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + this[++Ot];
      return (BigInt(or) << BigInt(32)) + BigInt(this[++Ot] * 2 ** 24 + this[++Ot] * 2 ** 16 + this[++Ot] * 2 ** 8 + Qt);
    }), Ve.prototype.readFloatLE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 4, this.length), Ct.read(this, Ot, !0, 23, 4);
    }, Ve.prototype.readFloatBE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 4, this.length), Ct.read(this, Ot, !1, 23, 4);
    }, Ve.prototype.readDoubleLE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 8, this.length), Ct.read(this, Ot, !0, 52, 8);
    }, Ve.prototype.readDoubleBE = function(Ot, Lt) {
      return Ot = Ot >>> 0, Lt || Mr(Ot, 8, this.length), Ct.read(this, Ot, !1, 52, 8);
    };
    function Cr(jt, Ot, Lt, Qt, or, hr) {
      if (!Ve.isBuffer(jt)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (Ot > or || Ot < hr) throw new RangeError('"value" argument is out of bounds');
      if (Lt + Qt > jt.length) throw new RangeError("Index out of range");
    }
    Ve.prototype.writeUintLE = Ve.prototype.writeUIntLE = function(Ot, Lt, Qt, or) {
      if (Ot = +Ot, Lt = Lt >>> 0, Qt = Qt >>> 0, !or) {
        const xr = Math.pow(2, 8 * Qt) - 1;
        Cr(this, Ot, Lt, Qt, xr, 0);
      }
      let hr = 1, yr = 0;
      for (this[Lt] = Ot & 255; ++yr < Qt && (hr *= 256); )
        this[Lt + yr] = Ot / hr & 255;
      return Lt + Qt;
    }, Ve.prototype.writeUintBE = Ve.prototype.writeUIntBE = function(Ot, Lt, Qt, or) {
      if (Ot = +Ot, Lt = Lt >>> 0, Qt = Qt >>> 0, !or) {
        const xr = Math.pow(2, 8 * Qt) - 1;
        Cr(this, Ot, Lt, Qt, xr, 0);
      }
      let hr = Qt - 1, yr = 1;
      for (this[Lt + hr] = Ot & 255; --hr >= 0 && (yr *= 256); )
        this[Lt + hr] = Ot / yr & 255;
      return Lt + Qt;
    }, Ve.prototype.writeUint8 = Ve.prototype.writeUInt8 = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 1, 255, 0), this[Lt] = Ot & 255, Lt + 1;
    }, Ve.prototype.writeUint16LE = Ve.prototype.writeUInt16LE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 2, 65535, 0), this[Lt] = Ot & 255, this[Lt + 1] = Ot >>> 8, Lt + 2;
    }, Ve.prototype.writeUint16BE = Ve.prototype.writeUInt16BE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 2, 65535, 0), this[Lt] = Ot >>> 8, this[Lt + 1] = Ot & 255, Lt + 2;
    }, Ve.prototype.writeUint32LE = Ve.prototype.writeUInt32LE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 4, 4294967295, 0), this[Lt + 3] = Ot >>> 24, this[Lt + 2] = Ot >>> 16, this[Lt + 1] = Ot >>> 8, this[Lt] = Ot & 255, Lt + 4;
    }, Ve.prototype.writeUint32BE = Ve.prototype.writeUInt32BE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 4, 4294967295, 0), this[Lt] = Ot >>> 24, this[Lt + 1] = Ot >>> 16, this[Lt + 2] = Ot >>> 8, this[Lt + 3] = Ot & 255, Lt + 4;
    };
    function Tr(jt, Ot, Lt, Qt, or) {
      rr(Ot, Qt, or, jt, Lt, 7);
      let hr = Number(Ot & BigInt(4294967295));
      jt[Lt++] = hr, hr = hr >> 8, jt[Lt++] = hr, hr = hr >> 8, jt[Lt++] = hr, hr = hr >> 8, jt[Lt++] = hr;
      let yr = Number(Ot >> BigInt(32) & BigInt(4294967295));
      return jt[Lt++] = yr, yr = yr >> 8, jt[Lt++] = yr, yr = yr >> 8, jt[Lt++] = yr, yr = yr >> 8, jt[Lt++] = yr, Lt;
    }
    function Hr(jt, Ot, Lt, Qt, or) {
      rr(Ot, Qt, or, jt, Lt, 7);
      let hr = Number(Ot & BigInt(4294967295));
      jt[Lt + 7] = hr, hr = hr >> 8, jt[Lt + 6] = hr, hr = hr >> 8, jt[Lt + 5] = hr, hr = hr >> 8, jt[Lt + 4] = hr;
      let yr = Number(Ot >> BigInt(32) & BigInt(4294967295));
      return jt[Lt + 3] = yr, yr = yr >> 8, jt[Lt + 2] = yr, yr = yr >> 8, jt[Lt + 1] = yr, yr = yr >> 8, jt[Lt] = yr, Lt + 8;
    }
    Ve.prototype.writeBigUInt64LE = tr(function(Ot, Lt = 0) {
      return Tr(this, Ot, Lt, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Ve.prototype.writeBigUInt64BE = tr(function(Ot, Lt = 0) {
      return Hr(this, Ot, Lt, BigInt(0), BigInt("0xffffffffffffffff"));
    }), Ve.prototype.writeIntLE = function(Ot, Lt, Qt, or) {
      if (Ot = +Ot, Lt = Lt >>> 0, !or) {
        const Rr = Math.pow(2, 8 * Qt - 1);
        Cr(this, Ot, Lt, Qt, Rr - 1, -Rr);
      }
      let hr = 0, yr = 1, xr = 0;
      for (this[Lt] = Ot & 255; ++hr < Qt && (yr *= 256); )
        Ot < 0 && xr === 0 && this[Lt + hr - 1] !== 0 && (xr = 1), this[Lt + hr] = (Ot / yr >> 0) - xr & 255;
      return Lt + Qt;
    }, Ve.prototype.writeIntBE = function(Ot, Lt, Qt, or) {
      if (Ot = +Ot, Lt = Lt >>> 0, !or) {
        const Rr = Math.pow(2, 8 * Qt - 1);
        Cr(this, Ot, Lt, Qt, Rr - 1, -Rr);
      }
      let hr = Qt - 1, yr = 1, xr = 0;
      for (this[Lt + hr] = Ot & 255; --hr >= 0 && (yr *= 256); )
        Ot < 0 && xr === 0 && this[Lt + hr + 1] !== 0 && (xr = 1), this[Lt + hr] = (Ot / yr >> 0) - xr & 255;
      return Lt + Qt;
    }, Ve.prototype.writeInt8 = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 1, 127, -128), Ot < 0 && (Ot = 255 + Ot + 1), this[Lt] = Ot & 255, Lt + 1;
    }, Ve.prototype.writeInt16LE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 2, 32767, -32768), this[Lt] = Ot & 255, this[Lt + 1] = Ot >>> 8, Lt + 2;
    }, Ve.prototype.writeInt16BE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 2, 32767, -32768), this[Lt] = Ot >>> 8, this[Lt + 1] = Ot & 255, Lt + 2;
    }, Ve.prototype.writeInt32LE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 4, 2147483647, -2147483648), this[Lt] = Ot & 255, this[Lt + 1] = Ot >>> 8, this[Lt + 2] = Ot >>> 16, this[Lt + 3] = Ot >>> 24, Lt + 4;
    }, Ve.prototype.writeInt32BE = function(Ot, Lt, Qt) {
      return Ot = +Ot, Lt = Lt >>> 0, Qt || Cr(this, Ot, Lt, 4, 2147483647, -2147483648), Ot < 0 && (Ot = 4294967295 + Ot + 1), this[Lt] = Ot >>> 24, this[Lt + 1] = Ot >>> 16, this[Lt + 2] = Ot >>> 8, this[Lt + 3] = Ot & 255, Lt + 4;
    }, Ve.prototype.writeBigInt64LE = tr(function(Ot, Lt = 0) {
      return Tr(this, Ot, Lt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), Ve.prototype.writeBigInt64BE = tr(function(Ot, Lt = 0) {
      return Hr(this, Ot, Lt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function Yr(jt, Ot, Lt, Qt, or, hr) {
      if (Lt + Qt > jt.length) throw new RangeError("Index out of range");
      if (Lt < 0) throw new RangeError("Index out of range");
    }
    function Nr(jt, Ot, Lt, Qt, or) {
      return Ot = +Ot, Lt = Lt >>> 0, or || Yr(jt, Ot, Lt, 4), Ct.write(jt, Ot, Lt, Qt, 23, 4), Lt + 4;
    }
    Ve.prototype.writeFloatLE = function(Ot, Lt, Qt) {
      return Nr(this, Ot, Lt, !0, Qt);
    }, Ve.prototype.writeFloatBE = function(Ot, Lt, Qt) {
      return Nr(this, Ot, Lt, !1, Qt);
    };
    function zr(jt, Ot, Lt, Qt, or) {
      return Ot = +Ot, Lt = Lt >>> 0, or || Yr(jt, Ot, Lt, 8), Ct.write(jt, Ot, Lt, Qt, 52, 8), Lt + 8;
    }
    Ve.prototype.writeDoubleLE = function(Ot, Lt, Qt) {
      return zr(this, Ot, Lt, !0, Qt);
    }, Ve.prototype.writeDoubleBE = function(Ot, Lt, Qt) {
      return zr(this, Ot, Lt, !1, Qt);
    }, Ve.prototype.copy = function(Ot, Lt, Qt, or) {
      if (!Ve.isBuffer(Ot)) throw new TypeError("argument should be a Buffer");
      if (Qt || (Qt = 0), !or && or !== 0 && (or = this.length), Lt >= Ot.length && (Lt = Ot.length), Lt || (Lt = 0), or > 0 && or < Qt && (or = Qt), or === Qt || Ot.length === 0 || this.length === 0) return 0;
      if (Lt < 0)
        throw new RangeError("targetStart out of bounds");
      if (Qt < 0 || Qt >= this.length) throw new RangeError("Index out of range");
      if (or < 0) throw new RangeError("sourceEnd out of bounds");
      or > this.length && (or = this.length), Ot.length - Lt < or - Qt && (or = Ot.length - Lt + Qt);
      const hr = or - Qt;
      return this === Ot && typeof Yt.prototype.copyWithin == "function" ? this.copyWithin(Lt, Qt, or) : Yt.prototype.set.call(
        Ot,
        this.subarray(Qt, or),
        Lt
      ), hr;
    }, Ve.prototype.fill = function(Ot, Lt, Qt, or) {
      if (typeof Ot == "string") {
        if (typeof Lt == "string" ? (or = Lt, Lt = 0, Qt = this.length) : typeof Qt == "string" && (or = Qt, Qt = this.length), or !== void 0 && typeof or != "string")
          throw new TypeError("encoding must be a string");
        if (typeof or == "string" && !Ve.isEncoding(or))
          throw new TypeError("Unknown encoding: " + or);
        if (Ot.length === 1) {
          const yr = Ot.charCodeAt(0);
          (or === "utf8" && yr < 128 || or === "latin1") && (Ot = yr);
        }
      } else typeof Ot == "number" ? Ot = Ot & 255 : typeof Ot == "boolean" && (Ot = Number(Ot));
      if (Lt < 0 || this.length < Lt || this.length < Qt)
        throw new RangeError("Out of range index");
      if (Qt <= Lt)
        return this;
      Lt = Lt >>> 0, Qt = Qt === void 0 ? this.length : Qt >>> 0, Ot || (Ot = 0);
      let hr;
      if (typeof Ot == "number")
        for (hr = Lt; hr < Qt; ++hr)
          this[hr] = Ot;
      else {
        const yr = Ve.isBuffer(Ot) ? Ot : Ve.from(Ot, or), xr = yr.length;
        if (xr === 0)
          throw new TypeError('The value "' + Ot + '" is invalid for argument "value"');
        for (hr = 0; hr < Qt - Lt; ++hr)
          this[hr + Lt] = yr[hr % xr];
      }
      return this;
    };
    const Jr = {};
    function Jt(jt, Ot, Lt) {
      Jr[jt] = class extends Lt {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: Ot.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${jt}]`, this.stack, delete this.name;
        }
        get code() {
          return jt;
        }
        set code(or) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: or,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${jt}]: ${this.message}`;
        }
      };
    }
    Jt(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(jt) {
        return jt ? `${jt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Jt(
      "ERR_INVALID_ARG_TYPE",
      function(jt, Ot) {
        return `The "${jt}" argument must be of type number. Received type ${typeof Ot}`;
      },
      TypeError
    ), Jt(
      "ERR_OUT_OF_RANGE",
      function(jt, Ot, Lt) {
        let Qt = `The value of "${jt}" is out of range.`, or = Lt;
        return Number.isInteger(Lt) && Math.abs(Lt) > 2 ** 32 ? or = Dt(String(Lt)) : typeof Lt == "bigint" && (or = String(Lt), (Lt > BigInt(2) ** BigInt(32) || Lt < -(BigInt(2) ** BigInt(32))) && (or = Dt(or)), or += "n"), Qt += ` It must be ${Ot}. Received ${or}`, Qt;
      },
      RangeError
    );
    function Dt(jt) {
      let Ot = "", Lt = jt.length;
      const Qt = jt[0] === "-" ? 1 : 0;
      for (; Lt >= Qt + 4; Lt -= 3)
        Ot = `_${jt.slice(Lt - 3, Lt)}${Ot}`;
      return `${jt.slice(0, Lt)}${Ot}`;
    }
    function Gt(jt, Ot, Lt) {
      cr(Ot, "offset"), (jt[Ot] === void 0 || jt[Ot + Lt] === void 0) && br(Ot, jt.length - (Lt + 1));
    }
    function rr(jt, Ot, Lt, Qt, or, hr) {
      if (jt > Lt || jt < Ot) {
        const yr = typeof Ot == "bigint" ? "n" : "";
        let xr;
        throw Ot === 0 || Ot === BigInt(0) ? xr = `>= 0${yr} and < 2${yr} ** ${(hr + 1) * 8}${yr}` : xr = `>= -(2${yr} ** ${(hr + 1) * 8 - 1}${yr}) and < 2 ** ${(hr + 1) * 8 - 1}${yr}`, new Jr.ERR_OUT_OF_RANGE("value", xr, jt);
      }
      Gt(Qt, or, hr);
    }
    function cr(jt, Ot) {
      if (typeof jt != "number")
        throw new Jr.ERR_INVALID_ARG_TYPE(Ot, "number", jt);
    }
    function br(jt, Ot, Lt) {
      throw Math.floor(jt) !== jt ? (cr(jt, Lt), new Jr.ERR_OUT_OF_RANGE("offset", "an integer", jt)) : Ot < 0 ? new Jr.ERR_BUFFER_OUT_OF_BOUNDS() : new Jr.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${Ot}`,
        jt
      );
    }
    const gr = /[^+/0-9A-Za-z-_]/g;
    function Or(jt) {
      if (jt = jt.split("=")[0], jt = jt.trim().replace(gr, ""), jt.length < 2) return "";
      for (; jt.length % 4 !== 0; )
        jt = jt + "=";
      return jt;
    }
    function Wr(jt, Ot) {
      Ot = Ot || 1 / 0;
      let Lt;
      const Qt = jt.length;
      let or = null;
      const hr = [];
      for (let yr = 0; yr < Qt; ++yr) {
        if (Lt = jt.charCodeAt(yr), Lt > 55295 && Lt < 57344) {
          if (!or) {
            if (Lt > 56319) {
              (Ot -= 3) > -1 && hr.push(239, 191, 189);
              continue;
            } else if (yr + 1 === Qt) {
              (Ot -= 3) > -1 && hr.push(239, 191, 189);
              continue;
            }
            or = Lt;
            continue;
          }
          if (Lt < 56320) {
            (Ot -= 3) > -1 && hr.push(239, 191, 189), or = Lt;
            continue;
          }
          Lt = (or - 55296 << 10 | Lt - 56320) + 65536;
        } else or && (Ot -= 3) > -1 && hr.push(239, 191, 189);
        if (or = null, Lt < 128) {
          if ((Ot -= 1) < 0) break;
          hr.push(Lt);
        } else if (Lt < 2048) {
          if ((Ot -= 2) < 0) break;
          hr.push(
            Lt >> 6 | 192,
            Lt & 63 | 128
          );
        } else if (Lt < 65536) {
          if ((Ot -= 3) < 0) break;
          hr.push(
            Lt >> 12 | 224,
            Lt >> 6 & 63 | 128,
            Lt & 63 | 128
          );
        } else if (Lt < 1114112) {
          if ((Ot -= 4) < 0) break;
          hr.push(
            Lt >> 18 | 240,
            Lt >> 12 & 63 | 128,
            Lt >> 6 & 63 | 128,
            Lt & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return hr;
    }
    function kr(jt) {
      const Ot = [];
      for (let Lt = 0; Lt < jt.length; ++Lt)
        Ot.push(jt.charCodeAt(Lt) & 255);
      return Ot;
    }
    function jr(jt, Ot) {
      let Lt, Qt, or;
      const hr = [];
      for (let yr = 0; yr < jt.length && !((Ot -= 2) < 0); ++yr)
        Lt = jt.charCodeAt(yr), Qt = Lt >> 8, or = Lt % 256, hr.push(or), hr.push(Qt);
      return hr;
    }
    function Lr(jt) {
      return Bt.toByteArray(Or(jt));
    }
    function Fr(jt, Ot, Lt, Qt) {
      let or;
      for (or = 0; or < Qt && !(or + Lt >= Ot.length || or >= jt.length); ++or)
        Ot[or + Lt] = jt[or];
      return or;
    }
    function Xr(jt, Ot) {
      return jt instanceof Ot || jt != null && jt.constructor != null && jt.constructor.name != null && jt.constructor.name === Ot.name;
    }
    function Zr(jt) {
      return jt !== jt;
    }
    const fr = function() {
      const jt = "0123456789abcdef", Ot = new Array(256);
      for (let Lt = 0; Lt < 16; ++Lt) {
        const Qt = Lt * 16;
        for (let or = 0; or < 16; ++or)
          Ot[Qt + or] = jt[Lt] + jt[or];
      }
      return Ot;
    }();
    function tr(jt) {
      return typeof BigInt > "u" ? ur : jt;
    }
    function ur() {
      throw new Error("BigInt not supported");
    }
  })(z);
  const Pt = z.Buffer;
  B.Blob = z.Blob, B.BlobOptions = z.BlobOptions, B.Buffer = z.Buffer, B.File = z.File, B.FileOptions = z.FileOptions, B.INSPECT_MAX_BYTES = z.INSPECT_MAX_BYTES, B.SlowBuffer = z.SlowBuffer, B.TranscodeEncoding = z.TranscodeEncoding, B.atob = z.atob, B.btoa = z.btoa, B.constants = z.constants, B.default = Pt, B.isAscii = z.isAscii, B.isUtf8 = z.isUtf8, B.kMaxLength = z.kMaxLength, B.kStringMaxLength = z.kStringMaxLength, B.resolveObjectURL = z.resolveObjectURL, B.transcode = z.transcode;
})(dist$1);
const Buffer$1 = /* @__PURE__ */ getDefaultExportFromCjs(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, z) {
  var Y = dist$1, ne = Y.Buffer;
  function oe(ae, se) {
    for (var ve in ae)
      se[ve] = ae[ve];
  }
  ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (oe(Y, z), z.Buffer = ie);
  function ie(ae, se, ve) {
    return ne(ae, se, ve);
  }
  ie.prototype = Object.create(ne.prototype), oe(ne, ie), ie.from = function(ae, se, ve) {
    if (typeof ae == "number")
      throw new TypeError("Argument must not be a number");
    return ne(ae, se, ve);
  }, ie.alloc = function(ae, se, ve) {
    if (typeof ae != "number")
      throw new TypeError("Argument must be a number");
    var ge = ne(ae);
    return se !== void 0 ? typeof ve == "string" ? ge.fill(se, ve) : ge.fill(se) : ge.fill(0), ge;
  }, ie.allocUnsafe = function(ae) {
    if (typeof ae != "number")
      throw new TypeError("Argument must be a number");
    return ne(ae);
  }, ie.allocUnsafeSlow = function(ae) {
    if (typeof ae != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(ae);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var B = 65536, z = 4294967295;
  function Y() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var ne = safeBufferExports.Buffer, oe = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  oe && oe.getRandomValues ? browser$b.exports = ie : browser$b.exports = Y;
  function ie(ae, se) {
    if (ae > z) throw new RangeError("requested too many random bytes");
    var ve = ne.allocUnsafe(ae);
    if (ae > 0)
      if (ae > B)
        for (var ge = 0; ge < ae; ge += B)
          oe.getRandomValues(ve.slice(ge, ge + B));
      else
        oe.getRandomValues(ve);
    return typeof se == "function" ? process$1.nextTick(function() {
      se(null, ve);
    }) : ve;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(z, Y) {
    Y && (z.super_ = Y, z.prototype = Object.create(Y.prototype, {
      constructor: {
        value: z,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(z, Y) {
    if (Y) {
      z.super_ = Y;
      var ne = function() {
      };
      ne.prototype = Y.prototype, z.prototype = new ne(), z.prototype.constructor = z;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var B = typeof Reflect == "object" ? Reflect : null, z = B && typeof B.apply == "function" ? B.apply : function(Wt, Kt, Yt) {
    return Function.prototype.apply.call(Wt, Kt, Yt);
  }, Y;
  B && typeof B.ownKeys == "function" ? Y = B.ownKeys : Object.getOwnPropertySymbols ? Y = function(Wt) {
    return Object.getOwnPropertyNames(Wt).concat(Object.getOwnPropertySymbols(Wt));
  } : Y = function(Wt) {
    return Object.getOwnPropertyNames(Wt);
  };
  function ne(Ct) {
    console && console.warn && console.warn(Ct);
  }
  var oe = Number.isNaN || function(Wt) {
    return Wt !== Wt;
  };
  function ie() {
    ie.init.call(this);
  }
  events.exports = ie, events.exports.once = Pt, ie.EventEmitter = ie, ie.prototype._events = void 0, ie.prototype._eventsCount = 0, ie.prototype._maxListeners = void 0;
  var ae = 10;
  function se(Ct) {
    if (typeof Ct != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof Ct);
  }
  Object.defineProperty(ie, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return ae;
    },
    set: function(Ct) {
      if (typeof Ct != "number" || Ct < 0 || oe(Ct))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + Ct + ".");
      ae = Ct;
    }
  }), ie.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, ie.prototype.setMaxListeners = function(Wt) {
    if (typeof Wt != "number" || Wt < 0 || oe(Wt))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + Wt + ".");
    return this._maxListeners = Wt, this;
  };
  function ve(Ct) {
    return Ct._maxListeners === void 0 ? ie.defaultMaxListeners : Ct._maxListeners;
  }
  ie.prototype.getMaxListeners = function() {
    return ve(this);
  }, ie.prototype.emit = function(Wt) {
    for (var Kt = [], Yt = 1; Yt < arguments.length; Yt++) Kt.push(arguments[Yt]);
    var Ut = Wt === "error", qt = this._events;
    if (qt !== void 0)
      Ut = Ut && qt.error === void 0;
    else if (!Ut)
      return !1;
    if (Ut) {
      var zt;
      if (Kt.length > 0 && (zt = Kt[0]), zt instanceof Error)
        throw zt;
      var Ft = new Error("Unhandled error." + (zt ? " (" + zt.message + ")" : ""));
      throw Ft.context = zt, Ft;
    }
    var Ve = qt[Wt];
    if (Ve === void 0)
      return !1;
    if (typeof Ve == "function")
      z(Ve, this, Kt);
    else
      for (var Je = Ve.length, Ke = Xe(Ve, Je), Yt = 0; Yt < Je; ++Yt)
        z(Ke[Yt], this, Kt);
    return !0;
  };
  function ge(Ct, Wt, Kt, Yt) {
    var Ut, qt, zt;
    if (se(Kt), qt = Ct._events, qt === void 0 ? (qt = Ct._events = /* @__PURE__ */ Object.create(null), Ct._eventsCount = 0) : (qt.newListener !== void 0 && (Ct.emit(
      "newListener",
      Wt,
      Kt.listener ? Kt.listener : Kt
    ), qt = Ct._events), zt = qt[Wt]), zt === void 0)
      zt = qt[Wt] = Kt, ++Ct._eventsCount;
    else if (typeof zt == "function" ? zt = qt[Wt] = Yt ? [Kt, zt] : [zt, Kt] : Yt ? zt.unshift(Kt) : zt.push(Kt), Ut = ve(Ct), Ut > 0 && zt.length > Ut && !zt.warned) {
      zt.warned = !0;
      var Ft = new Error("Possible EventEmitter memory leak detected. " + zt.length + " " + String(Wt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Ft.name = "MaxListenersExceededWarning", Ft.emitter = Ct, Ft.type = Wt, Ft.count = zt.length, ne(Ft);
    }
    return Ct;
  }
  ie.prototype.addListener = function(Wt, Kt) {
    return ge(this, Wt, Kt, !1);
  }, ie.prototype.on = ie.prototype.addListener, ie.prototype.prependListener = function(Wt, Kt) {
    return ge(this, Wt, Kt, !0);
  };
  function le() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Ee(Ct, Wt, Kt) {
    var Yt = { fired: !1, wrapFn: void 0, target: Ct, type: Wt, listener: Kt }, Ut = le.bind(Yt);
    return Ut.listener = Kt, Yt.wrapFn = Ut, Ut;
  }
  ie.prototype.once = function(Wt, Kt) {
    return se(Kt), this.on(Wt, Ee(this, Wt, Kt)), this;
  }, ie.prototype.prependOnceListener = function(Wt, Kt) {
    return se(Kt), this.prependListener(Wt, Ee(this, Wt, Kt)), this;
  }, ie.prototype.removeListener = function(Wt, Kt) {
    var Yt, Ut, qt, zt, Ft;
    if (se(Kt), Ut = this._events, Ut === void 0)
      return this;
    if (Yt = Ut[Wt], Yt === void 0)
      return this;
    if (Yt === Kt || Yt.listener === Kt)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Ut[Wt], Ut.removeListener && this.emit("removeListener", Wt, Yt.listener || Kt));
    else if (typeof Yt != "function") {
      for (qt = -1, zt = Yt.length - 1; zt >= 0; zt--)
        if (Yt[zt] === Kt || Yt[zt].listener === Kt) {
          Ft = Yt[zt].listener, qt = zt;
          break;
        }
      if (qt < 0)
        return this;
      qt === 0 ? Yt.shift() : ht(Yt, qt), Yt.length === 1 && (Ut[Wt] = Yt[0]), Ut.removeListener !== void 0 && this.emit("removeListener", Wt, Ft || Kt);
    }
    return this;
  }, ie.prototype.off = ie.prototype.removeListener, ie.prototype.removeAllListeners = function(Wt) {
    var Kt, Yt, Ut;
    if (Yt = this._events, Yt === void 0)
      return this;
    if (Yt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Yt[Wt] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Yt[Wt]), this;
    if (arguments.length === 0) {
      var qt = Object.keys(Yt), zt;
      for (Ut = 0; Ut < qt.length; ++Ut)
        zt = qt[Ut], zt !== "removeListener" && this.removeAllListeners(zt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (Kt = Yt[Wt], typeof Kt == "function")
      this.removeListener(Wt, Kt);
    else if (Kt !== void 0)
      for (Ut = Kt.length - 1; Ut >= 0; Ut--)
        this.removeListener(Wt, Kt[Ut]);
    return this;
  };
  function Ce(Ct, Wt, Kt) {
    var Yt = Ct._events;
    if (Yt === void 0)
      return [];
    var Ut = Yt[Wt];
    return Ut === void 0 ? [] : typeof Ut == "function" ? Kt ? [Ut.listener || Ut] : [Ut] : Kt ? wt(Ut) : Xe(Ut, Ut.length);
  }
  ie.prototype.listeners = function(Wt) {
    return Ce(this, Wt, !0);
  }, ie.prototype.rawListeners = function(Wt) {
    return Ce(this, Wt, !1);
  }, ie.listenerCount = function(Ct, Wt) {
    return typeof Ct.listenerCount == "function" ? Ct.listenerCount(Wt) : Pe.call(Ct, Wt);
  }, ie.prototype.listenerCount = Pe;
  function Pe(Ct) {
    var Wt = this._events;
    if (Wt !== void 0) {
      var Kt = Wt[Ct];
      if (typeof Kt == "function")
        return 1;
      if (Kt !== void 0)
        return Kt.length;
    }
    return 0;
  }
  ie.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Y(this._events) : [];
  };
  function Xe(Ct, Wt) {
    for (var Kt = new Array(Wt), Yt = 0; Yt < Wt; ++Yt)
      Kt[Yt] = Ct[Yt];
    return Kt;
  }
  function ht(Ct, Wt) {
    for (; Wt + 1 < Ct.length; Wt++)
      Ct[Wt] = Ct[Wt + 1];
    Ct.pop();
  }
  function wt(Ct) {
    for (var Wt = new Array(Ct.length), Kt = 0; Kt < Wt.length; ++Kt)
      Wt[Kt] = Ct[Kt].listener || Ct[Kt];
    return Wt;
  }
  function Pt(Ct, Wt) {
    return new Promise(function(Kt, Yt) {
      function Ut(zt) {
        Ct.removeListener(Wt, qt), Yt(zt);
      }
      function qt() {
        typeof Ct.removeListener == "function" && Ct.removeListener("error", Ut), Kt([].slice.call(arguments));
      }
      Bt(Ct, Wt, qt, { once: !0 }), Wt !== "error" && vt(Ct, Ut, { once: !0 });
    });
  }
  function vt(Ct, Wt, Kt) {
    typeof Ct.on == "function" && Bt(Ct, "error", Wt, Kt);
  }
  function Bt(Ct, Wt, Kt, Yt) {
    if (typeof Ct.on == "function")
      Yt.once ? Ct.once(Wt, Kt) : Ct.on(Wt, Kt);
    else if (typeof Ct.addEventListener == "function")
      Ct.addEventListener(Wt, function Ut(qt) {
        Yt.once && Ct.removeEventListener(Wt, Ut), Kt(qt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof Ct);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var z = {}, Y = Symbol("test"), ne = Object(Y);
    if (typeof Y == "string" || Object.prototype.toString.call(Y) !== "[object Symbol]" || Object.prototype.toString.call(ne) !== "[object Symbol]")
      return !1;
    var oe = 42;
    z[Y] = oe;
    for (var ie in z)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(z).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(z).length !== 0)
      return !1;
    var ae = Object.getOwnPropertySymbols(z);
    if (ae.length !== 1 || ae[0] !== Y || !Object.prototype.propertyIsEnumerable.call(z, Y))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var se = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(z, Y)
      );
      if (se.value !== oe || se.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var B = requireShams$1();
  return shams = function() {
    return B() && !!Symbol.toStringTag;
  }, shams;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(z) {
    return z !== z;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var B = require_isNaN();
  return sign$1 = function(Y) {
    return B(Y) || Y === 0 ? Y : Y < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var B = requireGOPD();
  if (B)
    try {
      B([], "length");
    } catch {
      B = null;
    }
  return gopd = B, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var B = Object.defineProperty || !1;
  if (B)
    try {
      B({}, "a", { value: 1 });
    } catch {
      B = !1;
    }
  return esDefineProperty = B, esDefineProperty;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, z = requireShams$1();
  return hasSymbols = function() {
    return typeof B != "function" || typeof Symbol != "function" || typeof B("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : z();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var B = requireEsObjectAtoms();
  return Object_getPrototypeOf = B.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var B = "Function.prototype.bind called on incompatible ", z = Object.prototype.toString, Y = Math.max, ne = "[object Function]", oe = function(ve, ge) {
    for (var le = [], Ee = 0; Ee < ve.length; Ee += 1)
      le[Ee] = ve[Ee];
    for (var Ce = 0; Ce < ge.length; Ce += 1)
      le[Ce + ve.length] = ge[Ce];
    return le;
  }, ie = function(ve, ge) {
    for (var le = [], Ee = ge, Ce = 0; Ee < ve.length; Ee += 1, Ce += 1)
      le[Ce] = ve[Ee];
    return le;
  }, ae = function(se, ve) {
    for (var ge = "", le = 0; le < se.length; le += 1)
      ge += se[le], le + 1 < se.length && (ge += ve);
    return ge;
  };
  return implementation = function(ve) {
    var ge = this;
    if (typeof ge != "function" || z.apply(ge) !== ne)
      throw new TypeError(B + ge);
    for (var le = ie(arguments, 1), Ee, Ce = function() {
      if (this instanceof Ee) {
        var Pt = ge.apply(
          this,
          oe(le, arguments)
        );
        return Object(Pt) === Pt ? Pt : this;
      }
      return ge.apply(
        ve,
        oe(le, arguments)
      );
    }, Pe = Y(0, ge.length - le.length), Xe = [], ht = 0; ht < Pe; ht++)
      Xe[ht] = "$" + ht;
    if (Ee = Function("binder", "return function (" + ae(Xe, ",") + "){ return binder.apply(this,arguments); }")(Ce), ge.prototype) {
      var wt = function() {
      };
      wt.prototype = ge.prototype, Ee.prototype = new wt(), wt.prototype = null;
    }
    return Ee;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var B = requireImplementation();
  return functionBind = Function.prototype.bind || B, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var B = requireFunctionBind(), z = requireFunctionApply(), Y = requireFunctionCall(), ne = requireReflectApply();
  return actualApply = ne || B.call(Y, z), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var B = requireFunctionBind(), z = requireType(), Y = requireFunctionCall(), ne = requireActualApply();
  return callBindApplyHelpers = function(ie) {
    if (ie.length < 1 || typeof ie[0] != "function")
      throw new z("a function is required");
    return ne(B, Y, ie);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var B = requireCallBindApplyHelpers(), z = requireGopd(), Y;
  try {
    Y = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (ae) {
    if (!ae || typeof ae != "object" || !("code" in ae) || ae.code !== "ERR_PROTO_ACCESS")
      throw ae;
  }
  var ne = !!Y && z && z(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), oe = Object, ie = oe.getPrototypeOf;
  return get = ne && typeof ne.get == "function" ? B([ne.get]) : typeof ie == "function" ? (
    /** @type {import('./get')} */
    function(se) {
      return ie(se == null ? se : oe(se));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var B = requireReflect_getPrototypeOf(), z = requireObject_getPrototypeOf(), Y = requireGet();
  return getProto = B ? function(oe) {
    return B(oe);
  } : z ? function(oe) {
    if (!oe || typeof oe != "object" && typeof oe != "function")
      throw new TypeError("getProto: not an object");
    return z(oe);
  } : Y ? function(oe) {
    return Y(oe);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var B = Function.prototype.call, z = Object.prototype.hasOwnProperty, Y = requireFunctionBind();
  return hasown = Y.call(B, z), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var B, z = requireEsObjectAtoms(), Y = requireEsErrors(), ne = require_eval(), oe = requireRange(), ie = requireRef(), ae = requireSyntax(), se = requireType(), ve = requireUri(), ge = requireAbs(), le = requireFloor(), Ee = requireMax(), Ce = requireMin(), Pe = requirePow(), Xe = requireRound(), ht = requireSign$1(), wt = Function, Pt = function(sr) {
    try {
      return wt('"use strict"; return (' + sr + ").constructor;")();
    } catch {
    }
  }, vt = requireGopd(), Bt = requireEsDefineProperty(), Ct = function() {
    throw new se();
  }, Wt = vt ? function() {
    try {
      return arguments.callee, Ct;
    } catch {
      try {
        return vt(arguments, "callee").get;
      } catch {
        return Ct;
      }
    }
  }() : Ct, Kt = requireHasSymbols()(), Yt = requireGetProto(), Ut = requireObject_getPrototypeOf(), qt = requireReflect_getPrototypeOf(), zt = requireFunctionApply(), Ft = requireFunctionCall(), Ve = {}, Je = typeof Uint8Array > "u" || !Yt ? B : Yt(Uint8Array), Ke = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? B : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? B : ArrayBuffer,
    "%ArrayIteratorPrototype%": Kt && Yt ? Yt([][Symbol.iterator]()) : B,
    "%AsyncFromSyncIteratorPrototype%": B,
    "%AsyncFunction%": Ve,
    "%AsyncGenerator%": Ve,
    "%AsyncGeneratorFunction%": Ve,
    "%AsyncIteratorPrototype%": Ve,
    "%Atomics%": typeof Atomics > "u" ? B : Atomics,
    "%BigInt%": typeof BigInt > "u" ? B : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? B : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? B : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? B : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Y,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": ne,
    "%Float32Array%": typeof Float32Array > "u" ? B : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? B : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? B : FinalizationRegistry,
    "%Function%": wt,
    "%GeneratorFunction%": Ve,
    "%Int8Array%": typeof Int8Array > "u" ? B : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? B : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? B : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Kt && Yt ? Yt(Yt([][Symbol.iterator]())) : B,
    "%JSON%": typeof JSON == "object" ? JSON : B,
    "%Map%": typeof Map > "u" ? B : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Kt || !Yt ? B : Yt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": z,
    "%Object.getOwnPropertyDescriptor%": vt,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? B : Promise,
    "%Proxy%": typeof Proxy > "u" ? B : Proxy,
    "%RangeError%": oe,
    "%ReferenceError%": ie,
    "%Reflect%": typeof Reflect > "u" ? B : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? B : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Kt || !Yt ? B : Yt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? B : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Kt && Yt ? Yt(""[Symbol.iterator]()) : B,
    "%Symbol%": Kt ? Symbol : B,
    "%SyntaxError%": ae,
    "%ThrowTypeError%": Wt,
    "%TypedArray%": Je,
    "%TypeError%": se,
    "%Uint8Array%": typeof Uint8Array > "u" ? B : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? B : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? B : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? B : Uint32Array,
    "%URIError%": ve,
    "%WeakMap%": typeof WeakMap > "u" ? B : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? B : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? B : WeakSet,
    "%Function.prototype.call%": Ft,
    "%Function.prototype.apply%": zt,
    "%Object.defineProperty%": Bt,
    "%Object.getPrototypeOf%": Ut,
    "%Math.abs%": ge,
    "%Math.floor%": le,
    "%Math.max%": Ee,
    "%Math.min%": Ce,
    "%Math.pow%": Pe,
    "%Math.round%": Xe,
    "%Math.sign%": ht,
    "%Reflect.getPrototypeOf%": qt
  };
  if (Yt)
    try {
      null.error;
    } catch (sr) {
      var Qe = Yt(Yt(sr));
      Ke["%Error.prototype%"] = Qe;
    }
  var bt = function sr(dr) {
    var er;
    if (dr === "%AsyncFunction%")
      er = Pt("async function () {}");
    else if (dr === "%GeneratorFunction%")
      er = Pt("function* () {}");
    else if (dr === "%AsyncGeneratorFunction%")
      er = Pt("async function* () {}");
    else if (dr === "%AsyncGenerator%") {
      var Zt = sr("%AsyncGeneratorFunction%");
      Zt && (er = Zt.prototype);
    } else if (dr === "%AsyncIteratorPrototype%") {
      var pr = sr("%AsyncGenerator%");
      pr && Yt && (er = Yt(pr.prototype));
    }
    return Ke[dr] = er, er;
  }, _t = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, $t = requireFunctionBind(), kt = requireHasown(), xt = $t.call(Ft, Array.prototype.concat), Nt = $t.call(zt, Array.prototype.splice), Rt = $t.call(Ft, String.prototype.replace), Ht = $t.call(Ft, String.prototype.slice), ar = $t.call(Ft, RegExp.prototype.exec), lr = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, nr = /\\(\\)?/g, Vt = function(dr) {
    var er = Ht(dr, 0, 1), Zt = Ht(dr, -1);
    if (er === "%" && Zt !== "%")
      throw new ae("invalid intrinsic syntax, expected closing `%`");
    if (Zt === "%" && er !== "%")
      throw new ae("invalid intrinsic syntax, expected opening `%`");
    var pr = [];
    return Rt(dr, lr, function(_r, Ar, Sr, Br) {
      pr[pr.length] = Sr ? Rt(Br, nr, "$1") : Ar || _r;
    }), pr;
  }, Xt = function(dr, er) {
    var Zt = dr, pr;
    if (kt(_t, Zt) && (pr = _t[Zt], Zt = "%" + pr[0] + "%"), kt(Ke, Zt)) {
      var _r = Ke[Zt];
      if (_r === Ve && (_r = bt(Zt)), typeof _r > "u" && !er)
        throw new se("intrinsic " + dr + " exists, but is not available. Please file an issue!");
      return {
        alias: pr,
        name: Zt,
        value: _r
      };
    }
    throw new ae("intrinsic " + dr + " does not exist!");
  };
  return getIntrinsic = function(dr, er) {
    if (typeof dr != "string" || dr.length === 0)
      throw new se("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof er != "boolean")
      throw new se('"allowMissing" argument must be a boolean');
    if (ar(/^%?[^%]*%?$/, dr) === null)
      throw new ae("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var Zt = Vt(dr), pr = Zt.length > 0 ? Zt[0] : "", _r = Xt("%" + pr + "%", er), Ar = _r.name, Sr = _r.value, Br = !1, Ir = _r.alias;
    Ir && (pr = Ir[0], Nt(Zt, xt([0, 1], Ir)));
    for (var wr = 1, Gr = !0; wr < Zt.length; wr += 1) {
      var Pr = Zt[wr], Mr = Ht(Pr, 0, 1), Cr = Ht(Pr, -1);
      if ((Mr === '"' || Mr === "'" || Mr === "`" || Cr === '"' || Cr === "'" || Cr === "`") && Mr !== Cr)
        throw new ae("property names with quotes must have matching quotes");
      if ((Pr === "constructor" || !Gr) && (Br = !0), pr += "." + Pr, Ar = "%" + pr + "%", kt(Ke, Ar))
        Sr = Ke[Ar];
      else if (Sr != null) {
        if (!(Pr in Sr)) {
          if (!er)
            throw new se("base intrinsic for " + dr + " exists, but the property is not available.");
          return;
        }
        if (vt && wr + 1 >= Zt.length) {
          var Tr = vt(Sr, Pr);
          Gr = !!Tr, Gr && "get" in Tr && !("originalValue" in Tr.get) ? Sr = Tr.get : Sr = Sr[Pr];
        } else
          Gr = kt(Sr, Pr), Sr = Sr[Pr];
        Gr && !Br && (Ke[Ar] = Sr);
      }
    }
    return Sr;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var B = requireGetIntrinsic(), z = requireCallBindApplyHelpers(), Y = z([B("%String.prototype.indexOf%")]);
  return callBound = function(oe, ie) {
    var ae = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      B(oe, !!ie)
    );
    return typeof ae == "function" && Y(oe, ".prototype.") > -1 ? z([ae]) : ae;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var B = requireShams()(), z = requireCallBound(), Y = z("Object.prototype.toString"), ne = function(se) {
    return B && se && typeof se == "object" && Symbol.toStringTag in se ? !1 : Y(se) === "[object Arguments]";
  }, oe = function(se) {
    return ne(se) ? !0 : se !== null && typeof se == "object" && "length" in se && typeof se.length == "number" && se.length >= 0 && Y(se) !== "[object Array]" && "callee" in se && Y(se.callee) === "[object Function]";
  }, ie = function() {
    return ne(arguments);
  }();
  return ne.isLegacyArguments = oe, isArguments = ie ? ne : oe, isArguments;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var B = requireCallBound(), z = requireShams()(), Y = requireHasown(), ne = requireGopd(), oe;
  if (z) {
    var ie = B("RegExp.prototype.exec"), ae = {}, se = function() {
      throw ae;
    }, ve = {
      toString: se,
      valueOf: se
    };
    typeof Symbol.toPrimitive == "symbol" && (ve[Symbol.toPrimitive] = se), oe = function(Ce) {
      if (!Ce || typeof Ce != "object")
        return !1;
      var Pe = (
        /** @type {NonNullable<typeof gOPD>} */
        ne(
          /** @type {{ lastIndex?: unknown }} */
          Ce,
          "lastIndex"
        )
      ), Xe = Pe && Y(Pe, "value");
      if (!Xe)
        return !1;
      try {
        ie(
          Ce,
          /** @type {string} */
          /** @type {unknown} */
          ve
        );
      } catch (ht) {
        return ht === ae;
      }
    };
  } else {
    var ge = B("Object.prototype.toString"), le = "[object RegExp]";
    oe = function(Ce) {
      return !Ce || typeof Ce != "object" && typeof Ce != "function" ? !1 : ge(Ce) === le;
    };
  }
  return isRegex = oe, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var B = requireCallBound(), z = requireIsRegex(), Y = B("RegExp.prototype.exec"), ne = requireType();
  return safeRegexTest = function(ie) {
    if (!z(ie))
      throw new ne("`regex` must be a RegExp");
    return function(se) {
      return Y(ie, se) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var B = requireCallBound(), z = requireSafeRegexTest(), Y = z(/^\s*(?:function)?\*/), ne = requireShams()(), oe = requireGetProto(), ie = B("Object.prototype.toString"), ae = B("Function.prototype.toString"), se = function() {
    if (!ne)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, ve;
  return isGeneratorFunction = function(le) {
    if (typeof le != "function")
      return !1;
    if (Y(ae(le)))
      return !0;
    if (!ne) {
      var Ee = ie(le);
      return Ee === "[object GeneratorFunction]";
    }
    if (!oe)
      return !1;
    if (typeof ve > "u") {
      var Ce = se();
      ve = Ce ? (
        /** @type {GeneratorFunctionConstructor} */
        oe(Ce)
      ) : !1;
    }
    return oe(le) === ve;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var B = Function.prototype.toString, z = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Y, ne;
  if (typeof z == "function" && typeof Object.defineProperty == "function")
    try {
      Y = Object.defineProperty({}, "length", {
        get: function() {
          throw ne;
        }
      }), ne = {}, z(function() {
        throw 42;
      }, null, Y);
    } catch (vt) {
      vt !== ne && (z = null);
    }
  else
    z = null;
  var oe = /^\s*class\b/, ie = function(Bt) {
    try {
      var Ct = B.call(Bt);
      return oe.test(Ct);
    } catch {
      return !1;
    }
  }, ae = function(Bt) {
    try {
      return ie(Bt) ? !1 : (B.call(Bt), !0);
    } catch {
      return !1;
    }
  }, se = Object.prototype.toString, ve = "[object Object]", ge = "[object Function]", le = "[object GeneratorFunction]", Ee = "[object HTMLAllCollection]", Ce = "[object HTML document.all class]", Pe = "[object HTMLCollection]", Xe = typeof Symbol == "function" && !!Symbol.toStringTag, ht = !(0 in [,]), wt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var Pt = document.all;
    se.call(Pt) === se.call(document.all) && (wt = function(Bt) {
      if ((ht || !Bt) && (typeof Bt > "u" || typeof Bt == "object"))
        try {
          var Ct = se.call(Bt);
          return (Ct === Ee || Ct === Ce || Ct === Pe || Ct === ve) && Bt("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = z ? function(Bt) {
    if (wt(Bt))
      return !0;
    if (!Bt || typeof Bt != "function" && typeof Bt != "object")
      return !1;
    try {
      z(Bt, null, Y);
    } catch (Ct) {
      if (Ct !== ne)
        return !1;
    }
    return !ie(Bt) && ae(Bt);
  } : function(Bt) {
    if (wt(Bt))
      return !0;
    if (!Bt || typeof Bt != "function" && typeof Bt != "object")
      return !1;
    if (Xe)
      return ae(Bt);
    if (ie(Bt))
      return !1;
    var Ct = se.call(Bt);
    return Ct !== ge && Ct !== le && !/^\[object HTML/.test(Ct) ? !1 : ae(Bt);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var B = requireIsCallable(), z = Object.prototype.toString, Y = Object.prototype.hasOwnProperty, ne = function(ve, ge, le) {
    for (var Ee = 0, Ce = ve.length; Ee < Ce; Ee++)
      Y.call(ve, Ee) && (le == null ? ge(ve[Ee], Ee, ve) : ge.call(le, ve[Ee], Ee, ve));
  }, oe = function(ve, ge, le) {
    for (var Ee = 0, Ce = ve.length; Ee < Ce; Ee++)
      le == null ? ge(ve.charAt(Ee), Ee, ve) : ge.call(le, ve.charAt(Ee), Ee, ve);
  }, ie = function(ve, ge, le) {
    for (var Ee in ve)
      Y.call(ve, Ee) && (le == null ? ge(ve[Ee], Ee, ve) : ge.call(le, ve[Ee], Ee, ve));
  };
  function ae(se) {
    return z.call(se) === "[object Array]";
  }
  return forEach = function(ve, ge, le) {
    if (!B(ge))
      throw new TypeError("iterator must be a function");
    var Ee;
    arguments.length >= 3 && (Ee = le), ae(ve) ? ne(ve, ge, Ee) : typeof ve == "string" ? oe(ve, ge, Ee) : ie(ve, ge, Ee);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var B = requirePossibleTypedArrayNames(), z = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var ne = [], oe = 0; oe < B.length; oe++)
      typeof z[B[oe]] == "function" && (ne[ne.length] = B[oe]);
    return ne;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var B = requireEsDefineProperty(), z = requireSyntax(), Y = requireType(), ne = requireGopd();
  return defineDataProperty = function(ie, ae, se) {
    if (!ie || typeof ie != "object" && typeof ie != "function")
      throw new Y("`obj` must be an object or a function`");
    if (typeof ae != "string" && typeof ae != "symbol")
      throw new Y("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new Y("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new Y("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new Y("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new Y("`loose`, if provided, must be a boolean");
    var ve = arguments.length > 3 ? arguments[3] : null, ge = arguments.length > 4 ? arguments[4] : null, le = arguments.length > 5 ? arguments[5] : null, Ee = arguments.length > 6 ? arguments[6] : !1, Ce = !!ne && ne(ie, ae);
    if (B)
      B(ie, ae, {
        configurable: le === null && Ce ? Ce.configurable : !le,
        enumerable: ve === null && Ce ? Ce.enumerable : !ve,
        value: se,
        writable: ge === null && Ce ? Ce.writable : !ge
      });
    else if (Ee || !ve && !ge && !le)
      ie[ae] = se;
    else
      throw new z("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var B = requireEsDefineProperty(), z = function() {
    return !!B;
  };
  return z.hasArrayLengthDefineBug = function() {
    if (!B)
      return null;
    try {
      return B([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = z, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var B = requireGetIntrinsic(), z = requireDefineDataProperty(), Y = requireHasPropertyDescriptors()(), ne = requireGopd(), oe = requireType(), ie = B("%Math.floor%");
  return setFunctionLength = function(se, ve) {
    if (typeof se != "function")
      throw new oe("`fn` is not a function");
    if (typeof ve != "number" || ve < 0 || ve > 4294967295 || ie(ve) !== ve)
      throw new oe("`length` must be a positive 32-bit integer");
    var ge = arguments.length > 2 && !!arguments[2], le = !0, Ee = !0;
    if ("length" in se && ne) {
      var Ce = ne(se, "length");
      Ce && !Ce.configurable && (le = !1), Ce && !Ce.writable && (Ee = !1);
    }
    return (le || Ee || !ge) && (Y ? z(
      /** @type {Parameters<define>[0]} */
      se,
      "length",
      ve,
      !0,
      !0
    ) : z(
      /** @type {Parameters<define>[0]} */
      se,
      "length",
      ve
    )), se;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var B = requireFunctionBind(), z = requireFunctionApply(), Y = requireActualApply();
  return applyBind = function() {
    return Y(B, z, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(B) {
    var z = requireSetFunctionLength(), Y = requireEsDefineProperty(), ne = requireCallBindApplyHelpers(), oe = requireApplyBind();
    B.exports = function(ae) {
      var se = ne(arguments), ve = ae.length - (arguments.length - 1);
      return z(
        se,
        1 + (ve > 0 ? ve : 0),
        !0
      );
    }, Y ? Y(B.exports, "apply", { value: oe }) : B.exports.apply = oe;
  }(callBind)), callBind.exports;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var B = requireForEach(), z = requireAvailableTypedArrays(), Y = requireCallBind(), ne = requireCallBound(), oe = requireGopd(), ie = ne("Object.prototype.toString"), ae = requireShams()(), se = typeof globalThis > "u" ? commonjsGlobal : globalThis, ve = z(), ge = ne("String.prototype.slice"), le = Object.getPrototypeOf, Ee = ne("Array.prototype.indexOf", !0) || function(wt, Pt) {
    for (var vt = 0; vt < wt.length; vt += 1)
      if (wt[vt] === Pt)
        return vt;
    return -1;
  }, Ce = { __proto__: null };
  ae && oe && le ? B(ve, function(ht) {
    var wt = new se[ht]();
    if (Symbol.toStringTag in wt) {
      var Pt = le(wt), vt = oe(Pt, Symbol.toStringTag);
      if (!vt) {
        var Bt = le(Pt);
        vt = oe(Bt, Symbol.toStringTag);
      }
      Ce["$" + ht] = Y(vt.get);
    }
  }) : B(ve, function(ht) {
    var wt = new se[ht](), Pt = wt.slice || wt.set;
    Pt && (Ce["$" + ht] = Y(Pt));
  });
  var Pe = function(wt) {
    var Pt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ce,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(vt, Bt) {
        if (!Pt)
          try {
            "$" + vt(wt) === Bt && (Pt = ge(Bt, 1));
          } catch {
          }
      }
    ), Pt;
  }, Xe = function(wt) {
    var Pt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ce,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(vt, Bt) {
        if (!Pt)
          try {
            vt(wt), Pt = ge(Bt, 1);
          } catch {
          }
      }
    ), Pt;
  };
  return whichTypedArray = function(wt) {
    if (!wt || typeof wt != "object")
      return !1;
    if (!ae) {
      var Pt = ge(ie(wt), 8, -1);
      return Ee(ve, Pt) > -1 ? Pt : Pt !== "Object" ? !1 : Xe(wt);
    }
    return oe ? Pe(wt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var B = requireWhichTypedArray();
  return isTypedArray = function(Y) {
    return !!B(Y);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(B) {
    var z = requireIsArguments(), Y = requireIsGeneratorFunction(), ne = requireWhichTypedArray(), oe = requireIsTypedArray();
    function ie(wr) {
      return wr.call.bind(wr);
    }
    var ae = typeof BigInt < "u", se = typeof Symbol < "u", ve = ie(Object.prototype.toString), ge = ie(Number.prototype.valueOf), le = ie(String.prototype.valueOf), Ee = ie(Boolean.prototype.valueOf);
    if (ae)
      var Ce = ie(BigInt.prototype.valueOf);
    if (se)
      var Pe = ie(Symbol.prototype.valueOf);
    function Xe(wr, Gr) {
      if (typeof wr != "object")
        return !1;
      try {
        return Gr(wr), !0;
      } catch {
        return !1;
      }
    }
    B.isArgumentsObject = z, B.isGeneratorFunction = Y, B.isTypedArray = oe;
    function ht(wr) {
      return typeof Promise < "u" && wr instanceof Promise || wr !== null && typeof wr == "object" && typeof wr.then == "function" && typeof wr.catch == "function";
    }
    B.isPromise = ht;
    function wt(wr) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(wr) : oe(wr) || Ht(wr);
    }
    B.isArrayBufferView = wt;
    function Pt(wr) {
      return ne(wr) === "Uint8Array";
    }
    B.isUint8Array = Pt;
    function vt(wr) {
      return ne(wr) === "Uint8ClampedArray";
    }
    B.isUint8ClampedArray = vt;
    function Bt(wr) {
      return ne(wr) === "Uint16Array";
    }
    B.isUint16Array = Bt;
    function Ct(wr) {
      return ne(wr) === "Uint32Array";
    }
    B.isUint32Array = Ct;
    function Wt(wr) {
      return ne(wr) === "Int8Array";
    }
    B.isInt8Array = Wt;
    function Kt(wr) {
      return ne(wr) === "Int16Array";
    }
    B.isInt16Array = Kt;
    function Yt(wr) {
      return ne(wr) === "Int32Array";
    }
    B.isInt32Array = Yt;
    function Ut(wr) {
      return ne(wr) === "Float32Array";
    }
    B.isFloat32Array = Ut;
    function qt(wr) {
      return ne(wr) === "Float64Array";
    }
    B.isFloat64Array = qt;
    function zt(wr) {
      return ne(wr) === "BigInt64Array";
    }
    B.isBigInt64Array = zt;
    function Ft(wr) {
      return ne(wr) === "BigUint64Array";
    }
    B.isBigUint64Array = Ft;
    function Ve(wr) {
      return ve(wr) === "[object Map]";
    }
    Ve.working = typeof Map < "u" && Ve(/* @__PURE__ */ new Map());
    function Je(wr) {
      return typeof Map > "u" ? !1 : Ve.working ? Ve(wr) : wr instanceof Map;
    }
    B.isMap = Je;
    function Ke(wr) {
      return ve(wr) === "[object Set]";
    }
    Ke.working = typeof Set < "u" && Ke(/* @__PURE__ */ new Set());
    function Qe(wr) {
      return typeof Set > "u" ? !1 : Ke.working ? Ke(wr) : wr instanceof Set;
    }
    B.isSet = Qe;
    function bt(wr) {
      return ve(wr) === "[object WeakMap]";
    }
    bt.working = typeof WeakMap < "u" && bt(/* @__PURE__ */ new WeakMap());
    function _t(wr) {
      return typeof WeakMap > "u" ? !1 : bt.working ? bt(wr) : wr instanceof WeakMap;
    }
    B.isWeakMap = _t;
    function $t(wr) {
      return ve(wr) === "[object WeakSet]";
    }
    $t.working = typeof WeakSet < "u" && $t(/* @__PURE__ */ new WeakSet());
    function kt(wr) {
      return $t(wr);
    }
    B.isWeakSet = kt;
    function xt(wr) {
      return ve(wr) === "[object ArrayBuffer]";
    }
    xt.working = typeof ArrayBuffer < "u" && xt(new ArrayBuffer());
    function Nt(wr) {
      return typeof ArrayBuffer > "u" ? !1 : xt.working ? xt(wr) : wr instanceof ArrayBuffer;
    }
    B.isArrayBuffer = Nt;
    function Rt(wr) {
      return ve(wr) === "[object DataView]";
    }
    Rt.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Rt(new DataView(new ArrayBuffer(1), 0, 1));
    function Ht(wr) {
      return typeof DataView > "u" ? !1 : Rt.working ? Rt(wr) : wr instanceof DataView;
    }
    B.isDataView = Ht;
    var ar = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function lr(wr) {
      return ve(wr) === "[object SharedArrayBuffer]";
    }
    function nr(wr) {
      return typeof ar > "u" ? !1 : (typeof lr.working > "u" && (lr.working = lr(new ar())), lr.working ? lr(wr) : wr instanceof ar);
    }
    B.isSharedArrayBuffer = nr;
    function Vt(wr) {
      return ve(wr) === "[object AsyncFunction]";
    }
    B.isAsyncFunction = Vt;
    function Xt(wr) {
      return ve(wr) === "[object Map Iterator]";
    }
    B.isMapIterator = Xt;
    function sr(wr) {
      return ve(wr) === "[object Set Iterator]";
    }
    B.isSetIterator = sr;
    function dr(wr) {
      return ve(wr) === "[object Generator]";
    }
    B.isGeneratorObject = dr;
    function er(wr) {
      return ve(wr) === "[object WebAssembly.Module]";
    }
    B.isWebAssemblyCompiledModule = er;
    function Zt(wr) {
      return Xe(wr, ge);
    }
    B.isNumberObject = Zt;
    function pr(wr) {
      return Xe(wr, le);
    }
    B.isStringObject = pr;
    function _r(wr) {
      return Xe(wr, Ee);
    }
    B.isBooleanObject = _r;
    function Ar(wr) {
      return ae && Xe(wr, Ce);
    }
    B.isBigIntObject = Ar;
    function Sr(wr) {
      return se && Xe(wr, Pe);
    }
    B.isSymbolObject = Sr;
    function Br(wr) {
      return Zt(wr) || pr(wr) || _r(wr) || Ar(wr) || Sr(wr);
    }
    B.isBoxedPrimitive = Br;
    function Ir(wr) {
      return typeof Uint8Array < "u" && (Nt(wr) || nr(wr));
    }
    B.isAnyArrayBuffer = Ir, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(wr) {
      Object.defineProperty(B, wr, {
        enumerable: !1,
        value: function() {
          throw new Error(wr + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(z) {
    return z && typeof z == "object" && typeof z.copy == "function" && typeof z.fill == "function" && typeof z.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(B) {
    var z = Object.getOwnPropertyDescriptors || function(Ht) {
      for (var ar = Object.keys(Ht), lr = {}, nr = 0; nr < ar.length; nr++)
        lr[ar[nr]] = Object.getOwnPropertyDescriptor(Ht, ar[nr]);
      return lr;
    }, Y = /%[sdj%]/g;
    B.format = function(Rt) {
      if (!Wt(Rt)) {
        for (var Ht = [], ar = 0; ar < arguments.length; ar++)
          Ht.push(ae(arguments[ar]));
        return Ht.join(" ");
      }
      for (var ar = 1, lr = arguments, nr = lr.length, Vt = String(Rt).replace(Y, function(sr) {
        if (sr === "%%") return "%";
        if (ar >= nr) return sr;
        switch (sr) {
          case "%s":
            return String(lr[ar++]);
          case "%d":
            return Number(lr[ar++]);
          case "%j":
            try {
              return JSON.stringify(lr[ar++]);
            } catch {
              return "[Circular]";
            }
          default:
            return sr;
        }
      }), Xt = lr[ar]; ar < nr; Xt = lr[++ar])
        vt(Xt) || !qt(Xt) ? Vt += " " + Xt : Vt += " " + ae(Xt);
      return Vt;
    }, B.deprecate = function(Rt, Ht) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return Rt;
      if (typeof process$1 > "u")
        return function() {
          return B.deprecate(Rt, Ht).apply(this, arguments);
        };
      var ar = !1;
      function lr() {
        if (!ar) {
          if (process$1.throwDeprecation)
            throw new Error(Ht);
          process$1.traceDeprecation ? console.trace(Ht) : console.error(Ht), ar = !0;
        }
        return Rt.apply(this, arguments);
      }
      return lr;
    };
    var ne = {}, oe = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var ie = process$1.env.NODE_DEBUG;
      ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), oe = new RegExp("^" + ie + "$", "i");
    }
    B.debuglog = function(Rt) {
      if (Rt = Rt.toUpperCase(), !ne[Rt])
        if (oe.test(Rt)) {
          var Ht = process$1.pid;
          ne[Rt] = function() {
            var ar = B.format.apply(B, arguments);
            console.error("%s %d: %s", Rt, Ht, ar);
          };
        } else
          ne[Rt] = function() {
          };
      return ne[Rt];
    };
    function ae(Rt, Ht) {
      var ar = {
        seen: [],
        stylize: ve
      };
      return arguments.length >= 3 && (ar.depth = arguments[2]), arguments.length >= 4 && (ar.colors = arguments[3]), Pt(Ht) ? ar.showHidden = Ht : Ht && B._extend(ar, Ht), Yt(ar.showHidden) && (ar.showHidden = !1), Yt(ar.depth) && (ar.depth = 2), Yt(ar.colors) && (ar.colors = !1), Yt(ar.customInspect) && (ar.customInspect = !0), ar.colors && (ar.stylize = se), le(ar, Rt, ar.depth);
    }
    B.inspect = ae, ae.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, ae.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function se(Rt, Ht) {
      var ar = ae.styles[Ht];
      return ar ? "\x1B[" + ae.colors[ar][0] + "m" + Rt + "\x1B[" + ae.colors[ar][1] + "m" : Rt;
    }
    function ve(Rt, Ht) {
      return Rt;
    }
    function ge(Rt) {
      var Ht = {};
      return Rt.forEach(function(ar, lr) {
        Ht[ar] = !0;
      }), Ht;
    }
    function le(Rt, Ht, ar) {
      if (Rt.customInspect && Ht && Ve(Ht.inspect) && // Filter out the util module, it's inspect function is special
      Ht.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
      !(Ht.constructor && Ht.constructor.prototype === Ht)) {
        var lr = Ht.inspect(ar, Rt);
        return Wt(lr) || (lr = le(Rt, lr, ar)), lr;
      }
      var nr = Ee(Rt, Ht);
      if (nr)
        return nr;
      var Vt = Object.keys(Ht), Xt = ge(Vt);
      if (Rt.showHidden && (Vt = Object.getOwnPropertyNames(Ht)), Ft(Ht) && (Vt.indexOf("message") >= 0 || Vt.indexOf("description") >= 0))
        return Ce(Ht);
      if (Vt.length === 0) {
        if (Ve(Ht)) {
          var sr = Ht.name ? ": " + Ht.name : "";
          return Rt.stylize("[Function" + sr + "]", "special");
        }
        if (Ut(Ht))
          return Rt.stylize(RegExp.prototype.toString.call(Ht), "regexp");
        if (zt(Ht))
          return Rt.stylize(Date.prototype.toString.call(Ht), "date");
        if (Ft(Ht))
          return Ce(Ht);
      }
      var dr = "", er = !1, Zt = ["{", "}"];
      if (wt(Ht) && (er = !0, Zt = ["[", "]"]), Ve(Ht)) {
        var pr = Ht.name ? ": " + Ht.name : "";
        dr = " [Function" + pr + "]";
      }
      if (Ut(Ht) && (dr = " " + RegExp.prototype.toString.call(Ht)), zt(Ht) && (dr = " " + Date.prototype.toUTCString.call(Ht)), Ft(Ht) && (dr = " " + Ce(Ht)), Vt.length === 0 && (!er || Ht.length == 0))
        return Zt[0] + dr + Zt[1];
      if (ar < 0)
        return Ut(Ht) ? Rt.stylize(RegExp.prototype.toString.call(Ht), "regexp") : Rt.stylize("[Object]", "special");
      Rt.seen.push(Ht);
      var _r;
      return er ? _r = Pe(Rt, Ht, ar, Xt, Vt) : _r = Vt.map(function(Ar) {
        return Xe(Rt, Ht, ar, Xt, Ar, er);
      }), Rt.seen.pop(), ht(_r, dr, Zt);
    }
    function Ee(Rt, Ht) {
      if (Yt(Ht))
        return Rt.stylize("undefined", "undefined");
      if (Wt(Ht)) {
        var ar = "'" + JSON.stringify(Ht).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Rt.stylize(ar, "string");
      }
      if (Ct(Ht))
        return Rt.stylize("" + Ht, "number");
      if (Pt(Ht))
        return Rt.stylize("" + Ht, "boolean");
      if (vt(Ht))
        return Rt.stylize("null", "null");
    }
    function Ce(Rt) {
      return "[" + Error.prototype.toString.call(Rt) + "]";
    }
    function Pe(Rt, Ht, ar, lr, nr) {
      for (var Vt = [], Xt = 0, sr = Ht.length; Xt < sr; ++Xt)
        $t(Ht, String(Xt)) ? Vt.push(Xe(
          Rt,
          Ht,
          ar,
          lr,
          String(Xt),
          !0
        )) : Vt.push("");
      return nr.forEach(function(dr) {
        dr.match(/^\d+$/) || Vt.push(Xe(
          Rt,
          Ht,
          ar,
          lr,
          dr,
          !0
        ));
      }), Vt;
    }
    function Xe(Rt, Ht, ar, lr, nr, Vt) {
      var Xt, sr, dr;
      if (dr = Object.getOwnPropertyDescriptor(Ht, nr) || { value: Ht[nr] }, dr.get ? dr.set ? sr = Rt.stylize("[Getter/Setter]", "special") : sr = Rt.stylize("[Getter]", "special") : dr.set && (sr = Rt.stylize("[Setter]", "special")), $t(lr, nr) || (Xt = "[" + nr + "]"), sr || (Rt.seen.indexOf(dr.value) < 0 ? (vt(ar) ? sr = le(Rt, dr.value, null) : sr = le(Rt, dr.value, ar - 1), sr.indexOf(`
`) > -1 && (Vt ? sr = sr.split(`
`).map(function(er) {
        return "  " + er;
      }).join(`
`).slice(2) : sr = `
` + sr.split(`
`).map(function(er) {
        return "   " + er;
      }).join(`
`))) : sr = Rt.stylize("[Circular]", "special")), Yt(Xt)) {
        if (Vt && nr.match(/^\d+$/))
          return sr;
        Xt = JSON.stringify("" + nr), Xt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Xt = Xt.slice(1, -1), Xt = Rt.stylize(Xt, "name")) : (Xt = Xt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Xt = Rt.stylize(Xt, "string"));
      }
      return Xt + ": " + sr;
    }
    function ht(Rt, Ht, ar) {
      var lr = Rt.reduce(function(nr, Vt) {
        return Vt.indexOf(`
`) >= 0, nr + Vt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return lr > 60 ? ar[0] + (Ht === "" ? "" : Ht + `
 `) + " " + Rt.join(`,
  `) + " " + ar[1] : ar[0] + Ht + " " + Rt.join(", ") + " " + ar[1];
    }
    B.types = requireTypes();
    function wt(Rt) {
      return Array.isArray(Rt);
    }
    B.isArray = wt;
    function Pt(Rt) {
      return typeof Rt == "boolean";
    }
    B.isBoolean = Pt;
    function vt(Rt) {
      return Rt === null;
    }
    B.isNull = vt;
    function Bt(Rt) {
      return Rt == null;
    }
    B.isNullOrUndefined = Bt;
    function Ct(Rt) {
      return typeof Rt == "number";
    }
    B.isNumber = Ct;
    function Wt(Rt) {
      return typeof Rt == "string";
    }
    B.isString = Wt;
    function Kt(Rt) {
      return typeof Rt == "symbol";
    }
    B.isSymbol = Kt;
    function Yt(Rt) {
      return Rt === void 0;
    }
    B.isUndefined = Yt;
    function Ut(Rt) {
      return qt(Rt) && Ke(Rt) === "[object RegExp]";
    }
    B.isRegExp = Ut, B.types.isRegExp = Ut;
    function qt(Rt) {
      return typeof Rt == "object" && Rt !== null;
    }
    B.isObject = qt;
    function zt(Rt) {
      return qt(Rt) && Ke(Rt) === "[object Date]";
    }
    B.isDate = zt, B.types.isDate = zt;
    function Ft(Rt) {
      return qt(Rt) && (Ke(Rt) === "[object Error]" || Rt instanceof Error);
    }
    B.isError = Ft, B.types.isNativeError = Ft;
    function Ve(Rt) {
      return typeof Rt == "function";
    }
    B.isFunction = Ve;
    function Je(Rt) {
      return Rt === null || typeof Rt == "boolean" || typeof Rt == "number" || typeof Rt == "string" || typeof Rt == "symbol" || // ES6 symbol
      typeof Rt > "u";
    }
    B.isPrimitive = Je, B.isBuffer = requireIsBufferBrowser();
    function Ke(Rt) {
      return Object.prototype.toString.call(Rt);
    }
    function Qe(Rt) {
      return Rt < 10 ? "0" + Rt.toString(10) : Rt.toString(10);
    }
    var bt = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function _t() {
      var Rt = /* @__PURE__ */ new Date(), Ht = [
        Qe(Rt.getHours()),
        Qe(Rt.getMinutes()),
        Qe(Rt.getSeconds())
      ].join(":");
      return [Rt.getDate(), bt[Rt.getMonth()], Ht].join(" ");
    }
    B.log = function() {
      console.log("%s - %s", _t(), B.format.apply(B, arguments));
    }, B.inherits = requireInherits_browser(), B._extend = function(Rt, Ht) {
      if (!Ht || !qt(Ht)) return Rt;
      for (var ar = Object.keys(Ht), lr = ar.length; lr--; )
        Rt[ar[lr]] = Ht[ar[lr]];
      return Rt;
    };
    function $t(Rt, Ht) {
      return Object.prototype.hasOwnProperty.call(Rt, Ht);
    }
    var kt = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    B.promisify = function(Ht) {
      if (typeof Ht != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kt && Ht[kt]) {
        var ar = Ht[kt];
        if (typeof ar != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(ar, kt, {
          value: ar,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), ar;
      }
      function ar() {
        for (var lr, nr, Vt = new Promise(function(dr, er) {
          lr = dr, nr = er;
        }), Xt = [], sr = 0; sr < arguments.length; sr++)
          Xt.push(arguments[sr]);
        Xt.push(function(dr, er) {
          dr ? nr(dr) : lr(er);
        });
        try {
          Ht.apply(this, Xt);
        } catch (dr) {
          nr(dr);
        }
        return Vt;
      }
      return Object.setPrototypeOf(ar, Object.getPrototypeOf(Ht)), kt && Object.defineProperty(ar, kt, {
        value: ar,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        ar,
        z(Ht)
      );
    }, B.promisify.custom = kt;
    function xt(Rt, Ht) {
      if (!Rt) {
        var ar = new Error("Promise was rejected with a falsy value");
        ar.reason = Rt, Rt = ar;
      }
      return Ht(Rt);
    }
    function Nt(Rt) {
      if (typeof Rt != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Ht() {
        for (var ar = [], lr = 0; lr < arguments.length; lr++)
          ar.push(arguments[lr]);
        var nr = ar.pop();
        if (typeof nr != "function")
          throw new TypeError("The last argument must be of type Function");
        var Vt = this, Xt = function() {
          return nr.apply(Vt, arguments);
        };
        Rt.apply(this, ar).then(
          function(sr) {
            process$1.nextTick(Xt.bind(null, null, sr));
          },
          function(sr) {
            process$1.nextTick(xt.bind(null, sr, Xt));
          }
        );
      }
      return Object.setPrototypeOf(Ht, Object.getPrototypeOf(Rt)), Object.defineProperties(
        Ht,
        z(Rt)
      ), Ht;
    }
    B.callbackify = Nt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B(Xe, ht) {
    var wt = Object.keys(Xe);
    if (Object.getOwnPropertySymbols) {
      var Pt = Object.getOwnPropertySymbols(Xe);
      ht && (Pt = Pt.filter(function(vt) {
        return Object.getOwnPropertyDescriptor(Xe, vt).enumerable;
      })), wt.push.apply(wt, Pt);
    }
    return wt;
  }
  function z(Xe) {
    for (var ht = 1; ht < arguments.length; ht++) {
      var wt = arguments[ht] != null ? arguments[ht] : {};
      ht % 2 ? B(Object(wt), !0).forEach(function(Pt) {
        Y(Xe, Pt, wt[Pt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(Xe, Object.getOwnPropertyDescriptors(wt)) : B(Object(wt)).forEach(function(Pt) {
        Object.defineProperty(Xe, Pt, Object.getOwnPropertyDescriptor(wt, Pt));
      });
    }
    return Xe;
  }
  function Y(Xe, ht, wt) {
    return ht = ae(ht), ht in Xe ? Object.defineProperty(Xe, ht, { value: wt, enumerable: !0, configurable: !0, writable: !0 }) : Xe[ht] = wt, Xe;
  }
  function ne(Xe, ht) {
    if (!(Xe instanceof ht))
      throw new TypeError("Cannot call a class as a function");
  }
  function oe(Xe, ht) {
    for (var wt = 0; wt < ht.length; wt++) {
      var Pt = ht[wt];
      Pt.enumerable = Pt.enumerable || !1, Pt.configurable = !0, "value" in Pt && (Pt.writable = !0), Object.defineProperty(Xe, ae(Pt.key), Pt);
    }
  }
  function ie(Xe, ht, wt) {
    return ht && oe(Xe.prototype, ht), Object.defineProperty(Xe, "prototype", { writable: !1 }), Xe;
  }
  function ae(Xe) {
    var ht = se(Xe, "string");
    return typeof ht == "symbol" ? ht : String(ht);
  }
  function se(Xe, ht) {
    if (typeof Xe != "object" || Xe === null) return Xe;
    var wt = Xe[Symbol.toPrimitive];
    if (wt !== void 0) {
      var Pt = wt.call(Xe, ht);
      if (typeof Pt != "object") return Pt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(Xe);
  }
  var ve = dist$1, ge = ve.Buffer, le = requireUtil$1(), Ee = le.inspect, Ce = Ee && Ee.custom || "inspect";
  function Pe(Xe, ht, wt) {
    ge.prototype.copy.call(Xe, ht, wt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function Xe() {
      ne(this, Xe), this.head = null, this.tail = null, this.length = 0;
    }
    return ie(Xe, [{
      key: "push",
      value: function(wt) {
        var Pt = {
          data: wt,
          next: null
        };
        this.length > 0 ? this.tail.next = Pt : this.head = Pt, this.tail = Pt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(wt) {
        var Pt = {
          data: wt,
          next: this.head
        };
        this.length === 0 && (this.tail = Pt), this.head = Pt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var wt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, wt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(wt) {
        if (this.length === 0) return "";
        for (var Pt = this.head, vt = "" + Pt.data; Pt = Pt.next; ) vt += wt + Pt.data;
        return vt;
      }
    }, {
      key: "concat",
      value: function(wt) {
        if (this.length === 0) return ge.alloc(0);
        for (var Pt = ge.allocUnsafe(wt >>> 0), vt = this.head, Bt = 0; vt; )
          Pe(vt.data, Pt, Bt), Bt += vt.data.length, vt = vt.next;
        return Pt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(wt, Pt) {
        var vt;
        return wt < this.head.data.length ? (vt = this.head.data.slice(0, wt), this.head.data = this.head.data.slice(wt)) : wt === this.head.data.length ? vt = this.shift() : vt = Pt ? this._getString(wt) : this._getBuffer(wt), vt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(wt) {
        var Pt = this.head, vt = 1, Bt = Pt.data;
        for (wt -= Bt.length; Pt = Pt.next; ) {
          var Ct = Pt.data, Wt = wt > Ct.length ? Ct.length : wt;
          if (Wt === Ct.length ? Bt += Ct : Bt += Ct.slice(0, wt), wt -= Wt, wt === 0) {
            Wt === Ct.length ? (++vt, Pt.next ? this.head = Pt.next : this.head = this.tail = null) : (this.head = Pt, Pt.data = Ct.slice(Wt));
            break;
          }
          ++vt;
        }
        return this.length -= vt, Bt;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(wt) {
        var Pt = ge.allocUnsafe(wt), vt = this.head, Bt = 1;
        for (vt.data.copy(Pt), wt -= vt.data.length; vt = vt.next; ) {
          var Ct = vt.data, Wt = wt > Ct.length ? Ct.length : wt;
          if (Ct.copy(Pt, Pt.length - wt, 0, Wt), wt -= Wt, wt === 0) {
            Wt === Ct.length ? (++Bt, vt.next ? this.head = vt.next : this.head = this.tail = null) : (this.head = vt, vt.data = Ct.slice(Wt));
            break;
          }
          ++Bt;
        }
        return this.length -= Bt, Pt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Ce,
      value: function(wt, Pt) {
        return Ee(this, z(z({}, Pt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), Xe;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function B(ae, se) {
    var ve = this, ge = this._readableState && this._readableState.destroyed, le = this._writableState && this._writableState.destroyed;
    return ge || le ? (se ? se(ae) : ae && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(oe, this, ae)) : process$1.nextTick(oe, this, ae)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(ae || null, function(Ee) {
      !se && Ee ? ve._writableState ? ve._writableState.errorEmitted ? process$1.nextTick(Y, ve) : (ve._writableState.errorEmitted = !0, process$1.nextTick(z, ve, Ee)) : process$1.nextTick(z, ve, Ee) : se ? (process$1.nextTick(Y, ve), se(Ee)) : process$1.nextTick(Y, ve);
    }), this);
  }
  function z(ae, se) {
    oe(ae, se), Y(ae);
  }
  function Y(ae) {
    ae._writableState && !ae._writableState.emitClose || ae._readableState && !ae._readableState.emitClose || ae.emit("close");
  }
  function ne() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function oe(ae, se) {
    ae.emit("error", se);
  }
  function ie(ae, se) {
    var ve = ae._readableState, ge = ae._writableState;
    ve && ve.autoDestroy || ge && ge.autoDestroy ? ae.destroy(se) : ae.emit("error", se);
  }
  return destroy_1$1 = {
    destroy: B,
    undestroy: ne,
    errorOrDestroy: ie
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function B(se, ve) {
    se.prototype = Object.create(ve.prototype), se.prototype.constructor = se, se.__proto__ = ve;
  }
  var z = {};
  function Y(se, ve, ge) {
    ge || (ge = Error);
    function le(Ce, Pe, Xe) {
      return typeof ve == "string" ? ve : ve(Ce, Pe, Xe);
    }
    var Ee = /* @__PURE__ */ function(Ce) {
      B(Pe, Ce);
      function Pe(Xe, ht, wt) {
        return Ce.call(this, le(Xe, ht, wt)) || this;
      }
      return Pe;
    }(ge);
    Ee.prototype.name = ge.name, Ee.prototype.code = se, z[se] = Ee;
  }
  function ne(se, ve) {
    if (Array.isArray(se)) {
      var ge = se.length;
      return se = se.map(function(le) {
        return String(le);
      }), ge > 2 ? "one of ".concat(ve, " ").concat(se.slice(0, ge - 1).join(", "), ", or ") + se[ge - 1] : ge === 2 ? "one of ".concat(ve, " ").concat(se[0], " or ").concat(se[1]) : "of ".concat(ve, " ").concat(se[0]);
    } else
      return "of ".concat(ve, " ").concat(String(se));
  }
  function oe(se, ve, ge) {
    return se.substr(0, ve.length) === ve;
  }
  function ie(se, ve, ge) {
    return (ge === void 0 || ge > se.length) && (ge = se.length), se.substring(ge - ve.length, ge) === ve;
  }
  function ae(se, ve, ge) {
    return typeof ge != "number" && (ge = 0), ge + ve.length > se.length ? !1 : se.indexOf(ve, ge) !== -1;
  }
  return Y("ERR_INVALID_OPT_VALUE", function(se, ve) {
    return 'The value "' + ve + '" is invalid for option "' + se + '"';
  }, TypeError), Y("ERR_INVALID_ARG_TYPE", function(se, ve, ge) {
    var le;
    typeof ve == "string" && oe(ve, "not ") ? (le = "must not be", ve = ve.replace(/^not /, "")) : le = "must be";
    var Ee;
    if (ie(se, " argument"))
      Ee = "The ".concat(se, " ").concat(le, " ").concat(ne(ve, "type"));
    else {
      var Ce = ae(se, ".") ? "property" : "argument";
      Ee = 'The "'.concat(se, '" ').concat(Ce, " ").concat(le, " ").concat(ne(ve, "type"));
    }
    return Ee += ". Received type ".concat(typeof ge), Ee;
  }, TypeError), Y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Y("ERR_METHOD_NOT_IMPLEMENTED", function(se) {
    return "The " + se + " method is not implemented";
  }), Y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Y("ERR_STREAM_DESTROYED", function(se) {
    return "Cannot call " + se + " after a stream was destroyed";
  }), Y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Y("ERR_STREAM_WRITE_AFTER_END", "write after end"), Y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Y("ERR_UNKNOWN_ENCODING", function(se) {
    return "Unknown encoding: " + se;
  }, TypeError), Y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = z, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function z(ne, oe, ie) {
    return ne.highWaterMark != null ? ne.highWaterMark : oe ? ne[ie] : null;
  }
  function Y(ne, oe, ie, ae) {
    var se = z(oe, ae, ie);
    if (se != null) {
      if (!(isFinite(se) && Math.floor(se) === se) || se < 0) {
        var ve = ae ? ie : "highWaterMark";
        throw new B(ve, se);
      }
      return Math.floor(se);
    }
    return ne.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Y
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = B;
  function B(Y, ne) {
    if (z("noDeprecation"))
      return Y;
    var oe = !1;
    function ie() {
      if (!oe) {
        if (z("throwDeprecation"))
          throw new Error(ne);
        z("traceDeprecation") ? console.trace(ne) : console.warn(ne), oe = !0;
      }
      return Y.apply(this, arguments);
    }
    return ie;
  }
  function z(Y) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var ne = commonjsGlobal.localStorage[Y];
    return ne == null ? !1 : String(ne).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Ut;
  function B(nr) {
    var Vt = this;
    this.next = null, this.entry = null, this.finish = function() {
      lr(Vt, nr);
    };
  }
  var z;
  Ut.WritableState = Kt;
  var Y = {
    deprecate: requireBrowser$a()
  }, ne = requireStreamBrowser$1(), oe = dist$1.Buffer, ie = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ae(nr) {
    return oe.from(nr);
  }
  function se(nr) {
    return oe.isBuffer(nr) || nr instanceof ie;
  }
  var ve = requireDestroy$1(), ge = requireState(), le = ge.getHighWaterMark, Ee = requireErrorsBrowser().codes, Ce = Ee.ERR_INVALID_ARG_TYPE, Pe = Ee.ERR_METHOD_NOT_IMPLEMENTED, Xe = Ee.ERR_MULTIPLE_CALLBACK, ht = Ee.ERR_STREAM_CANNOT_PIPE, wt = Ee.ERR_STREAM_DESTROYED, Pt = Ee.ERR_STREAM_NULL_VALUES, vt = Ee.ERR_STREAM_WRITE_AFTER_END, Bt = Ee.ERR_UNKNOWN_ENCODING, Ct = ve.errorOrDestroy;
  requireInherits_browser()(Ut, ne);
  function Wt() {
  }
  function Kt(nr, Vt, Xt) {
    z = z || require_stream_duplex$1(), nr = nr || {}, typeof Xt != "boolean" && (Xt = Vt instanceof z), this.objectMode = !!nr.objectMode, Xt && (this.objectMode = this.objectMode || !!nr.writableObjectMode), this.highWaterMark = le(this, nr, "writableHighWaterMark", Xt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var sr = nr.decodeStrings === !1;
    this.decodeStrings = !sr, this.defaultEncoding = nr.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(dr) {
      bt(Vt, dr);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = nr.emitClose !== !1, this.autoDestroy = !!nr.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Kt.prototype.getBuffer = function() {
    for (var Vt = this.bufferedRequest, Xt = []; Vt; )
      Xt.push(Vt), Vt = Vt.next;
    return Xt;
  }, function() {
    try {
      Object.defineProperty(Kt.prototype, "buffer", {
        get: Y.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Yt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Yt = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ut, Symbol.hasInstance, {
    value: function(Vt) {
      return Yt.call(this, Vt) ? !0 : this !== Ut ? !1 : Vt && Vt._writableState instanceof Kt;
    }
  })) : Yt = function(Vt) {
    return Vt instanceof this;
  };
  function Ut(nr) {
    z = z || require_stream_duplex$1();
    var Vt = this instanceof z;
    if (!Vt && !Yt.call(Ut, this)) return new Ut(nr);
    this._writableState = new Kt(nr, this, Vt), this.writable = !0, nr && (typeof nr.write == "function" && (this._write = nr.write), typeof nr.writev == "function" && (this._writev = nr.writev), typeof nr.destroy == "function" && (this._destroy = nr.destroy), typeof nr.final == "function" && (this._final = nr.final)), ne.call(this);
  }
  Ut.prototype.pipe = function() {
    Ct(this, new ht());
  };
  function qt(nr, Vt) {
    var Xt = new vt();
    Ct(nr, Xt), process$1.nextTick(Vt, Xt);
  }
  function zt(nr, Vt, Xt, sr) {
    var dr;
    return Xt === null ? dr = new Pt() : typeof Xt != "string" && !Vt.objectMode && (dr = new Ce("chunk", ["string", "Buffer"], Xt)), dr ? (Ct(nr, dr), process$1.nextTick(sr, dr), !1) : !0;
  }
  Ut.prototype.write = function(nr, Vt, Xt) {
    var sr = this._writableState, dr = !1, er = !sr.objectMode && se(nr);
    return er && !oe.isBuffer(nr) && (nr = ae(nr)), typeof Vt == "function" && (Xt = Vt, Vt = null), er ? Vt = "buffer" : Vt || (Vt = sr.defaultEncoding), typeof Xt != "function" && (Xt = Wt), sr.ending ? qt(this, Xt) : (er || zt(this, sr, nr, Xt)) && (sr.pendingcb++, dr = Ve(this, sr, er, nr, Vt, Xt)), dr;
  }, Ut.prototype.cork = function() {
    this._writableState.corked++;
  }, Ut.prototype.uncork = function() {
    var nr = this._writableState;
    nr.corked && (nr.corked--, !nr.writing && !nr.corked && !nr.bufferProcessing && nr.bufferedRequest && kt(this, nr));
  }, Ut.prototype.setDefaultEncoding = function(Vt) {
    if (typeof Vt == "string" && (Vt = Vt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Vt + "").toLowerCase()) > -1)) throw new Bt(Vt);
    return this._writableState.defaultEncoding = Vt, this;
  }, Object.defineProperty(Ut.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Ft(nr, Vt, Xt) {
    return !nr.objectMode && nr.decodeStrings !== !1 && typeof Vt == "string" && (Vt = oe.from(Vt, Xt)), Vt;
  }
  Object.defineProperty(Ut.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ve(nr, Vt, Xt, sr, dr, er) {
    if (!Xt) {
      var Zt = Ft(Vt, sr, dr);
      sr !== Zt && (Xt = !0, dr = "buffer", sr = Zt);
    }
    var pr = Vt.objectMode ? 1 : sr.length;
    Vt.length += pr;
    var _r = Vt.length < Vt.highWaterMark;
    if (_r || (Vt.needDrain = !0), Vt.writing || Vt.corked) {
      var Ar = Vt.lastBufferedRequest;
      Vt.lastBufferedRequest = {
        chunk: sr,
        encoding: dr,
        isBuf: Xt,
        callback: er,
        next: null
      }, Ar ? Ar.next = Vt.lastBufferedRequest : Vt.bufferedRequest = Vt.lastBufferedRequest, Vt.bufferedRequestCount += 1;
    } else
      Je(nr, Vt, !1, pr, sr, dr, er);
    return _r;
  }
  function Je(nr, Vt, Xt, sr, dr, er, Zt) {
    Vt.writelen = sr, Vt.writecb = Zt, Vt.writing = !0, Vt.sync = !0, Vt.destroyed ? Vt.onwrite(new wt("write")) : Xt ? nr._writev(dr, Vt.onwrite) : nr._write(dr, er, Vt.onwrite), Vt.sync = !1;
  }
  function Ke(nr, Vt, Xt, sr, dr) {
    --Vt.pendingcb, Xt ? (process$1.nextTick(dr, sr), process$1.nextTick(Ht, nr, Vt), nr._writableState.errorEmitted = !0, Ct(nr, sr)) : (dr(sr), nr._writableState.errorEmitted = !0, Ct(nr, sr), Ht(nr, Vt));
  }
  function Qe(nr) {
    nr.writing = !1, nr.writecb = null, nr.length -= nr.writelen, nr.writelen = 0;
  }
  function bt(nr, Vt) {
    var Xt = nr._writableState, sr = Xt.sync, dr = Xt.writecb;
    if (typeof dr != "function") throw new Xe();
    if (Qe(Xt), Vt) Ke(nr, Xt, sr, Vt, dr);
    else {
      var er = xt(Xt) || nr.destroyed;
      !er && !Xt.corked && !Xt.bufferProcessing && Xt.bufferedRequest && kt(nr, Xt), sr ? process$1.nextTick(_t, nr, Xt, er, dr) : _t(nr, Xt, er, dr);
    }
  }
  function _t(nr, Vt, Xt, sr) {
    Xt || $t(nr, Vt), Vt.pendingcb--, sr(), Ht(nr, Vt);
  }
  function $t(nr, Vt) {
    Vt.length === 0 && Vt.needDrain && (Vt.needDrain = !1, nr.emit("drain"));
  }
  function kt(nr, Vt) {
    Vt.bufferProcessing = !0;
    var Xt = Vt.bufferedRequest;
    if (nr._writev && Xt && Xt.next) {
      var sr = Vt.bufferedRequestCount, dr = new Array(sr), er = Vt.corkedRequestsFree;
      er.entry = Xt;
      for (var Zt = 0, pr = !0; Xt; )
        dr[Zt] = Xt, Xt.isBuf || (pr = !1), Xt = Xt.next, Zt += 1;
      dr.allBuffers = pr, Je(nr, Vt, !0, Vt.length, dr, "", er.finish), Vt.pendingcb++, Vt.lastBufferedRequest = null, er.next ? (Vt.corkedRequestsFree = er.next, er.next = null) : Vt.corkedRequestsFree = new B(Vt), Vt.bufferedRequestCount = 0;
    } else {
      for (; Xt; ) {
        var _r = Xt.chunk, Ar = Xt.encoding, Sr = Xt.callback, Br = Vt.objectMode ? 1 : _r.length;
        if (Je(nr, Vt, !1, Br, _r, Ar, Sr), Xt = Xt.next, Vt.bufferedRequestCount--, Vt.writing)
          break;
      }
      Xt === null && (Vt.lastBufferedRequest = null);
    }
    Vt.bufferedRequest = Xt, Vt.bufferProcessing = !1;
  }
  Ut.prototype._write = function(nr, Vt, Xt) {
    Xt(new Pe("_write()"));
  }, Ut.prototype._writev = null, Ut.prototype.end = function(nr, Vt, Xt) {
    var sr = this._writableState;
    return typeof nr == "function" ? (Xt = nr, nr = null, Vt = null) : typeof Vt == "function" && (Xt = Vt, Vt = null), nr != null && this.write(nr, Vt), sr.corked && (sr.corked = 1, this.uncork()), sr.ending || ar(this, sr, Xt), this;
  }, Object.defineProperty(Ut.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function xt(nr) {
    return nr.ending && nr.length === 0 && nr.bufferedRequest === null && !nr.finished && !nr.writing;
  }
  function Nt(nr, Vt) {
    nr._final(function(Xt) {
      Vt.pendingcb--, Xt && Ct(nr, Xt), Vt.prefinished = !0, nr.emit("prefinish"), Ht(nr, Vt);
    });
  }
  function Rt(nr, Vt) {
    !Vt.prefinished && !Vt.finalCalled && (typeof nr._final == "function" && !Vt.destroyed ? (Vt.pendingcb++, Vt.finalCalled = !0, process$1.nextTick(Nt, nr, Vt)) : (Vt.prefinished = !0, nr.emit("prefinish")));
  }
  function Ht(nr, Vt) {
    var Xt = xt(Vt);
    if (Xt && (Rt(nr, Vt), Vt.pendingcb === 0 && (Vt.finished = !0, nr.emit("finish"), Vt.autoDestroy))) {
      var sr = nr._readableState;
      (!sr || sr.autoDestroy && sr.endEmitted) && nr.destroy();
    }
    return Xt;
  }
  function ar(nr, Vt, Xt) {
    Vt.ending = !0, Ht(nr, Vt), Xt && (Vt.finished ? process$1.nextTick(Xt) : nr.once("finish", Xt)), Vt.ended = !0, nr.writable = !1;
  }
  function lr(nr, Vt, Xt) {
    var sr = nr.entry;
    for (nr.entry = null; sr; ) {
      var dr = sr.callback;
      Vt.pendingcb--, dr(Xt), sr = sr.next;
    }
    Vt.corkedRequestsFree.next = nr;
  }
  return Object.defineProperty(Ut.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Vt) {
      this._writableState && (this._writableState.destroyed = Vt);
    }
  }), Ut.prototype.destroy = ve.destroy, Ut.prototype._undestroy = ve.undestroy, Ut.prototype._destroy = function(nr, Vt) {
    Vt(nr);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(ge) {
    var le = [];
    for (var Ee in ge) le.push(Ee);
    return le;
  };
  _stream_duplex$1 = ae;
  var z = require_stream_readable$1(), Y = require_stream_writable$1();
  requireInherits_browser()(ae, z);
  for (var ne = B(Y.prototype), oe = 0; oe < ne.length; oe++) {
    var ie = ne[oe];
    ae.prototype[ie] || (ae.prototype[ie] = Y.prototype[ie]);
  }
  function ae(ge) {
    if (!(this instanceof ae)) return new ae(ge);
    z.call(this, ge), Y.call(this, ge), this.allowHalfOpen = !0, ge && (ge.readable === !1 && (this.readable = !1), ge.writable === !1 && (this.writable = !1), ge.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", se)));
  }
  Object.defineProperty(ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function se() {
    this._writableState.ended || process$1.nextTick(ve, this);
  }
  function ve(ge) {
    ge.end();
  }
  return Object.defineProperty(ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(le) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = le, this._writableState.destroyed = le);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var B = safeBufferExports.Buffer, z = B.isEncoding || function(Pt) {
    switch (Pt = "" + Pt, Pt && Pt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function Y(Pt) {
    if (!Pt) return "utf8";
    for (var vt; ; )
      switch (Pt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return Pt;
        default:
          if (vt) return;
          Pt = ("" + Pt).toLowerCase(), vt = !0;
      }
  }
  function ne(Pt) {
    var vt = Y(Pt);
    if (typeof vt != "string" && (B.isEncoding === z || !z(Pt))) throw new Error("Unknown encoding: " + Pt);
    return vt || Pt;
  }
  string_decoder.StringDecoder = oe;
  function oe(Pt) {
    this.encoding = ne(Pt);
    var vt;
    switch (this.encoding) {
      case "utf16le":
        this.text = Ee, this.end = Ce, vt = 4;
        break;
      case "utf8":
        this.fillLast = ve, vt = 4;
        break;
      case "base64":
        this.text = Pe, this.end = Xe, vt = 3;
        break;
      default:
        this.write = ht, this.end = wt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = B.allocUnsafe(vt);
  }
  oe.prototype.write = function(Pt) {
    if (Pt.length === 0) return "";
    var vt, Bt;
    if (this.lastNeed) {
      if (vt = this.fillLast(Pt), vt === void 0) return "";
      Bt = this.lastNeed, this.lastNeed = 0;
    } else
      Bt = 0;
    return Bt < Pt.length ? vt ? vt + this.text(Pt, Bt) : this.text(Pt, Bt) : vt || "";
  }, oe.prototype.end = le, oe.prototype.text = ge, oe.prototype.fillLast = function(Pt) {
    if (this.lastNeed <= Pt.length)
      return Pt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Pt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Pt.length), this.lastNeed -= Pt.length;
  };
  function ie(Pt) {
    return Pt <= 127 ? 0 : Pt >> 5 === 6 ? 2 : Pt >> 4 === 14 ? 3 : Pt >> 3 === 30 ? 4 : Pt >> 6 === 2 ? -1 : -2;
  }
  function ae(Pt, vt, Bt) {
    var Ct = vt.length - 1;
    if (Ct < Bt) return 0;
    var Wt = ie(vt[Ct]);
    return Wt >= 0 ? (Wt > 0 && (Pt.lastNeed = Wt - 1), Wt) : --Ct < Bt || Wt === -2 ? 0 : (Wt = ie(vt[Ct]), Wt >= 0 ? (Wt > 0 && (Pt.lastNeed = Wt - 2), Wt) : --Ct < Bt || Wt === -2 ? 0 : (Wt = ie(vt[Ct]), Wt >= 0 ? (Wt > 0 && (Wt === 2 ? Wt = 0 : Pt.lastNeed = Wt - 3), Wt) : 0));
  }
  function se(Pt, vt, Bt) {
    if ((vt[0] & 192) !== 128)
      return Pt.lastNeed = 0, "";
    if (Pt.lastNeed > 1 && vt.length > 1) {
      if ((vt[1] & 192) !== 128)
        return Pt.lastNeed = 1, "";
      if (Pt.lastNeed > 2 && vt.length > 2 && (vt[2] & 192) !== 128)
        return Pt.lastNeed = 2, "";
    }
  }
  function ve(Pt) {
    var vt = this.lastTotal - this.lastNeed, Bt = se(this, Pt);
    if (Bt !== void 0) return Bt;
    if (this.lastNeed <= Pt.length)
      return Pt.copy(this.lastChar, vt, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Pt.copy(this.lastChar, vt, 0, Pt.length), this.lastNeed -= Pt.length;
  }
  function ge(Pt, vt) {
    var Bt = ae(this, Pt, vt);
    if (!this.lastNeed) return Pt.toString("utf8", vt);
    this.lastTotal = Bt;
    var Ct = Pt.length - (Bt - this.lastNeed);
    return Pt.copy(this.lastChar, 0, Ct), Pt.toString("utf8", vt, Ct);
  }
  function le(Pt) {
    var vt = Pt && Pt.length ? this.write(Pt) : "";
    return this.lastNeed ? vt + "" : vt;
  }
  function Ee(Pt, vt) {
    if ((Pt.length - vt) % 2 === 0) {
      var Bt = Pt.toString("utf16le", vt);
      if (Bt) {
        var Ct = Bt.charCodeAt(Bt.length - 1);
        if (Ct >= 55296 && Ct <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Pt[Pt.length - 2], this.lastChar[1] = Pt[Pt.length - 1], Bt.slice(0, -1);
      }
      return Bt;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Pt[Pt.length - 1], Pt.toString("utf16le", vt, Pt.length - 1);
  }
  function Ce(Pt) {
    var vt = Pt && Pt.length ? this.write(Pt) : "";
    if (this.lastNeed) {
      var Bt = this.lastTotal - this.lastNeed;
      return vt + this.lastChar.toString("utf16le", 0, Bt);
    }
    return vt;
  }
  function Pe(Pt, vt) {
    var Bt = (Pt.length - vt) % 3;
    return Bt === 0 ? Pt.toString("base64", vt) : (this.lastNeed = 3 - Bt, this.lastTotal = 3, Bt === 1 ? this.lastChar[0] = Pt[Pt.length - 1] : (this.lastChar[0] = Pt[Pt.length - 2], this.lastChar[1] = Pt[Pt.length - 1]), Pt.toString("base64", vt, Pt.length - Bt));
  }
  function Xe(Pt) {
    var vt = Pt && Pt.length ? this.write(Pt) : "";
    return this.lastNeed ? vt + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : vt;
  }
  function ht(Pt) {
    return Pt.toString(this.encoding);
  }
  function wt(Pt) {
    return Pt && Pt.length ? this.write(Pt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function z(ie) {
    var ae = !1;
    return function() {
      if (!ae) {
        ae = !0;
        for (var se = arguments.length, ve = new Array(se), ge = 0; ge < se; ge++)
          ve[ge] = arguments[ge];
        ie.apply(this, ve);
      }
    };
  }
  function Y() {
  }
  function ne(ie) {
    return ie.setHeader && typeof ie.abort == "function";
  }
  function oe(ie, ae, se) {
    if (typeof ae == "function") return oe(ie, null, ae);
    ae || (ae = {}), se = z(se || Y);
    var ve = ae.readable || ae.readable !== !1 && ie.readable, ge = ae.writable || ae.writable !== !1 && ie.writable, le = function() {
      ie.writable || Ce();
    }, Ee = ie._writableState && ie._writableState.finished, Ce = function() {
      ge = !1, Ee = !0, ve || se.call(ie);
    }, Pe = ie._readableState && ie._readableState.endEmitted, Xe = function() {
      ve = !1, Pe = !0, ge || se.call(ie);
    }, ht = function(Bt) {
      se.call(ie, Bt);
    }, wt = function() {
      var Bt;
      if (ve && !Pe)
        return (!ie._readableState || !ie._readableState.ended) && (Bt = new B()), se.call(ie, Bt);
      if (ge && !Ee)
        return (!ie._writableState || !ie._writableState.ended) && (Bt = new B()), se.call(ie, Bt);
    }, Pt = function() {
      ie.req.on("finish", Ce);
    };
    return ne(ie) ? (ie.on("complete", Ce), ie.on("abort", wt), ie.req ? Pt() : ie.on("request", Pt)) : ge && !ie._writableState && (ie.on("end", le), ie.on("close", le)), ie.on("end", Xe), ie.on("finish", Ce), ae.error !== !1 && ie.on("error", ht), ie.on("close", wt), function() {
      ie.removeListener("complete", Ce), ie.removeListener("abort", wt), ie.removeListener("request", Pt), ie.req && ie.req.removeListener("finish", Ce), ie.removeListener("end", le), ie.removeListener("close", le), ie.removeListener("finish", Ce), ie.removeListener("end", Xe), ie.removeListener("error", ht), ie.removeListener("close", wt);
    };
  }
  return endOfStream = oe, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function z(Bt, Ct, Wt) {
    return Ct = Y(Ct), Ct in Bt ? Object.defineProperty(Bt, Ct, { value: Wt, enumerable: !0, configurable: !0, writable: !0 }) : Bt[Ct] = Wt, Bt;
  }
  function Y(Bt) {
    var Ct = ne(Bt, "string");
    return typeof Ct == "symbol" ? Ct : String(Ct);
  }
  function ne(Bt, Ct) {
    if (typeof Bt != "object" || Bt === null) return Bt;
    var Wt = Bt[Symbol.toPrimitive];
    if (Wt !== void 0) {
      var Kt = Wt.call(Bt, Ct);
      if (typeof Kt != "object") return Kt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (Ct === "string" ? String : Number)(Bt);
  }
  var oe = requireEndOfStream(), ie = Symbol("lastResolve"), ae = Symbol("lastReject"), se = Symbol("error"), ve = Symbol("ended"), ge = Symbol("lastPromise"), le = Symbol("handlePromise"), Ee = Symbol("stream");
  function Ce(Bt, Ct) {
    return {
      value: Bt,
      done: Ct
    };
  }
  function Pe(Bt) {
    var Ct = Bt[ie];
    if (Ct !== null) {
      var Wt = Bt[Ee].read();
      Wt !== null && (Bt[ge] = null, Bt[ie] = null, Bt[ae] = null, Ct(Ce(Wt, !1)));
    }
  }
  function Xe(Bt) {
    process$1.nextTick(Pe, Bt);
  }
  function ht(Bt, Ct) {
    return function(Wt, Kt) {
      Bt.then(function() {
        if (Ct[ve]) {
          Wt(Ce(void 0, !0));
          return;
        }
        Ct[le](Wt, Kt);
      }, Kt);
    };
  }
  var wt = Object.getPrototypeOf(function() {
  }), Pt = Object.setPrototypeOf((B = {
    get stream() {
      return this[Ee];
    },
    next: function() {
      var Ct = this, Wt = this[se];
      if (Wt !== null)
        return Promise.reject(Wt);
      if (this[ve])
        return Promise.resolve(Ce(void 0, !0));
      if (this[Ee].destroyed)
        return new Promise(function(qt, zt) {
          process$1.nextTick(function() {
            Ct[se] ? zt(Ct[se]) : qt(Ce(void 0, !0));
          });
        });
      var Kt = this[ge], Yt;
      if (Kt)
        Yt = new Promise(ht(Kt, this));
      else {
        var Ut = this[Ee].read();
        if (Ut !== null)
          return Promise.resolve(Ce(Ut, !1));
        Yt = new Promise(this[le]);
      }
      return this[ge] = Yt, Yt;
    }
  }, z(B, Symbol.asyncIterator, function() {
    return this;
  }), z(B, "return", function() {
    var Ct = this;
    return new Promise(function(Wt, Kt) {
      Ct[Ee].destroy(null, function(Yt) {
        if (Yt) {
          Kt(Yt);
          return;
        }
        Wt(Ce(void 0, !0));
      });
    });
  }), B), wt), vt = function(Ct) {
    var Wt, Kt = Object.create(Pt, (Wt = {}, z(Wt, Ee, {
      value: Ct,
      writable: !0
    }), z(Wt, ie, {
      value: null,
      writable: !0
    }), z(Wt, ae, {
      value: null,
      writable: !0
    }), z(Wt, se, {
      value: null,
      writable: !0
    }), z(Wt, ve, {
      value: Ct._readableState.endEmitted,
      writable: !0
    }), z(Wt, le, {
      value: function(Ut, qt) {
        var zt = Kt[Ee].read();
        zt ? (Kt[ge] = null, Kt[ie] = null, Kt[ae] = null, Ut(Ce(zt, !1))) : (Kt[ie] = Ut, Kt[ae] = qt);
      },
      writable: !0
    }), Wt));
    return Kt[ge] = null, oe(Ct, function(Yt) {
      if (Yt && Yt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ut = Kt[ae];
        Ut !== null && (Kt[ge] = null, Kt[ie] = null, Kt[ae] = null, Ut(Yt)), Kt[se] = Yt;
        return;
      }
      var qt = Kt[ie];
      qt !== null && (Kt[ge] = null, Kt[ie] = null, Kt[ae] = null, qt(Ce(void 0, !0))), Kt[ve] = !0;
    }), Ct.on("readable", Xe.bind(null, Kt)), Kt;
  };
  return async_iterator = vt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = qt;
  var B;
  qt.ReadableState = Ut, requireEvents().EventEmitter;
  var z = function(Zt, pr) {
    return Zt.listeners(pr).length;
  }, Y = requireStreamBrowser$1(), ne = dist$1.Buffer, oe = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ie(er) {
    return ne.from(er);
  }
  function ae(er) {
    return ne.isBuffer(er) || er instanceof oe;
  }
  var se = requireUtil$1(), ve;
  se && se.debuglog ? ve = se.debuglog("stream") : ve = function() {
  };
  var ge = requireBuffer_list(), le = requireDestroy$1(), Ee = requireState(), Ce = Ee.getHighWaterMark, Pe = requireErrorsBrowser().codes, Xe = Pe.ERR_INVALID_ARG_TYPE, ht = Pe.ERR_STREAM_PUSH_AFTER_EOF, wt = Pe.ERR_METHOD_NOT_IMPLEMENTED, Pt = Pe.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, vt, Bt, Ct;
  requireInherits_browser()(qt, Y);
  var Wt = le.errorOrDestroy, Kt = ["error", "close", "destroy", "pause", "resume"];
  function Yt(er, Zt, pr) {
    if (typeof er.prependListener == "function") return er.prependListener(Zt, pr);
    !er._events || !er._events[Zt] ? er.on(Zt, pr) : Array.isArray(er._events[Zt]) ? er._events[Zt].unshift(pr) : er._events[Zt] = [pr, er._events[Zt]];
  }
  function Ut(er, Zt, pr) {
    B = B || require_stream_duplex$1(), er = er || {}, typeof pr != "boolean" && (pr = Zt instanceof B), this.objectMode = !!er.objectMode, pr && (this.objectMode = this.objectMode || !!er.readableObjectMode), this.highWaterMark = Ce(this, er, "readableHighWaterMark", pr), this.buffer = new ge(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = er.emitClose !== !1, this.autoDestroy = !!er.autoDestroy, this.destroyed = !1, this.defaultEncoding = er.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, er.encoding && (vt || (vt = requireString_decoder().StringDecoder), this.decoder = new vt(er.encoding), this.encoding = er.encoding);
  }
  function qt(er) {
    if (B = B || require_stream_duplex$1(), !(this instanceof qt)) return new qt(er);
    var Zt = this instanceof B;
    this._readableState = new Ut(er, this, Zt), this.readable = !0, er && (typeof er.read == "function" && (this._read = er.read), typeof er.destroy == "function" && (this._destroy = er.destroy)), Y.call(this);
  }
  Object.defineProperty(qt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Zt) {
      this._readableState && (this._readableState.destroyed = Zt);
    }
  }), qt.prototype.destroy = le.destroy, qt.prototype._undestroy = le.undestroy, qt.prototype._destroy = function(er, Zt) {
    Zt(er);
  }, qt.prototype.push = function(er, Zt) {
    var pr = this._readableState, _r;
    return pr.objectMode ? _r = !0 : typeof er == "string" && (Zt = Zt || pr.defaultEncoding, Zt !== pr.encoding && (er = ne.from(er, Zt), Zt = ""), _r = !0), zt(this, er, Zt, !1, _r);
  }, qt.prototype.unshift = function(er) {
    return zt(this, er, null, !0, !1);
  };
  function zt(er, Zt, pr, _r, Ar) {
    ve("readableAddChunk", Zt);
    var Sr = er._readableState;
    if (Zt === null)
      Sr.reading = !1, bt(er, Sr);
    else {
      var Br;
      if (Ar || (Br = Ve(Sr, Zt)), Br)
        Wt(er, Br);
      else if (Sr.objectMode || Zt && Zt.length > 0)
        if (typeof Zt != "string" && !Sr.objectMode && Object.getPrototypeOf(Zt) !== ne.prototype && (Zt = ie(Zt)), _r)
          Sr.endEmitted ? Wt(er, new Pt()) : Ft(er, Sr, Zt, !0);
        else if (Sr.ended)
          Wt(er, new ht());
        else {
          if (Sr.destroyed)
            return !1;
          Sr.reading = !1, Sr.decoder && !pr ? (Zt = Sr.decoder.write(Zt), Sr.objectMode || Zt.length !== 0 ? Ft(er, Sr, Zt, !1) : kt(er, Sr)) : Ft(er, Sr, Zt, !1);
        }
      else _r || (Sr.reading = !1, kt(er, Sr));
    }
    return !Sr.ended && (Sr.length < Sr.highWaterMark || Sr.length === 0);
  }
  function Ft(er, Zt, pr, _r) {
    Zt.flowing && Zt.length === 0 && !Zt.sync ? (Zt.awaitDrain = 0, er.emit("data", pr)) : (Zt.length += Zt.objectMode ? 1 : pr.length, _r ? Zt.buffer.unshift(pr) : Zt.buffer.push(pr), Zt.needReadable && _t(er)), kt(er, Zt);
  }
  function Ve(er, Zt) {
    var pr;
    return !ae(Zt) && typeof Zt != "string" && Zt !== void 0 && !er.objectMode && (pr = new Xe("chunk", ["string", "Buffer", "Uint8Array"], Zt)), pr;
  }
  qt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, qt.prototype.setEncoding = function(er) {
    vt || (vt = requireString_decoder().StringDecoder);
    var Zt = new vt(er);
    this._readableState.decoder = Zt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var pr = this._readableState.buffer.head, _r = ""; pr !== null; )
      _r += Zt.write(pr.data), pr = pr.next;
    return this._readableState.buffer.clear(), _r !== "" && this._readableState.buffer.push(_r), this._readableState.length = _r.length, this;
  };
  var Je = 1073741824;
  function Ke(er) {
    return er >= Je ? er = Je : (er--, er |= er >>> 1, er |= er >>> 2, er |= er >>> 4, er |= er >>> 8, er |= er >>> 16, er++), er;
  }
  function Qe(er, Zt) {
    return er <= 0 || Zt.length === 0 && Zt.ended ? 0 : Zt.objectMode ? 1 : er !== er ? Zt.flowing && Zt.length ? Zt.buffer.head.data.length : Zt.length : (er > Zt.highWaterMark && (Zt.highWaterMark = Ke(er)), er <= Zt.length ? er : Zt.ended ? Zt.length : (Zt.needReadable = !0, 0));
  }
  qt.prototype.read = function(er) {
    ve("read", er), er = parseInt(er, 10);
    var Zt = this._readableState, pr = er;
    if (er !== 0 && (Zt.emittedReadable = !1), er === 0 && Zt.needReadable && ((Zt.highWaterMark !== 0 ? Zt.length >= Zt.highWaterMark : Zt.length > 0) || Zt.ended))
      return ve("read: emitReadable", Zt.length, Zt.ended), Zt.length === 0 && Zt.ended ? Xt(this) : _t(this), null;
    if (er = Qe(er, Zt), er === 0 && Zt.ended)
      return Zt.length === 0 && Xt(this), null;
    var _r = Zt.needReadable;
    ve("need readable", _r), (Zt.length === 0 || Zt.length - er < Zt.highWaterMark) && (_r = !0, ve("length less than watermark", _r)), Zt.ended || Zt.reading ? (_r = !1, ve("reading or ended", _r)) : _r && (ve("do read"), Zt.reading = !0, Zt.sync = !0, Zt.length === 0 && (Zt.needReadable = !0), this._read(Zt.highWaterMark), Zt.sync = !1, Zt.reading || (er = Qe(pr, Zt)));
    var Ar;
    return er > 0 ? Ar = Vt(er, Zt) : Ar = null, Ar === null ? (Zt.needReadable = Zt.length <= Zt.highWaterMark, er = 0) : (Zt.length -= er, Zt.awaitDrain = 0), Zt.length === 0 && (Zt.ended || (Zt.needReadable = !0), pr !== er && Zt.ended && Xt(this)), Ar !== null && this.emit("data", Ar), Ar;
  };
  function bt(er, Zt) {
    if (ve("onEofChunk"), !Zt.ended) {
      if (Zt.decoder) {
        var pr = Zt.decoder.end();
        pr && pr.length && (Zt.buffer.push(pr), Zt.length += Zt.objectMode ? 1 : pr.length);
      }
      Zt.ended = !0, Zt.sync ? _t(er) : (Zt.needReadable = !1, Zt.emittedReadable || (Zt.emittedReadable = !0, $t(er)));
    }
  }
  function _t(er) {
    var Zt = er._readableState;
    ve("emitReadable", Zt.needReadable, Zt.emittedReadable), Zt.needReadable = !1, Zt.emittedReadable || (ve("emitReadable", Zt.flowing), Zt.emittedReadable = !0, process$1.nextTick($t, er));
  }
  function $t(er) {
    var Zt = er._readableState;
    ve("emitReadable_", Zt.destroyed, Zt.length, Zt.ended), !Zt.destroyed && (Zt.length || Zt.ended) && (er.emit("readable"), Zt.emittedReadable = !1), Zt.needReadable = !Zt.flowing && !Zt.ended && Zt.length <= Zt.highWaterMark, nr(er);
  }
  function kt(er, Zt) {
    Zt.readingMore || (Zt.readingMore = !0, process$1.nextTick(xt, er, Zt));
  }
  function xt(er, Zt) {
    for (; !Zt.reading && !Zt.ended && (Zt.length < Zt.highWaterMark || Zt.flowing && Zt.length === 0); ) {
      var pr = Zt.length;
      if (ve("maybeReadMore read 0"), er.read(0), pr === Zt.length)
        break;
    }
    Zt.readingMore = !1;
  }
  qt.prototype._read = function(er) {
    Wt(this, new wt("_read()"));
  }, qt.prototype.pipe = function(er, Zt) {
    var pr = this, _r = this._readableState;
    switch (_r.pipesCount) {
      case 0:
        _r.pipes = er;
        break;
      case 1:
        _r.pipes = [_r.pipes, er];
        break;
      default:
        _r.pipes.push(er);
        break;
    }
    _r.pipesCount += 1, ve("pipe count=%d opts=%j", _r.pipesCount, Zt);
    var Ar = (!Zt || Zt.end !== !1) && er !== process$1.stdout && er !== process$1.stderr, Sr = Ar ? Ir : Yr;
    _r.endEmitted ? process$1.nextTick(Sr) : pr.once("end", Sr), er.on("unpipe", Br);
    function Br(Nr, zr) {
      ve("onunpipe"), Nr === pr && zr && zr.hasUnpiped === !1 && (zr.hasUnpiped = !0, Pr());
    }
    function Ir() {
      ve("onend"), er.end();
    }
    var wr = Nt(pr);
    er.on("drain", wr);
    var Gr = !1;
    function Pr() {
      ve("cleanup"), er.removeListener("close", Tr), er.removeListener("finish", Hr), er.removeListener("drain", wr), er.removeListener("error", Cr), er.removeListener("unpipe", Br), pr.removeListener("end", Ir), pr.removeListener("end", Yr), pr.removeListener("data", Mr), Gr = !0, _r.awaitDrain && (!er._writableState || er._writableState.needDrain) && wr();
    }
    pr.on("data", Mr);
    function Mr(Nr) {
      ve("ondata");
      var zr = er.write(Nr);
      ve("dest.write", zr), zr === !1 && ((_r.pipesCount === 1 && _r.pipes === er || _r.pipesCount > 1 && dr(_r.pipes, er) !== -1) && !Gr && (ve("false write response, pause", _r.awaitDrain), _r.awaitDrain++), pr.pause());
    }
    function Cr(Nr) {
      ve("onerror", Nr), Yr(), er.removeListener("error", Cr), z(er, "error") === 0 && Wt(er, Nr);
    }
    Yt(er, "error", Cr);
    function Tr() {
      er.removeListener("finish", Hr), Yr();
    }
    er.once("close", Tr);
    function Hr() {
      ve("onfinish"), er.removeListener("close", Tr), Yr();
    }
    er.once("finish", Hr);
    function Yr() {
      ve("unpipe"), pr.unpipe(er);
    }
    return er.emit("pipe", pr), _r.flowing || (ve("pipe resume"), pr.resume()), er;
  };
  function Nt(er) {
    return function() {
      var pr = er._readableState;
      ve("pipeOnDrain", pr.awaitDrain), pr.awaitDrain && pr.awaitDrain--, pr.awaitDrain === 0 && z(er, "data") && (pr.flowing = !0, nr(er));
    };
  }
  qt.prototype.unpipe = function(er) {
    var Zt = this._readableState, pr = {
      hasUnpiped: !1
    };
    if (Zt.pipesCount === 0) return this;
    if (Zt.pipesCount === 1)
      return er && er !== Zt.pipes ? this : (er || (er = Zt.pipes), Zt.pipes = null, Zt.pipesCount = 0, Zt.flowing = !1, er && er.emit("unpipe", this, pr), this);
    if (!er) {
      var _r = Zt.pipes, Ar = Zt.pipesCount;
      Zt.pipes = null, Zt.pipesCount = 0, Zt.flowing = !1;
      for (var Sr = 0; Sr < Ar; Sr++) _r[Sr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var Br = dr(Zt.pipes, er);
    return Br === -1 ? this : (Zt.pipes.splice(Br, 1), Zt.pipesCount -= 1, Zt.pipesCount === 1 && (Zt.pipes = Zt.pipes[0]), er.emit("unpipe", this, pr), this);
  }, qt.prototype.on = function(er, Zt) {
    var pr = Y.prototype.on.call(this, er, Zt), _r = this._readableState;
    return er === "data" ? (_r.readableListening = this.listenerCount("readable") > 0, _r.flowing !== !1 && this.resume()) : er === "readable" && !_r.endEmitted && !_r.readableListening && (_r.readableListening = _r.needReadable = !0, _r.flowing = !1, _r.emittedReadable = !1, ve("on readable", _r.length, _r.reading), _r.length ? _t(this) : _r.reading || process$1.nextTick(Ht, this)), pr;
  }, qt.prototype.addListener = qt.prototype.on, qt.prototype.removeListener = function(er, Zt) {
    var pr = Y.prototype.removeListener.call(this, er, Zt);
    return er === "readable" && process$1.nextTick(Rt, this), pr;
  }, qt.prototype.removeAllListeners = function(er) {
    var Zt = Y.prototype.removeAllListeners.apply(this, arguments);
    return (er === "readable" || er === void 0) && process$1.nextTick(Rt, this), Zt;
  };
  function Rt(er) {
    var Zt = er._readableState;
    Zt.readableListening = er.listenerCount("readable") > 0, Zt.resumeScheduled && !Zt.paused ? Zt.flowing = !0 : er.listenerCount("data") > 0 && er.resume();
  }
  function Ht(er) {
    ve("readable nexttick read 0"), er.read(0);
  }
  qt.prototype.resume = function() {
    var er = this._readableState;
    return er.flowing || (ve("resume"), er.flowing = !er.readableListening, ar(this, er)), er.paused = !1, this;
  };
  function ar(er, Zt) {
    Zt.resumeScheduled || (Zt.resumeScheduled = !0, process$1.nextTick(lr, er, Zt));
  }
  function lr(er, Zt) {
    ve("resume", Zt.reading), Zt.reading || er.read(0), Zt.resumeScheduled = !1, er.emit("resume"), nr(er), Zt.flowing && !Zt.reading && er.read(0);
  }
  qt.prototype.pause = function() {
    return ve("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ve("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function nr(er) {
    var Zt = er._readableState;
    for (ve("flow", Zt.flowing); Zt.flowing && er.read() !== null; ) ;
  }
  qt.prototype.wrap = function(er) {
    var Zt = this, pr = this._readableState, _r = !1;
    er.on("end", function() {
      if (ve("wrapped end"), pr.decoder && !pr.ended) {
        var Br = pr.decoder.end();
        Br && Br.length && Zt.push(Br);
      }
      Zt.push(null);
    }), er.on("data", function(Br) {
      if (ve("wrapped data"), pr.decoder && (Br = pr.decoder.write(Br)), !(pr.objectMode && Br == null) && !(!pr.objectMode && (!Br || !Br.length))) {
        var Ir = Zt.push(Br);
        Ir || (_r = !0, er.pause());
      }
    });
    for (var Ar in er)
      this[Ar] === void 0 && typeof er[Ar] == "function" && (this[Ar] = /* @__PURE__ */ function(Ir) {
        return function() {
          return er[Ir].apply(er, arguments);
        };
      }(Ar));
    for (var Sr = 0; Sr < Kt.length; Sr++)
      er.on(Kt[Sr], this.emit.bind(this, Kt[Sr]));
    return this._read = function(Br) {
      ve("wrapped _read", Br), _r && (_r = !1, er.resume());
    }, this;
  }, typeof Symbol == "function" && (qt.prototype[Symbol.asyncIterator] = function() {
    return Bt === void 0 && (Bt = requireAsync_iterator()), Bt(this);
  }), Object.defineProperty(qt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(qt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(qt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Zt) {
      this._readableState && (this._readableState.flowing = Zt);
    }
  }), qt._fromList = Vt, Object.defineProperty(qt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Vt(er, Zt) {
    if (Zt.length === 0) return null;
    var pr;
    return Zt.objectMode ? pr = Zt.buffer.shift() : !er || er >= Zt.length ? (Zt.decoder ? pr = Zt.buffer.join("") : Zt.buffer.length === 1 ? pr = Zt.buffer.first() : pr = Zt.buffer.concat(Zt.length), Zt.buffer.clear()) : pr = Zt.buffer.consume(er, Zt.decoder), pr;
  }
  function Xt(er) {
    var Zt = er._readableState;
    ve("endReadable", Zt.endEmitted), Zt.endEmitted || (Zt.ended = !0, process$1.nextTick(sr, Zt, er));
  }
  function sr(er, Zt) {
    if (ve("endReadableNT", er.endEmitted, er.length), !er.endEmitted && er.length === 0 && (er.endEmitted = !0, Zt.readable = !1, Zt.emit("end"), er.autoDestroy)) {
      var pr = Zt._writableState;
      (!pr || pr.autoDestroy && pr.finished) && Zt.destroy();
    }
  }
  typeof Symbol == "function" && (qt.from = function(er, Zt) {
    return Ct === void 0 && (Ct = requireFromBrowser()), Ct(qt, er, Zt);
  });
  function dr(er, Zt) {
    for (var pr = 0, _r = er.length; pr < _r; pr++)
      if (er[pr] === Zt) return pr;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = se;
  var B = requireErrorsBrowser().codes, z = B.ERR_METHOD_NOT_IMPLEMENTED, Y = B.ERR_MULTIPLE_CALLBACK, ne = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, oe = B.ERR_TRANSFORM_WITH_LENGTH_0, ie = require_stream_duplex$1();
  requireInherits_browser()(se, ie);
  function ae(le, Ee) {
    var Ce = this._transformState;
    Ce.transforming = !1;
    var Pe = Ce.writecb;
    if (Pe === null)
      return this.emit("error", new Y());
    Ce.writechunk = null, Ce.writecb = null, Ee != null && this.push(Ee), Pe(le);
    var Xe = this._readableState;
    Xe.reading = !1, (Xe.needReadable || Xe.length < Xe.highWaterMark) && this._read(Xe.highWaterMark);
  }
  function se(le) {
    if (!(this instanceof se)) return new se(le);
    ie.call(this, le), this._transformState = {
      afterTransform: ae.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, le && (typeof le.transform == "function" && (this._transform = le.transform), typeof le.flush == "function" && (this._flush = le.flush)), this.on("prefinish", ve);
  }
  function ve() {
    var le = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Ee, Ce) {
      ge(le, Ee, Ce);
    }) : ge(this, null, null);
  }
  se.prototype.push = function(le, Ee) {
    return this._transformState.needTransform = !1, ie.prototype.push.call(this, le, Ee);
  }, se.prototype._transform = function(le, Ee, Ce) {
    Ce(new z("_transform()"));
  }, se.prototype._write = function(le, Ee, Ce) {
    var Pe = this._transformState;
    if (Pe.writecb = Ce, Pe.writechunk = le, Pe.writeencoding = Ee, !Pe.transforming) {
      var Xe = this._readableState;
      (Pe.needTransform || Xe.needReadable || Xe.length < Xe.highWaterMark) && this._read(Xe.highWaterMark);
    }
  }, se.prototype._read = function(le) {
    var Ee = this._transformState;
    Ee.writechunk !== null && !Ee.transforming ? (Ee.transforming = !0, this._transform(Ee.writechunk, Ee.writeencoding, Ee.afterTransform)) : Ee.needTransform = !0;
  }, se.prototype._destroy = function(le, Ee) {
    ie.prototype._destroy.call(this, le, function(Ce) {
      Ee(Ce);
    });
  };
  function ge(le, Ee, Ce) {
    if (Ee) return le.emit("error", Ee);
    if (Ce != null && le.push(Ce), le._writableState.length) throw new oe();
    if (le._transformState.transforming) throw new ne();
    return le.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = z;
  var B = require_stream_transform$1();
  requireInherits_browser()(z, B);
  function z(Y) {
    if (!(this instanceof z)) return new z(Y);
    B.call(this, Y);
  }
  return z.prototype._transform = function(Y, ne, oe) {
    oe(null, Y);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var B;
  function z(Ce) {
    var Pe = !1;
    return function() {
      Pe || (Pe = !0, Ce.apply(void 0, arguments));
    };
  }
  var Y = requireErrorsBrowser().codes, ne = Y.ERR_MISSING_ARGS, oe = Y.ERR_STREAM_DESTROYED;
  function ie(Ce) {
    if (Ce) throw Ce;
  }
  function ae(Ce) {
    return Ce.setHeader && typeof Ce.abort == "function";
  }
  function se(Ce, Pe, Xe, ht) {
    ht = z(ht);
    var wt = !1;
    Ce.on("close", function() {
      wt = !0;
    }), B === void 0 && (B = requireEndOfStream()), B(Ce, {
      readable: Pe,
      writable: Xe
    }, function(vt) {
      if (vt) return ht(vt);
      wt = !0, ht();
    });
    var Pt = !1;
    return function(vt) {
      if (!wt && !Pt) {
        if (Pt = !0, ae(Ce)) return Ce.abort();
        if (typeof Ce.destroy == "function") return Ce.destroy();
        ht(vt || new oe("pipe"));
      }
    };
  }
  function ve(Ce) {
    Ce();
  }
  function ge(Ce, Pe) {
    return Ce.pipe(Pe);
  }
  function le(Ce) {
    return !Ce.length || typeof Ce[Ce.length - 1] != "function" ? ie : Ce.pop();
  }
  function Ee() {
    for (var Ce = arguments.length, Pe = new Array(Ce), Xe = 0; Xe < Ce; Xe++)
      Pe[Xe] = arguments[Xe];
    var ht = le(Pe);
    if (Array.isArray(Pe[0]) && (Pe = Pe[0]), Pe.length < 2)
      throw new ne("streams");
    var wt, Pt = Pe.map(function(vt, Bt) {
      var Ct = Bt < Pe.length - 1, Wt = Bt > 0;
      return se(vt, Ct, Wt, function(Kt) {
        wt || (wt = Kt), Kt && Pt.forEach(ve), !Ct && (Pt.forEach(ve), ht(wt));
      });
    });
    return Pe.reduce(ge);
  }
  return pipeline_1 = Ee, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(B, z) {
    z = B.exports = require_stream_readable$1(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable$1(), z.Duplex = require_stream_duplex$1(), z.Transform = require_stream_transform$1(), z.PassThrough = require_stream_passthrough$1(), z.finished = requireEndOfStream(), z.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var B = safeBufferExports.Buffer, z = requireReadableBrowser$1().Transform, Y = requireInherits_browser();
  function ne(ie, ae) {
    if (!B.isBuffer(ie) && typeof ie != "string")
      throw new TypeError(ae + " must be a string or a buffer");
  }
  function oe(ie) {
    z.call(this), this._block = B.allocUnsafe(ie), this._blockSize = ie, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Y(oe, z), oe.prototype._transform = function(ie, ae, se) {
    var ve = null;
    try {
      this.update(ie, ae);
    } catch (ge) {
      ve = ge;
    }
    se(ve);
  }, oe.prototype._flush = function(ie) {
    var ae = null;
    try {
      this.push(this.digest());
    } catch (se) {
      ae = se;
    }
    ie(ae);
  }, oe.prototype.update = function(ie, ae) {
    if (ne(ie, "Data"), this._finalized) throw new Error("Digest already called");
    B.isBuffer(ie) || (ie = B.from(ie, ae));
    for (var se = this._block, ve = 0; this._blockOffset + ie.length - ve >= this._blockSize; ) {
      for (var ge = this._blockOffset; ge < this._blockSize; ) se[ge++] = ie[ve++];
      this._update(), this._blockOffset = 0;
    }
    for (; ve < ie.length; ) se[this._blockOffset++] = ie[ve++];
    for (var le = 0, Ee = ie.length * 8; Ee > 0; ++le)
      this._length[le] += Ee, Ee = this._length[le] / 4294967296 | 0, Ee > 0 && (this._length[le] -= 4294967296 * Ee);
    return this;
  }, oe.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, oe.prototype.digest = function(ie) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var ae = this._digest();
    ie !== void 0 && (ae = ae.toString(ie)), this._block.fill(0), this._blockOffset = 0;
    for (var se = 0; se < 4; ++se) this._length[se] = 0;
    return ae;
  }, oe.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = oe, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var B = requireInherits_browser(), z = requireHashBase(), Y = safeBufferExports.Buffer, ne = new Array(16);
  function oe() {
    z.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  B(oe, z), oe.prototype._update = function() {
    for (var le = ne, Ee = 0; Ee < 16; ++Ee) le[Ee] = this._block.readInt32LE(Ee * 4);
    var Ce = this._a, Pe = this._b, Xe = this._c, ht = this._d;
    Ce = ae(Ce, Pe, Xe, ht, le[0], 3614090360, 7), ht = ae(ht, Ce, Pe, Xe, le[1], 3905402710, 12), Xe = ae(Xe, ht, Ce, Pe, le[2], 606105819, 17), Pe = ae(Pe, Xe, ht, Ce, le[3], 3250441966, 22), Ce = ae(Ce, Pe, Xe, ht, le[4], 4118548399, 7), ht = ae(ht, Ce, Pe, Xe, le[5], 1200080426, 12), Xe = ae(Xe, ht, Ce, Pe, le[6], 2821735955, 17), Pe = ae(Pe, Xe, ht, Ce, le[7], 4249261313, 22), Ce = ae(Ce, Pe, Xe, ht, le[8], 1770035416, 7), ht = ae(ht, Ce, Pe, Xe, le[9], 2336552879, 12), Xe = ae(Xe, ht, Ce, Pe, le[10], 4294925233, 17), Pe = ae(Pe, Xe, ht, Ce, le[11], 2304563134, 22), Ce = ae(Ce, Pe, Xe, ht, le[12], 1804603682, 7), ht = ae(ht, Ce, Pe, Xe, le[13], 4254626195, 12), Xe = ae(Xe, ht, Ce, Pe, le[14], 2792965006, 17), Pe = ae(Pe, Xe, ht, Ce, le[15], 1236535329, 22), Ce = se(Ce, Pe, Xe, ht, le[1], 4129170786, 5), ht = se(ht, Ce, Pe, Xe, le[6], 3225465664, 9), Xe = se(Xe, ht, Ce, Pe, le[11], 643717713, 14), Pe = se(Pe, Xe, ht, Ce, le[0], 3921069994, 20), Ce = se(Ce, Pe, Xe, ht, le[5], 3593408605, 5), ht = se(ht, Ce, Pe, Xe, le[10], 38016083, 9), Xe = se(Xe, ht, Ce, Pe, le[15], 3634488961, 14), Pe = se(Pe, Xe, ht, Ce, le[4], 3889429448, 20), Ce = se(Ce, Pe, Xe, ht, le[9], 568446438, 5), ht = se(ht, Ce, Pe, Xe, le[14], 3275163606, 9), Xe = se(Xe, ht, Ce, Pe, le[3], 4107603335, 14), Pe = se(Pe, Xe, ht, Ce, le[8], 1163531501, 20), Ce = se(Ce, Pe, Xe, ht, le[13], 2850285829, 5), ht = se(ht, Ce, Pe, Xe, le[2], 4243563512, 9), Xe = se(Xe, ht, Ce, Pe, le[7], 1735328473, 14), Pe = se(Pe, Xe, ht, Ce, le[12], 2368359562, 20), Ce = ve(Ce, Pe, Xe, ht, le[5], 4294588738, 4), ht = ve(ht, Ce, Pe, Xe, le[8], 2272392833, 11), Xe = ve(Xe, ht, Ce, Pe, le[11], 1839030562, 16), Pe = ve(Pe, Xe, ht, Ce, le[14], 4259657740, 23), Ce = ve(Ce, Pe, Xe, ht, le[1], 2763975236, 4), ht = ve(ht, Ce, Pe, Xe, le[4], 1272893353, 11), Xe = ve(Xe, ht, Ce, Pe, le[7], 4139469664, 16), Pe = ve(Pe, Xe, ht, Ce, le[10], 3200236656, 23), Ce = ve(Ce, Pe, Xe, ht, le[13], 681279174, 4), ht = ve(ht, Ce, Pe, Xe, le[0], 3936430074, 11), Xe = ve(Xe, ht, Ce, Pe, le[3], 3572445317, 16), Pe = ve(Pe, Xe, ht, Ce, le[6], 76029189, 23), Ce = ve(Ce, Pe, Xe, ht, le[9], 3654602809, 4), ht = ve(ht, Ce, Pe, Xe, le[12], 3873151461, 11), Xe = ve(Xe, ht, Ce, Pe, le[15], 530742520, 16), Pe = ve(Pe, Xe, ht, Ce, le[2], 3299628645, 23), Ce = ge(Ce, Pe, Xe, ht, le[0], 4096336452, 6), ht = ge(ht, Ce, Pe, Xe, le[7], 1126891415, 10), Xe = ge(Xe, ht, Ce, Pe, le[14], 2878612391, 15), Pe = ge(Pe, Xe, ht, Ce, le[5], 4237533241, 21), Ce = ge(Ce, Pe, Xe, ht, le[12], 1700485571, 6), ht = ge(ht, Ce, Pe, Xe, le[3], 2399980690, 10), Xe = ge(Xe, ht, Ce, Pe, le[10], 4293915773, 15), Pe = ge(Pe, Xe, ht, Ce, le[1], 2240044497, 21), Ce = ge(Ce, Pe, Xe, ht, le[8], 1873313359, 6), ht = ge(ht, Ce, Pe, Xe, le[15], 4264355552, 10), Xe = ge(Xe, ht, Ce, Pe, le[6], 2734768916, 15), Pe = ge(Pe, Xe, ht, Ce, le[13], 1309151649, 21), Ce = ge(Ce, Pe, Xe, ht, le[4], 4149444226, 6), ht = ge(ht, Ce, Pe, Xe, le[11], 3174756917, 10), Xe = ge(Xe, ht, Ce, Pe, le[2], 718787259, 15), Pe = ge(Pe, Xe, ht, Ce, le[9], 3951481745, 21), this._a = this._a + Ce | 0, this._b = this._b + Pe | 0, this._c = this._c + Xe | 0, this._d = this._d + ht | 0;
  }, oe.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var le = Y.allocUnsafe(16);
    return le.writeInt32LE(this._a, 0), le.writeInt32LE(this._b, 4), le.writeInt32LE(this._c, 8), le.writeInt32LE(this._d, 12), le;
  };
  function ie(le, Ee) {
    return le << Ee | le >>> 32 - Ee;
  }
  function ae(le, Ee, Ce, Pe, Xe, ht, wt) {
    return ie(le + (Ee & Ce | ~Ee & Pe) + Xe + ht | 0, wt) + Ee | 0;
  }
  function se(le, Ee, Ce, Pe, Xe, ht, wt) {
    return ie(le + (Ee & Pe | Ce & ~Pe) + Xe + ht | 0, wt) + Ee | 0;
  }
  function ve(le, Ee, Ce, Pe, Xe, ht, wt) {
    return ie(le + (Ee ^ Ce ^ Pe) + Xe + ht | 0, wt) + Ee | 0;
  }
  function ge(le, Ee, Ce, Pe, Xe, ht, wt) {
    return ie(le + (Ce ^ (Ee | ~Pe)) + Xe + ht | 0, wt) + Ee | 0;
  }
  return md5_js = oe, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var B = dist$1.Buffer, z = requireInherits_browser(), Y = requireHashBase(), ne = new Array(16), oe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ie = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], ae = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], se = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ve = [0, 1518500249, 1859775393, 2400959708, 2840853838], ge = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function le() {
    Y.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  z(le, Y), le.prototype._update = function() {
    for (var Pt = ne, vt = 0; vt < 16; ++vt) Pt[vt] = this._block.readInt32LE(vt * 4);
    for (var Bt = this._a | 0, Ct = this._b | 0, Wt = this._c | 0, Kt = this._d | 0, Yt = this._e | 0, Ut = this._a | 0, qt = this._b | 0, zt = this._c | 0, Ft = this._d | 0, Ve = this._e | 0, Je = 0; Je < 80; Je += 1) {
      var Ke, Qe;
      Je < 16 ? (Ke = Ce(Bt, Ct, Wt, Kt, Yt, Pt[oe[Je]], ve[0], ae[Je]), Qe = wt(Ut, qt, zt, Ft, Ve, Pt[ie[Je]], ge[0], se[Je])) : Je < 32 ? (Ke = Pe(Bt, Ct, Wt, Kt, Yt, Pt[oe[Je]], ve[1], ae[Je]), Qe = ht(Ut, qt, zt, Ft, Ve, Pt[ie[Je]], ge[1], se[Je])) : Je < 48 ? (Ke = Xe(Bt, Ct, Wt, Kt, Yt, Pt[oe[Je]], ve[2], ae[Je]), Qe = Xe(Ut, qt, zt, Ft, Ve, Pt[ie[Je]], ge[2], se[Je])) : Je < 64 ? (Ke = ht(Bt, Ct, Wt, Kt, Yt, Pt[oe[Je]], ve[3], ae[Je]), Qe = Pe(Ut, qt, zt, Ft, Ve, Pt[ie[Je]], ge[3], se[Je])) : (Ke = wt(Bt, Ct, Wt, Kt, Yt, Pt[oe[Je]], ve[4], ae[Je]), Qe = Ce(Ut, qt, zt, Ft, Ve, Pt[ie[Je]], ge[4], se[Je])), Bt = Yt, Yt = Kt, Kt = Ee(Wt, 10), Wt = Ct, Ct = Ke, Ut = Ve, Ve = Ft, Ft = Ee(zt, 10), zt = qt, qt = Qe;
    }
    var bt = this._b + Wt + Ft | 0;
    this._b = this._c + Kt + Ve | 0, this._c = this._d + Yt + Ut | 0, this._d = this._e + Bt + qt | 0, this._e = this._a + Ct + zt | 0, this._a = bt;
  }, le.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var Pt = B.alloc ? B.alloc(20) : new B(20);
    return Pt.writeInt32LE(this._a, 0), Pt.writeInt32LE(this._b, 4), Pt.writeInt32LE(this._c, 8), Pt.writeInt32LE(this._d, 12), Pt.writeInt32LE(this._e, 16), Pt;
  };
  function Ee(Pt, vt) {
    return Pt << vt | Pt >>> 32 - vt;
  }
  function Ce(Pt, vt, Bt, Ct, Wt, Kt, Yt, Ut) {
    return Ee(Pt + (vt ^ Bt ^ Ct) + Kt + Yt | 0, Ut) + Wt | 0;
  }
  function Pe(Pt, vt, Bt, Ct, Wt, Kt, Yt, Ut) {
    return Ee(Pt + (vt & Bt | ~vt & Ct) + Kt + Yt | 0, Ut) + Wt | 0;
  }
  function Xe(Pt, vt, Bt, Ct, Wt, Kt, Yt, Ut) {
    return Ee(Pt + ((vt | ~Bt) ^ Ct) + Kt + Yt | 0, Ut) + Wt | 0;
  }
  function ht(Pt, vt, Bt, Ct, Wt, Kt, Yt, Ut) {
    return Ee(Pt + (vt & Ct | Bt & ~Ct) + Kt + Yt | 0, Ut) + Wt | 0;
  }
  function wt(Pt, vt, Bt, Ct, Wt, Kt, Yt, Ut) {
    return Ee(Pt + (vt ^ (Bt | ~Ct)) + Kt + Yt | 0, Ut) + Wt | 0;
  }
  return ripemd160$1 = le, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var B = safeBufferExports.Buffer;
  function z(Y, ne) {
    this._block = B.alloc(Y), this._finalSize = ne, this._blockSize = Y, this._len = 0;
  }
  return z.prototype.update = function(Y, ne) {
    typeof Y == "string" && (ne = ne || "utf8", Y = B.from(Y, ne));
    for (var oe = this._block, ie = this._blockSize, ae = Y.length, se = this._len, ve = 0; ve < ae; ) {
      for (var ge = se % ie, le = Math.min(ae - ve, ie - ge), Ee = 0; Ee < le; Ee++)
        oe[ge + Ee] = Y[ve + Ee];
      se += le, ve += le, se % ie === 0 && this._update(oe);
    }
    return this._len += ae, this;
  }, z.prototype.digest = function(Y) {
    var ne = this._len % this._blockSize;
    this._block[ne] = 128, this._block.fill(0, ne + 1), ne >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var oe = this._len * 8;
    if (oe <= 4294967295)
      this._block.writeUInt32BE(oe, this._blockSize - 4);
    else {
      var ie = (oe & 4294967295) >>> 0, ae = (oe - ie) / 4294967296;
      this._block.writeUInt32BE(ae, this._blockSize - 8), this._block.writeUInt32BE(ie, this._blockSize - 4);
    }
    this._update(this._block);
    var se = this._hash();
    return Y ? se.toString(Y) : se;
  }, z.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = z, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], oe = new Array(80);
  function ie() {
    this.init(), this._w = oe, z.call(this, 64, 56);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function ae(ge) {
    return ge << 5 | ge >>> 27;
  }
  function se(ge) {
    return ge << 30 | ge >>> 2;
  }
  function ve(ge, le, Ee, Ce) {
    return ge === 0 ? le & Ee | ~le & Ce : ge === 2 ? le & Ee | le & Ce | Ee & Ce : le ^ Ee ^ Ce;
  }
  return ie.prototype._update = function(ge) {
    for (var le = this._w, Ee = this._a | 0, Ce = this._b | 0, Pe = this._c | 0, Xe = this._d | 0, ht = this._e | 0, wt = 0; wt < 16; ++wt) le[wt] = ge.readInt32BE(wt * 4);
    for (; wt < 80; ++wt) le[wt] = le[wt - 3] ^ le[wt - 8] ^ le[wt - 14] ^ le[wt - 16];
    for (var Pt = 0; Pt < 80; ++Pt) {
      var vt = ~~(Pt / 20), Bt = ae(Ee) + ve(vt, Ce, Pe, Xe) + ht + le[Pt] + ne[vt] | 0;
      ht = Xe, Xe = Pe, Pe = se(Ce), Ce = Ee, Ee = Bt;
    }
    this._a = Ee + this._a | 0, this._b = Ce + this._b | 0, this._c = Pe + this._c | 0, this._d = Xe + this._d | 0, this._e = ht + this._e | 0;
  }, ie.prototype._hash = function() {
    var ge = Y.allocUnsafe(20);
    return ge.writeInt32BE(this._a | 0, 0), ge.writeInt32BE(this._b | 0, 4), ge.writeInt32BE(this._c | 0, 8), ge.writeInt32BE(this._d | 0, 12), ge.writeInt32BE(this._e | 0, 16), ge;
  }, sha$1 = ie, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], oe = new Array(80);
  function ie() {
    this.init(), this._w = oe, z.call(this, 64, 56);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function ae(le) {
    return le << 1 | le >>> 31;
  }
  function se(le) {
    return le << 5 | le >>> 27;
  }
  function ve(le) {
    return le << 30 | le >>> 2;
  }
  function ge(le, Ee, Ce, Pe) {
    return le === 0 ? Ee & Ce | ~Ee & Pe : le === 2 ? Ee & Ce | Ee & Pe | Ce & Pe : Ee ^ Ce ^ Pe;
  }
  return ie.prototype._update = function(le) {
    for (var Ee = this._w, Ce = this._a | 0, Pe = this._b | 0, Xe = this._c | 0, ht = this._d | 0, wt = this._e | 0, Pt = 0; Pt < 16; ++Pt) Ee[Pt] = le.readInt32BE(Pt * 4);
    for (; Pt < 80; ++Pt) Ee[Pt] = ae(Ee[Pt - 3] ^ Ee[Pt - 8] ^ Ee[Pt - 14] ^ Ee[Pt - 16]);
    for (var vt = 0; vt < 80; ++vt) {
      var Bt = ~~(vt / 20), Ct = se(Ce) + ge(Bt, Pe, Xe, ht) + wt + Ee[vt] + ne[Bt] | 0;
      wt = ht, ht = Xe, Xe = ve(Pe), Pe = Ce, Ce = Ct;
    }
    this._a = Ce + this._a | 0, this._b = Pe + this._b | 0, this._c = Xe + this._c | 0, this._d = ht + this._d | 0, this._e = wt + this._e | 0;
  }, ie.prototype._hash = function() {
    var le = Y.allocUnsafe(20);
    return le.writeInt32BE(this._a | 0, 0), le.writeInt32BE(this._b | 0, 4), le.writeInt32BE(this._c | 0, 8), le.writeInt32BE(this._d | 0, 12), le.writeInt32BE(this._e | 0, 16), le;
  }, sha1$1 = ie, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], oe = new Array(64);
  function ie() {
    this.init(), this._w = oe, z.call(this, 64, 56);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function ae(Ce, Pe, Xe) {
    return Xe ^ Ce & (Pe ^ Xe);
  }
  function se(Ce, Pe, Xe) {
    return Ce & Pe | Xe & (Ce | Pe);
  }
  function ve(Ce) {
    return (Ce >>> 2 | Ce << 30) ^ (Ce >>> 13 | Ce << 19) ^ (Ce >>> 22 | Ce << 10);
  }
  function ge(Ce) {
    return (Ce >>> 6 | Ce << 26) ^ (Ce >>> 11 | Ce << 21) ^ (Ce >>> 25 | Ce << 7);
  }
  function le(Ce) {
    return (Ce >>> 7 | Ce << 25) ^ (Ce >>> 18 | Ce << 14) ^ Ce >>> 3;
  }
  function Ee(Ce) {
    return (Ce >>> 17 | Ce << 15) ^ (Ce >>> 19 | Ce << 13) ^ Ce >>> 10;
  }
  return ie.prototype._update = function(Ce) {
    for (var Pe = this._w, Xe = this._a | 0, ht = this._b | 0, wt = this._c | 0, Pt = this._d | 0, vt = this._e | 0, Bt = this._f | 0, Ct = this._g | 0, Wt = this._h | 0, Kt = 0; Kt < 16; ++Kt) Pe[Kt] = Ce.readInt32BE(Kt * 4);
    for (; Kt < 64; ++Kt) Pe[Kt] = Ee(Pe[Kt - 2]) + Pe[Kt - 7] + le(Pe[Kt - 15]) + Pe[Kt - 16] | 0;
    for (var Yt = 0; Yt < 64; ++Yt) {
      var Ut = Wt + ge(vt) + ae(vt, Bt, Ct) + ne[Yt] + Pe[Yt] | 0, qt = ve(Xe) + se(Xe, ht, wt) | 0;
      Wt = Ct, Ct = Bt, Bt = vt, vt = Pt + Ut | 0, Pt = wt, wt = ht, ht = Xe, Xe = Ut + qt | 0;
    }
    this._a = Xe + this._a | 0, this._b = ht + this._b | 0, this._c = wt + this._c | 0, this._d = Pt + this._d | 0, this._e = vt + this._e | 0, this._f = Bt + this._f | 0, this._g = Ct + this._g | 0, this._h = Wt + this._h | 0;
  }, ie.prototype._hash = function() {
    var Ce = Y.allocUnsafe(32);
    return Ce.writeInt32BE(this._a, 0), Ce.writeInt32BE(this._b, 4), Ce.writeInt32BE(this._c, 8), Ce.writeInt32BE(this._d, 12), Ce.writeInt32BE(this._e, 16), Ce.writeInt32BE(this._f, 20), Ce.writeInt32BE(this._g, 24), Ce.writeInt32BE(this._h, 28), Ce;
  }, sha256$3 = ie, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var B = requireInherits_browser(), z = requireSha256(), Y = requireHash$1(), ne = safeBufferExports.Buffer, oe = new Array(64);
  function ie() {
    this.init(), this._w = oe, Y.call(this, 64, 56);
  }
  return B(ie, z), ie.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, ie.prototype._hash = function() {
    var ae = ne.allocUnsafe(28);
    return ae.writeInt32BE(this._a, 0), ae.writeInt32BE(this._b, 4), ae.writeInt32BE(this._c, 8), ae.writeInt32BE(this._d, 12), ae.writeInt32BE(this._e, 16), ae.writeInt32BE(this._f, 20), ae.writeInt32BE(this._g, 24), ae;
  }, sha224$1 = ie, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ne = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], oe = new Array(160);
  function ie() {
    this.init(), this._w = oe, z.call(this, 128, 112);
  }
  B(ie, z), ie.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function ae(ht, wt, Pt) {
    return Pt ^ ht & (wt ^ Pt);
  }
  function se(ht, wt, Pt) {
    return ht & wt | Pt & (ht | wt);
  }
  function ve(ht, wt) {
    return (ht >>> 28 | wt << 4) ^ (wt >>> 2 | ht << 30) ^ (wt >>> 7 | ht << 25);
  }
  function ge(ht, wt) {
    return (ht >>> 14 | wt << 18) ^ (ht >>> 18 | wt << 14) ^ (wt >>> 9 | ht << 23);
  }
  function le(ht, wt) {
    return (ht >>> 1 | wt << 31) ^ (ht >>> 8 | wt << 24) ^ ht >>> 7;
  }
  function Ee(ht, wt) {
    return (ht >>> 1 | wt << 31) ^ (ht >>> 8 | wt << 24) ^ (ht >>> 7 | wt << 25);
  }
  function Ce(ht, wt) {
    return (ht >>> 19 | wt << 13) ^ (wt >>> 29 | ht << 3) ^ ht >>> 6;
  }
  function Pe(ht, wt) {
    return (ht >>> 19 | wt << 13) ^ (wt >>> 29 | ht << 3) ^ (ht >>> 6 | wt << 26);
  }
  function Xe(ht, wt) {
    return ht >>> 0 < wt >>> 0 ? 1 : 0;
  }
  return ie.prototype._update = function(ht) {
    for (var wt = this._w, Pt = this._ah | 0, vt = this._bh | 0, Bt = this._ch | 0, Ct = this._dh | 0, Wt = this._eh | 0, Kt = this._fh | 0, Yt = this._gh | 0, Ut = this._hh | 0, qt = this._al | 0, zt = this._bl | 0, Ft = this._cl | 0, Ve = this._dl | 0, Je = this._el | 0, Ke = this._fl | 0, Qe = this._gl | 0, bt = this._hl | 0, _t = 0; _t < 32; _t += 2)
      wt[_t] = ht.readInt32BE(_t * 4), wt[_t + 1] = ht.readInt32BE(_t * 4 + 4);
    for (; _t < 160; _t += 2) {
      var $t = wt[_t - 30], kt = wt[_t - 15 * 2 + 1], xt = le($t, kt), Nt = Ee(kt, $t);
      $t = wt[_t - 2 * 2], kt = wt[_t - 2 * 2 + 1];
      var Rt = Ce($t, kt), Ht = Pe(kt, $t), ar = wt[_t - 7 * 2], lr = wt[_t - 7 * 2 + 1], nr = wt[_t - 16 * 2], Vt = wt[_t - 16 * 2 + 1], Xt = Nt + lr | 0, sr = xt + ar + Xe(Xt, Nt) | 0;
      Xt = Xt + Ht | 0, sr = sr + Rt + Xe(Xt, Ht) | 0, Xt = Xt + Vt | 0, sr = sr + nr + Xe(Xt, Vt) | 0, wt[_t] = sr, wt[_t + 1] = Xt;
    }
    for (var dr = 0; dr < 160; dr += 2) {
      sr = wt[dr], Xt = wt[dr + 1];
      var er = se(Pt, vt, Bt), Zt = se(qt, zt, Ft), pr = ve(Pt, qt), _r = ve(qt, Pt), Ar = ge(Wt, Je), Sr = ge(Je, Wt), Br = ne[dr], Ir = ne[dr + 1], wr = ae(Wt, Kt, Yt), Gr = ae(Je, Ke, Qe), Pr = bt + Sr | 0, Mr = Ut + Ar + Xe(Pr, bt) | 0;
      Pr = Pr + Gr | 0, Mr = Mr + wr + Xe(Pr, Gr) | 0, Pr = Pr + Ir | 0, Mr = Mr + Br + Xe(Pr, Ir) | 0, Pr = Pr + Xt | 0, Mr = Mr + sr + Xe(Pr, Xt) | 0;
      var Cr = _r + Zt | 0, Tr = pr + er + Xe(Cr, _r) | 0;
      Ut = Yt, bt = Qe, Yt = Kt, Qe = Ke, Kt = Wt, Ke = Je, Je = Ve + Pr | 0, Wt = Ct + Mr + Xe(Je, Ve) | 0, Ct = Bt, Ve = Ft, Bt = vt, Ft = zt, vt = Pt, zt = qt, qt = Pr + Cr | 0, Pt = Mr + Tr + Xe(qt, Pr) | 0;
    }
    this._al = this._al + qt | 0, this._bl = this._bl + zt | 0, this._cl = this._cl + Ft | 0, this._dl = this._dl + Ve | 0, this._el = this._el + Je | 0, this._fl = this._fl + Ke | 0, this._gl = this._gl + Qe | 0, this._hl = this._hl + bt | 0, this._ah = this._ah + Pt + Xe(this._al, qt) | 0, this._bh = this._bh + vt + Xe(this._bl, zt) | 0, this._ch = this._ch + Bt + Xe(this._cl, Ft) | 0, this._dh = this._dh + Ct + Xe(this._dl, Ve) | 0, this._eh = this._eh + Wt + Xe(this._el, Je) | 0, this._fh = this._fh + Kt + Xe(this._fl, Ke) | 0, this._gh = this._gh + Yt + Xe(this._gl, Qe) | 0, this._hh = this._hh + Ut + Xe(this._hl, bt) | 0;
  }, ie.prototype._hash = function() {
    var ht = Y.allocUnsafe(64);
    function wt(Pt, vt, Bt) {
      ht.writeInt32BE(Pt, Bt), ht.writeInt32BE(vt, Bt + 4);
    }
    return wt(this._ah, this._al, 0), wt(this._bh, this._bl, 8), wt(this._ch, this._cl, 16), wt(this._dh, this._dl, 24), wt(this._eh, this._el, 32), wt(this._fh, this._fl, 40), wt(this._gh, this._gl, 48), wt(this._hh, this._hl, 56), ht;
  }, sha512$1 = ie, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var B = requireInherits_browser(), z = requireSha512(), Y = requireHash$1(), ne = safeBufferExports.Buffer, oe = new Array(160);
  function ie() {
    this.init(), this._w = oe, Y.call(this, 128, 112);
  }
  return B(ie, z), ie.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, ie.prototype._hash = function() {
    var ae = ne.allocUnsafe(48);
    function se(ve, ge, le) {
      ae.writeInt32BE(ve, le), ae.writeInt32BE(ge, le + 4);
    }
    return se(this._ah, this._al, 0), se(this._bh, this._bl, 8), se(this._ch, this._cl, 16), se(this._dh, this._dl, 24), se(this._eh, this._el, 32), se(this._fh, this._fl, 40), ae;
  }, sha384$1 = ie, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var B = sha_js.exports = function(Y) {
    Y = Y.toLowerCase();
    var ne = B[Y];
    if (!ne) throw new Error(Y + " is not supported (we accept pull requests)");
    return new ne();
  };
  return B.sha = requireSha$1(), B.sha1 = requireSha1(), B.sha224 = requireSha224(), B.sha256 = requireSha256(), B.sha384 = requireSha384(), B.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = Y;
  var B = requireEvents().EventEmitter, z = requireInherits_browser();
  z(Y, B), Y.Readable = require_stream_readable$1(), Y.Writable = require_stream_writable$1(), Y.Duplex = require_stream_duplex$1(), Y.Transform = require_stream_transform$1(), Y.PassThrough = require_stream_passthrough$1(), Y.finished = requireEndOfStream(), Y.pipeline = requirePipeline(), Y.Stream = Y;
  function Y() {
    B.call(this);
  }
  return Y.prototype.pipe = function(ne, oe) {
    var ie = this;
    function ae(Pe) {
      ne.writable && ne.write(Pe) === !1 && ie.pause && ie.pause();
    }
    ie.on("data", ae);
    function se() {
      ie.readable && ie.resume && ie.resume();
    }
    ne.on("drain", se), !ne._isStdio && (!oe || oe.end !== !1) && (ie.on("end", ge), ie.on("close", le));
    var ve = !1;
    function ge() {
      ve || (ve = !0, ne.end());
    }
    function le() {
      ve || (ve = !0, typeof ne.destroy == "function" && ne.destroy());
    }
    function Ee(Pe) {
      if (Ce(), B.listenerCount(this, "error") === 0)
        throw Pe;
    }
    ie.on("error", Ee), ne.on("error", Ee);
    function Ce() {
      ie.removeListener("data", ae), ne.removeListener("drain", se), ie.removeListener("end", ge), ie.removeListener("close", le), ie.removeListener("error", Ee), ne.removeListener("error", Ee), ie.removeListener("end", Ce), ie.removeListener("close", Ce), ne.removeListener("close", Ce);
    }
    return ie.on("end", Ce), ie.on("close", Ce), ne.on("close", Ce), ne.emit("pipe", ie), ne;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var B = safeBufferExports.Buffer, z = requireStreamBrowserify().Transform, Y = requireString_decoder().StringDecoder, ne = requireInherits_browser();
  function oe(ve) {
    z.call(this), this.hashMode = typeof ve == "string", this.hashMode ? this[ve] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  ne(oe, z);
  var ie = typeof Uint8Array < "u", ae = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (B.prototype instanceof Uint8Array || B.TYPED_ARRAY_SUPPORT);
  function se(ve, ge) {
    if (ve instanceof B)
      return ve;
    if (typeof ve == "string")
      return B.from(ve, ge);
    if (ae && ArrayBuffer.isView(ve)) {
      if (ve.byteLength === 0)
        return B.alloc(0);
      var le = B.from(ve.buffer, ve.byteOffset, ve.byteLength);
      if (le.byteLength === ve.byteLength)
        return le;
    }
    if (ie && ve instanceof Uint8Array || B.isBuffer(ve) && ve.constructor && typeof ve.constructor.isBuffer == "function" && ve.constructor.isBuffer(ve))
      return B.from(ve);
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  return oe.prototype.update = function(ve, ge, le) {
    var Ee = se(ve, ge), Ce = this._update(Ee);
    return this.hashMode ? this : (le && (Ce = this._toString(Ce, le)), Ce);
  }, oe.prototype.setAutoPadding = function() {
  }, oe.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, oe.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, oe.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, oe.prototype._transform = function(ve, ge, le) {
    var Ee;
    try {
      this.hashMode ? this._update(ve) : this.push(this._update(ve));
    } catch (Ce) {
      Ee = Ce;
    } finally {
      le(Ee);
    }
  }, oe.prototype._flush = function(ve) {
    var ge;
    try {
      this.push(this.__final());
    } catch (le) {
      ge = le;
    }
    ve(ge);
  }, oe.prototype._finalOrDigest = function(ve) {
    var ge = this.__final() || B.alloc(0);
    return ve && (ge = this._toString(ge, ve, !0)), ge;
  }, oe.prototype._toString = function(ve, ge, le) {
    if (this._decoder || (this._decoder = new Y(ge), this._encoding = ge), this._encoding !== ge)
      throw new Error("cant switch encodings");
    var Ee = this._decoder.write(ve);
    return le && (Ee += this._decoder.end()), Ee;
  }, cipherBase = oe, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var B = requireInherits_browser(), z = requireMd5_js(), Y = requireRipemd160(), ne = requireSha_js(), oe = requireCipherBase();
  function ie(ae) {
    oe.call(this, "digest"), this._hash = ae;
  }
  return B(ie, oe), ie.prototype._update = function(ae) {
    this._hash.update(ae);
  }, ie.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(se) {
    return se = se.toLowerCase(), se === "md5" ? new z() : se === "rmd160" || se === "ripemd160" ? new Y() : new ie(ne(se));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var B = requireInherits_browser(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ne = z.alloc(128), oe = 64;
  function ie(ae, se) {
    Y.call(this, "digest"), typeof se == "string" && (se = z.from(se)), this._alg = ae, this._key = se, se.length > oe ? se = ae(se) : se.length < oe && (se = z.concat([se, ne], oe));
    for (var ve = this._ipad = z.allocUnsafe(oe), ge = this._opad = z.allocUnsafe(oe), le = 0; le < oe; le++)
      ve[le] = se[le] ^ 54, ge[le] = se[le] ^ 92;
    this._hash = [ve];
  }
  return B(ie, Y), ie.prototype._update = function(ae) {
    this._hash.push(ae);
  }, ie.prototype._final = function() {
    var ae = this._alg(z.concat(this._hash));
    return this._alg(z.concat([this._opad, ae]));
  }, legacy = ie, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var B = requireMd5_js();
  return md5 = function(z) {
    return new B().update(z).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var B = requireInherits_browser(), z = requireLegacy(), Y = requireCipherBase(), ne = safeBufferExports.Buffer, oe = requireMd5(), ie = requireRipemd160(), ae = requireSha_js(), se = ne.alloc(128);
  function ve(ge, le) {
    Y.call(this, "digest"), typeof le == "string" && (le = ne.from(le));
    var Ee = ge === "sha512" || ge === "sha384" ? 128 : 64;
    if (this._alg = ge, this._key = le, le.length > Ee) {
      var Ce = ge === "rmd160" ? new ie() : ae(ge);
      le = Ce.update(le).digest();
    } else le.length < Ee && (le = ne.concat([le, se], Ee));
    for (var Pe = this._ipad = ne.allocUnsafe(Ee), Xe = this._opad = ne.allocUnsafe(Ee), ht = 0; ht < Ee; ht++)
      Pe[ht] = le[ht] ^ 54, Xe[ht] = le[ht] ^ 92;
    this._hash = ge === "rmd160" ? new ie() : ae(ge), this._hash.update(Pe);
  }
  return B(ve, Y), ve.prototype._update = function(ge) {
    this._hash.update(ge);
  }, ve.prototype._final = function() {
    var ge = this._hash.digest(), le = this._alg === "rmd160" ? new ie() : ae(this._alg);
    return le.update(this._opad).update(ge).digest();
  }, browser$8 = function(le, Ee) {
    return le = le.toLowerCase(), le === "rmd160" || le === "ripemd160" ? new ve("rmd160", Ee) : le === "md5" ? new z(oe, Ee) : new ve(le, Ee);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var B = Math.pow(2, 30) - 1;
  return precondition = function(z, Y) {
    if (typeof z != "number")
      throw new TypeError("Iterations not a number");
    if (z < 0)
      throw new TypeError("Bad iterations");
    if (typeof Y != "number")
      throw new TypeError("Key length not a number");
    if (Y < 0 || Y > B || Y !== Y)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var B;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    B = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var z = parseInt(process$1.version.split(".")[0].slice(1), 10);
    B = z >= 6 ? "utf-8" : "binary";
  } else
    B = "utf-8";
  return defaultEncoding_1 = B, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var B = safeBufferExports.Buffer;
  return toBuffer$1 = function(z, Y, ne) {
    if (B.isBuffer(z))
      return z;
    if (typeof z == "string")
      return B.from(z, Y);
    if (ArrayBuffer.isView(z))
      return B.from(z.buffer);
    throw new TypeError(ne + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var B = requireMd5(), z = requireRipemd160(), Y = requireSha_js(), ne = safeBufferExports.Buffer, oe = requirePrecondition(), ie = requireDefaultEncoding(), ae = requireToBuffer(), se = ne.alloc(128), ve = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function ge(Ce, Pe, Xe) {
    var ht = le(Ce), wt = Ce === "sha512" || Ce === "sha384" ? 128 : 64;
    Pe.length > wt ? Pe = ht(Pe) : Pe.length < wt && (Pe = ne.concat([Pe, se], wt));
    for (var Pt = ne.allocUnsafe(wt + ve[Ce]), vt = ne.allocUnsafe(wt + ve[Ce]), Bt = 0; Bt < wt; Bt++)
      Pt[Bt] = Pe[Bt] ^ 54, vt[Bt] = Pe[Bt] ^ 92;
    var Ct = ne.allocUnsafe(wt + Xe + 4);
    Pt.copy(Ct, 0, 0, wt), this.ipad1 = Ct, this.ipad2 = Pt, this.opad = vt, this.alg = Ce, this.blocksize = wt, this.hash = ht, this.size = ve[Ce];
  }
  ge.prototype.run = function(Ce, Pe) {
    Ce.copy(Pe, this.blocksize);
    var Xe = this.hash(Pe);
    return Xe.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function le(Ce) {
    function Pe(ht) {
      return Y(Ce).update(ht).digest();
    }
    function Xe(ht) {
      return new z().update(ht).digest();
    }
    return Ce === "rmd160" || Ce === "ripemd160" ? Xe : Ce === "md5" ? B : Pe;
  }
  function Ee(Ce, Pe, Xe, ht, wt) {
    oe(Xe, ht), Ce = ae(Ce, ie, "Password"), Pe = ae(Pe, ie, "Salt"), wt = wt || "sha1";
    var Pt = new ge(wt, Ce, Pe.length), vt = ne.allocUnsafe(ht), Bt = ne.allocUnsafe(Pe.length + 4);
    Pe.copy(Bt, 0, 0, Pe.length);
    for (var Ct = 0, Wt = ve[wt], Kt = Math.ceil(ht / Wt), Yt = 1; Yt <= Kt; Yt++) {
      Bt.writeUInt32BE(Yt, Pe.length);
      for (var Ut = Pt.run(Bt, Pt.ipad1), qt = Ut, zt = 1; zt < Xe; zt++) {
        qt = Pt.run(qt, Pt.ipad2);
        for (var Ft = 0; Ft < Wt; Ft++) Ut[Ft] ^= qt[Ft];
      }
      Ut.copy(vt, Ct), Ct += Wt;
    }
    return vt;
  }
  return syncBrowser = Ee, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var B = safeBufferExports.Buffer, z = requirePrecondition(), Y = requireDefaultEncoding(), ne = requireSyncBrowser(), oe = requireToBuffer(), ie, ae = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, se = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ve = [];
  function ge(Xe) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !ae || !ae.importKey || !ae.deriveBits)
      return Promise.resolve(!1);
    if (ve[Xe] !== void 0)
      return ve[Xe];
    ie = ie || B.alloc(8);
    var ht = Ce(ie, ie, 10, 128, Xe).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ve[Xe] = ht, ht;
  }
  var le;
  function Ee() {
    return le || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? le = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? le = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? le = commonjsGlobal.setImmediate : le = commonjsGlobal.setTimeout, le);
  }
  function Ce(Xe, ht, wt, Pt, vt) {
    return ae.importKey(
      "raw",
      Xe,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(Bt) {
      return ae.deriveBits({
        name: "PBKDF2",
        salt: ht,
        iterations: wt,
        hash: {
          name: vt
        }
      }, Bt, Pt << 3);
    }).then(function(Bt) {
      return B.from(Bt);
    });
  }
  function Pe(Xe, ht) {
    Xe.then(function(wt) {
      Ee()(function() {
        ht(null, wt);
      });
    }, function(wt) {
      Ee()(function() {
        ht(wt);
      });
    });
  }
  return async = function(Xe, ht, wt, Pt, vt, Bt) {
    typeof vt == "function" && (Bt = vt, vt = void 0), vt = vt || "sha1";
    var Ct = se[vt.toLowerCase()];
    if (!Ct || typeof commonjsGlobal.Promise != "function") {
      Ee()(function() {
        var Wt;
        try {
          Wt = ne(Xe, ht, wt, Pt, vt);
        } catch (Kt) {
          return Bt(Kt);
        }
        Bt(null, Wt);
      });
      return;
    }
    if (z(wt, Pt), Xe = oe(Xe, Y, "Password"), ht = oe(ht, Y, "Salt"), typeof Bt != "function") throw new Error("No callback provided to pbkdf2");
    Pe(ge(Ct).then(function(Wt) {
      return Wt ? Ce(Xe, ht, wt, Pt, Ct) : ne(Xe, ht, wt, Pt, vt);
    }), Bt);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(oe, ie) {
    var ae = oe[0 + ie] << 24 | oe[1 + ie] << 16 | oe[2 + ie] << 8 | oe[3 + ie];
    return ae >>> 0;
  }, utils$4.writeUInt32BE = function(oe, ie, ae) {
    oe[0 + ae] = ie >>> 24, oe[1 + ae] = ie >>> 16 & 255, oe[2 + ae] = ie >>> 8 & 255, oe[3 + ae] = ie & 255;
  }, utils$4.ip = function(oe, ie, ae, se) {
    for (var ve = 0, ge = 0, le = 6; le >= 0; le -= 2) {
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= ie >>> Ee + le & 1;
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= oe >>> Ee + le & 1;
    }
    for (var le = 6; le >= 0; le -= 2) {
      for (var Ee = 1; Ee <= 25; Ee += 8)
        ge <<= 1, ge |= ie >>> Ee + le & 1;
      for (var Ee = 1; Ee <= 25; Ee += 8)
        ge <<= 1, ge |= oe >>> Ee + le & 1;
    }
    ae[se + 0] = ve >>> 0, ae[se + 1] = ge >>> 0;
  }, utils$4.rip = function(oe, ie, ae, se) {
    for (var ve = 0, ge = 0, le = 0; le < 4; le++)
      for (var Ee = 24; Ee >= 0; Ee -= 8)
        ve <<= 1, ve |= ie >>> Ee + le & 1, ve <<= 1, ve |= oe >>> Ee + le & 1;
    for (var le = 4; le < 8; le++)
      for (var Ee = 24; Ee >= 0; Ee -= 8)
        ge <<= 1, ge |= ie >>> Ee + le & 1, ge <<= 1, ge |= oe >>> Ee + le & 1;
    ae[se + 0] = ve >>> 0, ae[se + 1] = ge >>> 0;
  }, utils$4.pc1 = function(oe, ie, ae, se) {
    for (var ve = 0, ge = 0, le = 7; le >= 5; le--) {
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= ie >> Ee + le & 1;
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ve <<= 1, ve |= oe >> Ee + le & 1;
    }
    for (var Ee = 0; Ee <= 24; Ee += 8)
      ve <<= 1, ve |= ie >> Ee + le & 1;
    for (var le = 1; le <= 3; le++) {
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ge <<= 1, ge |= ie >> Ee + le & 1;
      for (var Ee = 0; Ee <= 24; Ee += 8)
        ge <<= 1, ge |= oe >> Ee + le & 1;
    }
    for (var Ee = 0; Ee <= 24; Ee += 8)
      ge <<= 1, ge |= oe >> Ee + le & 1;
    ae[se + 0] = ve >>> 0, ae[se + 1] = ge >>> 0;
  }, utils$4.r28shl = function(oe, ie) {
    return oe << ie & 268435455 | oe >>> 28 - ie;
  };
  var B = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(oe, ie, ae, se) {
    for (var ve = 0, ge = 0, le = B.length >>> 1, Ee = 0; Ee < le; Ee++)
      ve <<= 1, ve |= oe >>> B[Ee] & 1;
    for (var Ee = le; Ee < B.length; Ee++)
      ge <<= 1, ge |= ie >>> B[Ee] & 1;
    ae[se + 0] = ve >>> 0, ae[se + 1] = ge >>> 0;
  }, utils$4.expand = function(oe, ie, ae) {
    var se = 0, ve = 0;
    se = (oe & 1) << 5 | oe >>> 27;
    for (var ge = 23; ge >= 15; ge -= 4)
      se <<= 6, se |= oe >>> ge & 63;
    for (var ge = 11; ge >= 3; ge -= 4)
      ve |= oe >>> ge & 63, ve <<= 6;
    ve |= (oe & 31) << 1 | oe >>> 31, ie[ae + 0] = se >>> 0, ie[ae + 1] = ve >>> 0;
  };
  var z = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(oe, ie) {
    for (var ae = 0, se = 0; se < 4; se++) {
      var ve = oe >>> 18 - se * 6 & 63, ge = z[se * 64 + ve];
      ae <<= 4, ae |= ge;
    }
    for (var se = 0; se < 4; se++) {
      var ve = ie >>> 18 - se * 6 & 63, ge = z[4 * 64 + se * 64 + ve];
      ae <<= 4, ae |= ge;
    }
    return ae >>> 0;
  };
  var Y = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(oe) {
    for (var ie = 0, ae = 0; ae < Y.length; ae++)
      ie <<= 1, ie |= oe >>> Y[ae] & 1;
    return ie >>> 0;
  }, utils$4.padSplit = function(oe, ie, ae) {
    for (var se = oe.toString(2); se.length < ie; )
      se = "0" + se;
    for (var ve = [], ge = 0; ge < ie; ge += ae)
      ve.push(se.slice(ge, ge + ae));
    return ve.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = B;
  function B(z, Y) {
    if (!z)
      throw new Error(Y || "Assertion failed");
  }
  return B.equal = function(Y, ne, oe) {
    if (Y != ne)
      throw new Error(oe || "Assertion failed: " + Y + " != " + ne);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var B = requireMinimalisticAssert();
  function z(Y) {
    this.options = Y, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = Y.padding !== !1;
  }
  return cipher = z, z.prototype._init = function() {
  }, z.prototype.update = function(ne) {
    return ne.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(ne) : this._updateEncrypt(ne);
  }, z.prototype._buffer = function(ne, oe) {
    for (var ie = Math.min(this.buffer.length - this.bufferOff, ne.length - oe), ae = 0; ae < ie; ae++)
      this.buffer[this.bufferOff + ae] = ne[oe + ae];
    return this.bufferOff += ie, ie;
  }, z.prototype._flushBuffer = function(ne, oe) {
    return this._update(this.buffer, 0, ne, oe), this.bufferOff = 0, this.blockSize;
  }, z.prototype._updateEncrypt = function(ne) {
    var oe = 0, ie = 0, ae = (this.bufferOff + ne.length) / this.blockSize | 0, se = new Array(ae * this.blockSize);
    this.bufferOff !== 0 && (oe += this._buffer(ne, oe), this.bufferOff === this.buffer.length && (ie += this._flushBuffer(se, ie)));
    for (var ve = ne.length - (ne.length - oe) % this.blockSize; oe < ve; oe += this.blockSize)
      this._update(ne, oe, se, ie), ie += this.blockSize;
    for (; oe < ne.length; oe++, this.bufferOff++)
      this.buffer[this.bufferOff] = ne[oe];
    return se;
  }, z.prototype._updateDecrypt = function(ne) {
    for (var oe = 0, ie = 0, ae = Math.ceil((this.bufferOff + ne.length) / this.blockSize) - 1, se = new Array(ae * this.blockSize); ae > 0; ae--)
      oe += this._buffer(ne, oe), ie += this._flushBuffer(se, ie);
    return oe += this._buffer(ne, oe), se;
  }, z.prototype.final = function(ne) {
    var oe;
    ne && (oe = this.update(ne));
    var ie;
    return this.type === "encrypt" ? ie = this._finalEncrypt() : ie = this._finalDecrypt(), oe ? oe.concat(ie) : ie;
  }, z.prototype._pad = function(ne, oe) {
    if (oe === 0)
      return !1;
    for (; oe < ne.length; )
      ne[oe++] = 0;
    return !0;
  }, z.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var ne = new Array(this.blockSize);
    return this._update(this.buffer, 0, ne, 0), ne;
  }, z.prototype._unpad = function(ne) {
    return ne;
  }, z.prototype._finalDecrypt = function() {
    B.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var ne = new Array(this.blockSize);
    return this._flushBuffer(ne, 0), this._unpad(ne);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = requireUtils$3(), ne = requireCipher();
  function oe() {
    this.tmp = new Array(2), this.keys = null;
  }
  function ie(se) {
    ne.call(this, se);
    var ve = new oe();
    this._desState = ve, this.deriveKeys(ve, se.key);
  }
  z(ie, ne), des = ie, ie.create = function(ve) {
    return new ie(ve);
  };
  var ae = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return ie.prototype.deriveKeys = function(ve, ge) {
    ve.keys = new Array(16 * 2), B.equal(ge.length, this.blockSize, "Invalid key length");
    var le = Y.readUInt32BE(ge, 0), Ee = Y.readUInt32BE(ge, 4);
    Y.pc1(le, Ee, ve.tmp, 0), le = ve.tmp[0], Ee = ve.tmp[1];
    for (var Ce = 0; Ce < ve.keys.length; Ce += 2) {
      var Pe = ae[Ce >>> 1];
      le = Y.r28shl(le, Pe), Ee = Y.r28shl(Ee, Pe), Y.pc2(le, Ee, ve.keys, Ce);
    }
  }, ie.prototype._update = function(ve, ge, le, Ee) {
    var Ce = this._desState, Pe = Y.readUInt32BE(ve, ge), Xe = Y.readUInt32BE(ve, ge + 4);
    Y.ip(Pe, Xe, Ce.tmp, 0), Pe = Ce.tmp[0], Xe = Ce.tmp[1], this.type === "encrypt" ? this._encrypt(Ce, Pe, Xe, Ce.tmp, 0) : this._decrypt(Ce, Pe, Xe, Ce.tmp, 0), Pe = Ce.tmp[0], Xe = Ce.tmp[1], Y.writeUInt32BE(le, Pe, Ee), Y.writeUInt32BE(le, Xe, Ee + 4);
  }, ie.prototype._pad = function(ve, ge) {
    if (this.padding === !1)
      return !1;
    for (var le = ve.length - ge, Ee = ge; Ee < ve.length; Ee++)
      ve[Ee] = le;
    return !0;
  }, ie.prototype._unpad = function(ve) {
    if (this.padding === !1)
      return ve;
    for (var ge = ve[ve.length - 1], le = ve.length - ge; le < ve.length; le++)
      B.equal(ve[le], ge);
    return ve.slice(0, ve.length - ge);
  }, ie.prototype._encrypt = function(ve, ge, le, Ee, Ce) {
    for (var Pe = ge, Xe = le, ht = 0; ht < ve.keys.length; ht += 2) {
      var wt = ve.keys[ht], Pt = ve.keys[ht + 1];
      Y.expand(Xe, ve.tmp, 0), wt ^= ve.tmp[0], Pt ^= ve.tmp[1];
      var vt = Y.substitute(wt, Pt), Bt = Y.permute(vt), Ct = Xe;
      Xe = (Pe ^ Bt) >>> 0, Pe = Ct;
    }
    Y.rip(Xe, Pe, Ee, Ce);
  }, ie.prototype._decrypt = function(ve, ge, le, Ee, Ce) {
    for (var Pe = le, Xe = ge, ht = ve.keys.length - 2; ht >= 0; ht -= 2) {
      var wt = ve.keys[ht], Pt = ve.keys[ht + 1];
      Y.expand(Pe, ve.tmp, 0), wt ^= ve.tmp[0], Pt ^= ve.tmp[1];
      var vt = Y.substitute(wt, Pt), Bt = Y.permute(vt), Ct = Pe;
      Pe = (Xe ^ Bt) >>> 0, Xe = Ct;
    }
    Y.rip(Pe, Xe, Ee, Ce);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = {};
  function ne(ie) {
    B.equal(ie.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var ae = 0; ae < this.iv.length; ae++)
      this.iv[ae] = ie[ae];
  }
  function oe(ie) {
    function ae(le) {
      ie.call(this, le), this._cbcInit();
    }
    z(ae, ie);
    for (var se = Object.keys(Y), ve = 0; ve < se.length; ve++) {
      var ge = se[ve];
      ae.prototype[ge] = Y[ge];
    }
    return ae.create = function(Ee) {
      return new ae(Ee);
    }, ae;
  }
  return cbc$1.instantiate = oe, Y._cbcInit = function() {
    var ae = new ne(this.options.iv);
    this._cbcState = ae;
  }, Y._update = function(ae, se, ve, ge) {
    var le = this._cbcState, Ee = this.constructor.super_.prototype, Ce = le.iv;
    if (this.type === "encrypt") {
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        Ce[Pe] ^= ae[se + Pe];
      Ee._update.call(this, Ce, 0, ve, ge);
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        Ce[Pe] = ve[ge + Pe];
    } else {
      Ee._update.call(this, ae, se, ve, ge);
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        ve[ge + Pe] ^= Ce[Pe];
      for (var Pe = 0; Pe < this.blockSize; Pe++)
        Ce[Pe] = ae[se + Pe];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = requireCipher(), ne = requireDes$1();
  function oe(ae, se) {
    B.equal(se.length, 24, "Invalid key length");
    var ve = se.slice(0, 8), ge = se.slice(8, 16), le = se.slice(16, 24);
    ae === "encrypt" ? this.ciphers = [
      ne.create({ type: "encrypt", key: ve }),
      ne.create({ type: "decrypt", key: ge }),
      ne.create({ type: "encrypt", key: le })
    ] : this.ciphers = [
      ne.create({ type: "decrypt", key: le }),
      ne.create({ type: "encrypt", key: ge }),
      ne.create({ type: "decrypt", key: ve })
    ];
  }
  function ie(ae) {
    Y.call(this, ae);
    var se = new oe(this.type, this.options.key);
    this._edeState = se;
  }
  return z(ie, Y), ede = ie, ie.create = function(se) {
    return new ie(se);
  }, ie.prototype._update = function(se, ve, ge, le) {
    var Ee = this._edeState;
    Ee.ciphers[0]._update(se, ve, ge, le), Ee.ciphers[1]._update(ge, le, ge, le), Ee.ciphers[2]._update(ge, le, ge, le);
  }, ie.prototype._pad = ne.prototype._pad, ie.prototype._unpad = ne.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var B = requireCipherBase(), z = requireDes(), Y = requireInherits_browser(), ne = safeBufferExports.Buffer, oe = {
    "des-ede3-cbc": z.CBC.instantiate(z.EDE),
    "des-ede3": z.EDE,
    "des-ede-cbc": z.CBC.instantiate(z.EDE),
    "des-ede": z.EDE,
    "des-cbc": z.CBC.instantiate(z.DES),
    "des-ecb": z.DES
  };
  oe.des = oe["des-cbc"], oe.des3 = oe["des-ede3-cbc"], browserifyDes = ie, Y(ie, B);
  function ie(ae) {
    B.call(this);
    var se = ae.mode.toLowerCase(), ve = oe[se], ge;
    ae.decrypt ? ge = "decrypt" : ge = "encrypt";
    var le = ae.key;
    ne.isBuffer(le) || (le = ne.from(le)), (se === "des-ede" || se === "des-ede-cbc") && (le = ne.concat([le, le.slice(0, 8)]));
    var Ee = ae.iv;
    ne.isBuffer(Ee) || (Ee = ne.from(Ee)), this._des = ve.create({
      key: le,
      iv: Ee,
      type: ge
    });
  }
  return ie.prototype._update = function(ae) {
    return ne.from(this._des.update(ae));
  }, ie.prototype._final = function() {
    return ne.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(B, z) {
    return B._cipher.encryptBlock(z);
  }, ecb.decrypt = function(B, z) {
    return B._cipher.decryptBlock(z);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(z, Y) {
    for (var ne = Math.min(z.length, Y.length), oe = new Buffer$1(ne), ie = 0; ie < ne; ++ie)
      oe[ie] = z[ie] ^ Y[ie];
    return oe;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var B = requireBufferXor();
  return cbc.encrypt = function(z, Y) {
    var ne = B(Y, z._prev);
    return z._prev = z._cipher.encryptBlock(ne), z._prev;
  }, cbc.decrypt = function(z, Y) {
    var ne = z._prev;
    z._prev = Y;
    var oe = z._cipher.decryptBlock(Y);
    return B(oe, ne);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var B = safeBufferExports.Buffer, z = requireBufferXor();
  function Y(ne, oe, ie) {
    var ae = oe.length, se = z(oe, ne._cache);
    return ne._cache = ne._cache.slice(ae), ne._prev = B.concat([ne._prev, ie ? oe : se]), se;
  }
  return cfb.encrypt = function(ne, oe, ie) {
    for (var ae = B.allocUnsafe(0), se; oe.length; )
      if (ne._cache.length === 0 && (ne._cache = ne._cipher.encryptBlock(ne._prev), ne._prev = B.allocUnsafe(0)), ne._cache.length <= oe.length)
        se = ne._cache.length, ae = B.concat([ae, Y(ne, oe.slice(0, se), ie)]), oe = oe.slice(se);
      else {
        ae = B.concat([ae, Y(ne, oe, ie)]);
        break;
      }
    return ae;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var B = safeBufferExports.Buffer;
  function z(Y, ne, oe) {
    var ie = Y._cipher.encryptBlock(Y._prev), ae = ie[0] ^ ne;
    return Y._prev = B.concat([
      Y._prev.slice(1),
      B.from([oe ? ne : ae])
    ]), ae;
  }
  return cfb8.encrypt = function(Y, ne, oe) {
    for (var ie = ne.length, ae = B.allocUnsafe(ie), se = -1; ++se < ie; )
      ae[se] = z(Y, ne[se], oe);
    return ae;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var B = safeBufferExports.Buffer;
  function z(ne, oe, ie) {
    for (var ae, se = -1, ve = 8, ge = 0, le, Ee; ++se < ve; )
      ae = ne._cipher.encryptBlock(ne._prev), le = oe & 1 << 7 - se ? 128 : 0, Ee = ae[0] ^ le, ge += (Ee & 128) >> se % 8, ne._prev = Y(ne._prev, ie ? le : Ee);
    return ge;
  }
  function Y(ne, oe) {
    var ie = ne.length, ae = -1, se = B.allocUnsafe(ne.length);
    for (ne = B.concat([ne, B.from([oe])]); ++ae < ie; )
      se[ae] = ne[ae] << 1 | ne[ae + 1] >> 7;
    return se;
  }
  return cfb1.encrypt = function(ne, oe, ie) {
    for (var ae = oe.length, se = B.allocUnsafe(ae), ve = -1; ++ve < ae; )
      se[ve] = z(ne, oe[ve], ie);
    return se;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var B = requireBufferXor();
  function z(Y) {
    return Y._prev = Y._cipher.encryptBlock(Y._prev), Y._prev;
  }
  return ofb.encrypt = function(Y, ne) {
    for (; Y._cache.length < ne.length; )
      Y._cache = Buffer$1.concat([Y._cache, z(Y)]);
    var oe = Y._cache.slice(0, ne.length);
    return Y._cache = Y._cache.slice(ne.length), B(ne, oe);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function B(z) {
    for (var Y = z.length, ne; Y--; )
      if (ne = z.readUInt8(Y), ne === 255)
        z.writeUInt8(0, Y);
      else {
        ne++, z.writeUInt8(ne, Y);
        break;
      }
  }
  return incr32_1 = B, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var B = requireBufferXor(), z = safeBufferExports.Buffer, Y = requireIncr32();
  function ne(ie) {
    var ae = ie._cipher.encryptBlockRaw(ie._prev);
    return Y(ie._prev), ae;
  }
  var oe = 16;
  return ctr.encrypt = function(ie, ae) {
    var se = Math.ceil(ae.length / oe), ve = ie._cache.length;
    ie._cache = z.concat([
      ie._cache,
      z.allocUnsafe(se * oe)
    ]);
    for (var ge = 0; ge < se; ge++) {
      var le = ne(ie), Ee = ve + ge * oe;
      ie._cache.writeUInt32BE(le[0], Ee + 0), ie._cache.writeUInt32BE(le[1], Ee + 4), ie._cache.writeUInt32BE(le[2], Ee + 8), ie._cache.writeUInt32BE(le[3], Ee + 12);
    }
    var Ce = ie._cache.slice(0, ae.length);
    return ie._cache = ie._cache.slice(ae.length), B(ae, Ce);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var B = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, z = require$$2;
  for (var Y in z)
    z[Y].module = B[z[Y].mode];
  return modes_1 = z, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var B = safeBufferExports.Buffer;
  function z(se) {
    B.isBuffer(se) || (se = B.from(se));
    for (var ve = se.length / 4 | 0, ge = new Array(ve), le = 0; le < ve; le++)
      ge[le] = se.readUInt32BE(le * 4);
    return ge;
  }
  function Y(se) {
    for (var ve = 0; ve < se.length; se++)
      se[ve] = 0;
  }
  function ne(se, ve, ge, le, Ee) {
    for (var Ce = ge[0], Pe = ge[1], Xe = ge[2], ht = ge[3], wt = se[0] ^ ve[0], Pt = se[1] ^ ve[1], vt = se[2] ^ ve[2], Bt = se[3] ^ ve[3], Ct, Wt, Kt, Yt, Ut = 4, qt = 1; qt < Ee; qt++)
      Ct = Ce[wt >>> 24] ^ Pe[Pt >>> 16 & 255] ^ Xe[vt >>> 8 & 255] ^ ht[Bt & 255] ^ ve[Ut++], Wt = Ce[Pt >>> 24] ^ Pe[vt >>> 16 & 255] ^ Xe[Bt >>> 8 & 255] ^ ht[wt & 255] ^ ve[Ut++], Kt = Ce[vt >>> 24] ^ Pe[Bt >>> 16 & 255] ^ Xe[wt >>> 8 & 255] ^ ht[Pt & 255] ^ ve[Ut++], Yt = Ce[Bt >>> 24] ^ Pe[wt >>> 16 & 255] ^ Xe[Pt >>> 8 & 255] ^ ht[vt & 255] ^ ve[Ut++], wt = Ct, Pt = Wt, vt = Kt, Bt = Yt;
    return Ct = (le[wt >>> 24] << 24 | le[Pt >>> 16 & 255] << 16 | le[vt >>> 8 & 255] << 8 | le[Bt & 255]) ^ ve[Ut++], Wt = (le[Pt >>> 24] << 24 | le[vt >>> 16 & 255] << 16 | le[Bt >>> 8 & 255] << 8 | le[wt & 255]) ^ ve[Ut++], Kt = (le[vt >>> 24] << 24 | le[Bt >>> 16 & 255] << 16 | le[wt >>> 8 & 255] << 8 | le[Pt & 255]) ^ ve[Ut++], Yt = (le[Bt >>> 24] << 24 | le[wt >>> 16 & 255] << 16 | le[Pt >>> 8 & 255] << 8 | le[vt & 255]) ^ ve[Ut++], Ct = Ct >>> 0, Wt = Wt >>> 0, Kt = Kt >>> 0, Yt = Yt >>> 0, [Ct, Wt, Kt, Yt];
  }
  var oe = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], ie = function() {
    for (var se = new Array(256), ve = 0; ve < 256; ve++)
      ve < 128 ? se[ve] = ve << 1 : se[ve] = ve << 1 ^ 283;
    for (var ge = [], le = [], Ee = [[], [], [], []], Ce = [[], [], [], []], Pe = 0, Xe = 0, ht = 0; ht < 256; ++ht) {
      var wt = Xe ^ Xe << 1 ^ Xe << 2 ^ Xe << 3 ^ Xe << 4;
      wt = wt >>> 8 ^ wt & 255 ^ 99, ge[Pe] = wt, le[wt] = Pe;
      var Pt = se[Pe], vt = se[Pt], Bt = se[vt], Ct = se[wt] * 257 ^ wt * 16843008;
      Ee[0][Pe] = Ct << 24 | Ct >>> 8, Ee[1][Pe] = Ct << 16 | Ct >>> 16, Ee[2][Pe] = Ct << 8 | Ct >>> 24, Ee[3][Pe] = Ct, Ct = Bt * 16843009 ^ vt * 65537 ^ Pt * 257 ^ Pe * 16843008, Ce[0][wt] = Ct << 24 | Ct >>> 8, Ce[1][wt] = Ct << 16 | Ct >>> 16, Ce[2][wt] = Ct << 8 | Ct >>> 24, Ce[3][wt] = Ct, Pe === 0 ? Pe = Xe = 1 : (Pe = Pt ^ se[se[se[Bt ^ Pt]]], Xe ^= se[se[Xe]]);
    }
    return {
      SBOX: ge,
      INV_SBOX: le,
      SUB_MIX: Ee,
      INV_SUB_MIX: Ce
    };
  }();
  function ae(se) {
    this._key = z(se), this._reset();
  }
  return ae.blockSize = 4 * 4, ae.keySize = 256 / 8, ae.prototype.blockSize = ae.blockSize, ae.prototype.keySize = ae.keySize, ae.prototype._reset = function() {
    for (var se = this._key, ve = se.length, ge = ve + 6, le = (ge + 1) * 4, Ee = [], Ce = 0; Ce < ve; Ce++)
      Ee[Ce] = se[Ce];
    for (Ce = ve; Ce < le; Ce++) {
      var Pe = Ee[Ce - 1];
      Ce % ve === 0 ? (Pe = Pe << 8 | Pe >>> 24, Pe = ie.SBOX[Pe >>> 24] << 24 | ie.SBOX[Pe >>> 16 & 255] << 16 | ie.SBOX[Pe >>> 8 & 255] << 8 | ie.SBOX[Pe & 255], Pe ^= oe[Ce / ve | 0] << 24) : ve > 6 && Ce % ve === 4 && (Pe = ie.SBOX[Pe >>> 24] << 24 | ie.SBOX[Pe >>> 16 & 255] << 16 | ie.SBOX[Pe >>> 8 & 255] << 8 | ie.SBOX[Pe & 255]), Ee[Ce] = Ee[Ce - ve] ^ Pe;
    }
    for (var Xe = [], ht = 0; ht < le; ht++) {
      var wt = le - ht, Pt = Ee[wt - (ht % 4 ? 0 : 4)];
      ht < 4 || wt <= 4 ? Xe[ht] = Pt : Xe[ht] = ie.INV_SUB_MIX[0][ie.SBOX[Pt >>> 24]] ^ ie.INV_SUB_MIX[1][ie.SBOX[Pt >>> 16 & 255]] ^ ie.INV_SUB_MIX[2][ie.SBOX[Pt >>> 8 & 255]] ^ ie.INV_SUB_MIX[3][ie.SBOX[Pt & 255]];
    }
    this._nRounds = ge, this._keySchedule = Ee, this._invKeySchedule = Xe;
  }, ae.prototype.encryptBlockRaw = function(se) {
    return se = z(se), ne(se, this._keySchedule, ie.SUB_MIX, ie.SBOX, this._nRounds);
  }, ae.prototype.encryptBlock = function(se) {
    var ve = this.encryptBlockRaw(se), ge = B.allocUnsafe(16);
    return ge.writeUInt32BE(ve[0], 0), ge.writeUInt32BE(ve[1], 4), ge.writeUInt32BE(ve[2], 8), ge.writeUInt32BE(ve[3], 12), ge;
  }, ae.prototype.decryptBlock = function(se) {
    se = z(se);
    var ve = se[1];
    se[1] = se[3], se[3] = ve;
    var ge = ne(se, this._invKeySchedule, ie.INV_SUB_MIX, ie.INV_SBOX, this._nRounds), le = B.allocUnsafe(16);
    return le.writeUInt32BE(ge[0], 0), le.writeUInt32BE(ge[3], 4), le.writeUInt32BE(ge[2], 8), le.writeUInt32BE(ge[1], 12), le;
  }, ae.prototype.scrub = function() {
    Y(this._keySchedule), Y(this._invKeySchedule), Y(this._key);
  }, aes.AES = ae, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var B = safeBufferExports.Buffer, z = B.alloc(16, 0);
  function Y(ie) {
    return [
      ie.readUInt32BE(0),
      ie.readUInt32BE(4),
      ie.readUInt32BE(8),
      ie.readUInt32BE(12)
    ];
  }
  function ne(ie) {
    var ae = B.allocUnsafe(16);
    return ae.writeUInt32BE(ie[0] >>> 0, 0), ae.writeUInt32BE(ie[1] >>> 0, 4), ae.writeUInt32BE(ie[2] >>> 0, 8), ae.writeUInt32BE(ie[3] >>> 0, 12), ae;
  }
  function oe(ie) {
    this.h = ie, this.state = B.alloc(16, 0), this.cache = B.allocUnsafe(0);
  }
  return oe.prototype.ghash = function(ie) {
    for (var ae = -1; ++ae < ie.length; )
      this.state[ae] ^= ie[ae];
    this._multiply();
  }, oe.prototype._multiply = function() {
    for (var ie = Y(this.h), ae = [0, 0, 0, 0], se, ve, ge, le = -1; ++le < 128; ) {
      for (ve = (this.state[~~(le / 8)] & 1 << 7 - le % 8) !== 0, ve && (ae[0] ^= ie[0], ae[1] ^= ie[1], ae[2] ^= ie[2], ae[3] ^= ie[3]), ge = (ie[3] & 1) !== 0, se = 3; se > 0; se--)
        ie[se] = ie[se] >>> 1 | (ie[se - 1] & 1) << 31;
      ie[0] = ie[0] >>> 1, ge && (ie[0] = ie[0] ^ 225 << 24);
    }
    this.state = ne(ae);
  }, oe.prototype.update = function(ie) {
    this.cache = B.concat([this.cache, ie]);
    for (var ae; this.cache.length >= 16; )
      ae = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(ae);
  }, oe.prototype.final = function(ie, ae) {
    return this.cache.length && this.ghash(B.concat([this.cache, z], 16)), this.ghash(ne([0, ie, 0, ae])), this.state;
  }, ghash = oe, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var B = requireAes(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ne = requireInherits_browser(), oe = requireGhash(), ie = requireBufferXor(), ae = requireIncr32();
  function se(le, Ee) {
    var Ce = 0;
    le.length !== Ee.length && Ce++;
    for (var Pe = Math.min(le.length, Ee.length), Xe = 0; Xe < Pe; ++Xe)
      Ce += le[Xe] ^ Ee[Xe];
    return Ce;
  }
  function ve(le, Ee, Ce) {
    if (Ee.length === 12)
      return le._finID = z.concat([Ee, z.from([0, 0, 0, 1])]), z.concat([Ee, z.from([0, 0, 0, 2])]);
    var Pe = new oe(Ce), Xe = Ee.length, ht = Xe % 16;
    Pe.update(Ee), ht && (ht = 16 - ht, Pe.update(z.alloc(ht, 0))), Pe.update(z.alloc(8, 0));
    var wt = Xe * 8, Pt = z.alloc(8);
    Pt.writeUIntBE(wt, 0, 8), Pe.update(Pt), le._finID = Pe.state;
    var vt = z.from(le._finID);
    return ae(vt), vt;
  }
  function ge(le, Ee, Ce, Pe) {
    Y.call(this);
    var Xe = z.alloc(4, 0);
    this._cipher = new B.AES(Ee);
    var ht = this._cipher.encryptBlock(Xe);
    this._ghash = new oe(ht), Ce = ve(this, Ce, ht), this._prev = z.from(Ce), this._cache = z.allocUnsafe(0), this._secCache = z.allocUnsafe(0), this._decrypt = Pe, this._alen = 0, this._len = 0, this._mode = le, this._authTag = null, this._called = !1;
  }
  return ne(ge, Y), ge.prototype._update = function(le) {
    if (!this._called && this._alen) {
      var Ee = 16 - this._alen % 16;
      Ee < 16 && (Ee = z.alloc(Ee, 0), this._ghash.update(Ee));
    }
    this._called = !0;
    var Ce = this._mode.encrypt(this, le);
    return this._decrypt ? this._ghash.update(le) : this._ghash.update(Ce), this._len += le.length, Ce;
  }, ge.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var le = ie(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && se(le, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = le, this._cipher.scrub();
  }, ge.prototype.getAuthTag = function() {
    if (this._decrypt || !z.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, ge.prototype.setAuthTag = function(Ee) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = Ee;
  }, ge.prototype.setAAD = function(Ee) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(Ee), this._alen += Ee.length;
  }, authCipher = ge, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var B = requireAes(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ne = requireInherits_browser();
  function oe(ie, ae, se, ve) {
    Y.call(this), this._cipher = new B.AES(ae), this._prev = z.from(se), this._cache = z.allocUnsafe(0), this._secCache = z.allocUnsafe(0), this._decrypt = ve, this._mode = ie;
  }
  return ne(oe, Y), oe.prototype._update = function(ie) {
    return this._mode.encrypt(this, ie, this._decrypt);
  }, oe.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = oe, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var B = safeBufferExports.Buffer, z = requireMd5_js();
  function Y(ne, oe, ie, ae) {
    if (B.isBuffer(ne) || (ne = B.from(ne, "binary")), oe && (B.isBuffer(oe) || (oe = B.from(oe, "binary")), oe.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var se = ie / 8, ve = B.alloc(se), ge = B.alloc(ae || 0), le = B.alloc(0); se > 0 || ae > 0; ) {
      var Ee = new z();
      Ee.update(le), Ee.update(ne), oe && Ee.update(oe), le = Ee.digest();
      var Ce = 0;
      if (se > 0) {
        var Pe = ve.length - se;
        Ce = Math.min(se, le.length), le.copy(ve, Pe, 0, Ce), se -= Ce;
      }
      if (Ce < le.length && ae > 0) {
        var Xe = ge.length - ae, ht = Math.min(ae, le.length - Ce);
        le.copy(ge, Xe, Ce, Ce + ht), ae -= ht;
      }
    }
    return le.fill(0), { key: ve, iv: ge };
  }
  return evp_bytestokey = Y, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var B = requireModes$1(), z = requireAuthCipher(), Y = safeBufferExports.Buffer, ne = requireStreamCipher(), oe = requireCipherBase(), ie = requireAes(), ae = requireEvp_bytestokey(), se = requireInherits_browser();
  function ve(Pe, Xe, ht) {
    oe.call(this), this._cache = new le(), this._cipher = new ie.AES(Xe), this._prev = Y.from(ht), this._mode = Pe, this._autopadding = !0;
  }
  se(ve, oe), ve.prototype._update = function(Pe) {
    this._cache.add(Pe);
    for (var Xe, ht, wt = []; Xe = this._cache.get(); )
      ht = this._mode.encrypt(this, Xe), wt.push(ht);
    return Y.concat(wt);
  };
  var ge = Y.alloc(16, 16);
  ve.prototype._final = function() {
    var Pe = this._cache.flush();
    if (this._autopadding)
      return Pe = this._mode.encrypt(this, Pe), this._cipher.scrub(), Pe;
    if (!Pe.equals(ge))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ve.prototype.setAutoPadding = function(Pe) {
    return this._autopadding = !!Pe, this;
  };
  function le() {
    this.cache = Y.allocUnsafe(0);
  }
  le.prototype.add = function(Pe) {
    this.cache = Y.concat([this.cache, Pe]);
  }, le.prototype.get = function() {
    if (this.cache.length > 15) {
      var Pe = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Pe;
    }
    return null;
  }, le.prototype.flush = function() {
    for (var Pe = 16 - this.cache.length, Xe = Y.allocUnsafe(Pe), ht = -1; ++ht < Pe; )
      Xe.writeUInt8(Pe, ht);
    return Y.concat([this.cache, Xe]);
  };
  function Ee(Pe, Xe, ht) {
    var wt = B[Pe.toLowerCase()];
    if (!wt) throw new TypeError("invalid suite type");
    if (typeof Xe == "string" && (Xe = Y.from(Xe)), Xe.length !== wt.key / 8) throw new TypeError("invalid key length " + Xe.length);
    if (typeof ht == "string" && (ht = Y.from(ht)), wt.mode !== "GCM" && ht.length !== wt.iv) throw new TypeError("invalid iv length " + ht.length);
    return wt.type === "stream" ? new ne(wt.module, Xe, ht) : wt.type === "auth" ? new z(wt.module, Xe, ht) : new ve(wt.module, Xe, ht);
  }
  function Ce(Pe, Xe) {
    var ht = B[Pe.toLowerCase()];
    if (!ht) throw new TypeError("invalid suite type");
    var wt = ae(Xe, !1, ht.key, ht.iv);
    return Ee(Pe, wt.key, wt.iv);
  }
  return encrypter.createCipheriv = Ee, encrypter.createCipher = Ce, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var B = requireAuthCipher(), z = safeBufferExports.Buffer, Y = requireModes$1(), ne = requireStreamCipher(), oe = requireCipherBase(), ie = requireAes(), ae = requireEvp_bytestokey(), se = requireInherits_browser();
  function ve(Pe, Xe, ht) {
    oe.call(this), this._cache = new ge(), this._last = void 0, this._cipher = new ie.AES(Xe), this._prev = z.from(ht), this._mode = Pe, this._autopadding = !0;
  }
  se(ve, oe), ve.prototype._update = function(Pe) {
    this._cache.add(Pe);
    for (var Xe, ht, wt = []; Xe = this._cache.get(this._autopadding); )
      ht = this._mode.decrypt(this, Xe), wt.push(ht);
    return z.concat(wt);
  }, ve.prototype._final = function() {
    var Pe = this._cache.flush();
    if (this._autopadding)
      return le(this._mode.decrypt(this, Pe));
    if (Pe)
      throw new Error("data not multiple of block length");
  }, ve.prototype.setAutoPadding = function(Pe) {
    return this._autopadding = !!Pe, this;
  };
  function ge() {
    this.cache = z.allocUnsafe(0);
  }
  ge.prototype.add = function(Pe) {
    this.cache = z.concat([this.cache, Pe]);
  }, ge.prototype.get = function(Pe) {
    var Xe;
    if (Pe) {
      if (this.cache.length > 16)
        return Xe = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Xe;
    } else if (this.cache.length >= 16)
      return Xe = this.cache.slice(0, 16), this.cache = this.cache.slice(16), Xe;
    return null;
  }, ge.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function le(Pe) {
    var Xe = Pe[15];
    if (Xe < 1 || Xe > 16)
      throw new Error("unable to decrypt data");
    for (var ht = -1; ++ht < Xe; )
      if (Pe[ht + (16 - Xe)] !== Xe)
        throw new Error("unable to decrypt data");
    if (Xe !== 16)
      return Pe.slice(0, 16 - Xe);
  }
  function Ee(Pe, Xe, ht) {
    var wt = Y[Pe.toLowerCase()];
    if (!wt) throw new TypeError("invalid suite type");
    if (typeof ht == "string" && (ht = z.from(ht)), wt.mode !== "GCM" && ht.length !== wt.iv) throw new TypeError("invalid iv length " + ht.length);
    if (typeof Xe == "string" && (Xe = z.from(Xe)), Xe.length !== wt.key / 8) throw new TypeError("invalid key length " + Xe.length);
    return wt.type === "stream" ? new ne(wt.module, Xe, ht, !0) : wt.type === "auth" ? new B(wt.module, Xe, ht, !0) : new ve(wt.module, Xe, ht);
  }
  function Ce(Pe, Xe) {
    var ht = Y[Pe.toLowerCase()];
    if (!ht) throw new TypeError("invalid suite type");
    var wt = ae(Xe, !1, ht.key, ht.iv);
    return Ee(Pe, wt.key, wt.iv);
  }
  return decrypter.createDecipher = Ce, decrypter.createDecipheriv = Ee, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var B = requireEncrypter(), z = requireDecrypter(), Y = require$$2;
  function ne() {
    return Object.keys(Y);
  }
  return browser$5.createCipher = browser$5.Cipher = B.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = B.createCipheriv, browser$5.createDecipher = browser$5.Decipher = z.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = z.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = ne, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(B) {
    B["des-ecb"] = {
      key: 8,
      iv: 0
    }, B["des-cbc"] = B.des = {
      key: 8,
      iv: 8
    }, B["des-ede3-cbc"] = B.des3 = {
      key: 24,
      iv: 8
    }, B["des-ede3"] = {
      key: 24,
      iv: 0
    }, B["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, B["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var B = requireBrowserifyDes(), z = requireBrowser$6(), Y = requireModes$1(), ne = requireModes(), oe = requireEvp_bytestokey();
  function ie(le, Ee) {
    le = le.toLowerCase();
    var Ce, Pe;
    if (Y[le])
      Ce = Y[le].key, Pe = Y[le].iv;
    else if (ne[le])
      Ce = ne[le].key * 8, Pe = ne[le].iv;
    else
      throw new TypeError("invalid suite type");
    var Xe = oe(Ee, !1, Ce, Pe);
    return se(le, Xe.key, Xe.iv);
  }
  function ae(le, Ee) {
    le = le.toLowerCase();
    var Ce, Pe;
    if (Y[le])
      Ce = Y[le].key, Pe = Y[le].iv;
    else if (ne[le])
      Ce = ne[le].key * 8, Pe = ne[le].iv;
    else
      throw new TypeError("invalid suite type");
    var Xe = oe(Ee, !1, Ce, Pe);
    return ve(le, Xe.key, Xe.iv);
  }
  function se(le, Ee, Ce) {
    if (le = le.toLowerCase(), Y[le]) return z.createCipheriv(le, Ee, Ce);
    if (ne[le]) return new B({ key: Ee, iv: Ce, mode: le });
    throw new TypeError("invalid suite type");
  }
  function ve(le, Ee, Ce) {
    if (le = le.toLowerCase(), Y[le]) return z.createDecipheriv(le, Ee, Ce);
    if (ne[le]) return new B({ key: Ee, iv: Ce, mode: le, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function ge() {
    return Object.keys(ne).concat(z.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = ie, browser$6.createCipheriv = browser$6.Cipheriv = se, browser$6.createDecipher = browser$6.Decipher = ae, browser$6.createDecipheriv = browser$6.Decipheriv = ve, browser$6.listCiphers = browser$6.getCiphers = ge, browser$6;
}
var browser$4 = {}, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(B) {
    (function(z, Y) {
      function ne(Ft, Ve) {
        if (!Ft) throw new Error(Ve || "Assertion failed");
      }
      function oe(Ft, Ve) {
        Ft.super_ = Ve;
        var Je = function() {
        };
        Je.prototype = Ve.prototype, Ft.prototype = new Je(), Ft.prototype.constructor = Ft;
      }
      function ie(Ft, Ve, Je) {
        if (ie.isBN(Ft))
          return Ft;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Ft !== null && ((Ve === "le" || Ve === "be") && (Je = Ve, Ve = 10), this._init(Ft || 0, Ve || 10, Je || "be"));
      }
      typeof z == "object" ? z.exports = ie : Y.BN = ie, ie.BN = ie, ie.wordSize = 26;
      var ae;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? ae = window.Buffer : ae = dist$1.Buffer;
      } catch {
      }
      ie.isBN = function(Ve) {
        return Ve instanceof ie ? !0 : Ve !== null && typeof Ve == "object" && Ve.constructor.wordSize === ie.wordSize && Array.isArray(Ve.words);
      }, ie.max = function(Ve, Je) {
        return Ve.cmp(Je) > 0 ? Ve : Je;
      }, ie.min = function(Ve, Je) {
        return Ve.cmp(Je) < 0 ? Ve : Je;
      }, ie.prototype._init = function(Ve, Je, Ke) {
        if (typeof Ve == "number")
          return this._initNumber(Ve, Je, Ke);
        if (typeof Ve == "object")
          return this._initArray(Ve, Je, Ke);
        Je === "hex" && (Je = 16), ne(Je === (Je | 0) && Je >= 2 && Je <= 36), Ve = Ve.toString().replace(/\s+/g, "");
        var Qe = 0;
        Ve[0] === "-" && (Qe++, this.negative = 1), Qe < Ve.length && (Je === 16 ? this._parseHex(Ve, Qe, Ke) : (this._parseBase(Ve, Je, Qe), Ke === "le" && this._initArray(this.toArray(), Je, Ke)));
      }, ie.prototype._initNumber = function(Ve, Je, Ke) {
        Ve < 0 && (this.negative = 1, Ve = -Ve), Ve < 67108864 ? (this.words = [Ve & 67108863], this.length = 1) : Ve < 4503599627370496 ? (this.words = [
          Ve & 67108863,
          Ve / 67108864 & 67108863
        ], this.length = 2) : (ne(Ve < 9007199254740992), this.words = [
          Ve & 67108863,
          Ve / 67108864 & 67108863,
          1
        ], this.length = 3), Ke === "le" && this._initArray(this.toArray(), Je, Ke);
      }, ie.prototype._initArray = function(Ve, Je, Ke) {
        if (ne(typeof Ve.length == "number"), Ve.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Ve.length / 3), this.words = new Array(this.length);
        for (var Qe = 0; Qe < this.length; Qe++)
          this.words[Qe] = 0;
        var bt, _t, $t = 0;
        if (Ke === "be")
          for (Qe = Ve.length - 1, bt = 0; Qe >= 0; Qe -= 3)
            _t = Ve[Qe] | Ve[Qe - 1] << 8 | Ve[Qe - 2] << 16, this.words[bt] |= _t << $t & 67108863, this.words[bt + 1] = _t >>> 26 - $t & 67108863, $t += 24, $t >= 26 && ($t -= 26, bt++);
        else if (Ke === "le")
          for (Qe = 0, bt = 0; Qe < Ve.length; Qe += 3)
            _t = Ve[Qe] | Ve[Qe + 1] << 8 | Ve[Qe + 2] << 16, this.words[bt] |= _t << $t & 67108863, this.words[bt + 1] = _t >>> 26 - $t & 67108863, $t += 24, $t >= 26 && ($t -= 26, bt++);
        return this.strip();
      };
      function se(Ft, Ve) {
        var Je = Ft.charCodeAt(Ve);
        return Je >= 65 && Je <= 70 ? Je - 55 : Je >= 97 && Je <= 102 ? Je - 87 : Je - 48 & 15;
      }
      function ve(Ft, Ve, Je) {
        var Ke = se(Ft, Je);
        return Je - 1 >= Ve && (Ke |= se(Ft, Je - 1) << 4), Ke;
      }
      ie.prototype._parseHex = function(Ve, Je, Ke) {
        this.length = Math.ceil((Ve.length - Je) / 6), this.words = new Array(this.length);
        for (var Qe = 0; Qe < this.length; Qe++)
          this.words[Qe] = 0;
        var bt = 0, _t = 0, $t;
        if (Ke === "be")
          for (Qe = Ve.length - 1; Qe >= Je; Qe -= 2)
            $t = ve(Ve, Je, Qe) << bt, this.words[_t] |= $t & 67108863, bt >= 18 ? (bt -= 18, _t += 1, this.words[_t] |= $t >>> 26) : bt += 8;
        else {
          var kt = Ve.length - Je;
          for (Qe = kt % 2 === 0 ? Je + 1 : Je; Qe < Ve.length; Qe += 2)
            $t = ve(Ve, Je, Qe) << bt, this.words[_t] |= $t & 67108863, bt >= 18 ? (bt -= 18, _t += 1, this.words[_t] |= $t >>> 26) : bt += 8;
        }
        this.strip();
      };
      function ge(Ft, Ve, Je, Ke) {
        for (var Qe = 0, bt = Math.min(Ft.length, Je), _t = Ve; _t < bt; _t++) {
          var $t = Ft.charCodeAt(_t) - 48;
          Qe *= Ke, $t >= 49 ? Qe += $t - 49 + 10 : $t >= 17 ? Qe += $t - 17 + 10 : Qe += $t;
        }
        return Qe;
      }
      ie.prototype._parseBase = function(Ve, Je, Ke) {
        this.words = [0], this.length = 1;
        for (var Qe = 0, bt = 1; bt <= 67108863; bt *= Je)
          Qe++;
        Qe--, bt = bt / Je | 0;
        for (var _t = Ve.length - Ke, $t = _t % Qe, kt = Math.min(_t, _t - $t) + Ke, xt = 0, Nt = Ke; Nt < kt; Nt += Qe)
          xt = ge(Ve, Nt, Nt + Qe, Je), this.imuln(bt), this.words[0] + xt < 67108864 ? this.words[0] += xt : this._iaddn(xt);
        if ($t !== 0) {
          var Rt = 1;
          for (xt = ge(Ve, Nt, Ve.length, Je), Nt = 0; Nt < $t; Nt++)
            Rt *= Je;
          this.imuln(Rt), this.words[0] + xt < 67108864 ? this.words[0] += xt : this._iaddn(xt);
        }
        this.strip();
      }, ie.prototype.copy = function(Ve) {
        Ve.words = new Array(this.length);
        for (var Je = 0; Je < this.length; Je++)
          Ve.words[Je] = this.words[Je];
        Ve.length = this.length, Ve.negative = this.negative, Ve.red = this.red;
      }, ie.prototype.clone = function() {
        var Ve = new ie(null);
        return this.copy(Ve), Ve;
      }, ie.prototype._expand = function(Ve) {
        for (; this.length < Ve; )
          this.words[this.length++] = 0;
        return this;
      }, ie.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ie.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, ie.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var le = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ee = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Ce = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ie.prototype.toString = function(Ve, Je) {
        Ve = Ve || 10, Je = Je | 0 || 1;
        var Ke;
        if (Ve === 16 || Ve === "hex") {
          Ke = "";
          for (var Qe = 0, bt = 0, _t = 0; _t < this.length; _t++) {
            var $t = this.words[_t], kt = (($t << Qe | bt) & 16777215).toString(16);
            bt = $t >>> 24 - Qe & 16777215, Qe += 2, Qe >= 26 && (Qe -= 26, _t--), bt !== 0 || _t !== this.length - 1 ? Ke = le[6 - kt.length] + kt + Ke : Ke = kt + Ke;
          }
          for (bt !== 0 && (Ke = bt.toString(16) + Ke); Ke.length % Je !== 0; )
            Ke = "0" + Ke;
          return this.negative !== 0 && (Ke = "-" + Ke), Ke;
        }
        if (Ve === (Ve | 0) && Ve >= 2 && Ve <= 36) {
          var xt = Ee[Ve], Nt = Ce[Ve];
          Ke = "";
          var Rt = this.clone();
          for (Rt.negative = 0; !Rt.isZero(); ) {
            var Ht = Rt.modn(Nt).toString(Ve);
            Rt = Rt.idivn(Nt), Rt.isZero() ? Ke = Ht + Ke : Ke = le[xt - Ht.length] + Ht + Ke;
          }
          for (this.isZero() && (Ke = "0" + Ke); Ke.length % Je !== 0; )
            Ke = "0" + Ke;
          return this.negative !== 0 && (Ke = "-" + Ke), Ke;
        }
        ne(!1, "Base should be between 2 and 36");
      }, ie.prototype.toNumber = function() {
        var Ve = this.words[0];
        return this.length === 2 ? Ve += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Ve += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Ve : Ve;
      }, ie.prototype.toJSON = function() {
        return this.toString(16);
      }, ie.prototype.toBuffer = function(Ve, Je) {
        return ne(typeof ae < "u"), this.toArrayLike(ae, Ve, Je);
      }, ie.prototype.toArray = function(Ve, Je) {
        return this.toArrayLike(Array, Ve, Je);
      }, ie.prototype.toArrayLike = function(Ve, Je, Ke) {
        var Qe = this.byteLength(), bt = Ke || Math.max(1, Qe);
        ne(Qe <= bt, "byte array longer than desired length"), ne(bt > 0, "Requested array length <= 0"), this.strip();
        var _t = Je === "le", $t = new Ve(bt), kt, xt, Nt = this.clone();
        if (_t) {
          for (xt = 0; !Nt.isZero(); xt++)
            kt = Nt.andln(255), Nt.iushrn(8), $t[xt] = kt;
          for (; xt < bt; xt++)
            $t[xt] = 0;
        } else {
          for (xt = 0; xt < bt - Qe; xt++)
            $t[xt] = 0;
          for (xt = 0; !Nt.isZero(); xt++)
            kt = Nt.andln(255), Nt.iushrn(8), $t[bt - xt - 1] = kt;
        }
        return $t;
      }, Math.clz32 ? ie.prototype._countBits = function(Ve) {
        return 32 - Math.clz32(Ve);
      } : ie.prototype._countBits = function(Ve) {
        var Je = Ve, Ke = 0;
        return Je >= 4096 && (Ke += 13, Je >>>= 13), Je >= 64 && (Ke += 7, Je >>>= 7), Je >= 8 && (Ke += 4, Je >>>= 4), Je >= 2 && (Ke += 2, Je >>>= 2), Ke + Je;
      }, ie.prototype._zeroBits = function(Ve) {
        if (Ve === 0) return 26;
        var Je = Ve, Ke = 0;
        return Je & 8191 || (Ke += 13, Je >>>= 13), Je & 127 || (Ke += 7, Je >>>= 7), Je & 15 || (Ke += 4, Je >>>= 4), Je & 3 || (Ke += 2, Je >>>= 2), Je & 1 || Ke++, Ke;
      }, ie.prototype.bitLength = function() {
        var Ve = this.words[this.length - 1], Je = this._countBits(Ve);
        return (this.length - 1) * 26 + Je;
      };
      function Pe(Ft) {
        for (var Ve = new Array(Ft.bitLength()), Je = 0; Je < Ve.length; Je++) {
          var Ke = Je / 26 | 0, Qe = Je % 26;
          Ve[Je] = (Ft.words[Ke] & 1 << Qe) >>> Qe;
        }
        return Ve;
      }
      ie.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Ve = 0, Je = 0; Je < this.length; Je++) {
          var Ke = this._zeroBits(this.words[Je]);
          if (Ve += Ke, Ke !== 26) break;
        }
        return Ve;
      }, ie.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ie.prototype.toTwos = function(Ve) {
        return this.negative !== 0 ? this.abs().inotn(Ve).iaddn(1) : this.clone();
      }, ie.prototype.fromTwos = function(Ve) {
        return this.testn(Ve - 1) ? this.notn(Ve).iaddn(1).ineg() : this.clone();
      }, ie.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ie.prototype.neg = function() {
        return this.clone().ineg();
      }, ie.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ie.prototype.iuor = function(Ve) {
        for (; this.length < Ve.length; )
          this.words[this.length++] = 0;
        for (var Je = 0; Je < Ve.length; Je++)
          this.words[Je] = this.words[Je] | Ve.words[Je];
        return this.strip();
      }, ie.prototype.ior = function(Ve) {
        return ne((this.negative | Ve.negative) === 0), this.iuor(Ve);
      }, ie.prototype.or = function(Ve) {
        return this.length > Ve.length ? this.clone().ior(Ve) : Ve.clone().ior(this);
      }, ie.prototype.uor = function(Ve) {
        return this.length > Ve.length ? this.clone().iuor(Ve) : Ve.clone().iuor(this);
      }, ie.prototype.iuand = function(Ve) {
        var Je;
        this.length > Ve.length ? Je = Ve : Je = this;
        for (var Ke = 0; Ke < Je.length; Ke++)
          this.words[Ke] = this.words[Ke] & Ve.words[Ke];
        return this.length = Je.length, this.strip();
      }, ie.prototype.iand = function(Ve) {
        return ne((this.negative | Ve.negative) === 0), this.iuand(Ve);
      }, ie.prototype.and = function(Ve) {
        return this.length > Ve.length ? this.clone().iand(Ve) : Ve.clone().iand(this);
      }, ie.prototype.uand = function(Ve) {
        return this.length > Ve.length ? this.clone().iuand(Ve) : Ve.clone().iuand(this);
      }, ie.prototype.iuxor = function(Ve) {
        var Je, Ke;
        this.length > Ve.length ? (Je = this, Ke = Ve) : (Je = Ve, Ke = this);
        for (var Qe = 0; Qe < Ke.length; Qe++)
          this.words[Qe] = Je.words[Qe] ^ Ke.words[Qe];
        if (this !== Je)
          for (; Qe < Je.length; Qe++)
            this.words[Qe] = Je.words[Qe];
        return this.length = Je.length, this.strip();
      }, ie.prototype.ixor = function(Ve) {
        return ne((this.negative | Ve.negative) === 0), this.iuxor(Ve);
      }, ie.prototype.xor = function(Ve) {
        return this.length > Ve.length ? this.clone().ixor(Ve) : Ve.clone().ixor(this);
      }, ie.prototype.uxor = function(Ve) {
        return this.length > Ve.length ? this.clone().iuxor(Ve) : Ve.clone().iuxor(this);
      }, ie.prototype.inotn = function(Ve) {
        ne(typeof Ve == "number" && Ve >= 0);
        var Je = Math.ceil(Ve / 26) | 0, Ke = Ve % 26;
        this._expand(Je), Ke > 0 && Je--;
        for (var Qe = 0; Qe < Je; Qe++)
          this.words[Qe] = ~this.words[Qe] & 67108863;
        return Ke > 0 && (this.words[Qe] = ~this.words[Qe] & 67108863 >> 26 - Ke), this.strip();
      }, ie.prototype.notn = function(Ve) {
        return this.clone().inotn(Ve);
      }, ie.prototype.setn = function(Ve, Je) {
        ne(typeof Ve == "number" && Ve >= 0);
        var Ke = Ve / 26 | 0, Qe = Ve % 26;
        return this._expand(Ke + 1), Je ? this.words[Ke] = this.words[Ke] | 1 << Qe : this.words[Ke] = this.words[Ke] & ~(1 << Qe), this.strip();
      }, ie.prototype.iadd = function(Ve) {
        var Je;
        if (this.negative !== 0 && Ve.negative === 0)
          return this.negative = 0, Je = this.isub(Ve), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Ve.negative !== 0)
          return Ve.negative = 0, Je = this.isub(Ve), Ve.negative = 1, Je._normSign();
        var Ke, Qe;
        this.length > Ve.length ? (Ke = this, Qe = Ve) : (Ke = Ve, Qe = this);
        for (var bt = 0, _t = 0; _t < Qe.length; _t++)
          Je = (Ke.words[_t] | 0) + (Qe.words[_t] | 0) + bt, this.words[_t] = Je & 67108863, bt = Je >>> 26;
        for (; bt !== 0 && _t < Ke.length; _t++)
          Je = (Ke.words[_t] | 0) + bt, this.words[_t] = Je & 67108863, bt = Je >>> 26;
        if (this.length = Ke.length, bt !== 0)
          this.words[this.length] = bt, this.length++;
        else if (Ke !== this)
          for (; _t < Ke.length; _t++)
            this.words[_t] = Ke.words[_t];
        return this;
      }, ie.prototype.add = function(Ve) {
        var Je;
        return Ve.negative !== 0 && this.negative === 0 ? (Ve.negative = 0, Je = this.sub(Ve), Ve.negative ^= 1, Je) : Ve.negative === 0 && this.negative !== 0 ? (this.negative = 0, Je = Ve.sub(this), this.negative = 1, Je) : this.length > Ve.length ? this.clone().iadd(Ve) : Ve.clone().iadd(this);
      }, ie.prototype.isub = function(Ve) {
        if (Ve.negative !== 0) {
          Ve.negative = 0;
          var Je = this.iadd(Ve);
          return Ve.negative = 1, Je._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Ve), this.negative = 1, this._normSign();
        var Ke = this.cmp(Ve);
        if (Ke === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var Qe, bt;
        Ke > 0 ? (Qe = this, bt = Ve) : (Qe = Ve, bt = this);
        for (var _t = 0, $t = 0; $t < bt.length; $t++)
          Je = (Qe.words[$t] | 0) - (bt.words[$t] | 0) + _t, _t = Je >> 26, this.words[$t] = Je & 67108863;
        for (; _t !== 0 && $t < Qe.length; $t++)
          Je = (Qe.words[$t] | 0) + _t, _t = Je >> 26, this.words[$t] = Je & 67108863;
        if (_t === 0 && $t < Qe.length && Qe !== this)
          for (; $t < Qe.length; $t++)
            this.words[$t] = Qe.words[$t];
        return this.length = Math.max(this.length, $t), Qe !== this && (this.negative = 1), this.strip();
      }, ie.prototype.sub = function(Ve) {
        return this.clone().isub(Ve);
      };
      function Xe(Ft, Ve, Je) {
        Je.negative = Ve.negative ^ Ft.negative;
        var Ke = Ft.length + Ve.length | 0;
        Je.length = Ke, Ke = Ke - 1 | 0;
        var Qe = Ft.words[0] | 0, bt = Ve.words[0] | 0, _t = Qe * bt, $t = _t & 67108863, kt = _t / 67108864 | 0;
        Je.words[0] = $t;
        for (var xt = 1; xt < Ke; xt++) {
          for (var Nt = kt >>> 26, Rt = kt & 67108863, Ht = Math.min(xt, Ve.length - 1), ar = Math.max(0, xt - Ft.length + 1); ar <= Ht; ar++) {
            var lr = xt - ar | 0;
            Qe = Ft.words[lr] | 0, bt = Ve.words[ar] | 0, _t = Qe * bt + Rt, Nt += _t / 67108864 | 0, Rt = _t & 67108863;
          }
          Je.words[xt] = Rt | 0, kt = Nt | 0;
        }
        return kt !== 0 ? Je.words[xt] = kt | 0 : Je.length--, Je.strip();
      }
      var ht = function(Ve, Je, Ke) {
        var Qe = Ve.words, bt = Je.words, _t = Ke.words, $t = 0, kt, xt, Nt, Rt = Qe[0] | 0, Ht = Rt & 8191, ar = Rt >>> 13, lr = Qe[1] | 0, nr = lr & 8191, Vt = lr >>> 13, Xt = Qe[2] | 0, sr = Xt & 8191, dr = Xt >>> 13, er = Qe[3] | 0, Zt = er & 8191, pr = er >>> 13, _r = Qe[4] | 0, Ar = _r & 8191, Sr = _r >>> 13, Br = Qe[5] | 0, Ir = Br & 8191, wr = Br >>> 13, Gr = Qe[6] | 0, Pr = Gr & 8191, Mr = Gr >>> 13, Cr = Qe[7] | 0, Tr = Cr & 8191, Hr = Cr >>> 13, Yr = Qe[8] | 0, Nr = Yr & 8191, zr = Yr >>> 13, Jr = Qe[9] | 0, Jt = Jr & 8191, Dt = Jr >>> 13, Gt = bt[0] | 0, rr = Gt & 8191, cr = Gt >>> 13, br = bt[1] | 0, gr = br & 8191, Or = br >>> 13, Wr = bt[2] | 0, kr = Wr & 8191, jr = Wr >>> 13, Lr = bt[3] | 0, Fr = Lr & 8191, Xr = Lr >>> 13, Zr = bt[4] | 0, fr = Zr & 8191, tr = Zr >>> 13, ur = bt[5] | 0, jt = ur & 8191, Ot = ur >>> 13, Lt = bt[6] | 0, Qt = Lt & 8191, or = Lt >>> 13, hr = bt[7] | 0, yr = hr & 8191, xr = hr >>> 13, Rr = bt[8] | 0, ir = Rr & 8191, vr = Rr >>> 13, Er = bt[9] | 0, $r = Er & 8191, Ur = Er >>> 13;
        Ke.negative = Ve.negative ^ Je.negative, Ke.length = 19, kt = Math.imul(Ht, rr), xt = Math.imul(Ht, cr), xt = xt + Math.imul(ar, rr) | 0, Nt = Math.imul(ar, cr);
        var Dr = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (Dr >>> 26) | 0, Dr &= 67108863, kt = Math.imul(nr, rr), xt = Math.imul(nr, cr), xt = xt + Math.imul(Vt, rr) | 0, Nt = Math.imul(Vt, cr), kt = kt + Math.imul(Ht, gr) | 0, xt = xt + Math.imul(Ht, Or) | 0, xt = xt + Math.imul(ar, gr) | 0, Nt = Nt + Math.imul(ar, Or) | 0;
        var qr = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (qr >>> 26) | 0, qr &= 67108863, kt = Math.imul(sr, rr), xt = Math.imul(sr, cr), xt = xt + Math.imul(dr, rr) | 0, Nt = Math.imul(dr, cr), kt = kt + Math.imul(nr, gr) | 0, xt = xt + Math.imul(nr, Or) | 0, xt = xt + Math.imul(Vt, gr) | 0, Nt = Nt + Math.imul(Vt, Or) | 0, kt = kt + Math.imul(Ht, kr) | 0, xt = xt + Math.imul(Ht, jr) | 0, xt = xt + Math.imul(ar, kr) | 0, Nt = Nt + Math.imul(ar, jr) | 0;
        var Vr = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, kt = Math.imul(Zt, rr), xt = Math.imul(Zt, cr), xt = xt + Math.imul(pr, rr) | 0, Nt = Math.imul(pr, cr), kt = kt + Math.imul(sr, gr) | 0, xt = xt + Math.imul(sr, Or) | 0, xt = xt + Math.imul(dr, gr) | 0, Nt = Nt + Math.imul(dr, Or) | 0, kt = kt + Math.imul(nr, kr) | 0, xt = xt + Math.imul(nr, jr) | 0, xt = xt + Math.imul(Vt, kr) | 0, Nt = Nt + Math.imul(Vt, jr) | 0, kt = kt + Math.imul(Ht, Fr) | 0, xt = xt + Math.imul(Ht, Xr) | 0, xt = xt + Math.imul(ar, Fr) | 0, Nt = Nt + Math.imul(ar, Xr) | 0;
        var tn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, kt = Math.imul(Ar, rr), xt = Math.imul(Ar, cr), xt = xt + Math.imul(Sr, rr) | 0, Nt = Math.imul(Sr, cr), kt = kt + Math.imul(Zt, gr) | 0, xt = xt + Math.imul(Zt, Or) | 0, xt = xt + Math.imul(pr, gr) | 0, Nt = Nt + Math.imul(pr, Or) | 0, kt = kt + Math.imul(sr, kr) | 0, xt = xt + Math.imul(sr, jr) | 0, xt = xt + Math.imul(dr, kr) | 0, Nt = Nt + Math.imul(dr, jr) | 0, kt = kt + Math.imul(nr, Fr) | 0, xt = xt + Math.imul(nr, Xr) | 0, xt = xt + Math.imul(Vt, Fr) | 0, Nt = Nt + Math.imul(Vt, Xr) | 0, kt = kt + Math.imul(Ht, fr) | 0, xt = xt + Math.imul(Ht, tr) | 0, xt = xt + Math.imul(ar, fr) | 0, Nt = Nt + Math.imul(ar, tr) | 0;
        var Qr = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, kt = Math.imul(Ir, rr), xt = Math.imul(Ir, cr), xt = xt + Math.imul(wr, rr) | 0, Nt = Math.imul(wr, cr), kt = kt + Math.imul(Ar, gr) | 0, xt = xt + Math.imul(Ar, Or) | 0, xt = xt + Math.imul(Sr, gr) | 0, Nt = Nt + Math.imul(Sr, Or) | 0, kt = kt + Math.imul(Zt, kr) | 0, xt = xt + Math.imul(Zt, jr) | 0, xt = xt + Math.imul(pr, kr) | 0, Nt = Nt + Math.imul(pr, jr) | 0, kt = kt + Math.imul(sr, Fr) | 0, xt = xt + Math.imul(sr, Xr) | 0, xt = xt + Math.imul(dr, Fr) | 0, Nt = Nt + Math.imul(dr, Xr) | 0, kt = kt + Math.imul(nr, fr) | 0, xt = xt + Math.imul(nr, tr) | 0, xt = xt + Math.imul(Vt, fr) | 0, Nt = Nt + Math.imul(Vt, tr) | 0, kt = kt + Math.imul(Ht, jt) | 0, xt = xt + Math.imul(Ht, Ot) | 0, xt = xt + Math.imul(ar, jt) | 0, Nt = Nt + Math.imul(ar, Ot) | 0;
        var en = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, kt = Math.imul(Pr, rr), xt = Math.imul(Pr, cr), xt = xt + Math.imul(Mr, rr) | 0, Nt = Math.imul(Mr, cr), kt = kt + Math.imul(Ir, gr) | 0, xt = xt + Math.imul(Ir, Or) | 0, xt = xt + Math.imul(wr, gr) | 0, Nt = Nt + Math.imul(wr, Or) | 0, kt = kt + Math.imul(Ar, kr) | 0, xt = xt + Math.imul(Ar, jr) | 0, xt = xt + Math.imul(Sr, kr) | 0, Nt = Nt + Math.imul(Sr, jr) | 0, kt = kt + Math.imul(Zt, Fr) | 0, xt = xt + Math.imul(Zt, Xr) | 0, xt = xt + Math.imul(pr, Fr) | 0, Nt = Nt + Math.imul(pr, Xr) | 0, kt = kt + Math.imul(sr, fr) | 0, xt = xt + Math.imul(sr, tr) | 0, xt = xt + Math.imul(dr, fr) | 0, Nt = Nt + Math.imul(dr, tr) | 0, kt = kt + Math.imul(nr, jt) | 0, xt = xt + Math.imul(nr, Ot) | 0, xt = xt + Math.imul(Vt, jt) | 0, Nt = Nt + Math.imul(Vt, Ot) | 0, kt = kt + Math.imul(Ht, Qt) | 0, xt = xt + Math.imul(Ht, or) | 0, xt = xt + Math.imul(ar, Qt) | 0, Nt = Nt + Math.imul(ar, or) | 0;
        var on = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, kt = Math.imul(Tr, rr), xt = Math.imul(Tr, cr), xt = xt + Math.imul(Hr, rr) | 0, Nt = Math.imul(Hr, cr), kt = kt + Math.imul(Pr, gr) | 0, xt = xt + Math.imul(Pr, Or) | 0, xt = xt + Math.imul(Mr, gr) | 0, Nt = Nt + Math.imul(Mr, Or) | 0, kt = kt + Math.imul(Ir, kr) | 0, xt = xt + Math.imul(Ir, jr) | 0, xt = xt + Math.imul(wr, kr) | 0, Nt = Nt + Math.imul(wr, jr) | 0, kt = kt + Math.imul(Ar, Fr) | 0, xt = xt + Math.imul(Ar, Xr) | 0, xt = xt + Math.imul(Sr, Fr) | 0, Nt = Nt + Math.imul(Sr, Xr) | 0, kt = kt + Math.imul(Zt, fr) | 0, xt = xt + Math.imul(Zt, tr) | 0, xt = xt + Math.imul(pr, fr) | 0, Nt = Nt + Math.imul(pr, tr) | 0, kt = kt + Math.imul(sr, jt) | 0, xt = xt + Math.imul(sr, Ot) | 0, xt = xt + Math.imul(dr, jt) | 0, Nt = Nt + Math.imul(dr, Ot) | 0, kt = kt + Math.imul(nr, Qt) | 0, xt = xt + Math.imul(nr, or) | 0, xt = xt + Math.imul(Vt, Qt) | 0, Nt = Nt + Math.imul(Vt, or) | 0, kt = kt + Math.imul(Ht, yr) | 0, xt = xt + Math.imul(Ht, xr) | 0, xt = xt + Math.imul(ar, yr) | 0, Nt = Nt + Math.imul(ar, xr) | 0;
        var sn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, kt = Math.imul(Nr, rr), xt = Math.imul(Nr, cr), xt = xt + Math.imul(zr, rr) | 0, Nt = Math.imul(zr, cr), kt = kt + Math.imul(Tr, gr) | 0, xt = xt + Math.imul(Tr, Or) | 0, xt = xt + Math.imul(Hr, gr) | 0, Nt = Nt + Math.imul(Hr, Or) | 0, kt = kt + Math.imul(Pr, kr) | 0, xt = xt + Math.imul(Pr, jr) | 0, xt = xt + Math.imul(Mr, kr) | 0, Nt = Nt + Math.imul(Mr, jr) | 0, kt = kt + Math.imul(Ir, Fr) | 0, xt = xt + Math.imul(Ir, Xr) | 0, xt = xt + Math.imul(wr, Fr) | 0, Nt = Nt + Math.imul(wr, Xr) | 0, kt = kt + Math.imul(Ar, fr) | 0, xt = xt + Math.imul(Ar, tr) | 0, xt = xt + Math.imul(Sr, fr) | 0, Nt = Nt + Math.imul(Sr, tr) | 0, kt = kt + Math.imul(Zt, jt) | 0, xt = xt + Math.imul(Zt, Ot) | 0, xt = xt + Math.imul(pr, jt) | 0, Nt = Nt + Math.imul(pr, Ot) | 0, kt = kt + Math.imul(sr, Qt) | 0, xt = xt + Math.imul(sr, or) | 0, xt = xt + Math.imul(dr, Qt) | 0, Nt = Nt + Math.imul(dr, or) | 0, kt = kt + Math.imul(nr, yr) | 0, xt = xt + Math.imul(nr, xr) | 0, xt = xt + Math.imul(Vt, yr) | 0, Nt = Nt + Math.imul(Vt, xr) | 0, kt = kt + Math.imul(Ht, ir) | 0, xt = xt + Math.imul(Ht, vr) | 0, xt = xt + Math.imul(ar, ir) | 0, Nt = Nt + Math.imul(ar, vr) | 0;
        var an = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, kt = Math.imul(Jt, rr), xt = Math.imul(Jt, cr), xt = xt + Math.imul(Dt, rr) | 0, Nt = Math.imul(Dt, cr), kt = kt + Math.imul(Nr, gr) | 0, xt = xt + Math.imul(Nr, Or) | 0, xt = xt + Math.imul(zr, gr) | 0, Nt = Nt + Math.imul(zr, Or) | 0, kt = kt + Math.imul(Tr, kr) | 0, xt = xt + Math.imul(Tr, jr) | 0, xt = xt + Math.imul(Hr, kr) | 0, Nt = Nt + Math.imul(Hr, jr) | 0, kt = kt + Math.imul(Pr, Fr) | 0, xt = xt + Math.imul(Pr, Xr) | 0, xt = xt + Math.imul(Mr, Fr) | 0, Nt = Nt + Math.imul(Mr, Xr) | 0, kt = kt + Math.imul(Ir, fr) | 0, xt = xt + Math.imul(Ir, tr) | 0, xt = xt + Math.imul(wr, fr) | 0, Nt = Nt + Math.imul(wr, tr) | 0, kt = kt + Math.imul(Ar, jt) | 0, xt = xt + Math.imul(Ar, Ot) | 0, xt = xt + Math.imul(Sr, jt) | 0, Nt = Nt + Math.imul(Sr, Ot) | 0, kt = kt + Math.imul(Zt, Qt) | 0, xt = xt + Math.imul(Zt, or) | 0, xt = xt + Math.imul(pr, Qt) | 0, Nt = Nt + Math.imul(pr, or) | 0, kt = kt + Math.imul(sr, yr) | 0, xt = xt + Math.imul(sr, xr) | 0, xt = xt + Math.imul(dr, yr) | 0, Nt = Nt + Math.imul(dr, xr) | 0, kt = kt + Math.imul(nr, ir) | 0, xt = xt + Math.imul(nr, vr) | 0, xt = xt + Math.imul(Vt, ir) | 0, Nt = Nt + Math.imul(Vt, vr) | 0, kt = kt + Math.imul(Ht, $r) | 0, xt = xt + Math.imul(Ht, Ur) | 0, xt = xt + Math.imul(ar, $r) | 0, Nt = Nt + Math.imul(ar, Ur) | 0;
        var nn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, kt = Math.imul(Jt, gr), xt = Math.imul(Jt, Or), xt = xt + Math.imul(Dt, gr) | 0, Nt = Math.imul(Dt, Or), kt = kt + Math.imul(Nr, kr) | 0, xt = xt + Math.imul(Nr, jr) | 0, xt = xt + Math.imul(zr, kr) | 0, Nt = Nt + Math.imul(zr, jr) | 0, kt = kt + Math.imul(Tr, Fr) | 0, xt = xt + Math.imul(Tr, Xr) | 0, xt = xt + Math.imul(Hr, Fr) | 0, Nt = Nt + Math.imul(Hr, Xr) | 0, kt = kt + Math.imul(Pr, fr) | 0, xt = xt + Math.imul(Pr, tr) | 0, xt = xt + Math.imul(Mr, fr) | 0, Nt = Nt + Math.imul(Mr, tr) | 0, kt = kt + Math.imul(Ir, jt) | 0, xt = xt + Math.imul(Ir, Ot) | 0, xt = xt + Math.imul(wr, jt) | 0, Nt = Nt + Math.imul(wr, Ot) | 0, kt = kt + Math.imul(Ar, Qt) | 0, xt = xt + Math.imul(Ar, or) | 0, xt = xt + Math.imul(Sr, Qt) | 0, Nt = Nt + Math.imul(Sr, or) | 0, kt = kt + Math.imul(Zt, yr) | 0, xt = xt + Math.imul(Zt, xr) | 0, xt = xt + Math.imul(pr, yr) | 0, Nt = Nt + Math.imul(pr, xr) | 0, kt = kt + Math.imul(sr, ir) | 0, xt = xt + Math.imul(sr, vr) | 0, xt = xt + Math.imul(dr, ir) | 0, Nt = Nt + Math.imul(dr, vr) | 0, kt = kt + Math.imul(nr, $r) | 0, xt = xt + Math.imul(nr, Ur) | 0, xt = xt + Math.imul(Vt, $r) | 0, Nt = Nt + Math.imul(Vt, Ur) | 0;
        var fn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, kt = Math.imul(Jt, kr), xt = Math.imul(Jt, jr), xt = xt + Math.imul(Dt, kr) | 0, Nt = Math.imul(Dt, jr), kt = kt + Math.imul(Nr, Fr) | 0, xt = xt + Math.imul(Nr, Xr) | 0, xt = xt + Math.imul(zr, Fr) | 0, Nt = Nt + Math.imul(zr, Xr) | 0, kt = kt + Math.imul(Tr, fr) | 0, xt = xt + Math.imul(Tr, tr) | 0, xt = xt + Math.imul(Hr, fr) | 0, Nt = Nt + Math.imul(Hr, tr) | 0, kt = kt + Math.imul(Pr, jt) | 0, xt = xt + Math.imul(Pr, Ot) | 0, xt = xt + Math.imul(Mr, jt) | 0, Nt = Nt + Math.imul(Mr, Ot) | 0, kt = kt + Math.imul(Ir, Qt) | 0, xt = xt + Math.imul(Ir, or) | 0, xt = xt + Math.imul(wr, Qt) | 0, Nt = Nt + Math.imul(wr, or) | 0, kt = kt + Math.imul(Ar, yr) | 0, xt = xt + Math.imul(Ar, xr) | 0, xt = xt + Math.imul(Sr, yr) | 0, Nt = Nt + Math.imul(Sr, xr) | 0, kt = kt + Math.imul(Zt, ir) | 0, xt = xt + Math.imul(Zt, vr) | 0, xt = xt + Math.imul(pr, ir) | 0, Nt = Nt + Math.imul(pr, vr) | 0, kt = kt + Math.imul(sr, $r) | 0, xt = xt + Math.imul(sr, Ur) | 0, xt = xt + Math.imul(dr, $r) | 0, Nt = Nt + Math.imul(dr, Ur) | 0;
        var un = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, kt = Math.imul(Jt, Fr), xt = Math.imul(Jt, Xr), xt = xt + Math.imul(Dt, Fr) | 0, Nt = Math.imul(Dt, Xr), kt = kt + Math.imul(Nr, fr) | 0, xt = xt + Math.imul(Nr, tr) | 0, xt = xt + Math.imul(zr, fr) | 0, Nt = Nt + Math.imul(zr, tr) | 0, kt = kt + Math.imul(Tr, jt) | 0, xt = xt + Math.imul(Tr, Ot) | 0, xt = xt + Math.imul(Hr, jt) | 0, Nt = Nt + Math.imul(Hr, Ot) | 0, kt = kt + Math.imul(Pr, Qt) | 0, xt = xt + Math.imul(Pr, or) | 0, xt = xt + Math.imul(Mr, Qt) | 0, Nt = Nt + Math.imul(Mr, or) | 0, kt = kt + Math.imul(Ir, yr) | 0, xt = xt + Math.imul(Ir, xr) | 0, xt = xt + Math.imul(wr, yr) | 0, Nt = Nt + Math.imul(wr, xr) | 0, kt = kt + Math.imul(Ar, ir) | 0, xt = xt + Math.imul(Ar, vr) | 0, xt = xt + Math.imul(Sr, ir) | 0, Nt = Nt + Math.imul(Sr, vr) | 0, kt = kt + Math.imul(Zt, $r) | 0, xt = xt + Math.imul(Zt, Ur) | 0, xt = xt + Math.imul(pr, $r) | 0, Nt = Nt + Math.imul(pr, Ur) | 0;
        var cn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, kt = Math.imul(Jt, fr), xt = Math.imul(Jt, tr), xt = xt + Math.imul(Dt, fr) | 0, Nt = Math.imul(Dt, tr), kt = kt + Math.imul(Nr, jt) | 0, xt = xt + Math.imul(Nr, Ot) | 0, xt = xt + Math.imul(zr, jt) | 0, Nt = Nt + Math.imul(zr, Ot) | 0, kt = kt + Math.imul(Tr, Qt) | 0, xt = xt + Math.imul(Tr, or) | 0, xt = xt + Math.imul(Hr, Qt) | 0, Nt = Nt + Math.imul(Hr, or) | 0, kt = kt + Math.imul(Pr, yr) | 0, xt = xt + Math.imul(Pr, xr) | 0, xt = xt + Math.imul(Mr, yr) | 0, Nt = Nt + Math.imul(Mr, xr) | 0, kt = kt + Math.imul(Ir, ir) | 0, xt = xt + Math.imul(Ir, vr) | 0, xt = xt + Math.imul(wr, ir) | 0, Nt = Nt + Math.imul(wr, vr) | 0, kt = kt + Math.imul(Ar, $r) | 0, xt = xt + Math.imul(Ar, Ur) | 0, xt = xt + Math.imul(Sr, $r) | 0, Nt = Nt + Math.imul(Sr, Ur) | 0;
        var ln = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, kt = Math.imul(Jt, jt), xt = Math.imul(Jt, Ot), xt = xt + Math.imul(Dt, jt) | 0, Nt = Math.imul(Dt, Ot), kt = kt + Math.imul(Nr, Qt) | 0, xt = xt + Math.imul(Nr, or) | 0, xt = xt + Math.imul(zr, Qt) | 0, Nt = Nt + Math.imul(zr, or) | 0, kt = kt + Math.imul(Tr, yr) | 0, xt = xt + Math.imul(Tr, xr) | 0, xt = xt + Math.imul(Hr, yr) | 0, Nt = Nt + Math.imul(Hr, xr) | 0, kt = kt + Math.imul(Pr, ir) | 0, xt = xt + Math.imul(Pr, vr) | 0, xt = xt + Math.imul(Mr, ir) | 0, Nt = Nt + Math.imul(Mr, vr) | 0, kt = kt + Math.imul(Ir, $r) | 0, xt = xt + Math.imul(Ir, Ur) | 0, xt = xt + Math.imul(wr, $r) | 0, Nt = Nt + Math.imul(wr, Ur) | 0;
        var dn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, kt = Math.imul(Jt, Qt), xt = Math.imul(Jt, or), xt = xt + Math.imul(Dt, Qt) | 0, Nt = Math.imul(Dt, or), kt = kt + Math.imul(Nr, yr) | 0, xt = xt + Math.imul(Nr, xr) | 0, xt = xt + Math.imul(zr, yr) | 0, Nt = Nt + Math.imul(zr, xr) | 0, kt = kt + Math.imul(Tr, ir) | 0, xt = xt + Math.imul(Tr, vr) | 0, xt = xt + Math.imul(Hr, ir) | 0, Nt = Nt + Math.imul(Hr, vr) | 0, kt = kt + Math.imul(Pr, $r) | 0, xt = xt + Math.imul(Pr, Ur) | 0, xt = xt + Math.imul(Mr, $r) | 0, Nt = Nt + Math.imul(Mr, Ur) | 0;
        var hn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, kt = Math.imul(Jt, yr), xt = Math.imul(Jt, xr), xt = xt + Math.imul(Dt, yr) | 0, Nt = Math.imul(Dt, xr), kt = kt + Math.imul(Nr, ir) | 0, xt = xt + Math.imul(Nr, vr) | 0, xt = xt + Math.imul(zr, ir) | 0, Nt = Nt + Math.imul(zr, vr) | 0, kt = kt + Math.imul(Tr, $r) | 0, xt = xt + Math.imul(Tr, Ur) | 0, xt = xt + Math.imul(Hr, $r) | 0, Nt = Nt + Math.imul(Hr, Ur) | 0;
        var pn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, kt = Math.imul(Jt, ir), xt = Math.imul(Jt, vr), xt = xt + Math.imul(Dt, ir) | 0, Nt = Math.imul(Dt, vr), kt = kt + Math.imul(Nr, $r) | 0, xt = xt + Math.imul(Nr, Ur) | 0, xt = xt + Math.imul(zr, $r) | 0, Nt = Nt + Math.imul(zr, Ur) | 0;
        var yn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        $t = (Nt + (xt >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, kt = Math.imul(Jt, $r), xt = Math.imul(Jt, Ur), xt = xt + Math.imul(Dt, $r) | 0, Nt = Math.imul(Dt, Ur);
        var mn = ($t + kt | 0) + ((xt & 8191) << 13) | 0;
        return $t = (Nt + (xt >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, _t[0] = Dr, _t[1] = qr, _t[2] = Vr, _t[3] = tn, _t[4] = Qr, _t[5] = en, _t[6] = on, _t[7] = sn, _t[8] = an, _t[9] = nn, _t[10] = fn, _t[11] = un, _t[12] = cn, _t[13] = ln, _t[14] = dn, _t[15] = hn, _t[16] = pn, _t[17] = yn, _t[18] = mn, $t !== 0 && (_t[19] = $t, Ke.length++), Ke;
      };
      Math.imul || (ht = Xe);
      function wt(Ft, Ve, Je) {
        Je.negative = Ve.negative ^ Ft.negative, Je.length = Ft.length + Ve.length;
        for (var Ke = 0, Qe = 0, bt = 0; bt < Je.length - 1; bt++) {
          var _t = Qe;
          Qe = 0;
          for (var $t = Ke & 67108863, kt = Math.min(bt, Ve.length - 1), xt = Math.max(0, bt - Ft.length + 1); xt <= kt; xt++) {
            var Nt = bt - xt, Rt = Ft.words[Nt] | 0, Ht = Ve.words[xt] | 0, ar = Rt * Ht, lr = ar & 67108863;
            _t = _t + (ar / 67108864 | 0) | 0, lr = lr + $t | 0, $t = lr & 67108863, _t = _t + (lr >>> 26) | 0, Qe += _t >>> 26, _t &= 67108863;
          }
          Je.words[bt] = $t, Ke = _t, _t = Qe;
        }
        return Ke !== 0 ? Je.words[bt] = Ke : Je.length--, Je.strip();
      }
      function Pt(Ft, Ve, Je) {
        var Ke = new vt();
        return Ke.mulp(Ft, Ve, Je);
      }
      ie.prototype.mulTo = function(Ve, Je) {
        var Ke, Qe = this.length + Ve.length;
        return this.length === 10 && Ve.length === 10 ? Ke = ht(this, Ve, Je) : Qe < 63 ? Ke = Xe(this, Ve, Je) : Qe < 1024 ? Ke = wt(this, Ve, Je) : Ke = Pt(this, Ve, Je), Ke;
      };
      function vt(Ft, Ve) {
        this.x = Ft, this.y = Ve;
      }
      vt.prototype.makeRBT = function(Ve) {
        for (var Je = new Array(Ve), Ke = ie.prototype._countBits(Ve) - 1, Qe = 0; Qe < Ve; Qe++)
          Je[Qe] = this.revBin(Qe, Ke, Ve);
        return Je;
      }, vt.prototype.revBin = function(Ve, Je, Ke) {
        if (Ve === 0 || Ve === Ke - 1) return Ve;
        for (var Qe = 0, bt = 0; bt < Je; bt++)
          Qe |= (Ve & 1) << Je - bt - 1, Ve >>= 1;
        return Qe;
      }, vt.prototype.permute = function(Ve, Je, Ke, Qe, bt, _t) {
        for (var $t = 0; $t < _t; $t++)
          Qe[$t] = Je[Ve[$t]], bt[$t] = Ke[Ve[$t]];
      }, vt.prototype.transform = function(Ve, Je, Ke, Qe, bt, _t) {
        this.permute(_t, Ve, Je, Ke, Qe, bt);
        for (var $t = 1; $t < bt; $t <<= 1)
          for (var kt = $t << 1, xt = Math.cos(2 * Math.PI / kt), Nt = Math.sin(2 * Math.PI / kt), Rt = 0; Rt < bt; Rt += kt)
            for (var Ht = xt, ar = Nt, lr = 0; lr < $t; lr++) {
              var nr = Ke[Rt + lr], Vt = Qe[Rt + lr], Xt = Ke[Rt + lr + $t], sr = Qe[Rt + lr + $t], dr = Ht * Xt - ar * sr;
              sr = Ht * sr + ar * Xt, Xt = dr, Ke[Rt + lr] = nr + Xt, Qe[Rt + lr] = Vt + sr, Ke[Rt + lr + $t] = nr - Xt, Qe[Rt + lr + $t] = Vt - sr, lr !== kt && (dr = xt * Ht - Nt * ar, ar = xt * ar + Nt * Ht, Ht = dr);
            }
      }, vt.prototype.guessLen13b = function(Ve, Je) {
        var Ke = Math.max(Je, Ve) | 1, Qe = Ke & 1, bt = 0;
        for (Ke = Ke / 2 | 0; Ke; Ke = Ke >>> 1)
          bt++;
        return 1 << bt + 1 + Qe;
      }, vt.prototype.conjugate = function(Ve, Je, Ke) {
        if (!(Ke <= 1))
          for (var Qe = 0; Qe < Ke / 2; Qe++) {
            var bt = Ve[Qe];
            Ve[Qe] = Ve[Ke - Qe - 1], Ve[Ke - Qe - 1] = bt, bt = Je[Qe], Je[Qe] = -Je[Ke - Qe - 1], Je[Ke - Qe - 1] = -bt;
          }
      }, vt.prototype.normalize13b = function(Ve, Je) {
        for (var Ke = 0, Qe = 0; Qe < Je / 2; Qe++) {
          var bt = Math.round(Ve[2 * Qe + 1] / Je) * 8192 + Math.round(Ve[2 * Qe] / Je) + Ke;
          Ve[Qe] = bt & 67108863, bt < 67108864 ? Ke = 0 : Ke = bt / 67108864 | 0;
        }
        return Ve;
      }, vt.prototype.convert13b = function(Ve, Je, Ke, Qe) {
        for (var bt = 0, _t = 0; _t < Je; _t++)
          bt = bt + (Ve[_t] | 0), Ke[2 * _t] = bt & 8191, bt = bt >>> 13, Ke[2 * _t + 1] = bt & 8191, bt = bt >>> 13;
        for (_t = 2 * Je; _t < Qe; ++_t)
          Ke[_t] = 0;
        ne(bt === 0), ne((bt & -8192) === 0);
      }, vt.prototype.stub = function(Ve) {
        for (var Je = new Array(Ve), Ke = 0; Ke < Ve; Ke++)
          Je[Ke] = 0;
        return Je;
      }, vt.prototype.mulp = function(Ve, Je, Ke) {
        var Qe = 2 * this.guessLen13b(Ve.length, Je.length), bt = this.makeRBT(Qe), _t = this.stub(Qe), $t = new Array(Qe), kt = new Array(Qe), xt = new Array(Qe), Nt = new Array(Qe), Rt = new Array(Qe), Ht = new Array(Qe), ar = Ke.words;
        ar.length = Qe, this.convert13b(Ve.words, Ve.length, $t, Qe), this.convert13b(Je.words, Je.length, Nt, Qe), this.transform($t, _t, kt, xt, Qe, bt), this.transform(Nt, _t, Rt, Ht, Qe, bt);
        for (var lr = 0; lr < Qe; lr++) {
          var nr = kt[lr] * Rt[lr] - xt[lr] * Ht[lr];
          xt[lr] = kt[lr] * Ht[lr] + xt[lr] * Rt[lr], kt[lr] = nr;
        }
        return this.conjugate(kt, xt, Qe), this.transform(kt, xt, ar, _t, Qe, bt), this.conjugate(ar, _t, Qe), this.normalize13b(ar, Qe), Ke.negative = Ve.negative ^ Je.negative, Ke.length = Ve.length + Je.length, Ke.strip();
      }, ie.prototype.mul = function(Ve) {
        var Je = new ie(null);
        return Je.words = new Array(this.length + Ve.length), this.mulTo(Ve, Je);
      }, ie.prototype.mulf = function(Ve) {
        var Je = new ie(null);
        return Je.words = new Array(this.length + Ve.length), Pt(this, Ve, Je);
      }, ie.prototype.imul = function(Ve) {
        return this.clone().mulTo(Ve, this);
      }, ie.prototype.imuln = function(Ve) {
        ne(typeof Ve == "number"), ne(Ve < 67108864);
        for (var Je = 0, Ke = 0; Ke < this.length; Ke++) {
          var Qe = (this.words[Ke] | 0) * Ve, bt = (Qe & 67108863) + (Je & 67108863);
          Je >>= 26, Je += Qe / 67108864 | 0, Je += bt >>> 26, this.words[Ke] = bt & 67108863;
        }
        return Je !== 0 && (this.words[Ke] = Je, this.length++), this;
      }, ie.prototype.muln = function(Ve) {
        return this.clone().imuln(Ve);
      }, ie.prototype.sqr = function() {
        return this.mul(this);
      }, ie.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ie.prototype.pow = function(Ve) {
        var Je = Pe(Ve);
        if (Je.length === 0) return new ie(1);
        for (var Ke = this, Qe = 0; Qe < Je.length && Je[Qe] === 0; Qe++, Ke = Ke.sqr())
          ;
        if (++Qe < Je.length)
          for (var bt = Ke.sqr(); Qe < Je.length; Qe++, bt = bt.sqr())
            Je[Qe] !== 0 && (Ke = Ke.mul(bt));
        return Ke;
      }, ie.prototype.iushln = function(Ve) {
        ne(typeof Ve == "number" && Ve >= 0);
        var Je = Ve % 26, Ke = (Ve - Je) / 26, Qe = 67108863 >>> 26 - Je << 26 - Je, bt;
        if (Je !== 0) {
          var _t = 0;
          for (bt = 0; bt < this.length; bt++) {
            var $t = this.words[bt] & Qe, kt = (this.words[bt] | 0) - $t << Je;
            this.words[bt] = kt | _t, _t = $t >>> 26 - Je;
          }
          _t && (this.words[bt] = _t, this.length++);
        }
        if (Ke !== 0) {
          for (bt = this.length - 1; bt >= 0; bt--)
            this.words[bt + Ke] = this.words[bt];
          for (bt = 0; bt < Ke; bt++)
            this.words[bt] = 0;
          this.length += Ke;
        }
        return this.strip();
      }, ie.prototype.ishln = function(Ve) {
        return ne(this.negative === 0), this.iushln(Ve);
      }, ie.prototype.iushrn = function(Ve, Je, Ke) {
        ne(typeof Ve == "number" && Ve >= 0);
        var Qe;
        Je ? Qe = (Je - Je % 26) / 26 : Qe = 0;
        var bt = Ve % 26, _t = Math.min((Ve - bt) / 26, this.length), $t = 67108863 ^ 67108863 >>> bt << bt, kt = Ke;
        if (Qe -= _t, Qe = Math.max(0, Qe), kt) {
          for (var xt = 0; xt < _t; xt++)
            kt.words[xt] = this.words[xt];
          kt.length = _t;
        }
        if (_t !== 0) if (this.length > _t)
          for (this.length -= _t, xt = 0; xt < this.length; xt++)
            this.words[xt] = this.words[xt + _t];
        else
          this.words[0] = 0, this.length = 1;
        var Nt = 0;
        for (xt = this.length - 1; xt >= 0 && (Nt !== 0 || xt >= Qe); xt--) {
          var Rt = this.words[xt] | 0;
          this.words[xt] = Nt << 26 - bt | Rt >>> bt, Nt = Rt & $t;
        }
        return kt && Nt !== 0 && (kt.words[kt.length++] = Nt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, ie.prototype.ishrn = function(Ve, Je, Ke) {
        return ne(this.negative === 0), this.iushrn(Ve, Je, Ke);
      }, ie.prototype.shln = function(Ve) {
        return this.clone().ishln(Ve);
      }, ie.prototype.ushln = function(Ve) {
        return this.clone().iushln(Ve);
      }, ie.prototype.shrn = function(Ve) {
        return this.clone().ishrn(Ve);
      }, ie.prototype.ushrn = function(Ve) {
        return this.clone().iushrn(Ve);
      }, ie.prototype.testn = function(Ve) {
        ne(typeof Ve == "number" && Ve >= 0);
        var Je = Ve % 26, Ke = (Ve - Je) / 26, Qe = 1 << Je;
        if (this.length <= Ke) return !1;
        var bt = this.words[Ke];
        return !!(bt & Qe);
      }, ie.prototype.imaskn = function(Ve) {
        ne(typeof Ve == "number" && Ve >= 0);
        var Je = Ve % 26, Ke = (Ve - Je) / 26;
        if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Ke)
          return this;
        if (Je !== 0 && Ke++, this.length = Math.min(Ke, this.length), Je !== 0) {
          var Qe = 67108863 ^ 67108863 >>> Je << Je;
          this.words[this.length - 1] &= Qe;
        }
        return this.strip();
      }, ie.prototype.maskn = function(Ve) {
        return this.clone().imaskn(Ve);
      }, ie.prototype.iaddn = function(Ve) {
        return ne(typeof Ve == "number"), ne(Ve < 67108864), Ve < 0 ? this.isubn(-Ve) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < Ve ? (this.words[0] = Ve - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Ve), this.negative = 1, this) : this._iaddn(Ve);
      }, ie.prototype._iaddn = function(Ve) {
        this.words[0] += Ve;
        for (var Je = 0; Je < this.length && this.words[Je] >= 67108864; Je++)
          this.words[Je] -= 67108864, Je === this.length - 1 ? this.words[Je + 1] = 1 : this.words[Je + 1]++;
        return this.length = Math.max(this.length, Je + 1), this;
      }, ie.prototype.isubn = function(Ve) {
        if (ne(typeof Ve == "number"), ne(Ve < 67108864), Ve < 0) return this.iaddn(-Ve);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Ve), this.negative = 1, this;
        if (this.words[0] -= Ve, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Je = 0; Je < this.length && this.words[Je] < 0; Je++)
            this.words[Je] += 67108864, this.words[Je + 1] -= 1;
        return this.strip();
      }, ie.prototype.addn = function(Ve) {
        return this.clone().iaddn(Ve);
      }, ie.prototype.subn = function(Ve) {
        return this.clone().isubn(Ve);
      }, ie.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ie.prototype.abs = function() {
        return this.clone().iabs();
      }, ie.prototype._ishlnsubmul = function(Ve, Je, Ke) {
        var Qe = Ve.length + Ke, bt;
        this._expand(Qe);
        var _t, $t = 0;
        for (bt = 0; bt < Ve.length; bt++) {
          _t = (this.words[bt + Ke] | 0) + $t;
          var kt = (Ve.words[bt] | 0) * Je;
          _t -= kt & 67108863, $t = (_t >> 26) - (kt / 67108864 | 0), this.words[bt + Ke] = _t & 67108863;
        }
        for (; bt < this.length - Ke; bt++)
          _t = (this.words[bt + Ke] | 0) + $t, $t = _t >> 26, this.words[bt + Ke] = _t & 67108863;
        if ($t === 0) return this.strip();
        for (ne($t === -1), $t = 0, bt = 0; bt < this.length; bt++)
          _t = -(this.words[bt] | 0) + $t, $t = _t >> 26, this.words[bt] = _t & 67108863;
        return this.negative = 1, this.strip();
      }, ie.prototype._wordDiv = function(Ve, Je) {
        var Ke = this.length - Ve.length, Qe = this.clone(), bt = Ve, _t = bt.words[bt.length - 1] | 0, $t = this._countBits(_t);
        Ke = 26 - $t, Ke !== 0 && (bt = bt.ushln(Ke), Qe.iushln(Ke), _t = bt.words[bt.length - 1] | 0);
        var kt = Qe.length - bt.length, xt;
        if (Je !== "mod") {
          xt = new ie(null), xt.length = kt + 1, xt.words = new Array(xt.length);
          for (var Nt = 0; Nt < xt.length; Nt++)
            xt.words[Nt] = 0;
        }
        var Rt = Qe.clone()._ishlnsubmul(bt, 1, kt);
        Rt.negative === 0 && (Qe = Rt, xt && (xt.words[kt] = 1));
        for (var Ht = kt - 1; Ht >= 0; Ht--) {
          var ar = (Qe.words[bt.length + Ht] | 0) * 67108864 + (Qe.words[bt.length + Ht - 1] | 0);
          for (ar = Math.min(ar / _t | 0, 67108863), Qe._ishlnsubmul(bt, ar, Ht); Qe.negative !== 0; )
            ar--, Qe.negative = 0, Qe._ishlnsubmul(bt, 1, Ht), Qe.isZero() || (Qe.negative ^= 1);
          xt && (xt.words[Ht] = ar);
        }
        return xt && xt.strip(), Qe.strip(), Je !== "div" && Ke !== 0 && Qe.iushrn(Ke), {
          div: xt || null,
          mod: Qe
        };
      }, ie.prototype.divmod = function(Ve, Je, Ke) {
        if (ne(!Ve.isZero()), this.isZero())
          return {
            div: new ie(0),
            mod: new ie(0)
          };
        var Qe, bt, _t;
        return this.negative !== 0 && Ve.negative === 0 ? (_t = this.neg().divmod(Ve, Je), Je !== "mod" && (Qe = _t.div.neg()), Je !== "div" && (bt = _t.mod.neg(), Ke && bt.negative !== 0 && bt.iadd(Ve)), {
          div: Qe,
          mod: bt
        }) : this.negative === 0 && Ve.negative !== 0 ? (_t = this.divmod(Ve.neg(), Je), Je !== "mod" && (Qe = _t.div.neg()), {
          div: Qe,
          mod: _t.mod
        }) : this.negative & Ve.negative ? (_t = this.neg().divmod(Ve.neg(), Je), Je !== "div" && (bt = _t.mod.neg(), Ke && bt.negative !== 0 && bt.isub(Ve)), {
          div: _t.div,
          mod: bt
        }) : Ve.length > this.length || this.cmp(Ve) < 0 ? {
          div: new ie(0),
          mod: this
        } : Ve.length === 1 ? Je === "div" ? {
          div: this.divn(Ve.words[0]),
          mod: null
        } : Je === "mod" ? {
          div: null,
          mod: new ie(this.modn(Ve.words[0]))
        } : {
          div: this.divn(Ve.words[0]),
          mod: new ie(this.modn(Ve.words[0]))
        } : this._wordDiv(Ve, Je);
      }, ie.prototype.div = function(Ve) {
        return this.divmod(Ve, "div", !1).div;
      }, ie.prototype.mod = function(Ve) {
        return this.divmod(Ve, "mod", !1).mod;
      }, ie.prototype.umod = function(Ve) {
        return this.divmod(Ve, "mod", !0).mod;
      }, ie.prototype.divRound = function(Ve) {
        var Je = this.divmod(Ve);
        if (Je.mod.isZero()) return Je.div;
        var Ke = Je.div.negative !== 0 ? Je.mod.isub(Ve) : Je.mod, Qe = Ve.ushrn(1), bt = Ve.andln(1), _t = Ke.cmp(Qe);
        return _t < 0 || bt === 1 && _t === 0 ? Je.div : Je.div.negative !== 0 ? Je.div.isubn(1) : Je.div.iaddn(1);
      }, ie.prototype.modn = function(Ve) {
        ne(Ve <= 67108863);
        for (var Je = (1 << 26) % Ve, Ke = 0, Qe = this.length - 1; Qe >= 0; Qe--)
          Ke = (Je * Ke + (this.words[Qe] | 0)) % Ve;
        return Ke;
      }, ie.prototype.idivn = function(Ve) {
        ne(Ve <= 67108863);
        for (var Je = 0, Ke = this.length - 1; Ke >= 0; Ke--) {
          var Qe = (this.words[Ke] | 0) + Je * 67108864;
          this.words[Ke] = Qe / Ve | 0, Je = Qe % Ve;
        }
        return this.strip();
      }, ie.prototype.divn = function(Ve) {
        return this.clone().idivn(Ve);
      }, ie.prototype.egcd = function(Ve) {
        ne(Ve.negative === 0), ne(!Ve.isZero());
        var Je = this, Ke = Ve.clone();
        Je.negative !== 0 ? Je = Je.umod(Ve) : Je = Je.clone();
        for (var Qe = new ie(1), bt = new ie(0), _t = new ie(0), $t = new ie(1), kt = 0; Je.isEven() && Ke.isEven(); )
          Je.iushrn(1), Ke.iushrn(1), ++kt;
        for (var xt = Ke.clone(), Nt = Je.clone(); !Je.isZero(); ) {
          for (var Rt = 0, Ht = 1; !(Je.words[0] & Ht) && Rt < 26; ++Rt, Ht <<= 1) ;
          if (Rt > 0)
            for (Je.iushrn(Rt); Rt-- > 0; )
              (Qe.isOdd() || bt.isOdd()) && (Qe.iadd(xt), bt.isub(Nt)), Qe.iushrn(1), bt.iushrn(1);
          for (var ar = 0, lr = 1; !(Ke.words[0] & lr) && ar < 26; ++ar, lr <<= 1) ;
          if (ar > 0)
            for (Ke.iushrn(ar); ar-- > 0; )
              (_t.isOdd() || $t.isOdd()) && (_t.iadd(xt), $t.isub(Nt)), _t.iushrn(1), $t.iushrn(1);
          Je.cmp(Ke) >= 0 ? (Je.isub(Ke), Qe.isub(_t), bt.isub($t)) : (Ke.isub(Je), _t.isub(Qe), $t.isub(bt));
        }
        return {
          a: _t,
          b: $t,
          gcd: Ke.iushln(kt)
        };
      }, ie.prototype._invmp = function(Ve) {
        ne(Ve.negative === 0), ne(!Ve.isZero());
        var Je = this, Ke = Ve.clone();
        Je.negative !== 0 ? Je = Je.umod(Ve) : Je = Je.clone();
        for (var Qe = new ie(1), bt = new ie(0), _t = Ke.clone(); Je.cmpn(1) > 0 && Ke.cmpn(1) > 0; ) {
          for (var $t = 0, kt = 1; !(Je.words[0] & kt) && $t < 26; ++$t, kt <<= 1) ;
          if ($t > 0)
            for (Je.iushrn($t); $t-- > 0; )
              Qe.isOdd() && Qe.iadd(_t), Qe.iushrn(1);
          for (var xt = 0, Nt = 1; !(Ke.words[0] & Nt) && xt < 26; ++xt, Nt <<= 1) ;
          if (xt > 0)
            for (Ke.iushrn(xt); xt-- > 0; )
              bt.isOdd() && bt.iadd(_t), bt.iushrn(1);
          Je.cmp(Ke) >= 0 ? (Je.isub(Ke), Qe.isub(bt)) : (Ke.isub(Je), bt.isub(Qe));
        }
        var Rt;
        return Je.cmpn(1) === 0 ? Rt = Qe : Rt = bt, Rt.cmpn(0) < 0 && Rt.iadd(Ve), Rt;
      }, ie.prototype.gcd = function(Ve) {
        if (this.isZero()) return Ve.abs();
        if (Ve.isZero()) return this.abs();
        var Je = this.clone(), Ke = Ve.clone();
        Je.negative = 0, Ke.negative = 0;
        for (var Qe = 0; Je.isEven() && Ke.isEven(); Qe++)
          Je.iushrn(1), Ke.iushrn(1);
        do {
          for (; Je.isEven(); )
            Je.iushrn(1);
          for (; Ke.isEven(); )
            Ke.iushrn(1);
          var bt = Je.cmp(Ke);
          if (bt < 0) {
            var _t = Je;
            Je = Ke, Ke = _t;
          } else if (bt === 0 || Ke.cmpn(1) === 0)
            break;
          Je.isub(Ke);
        } while (!0);
        return Ke.iushln(Qe);
      }, ie.prototype.invm = function(Ve) {
        return this.egcd(Ve).a.umod(Ve);
      }, ie.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ie.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ie.prototype.andln = function(Ve) {
        return this.words[0] & Ve;
      }, ie.prototype.bincn = function(Ve) {
        ne(typeof Ve == "number");
        var Je = Ve % 26, Ke = (Ve - Je) / 26, Qe = 1 << Je;
        if (this.length <= Ke)
          return this._expand(Ke + 1), this.words[Ke] |= Qe, this;
        for (var bt = Qe, _t = Ke; bt !== 0 && _t < this.length; _t++) {
          var $t = this.words[_t] | 0;
          $t += bt, bt = $t >>> 26, $t &= 67108863, this.words[_t] = $t;
        }
        return bt !== 0 && (this.words[_t] = bt, this.length++), this;
      }, ie.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ie.prototype.cmpn = function(Ve) {
        var Je = Ve < 0;
        if (this.negative !== 0 && !Je) return -1;
        if (this.negative === 0 && Je) return 1;
        this.strip();
        var Ke;
        if (this.length > 1)
          Ke = 1;
        else {
          Je && (Ve = -Ve), ne(Ve <= 67108863, "Number is too big");
          var Qe = this.words[0] | 0;
          Ke = Qe === Ve ? 0 : Qe < Ve ? -1 : 1;
        }
        return this.negative !== 0 ? -Ke | 0 : Ke;
      }, ie.prototype.cmp = function(Ve) {
        if (this.negative !== 0 && Ve.negative === 0) return -1;
        if (this.negative === 0 && Ve.negative !== 0) return 1;
        var Je = this.ucmp(Ve);
        return this.negative !== 0 ? -Je | 0 : Je;
      }, ie.prototype.ucmp = function(Ve) {
        if (this.length > Ve.length) return 1;
        if (this.length < Ve.length) return -1;
        for (var Je = 0, Ke = this.length - 1; Ke >= 0; Ke--) {
          var Qe = this.words[Ke] | 0, bt = Ve.words[Ke] | 0;
          if (Qe !== bt) {
            Qe < bt ? Je = -1 : Qe > bt && (Je = 1);
            break;
          }
        }
        return Je;
      }, ie.prototype.gtn = function(Ve) {
        return this.cmpn(Ve) === 1;
      }, ie.prototype.gt = function(Ve) {
        return this.cmp(Ve) === 1;
      }, ie.prototype.gten = function(Ve) {
        return this.cmpn(Ve) >= 0;
      }, ie.prototype.gte = function(Ve) {
        return this.cmp(Ve) >= 0;
      }, ie.prototype.ltn = function(Ve) {
        return this.cmpn(Ve) === -1;
      }, ie.prototype.lt = function(Ve) {
        return this.cmp(Ve) === -1;
      }, ie.prototype.lten = function(Ve) {
        return this.cmpn(Ve) <= 0;
      }, ie.prototype.lte = function(Ve) {
        return this.cmp(Ve) <= 0;
      }, ie.prototype.eqn = function(Ve) {
        return this.cmpn(Ve) === 0;
      }, ie.prototype.eq = function(Ve) {
        return this.cmp(Ve) === 0;
      }, ie.red = function(Ve) {
        return new qt(Ve);
      }, ie.prototype.toRed = function(Ve) {
        return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), Ve.convertTo(this)._forceRed(Ve);
      }, ie.prototype.fromRed = function() {
        return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ie.prototype._forceRed = function(Ve) {
        return this.red = Ve, this;
      }, ie.prototype.forceRed = function(Ve) {
        return ne(!this.red, "Already a number in reduction context"), this._forceRed(Ve);
      }, ie.prototype.redAdd = function(Ve) {
        return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, Ve);
      }, ie.prototype.redIAdd = function(Ve) {
        return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Ve);
      }, ie.prototype.redSub = function(Ve) {
        return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, Ve);
      }, ie.prototype.redISub = function(Ve) {
        return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, Ve);
      }, ie.prototype.redShl = function(Ve) {
        return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, Ve);
      }, ie.prototype.redMul = function(Ve) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ve), this.red.mul(this, Ve);
      }, ie.prototype.redIMul = function(Ve) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ve), this.red.imul(this, Ve);
      }, ie.prototype.redSqr = function() {
        return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ie.prototype.redISqr = function() {
        return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ie.prototype.redSqrt = function() {
        return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ie.prototype.redInvm = function() {
        return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ie.prototype.redNeg = function() {
        return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ie.prototype.redPow = function(Ve) {
        return ne(this.red && !Ve.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Ve);
      };
      var Bt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Ct(Ft, Ve) {
        this.name = Ft, this.p = new ie(Ve, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ct.prototype._tmp = function() {
        var Ve = new ie(null);
        return Ve.words = new Array(Math.ceil(this.n / 13)), Ve;
      }, Ct.prototype.ireduce = function(Ve) {
        var Je = Ve, Ke;
        do
          this.split(Je, this.tmp), Je = this.imulK(Je), Je = Je.iadd(this.tmp), Ke = Je.bitLength();
        while (Ke > this.n);
        var Qe = Ke < this.n ? -1 : Je.ucmp(this.p);
        return Qe === 0 ? (Je.words[0] = 0, Je.length = 1) : Qe > 0 ? Je.isub(this.p) : Je.strip !== void 0 ? Je.strip() : Je._strip(), Je;
      }, Ct.prototype.split = function(Ve, Je) {
        Ve.iushrn(this.n, 0, Je);
      }, Ct.prototype.imulK = function(Ve) {
        return Ve.imul(this.k);
      };
      function Wt() {
        Ct.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      oe(Wt, Ct), Wt.prototype.split = function(Ve, Je) {
        for (var Ke = 4194303, Qe = Math.min(Ve.length, 9), bt = 0; bt < Qe; bt++)
          Je.words[bt] = Ve.words[bt];
        if (Je.length = Qe, Ve.length <= 9) {
          Ve.words[0] = 0, Ve.length = 1;
          return;
        }
        var _t = Ve.words[9];
        for (Je.words[Je.length++] = _t & Ke, bt = 10; bt < Ve.length; bt++) {
          var $t = Ve.words[bt] | 0;
          Ve.words[bt - 10] = ($t & Ke) << 4 | _t >>> 22, _t = $t;
        }
        _t >>>= 22, Ve.words[bt - 10] = _t, _t === 0 && Ve.length > 10 ? Ve.length -= 10 : Ve.length -= 9;
      }, Wt.prototype.imulK = function(Ve) {
        Ve.words[Ve.length] = 0, Ve.words[Ve.length + 1] = 0, Ve.length += 2;
        for (var Je = 0, Ke = 0; Ke < Ve.length; Ke++) {
          var Qe = Ve.words[Ke] | 0;
          Je += Qe * 977, Ve.words[Ke] = Je & 67108863, Je = Qe * 64 + (Je / 67108864 | 0);
        }
        return Ve.words[Ve.length - 1] === 0 && (Ve.length--, Ve.words[Ve.length - 1] === 0 && Ve.length--), Ve;
      };
      function Kt() {
        Ct.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      oe(Kt, Ct);
      function Yt() {
        Ct.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      oe(Yt, Ct);
      function Ut() {
        Ct.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      oe(Ut, Ct), Ut.prototype.imulK = function(Ve) {
        for (var Je = 0, Ke = 0; Ke < Ve.length; Ke++) {
          var Qe = (Ve.words[Ke] | 0) * 19 + Je, bt = Qe & 67108863;
          Qe >>>= 26, Ve.words[Ke] = bt, Je = Qe;
        }
        return Je !== 0 && (Ve.words[Ve.length++] = Je), Ve;
      }, ie._prime = function(Ve) {
        if (Bt[Ve]) return Bt[Ve];
        var Je;
        if (Ve === "k256")
          Je = new Wt();
        else if (Ve === "p224")
          Je = new Kt();
        else if (Ve === "p192")
          Je = new Yt();
        else if (Ve === "p25519")
          Je = new Ut();
        else
          throw new Error("Unknown prime " + Ve);
        return Bt[Ve] = Je, Je;
      };
      function qt(Ft) {
        if (typeof Ft == "string") {
          var Ve = ie._prime(Ft);
          this.m = Ve.p, this.prime = Ve;
        } else
          ne(Ft.gtn(1), "modulus must be greater than 1"), this.m = Ft, this.prime = null;
      }
      qt.prototype._verify1 = function(Ve) {
        ne(Ve.negative === 0, "red works only with positives"), ne(Ve.red, "red works only with red numbers");
      }, qt.prototype._verify2 = function(Ve, Je) {
        ne((Ve.negative | Je.negative) === 0, "red works only with positives"), ne(
          Ve.red && Ve.red === Je.red,
          "red works only with red numbers"
        );
      }, qt.prototype.imod = function(Ve) {
        return this.prime ? this.prime.ireduce(Ve)._forceRed(this) : Ve.umod(this.m)._forceRed(this);
      }, qt.prototype.neg = function(Ve) {
        return Ve.isZero() ? Ve.clone() : this.m.sub(Ve)._forceRed(this);
      }, qt.prototype.add = function(Ve, Je) {
        this._verify2(Ve, Je);
        var Ke = Ve.add(Je);
        return Ke.cmp(this.m) >= 0 && Ke.isub(this.m), Ke._forceRed(this);
      }, qt.prototype.iadd = function(Ve, Je) {
        this._verify2(Ve, Je);
        var Ke = Ve.iadd(Je);
        return Ke.cmp(this.m) >= 0 && Ke.isub(this.m), Ke;
      }, qt.prototype.sub = function(Ve, Je) {
        this._verify2(Ve, Je);
        var Ke = Ve.sub(Je);
        return Ke.cmpn(0) < 0 && Ke.iadd(this.m), Ke._forceRed(this);
      }, qt.prototype.isub = function(Ve, Je) {
        this._verify2(Ve, Je);
        var Ke = Ve.isub(Je);
        return Ke.cmpn(0) < 0 && Ke.iadd(this.m), Ke;
      }, qt.prototype.shl = function(Ve, Je) {
        return this._verify1(Ve), this.imod(Ve.ushln(Je));
      }, qt.prototype.imul = function(Ve, Je) {
        return this._verify2(Ve, Je), this.imod(Ve.imul(Je));
      }, qt.prototype.mul = function(Ve, Je) {
        return this._verify2(Ve, Je), this.imod(Ve.mul(Je));
      }, qt.prototype.isqr = function(Ve) {
        return this.imul(Ve, Ve.clone());
      }, qt.prototype.sqr = function(Ve) {
        return this.mul(Ve, Ve);
      }, qt.prototype.sqrt = function(Ve) {
        if (Ve.isZero()) return Ve.clone();
        var Je = this.m.andln(3);
        if (ne(Je % 2 === 1), Je === 3) {
          var Ke = this.m.add(new ie(1)).iushrn(2);
          return this.pow(Ve, Ke);
        }
        for (var Qe = this.m.subn(1), bt = 0; !Qe.isZero() && Qe.andln(1) === 0; )
          bt++, Qe.iushrn(1);
        ne(!Qe.isZero());
        var _t = new ie(1).toRed(this), $t = _t.redNeg(), kt = this.m.subn(1).iushrn(1), xt = this.m.bitLength();
        for (xt = new ie(2 * xt * xt).toRed(this); this.pow(xt, kt).cmp($t) !== 0; )
          xt.redIAdd($t);
        for (var Nt = this.pow(xt, Qe), Rt = this.pow(Ve, Qe.addn(1).iushrn(1)), Ht = this.pow(Ve, Qe), ar = bt; Ht.cmp(_t) !== 0; ) {
          for (var lr = Ht, nr = 0; lr.cmp(_t) !== 0; nr++)
            lr = lr.redSqr();
          ne(nr < ar);
          var Vt = this.pow(Nt, new ie(1).iushln(ar - nr - 1));
          Rt = Rt.redMul(Vt), Nt = Vt.redSqr(), Ht = Ht.redMul(Nt), ar = nr;
        }
        return Rt;
      }, qt.prototype.invm = function(Ve) {
        var Je = Ve._invmp(this.m);
        return Je.negative !== 0 ? (Je.negative = 0, this.imod(Je).redNeg()) : this.imod(Je);
      }, qt.prototype.pow = function(Ve, Je) {
        if (Je.isZero()) return new ie(1).toRed(this);
        if (Je.cmpn(1) === 0) return Ve.clone();
        var Ke = 4, Qe = new Array(1 << Ke);
        Qe[0] = new ie(1).toRed(this), Qe[1] = Ve;
        for (var bt = 2; bt < Qe.length; bt++)
          Qe[bt] = this.mul(Qe[bt - 1], Ve);
        var _t = Qe[0], $t = 0, kt = 0, xt = Je.bitLength() % 26;
        for (xt === 0 && (xt = 26), bt = Je.length - 1; bt >= 0; bt--) {
          for (var Nt = Je.words[bt], Rt = xt - 1; Rt >= 0; Rt--) {
            var Ht = Nt >> Rt & 1;
            if (_t !== Qe[0] && (_t = this.sqr(_t)), Ht === 0 && $t === 0) {
              kt = 0;
              continue;
            }
            $t <<= 1, $t |= Ht, kt++, !(kt !== Ke && (bt !== 0 || Rt !== 0)) && (_t = this.mul(_t, Qe[$t]), kt = 0, $t = 0);
          }
          xt = 26;
        }
        return _t;
      }, qt.prototype.convertTo = function(Ve) {
        var Je = Ve.umod(this.m);
        return Je === Ve ? Je.clone() : Je;
      }, qt.prototype.convertFrom = function(Ve) {
        var Je = Ve.clone();
        return Je.red = null, Je;
      }, ie.mont = function(Ve) {
        return new zt(Ve);
      };
      function zt(Ft) {
        qt.call(this, Ft), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      oe(zt, qt), zt.prototype.convertTo = function(Ve) {
        return this.imod(Ve.ushln(this.shift));
      }, zt.prototype.convertFrom = function(Ve) {
        var Je = this.imod(Ve.mul(this.rinv));
        return Je.red = null, Je;
      }, zt.prototype.imul = function(Ve, Je) {
        if (Ve.isZero() || Je.isZero())
          return Ve.words[0] = 0, Ve.length = 1, Ve;
        var Ke = Ve.imul(Je), Qe = Ke.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), bt = Ke.isub(Qe).iushrn(this.shift), _t = bt;
        return bt.cmp(this.m) >= 0 ? _t = bt.isub(this.m) : bt.cmpn(0) < 0 && (_t = bt.iadd(this.m)), _t._forceRed(this);
      }, zt.prototype.mul = function(Ve, Je) {
        if (Ve.isZero() || Je.isZero()) return new ie(0)._forceRed(this);
        var Ke = Ve.mul(Je), Qe = Ke.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), bt = Ke.isub(Qe).iushrn(this.shift), _t = bt;
        return bt.cmp(this.m) >= 0 ? _t = bt.isub(this.m) : bt.cmpn(0) < 0 && (_t = bt.iadd(this.m)), _t._forceRed(this);
      }, zt.prototype.invm = function(Ve) {
        var Je = this.imod(Ve._invmp(this.m).mul(this.r2));
        return Je._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(oe) {
    return B || (B = new z(null)), B.generate(oe);
  };
  function z(ne) {
    this.rand = ne;
  }
  if (brorand.exports.Rand = z, z.prototype.generate = function(oe) {
    return this._rand(oe);
  }, z.prototype._rand = function(oe) {
    if (this.rand.getBytes)
      return this.rand.getBytes(oe);
    for (var ie = new Uint8Array(oe), ae = 0; ae < ie.length; ae++)
      ie[ae] = this.rand.getByte();
    return ie;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? z.prototype._rand = function(oe) {
      var ie = new Uint8Array(oe);
      return self.crypto.getRandomValues(ie), ie;
    } : self.msCrypto && self.msCrypto.getRandomValues ? z.prototype._rand = function(oe) {
      var ie = new Uint8Array(oe);
      return self.msCrypto.getRandomValues(ie), ie;
    } : typeof window == "object" && (z.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Y = requireCryptoBrowserify();
      if (typeof Y.randomBytes != "function")
        throw new Error("Not supported");
      z.prototype._rand = function(oe) {
        return Y.randomBytes(oe);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = requireBn$1(), z = requireBrorand();
  function Y(ne) {
    this.rand = ne || new z.Rand();
  }
  return mr = Y, Y.create = function(oe) {
    return new Y(oe);
  }, Y.prototype._randbelow = function(oe) {
    var ie = oe.bitLength(), ae = Math.ceil(ie / 8);
    do
      var se = new B(this.rand.generate(ae));
    while (se.cmp(oe) >= 0);
    return se;
  }, Y.prototype._randrange = function(oe, ie) {
    var ae = ie.sub(oe);
    return oe.add(this._randbelow(ae));
  }, Y.prototype.test = function(oe, ie, ae) {
    var se = oe.bitLength(), ve = B.mont(oe), ge = new B(1).toRed(ve);
    ie || (ie = Math.max(1, se / 48 | 0));
    for (var le = oe.subn(1), Ee = 0; !le.testn(Ee); Ee++)
      ;
    for (var Ce = oe.shrn(Ee), Pe = le.toRed(ve), Xe = !0; ie > 0; ie--) {
      var ht = this._randrange(new B(2), le);
      ae && ae(ht);
      var wt = ht.toRed(ve).redPow(Ce);
      if (!(wt.cmp(ge) === 0 || wt.cmp(Pe) === 0)) {
        for (var Pt = 1; Pt < Ee; Pt++) {
          if (wt = wt.redSqr(), wt.cmp(ge) === 0)
            return !1;
          if (wt.cmp(Pe) === 0)
            break;
        }
        if (Pt === Ee)
          return !1;
      }
    }
    return Xe;
  }, Y.prototype.getDivisor = function(oe, ie) {
    var ae = oe.bitLength(), se = B.mont(oe), ve = new B(1).toRed(se);
    ie || (ie = Math.max(1, ae / 48 | 0));
    for (var ge = oe.subn(1), le = 0; !ge.testn(le); le++)
      ;
    for (var Ee = oe.shrn(le), Ce = ge.toRed(se); ie > 0; ie--) {
      var Pe = this._randrange(new B(2), ge), Xe = oe.gcd(Pe);
      if (Xe.cmpn(1) !== 0)
        return Xe;
      var ht = Pe.toRed(se).redPow(Ee);
      if (!(ht.cmp(ve) === 0 || ht.cmp(Ce) === 0)) {
        for (var wt = 1; wt < le; wt++) {
          if (ht = ht.redSqr(), ht.cmp(ve) === 0)
            return ht.fromRed().subn(1).gcd(oe);
          if (ht.cmp(Ce) === 0)
            break;
        }
        if (wt === le)
          return ht = ht.redSqr(), ht.fromRed().subn(1).gcd(oe);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = requireBrowser$b();
  generatePrime = wt, wt.simpleSieve = Xe, wt.fermatTest = ht;
  var z = requireBn$1(), Y = new z(24), ne = requireMr(), oe = new ne(), ie = new z(1), ae = new z(2), se = new z(5);
  new z(16), new z(8);
  var ve = new z(10), ge = new z(3);
  new z(7);
  var le = new z(11), Ee = new z(4);
  new z(12);
  var Ce = null;
  function Pe() {
    if (Ce !== null)
      return Ce;
    var Pt = 1048576, vt = [];
    vt[0] = 2;
    for (var Bt = 1, Ct = 3; Ct < Pt; Ct += 2) {
      for (var Wt = Math.ceil(Math.sqrt(Ct)), Kt = 0; Kt < Bt && vt[Kt] <= Wt && Ct % vt[Kt] !== 0; Kt++)
        ;
      Bt !== Kt && vt[Kt] <= Wt || (vt[Bt++] = Ct);
    }
    return Ce = vt, vt;
  }
  function Xe(Pt) {
    for (var vt = Pe(), Bt = 0; Bt < vt.length; Bt++)
      if (Pt.modn(vt[Bt]) === 0)
        return Pt.cmpn(vt[Bt]) === 0;
    return !0;
  }
  function ht(Pt) {
    var vt = z.mont(Pt);
    return ae.toRed(vt).redPow(Pt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function wt(Pt, vt) {
    if (Pt < 16)
      return vt === 2 || vt === 5 ? new z([140, 123]) : new z([140, 39]);
    vt = new z(vt);
    for (var Bt, Ct; ; ) {
      for (Bt = new z(B(Math.ceil(Pt / 8))); Bt.bitLength() > Pt; )
        Bt.ishrn(1);
      if (Bt.isEven() && Bt.iadd(ie), Bt.testn(1) || Bt.iadd(ae), vt.cmp(ae)) {
        if (!vt.cmp(se))
          for (; Bt.mod(ve).cmp(ge); )
            Bt.iadd(Ee);
      } else for (; Bt.mod(Y).cmp(le); )
        Bt.iadd(Ee);
      if (Ct = Bt.shrn(1), Xe(Ct) && Xe(Bt) && ht(Ct) && ht(Bt) && oe.test(Ct) && oe.test(Bt))
        return Bt;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = requireBn$1(), z = requireMr(), Y = new z(), ne = new B(24), oe = new B(11), ie = new B(10), ae = new B(3), se = new B(7), ve = requireGeneratePrime(), ge = requireBrowser$b();
  dh = Xe;
  function le(wt, Pt) {
    return Pt = Pt || "utf8", Buffer$1.isBuffer(wt) || (wt = new Buffer$1(wt, Pt)), this._pub = new B(wt), this;
  }
  function Ee(wt, Pt) {
    return Pt = Pt || "utf8", Buffer$1.isBuffer(wt) || (wt = new Buffer$1(wt, Pt)), this._priv = new B(wt), this;
  }
  var Ce = {};
  function Pe(wt, Pt) {
    var vt = Pt.toString("hex"), Bt = [vt, wt.toString(16)].join("_");
    if (Bt in Ce)
      return Ce[Bt];
    var Ct = 0;
    if (wt.isEven() || !ve.simpleSieve || !ve.fermatTest(wt) || !Y.test(wt))
      return Ct += 1, vt === "02" || vt === "05" ? Ct += 8 : Ct += 4, Ce[Bt] = Ct, Ct;
    Y.test(wt.shrn(1)) || (Ct += 2);
    var Wt;
    switch (vt) {
      case "02":
        wt.mod(ne).cmp(oe) && (Ct += 8);
        break;
      case "05":
        Wt = wt.mod(ie), Wt.cmp(ae) && Wt.cmp(se) && (Ct += 8);
        break;
      default:
        Ct += 4;
    }
    return Ce[Bt] = Ct, Ct;
  }
  function Xe(wt, Pt, vt) {
    this.setGenerator(Pt), this.__prime = new B(wt), this._prime = B.mont(this.__prime), this._primeLen = wt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, vt ? (this.setPublicKey = le, this.setPrivateKey = Ee) : this._primeCode = 8;
  }
  Object.defineProperty(Xe.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Pe(this.__prime, this.__gen)), this._primeCode;
    }
  }), Xe.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(ge(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, Xe.prototype.computeSecret = function(wt) {
    wt = new B(wt), wt = wt.toRed(this._prime);
    var Pt = wt.redPow(this._priv).fromRed(), vt = new Buffer$1(Pt.toArray()), Bt = this.getPrime();
    if (vt.length < Bt.length) {
      var Ct = new Buffer$1(Bt.length - vt.length);
      Ct.fill(0), vt = Buffer$1.concat([Ct, vt]);
    }
    return vt;
  }, Xe.prototype.getPublicKey = function(Pt) {
    return ht(this._pub, Pt);
  }, Xe.prototype.getPrivateKey = function(Pt) {
    return ht(this._priv, Pt);
  }, Xe.prototype.getPrime = function(wt) {
    return ht(this.__prime, wt);
  }, Xe.prototype.getGenerator = function(wt) {
    return ht(this._gen, wt);
  }, Xe.prototype.setGenerator = function(wt, Pt) {
    return Pt = Pt || "utf8", Buffer$1.isBuffer(wt) || (wt = new Buffer$1(wt, Pt)), this.__gen = wt, this._gen = new B(wt), this;
  };
  function ht(wt, Pt) {
    var vt = new Buffer$1(wt.toArray());
    return Pt ? vt.toString(Pt) : vt;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var B = requireGeneratePrime(), z = require$$1$1, Y = requireDh();
  function ne(ae) {
    var se = new Buffer$1(z[ae].prime, "hex"), ve = new Buffer$1(z[ae].gen, "hex");
    return new Y(se, ve);
  }
  var oe = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function ie(ae, se, ve, ge) {
    return Buffer$1.isBuffer(se) || oe[se] === void 0 ? ie(ae, "binary", se, ve) : (se = se || "binary", ge = ge || "binary", ve = ve || new Buffer$1([2]), Buffer$1.isBuffer(ve) || (ve = new Buffer$1(ve, ge)), typeof ae == "number" ? new Y(B(ae, ve), ve, !0) : (Buffer$1.isBuffer(ae) || (ae = new Buffer$1(ae, se)), new Y(ae, ve, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ne, browser$4.createDiffieHellman = browser$4.DiffieHellman = ie, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: B } : processNextickArgs.exports = process$1;
  function B(z, Y, ne, oe) {
    if (typeof z != "function")
      throw new TypeError('"callback" argument must be a function');
    var ie = arguments.length, ae, se;
    switch (ie) {
      case 0:
      case 1:
        return process$1.nextTick(z);
      case 2:
        return process$1.nextTick(function() {
          z.call(null, Y);
        });
      case 3:
        return process$1.nextTick(function() {
          z.call(null, Y, ne);
        });
      case 4:
        return process$1.nextTick(function() {
          z.call(null, Y, ne, oe);
        });
      default:
        for (ae = new Array(ie - 1), se = 0; se < ae.length; )
          ae[se++] = arguments[se];
        return process$1.nextTick(function() {
          z.apply(null, ae);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var B = {}.toString;
  return isarray = Array.isArray || function(z) {
    return B.call(z) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(B, z) {
    var Y = dist$1, ne = Y.Buffer;
    function oe(ae, se) {
      for (var ve in ae)
        se[ve] = ae[ve];
    }
    ne.from && ne.alloc && ne.allocUnsafe && ne.allocUnsafeSlow ? B.exports = Y : (oe(Y, z), z.Buffer = ie);
    function ie(ae, se, ve) {
      return ne(ae, se, ve);
    }
    oe(ne, ie), ie.from = function(ae, se, ve) {
      if (typeof ae == "number")
        throw new TypeError("Argument must not be a number");
      return ne(ae, se, ve);
    }, ie.alloc = function(ae, se, ve) {
      if (typeof ae != "number")
        throw new TypeError("Argument must be a number");
      var ge = ne(ae);
      return se !== void 0 ? typeof ve == "string" ? ge.fill(se, ve) : ge.fill(se) : ge.fill(0), ge;
    }, ie.allocUnsafe = function(ae) {
      if (typeof ae != "number")
        throw new TypeError("Argument must be a number");
      return ne(ae);
    }, ie.allocUnsafeSlow = function(ae) {
      if (typeof ae != "number")
        throw new TypeError("Argument must be a number");
      return Y.SlowBuffer(ae);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function B(ht) {
    return Array.isArray ? Array.isArray(ht) : Xe(ht) === "[object Array]";
  }
  util.isArray = B;
  function z(ht) {
    return typeof ht == "boolean";
  }
  util.isBoolean = z;
  function Y(ht) {
    return ht === null;
  }
  util.isNull = Y;
  function ne(ht) {
    return ht == null;
  }
  util.isNullOrUndefined = ne;
  function oe(ht) {
    return typeof ht == "number";
  }
  util.isNumber = oe;
  function ie(ht) {
    return typeof ht == "string";
  }
  util.isString = ie;
  function ae(ht) {
    return typeof ht == "symbol";
  }
  util.isSymbol = ae;
  function se(ht) {
    return ht === void 0;
  }
  util.isUndefined = se;
  function ve(ht) {
    return Xe(ht) === "[object RegExp]";
  }
  util.isRegExp = ve;
  function ge(ht) {
    return typeof ht == "object" && ht !== null;
  }
  util.isObject = ge;
  function le(ht) {
    return Xe(ht) === "[object Date]";
  }
  util.isDate = le;
  function Ee(ht) {
    return Xe(ht) === "[object Error]" || ht instanceof Error;
  }
  util.isError = Ee;
  function Ce(ht) {
    return typeof ht == "function";
  }
  util.isFunction = Ce;
  function Pe(ht) {
    return ht === null || typeof ht == "boolean" || typeof ht == "number" || typeof ht == "string" || typeof ht == "symbol" || // ES6 symbol
    typeof ht > "u";
  }
  util.isPrimitive = Pe, util.isBuffer = dist$1.Buffer.isBuffer;
  function Xe(ht) {
    return Object.prototype.toString.call(ht);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function z(ie, ae) {
      if (!(ie instanceof ae))
        throw new TypeError("Cannot call a class as a function");
    }
    var Y = requireSafeBuffer().Buffer, ne = requireUtil$1();
    function oe(ie, ae, se) {
      ie.copy(ae, se);
    }
    B.exports = function() {
      function ie() {
        z(this, ie), this.head = null, this.tail = null, this.length = 0;
      }
      return ie.prototype.push = function(se) {
        var ve = { data: se, next: null };
        this.length > 0 ? this.tail.next = ve : this.head = ve, this.tail = ve, ++this.length;
      }, ie.prototype.unshift = function(se) {
        var ve = { data: se, next: this.head };
        this.length === 0 && (this.tail = ve), this.head = ve, ++this.length;
      }, ie.prototype.shift = function() {
        if (this.length !== 0) {
          var se = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, se;
        }
      }, ie.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, ie.prototype.join = function(se) {
        if (this.length === 0) return "";
        for (var ve = this.head, ge = "" + ve.data; ve = ve.next; )
          ge += se + ve.data;
        return ge;
      }, ie.prototype.concat = function(se) {
        if (this.length === 0) return Y.alloc(0);
        for (var ve = Y.allocUnsafe(se >>> 0), ge = this.head, le = 0; ge; )
          oe(ge.data, ve, le), le += ge.data.length, ge = ge.next;
        return ve;
      }, ie;
    }(), ne && ne.inspect && ne.inspect.custom && (B.exports.prototype[ne.inspect.custom] = function() {
      var ie = ne.inspect({ length: this.length });
      return this.constructor.name + " " + ie;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var B = requireProcessNextickArgs();
  function z(oe, ie) {
    var ae = this, se = this._readableState && this._readableState.destroyed, ve = this._writableState && this._writableState.destroyed;
    return se || ve ? (ie ? ie(oe) : oe && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, B.nextTick(ne, this, oe)) : B.nextTick(ne, this, oe)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(oe || null, function(ge) {
      !ie && ge ? ae._writableState ? ae._writableState.errorEmitted || (ae._writableState.errorEmitted = !0, B.nextTick(ne, ae, ge)) : B.nextTick(ne, ae, ge) : ie && ie(ge);
    }), this);
  }
  function Y() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function ne(oe, ie) {
    oe.emit("error", ie);
  }
  return destroy_1 = {
    destroy: z,
    undestroy: Y
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = requireProcessNextickArgs();
  _stream_writable = ht;
  function z(_t) {
    var $t = this;
    this.next = null, this.entry = null, this.finish = function() {
      bt($t, _t);
    };
  }
  var Y = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, ne;
  ht.WritableState = Pe;
  var oe = Object.create(requireUtil());
  oe.inherits = requireInherits_browser();
  var ie = {
    deprecate: requireBrowser$a()
  }, ae = requireStreamBrowser(), se = requireSafeBuffer().Buffer, ve = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ge(_t) {
    return se.from(_t);
  }
  function le(_t) {
    return se.isBuffer(_t) || _t instanceof ve;
  }
  var Ee = requireDestroy();
  oe.inherits(ht, ae);
  function Ce() {
  }
  function Pe(_t, $t) {
    ne = ne || require_stream_duplex(), _t = _t || {};
    var kt = $t instanceof ne;
    this.objectMode = !!_t.objectMode, kt && (this.objectMode = this.objectMode || !!_t.writableObjectMode);
    var xt = _t.highWaterMark, Nt = _t.writableHighWaterMark, Rt = this.objectMode ? 16 : 16 * 1024;
    xt || xt === 0 ? this.highWaterMark = xt : kt && (Nt || Nt === 0) ? this.highWaterMark = Nt : this.highWaterMark = Rt, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ht = _t.decodeStrings === !1;
    this.decodeStrings = !Ht, this.defaultEncoding = _t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ar) {
      Yt($t, ar);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new z(this);
  }
  Pe.prototype.getBuffer = function() {
    for (var $t = this.bufferedRequest, kt = []; $t; )
      kt.push($t), $t = $t.next;
    return kt;
  }, function() {
    try {
      Object.defineProperty(Pe.prototype, "buffer", {
        get: ie.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Xe;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Xe = Function.prototype[Symbol.hasInstance], Object.defineProperty(ht, Symbol.hasInstance, {
    value: function(_t) {
      return Xe.call(this, _t) ? !0 : this !== ht ? !1 : _t && _t._writableState instanceof Pe;
    }
  })) : Xe = function(_t) {
    return _t instanceof this;
  };
  function ht(_t) {
    if (ne = ne || require_stream_duplex(), !Xe.call(ht, this) && !(this instanceof ne))
      return new ht(_t);
    this._writableState = new Pe(_t, this), this.writable = !0, _t && (typeof _t.write == "function" && (this._write = _t.write), typeof _t.writev == "function" && (this._writev = _t.writev), typeof _t.destroy == "function" && (this._destroy = _t.destroy), typeof _t.final == "function" && (this._final = _t.final)), ae.call(this);
  }
  ht.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function wt(_t, $t) {
    var kt = new Error("write after end");
    _t.emit("error", kt), B.nextTick($t, kt);
  }
  function Pt(_t, $t, kt, xt) {
    var Nt = !0, Rt = !1;
    return kt === null ? Rt = new TypeError("May not write null values to stream") : typeof kt != "string" && kt !== void 0 && !$t.objectMode && (Rt = new TypeError("Invalid non-string/buffer chunk")), Rt && (_t.emit("error", Rt), B.nextTick(xt, Rt), Nt = !1), Nt;
  }
  ht.prototype.write = function(_t, $t, kt) {
    var xt = this._writableState, Nt = !1, Rt = !xt.objectMode && le(_t);
    return Rt && !se.isBuffer(_t) && (_t = ge(_t)), typeof $t == "function" && (kt = $t, $t = null), Rt ? $t = "buffer" : $t || ($t = xt.defaultEncoding), typeof kt != "function" && (kt = Ce), xt.ended ? wt(this, kt) : (Rt || Pt(this, xt, _t, kt)) && (xt.pendingcb++, Nt = Bt(this, xt, Rt, _t, $t, kt)), Nt;
  }, ht.prototype.cork = function() {
    var _t = this._writableState;
    _t.corked++;
  }, ht.prototype.uncork = function() {
    var _t = this._writableState;
    _t.corked && (_t.corked--, !_t.writing && !_t.corked && !_t.bufferProcessing && _t.bufferedRequest && zt(this, _t));
  }, ht.prototype.setDefaultEncoding = function($t) {
    if (typeof $t == "string" && ($t = $t.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf(($t + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + $t);
    return this._writableState.defaultEncoding = $t, this;
  };
  function vt(_t, $t, kt) {
    return !_t.objectMode && _t.decodeStrings !== !1 && typeof $t == "string" && ($t = se.from($t, kt)), $t;
  }
  Object.defineProperty(ht.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Bt(_t, $t, kt, xt, Nt, Rt) {
    if (!kt) {
      var Ht = vt($t, xt, Nt);
      xt !== Ht && (kt = !0, Nt = "buffer", xt = Ht);
    }
    var ar = $t.objectMode ? 1 : xt.length;
    $t.length += ar;
    var lr = $t.length < $t.highWaterMark;
    if (lr || ($t.needDrain = !0), $t.writing || $t.corked) {
      var nr = $t.lastBufferedRequest;
      $t.lastBufferedRequest = {
        chunk: xt,
        encoding: Nt,
        isBuf: kt,
        callback: Rt,
        next: null
      }, nr ? nr.next = $t.lastBufferedRequest : $t.bufferedRequest = $t.lastBufferedRequest, $t.bufferedRequestCount += 1;
    } else
      Ct(_t, $t, !1, ar, xt, Nt, Rt);
    return lr;
  }
  function Ct(_t, $t, kt, xt, Nt, Rt, Ht) {
    $t.writelen = xt, $t.writecb = Ht, $t.writing = !0, $t.sync = !0, kt ? _t._writev(Nt, $t.onwrite) : _t._write(Nt, Rt, $t.onwrite), $t.sync = !1;
  }
  function Wt(_t, $t, kt, xt, Nt) {
    --$t.pendingcb, kt ? (B.nextTick(Nt, xt), B.nextTick(Ke, _t, $t), _t._writableState.errorEmitted = !0, _t.emit("error", xt)) : (Nt(xt), _t._writableState.errorEmitted = !0, _t.emit("error", xt), Ke(_t, $t));
  }
  function Kt(_t) {
    _t.writing = !1, _t.writecb = null, _t.length -= _t.writelen, _t.writelen = 0;
  }
  function Yt(_t, $t) {
    var kt = _t._writableState, xt = kt.sync, Nt = kt.writecb;
    if (Kt(kt), $t) Wt(_t, kt, xt, $t, Nt);
    else {
      var Rt = Ft(kt);
      !Rt && !kt.corked && !kt.bufferProcessing && kt.bufferedRequest && zt(_t, kt), xt ? Y(Ut, _t, kt, Rt, Nt) : Ut(_t, kt, Rt, Nt);
    }
  }
  function Ut(_t, $t, kt, xt) {
    kt || qt(_t, $t), $t.pendingcb--, xt(), Ke(_t, $t);
  }
  function qt(_t, $t) {
    $t.length === 0 && $t.needDrain && ($t.needDrain = !1, _t.emit("drain"));
  }
  function zt(_t, $t) {
    $t.bufferProcessing = !0;
    var kt = $t.bufferedRequest;
    if (_t._writev && kt && kt.next) {
      var xt = $t.bufferedRequestCount, Nt = new Array(xt), Rt = $t.corkedRequestsFree;
      Rt.entry = kt;
      for (var Ht = 0, ar = !0; kt; )
        Nt[Ht] = kt, kt.isBuf || (ar = !1), kt = kt.next, Ht += 1;
      Nt.allBuffers = ar, Ct(_t, $t, !0, $t.length, Nt, "", Rt.finish), $t.pendingcb++, $t.lastBufferedRequest = null, Rt.next ? ($t.corkedRequestsFree = Rt.next, Rt.next = null) : $t.corkedRequestsFree = new z($t), $t.bufferedRequestCount = 0;
    } else {
      for (; kt; ) {
        var lr = kt.chunk, nr = kt.encoding, Vt = kt.callback, Xt = $t.objectMode ? 1 : lr.length;
        if (Ct(_t, $t, !1, Xt, lr, nr, Vt), kt = kt.next, $t.bufferedRequestCount--, $t.writing)
          break;
      }
      kt === null && ($t.lastBufferedRequest = null);
    }
    $t.bufferedRequest = kt, $t.bufferProcessing = !1;
  }
  ht.prototype._write = function(_t, $t, kt) {
    kt(new Error("_write() is not implemented"));
  }, ht.prototype._writev = null, ht.prototype.end = function(_t, $t, kt) {
    var xt = this._writableState;
    typeof _t == "function" ? (kt = _t, _t = null, $t = null) : typeof $t == "function" && (kt = $t, $t = null), _t != null && this.write(_t, $t), xt.corked && (xt.corked = 1, this.uncork()), xt.ending || Qe(this, xt, kt);
  };
  function Ft(_t) {
    return _t.ending && _t.length === 0 && _t.bufferedRequest === null && !_t.finished && !_t.writing;
  }
  function Ve(_t, $t) {
    _t._final(function(kt) {
      $t.pendingcb--, kt && _t.emit("error", kt), $t.prefinished = !0, _t.emit("prefinish"), Ke(_t, $t);
    });
  }
  function Je(_t, $t) {
    !$t.prefinished && !$t.finalCalled && (typeof _t._final == "function" ? ($t.pendingcb++, $t.finalCalled = !0, B.nextTick(Ve, _t, $t)) : ($t.prefinished = !0, _t.emit("prefinish")));
  }
  function Ke(_t, $t) {
    var kt = Ft($t);
    return kt && (Je(_t, $t), $t.pendingcb === 0 && ($t.finished = !0, _t.emit("finish"))), kt;
  }
  function Qe(_t, $t, kt) {
    $t.ending = !0, Ke(_t, $t), kt && ($t.finished ? B.nextTick(kt) : _t.once("finish", kt)), $t.ended = !0, _t.writable = !1;
  }
  function bt(_t, $t, kt) {
    var xt = _t.entry;
    for (_t.entry = null; xt; ) {
      var Nt = xt.callback;
      $t.pendingcb--, Nt(kt), xt = xt.next;
    }
    $t.corkedRequestsFree.next = _t;
  }
  return Object.defineProperty(ht.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(_t) {
      this._writableState && (this._writableState.destroyed = _t);
    }
  }), ht.prototype.destroy = Ee.destroy, ht.prototype._undestroy = Ee.undestroy, ht.prototype._destroy = function(_t, $t) {
    this.end(), $t(_t);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = requireProcessNextickArgs(), z = Object.keys || function(Ee) {
    var Ce = [];
    for (var Pe in Ee)
      Ce.push(Pe);
    return Ce;
  };
  _stream_duplex = ve;
  var Y = Object.create(requireUtil());
  Y.inherits = requireInherits_browser();
  var ne = require_stream_readable(), oe = require_stream_writable();
  Y.inherits(ve, ne);
  for (var ie = z(oe.prototype), ae = 0; ae < ie.length; ae++) {
    var se = ie[ae];
    ve.prototype[se] || (ve.prototype[se] = oe.prototype[se]);
  }
  function ve(Ee) {
    if (!(this instanceof ve)) return new ve(Ee);
    ne.call(this, Ee), oe.call(this, Ee), Ee && Ee.readable === !1 && (this.readable = !1), Ee && Ee.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Ee && Ee.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", ge);
  }
  Object.defineProperty(ve.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ge() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(le, this);
  }
  function le(Ee) {
    Ee.end();
  }
  return Object.defineProperty(ve.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Ee) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Ee, this._writableState.destroyed = Ee);
    }
  }), ve.prototype._destroy = function(Ee, Ce) {
    this.push(null), this.end(), B.nextTick(Ce, Ee);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = requireProcessNextickArgs();
  _stream_readable = vt;
  var z = requireIsarray(), Y;
  vt.ReadableState = Pt, requireEvents().EventEmitter;
  var ne = function(Vt, Xt) {
    return Vt.listeners(Xt).length;
  }, oe = requireStreamBrowser(), ie = requireSafeBuffer().Buffer, ae = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function se(Vt) {
    return ie.from(Vt);
  }
  function ve(Vt) {
    return ie.isBuffer(Vt) || Vt instanceof ae;
  }
  var ge = Object.create(requireUtil());
  ge.inherits = requireInherits_browser();
  var le = requireUtil$1(), Ee = void 0;
  le && le.debuglog ? Ee = le.debuglog("stream") : Ee = function() {
  };
  var Ce = requireBufferList(), Pe = requireDestroy(), Xe;
  ge.inherits(vt, oe);
  var ht = ["error", "close", "destroy", "pause", "resume"];
  function wt(Vt, Xt, sr) {
    if (typeof Vt.prependListener == "function") return Vt.prependListener(Xt, sr);
    !Vt._events || !Vt._events[Xt] ? Vt.on(Xt, sr) : z(Vt._events[Xt]) ? Vt._events[Xt].unshift(sr) : Vt._events[Xt] = [sr, Vt._events[Xt]];
  }
  function Pt(Vt, Xt) {
    Y = Y || require_stream_duplex(), Vt = Vt || {};
    var sr = Xt instanceof Y;
    this.objectMode = !!Vt.objectMode, sr && (this.objectMode = this.objectMode || !!Vt.readableObjectMode);
    var dr = Vt.highWaterMark, er = Vt.readableHighWaterMark, Zt = this.objectMode ? 16 : 16 * 1024;
    dr || dr === 0 ? this.highWaterMark = dr : sr && (er || er === 0) ? this.highWaterMark = er : this.highWaterMark = Zt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Ce(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Vt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Vt.encoding && (Xe || (Xe = requireString_decoder().StringDecoder), this.decoder = new Xe(Vt.encoding), this.encoding = Vt.encoding);
  }
  function vt(Vt) {
    if (Y = Y || require_stream_duplex(), !(this instanceof vt)) return new vt(Vt);
    this._readableState = new Pt(Vt, this), this.readable = !0, Vt && (typeof Vt.read == "function" && (this._read = Vt.read), typeof Vt.destroy == "function" && (this._destroy = Vt.destroy)), oe.call(this);
  }
  Object.defineProperty(vt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Vt) {
      this._readableState && (this._readableState.destroyed = Vt);
    }
  }), vt.prototype.destroy = Pe.destroy, vt.prototype._undestroy = Pe.undestroy, vt.prototype._destroy = function(Vt, Xt) {
    this.push(null), Xt(Vt);
  }, vt.prototype.push = function(Vt, Xt) {
    var sr = this._readableState, dr;
    return sr.objectMode ? dr = !0 : typeof Vt == "string" && (Xt = Xt || sr.defaultEncoding, Xt !== sr.encoding && (Vt = ie.from(Vt, Xt), Xt = ""), dr = !0), Bt(this, Vt, Xt, !1, dr);
  }, vt.prototype.unshift = function(Vt) {
    return Bt(this, Vt, null, !0, !1);
  };
  function Bt(Vt, Xt, sr, dr, er) {
    var Zt = Vt._readableState;
    if (Xt === null)
      Zt.reading = !1, zt(Vt, Zt);
    else {
      var pr;
      er || (pr = Wt(Zt, Xt)), pr ? Vt.emit("error", pr) : Zt.objectMode || Xt && Xt.length > 0 ? (typeof Xt != "string" && !Zt.objectMode && Object.getPrototypeOf(Xt) !== ie.prototype && (Xt = se(Xt)), dr ? Zt.endEmitted ? Vt.emit("error", new Error("stream.unshift() after end event")) : Ct(Vt, Zt, Xt, !0) : Zt.ended ? Vt.emit("error", new Error("stream.push() after EOF")) : (Zt.reading = !1, Zt.decoder && !sr ? (Xt = Zt.decoder.write(Xt), Zt.objectMode || Xt.length !== 0 ? Ct(Vt, Zt, Xt, !1) : Je(Vt, Zt)) : Ct(Vt, Zt, Xt, !1))) : dr || (Zt.reading = !1);
    }
    return Kt(Zt);
  }
  function Ct(Vt, Xt, sr, dr) {
    Xt.flowing && Xt.length === 0 && !Xt.sync ? (Vt.emit("data", sr), Vt.read(0)) : (Xt.length += Xt.objectMode ? 1 : sr.length, dr ? Xt.buffer.unshift(sr) : Xt.buffer.push(sr), Xt.needReadable && Ft(Vt)), Je(Vt, Xt);
  }
  function Wt(Vt, Xt) {
    var sr;
    return !ve(Xt) && typeof Xt != "string" && Xt !== void 0 && !Vt.objectMode && (sr = new TypeError("Invalid non-string/buffer chunk")), sr;
  }
  function Kt(Vt) {
    return !Vt.ended && (Vt.needReadable || Vt.length < Vt.highWaterMark || Vt.length === 0);
  }
  vt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, vt.prototype.setEncoding = function(Vt) {
    return Xe || (Xe = requireString_decoder().StringDecoder), this._readableState.decoder = new Xe(Vt), this._readableState.encoding = Vt, this;
  };
  var Yt = 8388608;
  function Ut(Vt) {
    return Vt >= Yt ? Vt = Yt : (Vt--, Vt |= Vt >>> 1, Vt |= Vt >>> 2, Vt |= Vt >>> 4, Vt |= Vt >>> 8, Vt |= Vt >>> 16, Vt++), Vt;
  }
  function qt(Vt, Xt) {
    return Vt <= 0 || Xt.length === 0 && Xt.ended ? 0 : Xt.objectMode ? 1 : Vt !== Vt ? Xt.flowing && Xt.length ? Xt.buffer.head.data.length : Xt.length : (Vt > Xt.highWaterMark && (Xt.highWaterMark = Ut(Vt)), Vt <= Xt.length ? Vt : Xt.ended ? Xt.length : (Xt.needReadable = !0, 0));
  }
  vt.prototype.read = function(Vt) {
    Ee("read", Vt), Vt = parseInt(Vt, 10);
    var Xt = this._readableState, sr = Vt;
    if (Vt !== 0 && (Xt.emittedReadable = !1), Vt === 0 && Xt.needReadable && (Xt.length >= Xt.highWaterMark || Xt.ended))
      return Ee("read: emitReadable", Xt.length, Xt.ended), Xt.length === 0 && Xt.ended ? ar(this) : Ft(this), null;
    if (Vt = qt(Vt, Xt), Vt === 0 && Xt.ended)
      return Xt.length === 0 && ar(this), null;
    var dr = Xt.needReadable;
    Ee("need readable", dr), (Xt.length === 0 || Xt.length - Vt < Xt.highWaterMark) && (dr = !0, Ee("length less than watermark", dr)), Xt.ended || Xt.reading ? (dr = !1, Ee("reading or ended", dr)) : dr && (Ee("do read"), Xt.reading = !0, Xt.sync = !0, Xt.length === 0 && (Xt.needReadable = !0), this._read(Xt.highWaterMark), Xt.sync = !1, Xt.reading || (Vt = qt(sr, Xt)));
    var er;
    return Vt > 0 ? er = xt(Vt, Xt) : er = null, er === null ? (Xt.needReadable = !0, Vt = 0) : Xt.length -= Vt, Xt.length === 0 && (Xt.ended || (Xt.needReadable = !0), sr !== Vt && Xt.ended && ar(this)), er !== null && this.emit("data", er), er;
  };
  function zt(Vt, Xt) {
    if (!Xt.ended) {
      if (Xt.decoder) {
        var sr = Xt.decoder.end();
        sr && sr.length && (Xt.buffer.push(sr), Xt.length += Xt.objectMode ? 1 : sr.length);
      }
      Xt.ended = !0, Ft(Vt);
    }
  }
  function Ft(Vt) {
    var Xt = Vt._readableState;
    Xt.needReadable = !1, Xt.emittedReadable || (Ee("emitReadable", Xt.flowing), Xt.emittedReadable = !0, Xt.sync ? B.nextTick(Ve, Vt) : Ve(Vt));
  }
  function Ve(Vt) {
    Ee("emit readable"), Vt.emit("readable"), kt(Vt);
  }
  function Je(Vt, Xt) {
    Xt.readingMore || (Xt.readingMore = !0, B.nextTick(Ke, Vt, Xt));
  }
  function Ke(Vt, Xt) {
    for (var sr = Xt.length; !Xt.reading && !Xt.flowing && !Xt.ended && Xt.length < Xt.highWaterMark && (Ee("maybeReadMore read 0"), Vt.read(0), sr !== Xt.length); )
      sr = Xt.length;
    Xt.readingMore = !1;
  }
  vt.prototype._read = function(Vt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, vt.prototype.pipe = function(Vt, Xt) {
    var sr = this, dr = this._readableState;
    switch (dr.pipesCount) {
      case 0:
        dr.pipes = Vt;
        break;
      case 1:
        dr.pipes = [dr.pipes, Vt];
        break;
      default:
        dr.pipes.push(Vt);
        break;
    }
    dr.pipesCount += 1, Ee("pipe count=%d opts=%j", dr.pipesCount, Xt);
    var er = (!Xt || Xt.end !== !1) && Vt !== process$1.stdout && Vt !== process$1.stderr, Zt = er ? _r : Cr;
    dr.endEmitted ? B.nextTick(Zt) : sr.once("end", Zt), Vt.on("unpipe", pr);
    function pr(Tr, Hr) {
      Ee("onunpipe"), Tr === sr && Hr && Hr.hasUnpiped === !1 && (Hr.hasUnpiped = !0, Br());
    }
    function _r() {
      Ee("onend"), Vt.end();
    }
    var Ar = Qe(sr);
    Vt.on("drain", Ar);
    var Sr = !1;
    function Br() {
      Ee("cleanup"), Vt.removeListener("close", Pr), Vt.removeListener("finish", Mr), Vt.removeListener("drain", Ar), Vt.removeListener("error", Gr), Vt.removeListener("unpipe", pr), sr.removeListener("end", _r), sr.removeListener("end", Cr), sr.removeListener("data", wr), Sr = !0, dr.awaitDrain && (!Vt._writableState || Vt._writableState.needDrain) && Ar();
    }
    var Ir = !1;
    sr.on("data", wr);
    function wr(Tr) {
      Ee("ondata"), Ir = !1;
      var Hr = Vt.write(Tr);
      Hr === !1 && !Ir && ((dr.pipesCount === 1 && dr.pipes === Vt || dr.pipesCount > 1 && nr(dr.pipes, Vt) !== -1) && !Sr && (Ee("false write response, pause", dr.awaitDrain), dr.awaitDrain++, Ir = !0), sr.pause());
    }
    function Gr(Tr) {
      Ee("onerror", Tr), Cr(), Vt.removeListener("error", Gr), ne(Vt, "error") === 0 && Vt.emit("error", Tr);
    }
    wt(Vt, "error", Gr);
    function Pr() {
      Vt.removeListener("finish", Mr), Cr();
    }
    Vt.once("close", Pr);
    function Mr() {
      Ee("onfinish"), Vt.removeListener("close", Pr), Cr();
    }
    Vt.once("finish", Mr);
    function Cr() {
      Ee("unpipe"), sr.unpipe(Vt);
    }
    return Vt.emit("pipe", sr), dr.flowing || (Ee("pipe resume"), sr.resume()), Vt;
  };
  function Qe(Vt) {
    return function() {
      var Xt = Vt._readableState;
      Ee("pipeOnDrain", Xt.awaitDrain), Xt.awaitDrain && Xt.awaitDrain--, Xt.awaitDrain === 0 && ne(Vt, "data") && (Xt.flowing = !0, kt(Vt));
    };
  }
  vt.prototype.unpipe = function(Vt) {
    var Xt = this._readableState, sr = { hasUnpiped: !1 };
    if (Xt.pipesCount === 0) return this;
    if (Xt.pipesCount === 1)
      return Vt && Vt !== Xt.pipes ? this : (Vt || (Vt = Xt.pipes), Xt.pipes = null, Xt.pipesCount = 0, Xt.flowing = !1, Vt && Vt.emit("unpipe", this, sr), this);
    if (!Vt) {
      var dr = Xt.pipes, er = Xt.pipesCount;
      Xt.pipes = null, Xt.pipesCount = 0, Xt.flowing = !1;
      for (var Zt = 0; Zt < er; Zt++)
        dr[Zt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var pr = nr(Xt.pipes, Vt);
    return pr === -1 ? this : (Xt.pipes.splice(pr, 1), Xt.pipesCount -= 1, Xt.pipesCount === 1 && (Xt.pipes = Xt.pipes[0]), Vt.emit("unpipe", this, sr), this);
  }, vt.prototype.on = function(Vt, Xt) {
    var sr = oe.prototype.on.call(this, Vt, Xt);
    if (Vt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Vt === "readable") {
      var dr = this._readableState;
      !dr.endEmitted && !dr.readableListening && (dr.readableListening = dr.needReadable = !0, dr.emittedReadable = !1, dr.reading ? dr.length && Ft(this) : B.nextTick(bt, this));
    }
    return sr;
  }, vt.prototype.addListener = vt.prototype.on;
  function bt(Vt) {
    Ee("readable nexttick read 0"), Vt.read(0);
  }
  vt.prototype.resume = function() {
    var Vt = this._readableState;
    return Vt.flowing || (Ee("resume"), Vt.flowing = !0, _t(this, Vt)), this;
  };
  function _t(Vt, Xt) {
    Xt.resumeScheduled || (Xt.resumeScheduled = !0, B.nextTick($t, Vt, Xt));
  }
  function $t(Vt, Xt) {
    Xt.reading || (Ee("resume read 0"), Vt.read(0)), Xt.resumeScheduled = !1, Xt.awaitDrain = 0, Vt.emit("resume"), kt(Vt), Xt.flowing && !Xt.reading && Vt.read(0);
  }
  vt.prototype.pause = function() {
    return Ee("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Ee("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function kt(Vt) {
    var Xt = Vt._readableState;
    for (Ee("flow", Xt.flowing); Xt.flowing && Vt.read() !== null; )
      ;
  }
  vt.prototype.wrap = function(Vt) {
    var Xt = this, sr = this._readableState, dr = !1;
    Vt.on("end", function() {
      if (Ee("wrapped end"), sr.decoder && !sr.ended) {
        var pr = sr.decoder.end();
        pr && pr.length && Xt.push(pr);
      }
      Xt.push(null);
    }), Vt.on("data", function(pr) {
      if (Ee("wrapped data"), sr.decoder && (pr = sr.decoder.write(pr)), !(sr.objectMode && pr == null) && !(!sr.objectMode && (!pr || !pr.length))) {
        var _r = Xt.push(pr);
        _r || (dr = !0, Vt.pause());
      }
    });
    for (var er in Vt)
      this[er] === void 0 && typeof Vt[er] == "function" && (this[er] = /* @__PURE__ */ function(pr) {
        return function() {
          return Vt[pr].apply(Vt, arguments);
        };
      }(er));
    for (var Zt = 0; Zt < ht.length; Zt++)
      Vt.on(ht[Zt], this.emit.bind(this, ht[Zt]));
    return this._read = function(pr) {
      Ee("wrapped _read", pr), dr && (dr = !1, Vt.resume());
    }, this;
  }, Object.defineProperty(vt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), vt._fromList = xt;
  function xt(Vt, Xt) {
    if (Xt.length === 0) return null;
    var sr;
    return Xt.objectMode ? sr = Xt.buffer.shift() : !Vt || Vt >= Xt.length ? (Xt.decoder ? sr = Xt.buffer.join("") : Xt.buffer.length === 1 ? sr = Xt.buffer.head.data : sr = Xt.buffer.concat(Xt.length), Xt.buffer.clear()) : sr = Nt(Vt, Xt.buffer, Xt.decoder), sr;
  }
  function Nt(Vt, Xt, sr) {
    var dr;
    return Vt < Xt.head.data.length ? (dr = Xt.head.data.slice(0, Vt), Xt.head.data = Xt.head.data.slice(Vt)) : Vt === Xt.head.data.length ? dr = Xt.shift() : dr = sr ? Rt(Vt, Xt) : Ht(Vt, Xt), dr;
  }
  function Rt(Vt, Xt) {
    var sr = Xt.head, dr = 1, er = sr.data;
    for (Vt -= er.length; sr = sr.next; ) {
      var Zt = sr.data, pr = Vt > Zt.length ? Zt.length : Vt;
      if (pr === Zt.length ? er += Zt : er += Zt.slice(0, Vt), Vt -= pr, Vt === 0) {
        pr === Zt.length ? (++dr, sr.next ? Xt.head = sr.next : Xt.head = Xt.tail = null) : (Xt.head = sr, sr.data = Zt.slice(pr));
        break;
      }
      ++dr;
    }
    return Xt.length -= dr, er;
  }
  function Ht(Vt, Xt) {
    var sr = ie.allocUnsafe(Vt), dr = Xt.head, er = 1;
    for (dr.data.copy(sr), Vt -= dr.data.length; dr = dr.next; ) {
      var Zt = dr.data, pr = Vt > Zt.length ? Zt.length : Vt;
      if (Zt.copy(sr, sr.length - Vt, 0, pr), Vt -= pr, Vt === 0) {
        pr === Zt.length ? (++er, dr.next ? Xt.head = dr.next : Xt.head = Xt.tail = null) : (Xt.head = dr, dr.data = Zt.slice(pr));
        break;
      }
      ++er;
    }
    return Xt.length -= er, sr;
  }
  function ar(Vt) {
    var Xt = Vt._readableState;
    if (Xt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Xt.endEmitted || (Xt.ended = !0, B.nextTick(lr, Xt, Vt));
  }
  function lr(Vt, Xt) {
    !Vt.endEmitted && Vt.length === 0 && (Vt.endEmitted = !0, Xt.readable = !1, Xt.emit("end"));
  }
  function nr(Vt, Xt) {
    for (var sr = 0, dr = Vt.length; sr < dr; sr++)
      if (Vt[sr] === Xt) return sr;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = ne;
  var B = require_stream_duplex(), z = Object.create(requireUtil());
  z.inherits = requireInherits_browser(), z.inherits(ne, B);
  function Y(ae, se) {
    var ve = this._transformState;
    ve.transforming = !1;
    var ge = ve.writecb;
    if (!ge)
      return this.emit("error", new Error("write callback called multiple times"));
    ve.writechunk = null, ve.writecb = null, se != null && this.push(se), ge(ae);
    var le = this._readableState;
    le.reading = !1, (le.needReadable || le.length < le.highWaterMark) && this._read(le.highWaterMark);
  }
  function ne(ae) {
    if (!(this instanceof ne)) return new ne(ae);
    B.call(this, ae), this._transformState = {
      afterTransform: Y.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, ae && (typeof ae.transform == "function" && (this._transform = ae.transform), typeof ae.flush == "function" && (this._flush = ae.flush)), this.on("prefinish", oe);
  }
  function oe() {
    var ae = this;
    typeof this._flush == "function" ? this._flush(function(se, ve) {
      ie(ae, se, ve);
    }) : ie(this, null, null);
  }
  ne.prototype.push = function(ae, se) {
    return this._transformState.needTransform = !1, B.prototype.push.call(this, ae, se);
  }, ne.prototype._transform = function(ae, se, ve) {
    throw new Error("_transform() is not implemented");
  }, ne.prototype._write = function(ae, se, ve) {
    var ge = this._transformState;
    if (ge.writecb = ve, ge.writechunk = ae, ge.writeencoding = se, !ge.transforming) {
      var le = this._readableState;
      (ge.needTransform || le.needReadable || le.length < le.highWaterMark) && this._read(le.highWaterMark);
    }
  }, ne.prototype._read = function(ae) {
    var se = this._transformState;
    se.writechunk !== null && se.writecb && !se.transforming ? (se.transforming = !0, this._transform(se.writechunk, se.writeencoding, se.afterTransform)) : se.needTransform = !0;
  }, ne.prototype._destroy = function(ae, se) {
    var ve = this;
    B.prototype._destroy.call(this, ae, function(ge) {
      se(ge), ve.emit("close");
    });
  };
  function ie(ae, se, ve) {
    if (se) return ae.emit("error", se);
    if (ve != null && ae.push(ve), ae._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (ae._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return ae.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = Y;
  var B = require_stream_transform(), z = Object.create(requireUtil());
  z.inherits = requireInherits_browser(), z.inherits(Y, B);
  function Y(ne) {
    if (!(this instanceof Y)) return new Y(ne);
    B.call(this, ne);
  }
  return Y.prototype._transform = function(ne, oe, ie) {
    ie(null, ne);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(B, z) {
    z = B.exports = require_stream_readable(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable(), z.Duplex = require_stream_duplex(), z.Transform = require_stream_transform(), z.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(B) {
    (function(z, Y) {
      function ne(Je, Ke) {
        if (!Je) throw new Error(Ke || "Assertion failed");
      }
      function oe(Je, Ke) {
        Je.super_ = Ke;
        var Qe = function() {
        };
        Qe.prototype = Ke.prototype, Je.prototype = new Qe(), Je.prototype.constructor = Je;
      }
      function ie(Je, Ke, Qe) {
        if (ie.isBN(Je))
          return Je;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Je !== null && ((Ke === "le" || Ke === "be") && (Qe = Ke, Ke = 10), this._init(Je || 0, Ke || 10, Qe || "be"));
      }
      typeof z == "object" ? z.exports = ie : Y.BN = ie, ie.BN = ie, ie.wordSize = 26;
      var ae;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? ae = window.Buffer : ae = dist$1.Buffer;
      } catch {
      }
      ie.isBN = function(Ke) {
        return Ke instanceof ie ? !0 : Ke !== null && typeof Ke == "object" && Ke.constructor.wordSize === ie.wordSize && Array.isArray(Ke.words);
      }, ie.max = function(Ke, Qe) {
        return Ke.cmp(Qe) > 0 ? Ke : Qe;
      }, ie.min = function(Ke, Qe) {
        return Ke.cmp(Qe) < 0 ? Ke : Qe;
      }, ie.prototype._init = function(Ke, Qe, bt) {
        if (typeof Ke == "number")
          return this._initNumber(Ke, Qe, bt);
        if (typeof Ke == "object")
          return this._initArray(Ke, Qe, bt);
        Qe === "hex" && (Qe = 16), ne(Qe === (Qe | 0) && Qe >= 2 && Qe <= 36), Ke = Ke.toString().replace(/\s+/g, "");
        var _t = 0;
        Ke[0] === "-" && (_t++, this.negative = 1), _t < Ke.length && (Qe === 16 ? this._parseHex(Ke, _t, bt) : (this._parseBase(Ke, Qe, _t), bt === "le" && this._initArray(this.toArray(), Qe, bt)));
      }, ie.prototype._initNumber = function(Ke, Qe, bt) {
        Ke < 0 && (this.negative = 1, Ke = -Ke), Ke < 67108864 ? (this.words = [Ke & 67108863], this.length = 1) : Ke < 4503599627370496 ? (this.words = [
          Ke & 67108863,
          Ke / 67108864 & 67108863
        ], this.length = 2) : (ne(Ke < 9007199254740992), this.words = [
          Ke & 67108863,
          Ke / 67108864 & 67108863,
          1
        ], this.length = 3), bt === "le" && this._initArray(this.toArray(), Qe, bt);
      }, ie.prototype._initArray = function(Ke, Qe, bt) {
        if (ne(typeof Ke.length == "number"), Ke.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(Ke.length / 3), this.words = new Array(this.length);
        for (var _t = 0; _t < this.length; _t++)
          this.words[_t] = 0;
        var $t, kt, xt = 0;
        if (bt === "be")
          for (_t = Ke.length - 1, $t = 0; _t >= 0; _t -= 3)
            kt = Ke[_t] | Ke[_t - 1] << 8 | Ke[_t - 2] << 16, this.words[$t] |= kt << xt & 67108863, this.words[$t + 1] = kt >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, $t++);
        else if (bt === "le")
          for (_t = 0, $t = 0; _t < Ke.length; _t += 3)
            kt = Ke[_t] | Ke[_t + 1] << 8 | Ke[_t + 2] << 16, this.words[$t] |= kt << xt & 67108863, this.words[$t + 1] = kt >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, $t++);
        return this._strip();
      };
      function se(Je, Ke) {
        var Qe = Je.charCodeAt(Ke);
        if (Qe >= 48 && Qe <= 57)
          return Qe - 48;
        if (Qe >= 65 && Qe <= 70)
          return Qe - 55;
        if (Qe >= 97 && Qe <= 102)
          return Qe - 87;
        ne(!1, "Invalid character in " + Je);
      }
      function ve(Je, Ke, Qe) {
        var bt = se(Je, Qe);
        return Qe - 1 >= Ke && (bt |= se(Je, Qe - 1) << 4), bt;
      }
      ie.prototype._parseHex = function(Ke, Qe, bt) {
        this.length = Math.ceil((Ke.length - Qe) / 6), this.words = new Array(this.length);
        for (var _t = 0; _t < this.length; _t++)
          this.words[_t] = 0;
        var $t = 0, kt = 0, xt;
        if (bt === "be")
          for (_t = Ke.length - 1; _t >= Qe; _t -= 2)
            xt = ve(Ke, Qe, _t) << $t, this.words[kt] |= xt & 67108863, $t >= 18 ? ($t -= 18, kt += 1, this.words[kt] |= xt >>> 26) : $t += 8;
        else {
          var Nt = Ke.length - Qe;
          for (_t = Nt % 2 === 0 ? Qe + 1 : Qe; _t < Ke.length; _t += 2)
            xt = ve(Ke, Qe, _t) << $t, this.words[kt] |= xt & 67108863, $t >= 18 ? ($t -= 18, kt += 1, this.words[kt] |= xt >>> 26) : $t += 8;
        }
        this._strip();
      };
      function ge(Je, Ke, Qe, bt) {
        for (var _t = 0, $t = 0, kt = Math.min(Je.length, Qe), xt = Ke; xt < kt; xt++) {
          var Nt = Je.charCodeAt(xt) - 48;
          _t *= bt, Nt >= 49 ? $t = Nt - 49 + 10 : Nt >= 17 ? $t = Nt - 17 + 10 : $t = Nt, ne(Nt >= 0 && $t < bt, "Invalid character"), _t += $t;
        }
        return _t;
      }
      ie.prototype._parseBase = function(Ke, Qe, bt) {
        this.words = [0], this.length = 1;
        for (var _t = 0, $t = 1; $t <= 67108863; $t *= Qe)
          _t++;
        _t--, $t = $t / Qe | 0;
        for (var kt = Ke.length - bt, xt = kt % _t, Nt = Math.min(kt, kt - xt) + bt, Rt = 0, Ht = bt; Ht < Nt; Ht += _t)
          Rt = ge(Ke, Ht, Ht + _t, Qe), this.imuln($t), this.words[0] + Rt < 67108864 ? this.words[0] += Rt : this._iaddn(Rt);
        if (xt !== 0) {
          var ar = 1;
          for (Rt = ge(Ke, Ht, Ke.length, Qe), Ht = 0; Ht < xt; Ht++)
            ar *= Qe;
          this.imuln(ar), this.words[0] + Rt < 67108864 ? this.words[0] += Rt : this._iaddn(Rt);
        }
        this._strip();
      }, ie.prototype.copy = function(Ke) {
        Ke.words = new Array(this.length);
        for (var Qe = 0; Qe < this.length; Qe++)
          Ke.words[Qe] = this.words[Qe];
        Ke.length = this.length, Ke.negative = this.negative, Ke.red = this.red;
      };
      function le(Je, Ke) {
        Je.words = Ke.words, Je.length = Ke.length, Je.negative = Ke.negative, Je.red = Ke.red;
      }
      if (ie.prototype._move = function(Ke) {
        le(Ke, this);
      }, ie.prototype.clone = function() {
        var Ke = new ie(null);
        return this.copy(Ke), Ke;
      }, ie.prototype._expand = function(Ke) {
        for (; this.length < Ke; )
          this.words[this.length++] = 0;
        return this;
      }, ie.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ie.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          ie.prototype[Symbol.for("nodejs.util.inspect.custom")] = Ee;
        } catch {
          ie.prototype.inspect = Ee;
        }
      else
        ie.prototype.inspect = Ee;
      function Ee() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Ce = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Pe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Xe = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ie.prototype.toString = function(Ke, Qe) {
        Ke = Ke || 10, Qe = Qe | 0 || 1;
        var bt;
        if (Ke === 16 || Ke === "hex") {
          bt = "";
          for (var _t = 0, $t = 0, kt = 0; kt < this.length; kt++) {
            var xt = this.words[kt], Nt = ((xt << _t | $t) & 16777215).toString(16);
            $t = xt >>> 24 - _t & 16777215, _t += 2, _t >= 26 && (_t -= 26, kt--), $t !== 0 || kt !== this.length - 1 ? bt = Ce[6 - Nt.length] + Nt + bt : bt = Nt + bt;
          }
          for ($t !== 0 && (bt = $t.toString(16) + bt); bt.length % Qe !== 0; )
            bt = "0" + bt;
          return this.negative !== 0 && (bt = "-" + bt), bt;
        }
        if (Ke === (Ke | 0) && Ke >= 2 && Ke <= 36) {
          var Rt = Pe[Ke], Ht = Xe[Ke];
          bt = "";
          var ar = this.clone();
          for (ar.negative = 0; !ar.isZero(); ) {
            var lr = ar.modrn(Ht).toString(Ke);
            ar = ar.idivn(Ht), ar.isZero() ? bt = lr + bt : bt = Ce[Rt - lr.length] + lr + bt;
          }
          for (this.isZero() && (bt = "0" + bt); bt.length % Qe !== 0; )
            bt = "0" + bt;
          return this.negative !== 0 && (bt = "-" + bt), bt;
        }
        ne(!1, "Base should be between 2 and 36");
      }, ie.prototype.toNumber = function() {
        var Ke = this.words[0];
        return this.length === 2 ? Ke += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? Ke += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ne(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -Ke : Ke;
      }, ie.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, ae && (ie.prototype.toBuffer = function(Ke, Qe) {
        return this.toArrayLike(ae, Ke, Qe);
      }), ie.prototype.toArray = function(Ke, Qe) {
        return this.toArrayLike(Array, Ke, Qe);
      };
      var ht = function(Ke, Qe) {
        return Ke.allocUnsafe ? Ke.allocUnsafe(Qe) : new Ke(Qe);
      };
      ie.prototype.toArrayLike = function(Ke, Qe, bt) {
        this._strip();
        var _t = this.byteLength(), $t = bt || Math.max(1, _t);
        ne(_t <= $t, "byte array longer than desired length"), ne($t > 0, "Requested array length <= 0");
        var kt = ht(Ke, $t), xt = Qe === "le" ? "LE" : "BE";
        return this["_toArrayLike" + xt](kt, _t), kt;
      }, ie.prototype._toArrayLikeLE = function(Ke, Qe) {
        for (var bt = 0, _t = 0, $t = 0, kt = 0; $t < this.length; $t++) {
          var xt = this.words[$t] << kt | _t;
          Ke[bt++] = xt & 255, bt < Ke.length && (Ke[bt++] = xt >> 8 & 255), bt < Ke.length && (Ke[bt++] = xt >> 16 & 255), kt === 6 ? (bt < Ke.length && (Ke[bt++] = xt >> 24 & 255), _t = 0, kt = 0) : (_t = xt >>> 24, kt += 2);
        }
        if (bt < Ke.length)
          for (Ke[bt++] = _t; bt < Ke.length; )
            Ke[bt++] = 0;
      }, ie.prototype._toArrayLikeBE = function(Ke, Qe) {
        for (var bt = Ke.length - 1, _t = 0, $t = 0, kt = 0; $t < this.length; $t++) {
          var xt = this.words[$t] << kt | _t;
          Ke[bt--] = xt & 255, bt >= 0 && (Ke[bt--] = xt >> 8 & 255), bt >= 0 && (Ke[bt--] = xt >> 16 & 255), kt === 6 ? (bt >= 0 && (Ke[bt--] = xt >> 24 & 255), _t = 0, kt = 0) : (_t = xt >>> 24, kt += 2);
        }
        if (bt >= 0)
          for (Ke[bt--] = _t; bt >= 0; )
            Ke[bt--] = 0;
      }, Math.clz32 ? ie.prototype._countBits = function(Ke) {
        return 32 - Math.clz32(Ke);
      } : ie.prototype._countBits = function(Ke) {
        var Qe = Ke, bt = 0;
        return Qe >= 4096 && (bt += 13, Qe >>>= 13), Qe >= 64 && (bt += 7, Qe >>>= 7), Qe >= 8 && (bt += 4, Qe >>>= 4), Qe >= 2 && (bt += 2, Qe >>>= 2), bt + Qe;
      }, ie.prototype._zeroBits = function(Ke) {
        if (Ke === 0) return 26;
        var Qe = Ke, bt = 0;
        return Qe & 8191 || (bt += 13, Qe >>>= 13), Qe & 127 || (bt += 7, Qe >>>= 7), Qe & 15 || (bt += 4, Qe >>>= 4), Qe & 3 || (bt += 2, Qe >>>= 2), Qe & 1 || bt++, bt;
      }, ie.prototype.bitLength = function() {
        var Ke = this.words[this.length - 1], Qe = this._countBits(Ke);
        return (this.length - 1) * 26 + Qe;
      };
      function wt(Je) {
        for (var Ke = new Array(Je.bitLength()), Qe = 0; Qe < Ke.length; Qe++) {
          var bt = Qe / 26 | 0, _t = Qe % 26;
          Ke[Qe] = Je.words[bt] >>> _t & 1;
        }
        return Ke;
      }
      ie.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var Ke = 0, Qe = 0; Qe < this.length; Qe++) {
          var bt = this._zeroBits(this.words[Qe]);
          if (Ke += bt, bt !== 26) break;
        }
        return Ke;
      }, ie.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ie.prototype.toTwos = function(Ke) {
        return this.negative !== 0 ? this.abs().inotn(Ke).iaddn(1) : this.clone();
      }, ie.prototype.fromTwos = function(Ke) {
        return this.testn(Ke - 1) ? this.notn(Ke).iaddn(1).ineg() : this.clone();
      }, ie.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ie.prototype.neg = function() {
        return this.clone().ineg();
      }, ie.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ie.prototype.iuor = function(Ke) {
        for (; this.length < Ke.length; )
          this.words[this.length++] = 0;
        for (var Qe = 0; Qe < Ke.length; Qe++)
          this.words[Qe] = this.words[Qe] | Ke.words[Qe];
        return this._strip();
      }, ie.prototype.ior = function(Ke) {
        return ne((this.negative | Ke.negative) === 0), this.iuor(Ke);
      }, ie.prototype.or = function(Ke) {
        return this.length > Ke.length ? this.clone().ior(Ke) : Ke.clone().ior(this);
      }, ie.prototype.uor = function(Ke) {
        return this.length > Ke.length ? this.clone().iuor(Ke) : Ke.clone().iuor(this);
      }, ie.prototype.iuand = function(Ke) {
        var Qe;
        this.length > Ke.length ? Qe = Ke : Qe = this;
        for (var bt = 0; bt < Qe.length; bt++)
          this.words[bt] = this.words[bt] & Ke.words[bt];
        return this.length = Qe.length, this._strip();
      }, ie.prototype.iand = function(Ke) {
        return ne((this.negative | Ke.negative) === 0), this.iuand(Ke);
      }, ie.prototype.and = function(Ke) {
        return this.length > Ke.length ? this.clone().iand(Ke) : Ke.clone().iand(this);
      }, ie.prototype.uand = function(Ke) {
        return this.length > Ke.length ? this.clone().iuand(Ke) : Ke.clone().iuand(this);
      }, ie.prototype.iuxor = function(Ke) {
        var Qe, bt;
        this.length > Ke.length ? (Qe = this, bt = Ke) : (Qe = Ke, bt = this);
        for (var _t = 0; _t < bt.length; _t++)
          this.words[_t] = Qe.words[_t] ^ bt.words[_t];
        if (this !== Qe)
          for (; _t < Qe.length; _t++)
            this.words[_t] = Qe.words[_t];
        return this.length = Qe.length, this._strip();
      }, ie.prototype.ixor = function(Ke) {
        return ne((this.negative | Ke.negative) === 0), this.iuxor(Ke);
      }, ie.prototype.xor = function(Ke) {
        return this.length > Ke.length ? this.clone().ixor(Ke) : Ke.clone().ixor(this);
      }, ie.prototype.uxor = function(Ke) {
        return this.length > Ke.length ? this.clone().iuxor(Ke) : Ke.clone().iuxor(this);
      }, ie.prototype.inotn = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Math.ceil(Ke / 26) | 0, bt = Ke % 26;
        this._expand(Qe), bt > 0 && Qe--;
        for (var _t = 0; _t < Qe; _t++)
          this.words[_t] = ~this.words[_t] & 67108863;
        return bt > 0 && (this.words[_t] = ~this.words[_t] & 67108863 >> 26 - bt), this._strip();
      }, ie.prototype.notn = function(Ke) {
        return this.clone().inotn(Ke);
      }, ie.prototype.setn = function(Ke, Qe) {
        ne(typeof Ke == "number" && Ke >= 0);
        var bt = Ke / 26 | 0, _t = Ke % 26;
        return this._expand(bt + 1), Qe ? this.words[bt] = this.words[bt] | 1 << _t : this.words[bt] = this.words[bt] & ~(1 << _t), this._strip();
      }, ie.prototype.iadd = function(Ke) {
        var Qe;
        if (this.negative !== 0 && Ke.negative === 0)
          return this.negative = 0, Qe = this.isub(Ke), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && Ke.negative !== 0)
          return Ke.negative = 0, Qe = this.isub(Ke), Ke.negative = 1, Qe._normSign();
        var bt, _t;
        this.length > Ke.length ? (bt = this, _t = Ke) : (bt = Ke, _t = this);
        for (var $t = 0, kt = 0; kt < _t.length; kt++)
          Qe = (bt.words[kt] | 0) + (_t.words[kt] | 0) + $t, this.words[kt] = Qe & 67108863, $t = Qe >>> 26;
        for (; $t !== 0 && kt < bt.length; kt++)
          Qe = (bt.words[kt] | 0) + $t, this.words[kt] = Qe & 67108863, $t = Qe >>> 26;
        if (this.length = bt.length, $t !== 0)
          this.words[this.length] = $t, this.length++;
        else if (bt !== this)
          for (; kt < bt.length; kt++)
            this.words[kt] = bt.words[kt];
        return this;
      }, ie.prototype.add = function(Ke) {
        var Qe;
        return Ke.negative !== 0 && this.negative === 0 ? (Ke.negative = 0, Qe = this.sub(Ke), Ke.negative ^= 1, Qe) : Ke.negative === 0 && this.negative !== 0 ? (this.negative = 0, Qe = Ke.sub(this), this.negative = 1, Qe) : this.length > Ke.length ? this.clone().iadd(Ke) : Ke.clone().iadd(this);
      }, ie.prototype.isub = function(Ke) {
        if (Ke.negative !== 0) {
          Ke.negative = 0;
          var Qe = this.iadd(Ke);
          return Ke.negative = 1, Qe._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(Ke), this.negative = 1, this._normSign();
        var bt = this.cmp(Ke);
        if (bt === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var _t, $t;
        bt > 0 ? (_t = this, $t = Ke) : (_t = Ke, $t = this);
        for (var kt = 0, xt = 0; xt < $t.length; xt++)
          Qe = (_t.words[xt] | 0) - ($t.words[xt] | 0) + kt, kt = Qe >> 26, this.words[xt] = Qe & 67108863;
        for (; kt !== 0 && xt < _t.length; xt++)
          Qe = (_t.words[xt] | 0) + kt, kt = Qe >> 26, this.words[xt] = Qe & 67108863;
        if (kt === 0 && xt < _t.length && _t !== this)
          for (; xt < _t.length; xt++)
            this.words[xt] = _t.words[xt];
        return this.length = Math.max(this.length, xt), _t !== this && (this.negative = 1), this._strip();
      }, ie.prototype.sub = function(Ke) {
        return this.clone().isub(Ke);
      };
      function Pt(Je, Ke, Qe) {
        Qe.negative = Ke.negative ^ Je.negative;
        var bt = Je.length + Ke.length | 0;
        Qe.length = bt, bt = bt - 1 | 0;
        var _t = Je.words[0] | 0, $t = Ke.words[0] | 0, kt = _t * $t, xt = kt & 67108863, Nt = kt / 67108864 | 0;
        Qe.words[0] = xt;
        for (var Rt = 1; Rt < bt; Rt++) {
          for (var Ht = Nt >>> 26, ar = Nt & 67108863, lr = Math.min(Rt, Ke.length - 1), nr = Math.max(0, Rt - Je.length + 1); nr <= lr; nr++) {
            var Vt = Rt - nr | 0;
            _t = Je.words[Vt] | 0, $t = Ke.words[nr] | 0, kt = _t * $t + ar, Ht += kt / 67108864 | 0, ar = kt & 67108863;
          }
          Qe.words[Rt] = ar | 0, Nt = Ht | 0;
        }
        return Nt !== 0 ? Qe.words[Rt] = Nt | 0 : Qe.length--, Qe._strip();
      }
      var vt = function(Ke, Qe, bt) {
        var _t = Ke.words, $t = Qe.words, kt = bt.words, xt = 0, Nt, Rt, Ht, ar = _t[0] | 0, lr = ar & 8191, nr = ar >>> 13, Vt = _t[1] | 0, Xt = Vt & 8191, sr = Vt >>> 13, dr = _t[2] | 0, er = dr & 8191, Zt = dr >>> 13, pr = _t[3] | 0, _r = pr & 8191, Ar = pr >>> 13, Sr = _t[4] | 0, Br = Sr & 8191, Ir = Sr >>> 13, wr = _t[5] | 0, Gr = wr & 8191, Pr = wr >>> 13, Mr = _t[6] | 0, Cr = Mr & 8191, Tr = Mr >>> 13, Hr = _t[7] | 0, Yr = Hr & 8191, Nr = Hr >>> 13, zr = _t[8] | 0, Jr = zr & 8191, Jt = zr >>> 13, Dt = _t[9] | 0, Gt = Dt & 8191, rr = Dt >>> 13, cr = $t[0] | 0, br = cr & 8191, gr = cr >>> 13, Or = $t[1] | 0, Wr = Or & 8191, kr = Or >>> 13, jr = $t[2] | 0, Lr = jr & 8191, Fr = jr >>> 13, Xr = $t[3] | 0, Zr = Xr & 8191, fr = Xr >>> 13, tr = $t[4] | 0, ur = tr & 8191, jt = tr >>> 13, Ot = $t[5] | 0, Lt = Ot & 8191, Qt = Ot >>> 13, or = $t[6] | 0, hr = or & 8191, yr = or >>> 13, xr = $t[7] | 0, Rr = xr & 8191, ir = xr >>> 13, vr = $t[8] | 0, Er = vr & 8191, $r = vr >>> 13, Ur = $t[9] | 0, Dr = Ur & 8191, qr = Ur >>> 13;
        bt.negative = Ke.negative ^ Qe.negative, bt.length = 19, Nt = Math.imul(lr, br), Rt = Math.imul(lr, gr), Rt = Rt + Math.imul(nr, br) | 0, Ht = Math.imul(nr, gr);
        var Vr = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (Vr >>> 26) | 0, Vr &= 67108863, Nt = Math.imul(Xt, br), Rt = Math.imul(Xt, gr), Rt = Rt + Math.imul(sr, br) | 0, Ht = Math.imul(sr, gr), Nt = Nt + Math.imul(lr, Wr) | 0, Rt = Rt + Math.imul(lr, kr) | 0, Rt = Rt + Math.imul(nr, Wr) | 0, Ht = Ht + Math.imul(nr, kr) | 0;
        var tn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, Nt = Math.imul(er, br), Rt = Math.imul(er, gr), Rt = Rt + Math.imul(Zt, br) | 0, Ht = Math.imul(Zt, gr), Nt = Nt + Math.imul(Xt, Wr) | 0, Rt = Rt + Math.imul(Xt, kr) | 0, Rt = Rt + Math.imul(sr, Wr) | 0, Ht = Ht + Math.imul(sr, kr) | 0, Nt = Nt + Math.imul(lr, Lr) | 0, Rt = Rt + Math.imul(lr, Fr) | 0, Rt = Rt + Math.imul(nr, Lr) | 0, Ht = Ht + Math.imul(nr, Fr) | 0;
        var Qr = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, Nt = Math.imul(_r, br), Rt = Math.imul(_r, gr), Rt = Rt + Math.imul(Ar, br) | 0, Ht = Math.imul(Ar, gr), Nt = Nt + Math.imul(er, Wr) | 0, Rt = Rt + Math.imul(er, kr) | 0, Rt = Rt + Math.imul(Zt, Wr) | 0, Ht = Ht + Math.imul(Zt, kr) | 0, Nt = Nt + Math.imul(Xt, Lr) | 0, Rt = Rt + Math.imul(Xt, Fr) | 0, Rt = Rt + Math.imul(sr, Lr) | 0, Ht = Ht + Math.imul(sr, Fr) | 0, Nt = Nt + Math.imul(lr, Zr) | 0, Rt = Rt + Math.imul(lr, fr) | 0, Rt = Rt + Math.imul(nr, Zr) | 0, Ht = Ht + Math.imul(nr, fr) | 0;
        var en = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, Nt = Math.imul(Br, br), Rt = Math.imul(Br, gr), Rt = Rt + Math.imul(Ir, br) | 0, Ht = Math.imul(Ir, gr), Nt = Nt + Math.imul(_r, Wr) | 0, Rt = Rt + Math.imul(_r, kr) | 0, Rt = Rt + Math.imul(Ar, Wr) | 0, Ht = Ht + Math.imul(Ar, kr) | 0, Nt = Nt + Math.imul(er, Lr) | 0, Rt = Rt + Math.imul(er, Fr) | 0, Rt = Rt + Math.imul(Zt, Lr) | 0, Ht = Ht + Math.imul(Zt, Fr) | 0, Nt = Nt + Math.imul(Xt, Zr) | 0, Rt = Rt + Math.imul(Xt, fr) | 0, Rt = Rt + Math.imul(sr, Zr) | 0, Ht = Ht + Math.imul(sr, fr) | 0, Nt = Nt + Math.imul(lr, ur) | 0, Rt = Rt + Math.imul(lr, jt) | 0, Rt = Rt + Math.imul(nr, ur) | 0, Ht = Ht + Math.imul(nr, jt) | 0;
        var on = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, Nt = Math.imul(Gr, br), Rt = Math.imul(Gr, gr), Rt = Rt + Math.imul(Pr, br) | 0, Ht = Math.imul(Pr, gr), Nt = Nt + Math.imul(Br, Wr) | 0, Rt = Rt + Math.imul(Br, kr) | 0, Rt = Rt + Math.imul(Ir, Wr) | 0, Ht = Ht + Math.imul(Ir, kr) | 0, Nt = Nt + Math.imul(_r, Lr) | 0, Rt = Rt + Math.imul(_r, Fr) | 0, Rt = Rt + Math.imul(Ar, Lr) | 0, Ht = Ht + Math.imul(Ar, Fr) | 0, Nt = Nt + Math.imul(er, Zr) | 0, Rt = Rt + Math.imul(er, fr) | 0, Rt = Rt + Math.imul(Zt, Zr) | 0, Ht = Ht + Math.imul(Zt, fr) | 0, Nt = Nt + Math.imul(Xt, ur) | 0, Rt = Rt + Math.imul(Xt, jt) | 0, Rt = Rt + Math.imul(sr, ur) | 0, Ht = Ht + Math.imul(sr, jt) | 0, Nt = Nt + Math.imul(lr, Lt) | 0, Rt = Rt + Math.imul(lr, Qt) | 0, Rt = Rt + Math.imul(nr, Lt) | 0, Ht = Ht + Math.imul(nr, Qt) | 0;
        var sn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, Nt = Math.imul(Cr, br), Rt = Math.imul(Cr, gr), Rt = Rt + Math.imul(Tr, br) | 0, Ht = Math.imul(Tr, gr), Nt = Nt + Math.imul(Gr, Wr) | 0, Rt = Rt + Math.imul(Gr, kr) | 0, Rt = Rt + Math.imul(Pr, Wr) | 0, Ht = Ht + Math.imul(Pr, kr) | 0, Nt = Nt + Math.imul(Br, Lr) | 0, Rt = Rt + Math.imul(Br, Fr) | 0, Rt = Rt + Math.imul(Ir, Lr) | 0, Ht = Ht + Math.imul(Ir, Fr) | 0, Nt = Nt + Math.imul(_r, Zr) | 0, Rt = Rt + Math.imul(_r, fr) | 0, Rt = Rt + Math.imul(Ar, Zr) | 0, Ht = Ht + Math.imul(Ar, fr) | 0, Nt = Nt + Math.imul(er, ur) | 0, Rt = Rt + Math.imul(er, jt) | 0, Rt = Rt + Math.imul(Zt, ur) | 0, Ht = Ht + Math.imul(Zt, jt) | 0, Nt = Nt + Math.imul(Xt, Lt) | 0, Rt = Rt + Math.imul(Xt, Qt) | 0, Rt = Rt + Math.imul(sr, Lt) | 0, Ht = Ht + Math.imul(sr, Qt) | 0, Nt = Nt + Math.imul(lr, hr) | 0, Rt = Rt + Math.imul(lr, yr) | 0, Rt = Rt + Math.imul(nr, hr) | 0, Ht = Ht + Math.imul(nr, yr) | 0;
        var an = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, Nt = Math.imul(Yr, br), Rt = Math.imul(Yr, gr), Rt = Rt + Math.imul(Nr, br) | 0, Ht = Math.imul(Nr, gr), Nt = Nt + Math.imul(Cr, Wr) | 0, Rt = Rt + Math.imul(Cr, kr) | 0, Rt = Rt + Math.imul(Tr, Wr) | 0, Ht = Ht + Math.imul(Tr, kr) | 0, Nt = Nt + Math.imul(Gr, Lr) | 0, Rt = Rt + Math.imul(Gr, Fr) | 0, Rt = Rt + Math.imul(Pr, Lr) | 0, Ht = Ht + Math.imul(Pr, Fr) | 0, Nt = Nt + Math.imul(Br, Zr) | 0, Rt = Rt + Math.imul(Br, fr) | 0, Rt = Rt + Math.imul(Ir, Zr) | 0, Ht = Ht + Math.imul(Ir, fr) | 0, Nt = Nt + Math.imul(_r, ur) | 0, Rt = Rt + Math.imul(_r, jt) | 0, Rt = Rt + Math.imul(Ar, ur) | 0, Ht = Ht + Math.imul(Ar, jt) | 0, Nt = Nt + Math.imul(er, Lt) | 0, Rt = Rt + Math.imul(er, Qt) | 0, Rt = Rt + Math.imul(Zt, Lt) | 0, Ht = Ht + Math.imul(Zt, Qt) | 0, Nt = Nt + Math.imul(Xt, hr) | 0, Rt = Rt + Math.imul(Xt, yr) | 0, Rt = Rt + Math.imul(sr, hr) | 0, Ht = Ht + Math.imul(sr, yr) | 0, Nt = Nt + Math.imul(lr, Rr) | 0, Rt = Rt + Math.imul(lr, ir) | 0, Rt = Rt + Math.imul(nr, Rr) | 0, Ht = Ht + Math.imul(nr, ir) | 0;
        var nn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, Nt = Math.imul(Jr, br), Rt = Math.imul(Jr, gr), Rt = Rt + Math.imul(Jt, br) | 0, Ht = Math.imul(Jt, gr), Nt = Nt + Math.imul(Yr, Wr) | 0, Rt = Rt + Math.imul(Yr, kr) | 0, Rt = Rt + Math.imul(Nr, Wr) | 0, Ht = Ht + Math.imul(Nr, kr) | 0, Nt = Nt + Math.imul(Cr, Lr) | 0, Rt = Rt + Math.imul(Cr, Fr) | 0, Rt = Rt + Math.imul(Tr, Lr) | 0, Ht = Ht + Math.imul(Tr, Fr) | 0, Nt = Nt + Math.imul(Gr, Zr) | 0, Rt = Rt + Math.imul(Gr, fr) | 0, Rt = Rt + Math.imul(Pr, Zr) | 0, Ht = Ht + Math.imul(Pr, fr) | 0, Nt = Nt + Math.imul(Br, ur) | 0, Rt = Rt + Math.imul(Br, jt) | 0, Rt = Rt + Math.imul(Ir, ur) | 0, Ht = Ht + Math.imul(Ir, jt) | 0, Nt = Nt + Math.imul(_r, Lt) | 0, Rt = Rt + Math.imul(_r, Qt) | 0, Rt = Rt + Math.imul(Ar, Lt) | 0, Ht = Ht + Math.imul(Ar, Qt) | 0, Nt = Nt + Math.imul(er, hr) | 0, Rt = Rt + Math.imul(er, yr) | 0, Rt = Rt + Math.imul(Zt, hr) | 0, Ht = Ht + Math.imul(Zt, yr) | 0, Nt = Nt + Math.imul(Xt, Rr) | 0, Rt = Rt + Math.imul(Xt, ir) | 0, Rt = Rt + Math.imul(sr, Rr) | 0, Ht = Ht + Math.imul(sr, ir) | 0, Nt = Nt + Math.imul(lr, Er) | 0, Rt = Rt + Math.imul(lr, $r) | 0, Rt = Rt + Math.imul(nr, Er) | 0, Ht = Ht + Math.imul(nr, $r) | 0;
        var fn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, Nt = Math.imul(Gt, br), Rt = Math.imul(Gt, gr), Rt = Rt + Math.imul(rr, br) | 0, Ht = Math.imul(rr, gr), Nt = Nt + Math.imul(Jr, Wr) | 0, Rt = Rt + Math.imul(Jr, kr) | 0, Rt = Rt + Math.imul(Jt, Wr) | 0, Ht = Ht + Math.imul(Jt, kr) | 0, Nt = Nt + Math.imul(Yr, Lr) | 0, Rt = Rt + Math.imul(Yr, Fr) | 0, Rt = Rt + Math.imul(Nr, Lr) | 0, Ht = Ht + Math.imul(Nr, Fr) | 0, Nt = Nt + Math.imul(Cr, Zr) | 0, Rt = Rt + Math.imul(Cr, fr) | 0, Rt = Rt + Math.imul(Tr, Zr) | 0, Ht = Ht + Math.imul(Tr, fr) | 0, Nt = Nt + Math.imul(Gr, ur) | 0, Rt = Rt + Math.imul(Gr, jt) | 0, Rt = Rt + Math.imul(Pr, ur) | 0, Ht = Ht + Math.imul(Pr, jt) | 0, Nt = Nt + Math.imul(Br, Lt) | 0, Rt = Rt + Math.imul(Br, Qt) | 0, Rt = Rt + Math.imul(Ir, Lt) | 0, Ht = Ht + Math.imul(Ir, Qt) | 0, Nt = Nt + Math.imul(_r, hr) | 0, Rt = Rt + Math.imul(_r, yr) | 0, Rt = Rt + Math.imul(Ar, hr) | 0, Ht = Ht + Math.imul(Ar, yr) | 0, Nt = Nt + Math.imul(er, Rr) | 0, Rt = Rt + Math.imul(er, ir) | 0, Rt = Rt + Math.imul(Zt, Rr) | 0, Ht = Ht + Math.imul(Zt, ir) | 0, Nt = Nt + Math.imul(Xt, Er) | 0, Rt = Rt + Math.imul(Xt, $r) | 0, Rt = Rt + Math.imul(sr, Er) | 0, Ht = Ht + Math.imul(sr, $r) | 0, Nt = Nt + Math.imul(lr, Dr) | 0, Rt = Rt + Math.imul(lr, qr) | 0, Rt = Rt + Math.imul(nr, Dr) | 0, Ht = Ht + Math.imul(nr, qr) | 0;
        var un = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, Nt = Math.imul(Gt, Wr), Rt = Math.imul(Gt, kr), Rt = Rt + Math.imul(rr, Wr) | 0, Ht = Math.imul(rr, kr), Nt = Nt + Math.imul(Jr, Lr) | 0, Rt = Rt + Math.imul(Jr, Fr) | 0, Rt = Rt + Math.imul(Jt, Lr) | 0, Ht = Ht + Math.imul(Jt, Fr) | 0, Nt = Nt + Math.imul(Yr, Zr) | 0, Rt = Rt + Math.imul(Yr, fr) | 0, Rt = Rt + Math.imul(Nr, Zr) | 0, Ht = Ht + Math.imul(Nr, fr) | 0, Nt = Nt + Math.imul(Cr, ur) | 0, Rt = Rt + Math.imul(Cr, jt) | 0, Rt = Rt + Math.imul(Tr, ur) | 0, Ht = Ht + Math.imul(Tr, jt) | 0, Nt = Nt + Math.imul(Gr, Lt) | 0, Rt = Rt + Math.imul(Gr, Qt) | 0, Rt = Rt + Math.imul(Pr, Lt) | 0, Ht = Ht + Math.imul(Pr, Qt) | 0, Nt = Nt + Math.imul(Br, hr) | 0, Rt = Rt + Math.imul(Br, yr) | 0, Rt = Rt + Math.imul(Ir, hr) | 0, Ht = Ht + Math.imul(Ir, yr) | 0, Nt = Nt + Math.imul(_r, Rr) | 0, Rt = Rt + Math.imul(_r, ir) | 0, Rt = Rt + Math.imul(Ar, Rr) | 0, Ht = Ht + Math.imul(Ar, ir) | 0, Nt = Nt + Math.imul(er, Er) | 0, Rt = Rt + Math.imul(er, $r) | 0, Rt = Rt + Math.imul(Zt, Er) | 0, Ht = Ht + Math.imul(Zt, $r) | 0, Nt = Nt + Math.imul(Xt, Dr) | 0, Rt = Rt + Math.imul(Xt, qr) | 0, Rt = Rt + Math.imul(sr, Dr) | 0, Ht = Ht + Math.imul(sr, qr) | 0;
        var cn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, Nt = Math.imul(Gt, Lr), Rt = Math.imul(Gt, Fr), Rt = Rt + Math.imul(rr, Lr) | 0, Ht = Math.imul(rr, Fr), Nt = Nt + Math.imul(Jr, Zr) | 0, Rt = Rt + Math.imul(Jr, fr) | 0, Rt = Rt + Math.imul(Jt, Zr) | 0, Ht = Ht + Math.imul(Jt, fr) | 0, Nt = Nt + Math.imul(Yr, ur) | 0, Rt = Rt + Math.imul(Yr, jt) | 0, Rt = Rt + Math.imul(Nr, ur) | 0, Ht = Ht + Math.imul(Nr, jt) | 0, Nt = Nt + Math.imul(Cr, Lt) | 0, Rt = Rt + Math.imul(Cr, Qt) | 0, Rt = Rt + Math.imul(Tr, Lt) | 0, Ht = Ht + Math.imul(Tr, Qt) | 0, Nt = Nt + Math.imul(Gr, hr) | 0, Rt = Rt + Math.imul(Gr, yr) | 0, Rt = Rt + Math.imul(Pr, hr) | 0, Ht = Ht + Math.imul(Pr, yr) | 0, Nt = Nt + Math.imul(Br, Rr) | 0, Rt = Rt + Math.imul(Br, ir) | 0, Rt = Rt + Math.imul(Ir, Rr) | 0, Ht = Ht + Math.imul(Ir, ir) | 0, Nt = Nt + Math.imul(_r, Er) | 0, Rt = Rt + Math.imul(_r, $r) | 0, Rt = Rt + Math.imul(Ar, Er) | 0, Ht = Ht + Math.imul(Ar, $r) | 0, Nt = Nt + Math.imul(er, Dr) | 0, Rt = Rt + Math.imul(er, qr) | 0, Rt = Rt + Math.imul(Zt, Dr) | 0, Ht = Ht + Math.imul(Zt, qr) | 0;
        var ln = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, Nt = Math.imul(Gt, Zr), Rt = Math.imul(Gt, fr), Rt = Rt + Math.imul(rr, Zr) | 0, Ht = Math.imul(rr, fr), Nt = Nt + Math.imul(Jr, ur) | 0, Rt = Rt + Math.imul(Jr, jt) | 0, Rt = Rt + Math.imul(Jt, ur) | 0, Ht = Ht + Math.imul(Jt, jt) | 0, Nt = Nt + Math.imul(Yr, Lt) | 0, Rt = Rt + Math.imul(Yr, Qt) | 0, Rt = Rt + Math.imul(Nr, Lt) | 0, Ht = Ht + Math.imul(Nr, Qt) | 0, Nt = Nt + Math.imul(Cr, hr) | 0, Rt = Rt + Math.imul(Cr, yr) | 0, Rt = Rt + Math.imul(Tr, hr) | 0, Ht = Ht + Math.imul(Tr, yr) | 0, Nt = Nt + Math.imul(Gr, Rr) | 0, Rt = Rt + Math.imul(Gr, ir) | 0, Rt = Rt + Math.imul(Pr, Rr) | 0, Ht = Ht + Math.imul(Pr, ir) | 0, Nt = Nt + Math.imul(Br, Er) | 0, Rt = Rt + Math.imul(Br, $r) | 0, Rt = Rt + Math.imul(Ir, Er) | 0, Ht = Ht + Math.imul(Ir, $r) | 0, Nt = Nt + Math.imul(_r, Dr) | 0, Rt = Rt + Math.imul(_r, qr) | 0, Rt = Rt + Math.imul(Ar, Dr) | 0, Ht = Ht + Math.imul(Ar, qr) | 0;
        var dn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, Nt = Math.imul(Gt, ur), Rt = Math.imul(Gt, jt), Rt = Rt + Math.imul(rr, ur) | 0, Ht = Math.imul(rr, jt), Nt = Nt + Math.imul(Jr, Lt) | 0, Rt = Rt + Math.imul(Jr, Qt) | 0, Rt = Rt + Math.imul(Jt, Lt) | 0, Ht = Ht + Math.imul(Jt, Qt) | 0, Nt = Nt + Math.imul(Yr, hr) | 0, Rt = Rt + Math.imul(Yr, yr) | 0, Rt = Rt + Math.imul(Nr, hr) | 0, Ht = Ht + Math.imul(Nr, yr) | 0, Nt = Nt + Math.imul(Cr, Rr) | 0, Rt = Rt + Math.imul(Cr, ir) | 0, Rt = Rt + Math.imul(Tr, Rr) | 0, Ht = Ht + Math.imul(Tr, ir) | 0, Nt = Nt + Math.imul(Gr, Er) | 0, Rt = Rt + Math.imul(Gr, $r) | 0, Rt = Rt + Math.imul(Pr, Er) | 0, Ht = Ht + Math.imul(Pr, $r) | 0, Nt = Nt + Math.imul(Br, Dr) | 0, Rt = Rt + Math.imul(Br, qr) | 0, Rt = Rt + Math.imul(Ir, Dr) | 0, Ht = Ht + Math.imul(Ir, qr) | 0;
        var hn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, Nt = Math.imul(Gt, Lt), Rt = Math.imul(Gt, Qt), Rt = Rt + Math.imul(rr, Lt) | 0, Ht = Math.imul(rr, Qt), Nt = Nt + Math.imul(Jr, hr) | 0, Rt = Rt + Math.imul(Jr, yr) | 0, Rt = Rt + Math.imul(Jt, hr) | 0, Ht = Ht + Math.imul(Jt, yr) | 0, Nt = Nt + Math.imul(Yr, Rr) | 0, Rt = Rt + Math.imul(Yr, ir) | 0, Rt = Rt + Math.imul(Nr, Rr) | 0, Ht = Ht + Math.imul(Nr, ir) | 0, Nt = Nt + Math.imul(Cr, Er) | 0, Rt = Rt + Math.imul(Cr, $r) | 0, Rt = Rt + Math.imul(Tr, Er) | 0, Ht = Ht + Math.imul(Tr, $r) | 0, Nt = Nt + Math.imul(Gr, Dr) | 0, Rt = Rt + Math.imul(Gr, qr) | 0, Rt = Rt + Math.imul(Pr, Dr) | 0, Ht = Ht + Math.imul(Pr, qr) | 0;
        var pn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, Nt = Math.imul(Gt, hr), Rt = Math.imul(Gt, yr), Rt = Rt + Math.imul(rr, hr) | 0, Ht = Math.imul(rr, yr), Nt = Nt + Math.imul(Jr, Rr) | 0, Rt = Rt + Math.imul(Jr, ir) | 0, Rt = Rt + Math.imul(Jt, Rr) | 0, Ht = Ht + Math.imul(Jt, ir) | 0, Nt = Nt + Math.imul(Yr, Er) | 0, Rt = Rt + Math.imul(Yr, $r) | 0, Rt = Rt + Math.imul(Nr, Er) | 0, Ht = Ht + Math.imul(Nr, $r) | 0, Nt = Nt + Math.imul(Cr, Dr) | 0, Rt = Rt + Math.imul(Cr, qr) | 0, Rt = Rt + Math.imul(Tr, Dr) | 0, Ht = Ht + Math.imul(Tr, qr) | 0;
        var yn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, Nt = Math.imul(Gt, Rr), Rt = Math.imul(Gt, ir), Rt = Rt + Math.imul(rr, Rr) | 0, Ht = Math.imul(rr, ir), Nt = Nt + Math.imul(Jr, Er) | 0, Rt = Rt + Math.imul(Jr, $r) | 0, Rt = Rt + Math.imul(Jt, Er) | 0, Ht = Ht + Math.imul(Jt, $r) | 0, Nt = Nt + Math.imul(Yr, Dr) | 0, Rt = Rt + Math.imul(Yr, qr) | 0, Rt = Rt + Math.imul(Nr, Dr) | 0, Ht = Ht + Math.imul(Nr, qr) | 0;
        var mn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, Nt = Math.imul(Gt, Er), Rt = Math.imul(Gt, $r), Rt = Rt + Math.imul(rr, Er) | 0, Ht = Math.imul(rr, $r), Nt = Nt + Math.imul(Jr, Dr) | 0, Rt = Rt + Math.imul(Jr, qr) | 0, Rt = Rt + Math.imul(Jt, Dr) | 0, Ht = Ht + Math.imul(Jt, qr) | 0;
        var vn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        xt = (Ht + (Rt >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, Nt = Math.imul(Gt, Dr), Rt = Math.imul(Gt, qr), Rt = Rt + Math.imul(rr, Dr) | 0, Ht = Math.imul(rr, qr);
        var gn = (xt + Nt | 0) + ((Rt & 8191) << 13) | 0;
        return xt = (Ht + (Rt >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, kt[0] = Vr, kt[1] = tn, kt[2] = Qr, kt[3] = en, kt[4] = on, kt[5] = sn, kt[6] = an, kt[7] = nn, kt[8] = fn, kt[9] = un, kt[10] = cn, kt[11] = ln, kt[12] = dn, kt[13] = hn, kt[14] = pn, kt[15] = yn, kt[16] = mn, kt[17] = vn, kt[18] = gn, xt !== 0 && (kt[19] = xt, bt.length++), bt;
      };
      Math.imul || (vt = Pt);
      function Bt(Je, Ke, Qe) {
        Qe.negative = Ke.negative ^ Je.negative, Qe.length = Je.length + Ke.length;
        for (var bt = 0, _t = 0, $t = 0; $t < Qe.length - 1; $t++) {
          var kt = _t;
          _t = 0;
          for (var xt = bt & 67108863, Nt = Math.min($t, Ke.length - 1), Rt = Math.max(0, $t - Je.length + 1); Rt <= Nt; Rt++) {
            var Ht = $t - Rt, ar = Je.words[Ht] | 0, lr = Ke.words[Rt] | 0, nr = ar * lr, Vt = nr & 67108863;
            kt = kt + (nr / 67108864 | 0) | 0, Vt = Vt + xt | 0, xt = Vt & 67108863, kt = kt + (Vt >>> 26) | 0, _t += kt >>> 26, kt &= 67108863;
          }
          Qe.words[$t] = xt, bt = kt, kt = _t;
        }
        return bt !== 0 ? Qe.words[$t] = bt : Qe.length--, Qe._strip();
      }
      function Ct(Je, Ke, Qe) {
        return Bt(Je, Ke, Qe);
      }
      ie.prototype.mulTo = function(Ke, Qe) {
        var bt, _t = this.length + Ke.length;
        return this.length === 10 && Ke.length === 10 ? bt = vt(this, Ke, Qe) : _t < 63 ? bt = Pt(this, Ke, Qe) : _t < 1024 ? bt = Bt(this, Ke, Qe) : bt = Ct(this, Ke, Qe), bt;
      }, ie.prototype.mul = function(Ke) {
        var Qe = new ie(null);
        return Qe.words = new Array(this.length + Ke.length), this.mulTo(Ke, Qe);
      }, ie.prototype.mulf = function(Ke) {
        var Qe = new ie(null);
        return Qe.words = new Array(this.length + Ke.length), Ct(this, Ke, Qe);
      }, ie.prototype.imul = function(Ke) {
        return this.clone().mulTo(Ke, this);
      }, ie.prototype.imuln = function(Ke) {
        var Qe = Ke < 0;
        Qe && (Ke = -Ke), ne(typeof Ke == "number"), ne(Ke < 67108864);
        for (var bt = 0, _t = 0; _t < this.length; _t++) {
          var $t = (this.words[_t] | 0) * Ke, kt = ($t & 67108863) + (bt & 67108863);
          bt >>= 26, bt += $t / 67108864 | 0, bt += kt >>> 26, this.words[_t] = kt & 67108863;
        }
        return bt !== 0 && (this.words[_t] = bt, this.length++), Qe ? this.ineg() : this;
      }, ie.prototype.muln = function(Ke) {
        return this.clone().imuln(Ke);
      }, ie.prototype.sqr = function() {
        return this.mul(this);
      }, ie.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ie.prototype.pow = function(Ke) {
        var Qe = wt(Ke);
        if (Qe.length === 0) return new ie(1);
        for (var bt = this, _t = 0; _t < Qe.length && Qe[_t] === 0; _t++, bt = bt.sqr())
          ;
        if (++_t < Qe.length)
          for (var $t = bt.sqr(); _t < Qe.length; _t++, $t = $t.sqr())
            Qe[_t] !== 0 && (bt = bt.mul($t));
        return bt;
      }, ie.prototype.iushln = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Ke % 26, bt = (Ke - Qe) / 26, _t = 67108863 >>> 26 - Qe << 26 - Qe, $t;
        if (Qe !== 0) {
          var kt = 0;
          for ($t = 0; $t < this.length; $t++) {
            var xt = this.words[$t] & _t, Nt = (this.words[$t] | 0) - xt << Qe;
            this.words[$t] = Nt | kt, kt = xt >>> 26 - Qe;
          }
          kt && (this.words[$t] = kt, this.length++);
        }
        if (bt !== 0) {
          for ($t = this.length - 1; $t >= 0; $t--)
            this.words[$t + bt] = this.words[$t];
          for ($t = 0; $t < bt; $t++)
            this.words[$t] = 0;
          this.length += bt;
        }
        return this._strip();
      }, ie.prototype.ishln = function(Ke) {
        return ne(this.negative === 0), this.iushln(Ke);
      }, ie.prototype.iushrn = function(Ke, Qe, bt) {
        ne(typeof Ke == "number" && Ke >= 0);
        var _t;
        Qe ? _t = (Qe - Qe % 26) / 26 : _t = 0;
        var $t = Ke % 26, kt = Math.min((Ke - $t) / 26, this.length), xt = 67108863 ^ 67108863 >>> $t << $t, Nt = bt;
        if (_t -= kt, _t = Math.max(0, _t), Nt) {
          for (var Rt = 0; Rt < kt; Rt++)
            Nt.words[Rt] = this.words[Rt];
          Nt.length = kt;
        }
        if (kt !== 0) if (this.length > kt)
          for (this.length -= kt, Rt = 0; Rt < this.length; Rt++)
            this.words[Rt] = this.words[Rt + kt];
        else
          this.words[0] = 0, this.length = 1;
        var Ht = 0;
        for (Rt = this.length - 1; Rt >= 0 && (Ht !== 0 || Rt >= _t); Rt--) {
          var ar = this.words[Rt] | 0;
          this.words[Rt] = Ht << 26 - $t | ar >>> $t, Ht = ar & xt;
        }
        return Nt && Ht !== 0 && (Nt.words[Nt.length++] = Ht), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, ie.prototype.ishrn = function(Ke, Qe, bt) {
        return ne(this.negative === 0), this.iushrn(Ke, Qe, bt);
      }, ie.prototype.shln = function(Ke) {
        return this.clone().ishln(Ke);
      }, ie.prototype.ushln = function(Ke) {
        return this.clone().iushln(Ke);
      }, ie.prototype.shrn = function(Ke) {
        return this.clone().ishrn(Ke);
      }, ie.prototype.ushrn = function(Ke) {
        return this.clone().iushrn(Ke);
      }, ie.prototype.testn = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Ke % 26, bt = (Ke - Qe) / 26, _t = 1 << Qe;
        if (this.length <= bt) return !1;
        var $t = this.words[bt];
        return !!($t & _t);
      }, ie.prototype.imaskn = function(Ke) {
        ne(typeof Ke == "number" && Ke >= 0);
        var Qe = Ke % 26, bt = (Ke - Qe) / 26;
        if (ne(this.negative === 0, "imaskn works only with positive numbers"), this.length <= bt)
          return this;
        if (Qe !== 0 && bt++, this.length = Math.min(bt, this.length), Qe !== 0) {
          var _t = 67108863 ^ 67108863 >>> Qe << Qe;
          this.words[this.length - 1] &= _t;
        }
        return this._strip();
      }, ie.prototype.maskn = function(Ke) {
        return this.clone().imaskn(Ke);
      }, ie.prototype.iaddn = function(Ke) {
        return ne(typeof Ke == "number"), ne(Ke < 67108864), Ke < 0 ? this.isubn(-Ke) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= Ke ? (this.words[0] = Ke - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(Ke), this.negative = 1, this) : this._iaddn(Ke);
      }, ie.prototype._iaddn = function(Ke) {
        this.words[0] += Ke;
        for (var Qe = 0; Qe < this.length && this.words[Qe] >= 67108864; Qe++)
          this.words[Qe] -= 67108864, Qe === this.length - 1 ? this.words[Qe + 1] = 1 : this.words[Qe + 1]++;
        return this.length = Math.max(this.length, Qe + 1), this;
      }, ie.prototype.isubn = function(Ke) {
        if (ne(typeof Ke == "number"), ne(Ke < 67108864), Ke < 0) return this.iaddn(-Ke);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(Ke), this.negative = 1, this;
        if (this.words[0] -= Ke, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Qe = 0; Qe < this.length && this.words[Qe] < 0; Qe++)
            this.words[Qe] += 67108864, this.words[Qe + 1] -= 1;
        return this._strip();
      }, ie.prototype.addn = function(Ke) {
        return this.clone().iaddn(Ke);
      }, ie.prototype.subn = function(Ke) {
        return this.clone().isubn(Ke);
      }, ie.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ie.prototype.abs = function() {
        return this.clone().iabs();
      }, ie.prototype._ishlnsubmul = function(Ke, Qe, bt) {
        var _t = Ke.length + bt, $t;
        this._expand(_t);
        var kt, xt = 0;
        for ($t = 0; $t < Ke.length; $t++) {
          kt = (this.words[$t + bt] | 0) + xt;
          var Nt = (Ke.words[$t] | 0) * Qe;
          kt -= Nt & 67108863, xt = (kt >> 26) - (Nt / 67108864 | 0), this.words[$t + bt] = kt & 67108863;
        }
        for (; $t < this.length - bt; $t++)
          kt = (this.words[$t + bt] | 0) + xt, xt = kt >> 26, this.words[$t + bt] = kt & 67108863;
        if (xt === 0) return this._strip();
        for (ne(xt === -1), xt = 0, $t = 0; $t < this.length; $t++)
          kt = -(this.words[$t] | 0) + xt, xt = kt >> 26, this.words[$t] = kt & 67108863;
        return this.negative = 1, this._strip();
      }, ie.prototype._wordDiv = function(Ke, Qe) {
        var bt = this.length - Ke.length, _t = this.clone(), $t = Ke, kt = $t.words[$t.length - 1] | 0, xt = this._countBits(kt);
        bt = 26 - xt, bt !== 0 && ($t = $t.ushln(bt), _t.iushln(bt), kt = $t.words[$t.length - 1] | 0);
        var Nt = _t.length - $t.length, Rt;
        if (Qe !== "mod") {
          Rt = new ie(null), Rt.length = Nt + 1, Rt.words = new Array(Rt.length);
          for (var Ht = 0; Ht < Rt.length; Ht++)
            Rt.words[Ht] = 0;
        }
        var ar = _t.clone()._ishlnsubmul($t, 1, Nt);
        ar.negative === 0 && (_t = ar, Rt && (Rt.words[Nt] = 1));
        for (var lr = Nt - 1; lr >= 0; lr--) {
          var nr = (_t.words[$t.length + lr] | 0) * 67108864 + (_t.words[$t.length + lr - 1] | 0);
          for (nr = Math.min(nr / kt | 0, 67108863), _t._ishlnsubmul($t, nr, lr); _t.negative !== 0; )
            nr--, _t.negative = 0, _t._ishlnsubmul($t, 1, lr), _t.isZero() || (_t.negative ^= 1);
          Rt && (Rt.words[lr] = nr);
        }
        return Rt && Rt._strip(), _t._strip(), Qe !== "div" && bt !== 0 && _t.iushrn(bt), {
          div: Rt || null,
          mod: _t
        };
      }, ie.prototype.divmod = function(Ke, Qe, bt) {
        if (ne(!Ke.isZero()), this.isZero())
          return {
            div: new ie(0),
            mod: new ie(0)
          };
        var _t, $t, kt;
        return this.negative !== 0 && Ke.negative === 0 ? (kt = this.neg().divmod(Ke, Qe), Qe !== "mod" && (_t = kt.div.neg()), Qe !== "div" && ($t = kt.mod.neg(), bt && $t.negative !== 0 && $t.iadd(Ke)), {
          div: _t,
          mod: $t
        }) : this.negative === 0 && Ke.negative !== 0 ? (kt = this.divmod(Ke.neg(), Qe), Qe !== "mod" && (_t = kt.div.neg()), {
          div: _t,
          mod: kt.mod
        }) : this.negative & Ke.negative ? (kt = this.neg().divmod(Ke.neg(), Qe), Qe !== "div" && ($t = kt.mod.neg(), bt && $t.negative !== 0 && $t.isub(Ke)), {
          div: kt.div,
          mod: $t
        }) : Ke.length > this.length || this.cmp(Ke) < 0 ? {
          div: new ie(0),
          mod: this
        } : Ke.length === 1 ? Qe === "div" ? {
          div: this.divn(Ke.words[0]),
          mod: null
        } : Qe === "mod" ? {
          div: null,
          mod: new ie(this.modrn(Ke.words[0]))
        } : {
          div: this.divn(Ke.words[0]),
          mod: new ie(this.modrn(Ke.words[0]))
        } : this._wordDiv(Ke, Qe);
      }, ie.prototype.div = function(Ke) {
        return this.divmod(Ke, "div", !1).div;
      }, ie.prototype.mod = function(Ke) {
        return this.divmod(Ke, "mod", !1).mod;
      }, ie.prototype.umod = function(Ke) {
        return this.divmod(Ke, "mod", !0).mod;
      }, ie.prototype.divRound = function(Ke) {
        var Qe = this.divmod(Ke);
        if (Qe.mod.isZero()) return Qe.div;
        var bt = Qe.div.negative !== 0 ? Qe.mod.isub(Ke) : Qe.mod, _t = Ke.ushrn(1), $t = Ke.andln(1), kt = bt.cmp(_t);
        return kt < 0 || $t === 1 && kt === 0 ? Qe.div : Qe.div.negative !== 0 ? Qe.div.isubn(1) : Qe.div.iaddn(1);
      }, ie.prototype.modrn = function(Ke) {
        var Qe = Ke < 0;
        Qe && (Ke = -Ke), ne(Ke <= 67108863);
        for (var bt = (1 << 26) % Ke, _t = 0, $t = this.length - 1; $t >= 0; $t--)
          _t = (bt * _t + (this.words[$t] | 0)) % Ke;
        return Qe ? -_t : _t;
      }, ie.prototype.modn = function(Ke) {
        return this.modrn(Ke);
      }, ie.prototype.idivn = function(Ke) {
        var Qe = Ke < 0;
        Qe && (Ke = -Ke), ne(Ke <= 67108863);
        for (var bt = 0, _t = this.length - 1; _t >= 0; _t--) {
          var $t = (this.words[_t] | 0) + bt * 67108864;
          this.words[_t] = $t / Ke | 0, bt = $t % Ke;
        }
        return this._strip(), Qe ? this.ineg() : this;
      }, ie.prototype.divn = function(Ke) {
        return this.clone().idivn(Ke);
      }, ie.prototype.egcd = function(Ke) {
        ne(Ke.negative === 0), ne(!Ke.isZero());
        var Qe = this, bt = Ke.clone();
        Qe.negative !== 0 ? Qe = Qe.umod(Ke) : Qe = Qe.clone();
        for (var _t = new ie(1), $t = new ie(0), kt = new ie(0), xt = new ie(1), Nt = 0; Qe.isEven() && bt.isEven(); )
          Qe.iushrn(1), bt.iushrn(1), ++Nt;
        for (var Rt = bt.clone(), Ht = Qe.clone(); !Qe.isZero(); ) {
          for (var ar = 0, lr = 1; !(Qe.words[0] & lr) && ar < 26; ++ar, lr <<= 1) ;
          if (ar > 0)
            for (Qe.iushrn(ar); ar-- > 0; )
              (_t.isOdd() || $t.isOdd()) && (_t.iadd(Rt), $t.isub(Ht)), _t.iushrn(1), $t.iushrn(1);
          for (var nr = 0, Vt = 1; !(bt.words[0] & Vt) && nr < 26; ++nr, Vt <<= 1) ;
          if (nr > 0)
            for (bt.iushrn(nr); nr-- > 0; )
              (kt.isOdd() || xt.isOdd()) && (kt.iadd(Rt), xt.isub(Ht)), kt.iushrn(1), xt.iushrn(1);
          Qe.cmp(bt) >= 0 ? (Qe.isub(bt), _t.isub(kt), $t.isub(xt)) : (bt.isub(Qe), kt.isub(_t), xt.isub($t));
        }
        return {
          a: kt,
          b: xt,
          gcd: bt.iushln(Nt)
        };
      }, ie.prototype._invmp = function(Ke) {
        ne(Ke.negative === 0), ne(!Ke.isZero());
        var Qe = this, bt = Ke.clone();
        Qe.negative !== 0 ? Qe = Qe.umod(Ke) : Qe = Qe.clone();
        for (var _t = new ie(1), $t = new ie(0), kt = bt.clone(); Qe.cmpn(1) > 0 && bt.cmpn(1) > 0; ) {
          for (var xt = 0, Nt = 1; !(Qe.words[0] & Nt) && xt < 26; ++xt, Nt <<= 1) ;
          if (xt > 0)
            for (Qe.iushrn(xt); xt-- > 0; )
              _t.isOdd() && _t.iadd(kt), _t.iushrn(1);
          for (var Rt = 0, Ht = 1; !(bt.words[0] & Ht) && Rt < 26; ++Rt, Ht <<= 1) ;
          if (Rt > 0)
            for (bt.iushrn(Rt); Rt-- > 0; )
              $t.isOdd() && $t.iadd(kt), $t.iushrn(1);
          Qe.cmp(bt) >= 0 ? (Qe.isub(bt), _t.isub($t)) : (bt.isub(Qe), $t.isub(_t));
        }
        var ar;
        return Qe.cmpn(1) === 0 ? ar = _t : ar = $t, ar.cmpn(0) < 0 && ar.iadd(Ke), ar;
      }, ie.prototype.gcd = function(Ke) {
        if (this.isZero()) return Ke.abs();
        if (Ke.isZero()) return this.abs();
        var Qe = this.clone(), bt = Ke.clone();
        Qe.negative = 0, bt.negative = 0;
        for (var _t = 0; Qe.isEven() && bt.isEven(); _t++)
          Qe.iushrn(1), bt.iushrn(1);
        do {
          for (; Qe.isEven(); )
            Qe.iushrn(1);
          for (; bt.isEven(); )
            bt.iushrn(1);
          var $t = Qe.cmp(bt);
          if ($t < 0) {
            var kt = Qe;
            Qe = bt, bt = kt;
          } else if ($t === 0 || bt.cmpn(1) === 0)
            break;
          Qe.isub(bt);
        } while (!0);
        return bt.iushln(_t);
      }, ie.prototype.invm = function(Ke) {
        return this.egcd(Ke).a.umod(Ke);
      }, ie.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ie.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ie.prototype.andln = function(Ke) {
        return this.words[0] & Ke;
      }, ie.prototype.bincn = function(Ke) {
        ne(typeof Ke == "number");
        var Qe = Ke % 26, bt = (Ke - Qe) / 26, _t = 1 << Qe;
        if (this.length <= bt)
          return this._expand(bt + 1), this.words[bt] |= _t, this;
        for (var $t = _t, kt = bt; $t !== 0 && kt < this.length; kt++) {
          var xt = this.words[kt] | 0;
          xt += $t, $t = xt >>> 26, xt &= 67108863, this.words[kt] = xt;
        }
        return $t !== 0 && (this.words[kt] = $t, this.length++), this;
      }, ie.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ie.prototype.cmpn = function(Ke) {
        var Qe = Ke < 0;
        if (this.negative !== 0 && !Qe) return -1;
        if (this.negative === 0 && Qe) return 1;
        this._strip();
        var bt;
        if (this.length > 1)
          bt = 1;
        else {
          Qe && (Ke = -Ke), ne(Ke <= 67108863, "Number is too big");
          var _t = this.words[0] | 0;
          bt = _t === Ke ? 0 : _t < Ke ? -1 : 1;
        }
        return this.negative !== 0 ? -bt | 0 : bt;
      }, ie.prototype.cmp = function(Ke) {
        if (this.negative !== 0 && Ke.negative === 0) return -1;
        if (this.negative === 0 && Ke.negative !== 0) return 1;
        var Qe = this.ucmp(Ke);
        return this.negative !== 0 ? -Qe | 0 : Qe;
      }, ie.prototype.ucmp = function(Ke) {
        if (this.length > Ke.length) return 1;
        if (this.length < Ke.length) return -1;
        for (var Qe = 0, bt = this.length - 1; bt >= 0; bt--) {
          var _t = this.words[bt] | 0, $t = Ke.words[bt] | 0;
          if (_t !== $t) {
            _t < $t ? Qe = -1 : _t > $t && (Qe = 1);
            break;
          }
        }
        return Qe;
      }, ie.prototype.gtn = function(Ke) {
        return this.cmpn(Ke) === 1;
      }, ie.prototype.gt = function(Ke) {
        return this.cmp(Ke) === 1;
      }, ie.prototype.gten = function(Ke) {
        return this.cmpn(Ke) >= 0;
      }, ie.prototype.gte = function(Ke) {
        return this.cmp(Ke) >= 0;
      }, ie.prototype.ltn = function(Ke) {
        return this.cmpn(Ke) === -1;
      }, ie.prototype.lt = function(Ke) {
        return this.cmp(Ke) === -1;
      }, ie.prototype.lten = function(Ke) {
        return this.cmpn(Ke) <= 0;
      }, ie.prototype.lte = function(Ke) {
        return this.cmp(Ke) <= 0;
      }, ie.prototype.eqn = function(Ke) {
        return this.cmpn(Ke) === 0;
      }, ie.prototype.eq = function(Ke) {
        return this.cmp(Ke) === 0;
      }, ie.red = function(Ke) {
        return new Ft(Ke);
      }, ie.prototype.toRed = function(Ke) {
        return ne(!this.red, "Already a number in reduction context"), ne(this.negative === 0, "red works only with positives"), Ke.convertTo(this)._forceRed(Ke);
      }, ie.prototype.fromRed = function() {
        return ne(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ie.prototype._forceRed = function(Ke) {
        return this.red = Ke, this;
      }, ie.prototype.forceRed = function(Ke) {
        return ne(!this.red, "Already a number in reduction context"), this._forceRed(Ke);
      }, ie.prototype.redAdd = function(Ke) {
        return ne(this.red, "redAdd works only with red numbers"), this.red.add(this, Ke);
      }, ie.prototype.redIAdd = function(Ke) {
        return ne(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, Ke);
      }, ie.prototype.redSub = function(Ke) {
        return ne(this.red, "redSub works only with red numbers"), this.red.sub(this, Ke);
      }, ie.prototype.redISub = function(Ke) {
        return ne(this.red, "redISub works only with red numbers"), this.red.isub(this, Ke);
      }, ie.prototype.redShl = function(Ke) {
        return ne(this.red, "redShl works only with red numbers"), this.red.shl(this, Ke);
      }, ie.prototype.redMul = function(Ke) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ke), this.red.mul(this, Ke);
      }, ie.prototype.redIMul = function(Ke) {
        return ne(this.red, "redMul works only with red numbers"), this.red._verify2(this, Ke), this.red.imul(this, Ke);
      }, ie.prototype.redSqr = function() {
        return ne(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ie.prototype.redISqr = function() {
        return ne(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ie.prototype.redSqrt = function() {
        return ne(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ie.prototype.redInvm = function() {
        return ne(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ie.prototype.redNeg = function() {
        return ne(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ie.prototype.redPow = function(Ke) {
        return ne(this.red && !Ke.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, Ke);
      };
      var Wt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Kt(Je, Ke) {
        this.name = Je, this.p = new ie(Ke, 16), this.n = this.p.bitLength(), this.k = new ie(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Kt.prototype._tmp = function() {
        var Ke = new ie(null);
        return Ke.words = new Array(Math.ceil(this.n / 13)), Ke;
      }, Kt.prototype.ireduce = function(Ke) {
        var Qe = Ke, bt;
        do
          this.split(Qe, this.tmp), Qe = this.imulK(Qe), Qe = Qe.iadd(this.tmp), bt = Qe.bitLength();
        while (bt > this.n);
        var _t = bt < this.n ? -1 : Qe.ucmp(this.p);
        return _t === 0 ? (Qe.words[0] = 0, Qe.length = 1) : _t > 0 ? Qe.isub(this.p) : Qe.strip !== void 0 ? Qe.strip() : Qe._strip(), Qe;
      }, Kt.prototype.split = function(Ke, Qe) {
        Ke.iushrn(this.n, 0, Qe);
      }, Kt.prototype.imulK = function(Ke) {
        return Ke.imul(this.k);
      };
      function Yt() {
        Kt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      oe(Yt, Kt), Yt.prototype.split = function(Ke, Qe) {
        for (var bt = 4194303, _t = Math.min(Ke.length, 9), $t = 0; $t < _t; $t++)
          Qe.words[$t] = Ke.words[$t];
        if (Qe.length = _t, Ke.length <= 9) {
          Ke.words[0] = 0, Ke.length = 1;
          return;
        }
        var kt = Ke.words[9];
        for (Qe.words[Qe.length++] = kt & bt, $t = 10; $t < Ke.length; $t++) {
          var xt = Ke.words[$t] | 0;
          Ke.words[$t - 10] = (xt & bt) << 4 | kt >>> 22, kt = xt;
        }
        kt >>>= 22, Ke.words[$t - 10] = kt, kt === 0 && Ke.length > 10 ? Ke.length -= 10 : Ke.length -= 9;
      }, Yt.prototype.imulK = function(Ke) {
        Ke.words[Ke.length] = 0, Ke.words[Ke.length + 1] = 0, Ke.length += 2;
        for (var Qe = 0, bt = 0; bt < Ke.length; bt++) {
          var _t = Ke.words[bt] | 0;
          Qe += _t * 977, Ke.words[bt] = Qe & 67108863, Qe = _t * 64 + (Qe / 67108864 | 0);
        }
        return Ke.words[Ke.length - 1] === 0 && (Ke.length--, Ke.words[Ke.length - 1] === 0 && Ke.length--), Ke;
      };
      function Ut() {
        Kt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      oe(Ut, Kt);
      function qt() {
        Kt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      oe(qt, Kt);
      function zt() {
        Kt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      oe(zt, Kt), zt.prototype.imulK = function(Ke) {
        for (var Qe = 0, bt = 0; bt < Ke.length; bt++) {
          var _t = (Ke.words[bt] | 0) * 19 + Qe, $t = _t & 67108863;
          _t >>>= 26, Ke.words[bt] = $t, Qe = _t;
        }
        return Qe !== 0 && (Ke.words[Ke.length++] = Qe), Ke;
      }, ie._prime = function(Ke) {
        if (Wt[Ke]) return Wt[Ke];
        var Qe;
        if (Ke === "k256")
          Qe = new Yt();
        else if (Ke === "p224")
          Qe = new Ut();
        else if (Ke === "p192")
          Qe = new qt();
        else if (Ke === "p25519")
          Qe = new zt();
        else
          throw new Error("Unknown prime " + Ke);
        return Wt[Ke] = Qe, Qe;
      };
      function Ft(Je) {
        if (typeof Je == "string") {
          var Ke = ie._prime(Je);
          this.m = Ke.p, this.prime = Ke;
        } else
          ne(Je.gtn(1), "modulus must be greater than 1"), this.m = Je, this.prime = null;
      }
      Ft.prototype._verify1 = function(Ke) {
        ne(Ke.negative === 0, "red works only with positives"), ne(Ke.red, "red works only with red numbers");
      }, Ft.prototype._verify2 = function(Ke, Qe) {
        ne((Ke.negative | Qe.negative) === 0, "red works only with positives"), ne(
          Ke.red && Ke.red === Qe.red,
          "red works only with red numbers"
        );
      }, Ft.prototype.imod = function(Ke) {
        return this.prime ? this.prime.ireduce(Ke)._forceRed(this) : (le(Ke, Ke.umod(this.m)._forceRed(this)), Ke);
      }, Ft.prototype.neg = function(Ke) {
        return Ke.isZero() ? Ke.clone() : this.m.sub(Ke)._forceRed(this);
      }, Ft.prototype.add = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.add(Qe);
        return bt.cmp(this.m) >= 0 && bt.isub(this.m), bt._forceRed(this);
      }, Ft.prototype.iadd = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.iadd(Qe);
        return bt.cmp(this.m) >= 0 && bt.isub(this.m), bt;
      }, Ft.prototype.sub = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.sub(Qe);
        return bt.cmpn(0) < 0 && bt.iadd(this.m), bt._forceRed(this);
      }, Ft.prototype.isub = function(Ke, Qe) {
        this._verify2(Ke, Qe);
        var bt = Ke.isub(Qe);
        return bt.cmpn(0) < 0 && bt.iadd(this.m), bt;
      }, Ft.prototype.shl = function(Ke, Qe) {
        return this._verify1(Ke), this.imod(Ke.ushln(Qe));
      }, Ft.prototype.imul = function(Ke, Qe) {
        return this._verify2(Ke, Qe), this.imod(Ke.imul(Qe));
      }, Ft.prototype.mul = function(Ke, Qe) {
        return this._verify2(Ke, Qe), this.imod(Ke.mul(Qe));
      }, Ft.prototype.isqr = function(Ke) {
        return this.imul(Ke, Ke.clone());
      }, Ft.prototype.sqr = function(Ke) {
        return this.mul(Ke, Ke);
      }, Ft.prototype.sqrt = function(Ke) {
        if (Ke.isZero()) return Ke.clone();
        var Qe = this.m.andln(3);
        if (ne(Qe % 2 === 1), Qe === 3) {
          var bt = this.m.add(new ie(1)).iushrn(2);
          return this.pow(Ke, bt);
        }
        for (var _t = this.m.subn(1), $t = 0; !_t.isZero() && _t.andln(1) === 0; )
          $t++, _t.iushrn(1);
        ne(!_t.isZero());
        var kt = new ie(1).toRed(this), xt = kt.redNeg(), Nt = this.m.subn(1).iushrn(1), Rt = this.m.bitLength();
        for (Rt = new ie(2 * Rt * Rt).toRed(this); this.pow(Rt, Nt).cmp(xt) !== 0; )
          Rt.redIAdd(xt);
        for (var Ht = this.pow(Rt, _t), ar = this.pow(Ke, _t.addn(1).iushrn(1)), lr = this.pow(Ke, _t), nr = $t; lr.cmp(kt) !== 0; ) {
          for (var Vt = lr, Xt = 0; Vt.cmp(kt) !== 0; Xt++)
            Vt = Vt.redSqr();
          ne(Xt < nr);
          var sr = this.pow(Ht, new ie(1).iushln(nr - Xt - 1));
          ar = ar.redMul(sr), Ht = sr.redSqr(), lr = lr.redMul(Ht), nr = Xt;
        }
        return ar;
      }, Ft.prototype.invm = function(Ke) {
        var Qe = Ke._invmp(this.m);
        return Qe.negative !== 0 ? (Qe.negative = 0, this.imod(Qe).redNeg()) : this.imod(Qe);
      }, Ft.prototype.pow = function(Ke, Qe) {
        if (Qe.isZero()) return new ie(1).toRed(this);
        if (Qe.cmpn(1) === 0) return Ke.clone();
        var bt = 4, _t = new Array(1 << bt);
        _t[0] = new ie(1).toRed(this), _t[1] = Ke;
        for (var $t = 2; $t < _t.length; $t++)
          _t[$t] = this.mul(_t[$t - 1], Ke);
        var kt = _t[0], xt = 0, Nt = 0, Rt = Qe.bitLength() % 26;
        for (Rt === 0 && (Rt = 26), $t = Qe.length - 1; $t >= 0; $t--) {
          for (var Ht = Qe.words[$t], ar = Rt - 1; ar >= 0; ar--) {
            var lr = Ht >> ar & 1;
            if (kt !== _t[0] && (kt = this.sqr(kt)), lr === 0 && xt === 0) {
              Nt = 0;
              continue;
            }
            xt <<= 1, xt |= lr, Nt++, !(Nt !== bt && ($t !== 0 || ar !== 0)) && (kt = this.mul(kt, _t[xt]), Nt = 0, xt = 0);
          }
          Rt = 26;
        }
        return kt;
      }, Ft.prototype.convertTo = function(Ke) {
        var Qe = Ke.umod(this.m);
        return Qe === Ke ? Qe.clone() : Qe;
      }, Ft.prototype.convertFrom = function(Ke) {
        var Qe = Ke.clone();
        return Qe.red = null, Qe;
      }, ie.mont = function(Ke) {
        return new Ve(Ke);
      };
      function Ve(Je) {
        Ft.call(this, Je), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ie(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      oe(Ve, Ft), Ve.prototype.convertTo = function(Ke) {
        return this.imod(Ke.ushln(this.shift));
      }, Ve.prototype.convertFrom = function(Ke) {
        var Qe = this.imod(Ke.mul(this.rinv));
        return Qe.red = null, Qe;
      }, Ve.prototype.imul = function(Ke, Qe) {
        if (Ke.isZero() || Qe.isZero())
          return Ke.words[0] = 0, Ke.length = 1, Ke;
        var bt = Ke.imul(Qe), _t = bt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $t = bt.isub(_t).iushrn(this.shift), kt = $t;
        return $t.cmp(this.m) >= 0 ? kt = $t.isub(this.m) : $t.cmpn(0) < 0 && (kt = $t.iadd(this.m)), kt._forceRed(this);
      }, Ve.prototype.mul = function(Ke, Qe) {
        if (Ke.isZero() || Qe.isZero()) return new ie(0)._forceRed(this);
        var bt = Ke.mul(Qe), _t = bt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), $t = bt.isub(_t).iushrn(this.shift), kt = $t;
        return $t.cmp(this.m) >= 0 ? kt = $t.isub(this.m) : $t.cmpn(0) < 0 && (kt = $t.iadd(this.m)), kt._forceRed(this);
      }, Ve.prototype.invm = function(Ke) {
        var Qe = this.imod(Ke._invmp(this.m).mul(this.r2));
        return Qe._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn)), bn.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var B = requireBn(), z = requireBrowser$b(), Y = safeBufferExports.Buffer;
  function ne(ae) {
    var se = ae.modulus.byteLength(), ve;
    do
      ve = new B(z(se));
    while (ve.cmp(ae.modulus) >= 0 || !ve.umod(ae.prime1) || !ve.umod(ae.prime2));
    return ve;
  }
  function oe(ae) {
    var se = ne(ae), ve = se.toRed(B.mont(ae.modulus)).redPow(new B(ae.publicExponent)).fromRed();
    return { blinder: ve, unblinder: se.invm(ae.modulus) };
  }
  function ie(ae, se) {
    var ve = oe(se), ge = se.modulus.byteLength(), le = new B(ae).mul(ve.blinder).umod(se.modulus), Ee = le.toRed(B.mont(se.prime1)), Ce = le.toRed(B.mont(se.prime2)), Pe = se.coefficient, Xe = se.prime1, ht = se.prime2, wt = Ee.redPow(se.exponent1).fromRed(), Pt = Ce.redPow(se.exponent2).fromRed(), vt = wt.isub(Pt).imul(Pe).umod(Xe).imul(ht);
    return Pt.iadd(vt).imul(ve.unblinder).umod(se.modulus).toArrayLike(Y, "be", ge);
  }
  return ie.getr = ne, browserifyRsa = ie, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(B) {
    var z = B;
    function Y(ie, ae) {
      if (Array.isArray(ie))
        return ie.slice();
      if (!ie)
        return [];
      var se = [];
      if (typeof ie != "string") {
        for (var ve = 0; ve < ie.length; ve++)
          se[ve] = ie[ve] | 0;
        return se;
      }
      if (ae === "hex") {
        ie = ie.replace(/[^a-z0-9]+/ig, ""), ie.length % 2 !== 0 && (ie = "0" + ie);
        for (var ve = 0; ve < ie.length; ve += 2)
          se.push(parseInt(ie[ve] + ie[ve + 1], 16));
      } else
        for (var ve = 0; ve < ie.length; ve++) {
          var ge = ie.charCodeAt(ve), le = ge >> 8, Ee = ge & 255;
          le ? se.push(le, Ee) : se.push(Ee);
        }
      return se;
    }
    z.toArray = Y;
    function ne(ie) {
      return ie.length === 1 ? "0" + ie : ie;
    }
    z.zero2 = ne;
    function oe(ie) {
      for (var ae = "", se = 0; se < ie.length; se++)
        ae += ne(ie[se].toString(16));
      return ae;
    }
    z.toHex = oe, z.encode = function(ae, se) {
      return se === "hex" ? oe(ae) : ae;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(B) {
    var z = B, Y = requireBn$1(), ne = requireMinimalisticAssert(), oe = requireUtils$2();
    z.assert = ne, z.toArray = oe.toArray, z.zero2 = oe.zero2, z.toHex = oe.toHex, z.encode = oe.encode;
    function ie(le, Ee, Ce) {
      var Pe = new Array(Math.max(le.bitLength(), Ce) + 1), Xe;
      for (Xe = 0; Xe < Pe.length; Xe += 1)
        Pe[Xe] = 0;
      var ht = 1 << Ee + 1, wt = le.clone();
      for (Xe = 0; Xe < Pe.length; Xe++) {
        var Pt, vt = wt.andln(ht - 1);
        wt.isOdd() ? (vt > (ht >> 1) - 1 ? Pt = (ht >> 1) - vt : Pt = vt, wt.isubn(Pt)) : Pt = 0, Pe[Xe] = Pt, wt.iushrn(1);
      }
      return Pe;
    }
    z.getNAF = ie;
    function ae(le, Ee) {
      var Ce = [
        [],
        []
      ];
      le = le.clone(), Ee = Ee.clone();
      for (var Pe = 0, Xe = 0, ht; le.cmpn(-Pe) > 0 || Ee.cmpn(-Xe) > 0; ) {
        var wt = le.andln(3) + Pe & 3, Pt = Ee.andln(3) + Xe & 3;
        wt === 3 && (wt = -1), Pt === 3 && (Pt = -1);
        var vt;
        wt & 1 ? (ht = le.andln(7) + Pe & 7, (ht === 3 || ht === 5) && Pt === 2 ? vt = -wt : vt = wt) : vt = 0, Ce[0].push(vt);
        var Bt;
        Pt & 1 ? (ht = Ee.andln(7) + Xe & 7, (ht === 3 || ht === 5) && wt === 2 ? Bt = -Pt : Bt = Pt) : Bt = 0, Ce[1].push(Bt), 2 * Pe === vt + 1 && (Pe = 1 - Pe), 2 * Xe === Bt + 1 && (Xe = 1 - Xe), le.iushrn(1), Ee.iushrn(1);
      }
      return Ce;
    }
    z.getJSF = ae;
    function se(le, Ee, Ce) {
      var Pe = "_" + Ee;
      le.prototype[Ee] = function() {
        return this[Pe] !== void 0 ? this[Pe] : this[Pe] = Ce.call(this);
      };
    }
    z.cachedProperty = se;
    function ve(le) {
      return typeof le == "string" ? z.toArray(le, "hex") : le;
    }
    z.parseBytes = ve;
    function ge(le) {
      return new Y(le, "hex", "le");
    }
    z.intFromLE = ge;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.getNAF, ne = z.getJSF, oe = z.assert;
  function ie(se, ve) {
    this.type = se, this.p = new B(ve.p, 16), this.red = ve.prime ? B.red(ve.prime) : B.mont(this.p), this.zero = new B(0).toRed(this.red), this.one = new B(1).toRed(this.red), this.two = new B(2).toRed(this.red), this.n = ve.n && new B(ve.n, 16), this.g = ve.g && this.pointFromJSON(ve.g, ve.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var ge = this.n && this.p.div(this.n);
    !ge || ge.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = ie, ie.prototype.point = function() {
    throw new Error("Not implemented");
  }, ie.prototype.validate = function() {
    throw new Error("Not implemented");
  }, ie.prototype._fixedNafMul = function(ve, ge) {
    oe(ve.precomputed);
    var le = ve._getDoubles(), Ee = Y(ge, 1, this._bitLength), Ce = (1 << le.step + 1) - (le.step % 2 === 0 ? 2 : 1);
    Ce /= 3;
    var Pe = [], Xe, ht;
    for (Xe = 0; Xe < Ee.length; Xe += le.step) {
      ht = 0;
      for (var wt = Xe + le.step - 1; wt >= Xe; wt--)
        ht = (ht << 1) + Ee[wt];
      Pe.push(ht);
    }
    for (var Pt = this.jpoint(null, null, null), vt = this.jpoint(null, null, null), Bt = Ce; Bt > 0; Bt--) {
      for (Xe = 0; Xe < Pe.length; Xe++)
        ht = Pe[Xe], ht === Bt ? vt = vt.mixedAdd(le.points[Xe]) : ht === -Bt && (vt = vt.mixedAdd(le.points[Xe].neg()));
      Pt = Pt.add(vt);
    }
    return Pt.toP();
  }, ie.prototype._wnafMul = function(ve, ge) {
    var le = 4, Ee = ve._getNAFPoints(le);
    le = Ee.wnd;
    for (var Ce = Ee.points, Pe = Y(ge, le, this._bitLength), Xe = this.jpoint(null, null, null), ht = Pe.length - 1; ht >= 0; ht--) {
      for (var wt = 0; ht >= 0 && Pe[ht] === 0; ht--)
        wt++;
      if (ht >= 0 && wt++, Xe = Xe.dblp(wt), ht < 0)
        break;
      var Pt = Pe[ht];
      oe(Pt !== 0), ve.type === "affine" ? Pt > 0 ? Xe = Xe.mixedAdd(Ce[Pt - 1 >> 1]) : Xe = Xe.mixedAdd(Ce[-Pt - 1 >> 1].neg()) : Pt > 0 ? Xe = Xe.add(Ce[Pt - 1 >> 1]) : Xe = Xe.add(Ce[-Pt - 1 >> 1].neg());
    }
    return ve.type === "affine" ? Xe.toP() : Xe;
  }, ie.prototype._wnafMulAdd = function(ve, ge, le, Ee, Ce) {
    var Pe = this._wnafT1, Xe = this._wnafT2, ht = this._wnafT3, wt = 0, Pt, vt, Bt;
    for (Pt = 0; Pt < Ee; Pt++) {
      Bt = ge[Pt];
      var Ct = Bt._getNAFPoints(ve);
      Pe[Pt] = Ct.wnd, Xe[Pt] = Ct.points;
    }
    for (Pt = Ee - 1; Pt >= 1; Pt -= 2) {
      var Wt = Pt - 1, Kt = Pt;
      if (Pe[Wt] !== 1 || Pe[Kt] !== 1) {
        ht[Wt] = Y(le[Wt], Pe[Wt], this._bitLength), ht[Kt] = Y(le[Kt], Pe[Kt], this._bitLength), wt = Math.max(ht[Wt].length, wt), wt = Math.max(ht[Kt].length, wt);
        continue;
      }
      var Yt = [
        ge[Wt],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        ge[Kt]
        /* 7 */
      ];
      ge[Wt].y.cmp(ge[Kt].y) === 0 ? (Yt[1] = ge[Wt].add(ge[Kt]), Yt[2] = ge[Wt].toJ().mixedAdd(ge[Kt].neg())) : ge[Wt].y.cmp(ge[Kt].y.redNeg()) === 0 ? (Yt[1] = ge[Wt].toJ().mixedAdd(ge[Kt]), Yt[2] = ge[Wt].add(ge[Kt].neg())) : (Yt[1] = ge[Wt].toJ().mixedAdd(ge[Kt]), Yt[2] = ge[Wt].toJ().mixedAdd(ge[Kt].neg()));
      var Ut = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], qt = ne(le[Wt], le[Kt]);
      for (wt = Math.max(qt[0].length, wt), ht[Wt] = new Array(wt), ht[Kt] = new Array(wt), vt = 0; vt < wt; vt++) {
        var zt = qt[0][vt] | 0, Ft = qt[1][vt] | 0;
        ht[Wt][vt] = Ut[(zt + 1) * 3 + (Ft + 1)], ht[Kt][vt] = 0, Xe[Wt] = Yt;
      }
    }
    var Ve = this.jpoint(null, null, null), Je = this._wnafT4;
    for (Pt = wt; Pt >= 0; Pt--) {
      for (var Ke = 0; Pt >= 0; ) {
        var Qe = !0;
        for (vt = 0; vt < Ee; vt++)
          Je[vt] = ht[vt][Pt] | 0, Je[vt] !== 0 && (Qe = !1);
        if (!Qe)
          break;
        Ke++, Pt--;
      }
      if (Pt >= 0 && Ke++, Ve = Ve.dblp(Ke), Pt < 0)
        break;
      for (vt = 0; vt < Ee; vt++) {
        var bt = Je[vt];
        bt !== 0 && (bt > 0 ? Bt = Xe[vt][bt - 1 >> 1] : bt < 0 && (Bt = Xe[vt][-bt - 1 >> 1].neg()), Bt.type === "affine" ? Ve = Ve.mixedAdd(Bt) : Ve = Ve.add(Bt));
      }
    }
    for (Pt = 0; Pt < Ee; Pt++)
      Xe[Pt] = null;
    return Ce ? Ve : Ve.toP();
  };
  function ae(se, ve) {
    this.curve = se, this.type = ve, this.precomputed = null;
  }
  return ie.BasePoint = ae, ae.prototype.eq = function() {
    throw new Error("Not implemented");
  }, ae.prototype.validate = function() {
    return this.curve.validate(this);
  }, ie.prototype.decodePoint = function(ve, ge) {
    ve = z.toArray(ve, ge);
    var le = this.p.byteLength();
    if ((ve[0] === 4 || ve[0] === 6 || ve[0] === 7) && ve.length - 1 === 2 * le) {
      ve[0] === 6 ? oe(ve[ve.length - 1] % 2 === 0) : ve[0] === 7 && oe(ve[ve.length - 1] % 2 === 1);
      var Ee = this.point(
        ve.slice(1, 1 + le),
        ve.slice(1 + le, 1 + 2 * le)
      );
      return Ee;
    } else if ((ve[0] === 2 || ve[0] === 3) && ve.length - 1 === le)
      return this.pointFromX(ve.slice(1, 1 + le), ve[0] === 3);
    throw new Error("Unknown point format");
  }, ae.prototype.encodeCompressed = function(ve) {
    return this.encode(ve, !0);
  }, ae.prototype._encode = function(ve) {
    var ge = this.curve.p.byteLength(), le = this.getX().toArray("be", ge);
    return ve ? [this.getY().isEven() ? 2 : 3].concat(le) : [4].concat(le, this.getY().toArray("be", ge));
  }, ae.prototype.encode = function(ve, ge) {
    return z.encode(this._encode(ge), ve);
  }, ae.prototype.precompute = function(ve) {
    if (this.precomputed)
      return this;
    var ge = {
      doubles: null,
      naf: null,
      beta: null
    };
    return ge.naf = this._getNAFPoints(8), ge.doubles = this._getDoubles(4, ve), ge.beta = this._getBeta(), this.precomputed = ge, this;
  }, ae.prototype._hasDoubles = function(ve) {
    if (!this.precomputed)
      return !1;
    var ge = this.precomputed.doubles;
    return ge ? ge.points.length >= Math.ceil((ve.bitLength() + 1) / ge.step) : !1;
  }, ae.prototype._getDoubles = function(ve, ge) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var le = [this], Ee = this, Ce = 0; Ce < ge; Ce += ve) {
      for (var Pe = 0; Pe < ve; Pe++)
        Ee = Ee.dbl();
      le.push(Ee);
    }
    return {
      step: ve,
      points: le
    };
  }, ae.prototype._getNAFPoints = function(ve) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var ge = [this], le = (1 << ve) - 1, Ee = le === 1 ? null : this.dbl(), Ce = 1; Ce < le; Ce++)
      ge[Ce] = ge[Ce - 1].add(Ee);
    return {
      wnd: ve,
      points: ge
    };
  }, ae.prototype._getBeta = function() {
    return null;
  }, ae.prototype.dblp = function(ve) {
    for (var ge = this, le = 0; le < ve; le++)
      ge = ge.dbl();
    return ge;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var B = requireUtils$1(), z = requireBn$1(), Y = requireInherits_browser(), ne = requireBase$1(), oe = B.assert;
  function ie(ve) {
    ne.call(this, "short", ve), this.a = new z(ve.a, 16).toRed(this.red), this.b = new z(ve.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ve), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Y(ie, ne), short = ie, ie.prototype._getEndomorphism = function(ge) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var le, Ee;
      if (ge.beta)
        le = new z(ge.beta, 16).toRed(this.red);
      else {
        var Ce = this._getEndoRoots(this.p);
        le = Ce[0].cmp(Ce[1]) < 0 ? Ce[0] : Ce[1], le = le.toRed(this.red);
      }
      if (ge.lambda)
        Ee = new z(ge.lambda, 16);
      else {
        var Pe = this._getEndoRoots(this.n);
        this.g.mul(Pe[0]).x.cmp(this.g.x.redMul(le)) === 0 ? Ee = Pe[0] : (Ee = Pe[1], oe(this.g.mul(Ee).x.cmp(this.g.x.redMul(le)) === 0));
      }
      var Xe;
      return ge.basis ? Xe = ge.basis.map(function(ht) {
        return {
          a: new z(ht.a, 16),
          b: new z(ht.b, 16)
        };
      }) : Xe = this._getEndoBasis(Ee), {
        beta: le,
        lambda: Ee,
        basis: Xe
      };
    }
  }, ie.prototype._getEndoRoots = function(ge) {
    var le = ge === this.p ? this.red : z.mont(ge), Ee = new z(2).toRed(le).redInvm(), Ce = Ee.redNeg(), Pe = new z(3).toRed(le).redNeg().redSqrt().redMul(Ee), Xe = Ce.redAdd(Pe).fromRed(), ht = Ce.redSub(Pe).fromRed();
    return [Xe, ht];
  }, ie.prototype._getEndoBasis = function(ge) {
    for (var le = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Ee = ge, Ce = this.n.clone(), Pe = new z(1), Xe = new z(0), ht = new z(0), wt = new z(1), Pt, vt, Bt, Ct, Wt, Kt, Yt, Ut = 0, qt, zt; Ee.cmpn(0) !== 0; ) {
      var Ft = Ce.div(Ee);
      qt = Ce.sub(Ft.mul(Ee)), zt = ht.sub(Ft.mul(Pe));
      var Ve = wt.sub(Ft.mul(Xe));
      if (!Bt && qt.cmp(le) < 0)
        Pt = Yt.neg(), vt = Pe, Bt = qt.neg(), Ct = zt;
      else if (Bt && ++Ut === 2)
        break;
      Yt = qt, Ce = Ee, Ee = qt, ht = Pe, Pe = zt, wt = Xe, Xe = Ve;
    }
    Wt = qt.neg(), Kt = zt;
    var Je = Bt.sqr().add(Ct.sqr()), Ke = Wt.sqr().add(Kt.sqr());
    return Ke.cmp(Je) >= 0 && (Wt = Pt, Kt = vt), Bt.negative && (Bt = Bt.neg(), Ct = Ct.neg()), Wt.negative && (Wt = Wt.neg(), Kt = Kt.neg()), [
      { a: Bt, b: Ct },
      { a: Wt, b: Kt }
    ];
  }, ie.prototype._endoSplit = function(ge) {
    var le = this.endo.basis, Ee = le[0], Ce = le[1], Pe = Ce.b.mul(ge).divRound(this.n), Xe = Ee.b.neg().mul(ge).divRound(this.n), ht = Pe.mul(Ee.a), wt = Xe.mul(Ce.a), Pt = Pe.mul(Ee.b), vt = Xe.mul(Ce.b), Bt = ge.sub(ht).sub(wt), Ct = Pt.add(vt).neg();
    return { k1: Bt, k2: Ct };
  }, ie.prototype.pointFromX = function(ge, le) {
    ge = new z(ge, 16), ge.red || (ge = ge.toRed(this.red));
    var Ee = ge.redSqr().redMul(ge).redIAdd(ge.redMul(this.a)).redIAdd(this.b), Ce = Ee.redSqrt();
    if (Ce.redSqr().redSub(Ee).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Pe = Ce.fromRed().isOdd();
    return (le && !Pe || !le && Pe) && (Ce = Ce.redNeg()), this.point(ge, Ce);
  }, ie.prototype.validate = function(ge) {
    if (ge.inf)
      return !0;
    var le = ge.x, Ee = ge.y, Ce = this.a.redMul(le), Pe = le.redSqr().redMul(le).redIAdd(Ce).redIAdd(this.b);
    return Ee.redSqr().redISub(Pe).cmpn(0) === 0;
  }, ie.prototype._endoWnafMulAdd = function(ge, le, Ee) {
    for (var Ce = this._endoWnafT1, Pe = this._endoWnafT2, Xe = 0; Xe < ge.length; Xe++) {
      var ht = this._endoSplit(le[Xe]), wt = ge[Xe], Pt = wt._getBeta();
      ht.k1.negative && (ht.k1.ineg(), wt = wt.neg(!0)), ht.k2.negative && (ht.k2.ineg(), Pt = Pt.neg(!0)), Ce[Xe * 2] = wt, Ce[Xe * 2 + 1] = Pt, Pe[Xe * 2] = ht.k1, Pe[Xe * 2 + 1] = ht.k2;
    }
    for (var vt = this._wnafMulAdd(1, Ce, Pe, Xe * 2, Ee), Bt = 0; Bt < Xe * 2; Bt++)
      Ce[Bt] = null, Pe[Bt] = null;
    return vt;
  };
  function ae(ve, ge, le, Ee) {
    ne.BasePoint.call(this, ve, "affine"), ge === null && le === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new z(ge, 16), this.y = new z(le, 16), Ee && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  Y(ae, ne.BasePoint), ie.prototype.point = function(ge, le, Ee) {
    return new ae(this, ge, le, Ee);
  }, ie.prototype.pointFromJSON = function(ge, le) {
    return ae.fromJSON(this, ge, le);
  }, ae.prototype._getBeta = function() {
    if (this.curve.endo) {
      var ge = this.precomputed;
      if (ge && ge.beta)
        return ge.beta;
      var le = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (ge) {
        var Ee = this.curve, Ce = function(Pe) {
          return Ee.point(Pe.x.redMul(Ee.endo.beta), Pe.y);
        };
        ge.beta = le, le.precomputed = {
          beta: null,
          naf: ge.naf && {
            wnd: ge.naf.wnd,
            points: ge.naf.points.map(Ce)
          },
          doubles: ge.doubles && {
            step: ge.doubles.step,
            points: ge.doubles.points.map(Ce)
          }
        };
      }
      return le;
    }
  }, ae.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, ae.fromJSON = function(ge, le, Ee) {
    typeof le == "string" && (le = JSON.parse(le));
    var Ce = ge.point(le[0], le[1], Ee);
    if (!le[2])
      return Ce;
    function Pe(ht) {
      return ge.point(ht[0], ht[1], Ee);
    }
    var Xe = le[2];
    return Ce.precomputed = {
      beta: null,
      doubles: Xe.doubles && {
        step: Xe.doubles.step,
        points: [Ce].concat(Xe.doubles.points.map(Pe))
      },
      naf: Xe.naf && {
        wnd: Xe.naf.wnd,
        points: [Ce].concat(Xe.naf.points.map(Pe))
      }
    }, Ce;
  }, ae.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, ae.prototype.isInfinity = function() {
    return this.inf;
  }, ae.prototype.add = function(ge) {
    if (this.inf)
      return ge;
    if (ge.inf)
      return this;
    if (this.eq(ge))
      return this.dbl();
    if (this.neg().eq(ge))
      return this.curve.point(null, null);
    if (this.x.cmp(ge.x) === 0)
      return this.curve.point(null, null);
    var le = this.y.redSub(ge.y);
    le.cmpn(0) !== 0 && (le = le.redMul(this.x.redSub(ge.x).redInvm()));
    var Ee = le.redSqr().redISub(this.x).redISub(ge.x), Ce = le.redMul(this.x.redSub(Ee)).redISub(this.y);
    return this.curve.point(Ee, Ce);
  }, ae.prototype.dbl = function() {
    if (this.inf)
      return this;
    var ge = this.y.redAdd(this.y);
    if (ge.cmpn(0) === 0)
      return this.curve.point(null, null);
    var le = this.curve.a, Ee = this.x.redSqr(), Ce = ge.redInvm(), Pe = Ee.redAdd(Ee).redIAdd(Ee).redIAdd(le).redMul(Ce), Xe = Pe.redSqr().redISub(this.x.redAdd(this.x)), ht = Pe.redMul(this.x.redSub(Xe)).redISub(this.y);
    return this.curve.point(Xe, ht);
  }, ae.prototype.getX = function() {
    return this.x.fromRed();
  }, ae.prototype.getY = function() {
    return this.y.fromRed();
  }, ae.prototype.mul = function(ge) {
    return ge = new z(ge, 16), this.isInfinity() ? this : this._hasDoubles(ge) ? this.curve._fixedNafMul(this, ge) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [ge]) : this.curve._wnafMul(this, ge);
  }, ae.prototype.mulAdd = function(ge, le, Ee) {
    var Ce = [this, le], Pe = [ge, Ee];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ce, Pe) : this.curve._wnafMulAdd(1, Ce, Pe, 2);
  }, ae.prototype.jmulAdd = function(ge, le, Ee) {
    var Ce = [this, le], Pe = [ge, Ee];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ce, Pe, !0) : this.curve._wnafMulAdd(1, Ce, Pe, 2, !0);
  }, ae.prototype.eq = function(ge) {
    return this === ge || this.inf === ge.inf && (this.inf || this.x.cmp(ge.x) === 0 && this.y.cmp(ge.y) === 0);
  }, ae.prototype.neg = function(ge) {
    if (this.inf)
      return this;
    var le = this.curve.point(this.x, this.y.redNeg());
    if (ge && this.precomputed) {
      var Ee = this.precomputed, Ce = function(Pe) {
        return Pe.neg();
      };
      le.precomputed = {
        naf: Ee.naf && {
          wnd: Ee.naf.wnd,
          points: Ee.naf.points.map(Ce)
        },
        doubles: Ee.doubles && {
          step: Ee.doubles.step,
          points: Ee.doubles.points.map(Ce)
        }
      };
    }
    return le;
  }, ae.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var ge = this.curve.jpoint(this.x, this.y, this.curve.one);
    return ge;
  };
  function se(ve, ge, le, Ee) {
    ne.BasePoint.call(this, ve, "jacobian"), ge === null && le === null && Ee === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new z(0)) : (this.x = new z(ge, 16), this.y = new z(le, 16), this.z = new z(Ee, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return Y(se, ne.BasePoint), ie.prototype.jpoint = function(ge, le, Ee) {
    return new se(this, ge, le, Ee);
  }, se.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var ge = this.z.redInvm(), le = ge.redSqr(), Ee = this.x.redMul(le), Ce = this.y.redMul(le).redMul(ge);
    return this.curve.point(Ee, Ce);
  }, se.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, se.prototype.add = function(ge) {
    if (this.isInfinity())
      return ge;
    if (ge.isInfinity())
      return this;
    var le = ge.z.redSqr(), Ee = this.z.redSqr(), Ce = this.x.redMul(le), Pe = ge.x.redMul(Ee), Xe = this.y.redMul(le.redMul(ge.z)), ht = ge.y.redMul(Ee.redMul(this.z)), wt = Ce.redSub(Pe), Pt = Xe.redSub(ht);
    if (wt.cmpn(0) === 0)
      return Pt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var vt = wt.redSqr(), Bt = vt.redMul(wt), Ct = Ce.redMul(vt), Wt = Pt.redSqr().redIAdd(Bt).redISub(Ct).redISub(Ct), Kt = Pt.redMul(Ct.redISub(Wt)).redISub(Xe.redMul(Bt)), Yt = this.z.redMul(ge.z).redMul(wt);
    return this.curve.jpoint(Wt, Kt, Yt);
  }, se.prototype.mixedAdd = function(ge) {
    if (this.isInfinity())
      return ge.toJ();
    if (ge.isInfinity())
      return this;
    var le = this.z.redSqr(), Ee = this.x, Ce = ge.x.redMul(le), Pe = this.y, Xe = ge.y.redMul(le).redMul(this.z), ht = Ee.redSub(Ce), wt = Pe.redSub(Xe);
    if (ht.cmpn(0) === 0)
      return wt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Pt = ht.redSqr(), vt = Pt.redMul(ht), Bt = Ee.redMul(Pt), Ct = wt.redSqr().redIAdd(vt).redISub(Bt).redISub(Bt), Wt = wt.redMul(Bt.redISub(Ct)).redISub(Pe.redMul(vt)), Kt = this.z.redMul(ht);
    return this.curve.jpoint(Ct, Wt, Kt);
  }, se.prototype.dblp = function(ge) {
    if (ge === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!ge)
      return this.dbl();
    var le;
    if (this.curve.zeroA || this.curve.threeA) {
      var Ee = this;
      for (le = 0; le < ge; le++)
        Ee = Ee.dbl();
      return Ee;
    }
    var Ce = this.curve.a, Pe = this.curve.tinv, Xe = this.x, ht = this.y, wt = this.z, Pt = wt.redSqr().redSqr(), vt = ht.redAdd(ht);
    for (le = 0; le < ge; le++) {
      var Bt = Xe.redSqr(), Ct = vt.redSqr(), Wt = Ct.redSqr(), Kt = Bt.redAdd(Bt).redIAdd(Bt).redIAdd(Ce.redMul(Pt)), Yt = Xe.redMul(Ct), Ut = Kt.redSqr().redISub(Yt.redAdd(Yt)), qt = Yt.redISub(Ut), zt = Kt.redMul(qt);
      zt = zt.redIAdd(zt).redISub(Wt);
      var Ft = vt.redMul(wt);
      le + 1 < ge && (Pt = Pt.redMul(Wt)), Xe = Ut, wt = Ft, vt = zt;
    }
    return this.curve.jpoint(Xe, vt.redMul(Pe), wt);
  }, se.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, se.prototype._zeroDbl = function() {
    var ge, le, Ee;
    if (this.zOne) {
      var Ce = this.x.redSqr(), Pe = this.y.redSqr(), Xe = Pe.redSqr(), ht = this.x.redAdd(Pe).redSqr().redISub(Ce).redISub(Xe);
      ht = ht.redIAdd(ht);
      var wt = Ce.redAdd(Ce).redIAdd(Ce), Pt = wt.redSqr().redISub(ht).redISub(ht), vt = Xe.redIAdd(Xe);
      vt = vt.redIAdd(vt), vt = vt.redIAdd(vt), ge = Pt, le = wt.redMul(ht.redISub(Pt)).redISub(vt), Ee = this.y.redAdd(this.y);
    } else {
      var Bt = this.x.redSqr(), Ct = this.y.redSqr(), Wt = Ct.redSqr(), Kt = this.x.redAdd(Ct).redSqr().redISub(Bt).redISub(Wt);
      Kt = Kt.redIAdd(Kt);
      var Yt = Bt.redAdd(Bt).redIAdd(Bt), Ut = Yt.redSqr(), qt = Wt.redIAdd(Wt);
      qt = qt.redIAdd(qt), qt = qt.redIAdd(qt), ge = Ut.redISub(Kt).redISub(Kt), le = Yt.redMul(Kt.redISub(ge)).redISub(qt), Ee = this.y.redMul(this.z), Ee = Ee.redIAdd(Ee);
    }
    return this.curve.jpoint(ge, le, Ee);
  }, se.prototype._threeDbl = function() {
    var ge, le, Ee;
    if (this.zOne) {
      var Ce = this.x.redSqr(), Pe = this.y.redSqr(), Xe = Pe.redSqr(), ht = this.x.redAdd(Pe).redSqr().redISub(Ce).redISub(Xe);
      ht = ht.redIAdd(ht);
      var wt = Ce.redAdd(Ce).redIAdd(Ce).redIAdd(this.curve.a), Pt = wt.redSqr().redISub(ht).redISub(ht);
      ge = Pt;
      var vt = Xe.redIAdd(Xe);
      vt = vt.redIAdd(vt), vt = vt.redIAdd(vt), le = wt.redMul(ht.redISub(Pt)).redISub(vt), Ee = this.y.redAdd(this.y);
    } else {
      var Bt = this.z.redSqr(), Ct = this.y.redSqr(), Wt = this.x.redMul(Ct), Kt = this.x.redSub(Bt).redMul(this.x.redAdd(Bt));
      Kt = Kt.redAdd(Kt).redIAdd(Kt);
      var Yt = Wt.redIAdd(Wt);
      Yt = Yt.redIAdd(Yt);
      var Ut = Yt.redAdd(Yt);
      ge = Kt.redSqr().redISub(Ut), Ee = this.y.redAdd(this.z).redSqr().redISub(Ct).redISub(Bt);
      var qt = Ct.redSqr();
      qt = qt.redIAdd(qt), qt = qt.redIAdd(qt), qt = qt.redIAdd(qt), le = Kt.redMul(Yt.redISub(ge)).redISub(qt);
    }
    return this.curve.jpoint(ge, le, Ee);
  }, se.prototype._dbl = function() {
    var ge = this.curve.a, le = this.x, Ee = this.y, Ce = this.z, Pe = Ce.redSqr().redSqr(), Xe = le.redSqr(), ht = Ee.redSqr(), wt = Xe.redAdd(Xe).redIAdd(Xe).redIAdd(ge.redMul(Pe)), Pt = le.redAdd(le);
    Pt = Pt.redIAdd(Pt);
    var vt = Pt.redMul(ht), Bt = wt.redSqr().redISub(vt.redAdd(vt)), Ct = vt.redISub(Bt), Wt = ht.redSqr();
    Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt);
    var Kt = wt.redMul(Ct).redISub(Wt), Yt = Ee.redAdd(Ee).redMul(Ce);
    return this.curve.jpoint(Bt, Kt, Yt);
  }, se.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var ge = this.x.redSqr(), le = this.y.redSqr(), Ee = this.z.redSqr(), Ce = le.redSqr(), Pe = ge.redAdd(ge).redIAdd(ge), Xe = Pe.redSqr(), ht = this.x.redAdd(le).redSqr().redISub(ge).redISub(Ce);
    ht = ht.redIAdd(ht), ht = ht.redAdd(ht).redIAdd(ht), ht = ht.redISub(Xe);
    var wt = ht.redSqr(), Pt = Ce.redIAdd(Ce);
    Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt), Pt = Pt.redIAdd(Pt);
    var vt = Pe.redIAdd(ht).redSqr().redISub(Xe).redISub(wt).redISub(Pt), Bt = le.redMul(vt);
    Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt);
    var Ct = this.x.redMul(wt).redISub(Bt);
    Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct);
    var Wt = this.y.redMul(vt.redMul(Pt.redISub(vt)).redISub(ht.redMul(wt)));
    Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt), Wt = Wt.redIAdd(Wt);
    var Kt = this.z.redAdd(ht).redSqr().redISub(Ee).redISub(wt);
    return this.curve.jpoint(Ct, Wt, Kt);
  }, se.prototype.mul = function(ge, le) {
    return ge = new z(ge, le), this.curve._wnafMul(this, ge);
  }, se.prototype.eq = function(ge) {
    if (ge.type === "affine")
      return this.eq(ge.toJ());
    if (this === ge)
      return !0;
    var le = this.z.redSqr(), Ee = ge.z.redSqr();
    if (this.x.redMul(Ee).redISub(ge.x.redMul(le)).cmpn(0) !== 0)
      return !1;
    var Ce = le.redMul(this.z), Pe = Ee.redMul(ge.z);
    return this.y.redMul(Pe).redISub(ge.y.redMul(Ce)).cmpn(0) === 0;
  }, se.prototype.eqXToP = function(ge) {
    var le = this.z.redSqr(), Ee = ge.toRed(this.curve.red).redMul(le);
    if (this.x.cmp(Ee) === 0)
      return !0;
    for (var Ce = ge.clone(), Pe = this.curve.redN.redMul(le); ; ) {
      if (Ce.iadd(this.curve.n), Ce.cmp(this.curve.p) >= 0)
        return !1;
      if (Ee.redIAdd(Pe), this.x.cmp(Ee) === 0)
        return !0;
    }
  }, se.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, se.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var B = requireBn$1(), z = requireInherits_browser(), Y = requireBase$1(), ne = requireUtils$1();
  function oe(ae) {
    Y.call(this, "mont", ae), this.a = new B(ae.a, 16).toRed(this.red), this.b = new B(ae.b, 16).toRed(this.red), this.i4 = new B(4).toRed(this.red).redInvm(), this.two = new B(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  z(oe, Y), mont = oe, oe.prototype.validate = function(se) {
    var ve = se.normalize().x, ge = ve.redSqr(), le = ge.redMul(ve).redAdd(ge.redMul(this.a)).redAdd(ve), Ee = le.redSqrt();
    return Ee.redSqr().cmp(le) === 0;
  };
  function ie(ae, se, ve) {
    Y.BasePoint.call(this, ae, "projective"), se === null && ve === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new B(se, 16), this.z = new B(ve, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return z(ie, Y.BasePoint), oe.prototype.decodePoint = function(se, ve) {
    return this.point(ne.toArray(se, ve), 1);
  }, oe.prototype.point = function(se, ve) {
    return new ie(this, se, ve);
  }, oe.prototype.pointFromJSON = function(se) {
    return ie.fromJSON(this, se);
  }, ie.prototype.precompute = function() {
  }, ie.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, ie.fromJSON = function(se, ve) {
    return new ie(se, ve[0], ve[1] || se.one);
  }, ie.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, ie.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, ie.prototype.dbl = function() {
    var se = this.x.redAdd(this.z), ve = se.redSqr(), ge = this.x.redSub(this.z), le = ge.redSqr(), Ee = ve.redSub(le), Ce = ve.redMul(le), Pe = Ee.redMul(le.redAdd(this.curve.a24.redMul(Ee)));
    return this.curve.point(Ce, Pe);
  }, ie.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.diffAdd = function(se, ve) {
    var ge = this.x.redAdd(this.z), le = this.x.redSub(this.z), Ee = se.x.redAdd(se.z), Ce = se.x.redSub(se.z), Pe = Ce.redMul(ge), Xe = Ee.redMul(le), ht = ve.z.redMul(Pe.redAdd(Xe).redSqr()), wt = ve.x.redMul(Pe.redISub(Xe).redSqr());
    return this.curve.point(ht, wt);
  }, ie.prototype.mul = function(se) {
    for (var ve = se.clone(), ge = this, le = this.curve.point(null, null), Ee = this, Ce = []; ve.cmpn(0) !== 0; ve.iushrn(1))
      Ce.push(ve.andln(1));
    for (var Pe = Ce.length - 1; Pe >= 0; Pe--)
      Ce[Pe] === 0 ? (ge = ge.diffAdd(le, Ee), le = le.dbl()) : (le = ge.diffAdd(le, Ee), ge = ge.dbl());
    return le;
  }, ie.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ie.prototype.eq = function(se) {
    return this.getX().cmp(se.getX()) === 0;
  }, ie.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, ie.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var B = requireUtils$1(), z = requireBn$1(), Y = requireInherits_browser(), ne = requireBase$1(), oe = B.assert;
  function ie(se) {
    this.twisted = (se.a | 0) !== 1, this.mOneA = this.twisted && (se.a | 0) === -1, this.extended = this.mOneA, ne.call(this, "edwards", se), this.a = new z(se.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new z(se.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new z(se.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), oe(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (se.c | 0) === 1;
  }
  Y(ie, ne), edwards = ie, ie.prototype._mulA = function(ve) {
    return this.mOneA ? ve.redNeg() : this.a.redMul(ve);
  }, ie.prototype._mulC = function(ve) {
    return this.oneC ? ve : this.c.redMul(ve);
  }, ie.prototype.jpoint = function(ve, ge, le, Ee) {
    return this.point(ve, ge, le, Ee);
  }, ie.prototype.pointFromX = function(ve, ge) {
    ve = new z(ve, 16), ve.red || (ve = ve.toRed(this.red));
    var le = ve.redSqr(), Ee = this.c2.redSub(this.a.redMul(le)), Ce = this.one.redSub(this.c2.redMul(this.d).redMul(le)), Pe = Ee.redMul(Ce.redInvm()), Xe = Pe.redSqrt();
    if (Xe.redSqr().redSub(Pe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var ht = Xe.fromRed().isOdd();
    return (ge && !ht || !ge && ht) && (Xe = Xe.redNeg()), this.point(ve, Xe);
  }, ie.prototype.pointFromY = function(ve, ge) {
    ve = new z(ve, 16), ve.red || (ve = ve.toRed(this.red));
    var le = ve.redSqr(), Ee = le.redSub(this.c2), Ce = le.redMul(this.d).redMul(this.c2).redSub(this.a), Pe = Ee.redMul(Ce.redInvm());
    if (Pe.cmp(this.zero) === 0) {
      if (ge)
        throw new Error("invalid point");
      return this.point(this.zero, ve);
    }
    var Xe = Pe.redSqrt();
    if (Xe.redSqr().redSub(Pe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return Xe.fromRed().isOdd() !== ge && (Xe = Xe.redNeg()), this.point(Xe, ve);
  }, ie.prototype.validate = function(ve) {
    if (ve.isInfinity())
      return !0;
    ve.normalize();
    var ge = ve.x.redSqr(), le = ve.y.redSqr(), Ee = ge.redMul(this.a).redAdd(le), Ce = this.c2.redMul(this.one.redAdd(this.d.redMul(ge).redMul(le)));
    return Ee.cmp(Ce) === 0;
  };
  function ae(se, ve, ge, le, Ee) {
    ne.BasePoint.call(this, se, "projective"), ve === null && ge === null && le === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new z(ve, 16), this.y = new z(ge, 16), this.z = le ? new z(le, 16) : this.curve.one, this.t = Ee && new z(Ee, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return Y(ae, ne.BasePoint), ie.prototype.pointFromJSON = function(ve) {
    return ae.fromJSON(this, ve);
  }, ie.prototype.point = function(ve, ge, le, Ee) {
    return new ae(this, ve, ge, le, Ee);
  }, ae.fromJSON = function(ve, ge) {
    return new ae(ve, ge[0], ge[1], ge[2]);
  }, ae.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, ae.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, ae.prototype._extDbl = function() {
    var ve = this.x.redSqr(), ge = this.y.redSqr(), le = this.z.redSqr();
    le = le.redIAdd(le);
    var Ee = this.curve._mulA(ve), Ce = this.x.redAdd(this.y).redSqr().redISub(ve).redISub(ge), Pe = Ee.redAdd(ge), Xe = Pe.redSub(le), ht = Ee.redSub(ge), wt = Ce.redMul(Xe), Pt = Pe.redMul(ht), vt = Ce.redMul(ht), Bt = Xe.redMul(Pe);
    return this.curve.point(wt, Pt, Bt, vt);
  }, ae.prototype._projDbl = function() {
    var ve = this.x.redAdd(this.y).redSqr(), ge = this.x.redSqr(), le = this.y.redSqr(), Ee, Ce, Pe, Xe, ht, wt;
    if (this.curve.twisted) {
      Xe = this.curve._mulA(ge);
      var Pt = Xe.redAdd(le);
      this.zOne ? (Ee = ve.redSub(ge).redSub(le).redMul(Pt.redSub(this.curve.two)), Ce = Pt.redMul(Xe.redSub(le)), Pe = Pt.redSqr().redSub(Pt).redSub(Pt)) : (ht = this.z.redSqr(), wt = Pt.redSub(ht).redISub(ht), Ee = ve.redSub(ge).redISub(le).redMul(wt), Ce = Pt.redMul(Xe.redSub(le)), Pe = Pt.redMul(wt));
    } else
      Xe = ge.redAdd(le), ht = this.curve._mulC(this.z).redSqr(), wt = Xe.redSub(ht).redSub(ht), Ee = this.curve._mulC(ve.redISub(Xe)).redMul(wt), Ce = this.curve._mulC(Xe).redMul(ge.redISub(le)), Pe = Xe.redMul(wt);
    return this.curve.point(Ee, Ce, Pe);
  }, ae.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, ae.prototype._extAdd = function(ve) {
    var ge = this.y.redSub(this.x).redMul(ve.y.redSub(ve.x)), le = this.y.redAdd(this.x).redMul(ve.y.redAdd(ve.x)), Ee = this.t.redMul(this.curve.dd).redMul(ve.t), Ce = this.z.redMul(ve.z.redAdd(ve.z)), Pe = le.redSub(ge), Xe = Ce.redSub(Ee), ht = Ce.redAdd(Ee), wt = le.redAdd(ge), Pt = Pe.redMul(Xe), vt = ht.redMul(wt), Bt = Pe.redMul(wt), Ct = Xe.redMul(ht);
    return this.curve.point(Pt, vt, Ct, Bt);
  }, ae.prototype._projAdd = function(ve) {
    var ge = this.z.redMul(ve.z), le = ge.redSqr(), Ee = this.x.redMul(ve.x), Ce = this.y.redMul(ve.y), Pe = this.curve.d.redMul(Ee).redMul(Ce), Xe = le.redSub(Pe), ht = le.redAdd(Pe), wt = this.x.redAdd(this.y).redMul(ve.x.redAdd(ve.y)).redISub(Ee).redISub(Ce), Pt = ge.redMul(Xe).redMul(wt), vt, Bt;
    return this.curve.twisted ? (vt = ge.redMul(ht).redMul(Ce.redSub(this.curve._mulA(Ee))), Bt = Xe.redMul(ht)) : (vt = ge.redMul(ht).redMul(Ce.redSub(Ee)), Bt = this.curve._mulC(Xe).redMul(ht)), this.curve.point(Pt, vt, Bt);
  }, ae.prototype.add = function(ve) {
    return this.isInfinity() ? ve : ve.isInfinity() ? this : this.curve.extended ? this._extAdd(ve) : this._projAdd(ve);
  }, ae.prototype.mul = function(ve) {
    return this._hasDoubles(ve) ? this.curve._fixedNafMul(this, ve) : this.curve._wnafMul(this, ve);
  }, ae.prototype.mulAdd = function(ve, ge, le) {
    return this.curve._wnafMulAdd(1, [this, ge], [ve, le], 2, !1);
  }, ae.prototype.jmulAdd = function(ve, ge, le) {
    return this.curve._wnafMulAdd(1, [this, ge], [ve, le], 2, !0);
  }, ae.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ve = this.z.redInvm();
    return this.x = this.x.redMul(ve), this.y = this.y.redMul(ve), this.t && (this.t = this.t.redMul(ve)), this.z = this.curve.one, this.zOne = !0, this;
  }, ae.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, ae.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, ae.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, ae.prototype.eq = function(ve) {
    return this === ve || this.getX().cmp(ve.getX()) === 0 && this.getY().cmp(ve.getY()) === 0;
  }, ae.prototype.eqXToP = function(ve) {
    var ge = ve.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(ge) === 0)
      return !0;
    for (var le = ve.clone(), Ee = this.curve.redN.redMul(this.z); ; ) {
      if (le.iadd(this.curve.n), le.cmp(this.curve.p) >= 0)
        return !1;
      if (ge.redIAdd(Ee), this.x.cmp(ge) === 0)
        return !0;
    }
  }, ae.prototype.toP = ae.prototype.normalize, ae.prototype.mixedAdd = ae.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(B) {
    var z = B;
    z.base = requireBase$1(), z.short = requireShort(), z.mont = requireMont(), z.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser();
  utils$1.inherits = z;
  function Y(Ve, Je) {
    return (Ve.charCodeAt(Je) & 64512) !== 55296 || Je < 0 || Je + 1 >= Ve.length ? !1 : (Ve.charCodeAt(Je + 1) & 64512) === 56320;
  }
  function ne(Ve, Je) {
    if (Array.isArray(Ve))
      return Ve.slice();
    if (!Ve)
      return [];
    var Ke = [];
    if (typeof Ve == "string")
      if (Je) {
        if (Je === "hex")
          for (Ve = Ve.replace(/[^a-z0-9]+/ig, ""), Ve.length % 2 !== 0 && (Ve = "0" + Ve), bt = 0; bt < Ve.length; bt += 2)
            Ke.push(parseInt(Ve[bt] + Ve[bt + 1], 16));
      } else for (var Qe = 0, bt = 0; bt < Ve.length; bt++) {
        var _t = Ve.charCodeAt(bt);
        _t < 128 ? Ke[Qe++] = _t : _t < 2048 ? (Ke[Qe++] = _t >> 6 | 192, Ke[Qe++] = _t & 63 | 128) : Y(Ve, bt) ? (_t = 65536 + ((_t & 1023) << 10) + (Ve.charCodeAt(++bt) & 1023), Ke[Qe++] = _t >> 18 | 240, Ke[Qe++] = _t >> 12 & 63 | 128, Ke[Qe++] = _t >> 6 & 63 | 128, Ke[Qe++] = _t & 63 | 128) : (Ke[Qe++] = _t >> 12 | 224, Ke[Qe++] = _t >> 6 & 63 | 128, Ke[Qe++] = _t & 63 | 128);
      }
    else
      for (bt = 0; bt < Ve.length; bt++)
        Ke[bt] = Ve[bt] | 0;
    return Ke;
  }
  utils$1.toArray = ne;
  function oe(Ve) {
    for (var Je = "", Ke = 0; Ke < Ve.length; Ke++)
      Je += se(Ve[Ke].toString(16));
    return Je;
  }
  utils$1.toHex = oe;
  function ie(Ve) {
    var Je = Ve >>> 24 | Ve >>> 8 & 65280 | Ve << 8 & 16711680 | (Ve & 255) << 24;
    return Je >>> 0;
  }
  utils$1.htonl = ie;
  function ae(Ve, Je) {
    for (var Ke = "", Qe = 0; Qe < Ve.length; Qe++) {
      var bt = Ve[Qe];
      Je === "little" && (bt = ie(bt)), Ke += ve(bt.toString(16));
    }
    return Ke;
  }
  utils$1.toHex32 = ae;
  function se(Ve) {
    return Ve.length === 1 ? "0" + Ve : Ve;
  }
  utils$1.zero2 = se;
  function ve(Ve) {
    return Ve.length === 7 ? "0" + Ve : Ve.length === 6 ? "00" + Ve : Ve.length === 5 ? "000" + Ve : Ve.length === 4 ? "0000" + Ve : Ve.length === 3 ? "00000" + Ve : Ve.length === 2 ? "000000" + Ve : Ve.length === 1 ? "0000000" + Ve : Ve;
  }
  utils$1.zero8 = ve;
  function ge(Ve, Je, Ke, Qe) {
    var bt = Ke - Je;
    B(bt % 4 === 0);
    for (var _t = new Array(bt / 4), $t = 0, kt = Je; $t < _t.length; $t++, kt += 4) {
      var xt;
      Qe === "big" ? xt = Ve[kt] << 24 | Ve[kt + 1] << 16 | Ve[kt + 2] << 8 | Ve[kt + 3] : xt = Ve[kt + 3] << 24 | Ve[kt + 2] << 16 | Ve[kt + 1] << 8 | Ve[kt], _t[$t] = xt >>> 0;
    }
    return _t;
  }
  utils$1.join32 = ge;
  function le(Ve, Je) {
    for (var Ke = new Array(Ve.length * 4), Qe = 0, bt = 0; Qe < Ve.length; Qe++, bt += 4) {
      var _t = Ve[Qe];
      Je === "big" ? (Ke[bt] = _t >>> 24, Ke[bt + 1] = _t >>> 16 & 255, Ke[bt + 2] = _t >>> 8 & 255, Ke[bt + 3] = _t & 255) : (Ke[bt + 3] = _t >>> 24, Ke[bt + 2] = _t >>> 16 & 255, Ke[bt + 1] = _t >>> 8 & 255, Ke[bt] = _t & 255);
    }
    return Ke;
  }
  utils$1.split32 = le;
  function Ee(Ve, Je) {
    return Ve >>> Je | Ve << 32 - Je;
  }
  utils$1.rotr32 = Ee;
  function Ce(Ve, Je) {
    return Ve << Je | Ve >>> 32 - Je;
  }
  utils$1.rotl32 = Ce;
  function Pe(Ve, Je) {
    return Ve + Je >>> 0;
  }
  utils$1.sum32 = Pe;
  function Xe(Ve, Je, Ke) {
    return Ve + Je + Ke >>> 0;
  }
  utils$1.sum32_3 = Xe;
  function ht(Ve, Je, Ke, Qe) {
    return Ve + Je + Ke + Qe >>> 0;
  }
  utils$1.sum32_4 = ht;
  function wt(Ve, Je, Ke, Qe, bt) {
    return Ve + Je + Ke + Qe + bt >>> 0;
  }
  utils$1.sum32_5 = wt;
  function Pt(Ve, Je, Ke, Qe) {
    var bt = Ve[Je], _t = Ve[Je + 1], $t = Qe + _t >>> 0, kt = ($t < Qe ? 1 : 0) + Ke + bt;
    Ve[Je] = kt >>> 0, Ve[Je + 1] = $t;
  }
  utils$1.sum64 = Pt;
  function vt(Ve, Je, Ke, Qe) {
    var bt = Je + Qe >>> 0, _t = (bt < Je ? 1 : 0) + Ve + Ke;
    return _t >>> 0;
  }
  utils$1.sum64_hi = vt;
  function Bt(Ve, Je, Ke, Qe) {
    var bt = Je + Qe;
    return bt >>> 0;
  }
  utils$1.sum64_lo = Bt;
  function Ct(Ve, Je, Ke, Qe, bt, _t, $t, kt) {
    var xt = 0, Nt = Je;
    Nt = Nt + Qe >>> 0, xt += Nt < Je ? 1 : 0, Nt = Nt + _t >>> 0, xt += Nt < _t ? 1 : 0, Nt = Nt + kt >>> 0, xt += Nt < kt ? 1 : 0;
    var Rt = Ve + Ke + bt + $t + xt;
    return Rt >>> 0;
  }
  utils$1.sum64_4_hi = Ct;
  function Wt(Ve, Je, Ke, Qe, bt, _t, $t, kt) {
    var xt = Je + Qe + _t + kt;
    return xt >>> 0;
  }
  utils$1.sum64_4_lo = Wt;
  function Kt(Ve, Je, Ke, Qe, bt, _t, $t, kt, xt, Nt) {
    var Rt = 0, Ht = Je;
    Ht = Ht + Qe >>> 0, Rt += Ht < Je ? 1 : 0, Ht = Ht + _t >>> 0, Rt += Ht < _t ? 1 : 0, Ht = Ht + kt >>> 0, Rt += Ht < kt ? 1 : 0, Ht = Ht + Nt >>> 0, Rt += Ht < Nt ? 1 : 0;
    var ar = Ve + Ke + bt + $t + xt + Rt;
    return ar >>> 0;
  }
  utils$1.sum64_5_hi = Kt;
  function Yt(Ve, Je, Ke, Qe, bt, _t, $t, kt, xt, Nt) {
    var Rt = Je + Qe + _t + kt + Nt;
    return Rt >>> 0;
  }
  utils$1.sum64_5_lo = Yt;
  function Ut(Ve, Je, Ke) {
    var Qe = Je << 32 - Ke | Ve >>> Ke;
    return Qe >>> 0;
  }
  utils$1.rotr64_hi = Ut;
  function qt(Ve, Je, Ke) {
    var Qe = Ve << 32 - Ke | Je >>> Ke;
    return Qe >>> 0;
  }
  utils$1.rotr64_lo = qt;
  function zt(Ve, Je, Ke) {
    return Ve >>> Ke;
  }
  utils$1.shr64_hi = zt;
  function Ft(Ve, Je, Ke) {
    var Qe = Ve << 32 - Ke | Je >>> Ke;
    return Qe >>> 0;
  }
  return utils$1.shr64_lo = Ft, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var B = requireUtils(), z = requireMinimalisticAssert();
  function Y() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = Y, Y.prototype.update = function(oe, ie) {
    if (oe = B.toArray(oe, ie), this.pending ? this.pending = this.pending.concat(oe) : this.pending = oe, this.pendingTotal += oe.length, this.pending.length >= this._delta8) {
      oe = this.pending;
      var ae = oe.length % this._delta8;
      this.pending = oe.slice(oe.length - ae, oe.length), this.pending.length === 0 && (this.pending = null), oe = B.join32(oe, 0, oe.length - ae, this.endian);
      for (var se = 0; se < oe.length; se += this._delta32)
        this._update(oe, se, se + this._delta32);
    }
    return this;
  }, Y.prototype.digest = function(oe) {
    return this.update(this._pad()), z(this.pending === null), this._digest(oe);
  }, Y.prototype._pad = function() {
    var oe = this.pendingTotal, ie = this._delta8, ae = ie - (oe + this.padLength) % ie, se = new Array(ae + this.padLength);
    se[0] = 128;
    for (var ve = 1; ve < ae; ve++)
      se[ve] = 0;
    if (oe <<= 3, this.endian === "big") {
      for (var ge = 8; ge < this.padLength; ge++)
        se[ve++] = 0;
      se[ve++] = 0, se[ve++] = 0, se[ve++] = 0, se[ve++] = 0, se[ve++] = oe >>> 24 & 255, se[ve++] = oe >>> 16 & 255, se[ve++] = oe >>> 8 & 255, se[ve++] = oe & 255;
    } else
      for (se[ve++] = oe & 255, se[ve++] = oe >>> 8 & 255, se[ve++] = oe >>> 16 & 255, se[ve++] = oe >>> 24 & 255, se[ve++] = 0, se[ve++] = 0, se[ve++] = 0, se[ve++] = 0, ge = 8; ge < this.padLength; ge++)
        se[ve++] = 0;
    return se;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var B = requireUtils(), z = B.rotr32;
  function Y(le, Ee, Ce, Pe) {
    if (le === 0)
      return ne(Ee, Ce, Pe);
    if (le === 1 || le === 3)
      return ie(Ee, Ce, Pe);
    if (le === 2)
      return oe(Ee, Ce, Pe);
  }
  common.ft_1 = Y;
  function ne(le, Ee, Ce) {
    return le & Ee ^ ~le & Ce;
  }
  common.ch32 = ne;
  function oe(le, Ee, Ce) {
    return le & Ee ^ le & Ce ^ Ee & Ce;
  }
  common.maj32 = oe;
  function ie(le, Ee, Ce) {
    return le ^ Ee ^ Ce;
  }
  common.p32 = ie;
  function ae(le) {
    return z(le, 2) ^ z(le, 13) ^ z(le, 22);
  }
  common.s0_256 = ae;
  function se(le) {
    return z(le, 6) ^ z(le, 11) ^ z(le, 25);
  }
  common.s1_256 = se;
  function ve(le) {
    return z(le, 7) ^ z(le, 18) ^ le >>> 3;
  }
  common.g0_256 = ve;
  function ge(le) {
    return z(le, 17) ^ z(le, 19) ^ le >>> 10;
  }
  return common.g1_256 = ge, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireCommon(), ne = B.rotl32, oe = B.sum32, ie = B.sum32_5, ae = Y.ft_1, se = z.BlockHash, ve = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function ge() {
    if (!(this instanceof ge))
      return new ge();
    se.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return B.inherits(ge, se), _1 = ge, ge.blockSize = 512, ge.outSize = 160, ge.hmacStrength = 80, ge.padLength = 64, ge.prototype._update = function(Ee, Ce) {
    for (var Pe = this.W, Xe = 0; Xe < 16; Xe++)
      Pe[Xe] = Ee[Ce + Xe];
    for (; Xe < Pe.length; Xe++)
      Pe[Xe] = ne(Pe[Xe - 3] ^ Pe[Xe - 8] ^ Pe[Xe - 14] ^ Pe[Xe - 16], 1);
    var ht = this.h[0], wt = this.h[1], Pt = this.h[2], vt = this.h[3], Bt = this.h[4];
    for (Xe = 0; Xe < Pe.length; Xe++) {
      var Ct = ~~(Xe / 20), Wt = ie(ne(ht, 5), ae(Ct, wt, Pt, vt), Bt, Pe[Xe], ve[Ct]);
      Bt = vt, vt = Pt, Pt = ne(wt, 30), wt = ht, ht = Wt;
    }
    this.h[0] = oe(this.h[0], ht), this.h[1] = oe(this.h[1], wt), this.h[2] = oe(this.h[2], Pt), this.h[3] = oe(this.h[3], vt), this.h[4] = oe(this.h[4], Bt);
  }, ge.prototype._digest = function(Ee) {
    return Ee === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireCommon(), ne = requireMinimalisticAssert(), oe = B.sum32, ie = B.sum32_4, ae = B.sum32_5, se = Y.ch32, ve = Y.maj32, ge = Y.s0_256, le = Y.s1_256, Ee = Y.g0_256, Ce = Y.g1_256, Pe = z.BlockHash, Xe = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ht() {
    if (!(this instanceof ht))
      return new ht();
    Pe.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = Xe, this.W = new Array(64);
  }
  return B.inherits(ht, Pe), _256 = ht, ht.blockSize = 512, ht.outSize = 256, ht.hmacStrength = 192, ht.padLength = 64, ht.prototype._update = function(Pt, vt) {
    for (var Bt = this.W, Ct = 0; Ct < 16; Ct++)
      Bt[Ct] = Pt[vt + Ct];
    for (; Ct < Bt.length; Ct++)
      Bt[Ct] = ie(Ce(Bt[Ct - 2]), Bt[Ct - 7], Ee(Bt[Ct - 15]), Bt[Ct - 16]);
    var Wt = this.h[0], Kt = this.h[1], Yt = this.h[2], Ut = this.h[3], qt = this.h[4], zt = this.h[5], Ft = this.h[6], Ve = this.h[7];
    for (ne(this.k.length === Bt.length), Ct = 0; Ct < Bt.length; Ct++) {
      var Je = ae(Ve, le(qt), se(qt, zt, Ft), this.k[Ct], Bt[Ct]), Ke = oe(ge(Wt), ve(Wt, Kt, Yt));
      Ve = Ft, Ft = zt, zt = qt, qt = oe(Ut, Je), Ut = Yt, Yt = Kt, Kt = Wt, Wt = oe(Je, Ke);
    }
    this.h[0] = oe(this.h[0], Wt), this.h[1] = oe(this.h[1], Kt), this.h[2] = oe(this.h[2], Yt), this.h[3] = oe(this.h[3], Ut), this.h[4] = oe(this.h[4], qt), this.h[5] = oe(this.h[5], zt), this.h[6] = oe(this.h[6], Ft), this.h[7] = oe(this.h[7], Ve);
  }, ht.prototype._digest = function(Pt) {
    return Pt === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var B = requireUtils(), z = require_256();
  function Y() {
    if (!(this instanceof Y))
      return new Y();
    z.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return B.inherits(Y, z), _224 = Y, Y.blockSize = 512, Y.outSize = 224, Y.hmacStrength = 192, Y.padLength = 64, Y.prototype._digest = function(oe) {
    return oe === "hex" ? B.toHex32(this.h.slice(0, 7), "big") : B.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireMinimalisticAssert(), ne = B.rotr64_hi, oe = B.rotr64_lo, ie = B.shr64_hi, ae = B.shr64_lo, se = B.sum64, ve = B.sum64_hi, ge = B.sum64_lo, le = B.sum64_4_hi, Ee = B.sum64_4_lo, Ce = B.sum64_5_hi, Pe = B.sum64_5_lo, Xe = z.BlockHash, ht = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function wt() {
    if (!(this instanceof wt))
      return new wt();
    Xe.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = ht, this.W = new Array(160);
  }
  B.inherits(wt, Xe), _512 = wt, wt.blockSize = 1024, wt.outSize = 512, wt.hmacStrength = 192, wt.padLength = 128, wt.prototype._prepareBlock = function(Ke, Qe) {
    for (var bt = this.W, _t = 0; _t < 32; _t++)
      bt[_t] = Ke[Qe + _t];
    for (; _t < bt.length; _t += 2) {
      var $t = Ft(bt[_t - 4], bt[_t - 3]), kt = Ve(bt[_t - 4], bt[_t - 3]), xt = bt[_t - 14], Nt = bt[_t - 13], Rt = qt(bt[_t - 30], bt[_t - 29]), Ht = zt(bt[_t - 30], bt[_t - 29]), ar = bt[_t - 32], lr = bt[_t - 31];
      bt[_t] = le(
        $t,
        kt,
        xt,
        Nt,
        Rt,
        Ht,
        ar,
        lr
      ), bt[_t + 1] = Ee(
        $t,
        kt,
        xt,
        Nt,
        Rt,
        Ht,
        ar,
        lr
      );
    }
  }, wt.prototype._update = function(Ke, Qe) {
    this._prepareBlock(Ke, Qe);
    var bt = this.W, _t = this.h[0], $t = this.h[1], kt = this.h[2], xt = this.h[3], Nt = this.h[4], Rt = this.h[5], Ht = this.h[6], ar = this.h[7], lr = this.h[8], nr = this.h[9], Vt = this.h[10], Xt = this.h[11], sr = this.h[12], dr = this.h[13], er = this.h[14], Zt = this.h[15];
    Y(this.k.length === bt.length);
    for (var pr = 0; pr < bt.length; pr += 2) {
      var _r = er, Ar = Zt, Sr = Yt(lr, nr), Br = Ut(lr, nr), Ir = Pt(lr, nr, Vt, Xt, sr), wr = vt(lr, nr, Vt, Xt, sr, dr), Gr = this.k[pr], Pr = this.k[pr + 1], Mr = bt[pr], Cr = bt[pr + 1], Tr = Ce(
        _r,
        Ar,
        Sr,
        Br,
        Ir,
        wr,
        Gr,
        Pr,
        Mr,
        Cr
      ), Hr = Pe(
        _r,
        Ar,
        Sr,
        Br,
        Ir,
        wr,
        Gr,
        Pr,
        Mr,
        Cr
      );
      _r = Wt(_t, $t), Ar = Kt(_t, $t), Sr = Bt(_t, $t, kt, xt, Nt), Br = Ct(_t, $t, kt, xt, Nt, Rt);
      var Yr = ve(_r, Ar, Sr, Br), Nr = ge(_r, Ar, Sr, Br);
      er = sr, Zt = dr, sr = Vt, dr = Xt, Vt = lr, Xt = nr, lr = ve(Ht, ar, Tr, Hr), nr = ge(ar, ar, Tr, Hr), Ht = Nt, ar = Rt, Nt = kt, Rt = xt, kt = _t, xt = $t, _t = ve(Tr, Hr, Yr, Nr), $t = ge(Tr, Hr, Yr, Nr);
    }
    se(this.h, 0, _t, $t), se(this.h, 2, kt, xt), se(this.h, 4, Nt, Rt), se(this.h, 6, Ht, ar), se(this.h, 8, lr, nr), se(this.h, 10, Vt, Xt), se(this.h, 12, sr, dr), se(this.h, 14, er, Zt);
  }, wt.prototype._digest = function(Ke) {
    return Ke === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  };
  function Pt(Je, Ke, Qe, bt, _t) {
    var $t = Je & Qe ^ ~Je & _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function vt(Je, Ke, Qe, bt, _t, $t) {
    var kt = Ke & bt ^ ~Ke & $t;
    return kt < 0 && (kt += 4294967296), kt;
  }
  function Bt(Je, Ke, Qe, bt, _t) {
    var $t = Je & Qe ^ Je & _t ^ Qe & _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Ct(Je, Ke, Qe, bt, _t, $t) {
    var kt = Ke & bt ^ Ke & $t ^ bt & $t;
    return kt < 0 && (kt += 4294967296), kt;
  }
  function Wt(Je, Ke) {
    var Qe = ne(Je, Ke, 28), bt = ne(Ke, Je, 2), _t = ne(Ke, Je, 7), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Kt(Je, Ke) {
    var Qe = oe(Je, Ke, 28), bt = oe(Ke, Je, 2), _t = oe(Ke, Je, 7), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Yt(Je, Ke) {
    var Qe = ne(Je, Ke, 14), bt = ne(Je, Ke, 18), _t = ne(Ke, Je, 9), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Ut(Je, Ke) {
    var Qe = oe(Je, Ke, 14), bt = oe(Je, Ke, 18), _t = oe(Ke, Je, 9), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function qt(Je, Ke) {
    var Qe = ne(Je, Ke, 1), bt = ne(Je, Ke, 8), _t = ie(Je, Ke, 7), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function zt(Je, Ke) {
    var Qe = oe(Je, Ke, 1), bt = oe(Je, Ke, 8), _t = ae(Je, Ke, 7), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Ft(Je, Ke) {
    var Qe = ne(Je, Ke, 19), bt = ne(Ke, Je, 29), _t = ie(Je, Ke, 6), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Ve(Je, Ke) {
    var Qe = oe(Je, Ke, 19), bt = oe(Ke, Je, 29), _t = ae(Je, Ke, 6), $t = Qe ^ bt ^ _t;
    return $t < 0 && ($t += 4294967296), $t;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var B = requireUtils(), z = require_512();
  function Y() {
    if (!(this instanceof Y))
      return new Y();
    z.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return B.inherits(Y, z), _384 = Y, Y.blockSize = 1024, Y.outSize = 384, Y.hmacStrength = 192, Y.padLength = 128, Y.prototype._digest = function(oe) {
    return oe === "hex" ? B.toHex32(this.h.slice(0, 12), "big") : B.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = B.rotl32, ne = B.sum32, oe = B.sum32_3, ie = B.sum32_4, ae = z.BlockHash;
  function se() {
    if (!(this instanceof se))
      return new se();
    ae.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  B.inherits(se, ae), ripemd.ripemd160 = se, se.blockSize = 512, se.outSize = 160, se.hmacStrength = 192, se.padLength = 64, se.prototype._update = function(wt, Pt) {
    for (var vt = this.h[0], Bt = this.h[1], Ct = this.h[2], Wt = this.h[3], Kt = this.h[4], Yt = vt, Ut = Bt, qt = Ct, zt = Wt, Ft = Kt, Ve = 0; Ve < 80; Ve++) {
      var Je = ne(
        Y(
          ie(vt, ve(Ve, Bt, Ct, Wt), wt[Ee[Ve] + Pt], ge(Ve)),
          Pe[Ve]
        ),
        Kt
      );
      vt = Kt, Kt = Wt, Wt = Y(Ct, 10), Ct = Bt, Bt = Je, Je = ne(
        Y(
          ie(Yt, ve(79 - Ve, Ut, qt, zt), wt[Ce[Ve] + Pt], le(Ve)),
          Xe[Ve]
        ),
        Ft
      ), Yt = Ft, Ft = zt, zt = Y(qt, 10), qt = Ut, Ut = Je;
    }
    Je = oe(this.h[1], Ct, zt), this.h[1] = oe(this.h[2], Wt, Ft), this.h[2] = oe(this.h[3], Kt, Yt), this.h[3] = oe(this.h[4], vt, Ut), this.h[4] = oe(this.h[0], Bt, qt), this.h[0] = Je;
  }, se.prototype._digest = function(wt) {
    return wt === "hex" ? B.toHex32(this.h, "little") : B.split32(this.h, "little");
  };
  function ve(ht, wt, Pt, vt) {
    return ht <= 15 ? wt ^ Pt ^ vt : ht <= 31 ? wt & Pt | ~wt & vt : ht <= 47 ? (wt | ~Pt) ^ vt : ht <= 63 ? wt & vt | Pt & ~vt : wt ^ (Pt | ~vt);
  }
  function ge(ht) {
    return ht <= 15 ? 0 : ht <= 31 ? 1518500249 : ht <= 47 ? 1859775393 : ht <= 63 ? 2400959708 : 2840853838;
  }
  function le(ht) {
    return ht <= 15 ? 1352829926 : ht <= 31 ? 1548603684 : ht <= 47 ? 1836072691 : ht <= 63 ? 2053994217 : 0;
  }
  var Ee = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Ce = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Pe = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], Xe = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var B = requireUtils(), z = requireMinimalisticAssert();
  function Y(ne, oe, ie) {
    if (!(this instanceof Y))
      return new Y(ne, oe, ie);
    this.Hash = ne, this.blockSize = ne.blockSize / 8, this.outSize = ne.outSize / 8, this.inner = null, this.outer = null, this._init(B.toArray(oe, ie));
  }
  return hmac = Y, Y.prototype._init = function(oe) {
    oe.length > this.blockSize && (oe = new this.Hash().update(oe).digest()), z(oe.length <= this.blockSize);
    for (var ie = oe.length; ie < this.blockSize; ie++)
      oe.push(0);
    for (ie = 0; ie < oe.length; ie++)
      oe[ie] ^= 54;
    for (this.inner = new this.Hash().update(oe), ie = 0; ie < oe.length; ie++)
      oe[ie] ^= 106;
    this.outer = new this.Hash().update(oe);
  }, Y.prototype.update = function(oe, ie) {
    return this.inner.update(oe, ie), this;
  }, Y.prototype.digest = function(oe) {
    return this.outer.update(this.inner.digest()), this.outer.digest(oe);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(B) {
    var z = B;
    z.utils = requireUtils(), z.common = requireCommon$1(), z.sha = requireSha(), z.ripemd = requireRipemd(), z.hmac = requireHmac(), z.sha1 = z.sha.sha1, z.sha256 = z.sha.sha256, z.sha224 = z.sha.sha224, z.sha384 = z.sha.sha384, z.sha512 = z.sha.sha512, z.ripemd160 = z.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(B) {
    var z = B, Y = requireHash(), ne = requireCurve(), oe = requireUtils$1(), ie = oe.assert;
    function ae(ge) {
      ge.type === "short" ? this.curve = new ne.short(ge) : ge.type === "edwards" ? this.curve = new ne.edwards(ge) : this.curve = new ne.mont(ge), this.g = this.curve.g, this.n = this.curve.n, this.hash = ge.hash, ie(this.g.validate(), "Invalid curve"), ie(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    z.PresetCurve = ae;
    function se(ge, le) {
      Object.defineProperty(z, ge, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var Ee = new ae(le);
          return Object.defineProperty(z, ge, {
            configurable: !0,
            enumerable: !0,
            value: Ee
          }), Ee;
        }
      });
    }
    se("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), se("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), se("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), se("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: Y.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), se("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: Y.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), se("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), se("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ve;
    try {
      ve = requireSecp256k1();
    } catch {
      ve = void 0;
    }
    se("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Y.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ve
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var B = requireHash(), z = requireUtils$2(), Y = requireMinimalisticAssert();
  function ne(oe) {
    if (!(this instanceof ne))
      return new ne(oe);
    this.hash = oe.hash, this.predResist = !!oe.predResist, this.outLen = this.hash.outSize, this.minEntropy = oe.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var ie = z.toArray(oe.entropy, oe.entropyEnc || "hex"), ae = z.toArray(oe.nonce, oe.nonceEnc || "hex"), se = z.toArray(oe.pers, oe.persEnc || "hex");
    Y(
      ie.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(ie, ae, se);
  }
  return hmacDrbg = ne, ne.prototype._init = function(ie, ae, se) {
    var ve = ie.concat(ae).concat(se);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var ge = 0; ge < this.V.length; ge++)
      this.K[ge] = 0, this.V[ge] = 1;
    this._update(ve), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, ne.prototype._hmac = function() {
    return new B.hmac(this.hash, this.K);
  }, ne.prototype._update = function(ie) {
    var ae = this._hmac().update(this.V).update([0]);
    ie && (ae = ae.update(ie)), this.K = ae.digest(), this.V = this._hmac().update(this.V).digest(), ie && (this.K = this._hmac().update(this.V).update([1]).update(ie).digest(), this.V = this._hmac().update(this.V).digest());
  }, ne.prototype.reseed = function(ie, ae, se, ve) {
    typeof ae != "string" && (ve = se, se = ae, ae = null), ie = z.toArray(ie, ae), se = z.toArray(se, ve), Y(
      ie.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(ie.concat(se || [])), this._reseed = 1;
  }, ne.prototype.generate = function(ie, ae, se, ve) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof ae != "string" && (ve = se, se = ae, ae = null), se && (se = z.toArray(se, ve || "hex"), this._update(se));
    for (var ge = []; ge.length < ie; )
      this.V = this._hmac().update(this.V).digest(), ge = ge.concat(this.V);
    var le = ge.slice(0, ie);
    return this._update(se), this._reseed++, z.encode(le, ae);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.assert;
  function ne(oe, ie) {
    this.ec = oe, this.priv = null, this.pub = null, ie.priv && this._importPrivate(ie.priv, ie.privEnc), ie.pub && this._importPublic(ie.pub, ie.pubEnc);
  }
  return key$1 = ne, ne.fromPublic = function(ie, ae, se) {
    return ae instanceof ne ? ae : new ne(ie, {
      pub: ae,
      pubEnc: se
    });
  }, ne.fromPrivate = function(ie, ae, se) {
    return ae instanceof ne ? ae : new ne(ie, {
      priv: ae,
      privEnc: se
    });
  }, ne.prototype.validate = function() {
    var ie = this.getPublic();
    return ie.isInfinity() ? { result: !1, reason: "Invalid public key" } : ie.validate() ? ie.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, ne.prototype.getPublic = function(ie, ae) {
    return typeof ie == "string" && (ae = ie, ie = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), ae ? this.pub.encode(ae, ie) : this.pub;
  }, ne.prototype.getPrivate = function(ie) {
    return ie === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, ne.prototype._importPrivate = function(ie, ae) {
    this.priv = new B(ie, ae || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, ne.prototype._importPublic = function(ie, ae) {
    if (ie.x || ie.y) {
      this.ec.curve.type === "mont" ? Y(ie.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Y(ie.x && ie.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ie.x, ie.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(ie, ae);
  }, ne.prototype.derive = function(ie) {
    return ie.validate() || Y(ie.validate(), "public point not validated"), ie.mul(this.priv).getX();
  }, ne.prototype.sign = function(ie, ae, se) {
    return this.ec.sign(ie, this, ae, se);
  }, ne.prototype.verify = function(ie, ae, se) {
    return this.ec.verify(ie, ae, this, void 0, se);
  }, ne.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.assert;
  function ne(ve, ge) {
    if (ve instanceof ne)
      return ve;
    this._importDER(ve, ge) || (Y(ve.r && ve.s, "Signature without r or s"), this.r = new B(ve.r, 16), this.s = new B(ve.s, 16), ve.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ve.recoveryParam);
  }
  signature$1 = ne;
  function oe() {
    this.place = 0;
  }
  function ie(ve, ge) {
    var le = ve[ge.place++];
    if (!(le & 128))
      return le;
    var Ee = le & 15;
    if (Ee === 0 || Ee > 4 || ve[ge.place] === 0)
      return !1;
    for (var Ce = 0, Pe = 0, Xe = ge.place; Pe < Ee; Pe++, Xe++)
      Ce <<= 8, Ce |= ve[Xe], Ce >>>= 0;
    return Ce <= 127 ? !1 : (ge.place = Xe, Ce);
  }
  function ae(ve) {
    for (var ge = 0, le = ve.length - 1; !ve[ge] && !(ve[ge + 1] & 128) && ge < le; )
      ge++;
    return ge === 0 ? ve : ve.slice(ge);
  }
  ne.prototype._importDER = function(ge, le) {
    ge = z.toArray(ge, le);
    var Ee = new oe();
    if (ge[Ee.place++] !== 48)
      return !1;
    var Ce = ie(ge, Ee);
    if (Ce === !1 || Ce + Ee.place !== ge.length || ge[Ee.place++] !== 2)
      return !1;
    var Pe = ie(ge, Ee);
    if (Pe === !1 || ge[Ee.place] & 128)
      return !1;
    var Xe = ge.slice(Ee.place, Pe + Ee.place);
    if (Ee.place += Pe, ge[Ee.place++] !== 2)
      return !1;
    var ht = ie(ge, Ee);
    if (ht === !1 || ge.length !== ht + Ee.place || ge[Ee.place] & 128)
      return !1;
    var wt = ge.slice(Ee.place, ht + Ee.place);
    if (Xe[0] === 0)
      if (Xe[1] & 128)
        Xe = Xe.slice(1);
      else
        return !1;
    if (wt[0] === 0)
      if (wt[1] & 128)
        wt = wt.slice(1);
      else
        return !1;
    return this.r = new B(Xe), this.s = new B(wt), this.recoveryParam = null, !0;
  };
  function se(ve, ge) {
    if (ge < 128) {
      ve.push(ge);
      return;
    }
    var le = 1 + (Math.log(ge) / Math.LN2 >>> 3);
    for (ve.push(le | 128); --le; )
      ve.push(ge >>> (le << 3) & 255);
    ve.push(ge);
  }
  return ne.prototype.toDER = function(ge) {
    var le = this.r.toArray(), Ee = this.s.toArray();
    for (le[0] & 128 && (le = [0].concat(le)), Ee[0] & 128 && (Ee = [0].concat(Ee)), le = ae(le), Ee = ae(Ee); !Ee[0] && !(Ee[1] & 128); )
      Ee = Ee.slice(1);
    var Ce = [2];
    se(Ce, le.length), Ce = Ce.concat(le), Ce.push(2), se(Ce, Ee.length);
    var Pe = Ce.concat(Ee), Xe = [48];
    return se(Xe, Pe.length), Xe = Xe.concat(Pe), z.encode(Xe, ge);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = requireBn$1(), z = requireHmacDrbg(), Y = requireUtils$1(), ne = requireCurves(), oe = requireBrorand(), ie = Y.assert, ae = requireKey$1(), se = requireSignature$1();
  function ve(ge) {
    if (!(this instanceof ve))
      return new ve(ge);
    typeof ge == "string" && (ie(
      Object.prototype.hasOwnProperty.call(ne, ge),
      "Unknown curve " + ge
    ), ge = ne[ge]), ge instanceof ne.PresetCurve && (ge = { curve: ge }), this.curve = ge.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = ge.curve.g, this.g.precompute(ge.curve.n.bitLength() + 1), this.hash = ge.hash || ge.curve.hash;
  }
  return ec = ve, ve.prototype.keyPair = function(le) {
    return new ae(this, le);
  }, ve.prototype.keyFromPrivate = function(le, Ee) {
    return ae.fromPrivate(this, le, Ee);
  }, ve.prototype.keyFromPublic = function(le, Ee) {
    return ae.fromPublic(this, le, Ee);
  }, ve.prototype.genKeyPair = function(le) {
    le || (le = {});
    for (var Ee = new z({
      hash: this.hash,
      pers: le.pers,
      persEnc: le.persEnc || "utf8",
      entropy: le.entropy || oe(this.hash.hmacStrength),
      entropyEnc: le.entropy && le.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Ce = this.n.byteLength(), Pe = this.n.sub(new B(2)); ; ) {
      var Xe = new B(Ee.generate(Ce));
      if (!(Xe.cmp(Pe) > 0))
        return Xe.iaddn(1), this.keyFromPrivate(Xe);
    }
  }, ve.prototype._truncateToN = function(le, Ee, Ce) {
    var Pe;
    if (B.isBN(le) || typeof le == "number")
      le = new B(le, 16), Pe = le.byteLength();
    else if (typeof le == "object")
      Pe = le.length, le = new B(le, 16);
    else {
      var Xe = le.toString();
      Pe = Xe.length + 1 >>> 1, le = new B(Xe, 16);
    }
    typeof Ce != "number" && (Ce = Pe * 8);
    var ht = Ce - this.n.bitLength();
    return ht > 0 && (le = le.ushrn(ht)), !Ee && le.cmp(this.n) >= 0 ? le.sub(this.n) : le;
  }, ve.prototype.sign = function(le, Ee, Ce, Pe) {
    if (typeof Ce == "object" && (Pe = Ce, Ce = null), Pe || (Pe = {}), typeof le != "string" && typeof le != "number" && !B.isBN(le)) {
      ie(
        typeof le == "object" && le && typeof le.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), ie(le.length >>> 0 === le.length);
      for (var Xe = 0; Xe < le.length; Xe++) ie((le[Xe] & 255) === le[Xe]);
    }
    Ee = this.keyFromPrivate(Ee, Ce), le = this._truncateToN(le, !1, Pe.msgBitLength), ie(!le.isNeg(), "Can not sign a negative message");
    var ht = this.n.byteLength(), wt = Ee.getPrivate().toArray("be", ht), Pt = le.toArray("be", ht);
    ie(new B(Pt).eq(le), "Can not sign message");
    for (var vt = new z({
      hash: this.hash,
      entropy: wt,
      nonce: Pt,
      pers: Pe.pers,
      persEnc: Pe.persEnc || "utf8"
    }), Bt = this.n.sub(new B(1)), Ct = 0; ; Ct++) {
      var Wt = Pe.k ? Pe.k(Ct) : new B(vt.generate(this.n.byteLength()));
      if (Wt = this._truncateToN(Wt, !0), !(Wt.cmpn(1) <= 0 || Wt.cmp(Bt) >= 0)) {
        var Kt = this.g.mul(Wt);
        if (!Kt.isInfinity()) {
          var Yt = Kt.getX(), Ut = Yt.umod(this.n);
          if (Ut.cmpn(0) !== 0) {
            var qt = Wt.invm(this.n).mul(Ut.mul(Ee.getPrivate()).iadd(le));
            if (qt = qt.umod(this.n), qt.cmpn(0) !== 0) {
              var zt = (Kt.getY().isOdd() ? 1 : 0) | (Yt.cmp(Ut) !== 0 ? 2 : 0);
              return Pe.canonical && qt.cmp(this.nh) > 0 && (qt = this.n.sub(qt), zt ^= 1), new se({ r: Ut, s: qt, recoveryParam: zt });
            }
          }
        }
      }
    }
  }, ve.prototype.verify = function(le, Ee, Ce, Pe, Xe) {
    Xe || (Xe = {}), le = this._truncateToN(le, !1, Xe.msgBitLength), Ce = this.keyFromPublic(Ce, Pe), Ee = new se(Ee, "hex");
    var ht = Ee.r, wt = Ee.s;
    if (ht.cmpn(1) < 0 || ht.cmp(this.n) >= 0 || wt.cmpn(1) < 0 || wt.cmp(this.n) >= 0)
      return !1;
    var Pt = wt.invm(this.n), vt = Pt.mul(le).umod(this.n), Bt = Pt.mul(ht).umod(this.n), Ct;
    return this.curve._maxwellTrick ? (Ct = this.g.jmulAdd(vt, Ce.getPublic(), Bt), Ct.isInfinity() ? !1 : Ct.eqXToP(ht)) : (Ct = this.g.mulAdd(vt, Ce.getPublic(), Bt), Ct.isInfinity() ? !1 : Ct.getX().umod(this.n).cmp(ht) === 0);
  }, ve.prototype.recoverPubKey = function(ge, le, Ee, Ce) {
    ie((3 & Ee) === Ee, "The recovery param is more than two bits"), le = new se(le, Ce);
    var Pe = this.n, Xe = new B(ge), ht = le.r, wt = le.s, Pt = Ee & 1, vt = Ee >> 1;
    if (ht.cmp(this.curve.p.umod(this.curve.n)) >= 0 && vt)
      throw new Error("Unable to find sencond key candinate");
    vt ? ht = this.curve.pointFromX(ht.add(this.curve.n), Pt) : ht = this.curve.pointFromX(ht, Pt);
    var Bt = le.r.invm(Pe), Ct = Pe.sub(Xe).mul(Bt).umod(Pe), Wt = wt.mul(Bt).umod(Pe);
    return this.g.mulAdd(Ct, ht, Wt);
  }, ve.prototype.getKeyRecoveryParam = function(ge, le, Ee, Ce) {
    if (le = new se(le, Ce), le.recoveryParam !== null)
      return le.recoveryParam;
    for (var Pe = 0; Pe < 4; Pe++) {
      var Xe;
      try {
        Xe = this.recoverPubKey(ge, le, Pe);
      } catch {
        continue;
      }
      if (Xe.eq(Ee))
        return Pe;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var B = requireUtils$1(), z = B.assert, Y = B.parseBytes, ne = B.cachedProperty;
  function oe(ie, ae) {
    this.eddsa = ie, this._secret = Y(ae.secret), ie.isPoint(ae.pub) ? this._pub = ae.pub : this._pubBytes = Y(ae.pub);
  }
  return oe.fromPublic = function(ae, se) {
    return se instanceof oe ? se : new oe(ae, { pub: se });
  }, oe.fromSecret = function(ae, se) {
    return se instanceof oe ? se : new oe(ae, { secret: se });
  }, oe.prototype.secret = function() {
    return this._secret;
  }, ne(oe, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), ne(oe, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), ne(oe, "privBytes", function() {
    var ae = this.eddsa, se = this.hash(), ve = ae.encodingLength - 1, ge = se.slice(0, ae.encodingLength);
    return ge[0] &= 248, ge[ve] &= 127, ge[ve] |= 64, ge;
  }), ne(oe, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), ne(oe, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), ne(oe, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), oe.prototype.sign = function(ae) {
    return z(this._secret, "KeyPair can only verify"), this.eddsa.sign(ae, this);
  }, oe.prototype.verify = function(ae, se) {
    return this.eddsa.verify(ae, se, this);
  }, oe.prototype.getSecret = function(ae) {
    return z(this._secret, "KeyPair is public only"), B.encode(this.secret(), ae);
  }, oe.prototype.getPublic = function(ae) {
    return B.encode(this.pubBytes(), ae);
  }, key = oe, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var B = requireBn$1(), z = requireUtils$1(), Y = z.assert, ne = z.cachedProperty, oe = z.parseBytes;
  function ie(ae, se) {
    this.eddsa = ae, typeof se != "object" && (se = oe(se)), Array.isArray(se) && (Y(se.length === ae.encodingLength * 2, "Signature has invalid size"), se = {
      R: se.slice(0, ae.encodingLength),
      S: se.slice(ae.encodingLength)
    }), Y(se.R && se.S, "Signature without R or S"), ae.isPoint(se.R) && (this._R = se.R), se.S instanceof B && (this._S = se.S), this._Rencoded = Array.isArray(se.R) ? se.R : se.Rencoded, this._Sencoded = Array.isArray(se.S) ? se.S : se.Sencoded;
  }
  return ne(ie, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), ne(ie, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), ne(ie, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), ne(ie, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), ie.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, ie.prototype.toHex = function() {
    return z.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = ie, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var B = requireHash(), z = requireCurves(), Y = requireUtils$1(), ne = Y.assert, oe = Y.parseBytes, ie = requireKey(), ae = requireSignature();
  function se(ve) {
    if (ne(ve === "ed25519", "only tested with ed25519 so far"), !(this instanceof se))
      return new se(ve);
    ve = z[ve].curve, this.curve = ve, this.g = ve.g, this.g.precompute(ve.n.bitLength() + 1), this.pointClass = ve.point().constructor, this.encodingLength = Math.ceil(ve.n.bitLength() / 8), this.hash = B.sha512;
  }
  return eddsa = se, se.prototype.sign = function(ge, le) {
    ge = oe(ge);
    var Ee = this.keyFromSecret(le), Ce = this.hashInt(Ee.messagePrefix(), ge), Pe = this.g.mul(Ce), Xe = this.encodePoint(Pe), ht = this.hashInt(Xe, Ee.pubBytes(), ge).mul(Ee.priv()), wt = Ce.add(ht).umod(this.curve.n);
    return this.makeSignature({ R: Pe, S: wt, Rencoded: Xe });
  }, se.prototype.verify = function(ge, le, Ee) {
    if (ge = oe(ge), le = this.makeSignature(le), le.S().gte(le.eddsa.curve.n) || le.S().isNeg())
      return !1;
    var Ce = this.keyFromPublic(Ee), Pe = this.hashInt(le.Rencoded(), Ce.pubBytes(), ge), Xe = this.g.mul(le.S()), ht = le.R().add(Ce.pub().mul(Pe));
    return ht.eq(Xe);
  }, se.prototype.hashInt = function() {
    for (var ge = this.hash(), le = 0; le < arguments.length; le++)
      ge.update(arguments[le]);
    return Y.intFromLE(ge.digest()).umod(this.curve.n);
  }, se.prototype.keyFromPublic = function(ge) {
    return ie.fromPublic(this, ge);
  }, se.prototype.keyFromSecret = function(ge) {
    return ie.fromSecret(this, ge);
  }, se.prototype.makeSignature = function(ge) {
    return ge instanceof ae ? ge : new ae(this, ge);
  }, se.prototype.encodePoint = function(ge) {
    var le = ge.getY().toArray("le", this.encodingLength);
    return le[this.encodingLength - 1] |= ge.getX().isOdd() ? 128 : 0, le;
  }, se.prototype.decodePoint = function(ge) {
    ge = Y.parseBytes(ge);
    var le = ge.length - 1, Ee = ge.slice(0, le).concat(ge[le] & -129), Ce = (ge[le] & 128) !== 0, Pe = Y.intFromLE(Ee);
    return this.curve.pointFromY(Pe, Ce);
  }, se.prototype.encodeInt = function(ge) {
    return ge.toArray("le", this.encodingLength);
  }, se.prototype.decodeInt = function(ge) {
    return Y.intFromLE(ge);
  }, se.prototype.isPoint = function(ge) {
    return ge instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var z = B;
    z.version = require$$0.version, z.utils = requireUtils$1(), z.rand = requireBrorand(), z.curve = requireCurve(), z.curves = requireCurves(), z.ec = requireEc(), z.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, z) {
      if (B.indexOf) return B.indexOf(z);
      for (var Y = 0; Y < B.length; Y++)
        if (B[Y] === z) return Y;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var z = [];
      for (var Y in B) z.push(Y);
      return z;
    }, forEach = function(B, z) {
      if (B.forEach) return B.forEach(z);
      for (var Y = 0; Y < B.length; Y++)
        z(B[Y], Y, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, z, Y) {
          Object.defineProperty(B, z, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Y
          });
        };
      } catch {
        return function(z, Y, ne) {
          z[Y] = ne;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(z) {
      if (!(this instanceof Script)) return new Script(z);
      this.code = z;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var z = document.createElement("iframe");
      z.style || (z.style = {}), z.style.display = "none", document.body.appendChild(z);
      var Y = z.contentWindow, ne = Y.eval, oe = Y.execScript;
      !ne && oe && (oe.call(Y, "null"), ne = Y.eval), forEach(Object_keys(B), function(se) {
        Y[se] = B[se];
      }), forEach(globals, function(se) {
        B[se] && (Y[se] = B[se]);
      });
      var ie = Object_keys(Y), ae = ne.call(Y, this.code);
      return forEach(Object_keys(Y), function(se) {
        (se in B || indexOf(ie, se) === -1) && (B[se] = Y[se]);
      }), forEach(globals, function(se) {
        se in B || defineProp(B, se, Y[se]);
      }), document.body.removeChild(z), ae;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var z = Script.createContext(B), Y = this.runInContext(z);
      return B && forEach(Object_keys(z), function(ne) {
        B[ne] = z[ne];
      }), Y;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(z) {
        var Y = Script(z);
        return Y[B].apply(Y, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var z = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(Y) {
        z[Y] = B[Y];
      }), z;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var z = requireAsn1$1(), Y = requireInherits_browser(), ne = B;
    ne.define = function(ae, se) {
      return new oe(ae, se);
    };
    function oe(ie, ae) {
      this.name = ie, this.body = ae, this.decoders = {}, this.encoders = {};
    }
    oe.prototype._createNamed = function(ae) {
      var se;
      try {
        se = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        se = function(ge) {
          this._initNamed(ge);
        };
      }
      return Y(se, ae), se.prototype._initNamed = function(ge) {
        ae.call(this, ge);
      }, new se(this);
    }, oe.prototype._getDecoder = function(ae) {
      return ae = ae || "der", this.decoders.hasOwnProperty(ae) || (this.decoders[ae] = this._createNamed(z.decoders[ae])), this.decoders[ae];
    }, oe.prototype.decode = function(ae, se, ve) {
      return this._getDecoder(se).decode(ae, ve);
    }, oe.prototype._getEncoder = function(ae) {
      return ae = ae || "der", this.encoders.hasOwnProperty(ae) || (this.encoders[ae] = this._createNamed(z.encoders[ae])), this.encoders[ae];
    }, oe.prototype.encode = function(ae, se, ve) {
      return this._getEncoder(se).encode(ae, ve);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var B = requireInherits_browser();
  function z(ne) {
    this._reporterState = {
      obj: null,
      path: [],
      options: ne || {},
      errors: []
    };
  }
  reporter.Reporter = z, z.prototype.isError = function(oe) {
    return oe instanceof Y;
  }, z.prototype.save = function() {
    var oe = this._reporterState;
    return { obj: oe.obj, pathLen: oe.path.length };
  }, z.prototype.restore = function(oe) {
    var ie = this._reporterState;
    ie.obj = oe.obj, ie.path = ie.path.slice(0, oe.pathLen);
  }, z.prototype.enterKey = function(oe) {
    return this._reporterState.path.push(oe);
  }, z.prototype.exitKey = function(oe) {
    var ie = this._reporterState;
    ie.path = ie.path.slice(0, oe - 1);
  }, z.prototype.leaveKey = function(oe, ie, ae) {
    var se = this._reporterState;
    this.exitKey(oe), se.obj !== null && (se.obj[ie] = ae);
  }, z.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, z.prototype.enterObject = function() {
    var oe = this._reporterState, ie = oe.obj;
    return oe.obj = {}, ie;
  }, z.prototype.leaveObject = function(oe) {
    var ie = this._reporterState, ae = ie.obj;
    return ie.obj = oe, ae;
  }, z.prototype.error = function(oe) {
    var ie, ae = this._reporterState, se = oe instanceof Y;
    if (se ? ie = oe : ie = new Y(ae.path.map(function(ve) {
      return "[" + JSON.stringify(ve) + "]";
    }).join(""), oe.message || oe, oe.stack), !ae.options.partial)
      throw ie;
    return se || ae.errors.push(ie), ie;
  }, z.prototype.wrapResult = function(oe) {
    var ie = this._reporterState;
    return ie.options.partial ? {
      result: this.isError(oe) ? null : oe,
      errors: ie.errors
    } : oe;
  };
  function Y(ne, oe) {
    this.path = ne, this.rethrow(oe);
  }
  return B(Y, Error), Y.prototype.rethrow = function(oe) {
    if (this.message = oe + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Y), !this.stack)
      try {
        throw new Error(this.message);
      } catch (ie) {
        this.stack = ie.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = requireInherits_browser(), z = requireBase().Reporter, Y = dist$1.Buffer;
  function ne(ie, ae) {
    if (z.call(this, ae), !Y.isBuffer(ie)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = ie, this.offset = 0, this.length = ie.length;
  }
  B(ne, z), buffer.DecoderBuffer = ne, ne.prototype.save = function() {
    return { offset: this.offset, reporter: z.prototype.save.call(this) };
  }, ne.prototype.restore = function(ae) {
    var se = new ne(this.base);
    return se.offset = ae.offset, se.length = this.offset, this.offset = ae.offset, z.prototype.restore.call(this, ae.reporter), se;
  }, ne.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, ne.prototype.readUInt8 = function(ae) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ae || "DecoderBuffer overrun");
  }, ne.prototype.skip = function(ae, se) {
    if (!(this.offset + ae <= this.length))
      return this.error(se || "DecoderBuffer overrun");
    var ve = new ne(this.base);
    return ve._reporterState = this._reporterState, ve.offset = this.offset, ve.length = this.offset + ae, this.offset += ae, ve;
  }, ne.prototype.raw = function(ae) {
    return this.base.slice(ae ? ae.offset : this.offset, this.length);
  };
  function oe(ie, ae) {
    if (Array.isArray(ie))
      this.length = 0, this.value = ie.map(function(se) {
        return se instanceof oe || (se = new oe(se, ae)), this.length += se.length, se;
      }, this);
    else if (typeof ie == "number") {
      if (!(0 <= ie && ie <= 255))
        return ae.error("non-byte EncoderBuffer value");
      this.value = ie, this.length = 1;
    } else if (typeof ie == "string")
      this.value = ie, this.length = Y.byteLength(ie);
    else if (Y.isBuffer(ie))
      this.value = ie, this.length = ie.length;
    else
      return ae.error("Unsupported type: " + typeof ie);
  }
  return buffer.EncoderBuffer = oe, oe.prototype.join = function(ae, se) {
    return ae || (ae = new Y(this.length)), se || (se = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ve) {
      ve.join(ae, se), se += ve.length;
    }) : (typeof this.value == "number" ? ae[se] = this.value : typeof this.value == "string" ? ae.write(this.value, se) : Y.isBuffer(this.value) && this.value.copy(ae, se), se += this.length)), ae;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, z = requireBase().EncoderBuffer, Y = requireBase().DecoderBuffer, ne = requireMinimalisticAssert(), oe = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], ie = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(oe), ae = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function se(ge, le) {
    var Ee = {};
    this._baseState = Ee, Ee.enc = ge, Ee.parent = le || null, Ee.children = null, Ee.tag = null, Ee.args = null, Ee.reverseArgs = null, Ee.choice = null, Ee.optional = !1, Ee.any = !1, Ee.obj = !1, Ee.use = null, Ee.useDecoder = null, Ee.key = null, Ee.default = null, Ee.explicit = null, Ee.implicit = null, Ee.contains = null, Ee.parent || (Ee.children = [], this._wrap());
  }
  node = se;
  var ve = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return se.prototype.clone = function() {
    var le = this._baseState, Ee = {};
    ve.forEach(function(Pe) {
      Ee[Pe] = le[Pe];
    });
    var Ce = new this.constructor(Ee.parent);
    return Ce._baseState = Ee, Ce;
  }, se.prototype._wrap = function() {
    var le = this._baseState;
    ie.forEach(function(Ee) {
      this[Ee] = function() {
        var Pe = new this.constructor(this);
        return le.children.push(Pe), Pe[Ee].apply(Pe, arguments);
      };
    }, this);
  }, se.prototype._init = function(le) {
    var Ee = this._baseState;
    ne(Ee.parent === null), le.call(this), Ee.children = Ee.children.filter(function(Ce) {
      return Ce._baseState.parent === this;
    }, this), ne.equal(Ee.children.length, 1, "Root node can have only one child");
  }, se.prototype._useArgs = function(le) {
    var Ee = this._baseState, Ce = le.filter(function(Pe) {
      return Pe instanceof this.constructor;
    }, this);
    le = le.filter(function(Pe) {
      return !(Pe instanceof this.constructor);
    }, this), Ce.length !== 0 && (ne(Ee.children === null), Ee.children = Ce, Ce.forEach(function(Pe) {
      Pe._baseState.parent = this;
    }, this)), le.length !== 0 && (ne(Ee.args === null), Ee.args = le, Ee.reverseArgs = le.map(function(Pe) {
      if (typeof Pe != "object" || Pe.constructor !== Object)
        return Pe;
      var Xe = {};
      return Object.keys(Pe).forEach(function(ht) {
        ht == (ht | 0) && (ht |= 0);
        var wt = Pe[ht];
        Xe[wt] = ht;
      }), Xe;
    }));
  }, ae.forEach(function(ge) {
    se.prototype[ge] = function() {
      var Ee = this._baseState;
      throw new Error(ge + " not implemented for encoding: " + Ee.enc);
    };
  }), oe.forEach(function(ge) {
    se.prototype[ge] = function() {
      var Ee = this._baseState, Ce = Array.prototype.slice.call(arguments);
      return ne(Ee.tag === null), Ee.tag = ge, this._useArgs(Ce), this;
    };
  }), se.prototype.use = function(le) {
    ne(le);
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.use = le, this;
  }, se.prototype.optional = function() {
    var le = this._baseState;
    return le.optional = !0, this;
  }, se.prototype.def = function(le) {
    var Ee = this._baseState;
    return ne(Ee.default === null), Ee.default = le, Ee.optional = !0, this;
  }, se.prototype.explicit = function(le) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.explicit = le, this;
  }, se.prototype.implicit = function(le) {
    var Ee = this._baseState;
    return ne(Ee.explicit === null && Ee.implicit === null), Ee.implicit = le, this;
  }, se.prototype.obj = function() {
    var le = this._baseState, Ee = Array.prototype.slice.call(arguments);
    return le.obj = !0, Ee.length !== 0 && this._useArgs(Ee), this;
  }, se.prototype.key = function(le) {
    var Ee = this._baseState;
    return ne(Ee.key === null), Ee.key = le, this;
  }, se.prototype.any = function() {
    var le = this._baseState;
    return le.any = !0, this;
  }, se.prototype.choice = function(le) {
    var Ee = this._baseState;
    return ne(Ee.choice === null), Ee.choice = le, this._useArgs(Object.keys(le).map(function(Ce) {
      return le[Ce];
    })), this;
  }, se.prototype.contains = function(le) {
    var Ee = this._baseState;
    return ne(Ee.use === null), Ee.contains = le, this;
  }, se.prototype._decode = function(le, Ee) {
    var Ce = this._baseState;
    if (Ce.parent === null)
      return le.wrapResult(Ce.children[0]._decode(le, Ee));
    var Pe = Ce.default, Xe = !0, ht = null;
    if (Ce.key !== null && (ht = le.enterKey(Ce.key)), Ce.optional) {
      var wt = null;
      if (Ce.explicit !== null ? wt = Ce.explicit : Ce.implicit !== null ? wt = Ce.implicit : Ce.tag !== null && (wt = Ce.tag), wt === null && !Ce.any) {
        var Pt = le.save();
        try {
          Ce.choice === null ? this._decodeGeneric(Ce.tag, le, Ee) : this._decodeChoice(le, Ee), Xe = !0;
        } catch {
          Xe = !1;
        }
        le.restore(Pt);
      } else if (Xe = this._peekTag(le, wt, Ce.any), le.isError(Xe))
        return Xe;
    }
    var vt;
    if (Ce.obj && Xe && (vt = le.enterObject()), Xe) {
      if (Ce.explicit !== null) {
        var Bt = this._decodeTag(le, Ce.explicit);
        if (le.isError(Bt))
          return Bt;
        le = Bt;
      }
      var Ct = le.offset;
      if (Ce.use === null && Ce.choice === null) {
        if (Ce.any)
          var Pt = le.save();
        var Wt = this._decodeTag(
          le,
          Ce.implicit !== null ? Ce.implicit : Ce.tag,
          Ce.any
        );
        if (le.isError(Wt))
          return Wt;
        Ce.any ? Pe = le.raw(Pt) : le = Wt;
      }
      if (Ee && Ee.track && Ce.tag !== null && Ee.track(le.path(), Ct, le.length, "tagged"), Ee && Ee.track && Ce.tag !== null && Ee.track(le.path(), le.offset, le.length, "content"), Ce.any ? Pe = Pe : Ce.choice === null ? Pe = this._decodeGeneric(Ce.tag, le, Ee) : Pe = this._decodeChoice(le, Ee), le.isError(Pe))
        return Pe;
      if (!Ce.any && Ce.choice === null && Ce.children !== null && Ce.children.forEach(function(Ut) {
        Ut._decode(le, Ee);
      }), Ce.contains && (Ce.tag === "octstr" || Ce.tag === "bitstr")) {
        var Kt = new Y(Pe);
        Pe = this._getUse(Ce.contains, le._reporterState.obj)._decode(Kt, Ee);
      }
    }
    return Ce.obj && Xe && (Pe = le.leaveObject(vt)), Ce.key !== null && (Pe !== null || Xe === !0) ? le.leaveKey(ht, Ce.key, Pe) : ht !== null && le.exitKey(ht), Pe;
  }, se.prototype._decodeGeneric = function(le, Ee, Ce) {
    var Pe = this._baseState;
    return le === "seq" || le === "set" ? null : le === "seqof" || le === "setof" ? this._decodeList(Ee, le, Pe.args[0], Ce) : /str$/.test(le) ? this._decodeStr(Ee, le, Ce) : le === "objid" && Pe.args ? this._decodeObjid(Ee, Pe.args[0], Pe.args[1], Ce) : le === "objid" ? this._decodeObjid(Ee, null, null, Ce) : le === "gentime" || le === "utctime" ? this._decodeTime(Ee, le, Ce) : le === "null_" ? this._decodeNull(Ee, Ce) : le === "bool" ? this._decodeBool(Ee, Ce) : le === "objDesc" ? this._decodeStr(Ee, le, Ce) : le === "int" || le === "enum" ? this._decodeInt(Ee, Pe.args && Pe.args[0], Ce) : Pe.use !== null ? this._getUse(Pe.use, Ee._reporterState.obj)._decode(Ee, Ce) : Ee.error("unknown tag: " + le);
  }, se.prototype._getUse = function(le, Ee) {
    var Ce = this._baseState;
    return Ce.useDecoder = this._use(le, Ee), ne(Ce.useDecoder._baseState.parent === null), Ce.useDecoder = Ce.useDecoder._baseState.children[0], Ce.implicit !== Ce.useDecoder._baseState.implicit && (Ce.useDecoder = Ce.useDecoder.clone(), Ce.useDecoder._baseState.implicit = Ce.implicit), Ce.useDecoder;
  }, se.prototype._decodeChoice = function(le, Ee) {
    var Ce = this._baseState, Pe = null, Xe = !1;
    return Object.keys(Ce.choice).some(function(ht) {
      var wt = le.save(), Pt = Ce.choice[ht];
      try {
        var vt = Pt._decode(le, Ee);
        if (le.isError(vt))
          return !1;
        Pe = { type: ht, value: vt }, Xe = !0;
      } catch {
        return le.restore(wt), !1;
      }
      return !0;
    }, this), Xe ? Pe : le.error("Choice not matched");
  }, se.prototype._createEncoderBuffer = function(le) {
    return new z(le, this.reporter);
  }, se.prototype._encode = function(le, Ee, Ce) {
    var Pe = this._baseState;
    if (!(Pe.default !== null && Pe.default === le)) {
      var Xe = this._encodeValue(le, Ee, Ce);
      if (Xe !== void 0 && !this._skipDefault(Xe, Ee, Ce))
        return Xe;
    }
  }, se.prototype._encodeValue = function(le, Ee, Ce) {
    var Pe = this._baseState;
    if (Pe.parent === null)
      return Pe.children[0]._encode(le, Ee || new B());
    var Pt = null;
    if (this.reporter = Ee, Pe.optional && le === void 0)
      if (Pe.default !== null)
        le = Pe.default;
      else
        return;
    var Xe = null, ht = !1;
    if (Pe.any)
      Pt = this._createEncoderBuffer(le);
    else if (Pe.choice)
      Pt = this._encodeChoice(le, Ee);
    else if (Pe.contains)
      Xe = this._getUse(Pe.contains, Ce)._encode(le, Ee), ht = !0;
    else if (Pe.children)
      Xe = Pe.children.map(function(Ct) {
        if (Ct._baseState.tag === "null_")
          return Ct._encode(null, Ee, le);
        if (Ct._baseState.key === null)
          return Ee.error("Child should have a key");
        var Wt = Ee.enterKey(Ct._baseState.key);
        if (typeof le != "object")
          return Ee.error("Child expected, but input is not object");
        var Kt = Ct._encode(le[Ct._baseState.key], Ee, le);
        return Ee.leaveKey(Wt), Kt;
      }, this).filter(function(Ct) {
        return Ct;
      }), Xe = this._createEncoderBuffer(Xe);
    else if (Pe.tag === "seqof" || Pe.tag === "setof") {
      if (!(Pe.args && Pe.args.length === 1))
        return Ee.error("Too many args for : " + Pe.tag);
      if (!Array.isArray(le))
        return Ee.error("seqof/setof, but data is not Array");
      var wt = this.clone();
      wt._baseState.implicit = null, Xe = this._createEncoderBuffer(le.map(function(Ct) {
        var Wt = this._baseState;
        return this._getUse(Wt.args[0], le)._encode(Ct, Ee);
      }, wt));
    } else Pe.use !== null ? Pt = this._getUse(Pe.use, Ce)._encode(le, Ee) : (Xe = this._encodePrimitive(Pe.tag, le), ht = !0);
    var Pt;
    if (!Pe.any && Pe.choice === null) {
      var vt = Pe.implicit !== null ? Pe.implicit : Pe.tag, Bt = Pe.implicit === null ? "universal" : "context";
      vt === null ? Pe.use === null && Ee.error("Tag could be omitted only for .use()") : Pe.use === null && (Pt = this._encodeComposite(vt, ht, Bt, Xe));
    }
    return Pe.explicit !== null && (Pt = this._encodeComposite(Pe.explicit, !1, "context", Pt)), Pt;
  }, se.prototype._encodeChoice = function(le, Ee) {
    var Ce = this._baseState, Pe = Ce.choice[le.type];
    return Pe || ne(
      !1,
      le.type + " not found in " + JSON.stringify(Object.keys(Ce.choice))
    ), Pe._encode(le.value, Ee);
  }, se.prototype._encodePrimitive = function(le, Ee) {
    var Ce = this._baseState;
    if (/str$/.test(le))
      return this._encodeStr(Ee, le);
    if (le === "objid" && Ce.args)
      return this._encodeObjid(Ee, Ce.reverseArgs[0], Ce.args[1]);
    if (le === "objid")
      return this._encodeObjid(Ee, null, null);
    if (le === "gentime" || le === "utctime")
      return this._encodeTime(Ee, le);
    if (le === "null_")
      return this._encodeNull();
    if (le === "int" || le === "enum")
      return this._encodeInt(Ee, Ce.args && Ce.reverseArgs[0]);
    if (le === "bool")
      return this._encodeBool(Ee);
    if (le === "objDesc")
      return this._encodeStr(Ee, le);
    throw new Error("Unsupported tag: " + le);
  }, se.prototype._isNumstr = function(le) {
    return /^[0-9 ]*$/.test(le);
  }, se.prototype._isPrintstr = function(le) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(le);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var z = B;
    z.Reporter = requireReporter().Reporter, z.DecoderBuffer = requireBuffer().DecoderBuffer, z.EncoderBuffer = requireBuffer().EncoderBuffer, z.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var z = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = z._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = z._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var z = B;
    z._reverse = function(ne) {
      var oe = {};
      return Object.keys(ne).forEach(function(ie) {
        (ie | 0) == ie && (ie = ie | 0);
        var ae = ne[ie];
        oe[ae] = ie;
      }), oe;
    }, z.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = requireInherits_browser(), z = requireAsn1$1(), Y = z.base, ne = z.bignum, oe = z.constants.der;
  function ie(ge) {
    this.enc = "der", this.name = ge.name, this.entity = ge, this.tree = new ae(), this.tree._init(ge.body);
  }
  der_1$1 = ie, ie.prototype.decode = function(le, Ee) {
    return le instanceof Y.DecoderBuffer || (le = new Y.DecoderBuffer(le, Ee)), this.tree._decode(le, Ee);
  };
  function ae(ge) {
    Y.Node.call(this, "der", ge);
  }
  B(ae, Y.Node), ae.prototype._peekTag = function(le, Ee, Ce) {
    if (le.isEmpty())
      return !1;
    var Pe = le.save(), Xe = se(le, 'Failed to peek tag: "' + Ee + '"');
    return le.isError(Xe) ? Xe : (le.restore(Pe), Xe.tag === Ee || Xe.tagStr === Ee || Xe.tagStr + "of" === Ee || Ce);
  }, ae.prototype._decodeTag = function(le, Ee, Ce) {
    var Pe = se(
      le,
      'Failed to decode tag of "' + Ee + '"'
    );
    if (le.isError(Pe))
      return Pe;
    var Xe = ve(
      le,
      Pe.primitive,
      'Failed to get length of "' + Ee + '"'
    );
    if (le.isError(Xe))
      return Xe;
    if (!Ce && Pe.tag !== Ee && Pe.tagStr !== Ee && Pe.tagStr + "of" !== Ee)
      return le.error('Failed to match tag: "' + Ee + '"');
    if (Pe.primitive || Xe !== null)
      return le.skip(Xe, 'Failed to match body of: "' + Ee + '"');
    var ht = le.save(), wt = this._skipUntilEnd(
      le,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return le.isError(wt) ? wt : (Xe = le.offset - ht.offset, le.restore(ht), le.skip(Xe, 'Failed to match body of: "' + Ee + '"'));
  }, ae.prototype._skipUntilEnd = function(le, Ee) {
    for (; ; ) {
      var Ce = se(le, Ee);
      if (le.isError(Ce))
        return Ce;
      var Pe = ve(le, Ce.primitive, Ee);
      if (le.isError(Pe))
        return Pe;
      var Xe;
      if (Ce.primitive || Pe !== null ? Xe = le.skip(Pe) : Xe = this._skipUntilEnd(le, Ee), le.isError(Xe))
        return Xe;
      if (Ce.tagStr === "end")
        break;
    }
  }, ae.prototype._decodeList = function(le, Ee, Ce, Pe) {
    for (var Xe = []; !le.isEmpty(); ) {
      var ht = this._peekTag(le, "end");
      if (le.isError(ht))
        return ht;
      var wt = Ce.decode(le, "der", Pe);
      if (le.isError(wt) && ht)
        break;
      Xe.push(wt);
    }
    return Xe;
  }, ae.prototype._decodeStr = function(le, Ee) {
    if (Ee === "bitstr") {
      var Ce = le.readUInt8();
      return le.isError(Ce) ? Ce : { unused: Ce, data: le.raw() };
    } else if (Ee === "bmpstr") {
      var Pe = le.raw();
      if (Pe.length % 2 === 1)
        return le.error("Decoding of string type: bmpstr length mismatch");
      for (var Xe = "", ht = 0; ht < Pe.length / 2; ht++)
        Xe += String.fromCharCode(Pe.readUInt16BE(ht * 2));
      return Xe;
    } else if (Ee === "numstr") {
      var wt = le.raw().toString("ascii");
      return this._isNumstr(wt) ? wt : le.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (Ee === "octstr")
        return le.raw();
      if (Ee === "objDesc")
        return le.raw();
      if (Ee === "printstr") {
        var Pt = le.raw().toString("ascii");
        return this._isPrintstr(Pt) ? Pt : le.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(Ee) ? le.raw().toString() : le.error("Decoding of string type: " + Ee + " unsupported");
    }
  }, ae.prototype._decodeObjid = function(le, Ee, Ce) {
    for (var Pe, Xe = [], ht = 0; !le.isEmpty(); ) {
      var wt = le.readUInt8();
      ht <<= 7, ht |= wt & 127, wt & 128 || (Xe.push(ht), ht = 0);
    }
    wt & 128 && Xe.push(ht);
    var Pt = Xe[0] / 40 | 0, vt = Xe[0] % 40;
    if (Ce ? Pe = Xe : Pe = [Pt, vt].concat(Xe.slice(1)), Ee) {
      var Bt = Ee[Pe.join(" ")];
      Bt === void 0 && (Bt = Ee[Pe.join(".")]), Bt !== void 0 && (Pe = Bt);
    }
    return Pe;
  }, ae.prototype._decodeTime = function(le, Ee) {
    var Ce = le.raw().toString();
    if (Ee === "gentime")
      var Pe = Ce.slice(0, 4) | 0, Xe = Ce.slice(4, 6) | 0, ht = Ce.slice(6, 8) | 0, wt = Ce.slice(8, 10) | 0, Pt = Ce.slice(10, 12) | 0, vt = Ce.slice(12, 14) | 0;
    else if (Ee === "utctime") {
      var Pe = Ce.slice(0, 2) | 0, Xe = Ce.slice(2, 4) | 0, ht = Ce.slice(4, 6) | 0, wt = Ce.slice(6, 8) | 0, Pt = Ce.slice(8, 10) | 0, vt = Ce.slice(10, 12) | 0;
      Pe < 70 ? Pe = 2e3 + Pe : Pe = 1900 + Pe;
    } else
      return le.error("Decoding " + Ee + " time is not supported yet");
    return Date.UTC(Pe, Xe - 1, ht, wt, Pt, vt, 0);
  }, ae.prototype._decodeNull = function(le) {
    return null;
  }, ae.prototype._decodeBool = function(le) {
    var Ee = le.readUInt8();
    return le.isError(Ee) ? Ee : Ee !== 0;
  }, ae.prototype._decodeInt = function(le, Ee) {
    var Ce = le.raw(), Pe = new ne(Ce);
    return Ee && (Pe = Ee[Pe.toString(10)] || Pe), Pe;
  }, ae.prototype._use = function(le, Ee) {
    return typeof le == "function" && (le = le(Ee)), le._getDecoder("der").tree;
  };
  function se(ge, le) {
    var Ee = ge.readUInt8(le);
    if (ge.isError(Ee))
      return Ee;
    var Ce = oe.tagClass[Ee >> 6], Pe = (Ee & 32) === 0;
    if ((Ee & 31) === 31) {
      var Xe = Ee;
      for (Ee = 0; (Xe & 128) === 128; ) {
        if (Xe = ge.readUInt8(le), ge.isError(Xe))
          return Xe;
        Ee <<= 7, Ee |= Xe & 127;
      }
    } else
      Ee &= 31;
    var ht = oe.tag[Ee];
    return {
      cls: Ce,
      primitive: Pe,
      tag: Ee,
      tagStr: ht
    };
  }
  function ve(ge, le, Ee) {
    var Ce = ge.readUInt8(Ee);
    if (ge.isError(Ce))
      return Ce;
    if (!le && Ce === 128)
      return null;
    if (!(Ce & 128))
      return Ce;
    var Pe = Ce & 127;
    if (Pe > 4)
      return ge.error("length octect is too long");
    Ce = 0;
    for (var Xe = 0; Xe < Pe; Xe++) {
      Ce <<= 8;
      var ht = ge.readUInt8(Ee);
      if (ge.isError(ht))
        return ht;
      Ce |= ht;
    }
    return Ce;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = requireInherits_browser(), z = dist$1.Buffer, Y = requireDer$1();
  function ne(oe) {
    Y.call(this, oe), this.enc = "pem";
  }
  return B(ne, Y), pem$1 = ne, ne.prototype.decode = function(ie, ae) {
    for (var se = ie.toString().split(/[\r\n]+/g), ve = ae.label.toUpperCase(), ge = /^-----(BEGIN|END) ([^-]+)-----$/, le = -1, Ee = -1, Ce = 0; Ce < se.length; Ce++) {
      var Pe = se[Ce].match(ge);
      if (Pe !== null && Pe[2] === ve)
        if (le === -1) {
          if (Pe[1] !== "BEGIN")
            break;
          le = Ce;
        } else {
          if (Pe[1] !== "END")
            break;
          Ee = Ce;
          break;
        }
    }
    if (le === -1 || Ee === -1)
      throw new Error("PEM section not found for: " + ve);
    var Xe = se.slice(le + 1, Ee).join("");
    Xe.replace(/[^a-z0-9\+\/=]+/gi, "");
    var ht = new z(Xe, "base64");
    return Y.prototype.decode.call(this, ht, ae);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var z = B;
    z.der = requireDer$1(), z.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = requireInherits_browser(), z = dist$1.Buffer, Y = requireAsn1$1(), ne = Y.base, oe = Y.constants.der;
  function ie(ge) {
    this.enc = "der", this.name = ge.name, this.entity = ge, this.tree = new ae(), this.tree._init(ge.body);
  }
  der_1 = ie, ie.prototype.encode = function(le, Ee) {
    return this.tree._encode(le, Ee).join();
  };
  function ae(ge) {
    ne.Node.call(this, "der", ge);
  }
  B(ae, ne.Node), ae.prototype._encodeComposite = function(le, Ee, Ce, Pe) {
    var Xe = ve(le, Ee, Ce, this.reporter);
    if (Pe.length < 128) {
      var Pt = new z(2);
      return Pt[0] = Xe, Pt[1] = Pe.length, this._createEncoderBuffer([Pt, Pe]);
    }
    for (var ht = 1, wt = Pe.length; wt >= 256; wt >>= 8)
      ht++;
    var Pt = new z(2 + ht);
    Pt[0] = Xe, Pt[1] = 128 | ht;
    for (var wt = 1 + ht, vt = Pe.length; vt > 0; wt--, vt >>= 8)
      Pt[wt] = vt & 255;
    return this._createEncoderBuffer([Pt, Pe]);
  }, ae.prototype._encodeStr = function(le, Ee) {
    if (Ee === "bitstr")
      return this._createEncoderBuffer([le.unused | 0, le.data]);
    if (Ee === "bmpstr") {
      for (var Ce = new z(le.length * 2), Pe = 0; Pe < le.length; Pe++)
        Ce.writeUInt16BE(le.charCodeAt(Pe), Pe * 2);
      return this._createEncoderBuffer(Ce);
    } else return Ee === "numstr" ? this._isNumstr(le) ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : Ee === "printstr" ? this._isPrintstr(le) ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(Ee) ? this._createEncoderBuffer(le) : Ee === "objDesc" ? this._createEncoderBuffer(le) : this.reporter.error("Encoding of string type: " + Ee + " unsupported");
  }, ae.prototype._encodeObjid = function(le, Ee, Ce) {
    if (typeof le == "string") {
      if (!Ee)
        return this.reporter.error("string objid given, but no values map found");
      if (!Ee.hasOwnProperty(le))
        return this.reporter.error("objid not found in values map");
      le = Ee[le].split(/[\s\.]+/g);
      for (var Pe = 0; Pe < le.length; Pe++)
        le[Pe] |= 0;
    } else if (Array.isArray(le)) {
      le = le.slice();
      for (var Pe = 0; Pe < le.length; Pe++)
        le[Pe] |= 0;
    }
    if (!Array.isArray(le))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(le));
    if (!Ce) {
      if (le[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      le.splice(0, 2, le[0] * 40 + le[1]);
    }
    for (var Xe = 0, Pe = 0; Pe < le.length; Pe++) {
      var ht = le[Pe];
      for (Xe++; ht >= 128; ht >>= 7)
        Xe++;
    }
    for (var wt = new z(Xe), Pt = wt.length - 1, Pe = le.length - 1; Pe >= 0; Pe--) {
      var ht = le[Pe];
      for (wt[Pt--] = ht & 127; (ht >>= 7) > 0; )
        wt[Pt--] = 128 | ht & 127;
    }
    return this._createEncoderBuffer(wt);
  };
  function se(ge) {
    return ge < 10 ? "0" + ge : ge;
  }
  ae.prototype._encodeTime = function(le, Ee) {
    var Ce, Pe = new Date(le);
    return Ee === "gentime" ? Ce = [
      se(Pe.getFullYear()),
      se(Pe.getUTCMonth() + 1),
      se(Pe.getUTCDate()),
      se(Pe.getUTCHours()),
      se(Pe.getUTCMinutes()),
      se(Pe.getUTCSeconds()),
      "Z"
    ].join("") : Ee === "utctime" ? Ce = [
      se(Pe.getFullYear() % 100),
      se(Pe.getUTCMonth() + 1),
      se(Pe.getUTCDate()),
      se(Pe.getUTCHours()),
      se(Pe.getUTCMinutes()),
      se(Pe.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + Ee + " time is not supported yet"), this._encodeStr(Ce, "octstr");
  }, ae.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, ae.prototype._encodeInt = function(le, Ee) {
    if (typeof le == "string") {
      if (!Ee)
        return this.reporter.error("String int or enum given, but no values map");
      if (!Ee.hasOwnProperty(le))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(le));
      le = Ee[le];
    }
    if (typeof le != "number" && !z.isBuffer(le)) {
      var Ce = le.toArray();
      !le.sign && Ce[0] & 128 && Ce.unshift(0), le = new z(Ce);
    }
    if (z.isBuffer(le)) {
      var Pe = le.length;
      le.length === 0 && Pe++;
      var ht = new z(Pe);
      return le.copy(ht), le.length === 0 && (ht[0] = 0), this._createEncoderBuffer(ht);
    }
    if (le < 128)
      return this._createEncoderBuffer(le);
    if (le < 256)
      return this._createEncoderBuffer([0, le]);
    for (var Pe = 1, Xe = le; Xe >= 256; Xe >>= 8)
      Pe++;
    for (var ht = new Array(Pe), Xe = ht.length - 1; Xe >= 0; Xe--)
      ht[Xe] = le & 255, le >>= 8;
    return ht[0] & 128 && ht.unshift(0), this._createEncoderBuffer(new z(ht));
  }, ae.prototype._encodeBool = function(le) {
    return this._createEncoderBuffer(le ? 255 : 0);
  }, ae.prototype._use = function(le, Ee) {
    return typeof le == "function" && (le = le(Ee)), le._getEncoder("der").tree;
  }, ae.prototype._skipDefault = function(le, Ee, Ce) {
    var Pe = this._baseState, Xe;
    if (Pe.default === null)
      return !1;
    var ht = le.join();
    if (Pe.defaultBuffer === void 0 && (Pe.defaultBuffer = this._encodeValue(Pe.default, Ee, Ce).join()), ht.length !== Pe.defaultBuffer.length)
      return !1;
    for (Xe = 0; Xe < ht.length; Xe++)
      if (ht[Xe] !== Pe.defaultBuffer[Xe])
        return !1;
    return !0;
  };
  function ve(ge, le, Ee, Ce) {
    var Pe;
    if (ge === "seqof" ? ge = "seq" : ge === "setof" && (ge = "set"), oe.tagByName.hasOwnProperty(ge))
      Pe = oe.tagByName[ge];
    else if (typeof ge == "number" && (ge | 0) === ge)
      Pe = ge;
    else
      return Ce.error("Unknown tag: " + ge);
    return Pe >= 31 ? Ce.error("Multi-octet tag encoding unsupported") : (le || (Pe |= 32), Pe |= oe.tagClassByName[Ee || "universal"] << 6, Pe);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = requireInherits_browser(), z = requireDer();
  function Y(ne) {
    z.call(this, ne), this.enc = "pem";
  }
  return B(Y, z), pem = Y, Y.prototype.encode = function(oe, ie) {
    for (var ae = z.prototype.encode.call(this, oe), se = ae.toString("base64"), ve = ["-----BEGIN " + ie.label + "-----"], ge = 0; ge < se.length; ge += 64)
      ve.push(se.slice(ge, ge + 64));
    return ve.push("-----END " + ie.label + "-----"), ve.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var z = B;
    z.der = requireDer(), z.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(B) {
    var z = B;
    z.bignum = requireBn$1(), z.define = requireApi().define, z.base = requireBase(), z.constants = requireConstants(), z.decoders = requireDecoders(), z.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var B = requireAsn1$1(), z = B.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Y = B.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), ne = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), oe = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(ne),
      this.key("subjectPublicKey").bitstr()
    );
  }), ie = B.define("RelativeDistinguishedName", function() {
    this.setof(Y);
  }), ae = B.define("RDNSequence", function() {
    this.seqof(ie);
  }), se = B.define("Name", function() {
    this.choice({
      rdnSequence: this.use(ae)
    });
  }), ve = B.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(z),
      this.key("notAfter").use(z)
    );
  }), ge = B.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), le = B.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(ne),
      this.key("issuer").use(se),
      this.key("validity").use(ve),
      this.key("subject").use(se),
      this.key("subjectPublicKeyInfo").use(oe),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(ge).optional()
    );
  }), Ee = B.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(le),
      this.key("signatureAlgorithm").use(ne),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = Ee, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var B = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var z = B.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = z;
  var Y = B.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = Y;
  var ne = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), oe = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(ne),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = oe;
  var ie = B.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(ne),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = ie;
  var ae = B.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = ae;
  var se = B.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = se, asn1$1.DSAparam = B.define("DSAparam", function() {
    this.int();
  });
  var ve = B.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), ge = B.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ve),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = ge, asn1$1.signature = B.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var B = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, z = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Y = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, ne = requireEvp_bytestokey(), oe = requireBrowser$6(), ie = safeBufferExports.Buffer;
  return fixProc = function(ae, se) {
    var ve = ae.toString(), ge = ve.match(B), le;
    if (ge) {
      var Ce = "aes" + ge[1], Pe = ie.from(ge[2], "hex"), Xe = ie.from(ge[3].replace(/[\r\n]/g, ""), "base64"), ht = ne(se, Pe.slice(0, 8), parseInt(ge[1], 10)).key, wt = [], Pt = oe.createDecipheriv(Ce, ht, Pe);
      wt.push(Pt.update(Xe)), wt.push(Pt.final()), le = ie.concat(wt);
    } else {
      var Ee = ve.match(Y);
      le = ie.from(Ee[2].replace(/[\r\n]/g, ""), "base64");
    }
    var vt = ve.match(z)[1];
    return {
      tag: vt,
      data: le
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var B = requireAsn1(), z = require$$1, Y = requireFixProc(), ne = requireBrowser$6(), oe = requireBrowser$7(), ie = safeBufferExports.Buffer;
  function ae(ve, ge) {
    var le = ve.algorithm.decrypt.kde.kdeparams.salt, Ee = parseInt(ve.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), Ce = z[ve.algorithm.decrypt.cipher.algo.join(".")], Pe = ve.algorithm.decrypt.cipher.iv, Xe = ve.subjectPrivateKey, ht = parseInt(Ce.split("-")[1], 10) / 8, wt = oe.pbkdf2Sync(ge, le, Ee, ht, "sha1"), Pt = ne.createDecipheriv(Ce, wt, Pe), vt = [];
    return vt.push(Pt.update(Xe)), vt.push(Pt.final()), ie.concat(vt);
  }
  function se(ve) {
    var ge;
    typeof ve == "object" && !ie.isBuffer(ve) && (ge = ve.passphrase, ve = ve.key), typeof ve == "string" && (ve = ie.from(ve));
    var le = Y(ve, ge), Ee = le.tag, Ce = le.data, Pe, Xe;
    switch (Ee) {
      case "CERTIFICATE":
        Xe = B.certificate.decode(Ce, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (Xe || (Xe = B.PublicKey.decode(Ce, "der")), Pe = Xe.algorithm.algorithm.join("."), Pe) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPublicKey.decode(Xe.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return Xe.subjectPrivateKey = Xe.subjectPublicKey, {
              type: "ec",
              data: Xe
            };
          case "1.2.840.10040.4.1":
            return Xe.algorithm.params.pub_key = B.DSAparam.decode(Xe.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: Xe.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Pe);
        }
      case "ENCRYPTED PRIVATE KEY":
        Ce = B.EncryptedPrivateKey.decode(Ce, "der"), Ce = ae(Ce, ge);
      case "PRIVATE KEY":
        switch (Xe = B.PrivateKey.decode(Ce, "der"), Pe = Xe.algorithm.algorithm.join("."), Pe) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPrivateKey.decode(Xe.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: Xe.algorithm.curve,
              privateKey: B.ECPrivateKey.decode(Xe.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return Xe.algorithm.params.priv_key = B.DSAparam.decode(Xe.subjectPrivateKey, "der"), {
              type: "dsa",
              params: Xe.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Pe);
        }
      case "RSA PUBLIC KEY":
        return B.RSAPublicKey.decode(Ce, "der");
      case "RSA PRIVATE KEY":
        return B.RSAPrivateKey.decode(Ce, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: B.DSAPrivateKey.decode(Ce, "der")
        };
      case "EC PRIVATE KEY":
        return Ce = B.ECPrivateKey.decode(Ce, "der"), {
          curve: Ce.parameters.value,
          privateKey: Ce.privateKey
        };
      default:
        throw new Error("unknown key type " + Ee);
    }
  }
  return se.signature = B.signature, parseAsn1 = se, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports.Buffer, z = requireBrowser$8(), Y = requireBrowserifyRsa(), ne = requireElliptic().ec, oe = requireBn(), ie = requireParseAsn1(), ae = require$$4, se = 1;
  function ve(Pt, vt, Bt, Ct, Wt) {
    var Kt = ie(vt);
    if (Kt.curve) {
      if (Ct !== "ecdsa" && Ct !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return ge(Pt, Kt);
    } else if (Kt.type === "dsa") {
      if (Ct !== "dsa")
        throw new Error("wrong private key type");
      return le(Pt, Kt, Bt);
    }
    if (Ct !== "rsa" && Ct !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (vt.padding !== void 0 && vt.padding !== se)
      throw new Error("illegal or unsupported padding mode");
    Pt = B.concat([Wt, Pt]);
    for (var Yt = Kt.modulus.byteLength(), Ut = [0, 1]; Pt.length + Ut.length + 1 < Yt; )
      Ut.push(255);
    Ut.push(0);
    for (var qt = -1; ++qt < Pt.length; )
      Ut.push(Pt[qt]);
    var zt = Y(Ut, Kt);
    return zt;
  }
  function ge(Pt, vt) {
    var Bt = ae[vt.curve.join(".")];
    if (!Bt)
      throw new Error("unknown curve " + vt.curve.join("."));
    var Ct = new ne(Bt), Wt = Ct.keyFromPrivate(vt.privateKey), Kt = Wt.sign(Pt);
    return B.from(Kt.toDER());
  }
  function le(Pt, vt, Bt) {
    for (var Ct = vt.params.priv_key, Wt = vt.params.p, Kt = vt.params.q, Yt = vt.params.g, Ut = new oe(0), qt, zt = Pe(Pt, Kt).mod(Kt), Ft = !1, Ve = Ce(Ct, Kt, Pt, Bt); Ft === !1; )
      qt = ht(Kt, Ve, Bt), Ut = wt(Yt, qt, Wt, Kt), Ft = qt.invm(Kt).imul(zt.add(Ct.mul(Ut))).mod(Kt), Ft.cmpn(0) === 0 && (Ft = !1, Ut = new oe(0));
    return Ee(Ut, Ft);
  }
  function Ee(Pt, vt) {
    Pt = Pt.toArray(), vt = vt.toArray(), Pt[0] & 128 && (Pt = [0].concat(Pt)), vt[0] & 128 && (vt = [0].concat(vt));
    var Bt = Pt.length + vt.length + 4, Ct = [
      48,
      Bt,
      2,
      Pt.length
    ];
    return Ct = Ct.concat(Pt, [2, vt.length], vt), B.from(Ct);
  }
  function Ce(Pt, vt, Bt, Ct) {
    if (Pt = B.from(Pt.toArray()), Pt.length < vt.byteLength()) {
      var Wt = B.alloc(vt.byteLength() - Pt.length);
      Pt = B.concat([Wt, Pt]);
    }
    var Kt = Bt.length, Yt = Xe(Bt, vt), Ut = B.alloc(Kt);
    Ut.fill(1);
    var qt = B.alloc(Kt);
    return qt = z(Ct, qt).update(Ut).update(B.from([0])).update(Pt).update(Yt).digest(), Ut = z(Ct, qt).update(Ut).digest(), qt = z(Ct, qt).update(Ut).update(B.from([1])).update(Pt).update(Yt).digest(), Ut = z(Ct, qt).update(Ut).digest(), { k: qt, v: Ut };
  }
  function Pe(Pt, vt) {
    var Bt = new oe(Pt), Ct = (Pt.length << 3) - vt.bitLength();
    return Ct > 0 && Bt.ishrn(Ct), Bt;
  }
  function Xe(Pt, vt) {
    Pt = Pe(Pt, vt), Pt = Pt.mod(vt);
    var Bt = B.from(Pt.toArray());
    if (Bt.length < vt.byteLength()) {
      var Ct = B.alloc(vt.byteLength() - Bt.length);
      Bt = B.concat([Ct, Bt]);
    }
    return Bt;
  }
  function ht(Pt, vt, Bt) {
    var Ct, Wt;
    do {
      for (Ct = B.alloc(0); Ct.length * 8 < Pt.bitLength(); )
        vt.v = z(Bt, vt.k).update(vt.v).digest(), Ct = B.concat([Ct, vt.v]);
      Wt = Pe(Ct, Pt), vt.k = z(Bt, vt.k).update(vt.v).update(B.from([0])).digest(), vt.v = z(Bt, vt.k).update(vt.v).digest();
    } while (Wt.cmp(Pt) !== -1);
    return Wt;
  }
  function wt(Pt, vt, Bt, Ct) {
    return Pt.toRed(oe.mont(Bt)).redPow(vt).fromRed().mod(Ct);
  }
  return sign.exports = ve, sign.exports.getKey = Ce, sign.exports.makeKey = ht, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var B = safeBufferExports.Buffer, z = requireBn(), Y = requireElliptic().ec, ne = requireParseAsn1(), oe = require$$4;
  function ie(ge, le, Ee, Ce, Pe) {
    var Xe = ne(Ee);
    if (Xe.type === "ec") {
      if (Ce !== "ecdsa" && Ce !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return ae(ge, le, Xe);
    } else if (Xe.type === "dsa") {
      if (Ce !== "dsa")
        throw new Error("wrong public key type");
      return se(ge, le, Xe);
    }
    if (Ce !== "rsa" && Ce !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    le = B.concat([Pe, le]);
    for (var ht = Xe.modulus.byteLength(), wt = [1], Pt = 0; le.length + wt.length + 2 < ht; )
      wt.push(255), Pt += 1;
    wt.push(0);
    for (var vt = -1; ++vt < le.length; )
      wt.push(le[vt]);
    wt = B.from(wt);
    var Bt = z.mont(Xe.modulus);
    ge = new z(ge).toRed(Bt), ge = ge.redPow(new z(Xe.publicExponent)), ge = B.from(ge.fromRed().toArray());
    var Ct = Pt < 8 ? 1 : 0;
    for (ht = Math.min(ge.length, wt.length), ge.length !== wt.length && (Ct = 1), vt = -1; ++vt < ht; )
      Ct |= ge[vt] ^ wt[vt];
    return Ct === 0;
  }
  function ae(ge, le, Ee) {
    var Ce = oe[Ee.data.algorithm.curve.join(".")];
    if (!Ce)
      throw new Error("unknown curve " + Ee.data.algorithm.curve.join("."));
    var Pe = new Y(Ce), Xe = Ee.data.subjectPrivateKey.data;
    return Pe.verify(le, ge, Xe);
  }
  function se(ge, le, Ee) {
    var Ce = Ee.data.p, Pe = Ee.data.q, Xe = Ee.data.g, ht = Ee.data.pub_key, wt = ne.signature.decode(ge, "der"), Pt = wt.s, vt = wt.r;
    ve(Pt, Pe), ve(vt, Pe);
    var Bt = z.mont(Ce), Ct = Pt.invm(Pe), Wt = Xe.toRed(Bt).redPow(new z(le).mul(Ct).mod(Pe)).fromRed().mul(ht.toRed(Bt).redPow(vt.mul(Ct).mod(Pe)).fromRed()).mod(Ce).mod(Pe);
    return Wt.cmp(vt) === 0;
  }
  function ve(ge, le) {
    if (ge.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (ge.cmp(le) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = ie, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var B = safeBufferExports.Buffer, z = requireBrowser$9(), Y = requireReadableBrowser(), ne = requireInherits_browser(), oe = requireSign(), ie = requireVerify(), ae = require$$6;
  Object.keys(ae).forEach(function(Ee) {
    ae[Ee].id = B.from(ae[Ee].id, "hex"), ae[Ee.toLowerCase()] = ae[Ee];
  });
  function se(Ee) {
    Y.Writable.call(this);
    var Ce = ae[Ee];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hashType = Ce.hash, this._hash = z(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  ne(se, Y.Writable), se.prototype._write = function(Ce, Pe, Xe) {
    this._hash.update(Ce), Xe();
  }, se.prototype.update = function(Ce, Pe) {
    return this._hash.update(typeof Ce == "string" ? B.from(Ce, Pe) : Ce), this;
  }, se.prototype.sign = function(Ce, Pe) {
    this.end();
    var Xe = this._hash.digest(), ht = oe(Xe, Ce, this._hashType, this._signType, this._tag);
    return Pe ? ht.toString(Pe) : ht;
  };
  function ve(Ee) {
    Y.Writable.call(this);
    var Ce = ae[Ee];
    if (!Ce)
      throw new Error("Unknown message digest");
    this._hash = z(Ce.hash), this._tag = Ce.id, this._signType = Ce.sign;
  }
  ne(ve, Y.Writable), ve.prototype._write = function(Ce, Pe, Xe) {
    this._hash.update(Ce), Xe();
  }, ve.prototype.update = function(Ce, Pe) {
    return this._hash.update(typeof Ce == "string" ? B.from(Ce, Pe) : Ce), this;
  }, ve.prototype.verify = function(Ce, Pe, Xe) {
    var ht = typeof Pe == "string" ? B.from(Pe, Xe) : Pe;
    this.end();
    var wt = this._hash.digest();
    return ie(ht, wt, Ce, this._signType, this._tag);
  };
  function ge(Ee) {
    return new se(Ee);
  }
  function le(Ee) {
    return new ve(Ee);
  }
  return browser$3 = {
    Sign: ge,
    Verify: le,
    createSign: ge,
    createVerify: le
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var B = requireElliptic(), z = requireBn$1();
  browser$2 = function(ae) {
    return new ne(ae);
  };
  var Y = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Y.p224 = Y.secp224r1, Y.p256 = Y.secp256r1 = Y.prime256v1, Y.p192 = Y.secp192r1 = Y.prime192v1, Y.p384 = Y.secp384r1, Y.p521 = Y.secp521r1;
  function ne(ie) {
    this.curveType = Y[ie], this.curveType || (this.curveType = {
      name: ie
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  ne.prototype.generateKeys = function(ie, ae) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(ie, ae);
  }, ne.prototype.computeSecret = function(ie, ae, se) {
    ae = ae || "utf8", Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, ae));
    var ve = this.curve.keyFromPublic(ie).getPublic(), ge = ve.mul(this.keys.getPrivate()).getX();
    return oe(ge, se, this.curveType.byteLength);
  }, ne.prototype.getPublicKey = function(ie, ae) {
    var se = this.keys.getPublic(ae === "compressed", !0);
    return ae === "hybrid" && (se[se.length - 1] % 2 ? se[0] = 7 : se[0] = 6), oe(se, ie);
  }, ne.prototype.getPrivateKey = function(ie) {
    return oe(this.keys.getPrivate(), ie);
  }, ne.prototype.setPublicKey = function(ie, ae) {
    return ae = ae || "utf8", Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, ae)), this.keys._importPublic(ie), this;
  }, ne.prototype.setPrivateKey = function(ie, ae) {
    ae = ae || "utf8", Buffer$1.isBuffer(ie) || (ie = new Buffer$1(ie, ae));
    var se = new z(ie);
    return se = se.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(se), this;
  };
  function oe(ie, ae, se) {
    Array.isArray(ie) || (ie = ie.toArray());
    var ve = new Buffer$1(ie);
    if (se && ve.length < se) {
      var ge = new Buffer$1(se - ve.length);
      ge.fill(0), ve = Buffer$1.concat([ge, ve]);
    }
    return ae ? ve.toString(ae) : ve;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var B = requireBrowser$9(), z = safeBufferExports.Buffer;
  mgf = function(ne, oe) {
    for (var ie = z.alloc(0), ae = 0, se; ie.length < oe; )
      se = Y(ae++), ie = z.concat([ie, B("sha1").update(ne).update(se).digest()]);
    return ie.slice(0, oe);
  };
  function Y(ne) {
    var oe = z.allocUnsafe(4);
    return oe.writeUInt32BE(ne, 0), oe;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(z, Y) {
    for (var ne = z.length, oe = -1; ++oe < ne; )
      z[oe] ^= Y[oe];
    return z;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var B = requireBn$1(), z = safeBufferExports.Buffer;
  function Y(ne, oe) {
    return z.from(ne.toRed(B.mont(oe.modulus)).redPow(new B(oe.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = Y, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var B = requireParseAsn1(), z = requireBrowser$b(), Y = requireBrowser$9(), ne = requireMgf(), oe = requireXor(), ie = requireBn$1(), ae = requireWithPublic(), se = requireBrowserifyRsa(), ve = safeBufferExports.Buffer;
  publicEncrypt = function(Pe, Xe, ht) {
    var wt;
    Pe.padding ? wt = Pe.padding : ht ? wt = 1 : wt = 4;
    var Pt = B(Pe), vt;
    if (wt === 4)
      vt = ge(Pt, Xe);
    else if (wt === 1)
      vt = le(Pt, Xe, ht);
    else if (wt === 3) {
      if (vt = new ie(Xe), vt.cmp(Pt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return ht ? se(vt, Pt) : ae(vt, Pt);
  };
  function ge(Ce, Pe) {
    var Xe = Ce.modulus.byteLength(), ht = Pe.length, wt = Y("sha1").update(ve.alloc(0)).digest(), Pt = wt.length, vt = 2 * Pt;
    if (ht > Xe - vt - 2)
      throw new Error("message too long");
    var Bt = ve.alloc(Xe - ht - vt - 2), Ct = Xe - Pt - 1, Wt = z(Pt), Kt = oe(ve.concat([wt, Bt, ve.alloc(1, 1), Pe], Ct), ne(Wt, Ct)), Yt = oe(Wt, ne(Kt, Pt));
    return new ie(ve.concat([ve.alloc(1), Yt, Kt], Xe));
  }
  function le(Ce, Pe, Xe) {
    var ht = Pe.length, wt = Ce.modulus.byteLength();
    if (ht > wt - 11)
      throw new Error("message too long");
    var Pt;
    return Xe ? Pt = ve.alloc(wt - ht - 3, 255) : Pt = Ee(wt - ht - 3), new ie(ve.concat([ve.from([0, Xe ? 1 : 2]), Pt, ve.alloc(1), Pe], wt));
  }
  function Ee(Ce) {
    for (var Pe = ve.allocUnsafe(Ce), Xe = 0, ht = z(Ce * 2), wt = 0, Pt; Xe < Ce; )
      wt === ht.length && (ht = z(Ce * 2), wt = 0), Pt = ht[wt++], Pt && (Pe[Xe++] = Pt);
    return Pe;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var B = requireParseAsn1(), z = requireMgf(), Y = requireXor(), ne = requireBn$1(), oe = requireBrowserifyRsa(), ie = requireBrowser$9(), ae = requireWithPublic(), se = safeBufferExports.Buffer;
  privateDecrypt = function(Ce, Pe, Xe) {
    var ht;
    Ce.padding ? ht = Ce.padding : Xe ? ht = 1 : ht = 4;
    var wt = B(Ce), Pt = wt.modulus.byteLength();
    if (Pe.length > Pt || new ne(Pe).cmp(wt.modulus) >= 0)
      throw new Error("decryption error");
    var vt;
    Xe ? vt = ae(new ne(Pe), wt) : vt = oe(Pe, wt);
    var Bt = se.alloc(Pt - vt.length);
    if (vt = se.concat([Bt, vt], Pt), ht === 4)
      return ve(wt, vt);
    if (ht === 1)
      return ge(wt, vt, Xe);
    if (ht === 3)
      return vt;
    throw new Error("unknown padding");
  };
  function ve(Ee, Ce) {
    var Pe = Ee.modulus.byteLength(), Xe = ie("sha1").update(se.alloc(0)).digest(), ht = Xe.length;
    if (Ce[0] !== 0)
      throw new Error("decryption error");
    var wt = Ce.slice(1, ht + 1), Pt = Ce.slice(ht + 1), vt = Y(wt, z(Pt, ht)), Bt = Y(Pt, z(vt, Pe - ht - 1));
    if (le(Xe, Bt.slice(0, ht)))
      throw new Error("decryption error");
    for (var Ct = ht; Bt[Ct] === 0; )
      Ct++;
    if (Bt[Ct++] !== 1)
      throw new Error("decryption error");
    return Bt.slice(Ct);
  }
  function ge(Ee, Ce, Pe) {
    for (var Xe = Ce.slice(0, 2), ht = 2, wt = 0; Ce[ht++] !== 0; )
      if (ht >= Ce.length) {
        wt++;
        break;
      }
    var Pt = Ce.slice(2, ht - 1);
    if ((Xe.toString("hex") !== "0002" && !Pe || Xe.toString("hex") !== "0001" && Pe) && wt++, Pt.length < 8 && wt++, wt)
      throw new Error("decryption error");
    return Ce.slice(ht);
  }
  function le(Ee, Ce) {
    Ee = se.from(Ee), Ce = se.from(Ce);
    var Pe = 0, Xe = Ee.length;
    Ee.length !== Ce.length && (Pe++, Xe = Math.min(Ee.length, Ce.length));
    for (var ht = -1; ++ht < Xe; )
      Pe += Ee[ht] ^ Ce[ht];
    return Pe;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(B) {
    B.publicEncrypt = requirePublicEncrypt(), B.privateDecrypt = requirePrivateDecrypt(), B.privateEncrypt = function(Y, ne) {
      return B.publicEncrypt(Y, ne, !0);
    }, B.publicDecrypt = function(Y, ne) {
      return B.privateDecrypt(Y, ne, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function B() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var z = safeBufferExports, Y = requireBrowser$b(), ne = z.Buffer, oe = z.kMaxLength, ie = commonjsGlobal.crypto || commonjsGlobal.msCrypto, ae = Math.pow(2, 32) - 1;
  function se(Ce, Pe) {
    if (typeof Ce != "number" || Ce !== Ce)
      throw new TypeError("offset must be a number");
    if (Ce > ae || Ce < 0)
      throw new TypeError("offset must be a uint32");
    if (Ce > oe || Ce > Pe)
      throw new RangeError("offset out of range");
  }
  function ve(Ce, Pe, Xe) {
    if (typeof Ce != "number" || Ce !== Ce)
      throw new TypeError("size must be a number");
    if (Ce > ae || Ce < 0)
      throw new TypeError("size must be a uint32");
    if (Ce + Pe > Xe || Ce > oe)
      throw new RangeError("buffer too small");
  }
  ie && ie.getRandomValues || !process$1.browser ? (browser.randomFill = ge, browser.randomFillSync = Ee) : (browser.randomFill = B, browser.randomFillSync = B);
  function ge(Ce, Pe, Xe, ht) {
    if (!ne.isBuffer(Ce) && !(Ce instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Pe == "function")
      ht = Pe, Pe = 0, Xe = Ce.length;
    else if (typeof Xe == "function")
      ht = Xe, Xe = Ce.length - Pe;
    else if (typeof ht != "function")
      throw new TypeError('"cb" argument must be a function');
    return se(Pe, Ce.length), ve(Xe, Pe, Ce.length), le(Ce, Pe, Xe, ht);
  }
  function le(Ce, Pe, Xe, ht) {
    if (process$1.browser) {
      var wt = Ce.buffer, Pt = new Uint8Array(wt, Pe, Xe);
      if (ie.getRandomValues(Pt), ht) {
        process$1.nextTick(function() {
          ht(null, Ce);
        });
        return;
      }
      return Ce;
    }
    if (ht) {
      Y(Xe, function(Bt, Ct) {
        if (Bt)
          return ht(Bt);
        Ct.copy(Ce, Pe), ht(null, Ce);
      });
      return;
    }
    var vt = Y(Xe);
    return vt.copy(Ce, Pe), Ce;
  }
  function Ee(Ce, Pe, Xe) {
    if (typeof Pe > "u" && (Pe = 0), !ne.isBuffer(Ce) && !(Ce instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return se(Pe, Ce.length), Xe === void 0 && (Xe = Ce.length - Pe), ve(Xe, Pe, Ce.length), le(Ce, Pe, Xe);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var B = requireAlgos(), z = Object.keys(B), Y = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(z);
  cryptoBrowserify.getHashes = function() {
    return Y;
  };
  var ne = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = ne.pbkdf2, cryptoBrowserify.pbkdf2Sync = ne.pbkdf2Sync;
  var oe = requireBrowser$5();
  cryptoBrowserify.Cipher = oe.Cipher, cryptoBrowserify.createCipher = oe.createCipher, cryptoBrowserify.Cipheriv = oe.Cipheriv, cryptoBrowserify.createCipheriv = oe.createCipheriv, cryptoBrowserify.Decipher = oe.Decipher, cryptoBrowserify.createDecipher = oe.createDecipher, cryptoBrowserify.Decipheriv = oe.Decipheriv, cryptoBrowserify.createDecipheriv = oe.createDecipheriv, cryptoBrowserify.getCiphers = oe.getCiphers, cryptoBrowserify.listCiphers = oe.listCiphers;
  var ie = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = ie.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ie.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ie.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ie.createDiffieHellman, cryptoBrowserify.DiffieHellman = ie.DiffieHellman;
  var ae = requireBrowser$3();
  cryptoBrowserify.createSign = ae.createSign, cryptoBrowserify.Sign = ae.Sign, cryptoBrowserify.createVerify = ae.createVerify, cryptoBrowserify.Verify = ae.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var se = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = se.publicEncrypt, cryptoBrowserify.privateEncrypt = se.privateEncrypt, cryptoBrowserify.publicDecrypt = se.publicDecrypt, cryptoBrowserify.privateDecrypt = se.privateDecrypt;
  var ve = requireBrowser();
  return cryptoBrowserify.randomFill = ve.randomFill, cryptoBrowserify.randomFillSync = ve.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const z = requireCryptoBrowserify(), Y = BigInt(0), ne = BigInt(1), oe = BigInt(2), ie = BigInt(3), ae = BigInt(8), se = Object.freeze({
    a: Y,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: ne,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = se;
  const ve = (fr, tr) => (fr + tr / oe) / tr, ge = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(fr) {
      const { n: tr } = se, ur = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), jt = -ne * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), Ot = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), Lt = ur, Qt = BigInt("0x100000000000000000000000000000000"), or = ve(Lt * fr, tr), hr = ve(-jt * fr, tr);
      let yr = Ht(fr - or * ur - hr * Ot, tr), xr = Ht(-or * jt - hr * Lt, tr);
      const Rr = yr > Qt, ir = xr > Qt;
      if (Rr && (yr = tr - yr), ir && (xr = tr - xr), yr > Qt || xr > Qt)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + fr);
      return { k1neg: Rr, k1: yr, k2neg: ir, k2: xr };
    }
  }, le = 32, Ee = 32, Ce = 32, Pe = le + 1, Xe = 2 * le + 1;
  function ht(fr) {
    const { a: tr, b: ur } = se, jt = Ht(fr * fr), Ot = Ht(jt * fr);
    return Ht(Ot + tr * fr + ur);
  }
  const wt = se.a === Y;
  class Pt extends Error {
    constructor(tr) {
      super(tr);
    }
  }
  function vt(fr) {
    if (!(fr instanceof Bt))
      throw new TypeError("JacobianPoint expected");
  }
  class Bt {
    constructor(tr, ur, jt) {
      this.x = tr, this.y = ur, this.z = jt;
    }
    static fromAffine(tr) {
      if (!(tr instanceof Kt))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return tr.equals(Kt.ZERO) ? Bt.ZERO : new Bt(tr.x, tr.y, ne);
    }
    static toAffineBatch(tr) {
      const ur = Vt(tr.map((jt) => jt.z));
      return tr.map((jt, Ot) => jt.toAffine(ur[Ot]));
    }
    static normalizeZ(tr) {
      return Bt.toAffineBatch(tr).map(Bt.fromAffine);
    }
    equals(tr) {
      vt(tr);
      const { x: ur, y: jt, z: Ot } = this, { x: Lt, y: Qt, z: or } = tr, hr = Ht(Ot * Ot), yr = Ht(or * or), xr = Ht(ur * yr), Rr = Ht(Lt * hr), ir = Ht(Ht(jt * or) * yr), vr = Ht(Ht(Qt * Ot) * hr);
      return xr === Rr && ir === vr;
    }
    negate() {
      return new Bt(this.x, Ht(-this.y), this.z);
    }
    double() {
      const { x: tr, y: ur, z: jt } = this, Ot = Ht(tr * tr), Lt = Ht(ur * ur), Qt = Ht(Lt * Lt), or = tr + Lt, hr = Ht(oe * (Ht(or * or) - Ot - Qt)), yr = Ht(ie * Ot), xr = Ht(yr * yr), Rr = Ht(xr - oe * hr), ir = Ht(yr * (hr - Rr) - ae * Qt), vr = Ht(oe * ur * jt);
      return new Bt(Rr, ir, vr);
    }
    add(tr) {
      vt(tr);
      const { x: ur, y: jt, z: Ot } = this, { x: Lt, y: Qt, z: or } = tr;
      if (Lt === Y || Qt === Y)
        return this;
      if (ur === Y || jt === Y)
        return tr;
      const hr = Ht(Ot * Ot), yr = Ht(or * or), xr = Ht(ur * yr), Rr = Ht(Lt * hr), ir = Ht(Ht(jt * or) * yr), vr = Ht(Ht(Qt * Ot) * hr), Er = Ht(Rr - xr), $r = Ht(vr - ir);
      if (Er === Y)
        return $r === Y ? this.double() : Bt.ZERO;
      const Ur = Ht(Er * Er), Dr = Ht(Er * Ur), qr = Ht(xr * Ur), Vr = Ht($r * $r - Dr - oe * qr), tn = Ht($r * (qr - Vr) - ir * Dr), Qr = Ht(Ot * or * Er);
      return new Bt(Vr, tn, Qr);
    }
    subtract(tr) {
      return this.add(tr.negate());
    }
    multiplyUnsafe(tr) {
      const ur = Bt.ZERO;
      if (typeof tr == "bigint" && tr === Y)
        return ur;
      let jt = Rt(tr);
      if (jt === ne)
        return this;
      if (!wt) {
        let Rr = ur, ir = this;
        for (; jt > Y; )
          jt & ne && (Rr = Rr.add(ir)), ir = ir.double(), jt >>= ne;
        return Rr;
      }
      let { k1neg: Ot, k1: Lt, k2neg: Qt, k2: or } = ge.splitScalar(jt), hr = ur, yr = ur, xr = this;
      for (; Lt > Y || or > Y; )
        Lt & ne && (hr = hr.add(xr)), or & ne && (yr = yr.add(xr)), xr = xr.double(), Lt >>= ne, or >>= ne;
      return Ot && (hr = hr.negate()), Qt && (yr = yr.negate()), yr = new Bt(Ht(yr.x * ge.beta), yr.y, yr.z), hr.add(yr);
    }
    precomputeWindow(tr) {
      const ur = wt ? 128 / tr + 1 : 256 / tr + 1, jt = [];
      let Ot = this, Lt = Ot;
      for (let Qt = 0; Qt < ur; Qt++) {
        Lt = Ot, jt.push(Lt);
        for (let or = 1; or < 2 ** (tr - 1); or++)
          Lt = Lt.add(Ot), jt.push(Lt);
        Ot = Lt.double();
      }
      return jt;
    }
    wNAF(tr, ur) {
      !ur && this.equals(Bt.BASE) && (ur = Kt.BASE);
      const jt = ur && ur._WINDOW_SIZE || 1;
      if (256 % jt)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let Ot = ur && Wt.get(ur);
      Ot || (Ot = this.precomputeWindow(jt), ur && jt !== 1 && (Ot = Bt.normalizeZ(Ot), Wt.set(ur, Ot)));
      let Lt = Bt.ZERO, Qt = Bt.BASE;
      const or = 1 + (wt ? 128 / jt : 256 / jt), hr = 2 ** (jt - 1), yr = BigInt(2 ** jt - 1), xr = 2 ** jt, Rr = BigInt(jt);
      for (let ir = 0; ir < or; ir++) {
        const vr = ir * hr;
        let Er = Number(tr & yr);
        tr >>= Rr, Er > hr && (Er -= xr, tr += ne);
        const $r = vr, Ur = vr + Math.abs(Er) - 1, Dr = ir % 2 !== 0, qr = Er < 0;
        Er === 0 ? Qt = Qt.add(Ct(Dr, Ot[$r])) : Lt = Lt.add(Ct(qr, Ot[Ur]));
      }
      return { p: Lt, f: Qt };
    }
    multiply(tr, ur) {
      let jt = Rt(tr), Ot, Lt;
      if (wt) {
        const { k1neg: Qt, k1: or, k2neg: hr, k2: yr } = ge.splitScalar(jt);
        let { p: xr, f: Rr } = this.wNAF(or, ur), { p: ir, f: vr } = this.wNAF(yr, ur);
        xr = Ct(Qt, xr), ir = Ct(hr, ir), ir = new Bt(Ht(ir.x * ge.beta), ir.y, ir.z), Ot = xr.add(ir), Lt = Rr.add(vr);
      } else {
        const { p: Qt, f: or } = this.wNAF(jt, ur);
        Ot = Qt, Lt = or;
      }
      return Bt.normalizeZ([Ot, Lt])[0];
    }
    toAffine(tr) {
      const { x: ur, y: jt, z: Ot } = this, Lt = this.equals(Bt.ZERO);
      tr == null && (tr = Lt ? ae : nr(Ot));
      const Qt = tr, or = Ht(Qt * Qt), hr = Ht(or * Qt), yr = Ht(ur * or), xr = Ht(jt * hr), Rr = Ht(Ot * Qt);
      if (Lt)
        return Kt.ZERO;
      if (Rr !== ne)
        throw new Error("invZ was invalid");
      return new Kt(yr, xr);
    }
  }
  Bt.BASE = new Bt(se.Gx, se.Gy, ne), Bt.ZERO = new Bt(Y, ne, Y);
  function Ct(fr, tr) {
    const ur = tr.negate();
    return fr ? ur : tr;
  }
  const Wt = /* @__PURE__ */ new WeakMap();
  class Kt {
    constructor(tr, ur) {
      this.x = tr, this.y = ur;
    }
    _setWindowSize(tr) {
      this._WINDOW_SIZE = tr, Wt.delete(this);
    }
    hasEvenY() {
      return this.y % oe === Y;
    }
    static fromCompressedHex(tr) {
      const ur = tr.length === 32, jt = xt(ur ? tr : tr.subarray(1));
      if (!_r(jt))
        throw new Error("Point is not on curve");
      const Ot = ht(jt);
      let Lt = lr(Ot);
      const Qt = (Lt & ne) === ne;
      ur ? Qt && (Lt = Ht(-Lt)) : (tr[0] & 1) === 1 !== Qt && (Lt = Ht(-Lt));
      const or = new Kt(jt, Lt);
      return or.assertValidity(), or;
    }
    static fromUncompressedHex(tr) {
      const ur = xt(tr.subarray(1, le + 1)), jt = xt(tr.subarray(le + 1, le * 2 + 1)), Ot = new Kt(ur, jt);
      return Ot.assertValidity(), Ot;
    }
    static fromHex(tr) {
      const ur = Nt(tr), jt = ur.length, Ot = ur[0];
      if (jt === le)
        return this.fromCompressedHex(ur);
      if (jt === Pe && (Ot === 2 || Ot === 3))
        return this.fromCompressedHex(ur);
      if (jt === Xe && Ot === 4)
        return this.fromUncompressedHex(ur);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Pe} compressed bytes or ${Xe} uncompressed bytes, not ${jt}`);
    }
    static fromPrivateKey(tr) {
      return Kt.BASE.multiply(Sr(tr));
    }
    static fromSignature(tr, ur, jt) {
      const { r: Ot, s: Lt } = Ir(ur);
      if (![0, 1, 2, 3].includes(jt))
        throw new Error("Cannot recover: invalid recovery bit");
      const Qt = sr(Nt(tr)), { n: or } = se, hr = jt === 2 || jt === 3 ? Ot + or : Ot, yr = nr(hr, or), xr = Ht(-Qt * yr, or), Rr = Ht(Lt * yr, or), ir = jt & 1 ? "03" : "02", vr = Kt.fromHex(ir + Qe(hr)), Er = Kt.BASE.multiplyAndAddUnsafe(vr, xr, Rr);
      if (!Er)
        throw new Error("Cannot recover signature: point at infinify");
      return Er.assertValidity(), Er;
    }
    toRawBytes(tr = !1) {
      return kt(this.toHex(tr));
    }
    toHex(tr = !1) {
      const ur = Qe(this.x);
      return tr ? `${this.hasEvenY() ? "02" : "03"}${ur}` : `04${ur}${Qe(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const tr = "Point is not on elliptic curve", { x: ur, y: jt } = this;
      if (!_r(ur) || !_r(jt))
        throw new Error(tr);
      const Ot = Ht(jt * jt), Lt = ht(ur);
      if (Ht(Ot - Lt) !== Y)
        throw new Error(tr);
    }
    equals(tr) {
      return this.x === tr.x && this.y === tr.y;
    }
    negate() {
      return new Kt(this.x, Ht(-this.y));
    }
    double() {
      return Bt.fromAffine(this).double().toAffine();
    }
    add(tr) {
      return Bt.fromAffine(this).add(Bt.fromAffine(tr)).toAffine();
    }
    subtract(tr) {
      return this.add(tr.negate());
    }
    multiply(tr) {
      return Bt.fromAffine(this).multiply(tr, this).toAffine();
    }
    multiplyAndAddUnsafe(tr, ur, jt) {
      const Ot = Bt.fromAffine(this), Lt = ur === Y || ur === ne || this !== Kt.BASE ? Ot.multiplyUnsafe(ur) : Ot.multiply(ur), Qt = Bt.fromAffine(tr).multiplyUnsafe(jt), or = Lt.add(Qt);
      return or.equals(Bt.ZERO) ? void 0 : or.toAffine();
    }
  }
  B.Point = Kt, Kt.BASE = new Kt(se.Gx, se.Gy), Kt.ZERO = new Kt(Y, Y);
  function Yt(fr) {
    return Number.parseInt(fr[0], 16) >= 8 ? "00" + fr : fr;
  }
  function Ut(fr) {
    if (fr.length < 2 || fr[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Je(fr)}`);
    const tr = fr[1], ur = fr.subarray(2, tr + 2);
    if (!tr || ur.length !== tr)
      throw new Error("Invalid signature integer: wrong length");
    if (ur[0] === 0 && ur[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: xt(ur), left: fr.subarray(tr + 2) };
  }
  function qt(fr) {
    if (fr.length < 2 || fr[0] != 48)
      throw new Error(`Invalid signature tag: ${Je(fr)}`);
    if (fr[1] !== fr.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: tr, left: ur } = Ut(fr.subarray(2)), { data: jt, left: Ot } = Ut(ur);
    if (Ot.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Je(Ot)}`);
    return { r: tr, s: jt };
  }
  class zt {
    constructor(tr, ur) {
      this.r = tr, this.s = ur, this.assertValidity();
    }
    static fromCompact(tr) {
      const ur = tr instanceof Uint8Array, jt = "Signature.fromCompact";
      if (typeof tr != "string" && !ur)
        throw new TypeError(`${jt}: Expected string or Uint8Array`);
      const Ot = ur ? Je(tr) : tr;
      if (Ot.length !== 128)
        throw new Error(`${jt}: Expected 64-byte hex`);
      return new zt($t(Ot.slice(0, 64)), $t(Ot.slice(64, 128)));
    }
    static fromDER(tr) {
      const ur = tr instanceof Uint8Array;
      if (typeof tr != "string" && !ur)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: jt, s: Ot } = qt(ur ? tr : kt(tr));
      return new zt(jt, Ot);
    }
    static fromHex(tr) {
      return this.fromDER(tr);
    }
    assertValidity() {
      const { r: tr, s: ur } = this;
      if (!pr(tr))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!pr(ur))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const tr = se.n >> ne;
      return this.s > tr;
    }
    normalizeS() {
      return this.hasHighS() ? new zt(this.r, Ht(-this.s, se.n)) : this;
    }
    toDERRawBytes() {
      return kt(this.toDERHex());
    }
    toDERHex() {
      const tr = Yt(_t(this.s)), ur = Yt(_t(this.r)), jt = tr.length / 2, Ot = ur.length / 2, Lt = _t(jt), Qt = _t(Ot);
      return `30${_t(Ot + jt + 4)}02${Qt}${ur}02${Lt}${tr}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return kt(this.toCompactHex());
    }
    toCompactHex() {
      return Qe(this.r) + Qe(this.s);
    }
  }
  B.Signature = zt;
  function Ft(...fr) {
    if (!fr.every((jt) => jt instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (fr.length === 1)
      return fr[0];
    const tr = fr.reduce((jt, Ot) => jt + Ot.length, 0), ur = new Uint8Array(tr);
    for (let jt = 0, Ot = 0; jt < fr.length; jt++) {
      const Lt = fr[jt];
      ur.set(Lt, Ot), Ot += Lt.length;
    }
    return ur;
  }
  const Ve = Array.from({ length: 256 }, (fr, tr) => tr.toString(16).padStart(2, "0"));
  function Je(fr) {
    if (!(fr instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let tr = "";
    for (let ur = 0; ur < fr.length; ur++)
      tr += Ve[fr[ur]];
    return tr;
  }
  const Ke = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Qe(fr) {
    if (typeof fr != "bigint")
      throw new Error("Expected bigint");
    if (!(Y <= fr && fr < Ke))
      throw new Error("Expected number 0 <= n < 2^256");
    return fr.toString(16).padStart(64, "0");
  }
  function bt(fr) {
    const tr = kt(Qe(fr));
    if (tr.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return tr;
  }
  function _t(fr) {
    const tr = fr.toString(16);
    return tr.length & 1 ? `0${tr}` : tr;
  }
  function $t(fr) {
    if (typeof fr != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof fr);
    return BigInt(`0x${fr}`);
  }
  function kt(fr) {
    if (typeof fr != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof fr);
    if (fr.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + fr.length);
    const tr = new Uint8Array(fr.length / 2);
    for (let ur = 0; ur < tr.length; ur++) {
      const jt = ur * 2, Ot = fr.slice(jt, jt + 2), Lt = Number.parseInt(Ot, 16);
      if (Number.isNaN(Lt) || Lt < 0)
        throw new Error("Invalid byte sequence");
      tr[ur] = Lt;
    }
    return tr;
  }
  function xt(fr) {
    return $t(Je(fr));
  }
  function Nt(fr) {
    return fr instanceof Uint8Array ? Uint8Array.from(fr) : kt(fr);
  }
  function Rt(fr) {
    if (typeof fr == "number" && Number.isSafeInteger(fr) && fr > 0)
      return BigInt(fr);
    if (typeof fr == "bigint" && pr(fr))
      return fr;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Ht(fr, tr = se.P) {
    const ur = fr % tr;
    return ur >= Y ? ur : tr + ur;
  }
  function ar(fr, tr) {
    const { P: ur } = se;
    let jt = fr;
    for (; tr-- > Y; )
      jt *= jt, jt %= ur;
    return jt;
  }
  function lr(fr) {
    const { P: tr } = se, ur = BigInt(6), jt = BigInt(11), Ot = BigInt(22), Lt = BigInt(23), Qt = BigInt(44), or = BigInt(88), hr = fr * fr * fr % tr, yr = hr * hr * fr % tr, xr = ar(yr, ie) * yr % tr, Rr = ar(xr, ie) * yr % tr, ir = ar(Rr, oe) * hr % tr, vr = ar(ir, jt) * ir % tr, Er = ar(vr, Ot) * vr % tr, $r = ar(Er, Qt) * Er % tr, Ur = ar($r, or) * $r % tr, Dr = ar(Ur, Qt) * Er % tr, qr = ar(Dr, ie) * yr % tr, Vr = ar(qr, Lt) * vr % tr, tn = ar(Vr, ur) * hr % tr, Qr = ar(tn, oe);
    if (Qr * Qr % tr !== fr)
      throw new Error("Cannot find square root");
    return Qr;
  }
  function nr(fr, tr = se.P) {
    if (fr === Y || tr <= Y)
      throw new Error(`invert: expected positive integers, got n=${fr} mod=${tr}`);
    let ur = Ht(fr, tr), jt = tr, Ot = Y, Lt = ne;
    for (; ur !== Y; ) {
      const or = jt / ur, hr = jt % ur, yr = Ot - Lt * or;
      jt = ur, ur = hr, Ot = Lt, Lt = yr;
    }
    if (jt !== ne)
      throw new Error("invert: does not exist");
    return Ht(Ot, tr);
  }
  function Vt(fr, tr = se.P) {
    const ur = new Array(fr.length), jt = fr.reduce((Lt, Qt, or) => Qt === Y ? Lt : (ur[or] = Lt, Ht(Lt * Qt, tr)), ne), Ot = nr(jt, tr);
    return fr.reduceRight((Lt, Qt, or) => Qt === Y ? Lt : (ur[or] = Ht(Lt * ur[or], tr), Ht(Lt * Qt, tr)), Ot), ur;
  }
  function Xt(fr) {
    const tr = fr.length * 8 - Ee * 8, ur = xt(fr);
    return tr > 0 ? ur >> BigInt(tr) : ur;
  }
  function sr(fr, tr = !1) {
    const ur = Xt(fr);
    if (tr)
      return ur;
    const { n: jt } = se;
    return ur >= jt ? ur - jt : ur;
  }
  let dr, er;
  class Zt {
    constructor(tr, ur) {
      if (this.hashLen = tr, this.qByteLen = ur, typeof tr != "number" || tr < 2)
        throw new Error("hashLen must be a number");
      if (typeof ur != "number" || ur < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(tr).fill(1), this.k = new Uint8Array(tr).fill(0), this.counter = 0;
    }
    hmac(...tr) {
      return B.utils.hmacSha256(this.k, ...tr);
    }
    hmacSync(...tr) {
      return er(this.k, ...tr);
    }
    checkSync() {
      if (typeof er != "function")
        throw new Pt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(tr = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), tr), this.v = await this.hmac(this.v), tr.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), tr), this.v = await this.hmac(this.v));
    }
    reseedSync(tr = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), tr), this.v = this.hmacSync(this.v), tr.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), tr), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let tr = 0;
      const ur = [];
      for (; tr < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const jt = this.v.slice();
        ur.push(jt), tr += this.v.length;
      }
      return Ft(...ur);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let tr = 0;
      const ur = [];
      for (; tr < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const jt = this.v.slice();
        ur.push(jt), tr += this.v.length;
      }
      return Ft(...ur);
    }
  }
  function pr(fr) {
    return Y < fr && fr < se.n;
  }
  function _r(fr) {
    return Y < fr && fr < se.P;
  }
  function Ar(fr, tr, ur, jt = !0) {
    const { n: Ot } = se, Lt = sr(fr, !0);
    if (!pr(Lt))
      return;
    const Qt = nr(Lt, Ot), or = Kt.BASE.multiply(Lt), hr = Ht(or.x, Ot);
    if (hr === Y)
      return;
    const yr = Ht(Qt * Ht(tr + ur * hr, Ot), Ot);
    if (yr === Y)
      return;
    let xr = new zt(hr, yr), Rr = (or.x === xr.r ? 0 : 2) | Number(or.y & ne);
    return jt && xr.hasHighS() && (xr = xr.normalizeS(), Rr ^= 1), { sig: xr, recovery: Rr };
  }
  function Sr(fr) {
    let tr;
    if (typeof fr == "bigint")
      tr = fr;
    else if (typeof fr == "number" && Number.isSafeInteger(fr) && fr > 0)
      tr = BigInt(fr);
    else if (typeof fr == "string") {
      if (fr.length !== 2 * Ee)
        throw new Error("Expected 32 bytes of private key");
      tr = $t(fr);
    } else if (fr instanceof Uint8Array) {
      if (fr.length !== Ee)
        throw new Error("Expected 32 bytes of private key");
      tr = xt(fr);
    } else
      throw new TypeError("Expected valid private key");
    if (!pr(tr))
      throw new Error("Expected private key: 0 < key < n");
    return tr;
  }
  function Br(fr) {
    return fr instanceof Kt ? (fr.assertValidity(), fr) : Kt.fromHex(fr);
  }
  function Ir(fr) {
    if (fr instanceof zt)
      return fr.assertValidity(), fr;
    try {
      return zt.fromDER(fr);
    } catch {
      return zt.fromCompact(fr);
    }
  }
  function wr(fr, tr = !1) {
    return Kt.fromPrivateKey(fr).toRawBytes(tr);
  }
  B.getPublicKey = wr;
  function Gr(fr, tr, ur, jt = !1) {
    return Kt.fromSignature(fr, tr, ur).toRawBytes(jt);
  }
  B.recoverPublicKey = Gr;
  function Pr(fr) {
    const tr = fr instanceof Uint8Array, ur = typeof fr == "string", jt = (tr || ur) && fr.length;
    return tr ? jt === Pe || jt === Xe : ur ? jt === Pe * 2 || jt === Xe * 2 : fr instanceof Kt;
  }
  function Mr(fr, tr, ur = !1) {
    if (Pr(fr))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Pr(tr))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const jt = Br(tr);
    return jt.assertValidity(), jt.multiply(Sr(fr)).toRawBytes(ur);
  }
  B.getSharedSecret = Mr;
  function Cr(fr) {
    const tr = fr.length > le ? fr.slice(0, le) : fr;
    return xt(tr);
  }
  function Tr(fr) {
    const tr = Cr(fr), ur = Ht(tr, se.n);
    return Hr(ur < Y ? tr : ur);
  }
  function Hr(fr) {
    return bt(fr);
  }
  function Yr(fr, tr, ur) {
    if (fr == null)
      throw new Error(`sign: expected valid message hash, not "${fr}"`);
    const jt = Nt(fr), Ot = Sr(tr), Lt = [Hr(Ot), Tr(jt)];
    if (ur != null) {
      ur === !0 && (ur = B.utils.randomBytes(le));
      const hr = Nt(ur);
      if (hr.length !== le)
        throw new Error(`sign: Expected ${le} bytes of extra data`);
      Lt.push(hr);
    }
    const Qt = Ft(...Lt), or = Cr(jt);
    return { seed: Qt, m: or, d: Ot };
  }
  function Nr(fr, tr) {
    const { sig: ur, recovery: jt } = fr, { der: Ot, recovered: Lt } = Object.assign({ canonical: !0, der: !0 }, tr), Qt = Ot ? ur.toDERRawBytes() : ur.toCompactRawBytes();
    return Lt ? [Qt, jt] : Qt;
  }
  async function zr(fr, tr, ur = {}) {
    const { seed: jt, m: Ot, d: Lt } = Yr(fr, tr, ur.extraEntropy), Qt = new Zt(Ce, Ee);
    await Qt.reseed(jt);
    let or;
    for (; !(or = Ar(await Qt.generate(), Ot, Lt, ur.canonical)); )
      await Qt.reseed();
    return Nr(or, ur);
  }
  B.sign = zr;
  function Jr(fr, tr, ur = {}) {
    const { seed: jt, m: Ot, d: Lt } = Yr(fr, tr, ur.extraEntropy), Qt = new Zt(Ce, Ee);
    Qt.reseedSync(jt);
    let or;
    for (; !(or = Ar(Qt.generateSync(), Ot, Lt, ur.canonical)); )
      Qt.reseedSync();
    return Nr(or, ur);
  }
  B.signSync = Jr;
  const Jt = { strict: !0 };
  function Dt(fr, tr, ur, jt = Jt) {
    let Ot;
    try {
      Ot = Ir(fr), tr = Nt(tr);
    } catch {
      return !1;
    }
    const { r: Lt, s: Qt } = Ot;
    if (jt.strict && Ot.hasHighS())
      return !1;
    const or = sr(tr);
    let hr;
    try {
      hr = Br(ur);
    } catch {
      return !1;
    }
    const { n: yr } = se, xr = nr(Qt, yr), Rr = Ht(or * xr, yr), ir = Ht(Lt * xr, yr), vr = Kt.BASE.multiplyAndAddUnsafe(hr, Rr, ir);
    return vr ? Ht(vr.x, yr) === Lt : !1;
  }
  B.verify = Dt;
  function Gt(fr) {
    return Ht(xt(fr), se.n);
  }
  class rr {
    constructor(tr, ur) {
      this.r = tr, this.s = ur, this.assertValidity();
    }
    static fromHex(tr) {
      const ur = Nt(tr);
      if (ur.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${ur.length}`);
      const jt = xt(ur.subarray(0, 32)), Ot = xt(ur.subarray(32, 64));
      return new rr(jt, Ot);
    }
    assertValidity() {
      const { r: tr, s: ur } = this;
      if (!_r(tr) || !pr(ur))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Qe(this.r) + Qe(this.s);
    }
    toRawBytes() {
      return kt(this.toHex());
    }
  }
  function cr(fr) {
    return Kt.fromPrivateKey(fr).toRawX();
  }
  class br {
    constructor(tr, ur, jt = B.utils.randomBytes()) {
      if (tr == null)
        throw new TypeError(`sign: Expected valid message, not "${tr}"`);
      this.m = Nt(tr);
      const { x: Ot, scalar: Lt } = this.getScalar(Sr(ur));
      if (this.px = Ot, this.d = Lt, this.rand = Nt(jt), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(tr) {
      const ur = Kt.fromPrivateKey(tr), jt = ur.hasEvenY() ? tr : se.n - tr;
      return { point: ur, scalar: jt, x: ur.toRawX() };
    }
    initNonce(tr, ur) {
      return bt(tr ^ xt(ur));
    }
    finalizeNonce(tr) {
      const ur = Ht(xt(tr), se.n);
      if (ur === Y)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: jt, x: Ot, scalar: Lt } = this.getScalar(ur);
      return { R: jt, rx: Ot, k: Lt };
    }
    finalizeSig(tr, ur, jt, Ot) {
      return new rr(tr.x, Ht(ur + jt * Ot, se.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: tr, d: ur, px: jt, rand: Ot } = this, Lt = B.utils.taggedHash, Qt = this.initNonce(ur, await Lt(Xr.aux, Ot)), { R: or, rx: hr, k: yr } = this.finalizeNonce(await Lt(Xr.nonce, Qt, jt, tr)), xr = Gt(await Lt(Xr.challenge, hr, jt, tr)), Rr = this.finalizeSig(or, yr, xr, ur);
      return await jr(Rr, tr, jt) || this.error(), Rr;
    }
    calcSync() {
      const { m: tr, d: ur, px: jt, rand: Ot } = this, Lt = B.utils.taggedHashSync, Qt = this.initNonce(ur, Lt(Xr.aux, Ot)), { R: or, rx: hr, k: yr } = this.finalizeNonce(Lt(Xr.nonce, Qt, jt, tr)), xr = Gt(Lt(Xr.challenge, hr, jt, tr)), Rr = this.finalizeSig(or, yr, xr, ur);
      return Lr(Rr, tr, jt) || this.error(), Rr;
    }
  }
  async function gr(fr, tr, ur) {
    return new br(fr, tr, ur).calc();
  }
  function Or(fr, tr, ur) {
    return new br(fr, tr, ur).calcSync();
  }
  function Wr(fr, tr, ur) {
    const jt = fr instanceof rr, Ot = jt ? fr : rr.fromHex(fr);
    return jt && Ot.assertValidity(), {
      ...Ot,
      m: Nt(tr),
      P: Br(ur)
    };
  }
  function kr(fr, tr, ur, jt) {
    const Ot = Kt.BASE.multiplyAndAddUnsafe(tr, Sr(ur), Ht(-jt, se.n));
    return !(!Ot || !Ot.hasEvenY() || Ot.x !== fr);
  }
  async function jr(fr, tr, ur) {
    try {
      const { r: jt, s: Ot, m: Lt, P: Qt } = Wr(fr, tr, ur), or = Gt(await B.utils.taggedHash(Xr.challenge, bt(jt), Qt.toRawX(), Lt));
      return kr(jt, Qt, Ot, or);
    } catch {
      return !1;
    }
  }
  function Lr(fr, tr, ur) {
    try {
      const { r: jt, s: Ot, m: Lt, P: Qt } = Wr(fr, tr, ur), or = Gt(B.utils.taggedHashSync(Xr.challenge, bt(jt), Qt.toRawX(), Lt));
      return kr(jt, Qt, Ot, or);
    } catch (jt) {
      if (jt instanceof Pt)
        throw jt;
      return !1;
    }
  }
  B.schnorr = {
    Signature: rr,
    getPublicKey: cr,
    sign: gr,
    verify: jr,
    signSync: Or,
    verifySync: Lr
  }, Kt.BASE._setWindowSize(8);
  const Fr = {
    node: z,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Xr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Zr = {};
  B.utils = {
    bytesToHex: Je,
    hexToBytes: kt,
    concatBytes: Ft,
    mod: Ht,
    invert: nr,
    isValidPrivateKey(fr) {
      try {
        return Sr(fr), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: bt,
    _normalizePrivateKey: Sr,
    hashToPrivateKey: (fr) => {
      fr = Nt(fr);
      const tr = Ee + 8;
      if (fr.length < tr || fr.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const ur = Ht(xt(fr), se.n - ne) + ne;
      return bt(ur);
    },
    randomBytes: (fr = 32) => {
      if (Fr.web)
        return Fr.web.getRandomValues(new Uint8Array(fr));
      if (Fr.node) {
        const { randomBytes: tr } = Fr.node;
        return Uint8Array.from(tr(fr));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(Ee + 8)),
    precompute(fr = 8, tr = Kt.BASE) {
      const ur = tr === Kt.BASE ? tr : new Kt(tr.x, tr.y);
      return ur._setWindowSize(fr), ur.multiply(ie), ur;
    },
    sha256: async (...fr) => {
      if (Fr.web) {
        const tr = await Fr.web.subtle.digest("SHA-256", Ft(...fr));
        return new Uint8Array(tr);
      } else if (Fr.node) {
        const { createHash: tr } = Fr.node, ur = tr("sha256");
        return fr.forEach((jt) => ur.update(jt)), Uint8Array.from(ur.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (fr, ...tr) => {
      if (Fr.web) {
        const ur = await Fr.web.subtle.importKey("raw", fr, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), jt = Ft(...tr), Ot = await Fr.web.subtle.sign("HMAC", ur, jt);
        return new Uint8Array(Ot);
      } else if (Fr.node) {
        const { createHmac: ur } = Fr.node, jt = ur("sha256", fr);
        return tr.forEach((Ot) => jt.update(Ot)), Uint8Array.from(jt.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (fr, ...tr) => {
      let ur = Zr[fr];
      if (ur === void 0) {
        const jt = await B.utils.sha256(Uint8Array.from(fr, (Ot) => Ot.charCodeAt(0)));
        ur = Ft(jt, jt), Zr[fr] = ur;
      }
      return B.utils.sha256(ur, ...tr);
    },
    taggedHashSync: (fr, ...tr) => {
      if (typeof dr != "function")
        throw new Pt("sha256Sync is undefined, you need to set it");
      let ur = Zr[fr];
      if (ur === void 0) {
        const jt = dr(Uint8Array.from(fr, (Ot) => Ot.charCodeAt(0)));
        ur = Ft(jt, jt), Zr[fr] = ur;
      }
      return dr(ur, ...tr);
    },
    _JacobianPoint: Bt
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return dr;
      },
      set(fr) {
        dr || (dr = fr);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return er;
      },
      set(fr) {
        er || (er = fr);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const z = paramBytesForAlg[B];
  if (z)
    return z;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, z) {
  const Y = signatureAsBytes(B), ne = getParamBytesForAlg(z), oe = ne + 1, ie = Y.length;
  let ae = 0;
  if (Y[ae++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let se = Y[ae++];
  if (se === (MAX_OCTET | 1) && (se = Y[ae++]), ie - ae < se)
    throw new Error(`"seq" specified length of "${se}", only "${ie - ae}" remaining`);
  if (Y[ae++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ve = Y[ae++];
  if (ie - ae - 2 < ve)
    throw new Error(`"r" specified length of "${ve}", only "${ie - ae - 2}" available`);
  if (oe < ve)
    throw new Error(`"r" specified length of "${ve}", max of "${oe}" is acceptable`);
  const ge = ae;
  if (ae += ve, Y[ae++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const le = Y[ae++];
  if (ie - ae !== le)
    throw new Error(`"s" specified length of "${le}", expected "${ie - ae}"`);
  if (oe < le)
    throw new Error(`"s" specified length of "${le}", max of "${oe}" is acceptable`);
  const Ee = ae;
  if (ae += le, ae !== ie)
    throw new Error(`Expected to consume entire array, but "${ie - ae}" bytes remain`);
  const Ce = ne - ve, Pe = ne - le, Xe = new Uint8Array(Ce + ve + Pe + le);
  for (ae = 0; ae < Ce; ++ae)
    Xe[ae] = 0;
  Xe.set(Y.subarray(ge + Math.max(-Ce, 0), ge + ve), ae), ae = ne;
  for (const ht = ae; ae < ht + Pe; ++ae)
    Xe[ae] = 0;
  return Xe.set(Y.subarray(Ee + Math.max(-Pe, 0), Ee + le), ae), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(Xe));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, z, Y) {
  let ne = 0;
  for (; z + ne < Y && B[z + ne] === 0; )
    ++ne;
  return B[z + ne] >= MAX_OCTET && --ne, ne;
}
function joseToDer(B, z) {
  B = signatureAsBytes(B);
  const Y = getParamBytesForAlg(z), ne = B.length;
  if (ne !== Y * 2)
    throw new TypeError(`"${z}" signatures must be "${Y * 2}" bytes, saw "${ne}"`);
  const oe = countPadding(B, 0, Y), ie = countPadding(B, Y, B.length), ae = Y - oe, se = Y - ie, ve = 2 + ae + 1 + 1 + se, ge = ve < MAX_OCTET, le = new Uint8Array((ge ? 2 : 3) + ve);
  let Ee = 0;
  return le[Ee++] = ENCODED_TAG_SEQ, ge ? le[Ee++] = ve : (le[Ee++] = MAX_OCTET | 1, le[Ee++] = ve & 255), le[Ee++] = ENCODED_TAG_INT, le[Ee++] = ae, oe < 0 ? (le[Ee++] = 0, le.set(B.subarray(0, Y), Ee), Ee += Y) : (le.set(B.subarray(oe, Y), Ee), Ee += Y - oe), le[Ee++] = ENCODED_TAG_INT, le[Ee++] = se, ie < 0 ? (le[Ee++] = 0, le.set(B.subarray(Y), Ee)) : le.set(B.subarray(Y + ie), Ee), le;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(z) {
    super(), this.name = "MissingParametersError", this.message = z || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(z) {
    super(), this.name = "InvalidTokenError", this.message = z || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (B, ...z) => {
  const Y = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return z.forEach((ne) => Y.update(ne)), Y.digest();
};
class SECP256K1Client {
  static derivePublicKey(z, Y = !0) {
    return z.length === 66 && (z = z.slice(0, 64)), z.length < 64 && (z = z.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(z, Y));
  }
  static signHash(z, Y, ne = "jose") {
    if (!z || !Y)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const oe = secp.signSync(z, Y.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (ne === "der")
      return (0, utils_1$2.bytesToHex)(oe);
    if (ne === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(oe, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(z) {
    return (0, ecdsaSigFormatter_1.joseToDer)(z, "ES256");
  }
  static verifyHash(z, Y, ne) {
    if (!z || !Y || !ne)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(Y, z, ne, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const z = secp256k1$1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return z.SECP256K1Client;
  } });
  const Y = {
    ES256K: z.SECP256K1Client
  };
  B.cryptoClients = Y;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function oe(ie) {
    return ie instanceof Y ? ie : new Y(function(ae) {
      ae(ie);
    });
  }
  return new (Y || (Y = Promise))(function(ie, ae) {
    function se(le) {
      try {
        ge(ne.next(le));
      } catch (Ee) {
        ae(Ee);
      }
    }
    function ve(le) {
      try {
        ge(ne.throw(le));
      } catch (Ee) {
        ae(Ee);
      }
    }
    function ge(le) {
      le.done ? ie(le.value) : oe(le.value).then(se, ve);
    }
    ge((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const Y = typeof B == "string" ? new TextEncoder().encode(B) : B, ne = yield crypto.subtle.digest("SHA-256", Y);
        return new Uint8Array(ne);
      } else {
        const Y = requireCryptoBrowserify();
        if (!Y.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(Y.createHash("sha256").update(B).digest());
      }
    } catch (z) {
      return console.log(z), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ne) {
  function oe(ie) {
    return ie instanceof Y ? ie : new Y(function(ae) {
      ae(ie);
    });
  }
  return new (Y || (Y = Promise))(function(ie, ae) {
    function se(le) {
      try {
        ge(ne.next(le));
      } catch (Ee) {
        ae(Ee);
      }
    }
    function ve(le) {
      try {
        ge(ne.throw(le));
      } catch (Ee) {
        ae(Ee);
      }
    }
    function ge(le) {
      le.done ? ie(le.value) : oe(le.value).then(se, ve);
    }
    ge((ne = ne.apply(B, z || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(B, z) {
  const Y = [], ne = base64url$2.encode(JSON.stringify(z));
  Y.push(ne);
  const oe = base64url$2.encode(JSON.stringify(B));
  return Y.push(oe), Y.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof z != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (z = z.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(z))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[z], this.rawPrivateKey = Y;
  }
  header(z = {}) {
    const Y = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, Y, z);
  }
  sign(z, Y = !1, ne = {}) {
    const oe = this.header(ne), ie = createSigningInput(z, oe), ae = (0, sha256_1$1.hashSha256)(ie);
    return this.createWithSignedHash(z, Y, oe, ie, ae);
  }
  signAsync(z, Y = !1, ne = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const oe = this.header(ne), ie = createSigningInput(z, oe), ae = yield (0, sha256_1$1.hashSha256Async)(ie);
      return this.createWithSignedHash(z, Y, oe, ie, ae);
    });
  }
  createWithSignedHash(z, Y, ne, oe, ie) {
    const ae = this.cryptoClient.signHash(ie, this.rawPrivateKey);
    return Y ? {
      header: [base64url$2.encode(JSON.stringify(ne))],
      payload: JSON.stringify(z),
      signature: [ae]
    } : [oe, ae].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof z != "string")
      throw "signing algorithm parameter must be a string";
    if (z = z.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(z))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[z], this.rawPublicKey = Y;
  }
  verify(z) {
    return typeof z == "string" ? this.verifyCompact(z, !1) : typeof z == "object" ? this.verifyExpanded(z, !1) : !1;
  }
  verifyAsync(z) {
    return typeof z == "string" ? this.verifyCompact(z, !0) : typeof z == "object" ? this.verifyExpanded(z, !0) : Promise.resolve(!1);
  }
  verifyCompact(z, Y) {
    const ne = z.split("."), oe = ne[0] + "." + ne[1], ie = (ae) => {
      const se = this.cryptoClient.loadSignature(ne[2]);
      return this.cryptoClient.verifyHash(ae, se, this.rawPublicKey);
    };
    if (Y)
      return (0, sha256_1.hashSha256Async)(oe).then((ae) => ie(ae));
    {
      const ae = (0, sha256_1.hashSha256)(oe);
      return ie(ae);
    }
  }
  verifyExpanded(z, Y) {
    const ne = [z.header.join("."), base64url$1.encode(z.payload)].join(".");
    let oe = !0;
    const ie = (ae) => (z.signature.map((se) => {
      const ve = this.cryptoClient.loadSignature(se);
      this.cryptoClient.verifyHash(ae, ve, this.rawPublicKey) || (oe = !1);
    }), oe);
    if (Y)
      return (0, sha256_1.hashSha256Async)(ne).then((ae) => ie(ae));
    {
      const ae = (0, sha256_1.hashSha256)(ne);
      return ie(ae);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const z = B.split("."), Y = JSON.parse(base64url.decode(z[0])), ne = JSON.parse(base64url.decode(z[1])), oe = z[2];
    return {
      header: Y,
      payload: ne,
      signature: oe
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let z = B.payload;
    B.payload[0] !== "{" && (z = base64url.decode(z));
    const Y = [];
    return B.header.map((ne) => {
      const oe = JSON.parse(base64url.decode(ne));
      Y.push(oe);
    }), {
      header: Y,
      payload: JSON.parse(z),
      signature: B.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(B) {
  var z = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ne, oe, ie, ae) {
    ae === void 0 && (ae = ie);
    var se = Object.getOwnPropertyDescriptor(oe, ie);
    (!se || ("get" in se ? !oe.__esModule : se.writable || se.configurable)) && (se = { enumerable: !0, get: function() {
      return oe[ie];
    } }), Object.defineProperty(ne, ae, se);
  } : function(ne, oe, ie, ae) {
    ae === void 0 && (ae = ie), ne[ae] = oe[ie];
  }), Y = commonjsGlobal && commonjsGlobal.__exportStar || function(ne, oe) {
    for (var ie in ne) ie !== "default" && !Object.prototype.hasOwnProperty.call(oe, ie) && z(oe, ne, ie);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), Y(signer, B), Y(verifier, B), Y(decode$i, B), Y(errors$1, B), Y(cryptoClients, B);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const B = Array(256).fill(-1);
  for (let z = 0; z < r.length; ++z) B[r.charCodeAt(z)] = z;
})();
var s, i, o, h$1 = (s = function(B, z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.bech32m = z.bech32 = void 0;
  const Y = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ne = {};
  for (let Ee = 0; Ee < 32; Ee++) {
    const Ce = Y.charAt(Ee);
    ne[Ce] = Ee;
  }
  function oe(Ee) {
    const Ce = Ee >> 25;
    return (33554431 & Ee) << 5 ^ 996825010 & -(Ce >> 0 & 1) ^ 642813549 & -(Ce >> 1 & 1) ^ 513874426 & -(Ce >> 2 & 1) ^ 1027748829 & -(Ce >> 3 & 1) ^ 705979059 & -(Ce >> 4 & 1);
  }
  function ie(Ee) {
    let Ce = 1;
    for (let Pe = 0; Pe < Ee.length; ++Pe) {
      const Xe = Ee.charCodeAt(Pe);
      if (Xe < 33 || Xe > 126) return "Invalid prefix (" + Ee + ")";
      Ce = oe(Ce) ^ Xe >> 5;
    }
    Ce = oe(Ce);
    for (let Pe = 0; Pe < Ee.length; ++Pe) {
      const Xe = Ee.charCodeAt(Pe);
      Ce = oe(Ce) ^ 31 & Xe;
    }
    return Ce;
  }
  function ae(Ee, Ce, Pe, Xe) {
    let ht = 0, wt = 0;
    const Pt = (1 << Pe) - 1, vt = [];
    for (let Bt = 0; Bt < Ee.length; ++Bt) for (ht = ht << Ce | Ee[Bt], wt += Ce; wt >= Pe; ) wt -= Pe, vt.push(ht >> wt & Pt);
    if (Xe) wt > 0 && vt.push(ht << Pe - wt & Pt);
    else {
      if (wt >= Ce) return "Excess padding";
      if (ht << Pe - wt & Pt) return "Non-zero padding";
    }
    return vt;
  }
  function se(Ee) {
    return ae(Ee, 8, 5, !0);
  }
  function ve(Ee) {
    const Ce = ae(Ee, 5, 8, !1);
    if (Array.isArray(Ce)) return Ce;
  }
  function ge(Ee) {
    const Ce = ae(Ee, 5, 8, !1);
    if (Array.isArray(Ce)) return Ce;
    throw new Error(Ce);
  }
  function le(Ee) {
    let Ce;
    function Pe(Xe, ht) {
      if (ht = ht || 90, Xe.length < 8) return Xe + " too short";
      if (Xe.length > ht) return "Exceeds length limit";
      const wt = Xe.toLowerCase(), Pt = Xe.toUpperCase();
      if (Xe !== wt && Xe !== Pt) return "Mixed-case string " + Xe;
      const vt = (Xe = wt).lastIndexOf("1");
      if (vt === -1) return "No separator character for " + Xe;
      if (vt === 0) return "Missing prefix for " + Xe;
      const Bt = Xe.slice(0, vt), Ct = Xe.slice(vt + 1);
      if (Ct.length < 6) return "Data too short";
      let Wt = ie(Bt);
      if (typeof Wt == "string") return Wt;
      const Kt = [];
      for (let Yt = 0; Yt < Ct.length; ++Yt) {
        const Ut = Ct.charAt(Yt), qt = ne[Ut];
        if (qt === void 0) return "Unknown character " + Ut;
        Wt = oe(Wt) ^ qt, Yt + 6 >= Ct.length || Kt.push(qt);
      }
      return Wt !== Ce ? "Invalid checksum for " + Xe : { prefix: Bt, words: Kt };
    }
    return Ce = Ee === "bech32" ? 1 : 734539939, { decodeUnsafe: function(Xe, ht) {
      const wt = Pe(Xe, ht);
      if (typeof wt == "object") return wt;
    }, decode: function(Xe, ht) {
      const wt = Pe(Xe, ht);
      if (typeof wt == "object") return wt;
      throw new Error(wt);
    }, encode: function(Xe, ht, wt) {
      if (wt = wt || 90, Xe.length + 7 + ht.length > wt) throw new TypeError("Exceeds length limit");
      let Pt = ie(Xe = Xe.toLowerCase());
      if (typeof Pt == "string") throw new Error(Pt);
      let vt = Xe + "1";
      for (let Bt = 0; Bt < ht.length; ++Bt) {
        const Ct = ht[Bt];
        if (Ct >> 5) throw new Error("Non 5-bit word");
        Pt = oe(Pt) ^ Ct, vt += Y.charAt(Ct);
      }
      for (let Bt = 0; Bt < 6; ++Bt) Pt = oe(Pt);
      Pt ^= Ce;
      for (let Bt = 0; Bt < 6; ++Bt) vt += Y.charAt(Pt >> 5 * (5 - Bt) & 31);
      return vt;
    }, toWords: se, fromWordsUnsafe: ve, fromWords: ge };
  }
  z.bech32 = le("bech32"), z.bech32m = le("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
async function getProviderOrThrow(B) {
  var Y;
  const z = await (B == null ? void 0 : B()) || ((Y = window.XverseProviders) == null ? void 0 : Y.BitcoinProvider) || window.BitcoinProvider;
  if (!z)
    throw new Error("No Bitcoin wallet installed");
  return z;
}
var BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Testnet4 = "Testnet4", B.Signet = "Signet", B.Regtest = "Regtest", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), getAddress = async (B) => {
  var ne, oe;
  const z = await getProviderOrThrow(B.getProvider), { purposes: Y } = B.payload;
  if (!Y)
    throw new Error("Address purposes are required");
  try {
    const ie = lib$1.createUnsecuredToken(B.payload), ae = await z.connect(ie);
    (ne = B.onFinish) == null || ne.call(B, ae);
  } catch (ie) {
    console.error("[Connect] Error during address request", ie), (oe = B.onCancel) == null || oe.call(B);
  }
}, stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((B) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
async function waitForUnisatExtensionReady() {
  let B = 0;
  const z = 20;
  for (; B < z; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const Y = await window.unisat.getAccounts();
        if (Y && Y.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((Y) => {
      setTimeout(Y, 100);
    });
  }
  return !1;
}
BitcoinNetworkType.Mainnet, BitcoinNetworkType.Testnet, BitcoinNetworkType.Signet;
const getXverseAddresses = async (B) => {
  var ie;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((ie = window.XverseProviders) == null ? void 0 : ie.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const Y = async () => window.XverseProviders.BitcoinProvider, ne = [], oe = {
    payload: {
      purposes: ["ordinals", "payment"],
      message: "Provide access to Payment address and Ordinals address",
      network: {
        type: (B === Network.TESTNET, BitcoinNetworkType.Testnet4)
      }
    },
    getProvider: Y,
    onFinish: (ae) => {
      if (console.log("==>response", ae), !ae || !ae.addresses || ae.addresses.length !== 2)
        throw new BrowserWalletSigningError(
          "Failed to retrieve addresses using selected wallet"
        );
      ae.addresses.forEach((se) => {
        const ve = getAddressFormat(se.address, B);
        let ge = se.publicKey;
        ve === "taproot" && (ge = Buffer$2.from(se.publicKey, "hex").length === 33 ? ge : `02${ge}`), ne.push({
          publicKey: ge,
          address: se.address,
          format: ve
        });
      });
    },
    onCancel: () => {
      throw new BrowserWalletRequestCancelledByUserError("User Error");
    }
  };
  return await getAddress(oe), ne;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work\  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: B,
  wallet: z,
  chain: Y = Chain.BITCOIN
}, { readOnly: ne = !1 } = {}) => {
  switch (z) {
    case Wallet.UNISAT: {
      const ie = await getAddresses$3(B === "testnet4" ? "testnet" : B, Y, { readOnly: ne });
      if (!ie || ie.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const ae = ie[0];
      return {
        address: {
          ordinals: ae.address,
          payments: ae.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ae.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ae.format
        }
      };
    }
    case Wallet.XVERSE: {
      const oe = await getXverseAddresses(B);
      if (!oe || oe.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const ie = oe.find(
        (se) => se.format === "p2sh-p2wpkh" || se.format === "segwit"
      );
      if (!ie)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const ae = oe.find(
        (se) => se.format === "taproot"
      );
      if (!ae)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: ae.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ie.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const oe = await getAddresses$2(B);
      if (!oe || oe.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const ie = oe.find(
        (se) => se.format === "segwit" || se.format === "p2sh-p2wpkh"
      );
      if (!ie)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const ae = oe.find(
        (se) => se.format === "taproot"
      );
      if (!ae)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: ae.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ie.format
        }
      };
    }
    case Wallet.LEATHER: {
      const oe = await getAddresses$1(B);
      if (!oe || oe.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const ie = oe.find(
        (se) => se.format === "segwit"
      );
      if (!ie)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const ae = oe.find(
        (se) => se.format === "taproot"
      );
      if (!ae)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: ae.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ie.format
        }
      };
    }
    case Wallet.OKX: {
      const oe = await getAddresses(B);
      if (!oe || oe.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const ie = oe[0];
      return {
        address: {
          ordinals: ie.address,
          payments: ie.address
        },
        publicKey: {
          ordinals: ie.publicKey,
          payments: ie.publicKey
        },
        format: {
          ordinals: ie.format,
          payments: ie.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: B,
  onError: z
}) {
  const {
    updateAddress: Y,
    network: ne,
    updateWallet: oe,
    updatePublicKey: ie,
    updateFormat: ae,
    disconnectWallet: se,
    address: ve,
    publicKey: ge,
    format: le,
    wallet: Ee,
    chain: Ce
  } = useOrdConnect(), Pe = (ht, wt) => {
    z(wt.message ?? wt.toString()), console.error(`Error while connecting to ${ht} wallet`, wt), se(), wt instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[ht],
      "_blank",
      "noopener,noreferrer"
    );
  }, Xe = async (ht, { readOnly: wt = !1 } = {}) => {
    try {
      const { address: Pt, publicKey: vt, format: Bt } = await connectWallet(
        { network: ne, wallet: ht, chain: Ce },
        { readOnly: wt }
      );
      return Y({
        ordinals: Pt.ordinals,
        payments: Pt.payments
      }), ie({
        ordinals: vt.ordinals,
        payments: vt.payments
      }), oe(ht), ae({
        ordinals: Bt.ordinals,
        payments: Bt.payments
      }), B(), !0;
    } catch (Pt) {
      return console.log("===>err", Pt), Pe(ht, Pt), !1;
    }
  };
  return useEffect(() => {
    if (Ee !== Wallet.UNISAT)
      return;
    let ht = !0, wt = !1;
    const Pt = () => Xe(Wallet.UNISAT);
    return ve && ge && le && (async () => {
      const Bt = await waitForUnisatExtensionReady();
      if (ht) {
        if (!Bt) {
          se();
          return;
        }
        wt = await Xe(Wallet.UNISAT, {
          readOnly: !0
        }), ht && wt && window.unisat.addListener("accountsChanged", Pt);
      }
    })(), () => {
      ht = !1, wt && window.unisat.removeListener("accountsChanged", Pt);
    };
  }, [Ee]), { connectWallet: Xe };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  onConnect: z,
  icon: Y,
  renderAvatar: ne,
  isPreferred: oe
}) {
  const ie = isMobileUserAgent(), { wallet: ae, address: se } = useOrdConnect(), [ve, ge] = useState(!1), le = WALLET_TO_NAME[B], Ee = async () => {
    ge(!0);
    try {
      await z();
    } catch {
    }
    ge(!1);
  }, Ce = ae === B && se.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: Ee,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: Y, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: le }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: ie ? "Available on app" : "" })
        ] }),
        ae === B && se.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          ne ? ne(se.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: ie ? 12 : 16,
              variant: "beam",
              name: se.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(se.ordinals) })
        ] }) : null,
        !Ce && oe ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        ve ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: ie ? 20 : 24,
            height: ie ? 20 : 24,
            alt: `${le} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: ie ? 20 : 24,
            height: ie ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: B,
  closeModal: z,
  renderAvatar: Y,
  preferredWallet: ne,
  walletsOrder: oe,
  visibleWallets: ie
}) {
  const [ae, se] = useState(""), { connectWallet: ve } = useConnect({
    onClose: z,
    onError: (Pe) => se(Pe)
  }), { network: ge, chain: le } = useOrdConnect(), Ee = isMobileUserAgent(), Ce = useMemo(() => {
    const Xe = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ve(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: Ee && ge !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ve(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: Ee,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ve(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ve(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ve(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: Ee,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((wt) => (ie || []).includes(wt.wallet)).filter(
      (wt) => wt.chains.includes(le) && !wt.hidden
    );
    return oe ? Xe.map((wt) => {
      const Pt = oe.findIndex(
        (vt) => vt === wt.wallet
      );
      return Pt >= 0 ? { ...wt, order: Pt } : wt;
    }).sort((wt, Pt) => wt.order - Pt.order) : Xe;
  }, [Ee, ge, oe, ve, ie, le]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ze$1, { appear: !0, show: B, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    yt$1,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: z,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[le],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: z,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: Ce.map((Pe, Xe) => {
                  const ht = Xe === Ce.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Pe.wallet,
                        onConnect: async () => {
                          se("");
                          const wt = Pe.onConnect().then((vt) => (vt && se(""), vt)), Pt = await Promise.race([
                            wt,
                            new Promise((vt) => {
                              setTimeout(() => vt("timeout"), 5e3);
                            })
                          ]);
                          return typeof Pt == "string" ? (se(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), wt) : Pt;
                        },
                        icon: Pe.icon,
                        renderAvatar: Y,
                        isPreferred: ne === Pe.wallet
                      }
                    ),
                    !ht && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Pe.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: ae })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: B,
  onViewProfile: z,
  onChangeWalletClick: Y,
  onDisconnectWalletClick: ne,
  renderAvatar: oe,
  preferredWallet: ie,
  walletsOrder: ae
}) {
  const {
    address: se,
    disconnectWallet: ve,
    network: ge,
    isModalOpen: le,
    openModal: Ee,
    closeModal: Ce,
    visibleWallets: Pe
  } = useOrdConnect(), Xe = useHasMounted(), ht = () => B ? null : se != null && se.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: se.ordinals,
      network: ge,
      onViewProfile: z,
      onChangeWallet: () => {
        Ee(), Y == null || Y();
      },
      onDisconnectWallet: () => {
        ve(), ne == null || ne();
      },
      renderAvatar: oe
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !Xe, openModal: Ee });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    ht(),
    Xe ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: le,
        closeModal: Ce,
        renderAvatar: oe,
        preferredWallet: ie,
        walletsOrder: ae,
        visibleWallets: Pe
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var z, Y, ne, oe = vt.prototype = { constructor: vt, toString: null, valueOf: null }, ie = new vt(1), ae = 20, se = 4, ve = -7, ge = 21, le = -1e7, Ee = 1e7, Ce = !1, Pe = 1, Xe = 0, ht = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, wt = "0123456789abcdefghijklmnopqrstuvwxyz", Pt = !0;
  function vt(Ut, qt) {
    var zt, Ft, Ve, Je, Ke, Qe, bt, _t, $t = this;
    if (!($t instanceof vt)) return new vt(Ut, qt);
    if (qt == null) {
      if (Ut && Ut._isBigNumber === !0) {
        $t.s = Ut.s, !Ut.c || Ut.e > Ee ? $t.c = $t.e = null : Ut.e < le ? $t.c = [$t.e = 0] : ($t.e = Ut.e, $t.c = Ut.c.slice());
        return;
      }
      if ((Qe = typeof Ut == "number") && Ut * 0 == 0) {
        if ($t.s = 1 / Ut < 0 ? (Ut = -Ut, -1) : 1, Ut === ~~Ut) {
          for (Je = 0, Ke = Ut; Ke >= 10; Ke /= 10, Je++) ;
          Je > Ee ? $t.c = $t.e = null : ($t.e = Je, $t.c = [Ut]);
          return;
        }
        _t = String(Ut);
      } else {
        if (!isNumeric.test(_t = String(Ut))) return ne($t, _t, Qe);
        $t.s = _t.charCodeAt(0) == 45 ? (_t = _t.slice(1), -1) : 1;
      }
      (Je = _t.indexOf(".")) > -1 && (_t = _t.replace(".", "")), (Ke = _t.search(/e/i)) > 0 ? (Je < 0 && (Je = Ke), Je += +_t.slice(Ke + 1), _t = _t.substring(0, Ke)) : Je < 0 && (Je = _t.length);
    } else {
      if (intCheck(qt, 2, wt.length, "Base"), qt == 10 && Pt)
        return $t = new vt(Ut), Kt($t, ae + $t.e + 1, se);
      if (_t = String(Ut), Qe = typeof Ut == "number") {
        if (Ut * 0 != 0) return ne($t, _t, Qe, qt);
        if ($t.s = 1 / Ut < 0 ? (_t = _t.slice(1), -1) : 1, vt.DEBUG && _t.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Ut);
      } else
        $t.s = _t.charCodeAt(0) === 45 ? (_t = _t.slice(1), -1) : 1;
      for (zt = wt.slice(0, qt), Je = Ke = 0, bt = _t.length; Ke < bt; Ke++)
        if (zt.indexOf(Ft = _t.charAt(Ke)) < 0) {
          if (Ft == ".") {
            if (Ke > Je) {
              Je = bt;
              continue;
            }
          } else if (!Ve && (_t == _t.toUpperCase() && (_t = _t.toLowerCase()) || _t == _t.toLowerCase() && (_t = _t.toUpperCase()))) {
            Ve = !0, Ke = -1, Je = 0;
            continue;
          }
          return ne($t, String(Ut), Qe, qt);
        }
      Qe = !1, _t = Y(_t, qt, 10, $t.s), (Je = _t.indexOf(".")) > -1 ? _t = _t.replace(".", "") : Je = _t.length;
    }
    for (Ke = 0; _t.charCodeAt(Ke) === 48; Ke++) ;
    for (bt = _t.length; _t.charCodeAt(--bt) === 48; ) ;
    if (_t = _t.slice(Ke, ++bt)) {
      if (bt -= Ke, Qe && vt.DEBUG && bt > 15 && (Ut > MAX_SAFE_INTEGER$2 || Ut !== mathfloor(Ut)))
        throw Error(tooManyDigits + $t.s * Ut);
      if ((Je = Je - Ke - 1) > Ee)
        $t.c = $t.e = null;
      else if (Je < le)
        $t.c = [$t.e = 0];
      else {
        if ($t.e = Je, $t.c = [], Ke = (Je + 1) % LOG_BASE, Je < 0 && (Ke += LOG_BASE), Ke < bt) {
          for (Ke && $t.c.push(+_t.slice(0, Ke)), bt -= LOG_BASE; Ke < bt; )
            $t.c.push(+_t.slice(Ke, Ke += LOG_BASE));
          Ke = LOG_BASE - (_t = _t.slice(Ke)).length;
        } else
          Ke -= bt;
        for (; Ke--; _t += "0") ;
        $t.c.push(+_t);
      }
    } else
      $t.c = [$t.e = 0];
  }
  vt.clone = clone, vt.ROUND_UP = 0, vt.ROUND_DOWN = 1, vt.ROUND_CEIL = 2, vt.ROUND_FLOOR = 3, vt.ROUND_HALF_UP = 4, vt.ROUND_HALF_DOWN = 5, vt.ROUND_HALF_EVEN = 6, vt.ROUND_HALF_CEIL = 7, vt.ROUND_HALF_FLOOR = 8, vt.EUCLID = 9, vt.config = vt.set = function(Ut) {
    var qt, zt;
    if (Ut != null)
      if (typeof Ut == "object") {
        if (Ut.hasOwnProperty(qt = "DECIMAL_PLACES") && (zt = Ut[qt], intCheck(zt, 0, MAX, qt), ae = zt), Ut.hasOwnProperty(qt = "ROUNDING_MODE") && (zt = Ut[qt], intCheck(zt, 0, 8, qt), se = zt), Ut.hasOwnProperty(qt = "EXPONENTIAL_AT") && (zt = Ut[qt], zt && zt.pop ? (intCheck(zt[0], -1e9, 0, qt), intCheck(zt[1], 0, MAX, qt), ve = zt[0], ge = zt[1]) : (intCheck(zt, -1e9, MAX, qt), ve = -(ge = zt < 0 ? -zt : zt))), Ut.hasOwnProperty(qt = "RANGE"))
          if (zt = Ut[qt], zt && zt.pop)
            intCheck(zt[0], -1e9, -1, qt), intCheck(zt[1], 1, MAX, qt), le = zt[0], Ee = zt[1];
          else if (intCheck(zt, -1e9, MAX, qt), zt)
            le = -(Ee = zt < 0 ? -zt : zt);
          else
            throw Error(bignumberError + qt + " cannot be zero: " + zt);
        if (Ut.hasOwnProperty(qt = "CRYPTO"))
          if (zt = Ut[qt], zt === !!zt)
            if (zt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Ce = zt;
              else
                throw Ce = !zt, Error(bignumberError + "crypto unavailable");
            else
              Ce = zt;
          else
            throw Error(bignumberError + qt + " not true or false: " + zt);
        if (Ut.hasOwnProperty(qt = "MODULO_MODE") && (zt = Ut[qt], intCheck(zt, 0, 9, qt), Pe = zt), Ut.hasOwnProperty(qt = "POW_PRECISION") && (zt = Ut[qt], intCheck(zt, 0, MAX, qt), Xe = zt), Ut.hasOwnProperty(qt = "FORMAT"))
          if (zt = Ut[qt], typeof zt == "object") ht = zt;
          else throw Error(bignumberError + qt + " not an object: " + zt);
        if (Ut.hasOwnProperty(qt = "ALPHABET"))
          if (zt = Ut[qt], typeof zt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(zt))
            Pt = zt.slice(0, 10) == "0123456789", wt = zt;
          else
            throw Error(bignumberError + qt + " invalid: " + zt);
      } else
        throw Error(bignumberError + "Object expected: " + Ut);
    return {
      DECIMAL_PLACES: ae,
      ROUNDING_MODE: se,
      EXPONENTIAL_AT: [ve, ge],
      RANGE: [le, Ee],
      CRYPTO: Ce,
      MODULO_MODE: Pe,
      POW_PRECISION: Xe,
      FORMAT: ht,
      ALPHABET: wt
    };
  }, vt.isBigNumber = function(Ut) {
    if (!Ut || Ut._isBigNumber !== !0) return !1;
    if (!vt.DEBUG) return !0;
    var qt, zt, Ft = Ut.c, Ve = Ut.e, Je = Ut.s;
    e: if ({}.toString.call(Ft) == "[object Array]") {
      if ((Je === 1 || Je === -1) && Ve >= -1e9 && Ve <= MAX && Ve === mathfloor(Ve)) {
        if (Ft[0] === 0) {
          if (Ve === 0 && Ft.length === 1) return !0;
          break e;
        }
        if (qt = (Ve + 1) % LOG_BASE, qt < 1 && (qt += LOG_BASE), String(Ft[0]).length == qt) {
          for (qt = 0; qt < Ft.length; qt++)
            if (zt = Ft[qt], zt < 0 || zt >= BASE || zt !== mathfloor(zt)) break e;
          if (zt !== 0) return !0;
        }
      }
    } else if (Ft === null && Ve === null && (Je === null || Je === 1 || Je === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Ut);
  }, vt.maximum = vt.max = function() {
    return Ct(arguments, -1);
  }, vt.minimum = vt.min = function() {
    return Ct(arguments, 1);
  }, vt.random = function() {
    var Ut = 9007199254740992, qt = Math.random() * Ut & 2097151 ? function() {
      return mathfloor(Math.random() * Ut);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(zt) {
      var Ft, Ve, Je, Ke, Qe, bt = 0, _t = [], $t = new vt(ie);
      if (zt == null ? zt = ae : intCheck(zt, 0, MAX), Ke = mathceil(zt / LOG_BASE), Ce)
        if (crypto.getRandomValues) {
          for (Ft = crypto.getRandomValues(new Uint32Array(Ke *= 2)); bt < Ke; )
            Qe = Ft[bt] * 131072 + (Ft[bt + 1] >>> 11), Qe >= 9e15 ? (Ve = crypto.getRandomValues(new Uint32Array(2)), Ft[bt] = Ve[0], Ft[bt + 1] = Ve[1]) : (_t.push(Qe % 1e14), bt += 2);
          bt = Ke / 2;
        } else if (crypto.randomBytes) {
          for (Ft = crypto.randomBytes(Ke *= 7); bt < Ke; )
            Qe = (Ft[bt] & 31) * 281474976710656 + Ft[bt + 1] * 1099511627776 + Ft[bt + 2] * 4294967296 + Ft[bt + 3] * 16777216 + (Ft[bt + 4] << 16) + (Ft[bt + 5] << 8) + Ft[bt + 6], Qe >= 9e15 ? crypto.randomBytes(7).copy(Ft, bt) : (_t.push(Qe % 1e14), bt += 7);
          bt = Ke / 7;
        } else
          throw Ce = !1, Error(bignumberError + "crypto unavailable");
      if (!Ce)
        for (; bt < Ke; )
          Qe = qt(), Qe < 9e15 && (_t[bt++] = Qe % 1e14);
      for (Ke = _t[--bt], zt %= LOG_BASE, Ke && zt && (Qe = POWS_TEN[LOG_BASE - zt], _t[bt] = mathfloor(Ke / Qe) * Qe); _t[bt] === 0; _t.pop(), bt--) ;
      if (bt < 0)
        _t = [Je = 0];
      else {
        for (Je = -1; _t[0] === 0; _t.splice(0, 1), Je -= LOG_BASE) ;
        for (bt = 1, Qe = _t[0]; Qe >= 10; Qe /= 10, bt++) ;
        bt < LOG_BASE && (Je -= LOG_BASE - bt);
      }
      return $t.e = Je, $t.c = _t, $t;
    };
  }(), vt.sum = function() {
    for (var Ut = 1, qt = arguments, zt = new vt(qt[0]); Ut < qt.length; ) zt = zt.plus(qt[Ut++]);
    return zt;
  }, Y = /* @__PURE__ */ function() {
    var Ut = "0123456789";
    function qt(zt, Ft, Ve, Je) {
      for (var Ke, Qe = [0], bt, _t = 0, $t = zt.length; _t < $t; ) {
        for (bt = Qe.length; bt--; Qe[bt] *= Ft) ;
        for (Qe[0] += Je.indexOf(zt.charAt(_t++)), Ke = 0; Ke < Qe.length; Ke++)
          Qe[Ke] > Ve - 1 && (Qe[Ke + 1] == null && (Qe[Ke + 1] = 0), Qe[Ke + 1] += Qe[Ke] / Ve | 0, Qe[Ke] %= Ve);
      }
      return Qe.reverse();
    }
    return function(zt, Ft, Ve, Je, Ke) {
      var Qe, bt, _t, $t, kt, xt, Nt, Rt, Ht = zt.indexOf("."), ar = ae, lr = se;
      for (Ht >= 0 && ($t = Xe, Xe = 0, zt = zt.replace(".", ""), Rt = new vt(Ft), xt = Rt.pow(zt.length - Ht), Xe = $t, Rt.c = qt(
        toFixedPoint(coeffToString(xt.c), xt.e, "0"),
        10,
        Ve,
        Ut
      ), Rt.e = Rt.c.length), Nt = qt(zt, Ft, Ve, Ke ? (Qe = wt, Ut) : (Qe = Ut, wt)), _t = $t = Nt.length; Nt[--$t] == 0; Nt.pop()) ;
      if (!Nt[0]) return Qe.charAt(0);
      if (Ht < 0 ? --_t : (xt.c = Nt, xt.e = _t, xt.s = Je, xt = z(xt, Rt, ar, lr, Ve), Nt = xt.c, kt = xt.r, _t = xt.e), bt = _t + ar + 1, Ht = Nt[bt], $t = Ve / 2, kt = kt || bt < 0 || Nt[bt + 1] != null, kt = lr < 4 ? (Ht != null || kt) && (lr == 0 || lr == (xt.s < 0 ? 3 : 2)) : Ht > $t || Ht == $t && (lr == 4 || kt || lr == 6 && Nt[bt - 1] & 1 || lr == (xt.s < 0 ? 8 : 7)), bt < 1 || !Nt[0])
        zt = kt ? toFixedPoint(Qe.charAt(1), -ar, Qe.charAt(0)) : Qe.charAt(0);
      else {
        if (Nt.length = bt, kt)
          for (--Ve; ++Nt[--bt] > Ve; )
            Nt[bt] = 0, bt || (++_t, Nt = [1].concat(Nt));
        for ($t = Nt.length; !Nt[--$t]; ) ;
        for (Ht = 0, zt = ""; Ht <= $t; zt += Qe.charAt(Nt[Ht++])) ;
        zt = toFixedPoint(zt, _t, Qe.charAt(0));
      }
      return zt;
    };
  }(), z = /* @__PURE__ */ function() {
    function Ut(Ft, Ve, Je) {
      var Ke, Qe, bt, _t, $t = 0, kt = Ft.length, xt = Ve % SQRT_BASE, Nt = Ve / SQRT_BASE | 0;
      for (Ft = Ft.slice(); kt--; )
        bt = Ft[kt] % SQRT_BASE, _t = Ft[kt] / SQRT_BASE | 0, Ke = Nt * bt + _t * xt, Qe = xt * bt + Ke % SQRT_BASE * SQRT_BASE + $t, $t = (Qe / Je | 0) + (Ke / SQRT_BASE | 0) + Nt * _t, Ft[kt] = Qe % Je;
      return $t && (Ft = [$t].concat(Ft)), Ft;
    }
    function qt(Ft, Ve, Je, Ke) {
      var Qe, bt;
      if (Je != Ke)
        bt = Je > Ke ? 1 : -1;
      else
        for (Qe = bt = 0; Qe < Je; Qe++)
          if (Ft[Qe] != Ve[Qe]) {
            bt = Ft[Qe] > Ve[Qe] ? 1 : -1;
            break;
          }
      return bt;
    }
    function zt(Ft, Ve, Je, Ke) {
      for (var Qe = 0; Je--; )
        Ft[Je] -= Qe, Qe = Ft[Je] < Ve[Je] ? 1 : 0, Ft[Je] = Qe * Ke + Ft[Je] - Ve[Je];
      for (; !Ft[0] && Ft.length > 1; Ft.splice(0, 1)) ;
    }
    return function(Ft, Ve, Je, Ke, Qe) {
      var bt, _t, $t, kt, xt, Nt, Rt, Ht, ar, lr, nr, Vt, Xt, sr, dr, er, Zt, pr = Ft.s == Ve.s ? 1 : -1, _r = Ft.c, Ar = Ve.c;
      if (!_r || !_r[0] || !Ar || !Ar[0])
        return new vt(
          // Return NaN if either NaN, or both Infinity or 0.
          !Ft.s || !Ve.s || (_r ? Ar && _r[0] == Ar[0] : !Ar) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            _r && _r[0] == 0 || !Ar ? pr * 0 : pr / 0
          )
        );
      for (Ht = new vt(pr), ar = Ht.c = [], _t = Ft.e - Ve.e, pr = Je + _t + 1, Qe || (Qe = BASE, _t = bitFloor(Ft.e / LOG_BASE) - bitFloor(Ve.e / LOG_BASE), pr = pr / LOG_BASE | 0), $t = 0; Ar[$t] == (_r[$t] || 0); $t++) ;
      if (Ar[$t] > (_r[$t] || 0) && _t--, pr < 0)
        ar.push(1), kt = !0;
      else {
        for (sr = _r.length, er = Ar.length, $t = 0, pr += 2, xt = mathfloor(Qe / (Ar[0] + 1)), xt > 1 && (Ar = Ut(Ar, xt, Qe), _r = Ut(_r, xt, Qe), er = Ar.length, sr = _r.length), Xt = er, lr = _r.slice(0, er), nr = lr.length; nr < er; lr[nr++] = 0) ;
        Zt = Ar.slice(), Zt = [0].concat(Zt), dr = Ar[0], Ar[1] >= Qe / 2 && dr++;
        do {
          if (xt = 0, bt = qt(Ar, lr, er, nr), bt < 0) {
            if (Vt = lr[0], er != nr && (Vt = Vt * Qe + (lr[1] || 0)), xt = mathfloor(Vt / dr), xt > 1)
              for (xt >= Qe && (xt = Qe - 1), Nt = Ut(Ar, xt, Qe), Rt = Nt.length, nr = lr.length; qt(Nt, lr, Rt, nr) == 1; )
                xt--, zt(Nt, er < Rt ? Zt : Ar, Rt, Qe), Rt = Nt.length, bt = 1;
            else
              xt == 0 && (bt = xt = 1), Nt = Ar.slice(), Rt = Nt.length;
            if (Rt < nr && (Nt = [0].concat(Nt)), zt(lr, Nt, nr, Qe), nr = lr.length, bt == -1)
              for (; qt(Ar, lr, er, nr) < 1; )
                xt++, zt(lr, er < nr ? Zt : Ar, nr, Qe), nr = lr.length;
          } else bt === 0 && (xt++, lr = [0]);
          ar[$t++] = xt, lr[0] ? lr[nr++] = _r[Xt] || 0 : (lr = [_r[Xt]], nr = 1);
        } while ((Xt++ < sr || lr[0] != null) && pr--);
        kt = lr[0] != null, ar[0] || ar.splice(0, 1);
      }
      if (Qe == BASE) {
        for ($t = 1, pr = ar[0]; pr >= 10; pr /= 10, $t++) ;
        Kt(Ht, Je + (Ht.e = $t + _t * LOG_BASE - 1) + 1, Ke, kt);
      } else
        Ht.e = _t, Ht.r = +kt;
      return Ht;
    };
  }();
  function Bt(Ut, qt, zt, Ft) {
    var Ve, Je, Ke, Qe, bt;
    if (zt == null ? zt = se : intCheck(zt, 0, 8), !Ut.c) return Ut.toString();
    if (Ve = Ut.c[0], Ke = Ut.e, qt == null)
      bt = coeffToString(Ut.c), bt = Ft == 1 || Ft == 2 && (Ke <= ve || Ke >= ge) ? toExponential(bt, Ke) : toFixedPoint(bt, Ke, "0");
    else if (Ut = Kt(new vt(Ut), qt, zt), Je = Ut.e, bt = coeffToString(Ut.c), Qe = bt.length, Ft == 1 || Ft == 2 && (qt <= Je || Je <= ve)) {
      for (; Qe < qt; bt += "0", Qe++) ;
      bt = toExponential(bt, Je);
    } else if (qt -= Ke, bt = toFixedPoint(bt, Je, "0"), Je + 1 > Qe) {
      if (--qt > 0) for (bt += "."; qt--; bt += "0") ;
    } else if (qt += Je - Qe, qt > 0)
      for (Je + 1 == Qe && (bt += "."); qt--; bt += "0") ;
    return Ut.s < 0 && Ve ? "-" + bt : bt;
  }
  function Ct(Ut, qt) {
    for (var zt, Ft, Ve = 1, Je = new vt(Ut[0]); Ve < Ut.length; Ve++)
      Ft = new vt(Ut[Ve]), (!Ft.s || (zt = compare(Je, Ft)) === qt || zt === 0 && Je.s === qt) && (Je = Ft);
    return Je;
  }
  function Wt(Ut, qt, zt) {
    for (var Ft = 1, Ve = qt.length; !qt[--Ve]; qt.pop()) ;
    for (Ve = qt[0]; Ve >= 10; Ve /= 10, Ft++) ;
    return (zt = Ft + zt * LOG_BASE - 1) > Ee ? Ut.c = Ut.e = null : zt < le ? Ut.c = [Ut.e = 0] : (Ut.e = zt, Ut.c = qt), Ut;
  }
  ne = /* @__PURE__ */ function() {
    var Ut = /^(-?)0([xbo])(?=\w[\w.]*$)/i, qt = /^([^.]+)\.$/, zt = /^\.([^.]+)$/, Ft = /^-?(Infinity|NaN)$/, Ve = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Je, Ke, Qe, bt) {
      var _t, $t = Qe ? Ke : Ke.replace(Ve, "");
      if (Ft.test($t))
        Je.s = isNaN($t) ? null : $t < 0 ? -1 : 1;
      else {
        if (!Qe && ($t = $t.replace(Ut, function(kt, xt, Nt) {
          return _t = (Nt = Nt.toLowerCase()) == "x" ? 16 : Nt == "b" ? 2 : 8, !bt || bt == _t ? xt : kt;
        }), bt && (_t = bt, $t = $t.replace(qt, "$1").replace(zt, "0.$1")), Ke != $t))
          return new vt($t, _t);
        if (vt.DEBUG)
          throw Error(bignumberError + "Not a" + (bt ? " base " + bt : "") + " number: " + Ke);
        Je.s = null;
      }
      Je.c = Je.e = null;
    };
  }();
  function Kt(Ut, qt, zt, Ft) {
    var Ve, Je, Ke, Qe, bt, _t, $t, kt = Ut.c, xt = POWS_TEN;
    if (kt) {
      e: {
        for (Ve = 1, Qe = kt[0]; Qe >= 10; Qe /= 10, Ve++) ;
        if (Je = qt - Ve, Je < 0)
          Je += LOG_BASE, Ke = qt, bt = kt[_t = 0], $t = mathfloor(bt / xt[Ve - Ke - 1] % 10);
        else if (_t = mathceil((Je + 1) / LOG_BASE), _t >= kt.length)
          if (Ft) {
            for (; kt.length <= _t; kt.push(0)) ;
            bt = $t = 0, Ve = 1, Je %= LOG_BASE, Ke = Je - LOG_BASE + 1;
          } else
            break e;
        else {
          for (bt = Qe = kt[_t], Ve = 1; Qe >= 10; Qe /= 10, Ve++) ;
          Je %= LOG_BASE, Ke = Je - LOG_BASE + Ve, $t = Ke < 0 ? 0 : mathfloor(bt / xt[Ve - Ke - 1] % 10);
        }
        if (Ft = Ft || qt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        kt[_t + 1] != null || (Ke < 0 ? bt : bt % xt[Ve - Ke - 1]), Ft = zt < 4 ? ($t || Ft) && (zt == 0 || zt == (Ut.s < 0 ? 3 : 2)) : $t > 5 || $t == 5 && (zt == 4 || Ft || zt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Je > 0 ? Ke > 0 ? bt / xt[Ve - Ke] : 0 : kt[_t - 1]) % 10 & 1 || zt == (Ut.s < 0 ? 8 : 7)), qt < 1 || !kt[0])
          return kt.length = 0, Ft ? (qt -= Ut.e + 1, kt[0] = xt[(LOG_BASE - qt % LOG_BASE) % LOG_BASE], Ut.e = -qt || 0) : kt[0] = Ut.e = 0, Ut;
        if (Je == 0 ? (kt.length = _t, Qe = 1, _t--) : (kt.length = _t + 1, Qe = xt[LOG_BASE - Je], kt[_t] = Ke > 0 ? mathfloor(bt / xt[Ve - Ke] % xt[Ke]) * Qe : 0), Ft)
          for (; ; )
            if (_t == 0) {
              for (Je = 1, Ke = kt[0]; Ke >= 10; Ke /= 10, Je++) ;
              for (Ke = kt[0] += Qe, Qe = 1; Ke >= 10; Ke /= 10, Qe++) ;
              Je != Qe && (Ut.e++, kt[0] == BASE && (kt[0] = 1));
              break;
            } else {
              if (kt[_t] += Qe, kt[_t] != BASE) break;
              kt[_t--] = 0, Qe = 1;
            }
        for (Je = kt.length; kt[--Je] === 0; kt.pop()) ;
      }
      Ut.e > Ee ? Ut.c = Ut.e = null : Ut.e < le && (Ut.c = [Ut.e = 0]);
    }
    return Ut;
  }
  function Yt(Ut) {
    var qt, zt = Ut.e;
    return zt === null ? Ut.toString() : (qt = coeffToString(Ut.c), qt = zt <= ve || zt >= ge ? toExponential(qt, zt) : toFixedPoint(qt, zt, "0"), Ut.s < 0 ? "-" + qt : qt);
  }
  return oe.absoluteValue = oe.abs = function() {
    var Ut = new vt(this);
    return Ut.s < 0 && (Ut.s = 1), Ut;
  }, oe.comparedTo = function(Ut, qt) {
    return compare(this, new vt(Ut, qt));
  }, oe.decimalPlaces = oe.dp = function(Ut, qt) {
    var zt, Ft, Ve, Je = this;
    if (Ut != null)
      return intCheck(Ut, 0, MAX), qt == null ? qt = se : intCheck(qt, 0, 8), Kt(new vt(Je), Ut + Je.e + 1, qt);
    if (!(zt = Je.c)) return null;
    if (Ft = ((Ve = zt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, Ve = zt[Ve]) for (; Ve % 10 == 0; Ve /= 10, Ft--) ;
    return Ft < 0 && (Ft = 0), Ft;
  }, oe.dividedBy = oe.div = function(Ut, qt) {
    return z(this, new vt(Ut, qt), ae, se);
  }, oe.dividedToIntegerBy = oe.idiv = function(Ut, qt) {
    return z(this, new vt(Ut, qt), 0, 1);
  }, oe.exponentiatedBy = oe.pow = function(Ut, qt) {
    var zt, Ft, Ve, Je, Ke, Qe, bt, _t, $t, kt = this;
    if (Ut = new vt(Ut), Ut.c && !Ut.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Yt(Ut));
    if (qt != null && (qt = new vt(qt)), Qe = Ut.e > 14, !kt.c || !kt.c[0] || kt.c[0] == 1 && !kt.e && kt.c.length == 1 || !Ut.c || !Ut.c[0])
      return $t = new vt(Math.pow(+Yt(kt), Qe ? Ut.s * (2 - isOdd(Ut)) : +Yt(Ut))), qt ? $t.mod(qt) : $t;
    if (bt = Ut.s < 0, qt) {
      if (qt.c ? !qt.c[0] : !qt.s) return new vt(NaN);
      Ft = !bt && kt.isInteger() && qt.isInteger(), Ft && (kt = kt.mod(qt));
    } else {
      if (Ut.e > 9 && (kt.e > 0 || kt.e < -1 || (kt.e == 0 ? kt.c[0] > 1 || Qe && kt.c[1] >= 24e7 : kt.c[0] < 8e13 || Qe && kt.c[0] <= 9999975e7)))
        return Je = kt.s < 0 && isOdd(Ut) ? -0 : 0, kt.e > -1 && (Je = 1 / Je), new vt(bt ? 1 / Je : Je);
      Xe && (Je = mathceil(Xe / LOG_BASE + 2));
    }
    for (Qe ? (zt = new vt(0.5), bt && (Ut.s = 1), _t = isOdd(Ut)) : (Ve = Math.abs(+Yt(Ut)), _t = Ve % 2), $t = new vt(ie); ; ) {
      if (_t) {
        if ($t = $t.times(kt), !$t.c) break;
        Je ? $t.c.length > Je && ($t.c.length = Je) : Ft && ($t = $t.mod(qt));
      }
      if (Ve) {
        if (Ve = mathfloor(Ve / 2), Ve === 0) break;
        _t = Ve % 2;
      } else if (Ut = Ut.times(zt), Kt(Ut, Ut.e + 1, 1), Ut.e > 14)
        _t = isOdd(Ut);
      else {
        if (Ve = +Yt(Ut), Ve === 0) break;
        _t = Ve % 2;
      }
      kt = kt.times(kt), Je ? kt.c && kt.c.length > Je && (kt.c.length = Je) : Ft && (kt = kt.mod(qt));
    }
    return Ft ? $t : (bt && ($t = ie.div($t)), qt ? $t.mod(qt) : Je ? Kt($t, Xe, se, Ke) : $t);
  }, oe.integerValue = function(Ut) {
    var qt = new vt(this);
    return Ut == null ? Ut = se : intCheck(Ut, 0, 8), Kt(qt, qt.e + 1, Ut);
  }, oe.isEqualTo = oe.eq = function(Ut, qt) {
    return compare(this, new vt(Ut, qt)) === 0;
  }, oe.isFinite = function() {
    return !!this.c;
  }, oe.isGreaterThan = oe.gt = function(Ut, qt) {
    return compare(this, new vt(Ut, qt)) > 0;
  }, oe.isGreaterThanOrEqualTo = oe.gte = function(Ut, qt) {
    return (qt = compare(this, new vt(Ut, qt))) === 1 || qt === 0;
  }, oe.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, oe.isLessThan = oe.lt = function(Ut, qt) {
    return compare(this, new vt(Ut, qt)) < 0;
  }, oe.isLessThanOrEqualTo = oe.lte = function(Ut, qt) {
    return (qt = compare(this, new vt(Ut, qt))) === -1 || qt === 0;
  }, oe.isNaN = function() {
    return !this.s;
  }, oe.isNegative = function() {
    return this.s < 0;
  }, oe.isPositive = function() {
    return this.s > 0;
  }, oe.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, oe.minus = function(Ut, qt) {
    var zt, Ft, Ve, Je, Ke = this, Qe = Ke.s;
    if (Ut = new vt(Ut, qt), qt = Ut.s, !Qe || !qt) return new vt(NaN);
    if (Qe != qt)
      return Ut.s = -qt, Ke.plus(Ut);
    var bt = Ke.e / LOG_BASE, _t = Ut.e / LOG_BASE, $t = Ke.c, kt = Ut.c;
    if (!bt || !_t) {
      if (!$t || !kt) return $t ? (Ut.s = -qt, Ut) : new vt(kt ? Ke : NaN);
      if (!$t[0] || !kt[0])
        return kt[0] ? (Ut.s = -qt, Ut) : new vt($t[0] ? Ke : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          se == 3 ? -0 : 0
        ));
    }
    if (bt = bitFloor(bt), _t = bitFloor(_t), $t = $t.slice(), Qe = bt - _t) {
      for ((Je = Qe < 0) ? (Qe = -Qe, Ve = $t) : (_t = bt, Ve = kt), Ve.reverse(), qt = Qe; qt--; Ve.push(0)) ;
      Ve.reverse();
    } else
      for (Ft = (Je = (Qe = $t.length) < (qt = kt.length)) ? Qe : qt, Qe = qt = 0; qt < Ft; qt++)
        if ($t[qt] != kt[qt]) {
          Je = $t[qt] < kt[qt];
          break;
        }
    if (Je && (Ve = $t, $t = kt, kt = Ve, Ut.s = -Ut.s), qt = (Ft = kt.length) - (zt = $t.length), qt > 0) for (; qt--; $t[zt++] = 0) ;
    for (qt = BASE - 1; Ft > Qe; ) {
      if ($t[--Ft] < kt[Ft]) {
        for (zt = Ft; zt && !$t[--zt]; $t[zt] = qt) ;
        --$t[zt], $t[Ft] += BASE;
      }
      $t[Ft] -= kt[Ft];
    }
    for (; $t[0] == 0; $t.splice(0, 1), --_t) ;
    return $t[0] ? Wt(Ut, $t, _t) : (Ut.s = se == 3 ? -1 : 1, Ut.c = [Ut.e = 0], Ut);
  }, oe.modulo = oe.mod = function(Ut, qt) {
    var zt, Ft, Ve = this;
    return Ut = new vt(Ut, qt), !Ve.c || !Ut.s || Ut.c && !Ut.c[0] ? new vt(NaN) : !Ut.c || Ve.c && !Ve.c[0] ? new vt(Ve) : (Pe == 9 ? (Ft = Ut.s, Ut.s = 1, zt = z(Ve, Ut, 0, 3), Ut.s = Ft, zt.s *= Ft) : zt = z(Ve, Ut, 0, Pe), Ut = Ve.minus(zt.times(Ut)), !Ut.c[0] && Pe == 1 && (Ut.s = Ve.s), Ut);
  }, oe.multipliedBy = oe.times = function(Ut, qt) {
    var zt, Ft, Ve, Je, Ke, Qe, bt, _t, $t, kt, xt, Nt, Rt, Ht, ar, lr = this, nr = lr.c, Vt = (Ut = new vt(Ut, qt)).c;
    if (!nr || !Vt || !nr[0] || !Vt[0])
      return !lr.s || !Ut.s || nr && !nr[0] && !Vt || Vt && !Vt[0] && !nr ? Ut.c = Ut.e = Ut.s = null : (Ut.s *= lr.s, !nr || !Vt ? Ut.c = Ut.e = null : (Ut.c = [0], Ut.e = 0)), Ut;
    for (Ft = bitFloor(lr.e / LOG_BASE) + bitFloor(Ut.e / LOG_BASE), Ut.s *= lr.s, bt = nr.length, kt = Vt.length, bt < kt && (Rt = nr, nr = Vt, Vt = Rt, Ve = bt, bt = kt, kt = Ve), Ve = bt + kt, Rt = []; Ve--; Rt.push(0)) ;
    for (Ht = BASE, ar = SQRT_BASE, Ve = kt; --Ve >= 0; ) {
      for (zt = 0, xt = Vt[Ve] % ar, Nt = Vt[Ve] / ar | 0, Ke = bt, Je = Ve + Ke; Je > Ve; )
        _t = nr[--Ke] % ar, $t = nr[Ke] / ar | 0, Qe = Nt * _t + $t * xt, _t = xt * _t + Qe % ar * ar + Rt[Je] + zt, zt = (_t / Ht | 0) + (Qe / ar | 0) + Nt * $t, Rt[Je--] = _t % Ht;
      Rt[Je] = zt;
    }
    return zt ? ++Ft : Rt.splice(0, 1), Wt(Ut, Rt, Ft);
  }, oe.negated = function() {
    var Ut = new vt(this);
    return Ut.s = -Ut.s || null, Ut;
  }, oe.plus = function(Ut, qt) {
    var zt, Ft = this, Ve = Ft.s;
    if (Ut = new vt(Ut, qt), qt = Ut.s, !Ve || !qt) return new vt(NaN);
    if (Ve != qt)
      return Ut.s = -qt, Ft.minus(Ut);
    var Je = Ft.e / LOG_BASE, Ke = Ut.e / LOG_BASE, Qe = Ft.c, bt = Ut.c;
    if (!Je || !Ke) {
      if (!Qe || !bt) return new vt(Ve / 0);
      if (!Qe[0] || !bt[0]) return bt[0] ? Ut : new vt(Qe[0] ? Ft : Ve * 0);
    }
    if (Je = bitFloor(Je), Ke = bitFloor(Ke), Qe = Qe.slice(), Ve = Je - Ke) {
      for (Ve > 0 ? (Ke = Je, zt = bt) : (Ve = -Ve, zt = Qe), zt.reverse(); Ve--; zt.push(0)) ;
      zt.reverse();
    }
    for (Ve = Qe.length, qt = bt.length, Ve - qt < 0 && (zt = bt, bt = Qe, Qe = zt, qt = Ve), Ve = 0; qt; )
      Ve = (Qe[--qt] = Qe[qt] + bt[qt] + Ve) / BASE | 0, Qe[qt] = BASE === Qe[qt] ? 0 : Qe[qt] % BASE;
    return Ve && (Qe = [Ve].concat(Qe), ++Ke), Wt(Ut, Qe, Ke);
  }, oe.precision = oe.sd = function(Ut, qt) {
    var zt, Ft, Ve, Je = this;
    if (Ut != null && Ut !== !!Ut)
      return intCheck(Ut, 1, MAX), qt == null ? qt = se : intCheck(qt, 0, 8), Kt(new vt(Je), Ut, qt);
    if (!(zt = Je.c)) return null;
    if (Ve = zt.length - 1, Ft = Ve * LOG_BASE + 1, Ve = zt[Ve]) {
      for (; Ve % 10 == 0; Ve /= 10, Ft--) ;
      for (Ve = zt[0]; Ve >= 10; Ve /= 10, Ft++) ;
    }
    return Ut && Je.e + 1 > Ft && (Ft = Je.e + 1), Ft;
  }, oe.shiftedBy = function(Ut) {
    return intCheck(Ut, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + Ut);
  }, oe.squareRoot = oe.sqrt = function() {
    var Ut, qt, zt, Ft, Ve, Je = this, Ke = Je.c, Qe = Je.s, bt = Je.e, _t = ae + 4, $t = new vt("0.5");
    if (Qe !== 1 || !Ke || !Ke[0])
      return new vt(!Qe || Qe < 0 && (!Ke || Ke[0]) ? NaN : Ke ? Je : 1 / 0);
    if (Qe = Math.sqrt(+Yt(Je)), Qe == 0 || Qe == 1 / 0 ? (qt = coeffToString(Ke), (qt.length + bt) % 2 == 0 && (qt += "0"), Qe = Math.sqrt(+qt), bt = bitFloor((bt + 1) / 2) - (bt < 0 || bt % 2), Qe == 1 / 0 ? qt = "5e" + bt : (qt = Qe.toExponential(), qt = qt.slice(0, qt.indexOf("e") + 1) + bt), zt = new vt(qt)) : zt = new vt(Qe + ""), zt.c[0]) {
      for (bt = zt.e, Qe = bt + _t, Qe < 3 && (Qe = 0); ; )
        if (Ve = zt, zt = $t.times(Ve.plus(z(Je, Ve, _t, 1))), coeffToString(Ve.c).slice(0, Qe) === (qt = coeffToString(zt.c)).slice(0, Qe))
          if (zt.e < bt && --Qe, qt = qt.slice(Qe - 3, Qe + 1), qt == "9999" || !Ft && qt == "4999") {
            if (!Ft && (Kt(Ve, Ve.e + ae + 2, 0), Ve.times(Ve).eq(Je))) {
              zt = Ve;
              break;
            }
            _t += 4, Qe += 4, Ft = 1;
          } else {
            (!+qt || !+qt.slice(1) && qt.charAt(0) == "5") && (Kt(zt, zt.e + ae + 2, 1), Ut = !zt.times(zt).eq(Je));
            break;
          }
    }
    return Kt(zt, zt.e + ae + 1, se, Ut);
  }, oe.toExponential = function(Ut, qt) {
    return Ut != null && (intCheck(Ut, 0, MAX), Ut++), Bt(this, Ut, qt, 1);
  }, oe.toFixed = function(Ut, qt) {
    return Ut != null && (intCheck(Ut, 0, MAX), Ut = Ut + this.e + 1), Bt(this, Ut, qt);
  }, oe.toFormat = function(Ut, qt, zt) {
    var Ft, Ve = this;
    if (zt == null)
      Ut != null && qt && typeof qt == "object" ? (zt = qt, qt = null) : Ut && typeof Ut == "object" ? (zt = Ut, Ut = qt = null) : zt = ht;
    else if (typeof zt != "object")
      throw Error(bignumberError + "Argument not an object: " + zt);
    if (Ft = Ve.toFixed(Ut, qt), Ve.c) {
      var Je, Ke = Ft.split("."), Qe = +zt.groupSize, bt = +zt.secondaryGroupSize, _t = zt.groupSeparator || "", $t = Ke[0], kt = Ke[1], xt = Ve.s < 0, Nt = xt ? $t.slice(1) : $t, Rt = Nt.length;
      if (bt && (Je = Qe, Qe = bt, bt = Je, Rt -= Je), Qe > 0 && Rt > 0) {
        for (Je = Rt % Qe || Qe, $t = Nt.substr(0, Je); Je < Rt; Je += Qe) $t += _t + Nt.substr(Je, Qe);
        bt > 0 && ($t += _t + Nt.slice(Je)), xt && ($t = "-" + $t);
      }
      Ft = kt ? $t + (zt.decimalSeparator || "") + ((bt = +zt.fractionGroupSize) ? kt.replace(
        new RegExp("\\d{" + bt + "}\\B", "g"),
        "$&" + (zt.fractionGroupSeparator || "")
      ) : kt) : $t;
    }
    return (zt.prefix || "") + Ft + (zt.suffix || "");
  }, oe.toFraction = function(Ut) {
    var qt, zt, Ft, Ve, Je, Ke, Qe, bt, _t, $t, kt, xt, Nt = this, Rt = Nt.c;
    if (Ut != null && (Qe = new vt(Ut), !Qe.isInteger() && (Qe.c || Qe.s !== 1) || Qe.lt(ie)))
      throw Error(bignumberError + "Argument " + (Qe.isInteger() ? "out of range: " : "not an integer: ") + Yt(Qe));
    if (!Rt) return new vt(Nt);
    for (qt = new vt(ie), _t = zt = new vt(ie), Ft = bt = new vt(ie), xt = coeffToString(Rt), Je = qt.e = xt.length - Nt.e - 1, qt.c[0] = POWS_TEN[(Ke = Je % LOG_BASE) < 0 ? LOG_BASE + Ke : Ke], Ut = !Ut || Qe.comparedTo(qt) > 0 ? Je > 0 ? qt : _t : Qe, Ke = Ee, Ee = 1 / 0, Qe = new vt(xt), bt.c[0] = 0; $t = z(Qe, qt, 0, 1), Ve = zt.plus($t.times(Ft)), Ve.comparedTo(Ut) != 1; )
      zt = Ft, Ft = Ve, _t = bt.plus($t.times(Ve = _t)), bt = Ve, qt = Qe.minus($t.times(Ve = qt)), Qe = Ve;
    return Ve = z(Ut.minus(zt), Ft, 0, 1), bt = bt.plus(Ve.times(_t)), zt = zt.plus(Ve.times(Ft)), bt.s = _t.s = Nt.s, Je = Je * 2, kt = z(_t, Ft, Je, se).minus(Nt).abs().comparedTo(
      z(bt, zt, Je, se).minus(Nt).abs()
    ) < 1 ? [_t, Ft] : [bt, zt], Ee = Ke, kt;
  }, oe.toNumber = function() {
    return +Yt(this);
  }, oe.toPrecision = function(Ut, qt) {
    return Ut != null && intCheck(Ut, 1, MAX), Bt(this, Ut, qt, 2);
  }, oe.toString = function(Ut) {
    var qt, zt = this, Ft = zt.s, Ve = zt.e;
    return Ve === null ? Ft ? (qt = "Infinity", Ft < 0 && (qt = "-" + qt)) : qt = "NaN" : (Ut == null ? qt = Ve <= ve || Ve >= ge ? toExponential(coeffToString(zt.c), Ve) : toFixedPoint(coeffToString(zt.c), Ve, "0") : Ut === 10 && Pt ? (zt = Kt(new vt(zt), ae + Ve + 1, se), qt = toFixedPoint(coeffToString(zt.c), zt.e, "0")) : (intCheck(Ut, 2, wt.length, "Base"), qt = Y(toFixedPoint(coeffToString(zt.c), Ve, "0"), 10, Ut, Ft, !0)), Ft < 0 && zt.c[0] && (qt = "-" + qt)), qt;
  }, oe.valueOf = oe.toJSON = function() {
    return Yt(this);
  }, oe._isBigNumber = !0, oe[Symbol.toStringTag] = "BigNumber", oe[Symbol.for("nodejs.util.inspect.custom")] = oe.valueOf, B != null && vt.set(B), vt;
}
function bitFloor(B) {
  var z = B | 0;
  return B > 0 || B === z ? z : z - 1;
}
function coeffToString(B) {
  for (var z, Y, ne = 1, oe = B.length, ie = B[0] + ""; ne < oe; ) {
    for (z = B[ne++] + "", Y = LOG_BASE - z.length; Y--; z = "0" + z) ;
    ie += z;
  }
  for (oe = ie.length; ie.charCodeAt(--oe) === 48; ) ;
  return ie.slice(0, oe + 1 || 1);
}
function compare(B, z) {
  var Y, ne, oe = B.c, ie = z.c, ae = B.s, se = z.s, ve = B.e, ge = z.e;
  if (!ae || !se) return null;
  if (Y = oe && !oe[0], ne = ie && !ie[0], Y || ne) return Y ? ne ? 0 : -se : ae;
  if (ae != se) return ae;
  if (Y = ae < 0, ne = ve == ge, !oe || !ie) return ne ? 0 : !oe ^ Y ? 1 : -1;
  if (!ne) return ve > ge ^ Y ? 1 : -1;
  for (se = (ve = oe.length) < (ge = ie.length) ? ve : ge, ae = 0; ae < se; ae++) if (oe[ae] != ie[ae]) return oe[ae] > ie[ae] ^ Y ? 1 : -1;
  return ve == ge ? 0 : ve > ge ^ Y ? 1 : -1;
}
function intCheck(B, z, Y, ne) {
  if (B < z || B > Y || B !== mathfloor(B))
    throw Error(bignumberError + (ne || "Argument") + (typeof B == "number" ? B < z || B > Y ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var z = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == z && B.c[z] % 2 != 0;
}
function toExponential(B, z) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (z < 0 ? "e" : "e+") + z;
}
function toFixedPoint(B, z, Y) {
  var ne, oe;
  if (z < 0) {
    for (oe = Y + "."; ++z; oe += Y) ;
    B = oe + B;
  } else if (ne = B.length, ++z > ne) {
    for (oe = Y, z -= ne; --z; oe += Y) ;
    B += oe;
  } else z < ne && (B = B.slice(0, z) + "." + B.slice(z));
  return B;
}
var BigNumber = clone();
function useBalance() {
  const { network: B, publicKey: z, format: Y, chain: ne } = useOrdConnect(), [oe, ie] = useState(null), [ae, se] = useState(!1);
  return { getBalance: useCallback(async () => {
    se(!0);
    try {
      if (ie(null), !Y || !Y.payments || !z || !z.payments)
        throw new Error("No wallet is connected");
      const { address: ge } = getAddressesFromPublicKey(
        z.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[Y.payments],
        ne
      )[0], Ee = await new JsonRpcDatasource({
        chain: ne,
        network: B
      }).getBalance({ address: ge }), Ce = Number(
        new BigNumber(Ee).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return se(!1), Ce;
    } catch (ge) {
      throw ie(ge.message), se(!1), ge;
    }
  }, [Y, B, z]), error: oe, loading: ae };
}
async function signPsbt({
  address: B,
  wallet: z,
  network: Y,
  psbt: ne,
  options: oe
}) {
  var ve, ge;
  if ((ve = oe == null ? void 0 : oe.signingIndexes) != null && ve.length && ((ge = oe == null ? void 0 : oe.inputsToSign) != null && ge.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const ie = (oe == null ? void 0 : oe.finalize) ?? !0, ae = (oe == null ? void 0 : oe.extractTx) ?? !0, se = () => ne.data.inputs.map((le, Ee) => Ee);
  if (z === Wallet.MAGICEDEN)
    return await signPsbt$1(ne, {
      network: Y,
      inputsToSign: (oe == null ? void 0 : oe.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? se(),
          sigHash: oe == null ? void 0 : oe.sigHash
        }
      ],
      finalize: ie,
      extractTx: ae
    });
  if (z === Wallet.UNISAT)
    return await signPsbt$2(ne, {
      finalize: ie,
      extractTx: ae
    });
  if (z === Wallet.XVERSE)
    return await signPsbt$3(ne, {
      network: Y,
      inputsToSign: (oe == null ? void 0 : oe.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? se(),
          // If signingIndexes is not provided, just sign everything
          sigHash: oe == null ? void 0 : oe.sigHash
        }
      ],
      finalize: ie,
      extractTx: ae
    });
  if (z === Wallet.LEATHER)
    return await signPsbt$4(ne, {
      network: Y,
      finalize: ie,
      extractTx: ae,
      allowedSighash: oe != null && oe.sigHash ? [oe == null ? void 0 : oe.sigHash] : [],
      signAtIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? se()
      // If signingIndexes is not provided, just sign everything
    });
  if (z === Wallet.OKX)
    return await signPsbt$5(ne, {
      finalize: ie,
      extractTx: ae,
      network: Y,
      inputsToSign: (oe == null ? void 0 : oe.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (oe == null ? void 0 : oe.signingIndexes) ?? se(),
          // If signingIndexes is not provided, just sign everything
          sigHash: oe == null ? void 0 : oe.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: oe } = useOrdConnect(), [ie, ae] = useState(null), [se, ve] = useState(!1);
  return { send: useCallback(
    async (le, Ee, Ce, Pe = !0) => {
      ve(!0);
      try {
        if (ae(null), !Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Xe = new PSBTBuilder({
          address: Y.payments,
          feeRate: Ce,
          network: z,
          chain: oe,
          publicKey: ne.payments,
          outputs: [
            {
              address: le,
              value: Ee
            }
          ]
        });
        await Xe.prepare();
        const ht = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Xe.toPSBT()
        });
        if (Pe) {
          const Pt = await new JsonRpcDatasource({ network: z, chain: oe }).relay({ hex: ht.hex });
          return ve(!1), Pt;
        }
        return ve(!1), ht.hex;
      } catch (Xe) {
        return ae(Xe.message), ve(!1), null;
      }
    },
    [Y, z, ne, B]
  ), error: ie, loading: se };
}
function useSendV2() {
  const { wallet: B, network: z, address: Y, publicKey: ne, chain: oe } = useOrdConnect(), [ie, ae] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ve,
      satoshis: ge,
      feeRate: le,
      relay: Ee = !0,
      rbf: Ce = !1
    }) => {
      ae(!0);
      try {
        if (!Y || !Y.payments || !ne || !ne.payments || !B)
          throw new Error("No wallet is connected");
        const Pe = new PSBTBuilder({
          address: Y.payments,
          feeRate: le,
          network: z,
          chain: oe,
          publicKey: ne.payments,
          outputs: [
            {
              address: ve,
              value: ge
            }
          ]
        });
        Pe.setRBF(Ce), await Pe.prepare();
        const Xe = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Pe.toPSBT()
        });
        if (Ee) {
          const wt = await new JsonRpcDatasource({ network: z, chain: oe }).relay({ hex: Xe.hex });
          return ae(!1), {
            txId: wt
          };
        }
        return ae(!1), {
          signedPsbtHex: Xe.hex
        };
      } catch (Pe) {
        return ae(!1), {
          error: Pe.message
        };
      }
    },
    [Y, z, ne, B]
  ), isLoading: ie };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const z = B[3];
  if (z === 0 || 5 + z >= B.length || B[4 + z] !== 2) return !1;
  const Y = B[5 + z];
  return !(Y === 0 || 6 + z + Y !== B.length || B[4] & 128 || z > 1 && B[4] === 0 && !(B[5] & 128) || B[z + 6] & 128 || Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128));
}
bip66.check = check$d;
function decode$h(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const z = B[3];
  if (z === 0) throw new Error("R length is zero");
  if (5 + z >= B.length) throw new Error("R length is too long");
  if (B[4 + z] !== 2) throw new Error("Expected DER integer (2)");
  const Y = B[5 + z];
  if (Y === 0) throw new Error("S length is zero");
  if (6 + z + Y !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (z > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[z + 6] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + z),
    s: B.slice(6 + z)
  };
}
bip66.decode = decode$h;
function encode$i(B, z) {
  const Y = B.length, ne = z.length;
  if (Y === 0) throw new Error("R length is zero");
  if (ne === 0) throw new Error("S length is zero");
  if (Y > 33) throw new Error("R length is too long");
  if (ne > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (z[0] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (ne > 1 && z[0] === 0 && !(z[1] & 128))
    throw new Error("S value excessively padded");
  const oe = Buffer$1.allocUnsafe(6 + Y + ne);
  return oe[0] = 48, oe[1] = oe.length - 2, oe[2] = 2, oe[3] = B.length, B.copy(oe, 4), oe[4 + Y] = 2, oe[5 + Y] = z.length, z.copy(oe, 6 + Y), oe;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const z = OPS$7[B];
  REVERSE_OPS[z] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(B, z, Y) {
  const ne = encodingLength$2(z);
  return ne === 1 ? B.writeUInt8(z, Y) : ne === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, Y), B.writeUInt8(z, Y + 1)) : ne === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, Y), B.writeUInt16LE(z, Y + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, Y), B.writeUInt32LE(z, Y + 1)), ne;
}
push_data.encode = encode$h;
function decode$g(B, z) {
  const Y = B.readUInt8(z);
  let ne, oe;
  if (Y < ops_1.OPS.OP_PUSHDATA1)
    ne = Y, oe = 1;
  else if (Y === ops_1.OPS.OP_PUSHDATA1) {
    if (z + 2 > B.length) return null;
    ne = B.readUInt8(z + 1), oe = 2;
  } else if (Y === ops_1.OPS.OP_PUSHDATA2) {
    if (z + 3 > B.length) return null;
    ne = B.readUInt16LE(z + 1), oe = 3;
  } else {
    if (z + 5 > B.length) return null;
    if (Y !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    ne = B.readUInt32LE(z + 1), oe = 5;
  }
  return {
    opcode: Y,
    number: ne,
    size: oe
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(B, z, Y) {
  z = z || 4, Y = Y === void 0 ? !0 : Y;
  const ne = B.length;
  if (ne === 0) return 0;
  if (ne > z) throw new TypeError("Script number overflow");
  if (Y && !(B[ne - 1] & 127) && (ne <= 1 || !(B[ne - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (ne === 5) {
    const ie = B.readUInt32LE(0), ae = B.readUInt8(4);
    return ae & 128 ? -((ae & -129) * 4294967296 + ie) : ae * 4294967296 + ie;
  }
  let oe = 0;
  for (let ie = 0; ie < ne; ++ie)
    oe |= B[ie] << 8 * ie;
  return B[ne - 1] & 128 ? -(oe & ~(128 << 8 * (ne - 1))) : oe;
}
script_number.decode = decode$f;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$g(B) {
  let z = Math.abs(B);
  const Y = scriptNumSize(z), ne = Buffer$1.allocUnsafe(Y), oe = B < 0;
  for (let ie = 0; ie < Y; ++ie)
    ne.writeUInt8(z & 255, ie), z >>= 8;
  return ne[Y - 1] & 128 ? ne.writeUInt8(oe ? 128 : 0, Y - 1) : oe && (ne[Y - 1] |= 128), ne;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, z) {
  Error.captureStackTrace && Error.captureStackTrace(B, z);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, z, Y) {
  var ne = getValue(z);
  return "Expected " + tfJSON$1(B) + ", got" + (Y !== "" ? " " + Y : "") + (ne !== "" ? " " + ne : "");
}
function TfTypeError$1(B, z, Y) {
  Y = Y || getValueTypeName$1(z), this.message = tfErrorString(B, z, Y), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = z, this.__valueTypeName = Y;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, z, Y, ne, oe) {
  var ie = '" of type ';
  return z === "key" && (ie = '" with key type '), tfErrorString('property "' + tfJSON$1(Y) + ie + tfJSON$1(B), ne, oe);
}
function TfPropertyTypeError$1(B, z, Y, ne, oe) {
  B ? (oe = oe || getValueTypeName$1(ne), this.message = tfPropertyErrorString(B, Y, z, ne, oe)) : this.message = 'Unexpected property "' + z + '"', captureStackTrace(this, TfTypeError$1), this.__label = Y, this.__property = z, this.__type = B, this.__value = ne, this.__valueTypeName = oe;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, z) {
  return new TfTypeError$1(B, {}, z);
}
function tfSubError$1(B, z, Y) {
  return B instanceof TfPropertyTypeError$1 ? (z = z + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    z,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    z,
    Y,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, z = errors;
  function Y(Kt) {
    return Buffer$1.isBuffer(Kt);
  }
  function ne(Kt) {
    return typeof Kt == "string" && /^([0-9a-f]{2})+$/i.test(Kt);
  }
  function oe(Kt, Yt) {
    var Ut = Kt.toJSON();
    function qt(zt) {
      if (!Kt(zt)) return !1;
      if (zt.length === Yt) return !0;
      throw z.tfCustomError(Ut + "(Length: " + Yt + ")", Ut + "(Length: " + zt.length + ")");
    }
    return qt.toJSON = function() {
      return Ut;
    }, qt;
  }
  var ie = oe.bind(null, B.Array), ae = oe.bind(null, Y), se = oe.bind(null, ne), ve = oe.bind(null, B.String);
  function ge(Kt, Yt, Ut) {
    Ut = Ut || B.Number;
    function qt(zt, Ft) {
      return Ut(zt, Ft) && zt > Kt && zt < Yt;
    }
    return qt.toJSON = function() {
      return `${Ut.toJSON()} between [${Kt}, ${Yt}]`;
    }, qt;
  }
  var le = Math.pow(2, 53) - 1;
  function Ee(Kt) {
    return typeof Kt == "number" && isFinite(Kt);
  }
  function Ce(Kt) {
    return Kt << 24 >> 24 === Kt;
  }
  function Pe(Kt) {
    return Kt << 16 >> 16 === Kt;
  }
  function Xe(Kt) {
    return (Kt | 0) === Kt;
  }
  function ht(Kt) {
    return typeof Kt == "number" && Kt >= -le && Kt <= le && Math.floor(Kt) === Kt;
  }
  function wt(Kt) {
    return (Kt & 255) === Kt;
  }
  function Pt(Kt) {
    return (Kt & 65535) === Kt;
  }
  function vt(Kt) {
    return Kt >>> 0 === Kt;
  }
  function Bt(Kt) {
    return typeof Kt == "number" && Kt >= 0 && Kt <= le && Math.floor(Kt) === Kt;
  }
  var Ct = {
    ArrayN: ie,
    Buffer: Y,
    BufferN: ae,
    Finite: Ee,
    Hex: ne,
    HexN: se,
    Int8: Ce,
    Int16: Pe,
    Int32: Xe,
    Int53: ht,
    Range: ge,
    StringN: ve,
    UInt8: wt,
    UInt16: Pt,
    UInt32: vt,
    UInt53: Bt
  };
  for (var Wt in Ct)
    Ct[Wt].toJSON = (function(Kt) {
      return Kt;
    }).bind(null, Wt);
  return extra = Ct, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function B(z, Y) {
    z = compile(z), Y = Y || {};
    function ne(oe, ie) {
      return !NATIVE.Array(oe) || NATIVE.Nil(oe) || Y.minLength !== void 0 && oe.length < Y.minLength || Y.maxLength !== void 0 && oe.length > Y.maxLength || Y.length !== void 0 && oe.length !== Y.length ? !1 : oe.every(function(ae, se) {
        try {
          return typeforce$3(z, ae, ie);
        } catch (ve) {
          throw tfSubError(ve, se);
        }
      });
    }
    return ne.toJSON = function() {
      var oe = "[" + tfJSON(z) + "]";
      return Y.length !== void 0 ? oe += "{" + Y.length + "}" : (Y.minLength !== void 0 || Y.maxLength !== void 0) && (oe += "{" + (Y.minLength === void 0 ? 0 : Y.minLength) + "," + (Y.maxLength === void 0 ? 1 / 0 : Y.maxLength) + "}"), oe;
    }, ne;
  },
  maybe: function B(z) {
    z = compile(z);
    function Y(ne, oe) {
      return NATIVE.Nil(ne) || z(ne, oe, B);
    }
    return Y.toJSON = function() {
      return "?" + tfJSON(z);
    }, Y;
  },
  map: function B(z, Y) {
    z = compile(z), Y && (Y = compile(Y));
    function ne(oe, ie) {
      if (!NATIVE.Object(oe) || NATIVE.Nil(oe)) return !1;
      for (var ae in oe) {
        try {
          Y && typeforce$3(Y, ae, ie);
        } catch (ve) {
          throw tfSubError(ve, ae, "key");
        }
        try {
          var se = oe[ae];
          typeforce$3(z, se, ie);
        } catch (ve) {
          throw tfSubError(ve, ae);
        }
      }
      return !0;
    }
    return Y ? ne.toJSON = function() {
      return "{" + tfJSON(Y) + ": " + tfJSON(z) + "}";
    } : ne.toJSON = function() {
      return "{" + tfJSON(z) + "}";
    }, ne;
  },
  object: function B(z) {
    var Y = {};
    for (var ne in z)
      Y[ne] = compile(z[ne]);
    function oe(ie, ae) {
      if (!NATIVE.Object(ie) || NATIVE.Nil(ie)) return !1;
      var se;
      try {
        for (se in Y) {
          var ve = Y[se], ge = ie[se];
          typeforce$3(ve, ge, ae);
        }
      } catch (le) {
        throw tfSubError(le, se);
      }
      if (ae) {
        for (se in ie)
          if (!Y[se])
            throw new TfPropertyTypeError(void 0, se);
      }
      return !0;
    }
    return oe.toJSON = function() {
      return tfJSON(Y);
    }, oe;
  },
  anyOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, oe) {
      return z.some(function(ie) {
        try {
          return typeforce$3(ie, ne, oe);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join("|");
    }, Y;
  },
  allOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, oe) {
      return z.every(function(ie) {
        try {
          return typeforce$3(ie, ne, oe);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join(" & ");
    }, Y;
  },
  quacksLike: function B(z) {
    function Y(ne) {
      return z === getValueTypeName(ne);
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  },
  tuple: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ne, oe) {
      return NATIVE.Nil(ne) || NATIVE.Nil(ne.length) || oe && ne.length !== z.length ? !1 : z.every(function(ie, ae) {
        try {
          return typeforce$3(ie, ne[ae], oe);
        } catch (se) {
          throw tfSubError(se, ae);
        }
      });
    }
    return Y.toJSON = function() {
      return "(" + z.map(tfJSON).join(", ") + ")";
    }, Y;
  },
  value: function B(z) {
    function Y(ne) {
      return ne === z;
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$3(B, z, Y, ne) {
  if (NATIVE.Function(B)) {
    if (B(z, Y)) return !0;
    throw new TfTypeError(ne || B, z);
  }
  return typeforce$3(compile(B), z, Y);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const z = dist$1;
  B.typeforce = typeforce_1;
  const Y = z.Buffer.alloc(32, 0), ne = z.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function oe(le, Ee) {
    return le.length !== Ee.length ? !1 : le.every((Ce, Pe) => Ce.equals(Ee[Pe]));
  }
  B.stacksEqual = oe;
  function ie(le) {
    if (!z.Buffer.isBuffer(le) || le.length < 33) return !1;
    const Ee = le[0], Ce = le.slice(1, 33);
    if (Ce.compare(Y) === 0 || Ce.compare(ne) >= 0) return !1;
    if ((Ee === 2 || Ee === 3) && le.length === 33)
      return !0;
    const Pe = le.slice(33);
    return Pe.compare(Y) === 0 || Pe.compare(ne) >= 0 ? !1 : Ee === 4 && le.length === 65;
  }
  B.isPoint = ie;
  const ae = 21 * 1e14;
  function se(le) {
    return B.typeforce.UInt53(le) && le <= ae;
  }
  B.Satoshi = se, B.TAPLEAF_VERSION_MASK = 254;
  function ve(le) {
    return !le || !("output" in le) || !z.Buffer.isBuffer(le.output) ? !1 : le.version !== void 0 ? (le.version & B.TAPLEAF_VERSION_MASK) === le.version : !0;
  }
  B.isTapleaf = ve;
  function ge(le) {
    return (0, B.Array)(le) ? le.length !== 2 ? !1 : le.every((Ee) => ge(Ee)) : ve(le);
  }
  B.isTaptree = ge, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, z = requireScript(), Y = types$4, { typeforce: ne } = Y, oe = Buffer$1.alloc(1, 0);
  function ie(ge) {
    let le = 0;
    for (; ge[le] === 0; ) ++le;
    return le === ge.length ? oe : (ge = ge.slice(le), ge[0] & 128 ? Buffer$1.concat([oe, ge], 1 + ge.length) : ge);
  }
  function ae(ge) {
    ge[0] === 0 && (ge = ge.slice(1));
    const le = Buffer$1.alloc(32, 0), Ee = Math.max(0, 32 - ge.length);
    return ge.copy(le, Ee), le;
  }
  function se(ge) {
    const le = ge.readUInt8(ge.length - 1);
    if (!(0, z.isDefinedHashType)(le))
      throw new Error("Invalid hashType " + le);
    const Ee = B.decode(ge.slice(0, -1)), Ce = ae(Ee.r), Pe = ae(Ee.s);
    return { signature: Buffer$1.concat([Ce, Pe], 64), hashType: le };
  }
  script_signature.decode = se;
  function ve(ge, le) {
    if (ne(
      {
        signature: Y.BufferN(64),
        hashType: Y.UInt8
      },
      { signature: ge, hashType: le }
    ), !(0, z.isDefinedHashType)(le))
      throw new Error("Invalid hashType " + le);
    const Ee = Buffer$1.allocUnsafe(1);
    Ee.writeUInt8(le, 0);
    const Ce = ie(ge.slice(0, 32)), Pe = ie(ge.slice(32, 64));
    return Buffer$1.concat([B.encode(Ce, Pe), Ee]);
  }
  return script_signature.encode = ve, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const z = bip66, Y = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return Y.OPS;
      }
    });
    const ne = push_data, oe = script_number, ie = requireScript_signature(), ae = types$4, { typeforce: se } = ae, ve = Y.OPS.OP_RESERVED;
    function ge(qt) {
      return ae.Number(qt) && (qt === Y.OPS.OP_0 || qt >= Y.OPS.OP_1 && qt <= Y.OPS.OP_16 || qt === Y.OPS.OP_1NEGATE);
    }
    function le(qt) {
      return ae.Buffer(qt) || ge(qt);
    }
    function Ee(qt) {
      return ae.Array(qt) && qt.every(le);
    }
    B.isPushOnly = Ee;
    function Ce(qt) {
      return qt.length - qt.filter(le).length;
    }
    B.countNonPushOnlyOPs = Ce;
    function Pe(qt) {
      if (qt.length === 0) return Y.OPS.OP_0;
      if (qt.length === 1) {
        if (qt[0] >= 1 && qt[0] <= 16) return ve + qt[0];
        if (qt[0] === 129) return Y.OPS.OP_1NEGATE;
      }
    }
    function Xe(qt) {
      return Buffer$1.isBuffer(qt);
    }
    function ht(qt) {
      return ae.Array(qt);
    }
    function wt(qt) {
      return Buffer$1.isBuffer(qt);
    }
    function Pt(qt) {
      if (Xe(qt)) return qt;
      se(ae.Array, qt);
      const zt = qt.reduce((Je, Ke) => wt(Ke) ? Ke.length === 1 && Pe(Ke) !== void 0 ? Je + 1 : Je + ne.encodingLength(Ke.length) + Ke.length : Je + 1, 0), Ft = Buffer$1.allocUnsafe(zt);
      let Ve = 0;
      if (qt.forEach((Je) => {
        if (wt(Je)) {
          const Ke = Pe(Je);
          if (Ke !== void 0) {
            Ft.writeUInt8(Ke, Ve), Ve += 1;
            return;
          }
          Ve += ne.encode(Ft, Je.length, Ve), Je.copy(Ft, Ve), Ve += Je.length;
        } else
          Ft.writeUInt8(Je, Ve), Ve += 1;
      }), Ve !== Ft.length) throw new Error("Could not decode chunks");
      return Ft;
    }
    B.compile = Pt;
    function vt(qt) {
      if (ht(qt)) return qt;
      se(ae.Buffer, qt);
      const zt = [];
      let Ft = 0;
      for (; Ft < qt.length; ) {
        const Ve = qt[Ft];
        if (Ve > Y.OPS.OP_0 && Ve <= Y.OPS.OP_PUSHDATA4) {
          const Je = ne.decode(qt, Ft);
          if (Je === null || (Ft += Je.size, Ft + Je.number > qt.length)) return null;
          const Ke = qt.slice(Ft, Ft + Je.number);
          Ft += Je.number;
          const Qe = Pe(Ke);
          Qe !== void 0 ? zt.push(Qe) : zt.push(Ke);
        } else
          zt.push(Ve), Ft += 1;
      }
      return zt;
    }
    B.decompile = vt;
    function Bt(qt) {
      if (Xe(qt) && (qt = vt(qt)), !qt)
        throw new Error("Could not convert invalid chunks to ASM");
      return qt.map((zt) => {
        if (wt(zt)) {
          const Ft = Pe(zt);
          if (Ft === void 0) return zt.toString("hex");
          zt = Ft;
        }
        return Y.REVERSE_OPS[zt];
      }).join(" ");
    }
    B.toASM = Bt;
    function Ct(qt) {
      return se(ae.String, qt), Pt(
        qt.split(" ").map((zt) => Y.OPS[zt] !== void 0 ? Y.OPS[zt] : (se(ae.Hex, zt), Buffer$1.from(zt, "hex")))
      );
    }
    B.fromASM = Ct;
    function Wt(qt) {
      return qt = vt(qt), se(Ee, qt), qt.map((zt) => wt(zt) ? zt : zt === Y.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : oe.encode(zt - ve));
    }
    B.toStack = Wt;
    function Kt(qt) {
      return ae.isPoint(qt);
    }
    B.isCanonicalPubKey = Kt;
    function Yt(qt) {
      const zt = qt & -129;
      return zt > 0 && zt < 4;
    }
    B.isDefinedHashType = Yt;
    function Ut(qt) {
      return !Buffer$1.isBuffer(qt) || !Yt(qt[qt.length - 1]) ? !1 : z.check(qt.slice(0, -1));
    }
    B.isCanonicalScriptSignature = Ut, B.number = oe, B.signature = ie;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, z, Y) {
  Object.defineProperty(B, z, {
    configurable: !0,
    enumerable: !0,
    get() {
      const ne = Y.call(this);
      return this[z] = ne, ne;
    },
    set(ne) {
      Object.defineProperty(this, z, {
        configurable: !0,
        enumerable: !0,
        value: ne,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let z;
  return () => (z !== void 0 || (z = B()), z);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, z) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const ne = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(ne, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(ne, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), z.validate && B.output) {
    const oe = bscript$9.decompile(B.output);
    if (oe[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!oe.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, ne.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(ne, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, z) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {});
  function Y(ve) {
    return bscript$8.isCanonicalScriptSignature(ve) || (z.allowIncomplete && ve === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(Y)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const oe = { network: B.network || networks_1$6.bitcoin };
  let ie = [], ae = !1;
  function se(ve) {
    ae || (ae = !0, ie = bscript$8.decompile(ve), oe.m = ie[0] - OP_INT_BASE, oe.n = ie[ie.length - 2] - OP_INT_BASE, oe.pubkeys = ie.slice(1, -2));
  }
  if (lazy$5.prop(oe, "output", () => {
    if (B.m && oe.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + oe.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(oe, "m", () => {
    if (oe.output)
      return se(oe.output), oe.m;
  }), lazy$5.prop(oe, "n", () => {
    if (oe.pubkeys)
      return oe.pubkeys.length;
  }), lazy$5.prop(oe, "pubkeys", () => {
    if (B.output)
      return se(B.output), oe.pubkeys;
  }), lazy$5.prop(oe, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(oe, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(oe, "witness", () => {
    if (oe.input)
      return [];
  }), lazy$5.prop(oe, "name", () => {
    if (!(!oe.m || !oe.n))
      return `p2ms(${oe.m} of ${oe.n})`;
  }), z.validate) {
    if (B.output) {
      if (se(B.output), !types_1$6.typeforce.Number(ie[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(ie[ie.length - 2]))
        throw new TypeError("Output is invalid");
      if (ie[ie.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (oe.m <= 0 || oe.n > 16 || oe.m > oe.n || oe.n !== ie.length - 3)
        throw new TypeError("Output is invalid");
      if (!oe.pubkeys.every((ve) => (0, types_1$6.isPoint)(ve)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== oe.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== oe.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, oe.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (oe.n = B.pubkeys.length, oe.n < oe.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < oe.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > oe.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (oe.signatures.length === 0 || !oe.signatures.every(Y))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, oe.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(oe, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, z) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$4.value(() => bscript$7.decompile(B.input)), oe = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(oe, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(oe, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(oe, "signature", () => {
    if (B.input)
      return Y()[0];
  }), lazy$4.prop(oe, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(oe, "witness", () => {
    if (oe.input)
      return [];
  }), z.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(oe.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(oe.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(oe.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (Y().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(oe.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(oe, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, z) => z)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let z of [idxL, idxR])
    z.push(z[B].map((Y) => Rho[Y]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, z) => B.map((Y) => shifts[z][Y])), shiftsR = /* @__PURE__ */ idxR.map((B, z) => B.map((Y) => shifts[z][Y])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(B, z, Y, ne) {
  return B === 0 ? z ^ Y ^ ne : B === 1 ? z & Y | ~z & ne : B === 2 ? (z | ~Y) ^ ne : B === 3 ? z & ne | Y & ~ne : z ^ (Y | ~ne);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: z, h1: Y, h2: ne, h3: oe, h4: ie } = this;
    return [z, Y, ne, oe, ie];
  }
  set(z, Y, ne, oe, ie) {
    this.h0 = z | 0, this.h1 = Y | 0, this.h2 = ne | 0, this.h3 = oe | 0, this.h4 = ie | 0;
  }
  process(z, Y) {
    for (let Pe = 0; Pe < 16; Pe++, Y += 4)
      R_BUF[Pe] = z.getUint32(Y, !0);
    let ne = this.h0 | 0, oe = ne, ie = this.h1 | 0, ae = ie, se = this.h2 | 0, ve = se, ge = this.h3 | 0, le = ge, Ee = this.h4 | 0, Ce = Ee;
    for (let Pe = 0; Pe < 5; Pe++) {
      const Xe = 4 - Pe, ht = Kl[Pe], wt = Kr[Pe], Pt = idxL[Pe], vt = idxR[Pe], Bt = shiftsL[Pe], Ct = shiftsR[Pe];
      for (let Wt = 0; Wt < 16; Wt++) {
        const Kt = (0, utils_js_1$1.rotl)(ne + f(Pe, ie, se, ge) + R_BUF[Pt[Wt]] + ht, Bt[Wt]) + Ee | 0;
        ne = Ee, Ee = ge, ge = (0, utils_js_1$1.rotl)(se, 10) | 0, se = ie, ie = Kt;
      }
      for (let Wt = 0; Wt < 16; Wt++) {
        const Kt = (0, utils_js_1$1.rotl)(oe + f(Xe, ae, ve, le) + R_BUF[vt[Wt]] + wt, Ct[Wt]) + Ce | 0;
        oe = Ce, Ce = le, le = (0, utils_js_1$1.rotl)(ve, 10) | 0, ve = ae, ae = Kt;
      }
    }
    this.set(this.h1 + se + le | 0, this.h2 + ge + Ce | 0, this.h3 + Ee + oe | 0, this.h4 + ne + ae | 0, this.h0 + ie + ve | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: z, B: Y, C: ne, D: oe, E: ie } = this;
    return [z, Y, ne, oe, ie];
  }
  set(z, Y, ne, oe, ie) {
    this.A = z | 0, this.B = Y | 0, this.C = ne | 0, this.D = oe | 0, this.E = ie | 0;
  }
  process(z, Y) {
    for (let ve = 0; ve < 16; ve++, Y += 4)
      SHA1_W[ve] = z.getUint32(Y, !1);
    for (let ve = 16; ve < 80; ve++)
      SHA1_W[ve] = (0, utils_js_1.rotl)(SHA1_W[ve - 3] ^ SHA1_W[ve - 8] ^ SHA1_W[ve - 14] ^ SHA1_W[ve - 16], 1);
    let { A: ne, B: oe, C: ie, D: ae, E: se } = this;
    for (let ve = 0; ve < 80; ve++) {
      let ge, le;
      ve < 20 ? (ge = (0, _md_js_1.Chi)(oe, ie, ae), le = 1518500249) : ve < 40 ? (ge = oe ^ ie ^ ae, le = 1859775393) : ve < 60 ? (ge = (0, _md_js_1.Maj)(oe, ie, ae), le = 2400959708) : (ge = oe ^ ie ^ ae, le = 3395469782);
      const Ee = (0, utils_js_1.rotl)(ne, 5) + ge + se + le + SHA1_W[ve] | 0;
      se = ae, ae = ie, ie = (0, utils_js_1.rotl)(oe, 30), oe = ne, ne = Ee;
    }
    ne = ne + this.A | 0, oe = oe + this.B | 0, ie = ie + this.C | 0, ae = ae + this.D | 0, se = se + this.E | 0, this.set(ne, oe, ie, ae, se);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const z = ripemd160, Y = sha1, ne = sha256$4;
  function oe(le) {
    return Buffer$1.from((0, z.ripemd160)(Uint8Array.from(le)));
  }
  B.ripemd160 = oe;
  function ie(le) {
    return Buffer$1.from((0, Y.sha1)(Uint8Array.from(le)));
  }
  B.sha1 = ie;
  function ae(le) {
    return Buffer$1.from((0, ne.sha256)(Uint8Array.from(le)));
  }
  B.sha256 = ae;
  function se(le) {
    return Buffer$1.from(
      (0, z.ripemd160)((0, ne.sha256)(Uint8Array.from(le)))
    );
  }
  B.hash160 = se;
  function ve(le) {
    return Buffer$1.from(
      (0, ne.sha256)((0, ne.sha256)(Uint8Array.from(le)))
    );
  }
  B.hash256 = ve, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function ge(le, Ee) {
    return ae(Buffer$1.concat([B.TAGGED_HASH_PREFIXES[le], Ee]));
  }
  B.taggedHash = ge;
})(crypto$1);
function base$1(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var z = new Uint8Array(256), Y = 0; Y < z.length; Y++)
    z[Y] = 255;
  for (var ne = 0; ne < B.length; ne++) {
    var oe = B.charAt(ne), ie = oe.charCodeAt(0);
    if (z[ie] !== 255)
      throw new TypeError(oe + " is ambiguous");
    z[ie] = ne;
  }
  var ae = B.length, se = B.charAt(0), ve = Math.log(ae) / Math.log(256), ge = Math.log(256) / Math.log(ae);
  function le(Pe) {
    if (Pe instanceof Uint8Array || (ArrayBuffer.isView(Pe) ? Pe = new Uint8Array(Pe.buffer, Pe.byteOffset, Pe.byteLength) : Array.isArray(Pe) && (Pe = Uint8Array.from(Pe))), !(Pe instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Pe.length === 0)
      return "";
    for (var Xe = 0, ht = 0, wt = 0, Pt = Pe.length; wt !== Pt && Pe[wt] === 0; )
      wt++, Xe++;
    for (var vt = (Pt - wt) * ge + 1 >>> 0, Bt = new Uint8Array(vt); wt !== Pt; ) {
      for (var Ct = Pe[wt], Wt = 0, Kt = vt - 1; (Ct !== 0 || Wt < ht) && Kt !== -1; Kt--, Wt++)
        Ct += 256 * Bt[Kt] >>> 0, Bt[Kt] = Ct % ae >>> 0, Ct = Ct / ae >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      ht = Wt, wt++;
    }
    for (var Yt = vt - ht; Yt !== vt && Bt[Yt] === 0; )
      Yt++;
    for (var Ut = se.repeat(Xe); Yt < vt; ++Yt)
      Ut += B.charAt(Bt[Yt]);
    return Ut;
  }
  function Ee(Pe) {
    if (typeof Pe != "string")
      throw new TypeError("Expected String");
    if (Pe.length === 0)
      return new Uint8Array();
    for (var Xe = 0, ht = 0, wt = 0; Pe[Xe] === se; )
      ht++, Xe++;
    for (var Pt = (Pe.length - Xe) * ve + 1 >>> 0, vt = new Uint8Array(Pt); Pe[Xe]; ) {
      var Bt = z[Pe.charCodeAt(Xe)];
      if (Bt === 255)
        return;
      for (var Ct = 0, Wt = Pt - 1; (Bt !== 0 || Ct < wt) && Wt !== -1; Wt--, Ct++)
        Bt += ae * vt[Wt] >>> 0, vt[Wt] = Bt % 256 >>> 0, Bt = Bt / 256 >>> 0;
      if (Bt !== 0)
        throw new Error("Non-zero carry");
      wt = Ct, Xe++;
    }
    for (var Kt = Pt - wt; Kt !== Pt && vt[Kt] === 0; )
      Kt++;
    for (var Yt = new Uint8Array(ht + (Pt - Kt)), Ut = ht; Kt !== Pt; )
      Yt[Ut++] = vt[Kt++];
    return Yt;
  }
  function Ce(Pe) {
    var Xe = Ee(Pe);
    if (Xe)
      return Xe;
    throw new Error("Non-base" + ae + " character");
  }
  return {
    encode: le,
    decodeUnsafe: Ee,
    decode: Ce
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(B) {
  function z(ie) {
    var ae = Uint8Array.from(ie), se = B(ae), ve = ae.length + 4, ge = new Uint8Array(ve);
    return ge.set(ae, 0), ge.set(se.subarray(0, 4), ae.length), base58.encode(ge, ve);
  }
  function Y(ie) {
    var ae = ie.slice(0, -4), se = ie.slice(-4), ve = B(ae);
    if (!(se[0] ^ ve[0] | se[1] ^ ve[1] | se[2] ^ ve[2] | se[3] ^ ve[3]))
      return ae;
  }
  function ne(ie) {
    var ae = base58.decodeUnsafe(ie);
    if (ae)
      return Y(ae);
  }
  function oe(ie) {
    var ae = base58.decode(ie), se = Y(ae);
    if (!se) throw new Error("Invalid checksum");
    return se;
  }
  return {
    encode: z,
    decode: oe,
    decodeUnsafe: ne
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(B) {
  return sha256(sha256(B));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$3.value(() => {
    const ae = Buffer$1.from(bs58check$1.decode(B.address)), se = ae.readUInt8(0), ve = ae.slice(1);
    return { version: se, hash: ve };
  }), ne = lazy$3.value(() => bscript$6.decompile(B.input)), oe = B.network || networks_1$4.bitcoin, ie = { name: "p2pkh", network: oe };
  if (lazy$3.prop(ie, "address", () => {
    if (!ie.hash) return;
    const ae = Buffer$1.allocUnsafe(21);
    return ae.writeUInt8(oe.pubKeyHash, 0), ie.hash.copy(ae, 1), bs58check$1.encode(ae);
  }), lazy$3.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return Y().hash;
    if (B.pubkey || ie.pubkey) return bcrypto$5.hash160(B.pubkey || ie.pubkey);
  }), lazy$3.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        ie.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(ie, "pubkey", () => {
    if (B.input)
      return ne()[1];
  }), lazy$3.prop(ie, "signature", () => {
    if (B.input)
      return ne()[0];
  }), lazy$3.prop(ie, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(ie, "witness", () => {
    if (ie.input)
      return [];
  }), z.validate) {
    let ae = Buffer$1.from([]);
    if (B.address) {
      if (Y().version !== oe.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (Y().hash.length !== 20) throw new TypeError("Invalid address");
      ae = Y().hash;
    }
    if (B.hash) {
      if (ae.length > 0 && !ae.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ae = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const se = B.output.slice(3, 23);
      if (ae.length > 0 && !ae.equals(se))
        throw new TypeError("Hash mismatch");
      ae = se;
    }
    if (B.pubkey) {
      const se = bcrypto$5.hash160(B.pubkey);
      if (ae.length > 0 && !ae.equals(se))
        throw new TypeError("Hash mismatch");
      ae = se;
    }
    if (B.input) {
      const se = ne();
      if (se.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(se[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(se[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(se[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(se[1]))
        throw new TypeError("Pubkey mismatch");
      const ve = bcrypto$5.hash160(se[1]);
      if (ae.length > 0 && !ae.equals(ve))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ie, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let Y = B.network;
  Y || (Y = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const ne = { network: Y }, oe = lazy$2.value(() => {
    const se = Buffer$1.from(bs58check.decode(B.address)), ve = se.readUInt8(0), ge = se.slice(1);
    return { version: ve, hash: ge };
  }), ie = lazy$2.value(() => bscript$5.decompile(B.input)), ae = lazy$2.value(() => {
    const se = ie(), ve = se[se.length - 1];
    return {
      network: Y,
      output: ve === OPS$2.OP_FALSE ? Buffer$1.from([]) : ve,
      input: bscript$5.compile(se.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(ne, "address", () => {
    if (!ne.hash) return;
    const se = Buffer$1.allocUnsafe(21);
    return se.writeUInt8(ne.network.scriptHash, 0), ne.hash.copy(se, 1), bs58check.encode(se);
  }), lazy$2.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return oe().hash;
    if (ne.redeem && ne.redeem.output) return bcrypto$4.hash160(ne.redeem.output);
  }), lazy$2.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, ne.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(ne, "redeem", () => {
    if (B.input)
      return ae();
  }), lazy$2.prop(ne, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(ne, "witness", () => {
    if (ne.redeem && ne.redeem.witness) return ne.redeem.witness;
    if (ne.input) return [];
  }), lazy$2.prop(ne, "name", () => {
    const se = ["p2sh"];
    return ne.redeem !== void 0 && ne.redeem.name !== void 0 && se.push(ne.redeem.name), se.join("-");
  }), z.validate) {
    let se = Buffer$1.from([]);
    if (B.address) {
      if (oe().version !== Y.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (oe().hash.length !== 20) throw new TypeError("Invalid address");
      se = oe().hash;
    }
    if (B.hash) {
      if (se.length > 0 && !se.equals(B.hash))
        throw new TypeError("Hash mismatch");
      se = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const ge = B.output.slice(2, 22);
      if (se.length > 0 && !se.equals(ge))
        throw new TypeError("Hash mismatch");
      se = ge;
    }
    const ve = (ge) => {
      if (ge.output) {
        const le = bscript$5.decompile(ge.output);
        if (!le || le.length < 1)
          throw new TypeError("Redeem.output too short");
        if (ge.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(le) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const Ee = bcrypto$4.hash160(ge.output);
        if (se.length > 0 && !se.equals(Ee))
          throw new TypeError("Hash mismatch");
        se = Ee;
      }
      if (ge.input) {
        const le = ge.input.length > 0, Ee = ge.witness && ge.witness.length > 0;
        if (!le && !Ee) throw new TypeError("Empty input");
        if (le && Ee)
          throw new TypeError("Input and witness provided");
        if (le) {
          const Ce = bscript$5.decompile(ge.input);
          if (!bscript$5.isPushOnly(Ce))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const ge = ie();
      if (!ge || ge.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(ae().output))
        throw new TypeError("Input is invalid");
      ve(ae());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== Y)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const ge = ae();
        if (B.redeem.output && !B.redeem.output.equals(ge.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(ge.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ve(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(ne, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET.length; B++) {
  const z = ALPHABET.charAt(B);
  ALPHABET_MAP[z] = B;
}
function polymodStep(B) {
  const z = B >> 25;
  return (B & 33554431) << 5 ^ -(z >> 0 & 1) & 996825010 ^ -(z >> 1 & 1) & 642813549 ^ -(z >> 2 & 1) & 513874426 ^ -(z >> 3 & 1) & 1027748829 ^ -(z >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let z = 1;
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    if (ne < 33 || ne > 126)
      return "Invalid prefix (" + B + ")";
    z = polymodStep(z) ^ ne >> 5;
  }
  z = polymodStep(z);
  for (let Y = 0; Y < B.length; ++Y) {
    const ne = B.charCodeAt(Y);
    z = polymodStep(z) ^ ne & 31;
  }
  return z;
}
function convert$2(B, z, Y, ne) {
  let oe = 0, ie = 0;
  const ae = (1 << Y) - 1, se = [];
  for (let ve = 0; ve < B.length; ++ve)
    for (oe = oe << z | B[ve], ie += z; ie >= Y; )
      ie -= Y, se.push(oe >> ie & ae);
  if (ne)
    ie > 0 && se.push(oe << Y - ie & ae);
  else {
    if (ie >= z)
      return "Excess padding";
    if (oe << Y - ie & ae)
      return "Non-zero padding";
  }
  return se;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
}
function fromWords(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
  throw new Error(z);
}
function getLibraryFromEncoding(B) {
  let z;
  B === "bech32" ? z = 1 : z = 734539939;
  function Y(ae, se, ve) {
    if (ve = ve || 90, ae.length + 7 + se.length > ve)
      throw new TypeError("Exceeds length limit");
    ae = ae.toLowerCase();
    let ge = prefixChk(ae);
    if (typeof ge == "string")
      throw new Error(ge);
    let le = ae + "1";
    for (let Ee = 0; Ee < se.length; ++Ee) {
      const Ce = se[Ee];
      if (Ce >> 5)
        throw new Error("Non 5-bit word");
      ge = polymodStep(ge) ^ Ce, le += ALPHABET.charAt(Ce);
    }
    for (let Ee = 0; Ee < 6; ++Ee)
      ge = polymodStep(ge);
    ge ^= z;
    for (let Ee = 0; Ee < 6; ++Ee) {
      const Ce = ge >> (5 - Ee) * 5 & 31;
      le += ALPHABET.charAt(Ce);
    }
    return le;
  }
  function ne(ae, se) {
    if (se = se || 90, ae.length < 8)
      return ae + " too short";
    if (ae.length > se)
      return "Exceeds length limit";
    const ve = ae.toLowerCase(), ge = ae.toUpperCase();
    if (ae !== ve && ae !== ge)
      return "Mixed-case string " + ae;
    ae = ve;
    const le = ae.lastIndexOf("1");
    if (le === -1)
      return "No separator character for " + ae;
    if (le === 0)
      return "Missing prefix for " + ae;
    const Ee = ae.slice(0, le), Ce = ae.slice(le + 1);
    if (Ce.length < 6)
      return "Data too short";
    let Pe = prefixChk(Ee);
    if (typeof Pe == "string")
      return Pe;
    const Xe = [];
    for (let ht = 0; ht < Ce.length; ++ht) {
      const wt = Ce.charAt(ht), Pt = ALPHABET_MAP[wt];
      if (Pt === void 0)
        return "Unknown character " + wt;
      Pe = polymodStep(Pe) ^ Pt, !(ht + 6 >= Ce.length) && Xe.push(Pt);
    }
    return Pe !== z ? "Invalid checksum for " + ae : { prefix: Ee, words: Xe };
  }
  function oe(ae, se) {
    const ve = ne(ae, se);
    if (typeof ve == "object")
      return ve;
  }
  function ie(ae, se) {
    const ve = ne(ae, se);
    if (typeof ve == "object")
      return ve;
    throw new Error(ve);
  }
  return {
    decodeUnsafe: oe,
    decode: ie,
    encode: Y,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy$1.value(() => {
    const ie = bech32_1$1.bech32.decode(B.address), ae = ie.words.shift(), se = bech32_1$1.bech32.fromWords(ie.words);
    return {
      version: ae,
      prefix: ie.prefix,
      data: Buffer$1.from(se)
    };
  }), ne = B.network || networks_1$2.bitcoin, oe = { name: "p2wpkh", network: ne };
  if (lazy$1.prop(oe, "address", () => {
    if (!oe.hash) return;
    const ie = bech32_1$1.bech32.toWords(oe.hash);
    return ie.unshift(0), bech32_1$1.bech32.encode(ne.bech32, ie);
  }), lazy$1.prop(oe, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return Y().data;
    if (B.pubkey || oe.pubkey) return bcrypto$3.hash160(B.pubkey || oe.pubkey);
  }), lazy$1.prop(oe, "output", () => {
    if (oe.hash)
      return bscript$4.compile([OPS$1.OP_0, oe.hash]);
  }), lazy$1.prop(oe, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(oe, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(oe, "input", () => {
    if (oe.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(oe, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), z.validate) {
    let ie = Buffer$1.from([]);
    if (B.address) {
      if (ne && ne.bech32 !== Y().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 20)
        throw new TypeError("Invalid address data");
      ie = Y().data;
    }
    if (B.hash) {
      if (ie.length > 0 && !ie.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ie = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (ie.length > 0 && !ie.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      ie = B.output.slice(2);
    }
    if (B.pubkey) {
      const ae = bcrypto$3.hash160(B.pubkey);
      if (ie.length > 0 && !ie.equals(ae))
        throw new TypeError("Hash mismatch");
      if (ie = ae, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const ae = bcrypto$3.hash160(B.witness[1]);
      if (ie.length > 0 && !ie.equals(ae))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(oe, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$1.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy.value(() => {
    const ae = bech32_1.bech32.decode(B.address), se = ae.words.shift(), ve = bech32_1.bech32.fromWords(ae.words);
    return {
      version: se,
      prefix: ae.prefix,
      data: Buffer$1.from(ve)
    };
  }), ne = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let oe = B.network;
  oe || (oe = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const ie = { network: oe };
  if (lazy.prop(ie, "address", () => {
    if (!ie.hash) return;
    const ae = bech32_1.bech32.toWords(ie.hash);
    return ae.unshift(0), bech32_1.bech32.encode(oe.bech32, ae);
  }), lazy.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return Y().data;
    if (ie.redeem && ie.redeem.output) return bcrypto$2.sha256(ie.redeem.output);
  }), lazy.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$3.compile([OPS.OP_0, ie.hash]);
  }), lazy.prop(ie, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(ie, "input", () => {
    if (ie.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(ie, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const ae = bscript$3.toStack(ne());
      return ie.redeem = Object.assign({ witness: ae }, B.redeem), ie.redeem.input = EMPTY_BUFFER$1, [].concat(ae, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(ie, "name", () => {
    const ae = ["p2wsh"];
    return ie.redeem !== void 0 && ie.redeem.name !== void 0 && ae.push(ie.redeem.name), ae.join("-");
  }), z.validate) {
    let ae = Buffer$1.from([]);
    if (B.address) {
      if (Y().prefix !== oe.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 32)
        throw new TypeError("Invalid address data");
      ae = Y().data;
    }
    if (B.hash) {
      if (ae.length > 0 && !ae.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ae = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const se = B.output.slice(2);
      if (ae.length > 0 && !ae.equals(se))
        throw new TypeError("Hash mismatch");
      ae = se;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== oe)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const se = bscript$3.decompile(B.redeem.output);
        if (!se || se.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(se) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ve = bcrypto$2.sha256(B.redeem.output);
        if (ae.length > 0 && !ae.equals(ve))
          throw new TypeError("Hash mismatch");
        ae = ve;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(ne()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && ne().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const se = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(se))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(se) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(ie, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (B) => Buffer$1.from(B, "hex");
function verifyEcc(B) {
  assert(typeof B.isXOnlyPoint == "function"), assert(
    B.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    B.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((z) => {
    const Y = B.xOnlyPointAddTweak(h(z.pubkey), h(z.tweak));
    z.result === null ? assert(Y === null) : (assert(Y !== null), assert(Y.parity === z.parity), assert(Buffer$1.from(Y.xOnlyPubkey).equals(h(z.result))));
  });
}
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(B, z, Y) {
  if (checkUInt53$1(B), z || (z = Buffer.allocUnsafe(encodingLength$1(B))), !Buffer.isBuffer(z)) throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), encode$f.bytes = 1) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), encode$f.bytes = 3) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), encode$f.bytes = 5) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), encode$f.bytes = 9), z;
}
function decode$e(B, z) {
  if (!Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  var Y = B.readUInt8(z);
  if (Y < 253)
    return decode$e.bytes = 1, Y;
  if (Y === 253)
    return decode$e.bytes = 3, B.readUInt16LE(z + 1);
  if (Y === 254)
    return decode$e.bytes = 5, B.readUInt32LE(z + 1);
  decode$e.bytes = 9;
  var ne = B.readUInt32LE(z + 1), oe = B.readUInt32LE(z + 5), ie = oe * 4294967296 + ne;
  return checkUInt53$1(ie), ie;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint$1(ne + Y, 9007199254740991), ne + Y;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, z, Y) {
  return verifuint$1(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(B) {
  const z = Buffer$1.allocUnsafe(B.length);
  return B.copy(z), z;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(z) {
    return new BufferWriter(Buffer$1.alloc(z));
  }
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  writeUInt8(z) {
    this.offset = this.buffer.writeUInt8(z, this.offset);
  }
  writeInt32(z) {
    this.offset = this.buffer.writeInt32LE(z, this.offset);
  }
  writeUInt32(z) {
    this.offset = this.buffer.writeUInt32LE(z, this.offset);
  }
  writeUInt64(z) {
    this.offset = writeUInt64LE$1(this.buffer, z, this.offset);
  }
  writeVarInt(z) {
    varuint$7.encode(z, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(z) {
    if (this.buffer.length < this.offset + z.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += z.copy(this.buffer, this.offset);
  }
  writeVarSlice(z) {
    this.writeVarInt(z.length), this.writeSlice(z);
  }
  writeVector(z) {
    this.writeVarInt(z.length), z.forEach((Y) => this.writeVarSlice(Y));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  readUInt8() {
    const z = this.buffer.readUInt8(this.offset);
    return this.offset++, z;
  }
  readInt32() {
    const z = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt32() {
    const z = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt64() {
    const z = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, z;
  }
  readVarInt() {
    const z = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, z;
  }
  readSlice(z) {
    if (this.buffer.length < this.offset + z)
      throw new Error("Cannot read slice out of bounds");
    const Y = this.buffer.slice(this.offset, this.offset + z);
    return this.offset += z, Y;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const z = this.readVarInt(), Y = [];
    for (let ne = 0; ne < z; ne++) Y.push(this.readVarSlice());
    return Y;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const z = dist$1, Y = ecc_lib, ne = crypto$1, oe = bufferutils, ie = types$4;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const ae = (ht) => "left" in ht && "right" in ht;
  function se(ht, wt) {
    if (ht.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${ht.length}, expected min 33.`
      );
    const Pt = (ht.length - 33) / 32;
    let vt = wt;
    for (let Bt = 0; Bt < Pt; Bt++) {
      const Ct = ht.slice(33 + 32 * Bt, 65 + 32 * Bt);
      vt.compare(Ct) < 0 ? vt = Pe(vt, Ct) : vt = Pe(Ct, vt);
    }
    return vt;
  }
  B.rootHashFromPath = se;
  function ve(ht) {
    if ((0, ie.isTapleaf)(ht))
      return { hash: le(ht) };
    const wt = [ve(ht[0]), ve(ht[1])];
    wt.sort((Bt, Ct) => Bt.hash.compare(Ct.hash));
    const [Pt, vt] = wt;
    return {
      hash: Pe(Pt.hash, vt.hash),
      left: Pt,
      right: vt
    };
  }
  B.toHashTree = ve;
  function ge(ht, wt) {
    if (ae(ht)) {
      const Pt = ge(ht.left, wt);
      if (Pt !== void 0) return [...Pt, ht.right.hash];
      const vt = ge(ht.right, wt);
      if (vt !== void 0) return [...vt, ht.left.hash];
    } else if (ht.hash.equals(wt))
      return [];
  }
  B.findScriptPath = ge;
  function le(ht) {
    const wt = ht.version || B.LEAF_VERSION_TAPSCRIPT;
    return ne.taggedHash(
      "TapLeaf",
      z.Buffer.concat([
        z.Buffer.from([wt]),
        Xe(ht.output)
      ])
    );
  }
  B.tapleafHash = le;
  function Ee(ht, wt) {
    return ne.taggedHash(
      "TapTweak",
      z.Buffer.concat(wt ? [ht, wt] : [ht])
    );
  }
  B.tapTweakHash = Ee;
  function Ce(ht, wt) {
    if (!z.Buffer.isBuffer(ht) || ht.length !== 32 || wt && wt.length !== 32) return null;
    const Pt = Ee(ht, wt), vt = (0, Y.getEccLib)().xOnlyPointAddTweak(ht, Pt);
    return !vt || vt.xOnlyPubkey === null ? null : {
      parity: vt.parity,
      x: z.Buffer.from(vt.xOnlyPubkey)
    };
  }
  B.tweakKey = Ce;
  function Pe(ht, wt) {
    return ne.taggedHash("TapBranch", z.Buffer.concat([ht, wt]));
  }
  function Xe(ht) {
    const wt = oe.varuint.encodingLength(ht.length), Pt = z.Buffer.allocUnsafe(wt);
    return oe.varuint.encode(ht.length, Pt), z.Buffer.concat([Pt, ht]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = dist$1, z = networks, Y = requireScript(), ne = types$4, oe = ecc_lib, ie = bip341, ae = lazy$7, se = dist, ve = requireAddress(), ge = Y.OPS, le = 1, Ee = 80;
  function Ce(Pe, Xe) {
    if (!Pe.address && !Pe.output && !Pe.pubkey && !Pe.internalPubkey && !(Pe.witness && Pe.witness.length > 1))
      throw new TypeError("Not enough data");
    Xe = Object.assign({ validate: !0 }, Xe || {}), (0, ne.typeforce)(
      {
        address: ne.typeforce.maybe(ne.typeforce.String),
        input: ne.typeforce.maybe(ne.typeforce.BufferN(0)),
        network: ne.typeforce.maybe(ne.typeforce.Object),
        output: ne.typeforce.maybe(ne.typeforce.BufferN(34)),
        internalPubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        hash: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        pubkey: ne.typeforce.maybe(ne.typeforce.BufferN(32)),
        signature: ne.typeforce.maybe(
          ne.typeforce.anyOf(
            ne.typeforce.BufferN(64),
            ne.typeforce.BufferN(65)
          )
        ),
        witness: ne.typeforce.maybe(
          ne.typeforce.arrayOf(ne.typeforce.Buffer)
        ),
        scriptTree: ne.typeforce.maybe(ne.isTaptree),
        redeem: ne.typeforce.maybe({
          output: ne.typeforce.maybe(ne.typeforce.Buffer),
          redeemVersion: ne.typeforce.maybe(ne.typeforce.Number),
          witness: ne.typeforce.maybe(
            ne.typeforce.arrayOf(ne.typeforce.Buffer)
          )
        }),
        redeemVersion: ne.typeforce.maybe(ne.typeforce.Number)
      },
      Pe
    );
    const ht = ae.value(() => (0, ve.fromBech32)(Pe.address)), wt = ae.value(() => {
      if (!(!Pe.witness || !Pe.witness.length))
        return Pe.witness.length >= 2 && Pe.witness[Pe.witness.length - 1][0] === Ee ? Pe.witness.slice(0, -1) : Pe.witness.slice();
    }), Pt = ae.value(() => {
      if (Pe.scriptTree) return (0, ie.toHashTree)(Pe.scriptTree);
      if (Pe.hash) return { hash: Pe.hash };
    }), vt = Pe.network || z.bitcoin, Bt = { name: "p2tr", network: vt };
    if (ae.prop(Bt, "address", () => {
      if (!Bt.pubkey) return;
      const Ct = se.bech32m.toWords(Bt.pubkey);
      return Ct.unshift(le), se.bech32m.encode(vt.bech32, Ct);
    }), ae.prop(Bt, "hash", () => {
      const Ct = Pt();
      if (Ct) return Ct.hash;
      const Wt = wt();
      if (Wt && Wt.length > 1) {
        const Kt = Wt[Wt.length - 1], Yt = Kt[0] & ne.TAPLEAF_VERSION_MASK, Ut = Wt[Wt.length - 2], qt = (0, ie.tapleafHash)({
          output: Ut,
          version: Yt
        });
        return (0, ie.rootHashFromPath)(Kt, qt);
      }
      return null;
    }), ae.prop(Bt, "output", () => {
      if (Bt.pubkey)
        return Y.compile([ge.OP_1, Bt.pubkey]);
    }), ae.prop(Bt, "redeemVersion", () => Pe.redeemVersion ? Pe.redeemVersion : Pe.redeem && Pe.redeem.redeemVersion !== void 0 && Pe.redeem.redeemVersion !== null ? Pe.redeem.redeemVersion : ie.LEAF_VERSION_TAPSCRIPT), ae.prop(Bt, "redeem", () => {
      const Ct = wt();
      if (!(!Ct || Ct.length < 2))
        return {
          output: Ct[Ct.length - 2],
          witness: Ct.slice(0, -2),
          redeemVersion: Ct[Ct.length - 1][0] & ne.TAPLEAF_VERSION_MASK
        };
    }), ae.prop(Bt, "pubkey", () => {
      if (Pe.pubkey) return Pe.pubkey;
      if (Pe.output) return Pe.output.slice(2);
      if (Pe.address) return ht().data;
      if (Bt.internalPubkey) {
        const Ct = (0, ie.tweakKey)(Bt.internalPubkey, Bt.hash);
        if (Ct) return Ct.x;
      }
    }), ae.prop(Bt, "internalPubkey", () => {
      if (Pe.internalPubkey) return Pe.internalPubkey;
      const Ct = wt();
      if (Ct && Ct.length > 1)
        return Ct[Ct.length - 1].slice(1, 33);
    }), ae.prop(Bt, "signature", () => {
      if (Pe.signature) return Pe.signature;
      const Ct = wt();
      if (!(!Ct || Ct.length !== 1))
        return Ct[0];
    }), ae.prop(Bt, "witness", () => {
      if (Pe.witness) return Pe.witness;
      const Ct = Pt();
      if (Ct && Pe.redeem && Pe.redeem.output && Pe.internalPubkey) {
        const Wt = (0, ie.tapleafHash)({
          output: Pe.redeem.output,
          version: Bt.redeemVersion
        }), Kt = (0, ie.findScriptPath)(Ct, Wt);
        if (!Kt) return;
        const Yt = (0, ie.tweakKey)(Pe.internalPubkey, Ct.hash);
        if (!Yt) return;
        const Ut = B.Buffer.concat(
          [
            B.Buffer.from([Bt.redeemVersion | Yt.parity]),
            Pe.internalPubkey
          ].concat(Kt)
        );
        return [Pe.redeem.output, Ut];
      }
      if (Pe.signature) return [Pe.signature];
    }), Xe.validate) {
      let Ct = B.Buffer.from([]);
      if (Pe.address) {
        if (vt && vt.bech32 !== ht().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (ht().version !== le)
          throw new TypeError("Invalid address version");
        if (ht().data.length !== 32)
          throw new TypeError("Invalid address data");
        Ct = ht().data;
      }
      if (Pe.pubkey) {
        if (Ct.length > 0 && !Ct.equals(Pe.pubkey))
          throw new TypeError("Pubkey mismatch");
        Ct = Pe.pubkey;
      }
      if (Pe.output) {
        if (Pe.output.length !== 34 || Pe.output[0] !== ge.OP_1 || Pe.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (Ct.length > 0 && !Ct.equals(Pe.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        Ct = Pe.output.slice(2);
      }
      if (Pe.internalPubkey) {
        const Yt = (0, ie.tweakKey)(Pe.internalPubkey, Bt.hash);
        if (Ct.length > 0 && !Ct.equals(Yt.x))
          throw new TypeError("Pubkey mismatch");
        Ct = Yt.x;
      }
      if (Ct && Ct.length && !(0, oe.getEccLib)().isXOnlyPoint(Ct))
        throw new TypeError("Invalid pubkey for p2tr");
      const Wt = Pt();
      if (Pe.hash && Wt && !Pe.hash.equals(Wt.hash))
        throw new TypeError("Hash mismatch");
      if (Pe.redeem && Pe.redeem.output && Wt) {
        const Yt = (0, ie.tapleafHash)({
          output: Pe.redeem.output,
          version: Bt.redeemVersion
        });
        if (!(0, ie.findScriptPath)(Wt, Yt))
          throw new TypeError("Redeem script not in tree");
      }
      const Kt = wt();
      if (Pe.redeem && Bt.redeem) {
        if (Pe.redeem.redeemVersion && Pe.redeem.redeemVersion !== Bt.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Pe.redeem.output) {
          if (Y.decompile(Pe.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (Bt.redeem.output && !Pe.redeem.output.equals(Bt.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Pe.redeem.witness && Bt.redeem.witness && !(0, ne.stacksEqual)(Pe.redeem.witness, Bt.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Kt && Kt.length)
        if (Kt.length === 1) {
          if (Pe.signature && !Pe.signature.equals(Kt[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Yt = Kt[Kt.length - 1];
          if (Yt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Yt.length}, expected min 33.`
            );
          if ((Yt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Yt.length} is incorrect!`
            );
          const Ut = (Yt.length - 33) / 32;
          if (Ut > 128)
            throw new TypeError(
              `The script path is too long. Got ${Ut}, expected max 128.`
            );
          const qt = Yt.slice(1, 33);
          if (Pe.internalPubkey && !Pe.internalPubkey.equals(qt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, oe.getEccLib)().isXOnlyPoint(qt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const zt = Yt[0] & ne.TAPLEAF_VERSION_MASK, Ft = Kt[Kt.length - 2], Ve = (0, ie.tapleafHash)({
            output: Ft,
            version: zt
          }), Je = (0, ie.rootHashFromPath)(Yt, Ve), Ke = (0, ie.tweakKey)(qt, Je);
          if (!Ke)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (Ct.length && !Ct.equals(Ke.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (Ke.parity !== (Yt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(Bt, Pe);
  }
  return p2tr.p2tr = Ce, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const z = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return z.p2data;
      }
    });
    const Y = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return Y.p2ms;
      }
    });
    const ne = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return ne.p2pk;
      }
    });
    const oe = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return oe.p2pkh;
      }
    });
    const ie = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return ie.p2sh;
      }
    });
    const ae = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return ae.p2wpkh;
      }
    });
    const se = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return se.p2wsh;
      }
    });
    const ve = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return ve.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks, z = requirePayments(), Y = requireScript(), ne = types$4, oe = dist, ie = bs58check$2, ae = 40, se = 2, ve = 16, ge = 2, le = 80, Ee = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Ce(Bt, Ct) {
    const Wt = Bt.slice(2);
    if (Wt.length < se || Wt.length > ae)
      throw new TypeError("Invalid program length for segwit address");
    const Kt = Bt[0] - le;
    if (Kt < ge || Kt > ve)
      throw new TypeError("Invalid version for segwit address");
    if (Bt[1] !== Wt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(Ee), wt(Wt, Kt, Ct.bech32);
  }
  function Pe(Bt) {
    const Ct = Buffer$1.from(ie.decode(Bt));
    if (Ct.length < 21) throw new TypeError(Bt + " is too short");
    if (Ct.length > 21) throw new TypeError(Bt + " is too long");
    const Wt = Ct.readUInt8(0), Kt = Ct.slice(1);
    return { version: Wt, hash: Kt };
  }
  address.fromBase58Check = Pe;
  function Xe(Bt) {
    let Ct, Wt;
    try {
      Ct = oe.bech32.decode(Bt);
    } catch {
    }
    if (Ct) {
      if (Wt = Ct.words[0], Wt !== 0) throw new TypeError(Bt + " uses wrong encoding");
    } else if (Ct = oe.bech32m.decode(Bt), Wt = Ct.words[0], Wt === 0) throw new TypeError(Bt + " uses wrong encoding");
    const Kt = oe.bech32.fromWords(Ct.words.slice(1));
    return {
      version: Wt,
      prefix: Ct.prefix,
      data: Buffer$1.from(Kt)
    };
  }
  address.fromBech32 = Xe;
  function ht(Bt, Ct) {
    (0, ne.typeforce)(
      (0, ne.tuple)(ne.Hash160bit, ne.UInt8),
      arguments
    );
    const Wt = Buffer$1.allocUnsafe(21);
    return Wt.writeUInt8(Ct, 0), Bt.copy(Wt, 1), ie.encode(Wt);
  }
  address.toBase58Check = ht;
  function wt(Bt, Ct, Wt) {
    const Kt = oe.bech32.toWords(Bt);
    return Kt.unshift(Ct), Ct === 0 ? oe.bech32.encode(Wt, Kt) : oe.bech32m.encode(Wt, Kt);
  }
  address.toBech32 = wt;
  function Pt(Bt, Ct) {
    Ct = Ct || B.bitcoin;
    try {
      return z.p2pkh({ output: Bt, network: Ct }).address;
    } catch {
    }
    try {
      return z.p2sh({ output: Bt, network: Ct }).address;
    } catch {
    }
    try {
      return z.p2wpkh({ output: Bt, network: Ct }).address;
    } catch {
    }
    try {
      return z.p2wsh({ output: Bt, network: Ct }).address;
    } catch {
    }
    try {
      return z.p2tr({ output: Bt, network: Ct }).address;
    } catch {
    }
    try {
      return Ce(Bt, Ct);
    } catch {
    }
    throw new Error(Y.toASM(Bt) + " has no matching Address");
  }
  address.fromOutputScript = Pt;
  function vt(Bt, Ct) {
    Ct = Ct || B.bitcoin;
    let Wt, Kt;
    try {
      Wt = Pe(Bt);
    } catch {
    }
    if (Wt) {
      if (Wt.version === Ct.pubKeyHash)
        return z.p2pkh({ hash: Wt.hash }).output;
      if (Wt.version === Ct.scriptHash)
        return z.p2sh({ hash: Wt.hash }).output;
    } else {
      try {
        Kt = Xe(Bt);
      } catch {
      }
      if (Kt) {
        if (Kt.prefix !== Ct.bech32)
          throw new Error(Bt + " has an invalid prefix");
        if (Kt.version === 0) {
          if (Kt.data.length === 20)
            return z.p2wpkh({ hash: Kt.data }).output;
          if (Kt.data.length === 32)
            return z.p2wsh({ hash: Kt.data }).output;
        } else if (Kt.version === 1) {
          if (Kt.data.length === 32)
            return z.p2tr({ pubkey: Kt.data }).output;
        } else if (Kt.version >= ge && Kt.version <= ve && Kt.data.length >= se && Kt.data.length <= ae)
          return console.warn(Ee), Y.compile([
            Kt.version + le,
            Kt.data
          ]);
      }
    }
    throw new Error(Bt + " has no matching Script");
  }
  return address.toOutputScript = vt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, z) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof z != "function")
    throw TypeError("Expected digest Function");
  let Y = B.length;
  const ne = B.concat();
  for (; Y > 1; ) {
    let oe = 0;
    for (let ie = 0; ie < Y; ie += 2, ++oe) {
      const ae = ne[ie], se = ie + 1 === Y ? ae : ne[ie + 1], ve = Buffer$1.concat([ae, se]);
      ne[oe] = z(ve);
    }
    Y = oe;
  }
  return ne[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + z;
}
function vectorSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + B.reduce((Y, ne) => Y + varSliceSize(ne), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(z, Y) {
    const ne = new bufferutils_1$2.BufferReader(z), oe = new Transaction();
    oe.version = ne.readInt32();
    const ie = ne.readUInt8(), ae = ne.readUInt8();
    let se = !1;
    ie === Transaction.ADVANCED_TRANSACTION_MARKER && ae === Transaction.ADVANCED_TRANSACTION_FLAG ? se = !0 : ne.offset -= 2;
    const ve = ne.readVarInt();
    for (let le = 0; le < ve; ++le)
      oe.ins.push({
        hash: ne.readSlice(32),
        index: ne.readUInt32(),
        script: ne.readVarSlice(),
        sequence: ne.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const ge = ne.readVarInt();
    for (let le = 0; le < ge; ++le)
      oe.outs.push({
        value: ne.readUInt64(),
        script: ne.readVarSlice()
      });
    if (se) {
      for (let le = 0; le < ve; ++le)
        oe.ins[le].witness = ne.readVector();
      if (!oe.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (oe.locktime = ne.readUInt32(), Y) return oe;
    if (ne.offset !== z.length)
      throw new Error("Transaction has unexpected data");
    return oe;
  }
  static fromHex(z) {
    return Transaction.fromBuffer(Buffer$1.from(z, "hex"), !1);
  }
  static isCoinbaseHash(z) {
    typeforce$1(types$1.Hash256bit, z);
    for (let Y = 0; Y < 32; ++Y)
      if (z[Y] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(z, Y, ne, oe) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(ne) && (ne = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: z,
      index: Y,
      script: oe || EMPTY_BUFFER,
      sequence: ne,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(z, Y) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: z,
      value: Y
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((z) => z.witness.length !== 0);
  }
  weight() {
    const z = this.byteLength(!1), Y = this.byteLength(!0);
    return z * 3 + Y;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(z = !0) {
    const Y = z && this.hasWitnesses();
    return (Y ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((ne, oe) => ne + 40 + varSliceSize(oe.script), 0) + this.outs.reduce((ne, oe) => ne + 8 + varSliceSize(oe.script), 0) + (Y ? this.ins.reduce((ne, oe) => ne + vectorSize(oe.witness), 0) : 0);
  }
  clone() {
    const z = new Transaction();
    return z.version = this.version, z.locktime = this.locktime, z.ins = this.ins.map((Y) => ({
      hash: Y.hash,
      index: Y.index,
      script: Y.script,
      sequence: Y.sequence,
      witness: Y.witness
    })), z.outs = this.outs.map((Y) => ({
      script: Y.script,
      value: Y.value
    })), z;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(z, Y, ne) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), z >= this.ins.length) return ONE;
    const oe = bscript$2.compile(
      bscript$2.decompile(Y).filter((se) => se !== script_1.OPS.OP_CODESEPARATOR)
    ), ie = this.clone();
    if ((ne & 31) === Transaction.SIGHASH_NONE)
      ie.outs = [], ie.ins.forEach((se, ve) => {
        ve !== z && (se.sequence = 0);
      });
    else if ((ne & 31) === Transaction.SIGHASH_SINGLE) {
      if (z >= this.outs.length) return ONE;
      ie.outs.length = z + 1;
      for (let se = 0; se < z; se++)
        ie.outs[se] = BLANK_OUTPUT;
      ie.ins.forEach((se, ve) => {
        ve !== z && (se.sequence = 0);
      });
    }
    ne & Transaction.SIGHASH_ANYONECANPAY ? (ie.ins = [ie.ins[z]], ie.ins[0].script = oe) : (ie.ins.forEach((se) => {
      se.script = EMPTY_BUFFER;
    }), ie.ins[z].script = oe);
    const ae = Buffer$1.allocUnsafe(ie.byteLength(!1) + 4);
    return ae.writeInt32LE(ne, ae.length - 4), ie.__toBuffer(ae, 0, !1), bcrypto$1.hash256(ae);
  }
  hashForWitnessV1(z, Y, ne, oe, ie, ae) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), ne.length !== this.ins.length || Y.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const se = oe === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : oe & Transaction.SIGHASH_OUTPUT_MASK, ge = (oe & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, le = se === Transaction.SIGHASH_NONE, Ee = se === Transaction.SIGHASH_SINGLE;
    let Ce = EMPTY_BUFFER, Pe = EMPTY_BUFFER, Xe = EMPTY_BUFFER, ht = EMPTY_BUFFER, wt = EMPTY_BUFFER;
    if (!ge) {
      let Ct = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((Wt) => {
        Ct.writeSlice(Wt.hash), Ct.writeUInt32(Wt.index);
      }), Ce = bcrypto$1.sha256(Ct.end()), Ct = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), ne.forEach((Wt) => Ct.writeUInt64(Wt)), Pe = bcrypto$1.sha256(Ct.end()), Ct = bufferutils_1$2.BufferWriter.withCapacity(
        Y.map(varSliceSize).reduce((Wt, Kt) => Wt + Kt)
      ), Y.forEach(
        (Wt) => Ct.writeVarSlice(Wt)
      ), Xe = bcrypto$1.sha256(Ct.end()), Ct = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((Wt) => Ct.writeUInt32(Wt.sequence)), ht = bcrypto$1.sha256(Ct.end());
    }
    if (le || Ee) {
      if (Ee && z < this.outs.length) {
        const Ct = this.outs[z], Wt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(Ct.script)
        );
        Wt.writeUInt64(Ct.value), Wt.writeVarSlice(Ct.script), wt = bcrypto$1.sha256(Wt.end());
      }
    } else {
      const Ct = this.outs.map((Kt) => 8 + varSliceSize(Kt.script)).reduce((Kt, Yt) => Kt + Yt), Wt = bufferutils_1$2.BufferWriter.withCapacity(Ct);
      this.outs.forEach((Kt) => {
        Wt.writeUInt64(Kt.value), Wt.writeVarSlice(Kt.script);
      }), wt = bcrypto$1.sha256(Wt.end());
    }
    const Pt = (ie ? 2 : 0) + (ae ? 1 : 0), vt = 174 - (ge ? 49 : 0) - (le ? 32 : 0) + (ae ? 32 : 0) + (ie ? 37 : 0), Bt = bufferutils_1$2.BufferWriter.withCapacity(vt);
    if (Bt.writeUInt8(oe), Bt.writeInt32(this.version), Bt.writeUInt32(this.locktime), Bt.writeSlice(Ce), Bt.writeSlice(Pe), Bt.writeSlice(Xe), Bt.writeSlice(ht), le || Ee || Bt.writeSlice(wt), Bt.writeUInt8(Pt), ge) {
      const Ct = this.ins[z];
      Bt.writeSlice(Ct.hash), Bt.writeUInt32(Ct.index), Bt.writeUInt64(ne[z]), Bt.writeVarSlice(Y[z]), Bt.writeUInt32(Ct.sequence);
    } else
      Bt.writeUInt32(z);
    if (ae) {
      const Ct = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(ae)
      );
      Ct.writeVarSlice(ae), Bt.writeSlice(bcrypto$1.sha256(Ct.end()));
    }
    return Ee && Bt.writeSlice(wt), ie && (Bt.writeSlice(ie), Bt.writeUInt8(0), Bt.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), Bt.end()])
    );
  }
  hashForWitnessV0(z, Y, ne, oe) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let ie = Buffer$1.from([]), ae, se = ZERO, ve = ZERO, ge = ZERO;
    if (oe & Transaction.SIGHASH_ANYONECANPAY || (ie = Buffer$1.allocUnsafe(36 * this.ins.length), ae = new bufferutils_1$2.BufferWriter(ie, 0), this.ins.forEach((Ee) => {
      ae.writeSlice(Ee.hash), ae.writeUInt32(Ee.index);
    }), ve = bcrypto$1.hash256(ie)), !(oe & Transaction.SIGHASH_ANYONECANPAY) && (oe & 31) !== Transaction.SIGHASH_SINGLE && (oe & 31) !== Transaction.SIGHASH_NONE && (ie = Buffer$1.allocUnsafe(4 * this.ins.length), ae = new bufferutils_1$2.BufferWriter(ie, 0), this.ins.forEach((Ee) => {
      ae.writeUInt32(Ee.sequence);
    }), ge = bcrypto$1.hash256(ie)), (oe & 31) !== Transaction.SIGHASH_SINGLE && (oe & 31) !== Transaction.SIGHASH_NONE) {
      const Ee = this.outs.reduce((Ce, Pe) => Ce + 8 + varSliceSize(Pe.script), 0);
      ie = Buffer$1.allocUnsafe(Ee), ae = new bufferutils_1$2.BufferWriter(ie, 0), this.outs.forEach((Ce) => {
        ae.writeUInt64(Ce.value), ae.writeVarSlice(Ce.script);
      }), se = bcrypto$1.hash256(ie);
    } else if ((oe & 31) === Transaction.SIGHASH_SINGLE && z < this.outs.length) {
      const Ee = this.outs[z];
      ie = Buffer$1.allocUnsafe(8 + varSliceSize(Ee.script)), ae = new bufferutils_1$2.BufferWriter(ie, 0), ae.writeUInt64(Ee.value), ae.writeVarSlice(Ee.script), se = bcrypto$1.hash256(ie);
    }
    ie = Buffer$1.allocUnsafe(156 + varSliceSize(Y)), ae = new bufferutils_1$2.BufferWriter(ie, 0);
    const le = this.ins[z];
    return ae.writeInt32(this.version), ae.writeSlice(ve), ae.writeSlice(ge), ae.writeSlice(le.hash), ae.writeUInt32(le.index), ae.writeVarSlice(Y), ae.writeUInt64(ne), ae.writeUInt32(le.sequence), ae.writeSlice(se), ae.writeUInt32(this.locktime), ae.writeUInt32(oe), bcrypto$1.hash256(ie);
  }
  getHash(z) {
    return z && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, z));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(z, Y) {
    return this.__toBuffer(z, Y, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[z].script = Y;
  }
  setWitness(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[z].witness = Y;
  }
  __toBuffer(z, Y, ne = !1) {
    z || (z = Buffer$1.allocUnsafe(this.byteLength(ne)));
    const oe = new bufferutils_1$2.BufferWriter(
      z,
      Y || 0
    );
    oe.writeInt32(this.version);
    const ie = ne && this.hasWitnesses();
    return ie && (oe.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), oe.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), oe.writeVarInt(this.ins.length), this.ins.forEach((ae) => {
      oe.writeSlice(ae.hash), oe.writeUInt32(ae.index), oe.writeVarSlice(ae.script), oe.writeUInt32(ae.sequence);
    }), oe.writeVarInt(this.outs.length), this.outs.forEach((ae) => {
      isOutput(ae) ? oe.writeUInt64(ae.value) : oe.writeSlice(ae.valueBuffer), oe.writeVarSlice(ae.script);
    }), ie && this.ins.forEach((ae) => {
      oe.writeVector(ae.witness);
    }), oe.writeUInt32(this.locktime), Y !== void 0 ? z.slice(Y, oe.offset) : z;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(z) {
    if (z.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const Y = new bufferutils_1$1.BufferReader(z), ne = new Block();
    if (ne.version = Y.readInt32(), ne.prevHash = Y.readSlice(32), ne.merkleRoot = Y.readSlice(32), ne.timestamp = Y.readUInt32(), ne.bits = Y.readUInt32(), ne.nonce = Y.readUInt32(), z.length === 80) return ne;
    const oe = () => {
      const se = transaction_1$3.Transaction.fromBuffer(
        Y.buffer.slice(Y.offset),
        !0
      );
      return Y.offset += se.byteLength(), se;
    }, ie = Y.readVarInt();
    ne.transactions = [];
    for (let se = 0; se < ie; ++se) {
      const ve = oe();
      ne.transactions.push(ve);
    }
    const ae = ne.getWitnessCommit();
    return ae && (ne.witnessCommit = ae), ne;
  }
  static fromHex(z) {
    return Block.fromBuffer(Buffer$1.from(z, "hex"));
  }
  static calculateTarget(z) {
    const Y = ((z & 4278190080) >> 24) - 3, ne = z & 8388607, oe = Buffer$1.alloc(32, 0);
    return oe.writeUIntBE(ne, 29 - Y, 3), oe;
  }
  static calculateMerkleRoot(z, Y) {
    if (typeforce([{ getHash: types.Function }], z), z.length === 0) throw errorMerkleNoTxes;
    if (Y && !txesHaveWitnessCommit(z))
      throw errorWitnessNotSegwit;
    const ne = z.map(
      (ie) => ie.getHash(Y)
    ), oe = (0, merkle_1.fastMerkleRoot)(ne, bcrypto.hash256);
    return Y ? bcrypto.hash256(
      Buffer$1.concat([oe, z[0].ins[0].witness[0]])
    ) : oe;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const z = this.transactions[0].outs.filter(
      (ne) => ne.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((ne) => ne.script.slice(6, 38));
    if (z.length === 0) return null;
    const Y = z[z.length - 1];
    return Y instanceof Buffer$1 && Y.length === 32 ? Y : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const z = this.byteLength(!1, !1), Y = this.byteLength(!1, !0);
    return z * 3 + Y;
  }
  byteLength(z, Y = !0) {
    return z || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((ne, oe) => ne + oe.byteLength(Y), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const z = /* @__PURE__ */ new Date(0);
    return z.setUTCSeconds(this.timestamp), z;
  }
  // TODO: buffer, offset compatibility
  toBuffer(z) {
    const Y = Buffer$1.allocUnsafe(this.byteLength(z)), ne = new bufferutils_1$1.BufferWriter(Y);
    return ne.writeInt32(this.version), ne.writeSlice(this.prevHash), ne.writeSlice(this.merkleRoot), ne.writeUInt32(this.timestamp), ne.writeUInt32(this.bits), ne.writeUInt32(this.nonce), z || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      Y,
      ne.offset
    ), ne.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((oe) => {
      const ie = oe.byteLength();
      oe.toBuffer(Y, ne.offset), ne.offset += ie;
    })), Y;
  }
  toHex(z) {
    return this.toBuffer(z).toString("hex");
  }
  checkTxRoots() {
    const z = this.hasWitnessCommit();
    return !z && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (z ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const z = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), Y = Block.calculateTarget(this.bits);
    return z.compare(Y) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const z = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(z) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const z = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(z) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (z) => typeof z == "object" && z.ins instanceof Array && z.ins.some(
      (Y) => typeof Y == "object" && Y.witness instanceof Array && Y.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(z) {
    z[z.UNSIGNED_TX = 0] = "UNSIGNED_TX", z[z.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(z) {
    z[z.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", z[z.WITNESS_UTXO = 1] = "WITNESS_UTXO", z[z.PARTIAL_SIG = 2] = "PARTIAL_SIG", z[z.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", z[z.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", z[z.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", z[z.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", z[z.POR_COMMITMENT = 9] = "POR_COMMITMENT", z[z.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", z[z.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", z[z.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", z[z.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", z[z.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(z) {
    z[z.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", z[z.TAP_TREE = 6] = "TAP_TREE", z[z.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (B) => [...Array(B).keys()];
function decode$d(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const z = B.key.slice(1), Y = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: z,
    path: "m"
  };
  for (const ne of range$2(B.value.length / 4 - 1)) {
    const oe = B.value.readUInt32LE(ne * 4 + 4), ie = !!(oe & 2147483648), ae = oe & 2147483647;
    Y.path += "/" + ae.toString(10) + (ie ? "'" : "");
  }
  return Y;
}
globalXpub$1.decode = decode$d;
function encode$e(B) {
  const z = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), Y = Buffer$1.concat([z, B.extendedPubkey]), ne = B.path.split("/"), oe = Buffer$1.allocUnsafe(ne.length * 4);
  B.masterFingerprint.copy(oe, 0);
  let ie = 4;
  return ne.slice(1).forEach((ae) => {
    const se = ae.slice(-1) === "'";
    let ve = 2147483647 & parseInt(se ? ae.slice(0, -1) : ae, 10);
    se && (ve += 2147483648), oe.writeUInt32LE(ve, ie), ie += 4;
  }), {
    key: Y,
    value: oe
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const z = B.extendedPubkey, Y = B.masterFingerprint, ne = B.path;
  return Buffer$1.isBuffer(z) && z.length === 78 && [2, 3].indexOf(z[45]) > -1 && Buffer$1.isBuffer(Y) && Y.length === 4 && typeof ne == "string" && !!ne.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, z, Y) {
  const ne = z.extendedPubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((oe) => oe.extendedPubkey.equals(z.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(B) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(B) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$1.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, z) {
  return !!B && !!z && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(B) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$1.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, z) {
  return !!B && !!z && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(B) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$1.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, z) {
  return !!B && !!z && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(B) {
  const z = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([z, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$1.isBuffer(B.pubkey) && Buffer$1.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$1.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const z = B[3];
  if (z > 33 || z < 1 || B[3 + z + 1] !== 2) return !1;
  const Y = B[3 + z + 2];
  return !(Y > 33 || Y < 1 || B.length !== 3 + z + 2 + Y + 2);
}
function canAddToArray$2(B, z, Y) {
  const ne = z.pubkey.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((oe) => oe.pubkey.equals(z.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(B) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, z) {
  return !!B && !!z && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(B) {
  const z = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), Y = Buffer$1.allocUnsafe(4);
  return Y.writeUInt32LE(B, 0), {
    key: z,
    value: Y
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, z) {
  return !!B && !!z && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(B) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$1.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, z) {
  return !!B && !!z && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const z = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== z)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const Y = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: Y, leafVersion: z };
}
tapLeafScript$1.decode = decode$5;
function encode$5(B) {
  const z = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), Y = Buffer$1.from([B.leafVersion]);
  return {
    key: Buffer$1.concat([z, B.controlBlock]),
    value: Buffer$1.concat([B.script, Y])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$1.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$1.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, z, Y) {
  const ne = z.controlBlock.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter((oe) => oe.controlBlock.equals(z.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(B) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$1.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, z) {
  return !!B && !!z && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const z = B.key.slice(1, 33), Y = B.key.slice(33);
  return {
    pubkey: z,
    leafHash: Y,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(B) {
  const z = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([z, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$1.isBuffer(B.pubkey) && Buffer$1.isBuffer(B.leafHash) && Buffer$1.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, z, Y) {
  const ne = z.pubkey.toString("hex") + z.leafHash.toString("hex");
  return Y.has(ne) ? !1 : (Y.add(ne), B.filter(
    (oe) => oe.pubkey.equals(z.pubkey) && oe.leafHash.equals(z.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(B, z, Y) {
  if (checkUInt53(B), z || (z = Buffer$1.allocUnsafe(encodingLength(B))), !Buffer$1.isBuffer(z))
    throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), Object.assign(encode$2, { bytes: 1 })) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), Object.assign(encode$2, { bytes: 3 })) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), Object.assign(encode$2, { bytes: 5 })) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), Object.assign(encode$2, { bytes: 9 })), z;
}
varint.encode = encode$2;
function decode$2(B, z) {
  if (!Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  const Y = B.readUInt8(z);
  if (Y < 253)
    return Object.assign(decode$2, { bytes: 1 }), Y;
  if (Y === 253)
    return Object.assign(decode$2, { bytes: 3 }), B.readUInt16LE(z + 1);
  if (Y === 254)
    return Object.assign(decode$2, { bytes: 5 }), B.readUInt32LE(z + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const ne = B.readUInt32LE(z + 1), ie = B.readUInt32LE(z + 5) * 4294967296 + ne;
    return checkUInt53(ie), ie;
  }
}
varint.decode = decode$2;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ne = 0; ne < B.length / 2; ne++)
    Y = B[ne], B[ne] = B[z], B[z] = Y, z--;
  return B;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(B) {
  const z = B.map(keyValToBuffer);
  return z.push(Buffer$1.from([0])), Buffer$1.concat(z);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const z = B.key.length, Y = B.value.length, ne = varuint$6.encodingLength(z), oe = varuint$6.encodingLength(Y), ie = Buffer$1.allocUnsafe(
    ne + z + oe + Y
  );
  return varuint$6.encode(z, ie, 0), B.key.copy(ie, ne), varuint$6.encode(Y, ie, ne + z), B.value.copy(ie, ne + z + oe), ie;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, z) {
  const Y = B.readUInt32LE(z);
  let ne = B.readUInt32LE(z + 4);
  return ne *= 4294967296, verifuint(ne + Y, 9007199254740991), ne + Y;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, z, Y) {
  return verifuint(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const z = tools_1$2.readUInt64LE(B.value, 0);
  let Y = 8;
  const ne = varuint$5.decode(B.value, Y);
  Y += varuint$5.encodingLength(ne);
  const oe = B.value.slice(Y);
  if (oe.length !== ne)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: oe,
    value: z
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(B) {
  const { script: z, value: Y } = B, ne = varuint$5.encodingLength(z.length), oe = Buffer$1.allocUnsafe(8 + ne + z.length);
  return tools_1$2.writeUInt64LE(oe, Y, 0), varuint$5.encode(z.length, oe, 8), z.copy(oe, 8 + ne), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: oe
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$1.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, z) {
  return !!B && !!z && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let z = 0;
  const Y = [];
  for (; z < B.value.length; ) {
    const ne = B.value[z++], oe = B.value[z++], ie = varuint$4.decode(B.value, z);
    z += varuint$4.encodingLength(ie), Y.push({
      depth: ne,
      leafVersion: oe,
      script: B.value.slice(z, z + ie)
    }), z += ie;
  }
  return { leaves: Y };
}
tapTree$1.decode = decode;
function encode(B) {
  const z = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), Y = [].concat(
    ...B.leaves.map((ne) => [
      Buffer$1.of(ne.depth, ne.leafVersion),
      varuint$4.encode(ne.script.length),
      ne.script
    ])
  );
  return {
    key: z,
    value: Buffer$1.concat(Y)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (z) => z.depth >= 0 && z.depth <= 128 && (z.leafVersion & 254) === z.leafVersion && Buffer$1.isBuffer(z.script)
  );
}
tapTree$1.check = check;
function canAdd(B, z) {
  return !!B && !!z && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, z = isValidDERKey) {
  function Y(se) {
    if (se.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + se.key.toString("hex")
      );
    const ve = se.key.slice(1);
    if (!z(ve))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + se.key.toString("hex")
      );
    if (se.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const ge = {
      masterFingerprint: se.value.slice(0, 4),
      pubkey: ve,
      path: "m"
    };
    for (const le of range$1(se.value.length / 4 - 1)) {
      const Ee = se.value.readUInt32LE(le * 4 + 4), Ce = !!(Ee & 2147483648), Pe = Ee & 2147483647;
      ge.path += "/" + Pe.toString(10) + (Ce ? "'" : "");
    }
    return ge;
  }
  function ne(se) {
    const ve = Buffer$1.from([B]), ge = Buffer$1.concat([ve, se.pubkey]), le = se.path.split("/"), Ee = Buffer$1.allocUnsafe(le.length * 4);
    se.masterFingerprint.copy(Ee, 0);
    let Ce = 4;
    return le.slice(1).forEach((Pe) => {
      const Xe = Pe.slice(-1) === "'";
      let ht = 2147483647 & parseInt(Xe ? Pe.slice(0, -1) : Pe, 10);
      Xe && (ht += 2147483648), Ee.writeUInt32LE(ht, Ce), Ce += 4;
    }), {
      key: ge,
      value: Ee
    };
  }
  const oe = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function ie(se) {
    return Buffer$1.isBuffer(se.pubkey) && Buffer$1.isBuffer(se.masterFingerprint) && typeof se.path == "string" && z(se.pubkey) && se.masterFingerprint.length === 4;
  }
  function ae(se, ve, ge) {
    const le = ve.pubkey.toString("hex");
    return ge.has(le) ? !1 : (ge.add(le), se.filter((Ee) => Ee.pubkey.equals(ve.pubkey)).length === 0);
  }
  return {
    decode: Y,
    encode: ne,
    check: ie,
    expected: oe,
    canAddToArray: ae
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return z;
  function z(Y) {
    let ne;
    if (B.includes(Y.key[0]) && (ne = Y.key.slice(1), !(ne.length === 33 || ne.length === 65) || ![2, 3, 4].includes(ne[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Y.key.toString("hex")
      );
    return ne;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function z(ae) {
    if (ae.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + ae.key.toString("hex")
      );
    return ae.value;
  }
  function Y(ae) {
    return {
      key: Buffer$1.from([B]),
      value: ae
    };
  }
  const ne = "Buffer";
  function oe(ae) {
    return Buffer$1.isBuffer(ae);
  }
  function ie(ae, se) {
    return !!ae && !!se && ae.redeemScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: oe,
    expected: ne,
    canAdd: ie
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const z = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function Y(ae) {
    const se = varuint$3.decode(ae.value), ve = varuint$3.encodingLength(se), ge = z.decode({
      key: ae.key,
      value: ae.value.slice(ve + se * 32)
    }), le = new Array(se);
    for (let Ee = 0, Ce = ve; Ee < se; Ee++, Ce += 32)
      le[Ee] = ae.value.slice(Ce, Ce + 32);
    return Object.assign({}, ge, { leafHashes: le });
  }
  function ne(ae) {
    const se = z.encode(ae), ve = varuint$3.encodingLength(ae.leafHashes.length), ge = Buffer$1.allocUnsafe(ve);
    varuint$3.encode(ae.leafHashes.length, ge);
    const le = Buffer$1.concat([ge, ...ae.leafHashes, se.value]);
    return Object.assign({}, se, { value: le });
  }
  const oe = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function ie(ae) {
    return Array.isArray(ae.leafHashes) && ae.leafHashes.every(
      (se) => Buffer$1.isBuffer(se) && se.length === 32
    ) && z.check(ae);
  }
  return {
    decode: Y,
    encode: ne,
    check: ie,
    expected: oe,
    canAddToArray: z.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function z(ae) {
    if (ae.key[0] !== B || ae.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + ae.key.toString("hex")
      );
    if (ae.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return ae.value;
  }
  function Y(ae) {
    return { key: Buffer$1.from([B]), value: ae };
  }
  const ne = "Buffer";
  function oe(ae) {
    return Buffer$1.isBuffer(ae) && ae.length === 32;
  }
  function ie(ae, se) {
    return !!ae && !!se && ae.tapInternalKey === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: oe,
    expected: ne,
    canAdd: ie
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function z(ae) {
    if (ae.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + ae.key.toString("hex")
      );
    return ae.value;
  }
  function Y(ae) {
    return {
      key: Buffer$1.from([B]),
      value: ae
    };
  }
  const ne = "Buffer";
  function oe(ae) {
    return Buffer$1.isBuffer(ae);
  }
  function ie(ae, se) {
    return !!ae && !!se && ae.witnessScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: oe,
    expected: ne,
    canAdd: ie
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, z) {
  let Y = 0;
  function ne() {
    const wt = varuint$2.decode(B, Y);
    Y += varuint$2.encodingLength(wt);
    const Pt = B.slice(Y, Y + wt);
    return Y += wt, Pt;
  }
  function oe() {
    const wt = B.readUInt32BE(Y);
    return Y += 4, wt;
  }
  function ie() {
    const wt = B.readUInt8(Y);
    return Y += 1, wt;
  }
  function ae() {
    const wt = ne(), Pt = ne();
    return {
      key: wt,
      value: Pt
    };
  }
  function se() {
    if (Y >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const wt = B.readUInt8(Y) === 0;
    return wt && Y++, wt;
  }
  if (oe() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (ie() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ve = [], ge = {};
  for (; !se(); ) {
    const wt = ae(), Pt = wt.key.toString("hex");
    if (ge[Pt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + Pt
      );
    ge[Pt] = 1, ve.push(wt);
  }
  const le = ve.filter(
    (wt) => wt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (le.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const Ee = z(le[0].value), { inputCount: Ce, outputCount: Pe } = Ee.getInputOutputCounts(), Xe = [], ht = [];
  for (const wt of tools_1$1.range(Ce)) {
    const Pt = {}, vt = [];
    for (; !se(); ) {
      const Bt = ae(), Ct = Bt.key.toString("hex");
      if (Pt[Ct])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + wt + " key " + Ct
        );
      Pt[Ct] = 1, vt.push(Bt);
    }
    Xe.push(vt);
  }
  for (const wt of tools_1$1.range(Pe)) {
    const Pt = {}, vt = [];
    for (; !se(); ) {
      const Bt = ae(), Ct = Bt.key.toString("hex");
      if (Pt[Ct])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + wt + " key " + Ct
        );
      Pt[Ct] = 1, vt.push(Bt);
    }
    ht.push(vt);
  }
  return psbtFromKeyVals(Ee, {
    globalMapKeyVals: ve,
    inputKeyVals: Xe,
    outputKeyVals: ht
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, z, Y) {
  if (!z.equals(Buffer$1.from([Y])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${z.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: z, inputKeyVals: Y, outputKeyVals: ne }) {
  const oe = {
    unsignedTx: B
  };
  let ie = 0;
  for (const le of z)
    switch (le.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          le.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), ie > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        ie++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        oe.globalXpub === void 0 && (oe.globalXpub = []), oe.globalXpub.push(convert$1.globals.globalXpub.decode(le));
        break;
      default:
        oe.unknownKeyVals || (oe.unknownKeyVals = []), oe.unknownKeyVals.push(le);
    }
  const ae = Y.length, se = ne.length, ve = [], ge = [];
  for (const le of tools_1$1.range(ae)) {
    const Ee = {};
    for (const Ce of Y[le])
      switch (convert$1.inputs.checkPubkey(Ce), Ce.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), Ee.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          Ee.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), Ee.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          Ee.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          Ee.partialSig === void 0 && (Ee.partialSig = []), Ee.partialSig.push(convert$1.inputs.partialSig.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), Ee.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          Ee.sighashType = convert$1.inputs.sighashType.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.inputs.redeemScript.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.inputs.witnessScript.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), Ee.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), Ee.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Ce
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), Ee.porCommitment = convert$1.inputs.porCommitment.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), Ee.tapKeySig = convert$1.inputs.tapKeySig.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          Ee.tapScriptSig === void 0 && (Ee.tapScriptSig = []), Ee.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          Ee.tapLeafScript === void 0 && (Ee.tapLeafScript = []), Ee.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Ce));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Ce);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Ce.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), Ee.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Ce);
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Ce);
      }
    ve.push(Ee);
  }
  for (const le of tools_1$1.range(se)) {
    const Ee = {};
    for (const Ce of ne[le])
      switch (convert$1.outputs.checkPubkey(Ce), Ce.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), Ee.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          Ee.redeemScript = convert$1.outputs.redeemScript.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), Ee.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          Ee.witnessScript = convert$1.outputs.witnessScript.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          Ee.bip32Derivation === void 0 && (Ee.bip32Derivation = []), Ee.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Ce)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), Ee.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Ce.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), Ee.tapTree = convert$1.outputs.tapTree.decode(Ce);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          Ee.tapBip32Derivation === void 0 && (Ee.tapBip32Derivation = []), Ee.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Ce)
          );
          break;
        default:
          Ee.unknownKeyVals || (Ee.unknownKeyVals = []), Ee.unknownKeyVals.push(Ce);
      }
    ge.push(Ee);
  }
  return { globalMap: oe, inputs: ve, outputs: ge };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: z, outputs: Y }) {
  const { globalKeyVals: ne, inputKeyVals: oe, outputKeyVals: ie } = psbtToKeyVals({
    globalMap: B,
    inputs: z,
    outputs: Y
  }), ae = tools_1.keyValsToBuffer(ne), se = (Ee) => Ee.length === 0 ? [Buffer$1.from([0])] : Ee.map(tools_1.keyValsToBuffer), ve = se(oe), ge = se(ie), le = Buffer$1.allocUnsafe(5);
  return le.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [le, ae].concat(ve, ge)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, z) => B.key.compare(z.key);
function keyValsFromMap(B, z) {
  const Y = /* @__PURE__ */ new Set(), ne = Object.entries(B).reduce((ie, [ae, se]) => {
    if (ae === "unknownKeyVals") return ie;
    const ve = z[ae];
    if (ve === void 0) return ie;
    const ge = (Array.isArray(se) ? se : [se]).map(
      ve.encode
    );
    return ge.map((Ee) => Ee.key.toString("hex")).forEach((Ee) => {
      if (Y.has(Ee))
        throw new Error("Serialize Error: Duplicate key: " + Ee);
      Y.add(Ee);
    }), ie.concat(ge);
  }, []), oe = B.unknownKeyVals ? B.unknownKeyVals.filter((ie) => !Y.has(ie.key.toString("hex"))) : [];
  return ne.concat(oe).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: z, outputs: Y }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: z.map((ne) => keyValsFromMap(ne, convert.inputs)),
    outputKeyVals: Y.map((ne) => keyValsFromMap(ne, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function z(Y) {
    for (var ne in Y) B.hasOwnProperty(ne) || (B[ne] = Y[ne]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), z(fromBuffer), z(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const z = B[0], Y = parser_1$1.psbtToKeyVals(z), ne = B.slice(1);
  if (ne.length === 0) throw new Error("Combine: Nothing to combine");
  const oe = getTx(z);
  if (oe === void 0)
    throw new Error("Combine: Self missing transaction");
  const ie = getKeySet(Y.globalKeyVals), ae = Y.inputKeyVals.map(getKeySet), se = Y.outputKeyVals.map(getKeySet);
  for (const ve of ne) {
    const ge = getTx(ve);
    if (ge === void 0 || !ge.toBuffer().equals(oe.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const le = parser_1$1.psbtToKeyVals(ve);
    getKeySet(le.globalKeyVals).forEach(
      keyPusher(
        ie,
        Y.globalKeyVals,
        le.globalKeyVals
      )
    ), le.inputKeyVals.map(getKeySet).forEach(
      (Xe, ht) => Xe.forEach(
        keyPusher(
          ae[ht],
          Y.inputKeyVals[ht],
          le.inputKeyVals[ht]
        )
      )
    ), le.outputKeyVals.map(getKeySet).forEach(
      (Xe, ht) => Xe.forEach(
        keyPusher(
          se[ht],
          Y.outputKeyVals[ht],
          le.outputKeyVals[ht]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(oe, {
    globalMapKeyVals: Y.globalKeyVals,
    inputKeyVals: Y.inputKeyVals,
    outputKeyVals: Y.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, z, Y) {
  return (ne) => {
    if (B.has(ne)) return;
    const oe = Y.filter((ie) => ie.key.toString("hex") === ne)[0];
    z.push(oe), B.add(ne);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const z = /* @__PURE__ */ new Set();
  return B.forEach((Y) => {
    const ne = Y.key.toString("hex");
    if (z.has(ne))
      throw new Error("Combine: KeyValue Map keys should be unique");
    z.add(ne);
  }), z;
}
var utils = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const z = converter;
  function Y(Pe, Xe) {
    const ht = Pe[Xe];
    if (ht === void 0) throw new Error(`No input #${Xe}`);
    return ht;
  }
  B.checkForInput = Y;
  function ne(Pe, Xe) {
    const ht = Pe[Xe];
    if (ht === void 0) throw new Error(`No output #${Xe}`);
    return ht;
  }
  B.checkForOutput = ne;
  function oe(Pe, Xe, ht) {
    if (Pe.key[0] < ht)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (Xe && Xe.filter((wt) => wt.key.equals(Pe.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Pe.key.toString("hex")}`);
  }
  B.checkHasKey = oe;
  function ie(Pe) {
    let Xe = 0;
    return Object.keys(Pe).forEach((ht) => {
      Number(isNaN(Number(ht))) && Xe++;
    }), Xe;
  }
  B.getEnumLength = ie;
  function ae(Pe, Xe) {
    let ht = !1;
    if (Xe.nonWitnessUtxo || Xe.witnessUtxo) {
      const wt = !!Xe.redeemScript, Pt = !!Xe.witnessScript, vt = !wt || !!Xe.finalScriptSig, Bt = !Pt || !!Xe.finalScriptWitness, Ct = !!Xe.finalScriptSig || !!Xe.finalScriptWitness;
      ht = vt && Bt && Ct;
    }
    if (ht === !1)
      throw new Error(
        `Input #${Pe} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = ae;
  function se(Pe, Xe, ht, wt) {
    throw new Error(
      `Data for ${Pe} key ${Xe} is incorrect: Expected ${ht} and got ${JSON.stringify(wt)}`
    );
  }
  function ve(Pe) {
    return (Xe, ht) => {
      for (const wt of Object.keys(Xe)) {
        const Pt = Xe[wt], { canAdd: vt, canAddToArray: Bt, check: Ct, expected: Wt } = (
          // @ts-ignore
          z[Pe + "s"][wt] || {}
        ), Kt = !!Bt;
        if (Ct)
          if (Kt) {
            if (!Array.isArray(Pt) || // @ts-ignore
            ht[wt] && !Array.isArray(ht[wt]))
              throw new Error(`Key type ${wt} must be an array`);
            Pt.every(Ct) || se(Pe, wt, Wt, Pt);
            const Yt = ht[wt] || [], Ut = /* @__PURE__ */ new Set();
            if (!Pt.every((qt) => Bt(Yt, qt, Ut)))
              throw new Error("Can not add duplicate data to array");
            ht[wt] = Yt.concat(Pt);
          } else {
            if (Ct(Pt) || se(Pe, wt, Wt, Pt), !vt(ht, Pt))
              throw new Error(`Can not add duplicate data to ${Pe}`);
            ht[wt] = Pt;
          }
      }
    };
  }
  B.updateGlobal = ve("global"), B.updateInput = ve("input"), B.updateOutput = ve("output");
  function ge(Pe, Xe) {
    const ht = Pe.length - 1, wt = Y(Pe, ht);
    B.updateInput(Xe, wt);
  }
  B.addInputAttributes = ge;
  function le(Pe, Xe) {
    const ht = Pe.length - 1, wt = ne(Pe, ht);
    B.updateOutput(Xe, wt);
  }
  B.addOutputAttributes = le;
  function Ee(Pe, Xe) {
    if (!Buffer$1.isBuffer(Xe) || Xe.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return Xe.writeUInt32LE(Pe, 0), Xe;
  }
  B.defaultVersionSetter = Ee;
  function Ce(Pe, Xe) {
    if (!Buffer$1.isBuffer(Xe) || Xe.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return Xe.writeUInt32LE(Pe, Xe.length - 4), Xe;
  }
  B.defaultLocktimeSetter = Ce;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(z) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: z
    };
  }
  static fromBase64(z, Y) {
    const ne = Buffer$1.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y) {
    const ne = Buffer$1.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y) {
    const ne = parser_1.psbtFromBuffer(z, Y), oe = new this(ne.globalMap.unsignedTx);
    return Object.assign(oe, ne), oe;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(z) {
    return utils_1$1.updateGlobal(z, this.globalMap), this;
  }
  updateInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.updateInput(Y, ne), this;
  }
  updateOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.updateOutput(Y, ne), this;
  }
  addUnknownKeyValToGlobal(z) {
    return utils_1$1.checkHasKey(
      z,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    const ne = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    const ne = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ne.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), ne.unknownKeyVals || (ne.unknownKeyVals = []), ne.unknownKeyVals.push(Y), this;
  }
  addInput(z) {
    this.globalMap.unsignedTx.addInput(z), this.inputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.inputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (oe) => this.addUnknownKeyValToInput(ne, oe)
    ), utils_1$1.addInputAttributes(this.inputs, z), this;
  }
  addOutput(z) {
    this.globalMap.unsignedTx.addOutput(z), this.outputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ne = this.outputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (oe) => this.addUnknownKeyValToOutput(ne, oe)
    ), utils_1$1.addOutputAttributes(this.outputs, z), this;
  }
  clearFinalizedInput(z) {
    const Y = utils_1$1.checkForInput(this.inputs, z);
    utils_1$1.inputCheckUncleanFinalized(z, Y);
    for (const ne of Object.keys(Y))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(ne) || delete Y[ne];
    return this;
  }
  combine(...z) {
    const Y = combiner_1.combine([this].concat(z));
    return Object.assign(this, Y), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(B) {
  return (z) => {
    try {
      return B({ output: z }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let z = Buffer$1.allocUnsafe(0);
  function Y(ae) {
    z = Buffer$1.concat([z, Buffer$1.from(ae)]);
  }
  function ne(ae) {
    const se = z.length, ve = varuint$1.encodingLength(ae);
    z = Buffer$1.concat([z, Buffer$1.allocUnsafe(ve)]), varuint$1.encode(ae, z, se);
  }
  function oe(ae) {
    ne(ae.length), Y(ae);
  }
  function ie(ae) {
    ne(ae.length), ae.forEach(oe);
  }
  return ie(B), z;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, z) {
  const Y = (0, crypto_1.hash160)(B), ne = B.slice(1, 33), oe = bscript$1.decompile(z);
  if (oe === null) throw new Error("Unknown script error");
  return oe.findIndex((ie) => typeof ie == "number" ? !1 : ie.equals(B) || ie.equals(Y) || ie.equals(ne));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, z) {
  return pubkeyPositionInScript(B, z) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, z) {
  return extractPartialSigs(B).some(
    (ne) => signatureBlocksAction(ne, bscript$1.signature.decode, z)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, z, Y) {
  const { hashType: ne } = z(B), oe = [];
  switch (ne & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && oe.push("addInput"), ne & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      oe.push("addOutput"), oe.push("setInputSequence");
      break;
  }
  return oe.indexOf(Y) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let z = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    z = getPsigsFromInputFinalScripts(B);
  } else
    z = B.partialSig;
  return z.map((Y) => Y.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const z = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], Y = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return z.concat(Y).filter((ne) => Buffer$1.isBuffer(ne) && bscript$1.isCanonicalScriptSignature(ne)).map((ne) => ({ signature: ne }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(B, z, Y) {
  const ne = findTapLeafToFinalize(
    z,
    B,
    Y
  );
  try {
    const ie = sortSignatures(z, ne).concat(ne.script).concat(ne.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(ie)
    };
  } catch (oe) {
    throw new Error(`Can not finalize taproot input #${B}: ${oe}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, z) {
  const Y = z ? Buffer$1.from([z]) : Buffer$1.from([]);
  return Buffer$1.concat([B, Y]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, z) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || z && (0, psbtutils_1$1.isP2TR)(z));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootInputFields(B, z, Y), checkIfTapLeafInTree(B, z, Y);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootOutputFields(B, z, Y), checkTaprootScriptPubkey(B, z);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, z) {
  if (!z.tapTree && !z.tapInternalKey) return;
  const Y = z.tapInternalKey || B.tapInternalKey, ne = z.tapTree || B.tapTree;
  if (Y) {
    const { script: oe } = B, ie = getTaprootScripPubkey(Y, ne);
    if (oe && !oe.equals(ie))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, z) {
  const Y = z && tapTreeFromList(z.leaves), { output: ne } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: Y
  });
  return ne;
}
function tweakInternalPubKey(B, z) {
  const Y = z.tapInternalKey, ne = Y && (0, bip341_1$1.tweakKey)(Y, z.tapMerkleRoot);
  if (!ne)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${Y && Y.toString("hex")}`
    );
  return ne.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, z) {
  return extractTaprootSigs(B).some(
    (ne) => (0, psbtutils_2.signatureBlocksAction)(ne, decodeSchnorrSignature, z)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const z = [];
  if (B.tapKeySig && z.push(B.tapKeySig), B.tapScriptSig && z.push(...B.tapScriptSig.map((Y) => Y.signature)), !z.length) {
    const Y = getTapKeySigFromWithness(B.finalScriptWitness);
    Y && z.push(Y);
  }
  return z;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const z = B.slice(2);
  if (z.length === 64 || z.length === 65) return z;
}
function _tapTreeToList(B, z = [], Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (z.push({
    depth: Y,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), z) : (B[0] && _tapTreeToList(B[0], z, Y + 1), B[1] && _tapTreeToList(B[1], z, Y + 1), z) : [];
}
function instertLeavesInTree(B) {
  let z;
  for (const Y of B)
    if (z = instertLeafInTree(Y, z), !z) throw new Error("No room left to insert tapleaf in tree");
  return z;
}
function instertLeafInTree(B, z, Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === Y)
    return z ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(z)) return;
  const ne = instertLeafInTree(B, z && z[0], Y + 1);
  if (ne) return [ne, z && z[1]];
  const oe = instertLeafInTree(B, z && z[1], Y + 1);
  if (oe) return [z && z[0], oe];
}
function checkMixedTaprootAndNonTaprootInputFields(B, z, Y) {
  const ne = isTaprootInput(B) && hasNonTaprootFields(z), oe = hasNonTaprootFields(B) && isTaprootInput(z), ie = B === z && isTaprootInput(z) && hasNonTaprootFields(z);
  if (ne || oe || ie)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, z, Y) {
  const ne = isTaprootOutput(B) && hasNonTaprootFields(z), oe = hasNonTaprootFields(B) && isTaprootOutput(z), ie = B === z && isTaprootOutput(z) && hasNonTaprootFields(z);
  if (ne || oe || ie)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, z, Y) {
  if (z.tapMerkleRoot) {
    const ne = (z.tapLeafScript || []).every(
      (ie) => isTapLeafInTree(ie, z.tapMerkleRoot)
    ), oe = (B.tapLeafScript || []).every(
      (ie) => isTapLeafInTree(ie, z.tapMerkleRoot)
    );
    if (!ne || !oe)
      throw new Error(
        `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(z.tapLeafScript || []).every(
    (oe) => isTapLeafInTree(oe, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, z) {
  if (!z) return !0;
  const Y = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    Y
  ).equals(z);
}
function sortSignatures(B, z) {
  const Y = (0, bip341_1$1.tapleafHash)({
    output: z.script,
    version: z.leafVersion
  });
  return (B.tapScriptSig || []).filter((ne) => ne.leafHash.equals(Y)).map((ne) => addPubkeyPositionInScript(z.script, ne)).sort((ne, oe) => oe.positionInScript - ne.positionInScript).map((ne) => ne.signature);
}
function addPubkeyPositionInScript(B, z) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        z.pubkey,
        B
      )
    },
    z
  );
}
function findTapLeafToFinalize(B, z, Y) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${z}. No tapleaf script signature provided.`
    );
  const ne = (B.tapLeafScript || []).sort((oe, ie) => oe.controlBlock.length - ie.controlBlock.length).find(
    (oe) => canFinalizeLeaf(oe, B.tapScriptSig, Y)
  );
  if (!ne)
    throw new Error(
      `Can not finalize taproot input #${z}. Signature for tapleaf script not found.`
    );
  return ne;
}
function canFinalizeLeaf(B, z, Y) {
  const ne = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!Y || Y.equals(ne)) && z.find((ie) => ie.leafHash.equals(ne)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(z, Y = {}) {
    const ne = Buffer$1.from(z, "base64");
    return this.fromBuffer(ne, Y);
  }
  static fromHex(z, Y = {}) {
    const ne = Buffer$1.from(z, "hex");
    return this.fromBuffer(ne, Y);
  }
  static fromBuffer(z, Y = {}) {
    const ne = bip174_1.Psbt.fromBuffer(z, transactionFromBuffer), oe = new Psbt(Y, ne);
    return checkTxForDupeIns(oe.__CACHE.__TX, oe.__CACHE), oe;
  }
  constructor(z = {}, Y = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = Y, this.opts = Object.assign({}, DEFAULT_OPTS, z), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const ne = (oe, ie, ae, se) => Object.defineProperty(oe, ie, {
      enumerable: ae,
      writable: se
    });
    ne(this, "__CACHE", !1, !0), ne(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(z) {
    this.setVersion(z);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(z) {
    this.setLocktime(z);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((z) => ({
      hash: (0, bufferutils_1.cloneBuffer)(z.hash),
      index: z.index,
      sequence: z.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((z) => {
      let Y;
      try {
        Y = (0, address_1.fromOutputScript)(
          z.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(z.script),
        value: z.value,
        address: Y
      };
    });
  }
  combine(...z) {
    return this.data.combine(...z.map((Y) => Y.data)), this;
  }
  clone() {
    const z = Psbt.fromBuffer(this.data.toBuffer());
    return z.opts = JSON.parse(JSON.stringify(this.opts)), z;
  }
  setMaximumFeeRate(z) {
    check32Bit(z), this.opts.maximumFeeRate = z;
  }
  setVersion(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const Y = this.__CACHE;
    return Y.__TX.version = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const Y = this.__CACHE;
    return Y.__TX.locktime = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(z, Y) {
    check32Bit(Y), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const ne = this.__CACHE;
    if (ne.__TX.ins.length <= z)
      throw new Error("Input index too high");
    return ne.__TX.ins[z].sequence = Y, ne.__EXTRACTED_TX = void 0, this;
  }
  addInputs(z) {
    return z.forEach((Y) => this.addInput(Y)), this;
  }
  addInput(z) {
    if (arguments.length > 1 || !z || z.hash === void 0 || z.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(z, z, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), z.witnessScript && checkInvalidP2WSH(z.witnessScript);
    const Y = this.__CACHE;
    this.data.addInput(z);
    const ne = Y.__TX.ins[Y.__TX.ins.length - 1];
    checkTxInputCache(Y, ne);
    const oe = this.data.inputs.length - 1, ie = this.data.inputs[oe];
    return ie.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, ie, oe), Y.__FEE = void 0, Y.__FEE_RATE = void 0, Y.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(z) {
    return z.forEach((Y) => this.addOutput(Y)), this;
  }
  addOutput(z) {
    if (arguments.length > 1 || !z || z.value === void 0 || z.address === void 0 && z.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: Y } = z;
    if (typeof Y == "string") {
      const { network: oe } = this.opts, ie = (0, address_1.toOutputScript)(Y, oe);
      z = Object.assign({}, z, { script: ie });
    }
    (0, bip371_1.checkTaprootOutputFields)(z, z, "addOutput");
    const ne = this.__CACHE;
    return this.data.addOutput(z), ne.__FEE = void 0, ne.__FEE_RATE = void 0, ne.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(z) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const Y = this.__CACHE;
    if (z || checkFees(this, Y, this.opts), Y.__EXTRACTED_TX) return Y.__EXTRACTED_TX;
    const ne = Y.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, ne, Y, !0), ne;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((z) => this.finalizeInput(z)), this;
  }
  finalizeInput(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ne) ? this._finalizeTaprootInput(
      z,
      ne,
      void 0,
      Y
    ) : this._finalizeInput(z, ne, Y);
  }
  finalizeTaprootInput(z, Y, ne = bip371_1.tapScriptFinalizer) {
    const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(oe))
      return this._finalizeTaprootInput(
        z,
        oe,
        Y,
        ne
      );
    throw new Error(`Cannot finalize input #${z}. Not Taproot.`);
  }
  _finalizeInput(z, Y, ne = getFinalScripts) {
    const { script: oe, isP2SH: ie, isP2WSH: ae, isSegwit: se } = getScriptFromInput(
      z,
      Y,
      this.__CACHE
    );
    if (!oe) throw new Error(`No script found for input #${z}`);
    checkPartialSigSighashes(Y);
    const { finalScriptSig: ve, finalScriptWitness: ge } = ne(
      z,
      Y,
      oe,
      se,
      ie,
      ae
    );
    if (ve && this.data.updateInput(z, { finalScriptSig: ve }), ge && this.data.updateInput(z, { finalScriptWitness: ge }), !ve && !ge)
      throw new Error(`Unknown error finalizing input #${z}`);
    return this.data.clearFinalizedInput(z), this;
  }
  _finalizeTaprootInput(z, Y, ne, oe = bip371_1.tapScriptFinalizer) {
    if (!Y.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${z}. Missing withness utxo.`
      );
    if (Y.tapKeySig) {
      const ie = payments.p2tr({
        output: Y.witnessUtxo.script,
        signature: Y.tapKeySig
      }), ae = (0, psbtutils_1.witnessStackToScriptWitness)(
        ie.witness
      );
      this.data.updateInput(z, { finalScriptWitness: ae });
    } else {
      const { finalScriptWitness: ie } = oe(
        z,
        Y,
        ne
      );
      this.data.updateInput(z, { finalScriptWitness: ie });
    }
    return this.data.clearFinalizedInput(z), this;
  }
  getInputType(z) {
    const Y = (0, utils_1.checkForInput)(this.data.inputs, z), ne = getScriptFromUtxo(z, Y, this.__CACHE), oe = getMeaningfulScript(
      ne,
      z,
      "input",
      Y.redeemScript || redeemFromFinalScriptSig(Y.finalScriptSig),
      Y.witnessScript || redeemFromFinalWitnessScript(Y.finalScriptWitness)
    ), ie = oe.type === "raw" ? "" : oe.type + "-", ae = classifyScript(oe.meaningfulScript);
    return ie + ae;
  }
  inputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    return pubkeyInInput(Y, ne, z, this.__CACHE);
  }
  inputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z), oe = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(oe);
  }
  outputHasPubkey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z);
    return pubkeyInOutput(Y, ne, z, this.__CACHE);
  }
  outputHasHDKey(z, Y) {
    const ne = (0, utils_1.checkForOutput)(this.data.outputs, z), oe = bip32DerivationIsMine(Y);
    return !!ne.bip32Derivation && ne.bip32Derivation.some(oe);
  }
  validateSignaturesOfAllInputs(z) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (ne) => this.validateSignaturesOfInput(ne, z)
    ).reduce((ne, oe) => oe === !0 && ne, !0);
  }
  validateSignaturesOfInput(z, Y, ne) {
    const oe = this.data.inputs[z];
    return (0, bip371_1.isTaprootInput)(oe) ? this.validateSignaturesOfTaprootInput(
      z,
      Y,
      ne
    ) : this._validateSignaturesOfInput(z, Y, ne);
  }
  _validateSignaturesOfInput(z, Y, ne) {
    const oe = this.data.inputs[z], ie = (oe || {}).partialSig;
    if (!oe || !ie || ie.length < 1)
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    const ae = ne ? ie.filter((Ee) => Ee.pubkey.equals(ne)) : ie;
    if (ae.length < 1) throw new Error("No signatures for this pubkey");
    const se = [];
    let ve, ge, le;
    for (const Ee of ae) {
      const Ce = bscript.signature.decode(Ee.signature), { hash: Pe, script: Xe } = le !== Ce.hashType ? getHashForSig(
        z,
        Object.assign({}, oe, { sighashType: Ce.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ve, script: ge };
      le = Ce.hashType, ve = Pe, ge = Xe, checkScriptForPubkey(Ee.pubkey, Xe, "verify"), se.push(Y(Ee.pubkey, Pe, Ce.signature));
    }
    return se.every((Ee) => Ee === !0);
  }
  validateSignaturesOfTaprootInput(z, Y, ne) {
    const oe = this.data.inputs[z], ie = (oe || {}).tapKeySig, ae = (oe || {}).tapScriptSig;
    if (!oe && !ie && !(ae && !ae.length))
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    ne = ne && (0, bip371_1.toXOnly)(ne);
    const se = ne ? getTaprootHashesForSig(
      z,
      oe,
      this.data.inputs,
      ne,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      z,
      oe,
      this.data.inputs,
      this.__CACHE
    );
    if (!se.length) throw new Error("No signatures for this pubkey");
    const ve = se.find((le) => !le.leafHash);
    let ge = 0;
    if (ie && ve) {
      if (!Y(
        ve.pubkey,
        ve.hash,
        trimTaprootSig(ie)
      )) return !1;
      ge++;
    }
    if (ae)
      for (const le of ae) {
        const Ee = se.find((Ce) => le.pubkey.equals(Ce.pubkey));
        if (Ee) {
          if (!Y(
            le.pubkey,
            Ee.hash,
            trimTaprootSig(le.signature)
          )) return !1;
          ge++;
        }
      }
    return ge > 0;
  }
  signAllInputsHD(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!z || !z.publicKey || !z.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const ne = [];
    for (const oe of range(this.data.inputs.length))
      try {
        this.signInputHD(oe, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((oe) => oe === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ne, oe) => {
      if (!z || !z.publicKey || !z.fingerprint)
        return oe(new Error("Need HDSigner to sign input"));
      const ie = [], ae = [];
      for (const se of range(this.data.inputs.length))
        ae.push(
          this.signInputHDAsync(se, z, Y).then(
            () => {
              ie.push(!0);
            },
            () => {
              ie.push(!1);
            }
          )
        );
      return Promise.all(ae).then(() => {
        if (ie.every((se) => se === !1))
          return oe(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInputHD(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!Y || !Y.publicKey || !Y.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(z, this.data.inputs, Y).forEach((ie) => this.signInput(z, ie, ne)), this;
  }
  signInputHDAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((oe, ie) => {
      if (!Y || !Y.publicKey || !Y.fingerprint)
        return ie(new Error("Need HDSigner to sign input"));
      const se = getSignersFromHD(z, this.data.inputs, Y).map(
        (ve) => this.signInputAsync(z, ve, ne)
      );
      return Promise.all(se).then(() => {
        oe();
      }).catch(ie);
    });
  }
  signAllInputs(z, Y) {
    if (!z || !z.publicKey)
      throw new Error("Need Signer to sign input");
    const ne = [];
    for (const oe of range(this.data.inputs.length))
      try {
        this.signInput(oe, z, Y), ne.push(!0);
      } catch {
        ne.push(!1);
      }
    if (ne.every((oe) => oe === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(z, Y) {
    return new Promise((ne, oe) => {
      if (!z || !z.publicKey)
        return oe(new Error("Need Signer to sign input"));
      const ie = [], ae = [];
      for (const [se] of this.data.inputs.entries())
        ae.push(
          this.signInputAsync(se, z, Y).then(
            () => {
              ie.push(!0);
            },
            () => {
              ie.push(!1);
            }
          )
        );
      return Promise.all(ae).then(() => {
        if (ie.every((se) => se === !1))
          return oe(new Error("No inputs were signed"));
        ne();
      });
    });
  }
  signInput(z, Y, ne) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(oe) ? this._signTaprootInput(
      z,
      oe,
      Y,
      void 0,
      ne
    ) : this._signInput(z, Y, ne);
  }
  signTaprootInput(z, Y, ne, oe) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(ie))
      return this._signTaprootInput(
        z,
        ie,
        Y,
        ne,
        oe
      );
    throw new Error(`Input #${z} is not of type Taproot.`);
  }
  _signInput(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: oe, sighashType: ie } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    ), ae = [
      {
        pubkey: Y.publicKey,
        signature: bscript.signature.encode(Y.sign(oe), ie)
      }
    ];
    return this.data.updateInput(z, { partialSig: ae }), this;
  }
  _signTaprootInput(z, Y, ne, oe, ie = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const ae = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      oe,
      ie
    ), se = ae.filter((ge) => !ge.leafHash).map(
      (ge) => (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(ge.hash),
        Y.sighashType
      )
    )[0], ve = ae.filter((ge) => !!ge.leafHash).map((ge) => ({
      pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        ne.signSchnorr(ge.hash),
        Y.sighashType
      ),
      leafHash: ge.leafHash
    }));
    return se && this.data.updateInput(z, { tapKeySig: se }), ve.length && this.data.updateInput(z, { tapScriptSig: ve }), this;
  }
  signInputAsync(z, Y, ne) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const oe = (0, utils_1.checkForInput)(this.data.inputs, z);
      return (0, bip371_1.isTaprootInput)(oe) ? this._signTaprootInputAsync(
        z,
        oe,
        Y,
        void 0,
        ne
      ) : this._signInputAsync(z, Y, ne);
    });
  }
  signTaprootInputAsync(z, Y, ne, oe) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
      if ((0, bip371_1.isTaprootInput)(ie))
        return this._signTaprootInputAsync(
          z,
          ie,
          Y,
          ne,
          oe
        );
      throw new Error(`Input #${z} is not of type Taproot.`);
    });
  }
  _signInputAsync(z, Y, ne = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: oe, sighashType: ie } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ne
    );
    return Promise.resolve(Y.sign(oe)).then((ae) => {
      const se = [
        {
          pubkey: Y.publicKey,
          signature: bscript.signature.encode(ae, ie)
        }
      ];
      this.data.updateInput(z, { partialSig: se });
    });
  }
  async _signTaprootInputAsync(z, Y, ne, oe, ie = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const ae = this.checkTaprootHashesForSig(
      z,
      Y,
      ne,
      oe,
      ie
    ), se = [], ve = ae.filter((le) => !le.leafHash)[0];
    if (ve) {
      const le = Promise.resolve(
        ne.signSchnorr(ve.hash)
      ).then((Ee) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          Ee,
          Y.sighashType
        )
      }));
      se.push(le);
    }
    const ge = ae.filter((le) => !!le.leafHash);
    if (ge.length) {
      const le = ge.map((Ee) => Promise.resolve(ne.signSchnorr(Ee.hash)).then(
        (Ce) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(ne.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Ce,
              Y.sighashType
            ),
            leafHash: Ee.leafHash
          }
        ] })
      ));
      se.push(...le);
    }
    return Promise.all(se).then((le) => {
      le.forEach((Ee) => this.data.updateInput(z, Ee));
    });
  }
  checkTaprootHashesForSig(z, Y, ne, oe, ie) {
    if (typeof ne.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${z}.`
      );
    const ae = getTaprootHashesForSig(
      z,
      Y,
      this.data.inputs,
      ne.publicKey,
      this.__CACHE,
      oe,
      ie
    );
    if (!ae || !ae.length)
      throw new Error(
        `Can not sign for input #${z} with the key ${ne.publicKey.toString(
          "hex"
        )}`
      );
    return ae;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(z) {
    return this.data.updateGlobal(z), this;
  }
  updateInput(z, Y) {
    return Y.witnessScript && checkInvalidP2WSH(Y.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[z],
      Y,
      "updateInput"
    ), this.data.updateInput(z, Y), Y.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[z],
      z
    ), this;
  }
  updateOutput(z, Y) {
    const ne = this.data.outputs[z];
    return (0, bip371_1.checkTaprootOutputFields)(
      ne,
      Y,
      "updateOutput"
    ), this.data.updateOutput(z, Y), this;
  }
  addUnknownKeyValToGlobal(z) {
    return this.data.addUnknownKeyValToGlobal(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    return this.data.addUnknownKeyValToInput(z, Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    return this.data.addUnknownKeyValToOutput(z, Y), this;
  }
  clearFinalizedInput(z) {
    return this.data.clearFinalizedInput(z), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(z = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(z), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(z) {
    if (z.hash === void 0 || z.index === void 0 || !Buffer$1.isBuffer(z.hash) && typeof z.hash != "string" || typeof z.index != "number")
      throw new Error("Error adding input.");
    const Y = typeof z.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(z.hash, "hex")) : z.hash;
    this.tx.addInput(Y, z.index, z.sequence);
  }
  addOutput(z) {
    if (z.script === void 0 || z.value === void 0 || !Buffer$1.isBuffer(z.script) || typeof z.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(z.script, z.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, z, Y) {
  switch (Y) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const ne = payments.p2ms({ output: z });
      return hasSigs(ne.m, B.partialSig, ne.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, z, Y) {
  if (!z) return !1;
  let ne;
  if (Y ? ne = Y.map((oe) => {
    const ie = compressPubkey(oe);
    return z.find((ae) => ae.pubkey.equals(ie));
  }).filter((oe) => !!oe) : ne = z, ne.length > B) throw new Error("Too many signatures");
  return ne.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (z) => !(!z.masterFingerprint.equals(B.fingerprint) || !B.derivePath(z.path).publicKey.equals(z.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, z, Y) {
  const ne = z.__FEE_RATE || B.getFeeRate(), oe = z.__EXTRACTED_TX.virtualSize(), ie = ne * oe;
  if (ne >= Y.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(ie / 1e8).toFixed(8)} in fees, which is ${ne} satoshi per byte for a transaction with a VSize of ${oe} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, z) {
  B.forEach((Y) => {
    if ((0, bip371_1.isTaprootInput)(Y) ? (0, bip371_1.checkTaprootInputForSigs)(Y, z) : (0, psbtutils_1.checkInputForSig)(Y, z))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: z, sighashType: Y } = B;
  z.forEach((ne) => {
    const { hashType: oe } = bscript.signature.decode(ne.signature);
    if (Y !== oe)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, z, Y) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, z))
    throw new Error(
      `Can not ${Y} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (Y) => Y.script && Y.script.length === 0 && Y.witness && Y.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, z) {
  B.ins.forEach((Y) => {
    checkTxInputCache(z, Y);
  });
}
function checkTxInputCache(B, z) {
  const Y = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(z.hash)).toString("hex") + ":" + z.index;
  if (B.__TX_IN_CACHE[Y]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[Y] = 1;
}
function scriptCheckerFactory(B, z) {
  return (Y, ne, oe, ie) => {
    const ae = B({
      redeem: { output: oe }
    }).output;
    if (!ne.equals(ae))
      throw new Error(
        `${z} for ${ie} #${Y} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, z, Y, ne) {
  if (!Y.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${z}`);
  if (B === "__FEE_RATE" && ne.__FEE_RATE) return ne.__FEE_RATE;
  if (B === "__FEE" && ne.__FEE) return ne.__FEE;
  let oe, ie = !0;
  if (ne.__EXTRACTED_TX ? (oe = ne.__EXTRACTED_TX, ie = !1) : oe = ne.__TX.clone(), inputFinalizeGetAmts(Y, oe, ne, ie), B === "__FEE_RATE") return ne.__FEE_RATE;
  if (B === "__FEE") return ne.__FEE;
}
function getFinalScripts(B, z, Y, ne, oe, ie) {
  const ae = classifyScript(Y);
  if (!canFinalize(z, Y, ae))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    Y,
    ae,
    z.partialSig,
    ne,
    oe,
    ie
  );
}
function prepareFinalScripts(B, z, Y, ne, oe, ie) {
  let ae, se;
  const ve = getPayment(B, z, Y), ge = ie ? payments.p2wsh({ redeem: ve }) : null, le = oe ? payments.p2sh({ redeem: ge || ve }) : null;
  return ne ? (ge ? se = (0, psbtutils_1.witnessStackToScriptWitness)(
    ge.witness
  ) : se = (0, psbtutils_1.witnessStackToScriptWitness)(
    ve.witness
  ), le && (ae = le.input)) : le ? ae = le.input : ae = ve.input, {
    finalScriptSig: ae,
    finalScriptWitness: se
  };
}
function getHashAndSighashType(B, z, Y, ne, oe) {
  const ie = (0, utils_1.checkForInput)(B, z), { hash: ae, sighashType: se, script: ve } = getHashForSig(
    z,
    ie,
    ne,
    !1,
    oe
  );
  return checkScriptForPubkey(Y, ve, "sign"), {
    hash: ae,
    sighashType: se
  };
}
function getHashForSig(B, z, Y, ne, oe) {
  const ie = Y.__TX, ae = z.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(ae, oe);
  let se, ve;
  if (z.nonWitnessUtxo) {
    const Ee = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), Ce = ie.ins[B].hash, Pe = Ee.getHash();
    if (!Ce.equals(Pe))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const Xe = ie.ins[B].index;
    ve = Ee.outs[Xe];
  } else if (z.witnessUtxo)
    ve = z.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: ge, type: le } = getMeaningfulScript(
    ve.script,
    B,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(le) >= 0)
    se = ie.hashForWitnessV0(
      B,
      ge,
      ve.value,
      ae
    );
  else if ((0, psbtutils_1.isP2WPKH)(ge)) {
    const Ee = payments.p2pkh({
      hash: ge.slice(2)
    }).output;
    se = ie.hashForWitnessV0(
      B,
      Ee,
      ve.value,
      ae
    );
  } else {
    if (z.nonWitnessUtxo === void 0 && Y.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${ge.toString("hex")}`
      );
    !ne && Y.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), se = ie.hashForSignature(
      B,
      ge,
      ae
    );
  }
  return {
    script: ge,
    sighashType: ae,
    hash: se
  };
}
function getAllTaprootHashesForSig(B, z, Y, ne) {
  const oe = [];
  if (z.tapInternalKey) {
    const ae = getPrevoutTaprootKey(B, z, ne);
    ae && oe.push(ae);
  }
  if (z.tapScriptSig) {
    const ae = z.tapScriptSig.map((se) => se.pubkey);
    oe.push(...ae);
  }
  return oe.map(
    (ae) => getTaprootHashesForSig(B, z, Y, ae, ne)
  ).flat();
}
function getPrevoutTaprootKey(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return (0, psbtutils_1.isP2TR)(ne) ? ne.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, z, Y, ne, oe, ie, ae) {
  const se = oe.__TX, ve = z.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ve, ae);
  const ge = Y.map(
    (Xe, ht) => getScriptAndAmountFromUtxo(ht, Xe, oe)
  ), le = ge.map((Xe) => Xe.script), Ee = ge.map((Xe) => Xe.value), Ce = [];
  if (z.tapInternalKey && !ie) {
    const Xe = getPrevoutTaprootKey(B, z, oe) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(ne).equals(Xe)) {
      const ht = se.hashForWitnessV1(
        B,
        le,
        Ee,
        ve
      );
      Ce.push({ pubkey: ne, hash: ht });
    }
  }
  const Pe = (z.tapLeafScript || []).filter((Xe) => (0, psbtutils_1.pubkeyInScript)(ne, Xe.script)).map((Xe) => {
    const ht = (0, bip341_1.tapleafHash)({
      output: Xe.script,
      version: Xe.leafVersion
    });
    return Object.assign({ hash: ht }, Xe);
  }).filter(
    (Xe) => !ie || ie.equals(Xe.hash)
  ).map((Xe) => {
    const ht = se.hashForWitnessV1(
      B,
      le,
      Ee,
      ve,
      Xe.hash
    );
    return {
      pubkey: ne,
      hash: ht,
      leafHash: Xe.hash
    };
  });
  return Ce.concat(Pe);
}
function checkSighashTypeAllowed(B, z) {
  if (z && z.indexOf(B) < 0) {
    const Y = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${Y}`
    );
  }
}
function getPayment(B, z, Y) {
  let ne;
  switch (z) {
    case "multisig":
      const oe = getSortedSigs(B, Y);
      ne = payments.p2ms({
        output: B,
        signatures: oe
      });
      break;
    case "pubkey":
      ne = payments.p2pk({
        output: B,
        signature: Y[0].signature
      });
      break;
    case "pubkeyhash":
      ne = payments.p2pkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
    case "witnesspubkeyhash":
      ne = payments.p2wpkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
  }
  return ne;
}
function getScriptFromInput(B, z, Y) {
  const ne = Y.__TX, oe = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (oe.isP2SH = !!z.redeemScript, oe.isP2WSH = !!z.witnessScript, z.witnessScript)
    oe.script = z.witnessScript;
  else if (z.redeemScript)
    oe.script = z.redeemScript;
  else if (z.nonWitnessUtxo) {
    const ie = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), ae = ne.ins[B].index;
    oe.script = ie.outs[ae].script;
  } else z.witnessUtxo && (oe.script = z.witnessUtxo.script);
  return (z.witnessScript || (0, psbtutils_1.isP2WPKH)(oe.script)) && (oe.isSegwit = !0), oe;
}
function getSignersFromHD(B, z, Y) {
  const ne = (0, utils_1.checkForInput)(z, B);
  if (!ne.bip32Derivation || ne.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const oe = ne.bip32Derivation.map((ae) => {
    if (ae.masterFingerprint.equals(Y.fingerprint))
      return ae;
  }).filter((ae) => !!ae);
  if (oe.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return oe.map((ae) => {
    const se = Y.derivePath(ae.path);
    if (!ae.pubkey.equals(se.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return se;
  });
}
function getSortedSigs(B, z) {
  return payments.p2ms({ output: B }).pubkeys.map((ne) => (z.filter((oe) => oe.pubkey.equals(ne))[0] || {}).signature).filter((ne) => !!ne);
}
function scriptWitnessToWitnessStack(B) {
  let z = 0;
  function Y(ae) {
    return z += ae, B.slice(z - ae, z);
  }
  function ne() {
    const ae = varuint.decode(B, z);
    return z += varuint.decode.bytes, ae;
  }
  function oe() {
    return Y(ne());
  }
  function ie() {
    const ae = ne(), se = [];
    for (let ve = 0; ve < ae; ve++) se.push(oe());
    return se;
  }
  return ie();
}
function sighashTypeToString(B) {
  let z = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      z += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      z += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      z += "SIGHASH_NONE";
      break;
  }
  return z;
}
function addNonWitnessTxCache(B, z, Y) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[Y] = z.nonWitnessUtxo;
  const ne = transaction_1.Transaction.fromBuffer(z.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[Y] = ne;
  const oe = B, ie = Y;
  delete z.nonWitnessUtxo, Object.defineProperty(z, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const ae = oe.__NON_WITNESS_UTXO_BUF_CACHE[ie], se = oe.__NON_WITNESS_UTXO_TX_CACHE[ie];
      if (ae !== void 0)
        return ae;
      {
        const ve = se.toBuffer();
        return oe.__NON_WITNESS_UTXO_BUF_CACHE[ie] = ve, ve;
      }
    },
    set(ae) {
      oe.__NON_WITNESS_UTXO_BUF_CACHE[ie] = ae;
    }
  });
}
function inputFinalizeGetAmts(B, z, Y, ne) {
  let oe = 0;
  B.forEach((ve, ge) => {
    if (ne && ve.finalScriptSig && (z.ins[ge].script = ve.finalScriptSig), ne && ve.finalScriptWitness && (z.ins[ge].witness = scriptWitnessToWitnessStack(
      ve.finalScriptWitness
    )), ve.witnessUtxo)
      oe += ve.witnessUtxo.value;
    else if (ve.nonWitnessUtxo) {
      const le = nonWitnessUtxoTxFromCache(Y, ve, ge), Ee = z.ins[ge].index, Ce = le.outs[Ee];
      oe += Ce.value;
    }
  });
  const ie = z.outs.reduce((ve, ge) => ve + ge.value, 0), ae = oe - ie;
  if (ae < 0)
    throw new Error("Outputs are spending more than Inputs");
  const se = z.virtualSize();
  Y.__FEE = ae, Y.__EXTRACTED_TX = z, Y.__FEE_RATE = Math.floor(ae / se);
}
function nonWitnessUtxoTxFromCache(B, z, Y) {
  const ne = B.__NON_WITNESS_UTXO_TX_CACHE;
  return ne[Y] || addNonWitnessTxCache(B, z, Y), ne[Y];
}
function getScriptFromUtxo(B, z, Y) {
  const { script: ne } = getScriptAndAmountFromUtxo(B, z, Y);
  return ne;
}
function getScriptAndAmountFromUtxo(B, z, Y) {
  if (z.witnessUtxo !== void 0)
    return {
      script: z.witnessUtxo.script,
      value: z.witnessUtxo.value
    };
  if (z.nonWitnessUtxo !== void 0) {
    const oe = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ).outs[Y.__TX.ins[B].index];
    return { script: oe.script, value: oe.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, z, Y, ne) {
  const oe = getScriptFromUtxo(Y, z, ne), { meaningfulScript: ie } = getMeaningfulScript(
    oe,
    Y,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ie);
}
function pubkeyInOutput(B, z, Y, ne) {
  const oe = ne.__TX.outs[Y].script, { meaningfulScript: ie } = getMeaningfulScript(
    oe,
    Y,
    "output",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ie);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const z = bscript.decompile(B);
  if (!z) return;
  const Y = z[z.length - 1];
  if (!(!Buffer$1.isBuffer(Y) || isPubkeyLike(Y) || isSigLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const z = scriptWitnessToWitnessStack(B), Y = z[z.length - 1];
  if (!(isPubkeyLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const z = B[64] & 1, Y = B.slice(0, 33);
    return Y[0] = 2 | z, Y;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, z, Y, ne, oe) {
  const ie = (0, psbtutils_1.isP2SHScript)(B), ae = ie && ne && (0, psbtutils_1.isP2WSHScript)(ne), se = (0, psbtutils_1.isP2WSHScript)(B);
  if (ie && ne === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((se || ae) && oe === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ve;
  return ae ? (ve = oe, checkRedeemScript(z, B, ne, Y), checkWitnessScript(z, ne, oe, Y), checkInvalidP2WSH(ve)) : se ? (ve = oe, checkWitnessScript(z, B, oe, Y), checkInvalidP2WSH(ve)) : ie ? (ve = ne, checkRedeemScript(z, B, ne, Y)) : ve = B, {
    meaningfulScript: ve,
    type: ae ? "p2sh-p2wsh" : ie ? "p2sh" : se ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const z = requireAddress();
  B.address = z;
  const Y = crypto$1;
  B.crypto = Y;
  const ne = networks;
  B.networks = ne;
  const oe = requirePayments();
  B.payments = oe;
  const ie = requireScript();
  B.script = ie;
  var ae = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return ae.Block;
    }
  });
  var se = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return se.Psbt;
    }
  });
  var ve = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return ve.OPS;
    }
  });
  var ge = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return ge.Transaction;
    }
  });
  var le = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return le.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: B, publicKey: z, format: Y, wallet: ne } = useOrdConnect(), [oe, ie] = useState(null), [ae, se] = useState(!1);
  return { sign: useCallback(
    async (ge, le, Ee) => {
      se(!0);
      try {
        if (ie(null), !Y || !z || !ne)
          throw new Error("No wallet is connected");
        const Ce = src$1.Psbt.fromBase64(le), Pe = await signPsbt({
          address: ge,
          wallet: ne,
          network: B,
          psbt: Ce,
          options: Ee
        });
        return se(!1), Pe;
      } catch (Ce) {
        throw ie(Ce.message), se(!1), Ce;
      }
    },
    [Y, B, z, ne]
  ), error: oe, loading: ae };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signMessage({
  message: B,
  wallet: z,
  address: Y,
  network: ne,
  format: oe
}) {
  if (z === Wallet.MAGICEDEN) {
    const { base64: ie } = await signMessage$1(B, Y, ne);
    return ie;
  }
  if (z === Wallet.UNISAT) {
    const { base64: ie } = await signMessage$2(B, "bip322-simple");
    return ie;
  }
  if (z === Wallet.XVERSE) {
    const { base64: ie } = await signMessage$3(B, Y, ne);
    return ie;
  }
  if (z === Wallet.LEATHER) {
    const ie = leatherPaymentTypeFromFormat(oe), { base64: ae } = await signMessage$4(B, {
      paymentType: ie,
      network: ne
    });
    return ae;
  }
  if (z === Wallet.OKX) {
    const { base64: ie } = await signMessage$5(B, "bip322-simple", ne);
    return ie;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: z,
    publicKey: Y,
    format: ne,
    address: oe
  } = useOrdConnect(), [ie, ae] = useState(null), [se, ve] = useState(!1);
  return { signMsg: useCallback(
    async (le, Ee) => {
      ve(!0);
      try {
        if (ae(null), !ne || !Y || !z)
          throw new Error("No wallet is connected");
        if (oe.ordinals !== le && oe.payments !== le)
          throw new Error("Address supplied is not connected address");
        const Ce = await signMessage({
          address: le,
          wallet: z,
          message: Ee,
          network: B,
          format: oe.ordinals === le ? ne.ordinals : ne.payments
        });
        return ve(!1), Ce;
      } catch (Ce) {
        throw ae(Ce.message), ve(!1), Ce;
      }
    },
    [ne, B, Y, z, oe]
  ), error: ie, isLoading: se };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
