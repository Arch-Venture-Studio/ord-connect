(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode('@import"https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap";.ord-connect-wallet-button{color:#000;background-color:#fff;font-weight:700;font-size:14px;line-height:20px;border-radius:40px;padding:10px 16px;border:0px;cursor:pointer}.ord-connect-wallet-button:disabled{background-color:#888;cursor:not-allowed}.ord-connect-wallet-button span:before{content:"Connect"}@media screen and (min-width: 768px){.ord-connect-wallet-button{padding:10px 24px}.ord-connect-wallet-button span:before{content:"Connect wallet"}}.ord-connect-wallet-button:enabled:hover{background-color:#f2f2f2}.ord-connect-wallet-button:enabled:active{opacity:.7}.ord-wallet-connected-container{position:relative;display:inline-block}.ord-wallet-connected-button{border-radius:52px;border:1px solid #8c8c8c;background-color:transparent;padding:8px 12px 8px 8px;display:flex;align-items:center;cursor:pointer}.ord-wallet-connected-button .address-container{display:none}@media screen and (min-width: 768px){.ord-wallet-connected-button .address-container{display:block;margin-left:8px}}.ord-wallet-connected-button .address{color:#fff;font-size:14px;font-weight:700;line-height:20px;margin:0}.ord-wallet-connected-button .network-container{display:flex;align-items:center}.ord-wallet-connected-button .status-indicator{width:8px;height:8px;background:#00ad1d;border-radius:999px;margin-right:8px}.ord-wallet-connected-button .network{color:#ffffff80;margin:0;font-size:12px;font-weight:600;line-height:16px}.ord-wallet-connected-button .wallet-profile-icon{width:28px;height:28px;border-radius:999px;background-color:pink;margin-right:8px}.ord-wallet-connected-button .dropdown-button{transition:transform .3s ease;margin-left:16px}.ord-wallet-connected-button .expand-dropdown-button{width:20px;transform:rotate(0)}.ord-wallet-connected-button .close-dropdown-button{transform:rotate(-180deg)}.ord-wallet-connection-dropdown{background:#121212;border-radius:15px;border:.5px solid rgba(255,255,255,.5);width:256px;position:absolute;top:54px;right:0}.ord-wallet-connection-dropdown .dropdown-button{display:flex;align-items:center;background:transparent;border:0px;cursor:pointer;width:100%;justify-content:space-between}.ord-wallet-connection-dropdown .dropdown-button:hover{background:#ffffff1a}.ord-wallet-connection-dropdown .dropdown-button:hover:first-child{border-top-left-radius:15px;border-top-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:hover:last-child{border-bottom-left-radius:15px;border-bottom-right-radius:15px}.ord-wallet-connection-dropdown .dropdown-button:active{background:#ffffff1a;opacity:.7}.ord-wallet-connection-dropdown .dropdown-button:first-child{padding:26px 16px 18px}.ord-wallet-connection-dropdown .dropdown-button:not(:first-child):not(:last-child){padding:9px 16px}.ord-wallet-connection-dropdown .dropdown-button:last-child{padding:18px 16px 26px}.ord-wallet-connection-dropdown .label{color:#fff;font-size:14px;font-weight:600;flex:1 1 0%;text-align:left}.ord-wallet-connection-dropdown .value{color:#a6a6a6}.ord-wallet-connection-dropdown .change-wallet-label{color:#ffffffb3;font-size:14px;font-weight:700;flex:1 1 0%;text-align:right}.ord-wallet-connection-dropdown .profile-item-container{width:100%;display:flex;flex-direction:column}.ord-wallet-connection-dropdown .profile-item-inner-container{display:flex;justify-content:space-between}.ord-wallet-connection-dropdown .offers{font-size:10px;font-weight:700;line-height:12px;letter-spacing:.08em;color:#fff;padding:4px 12px;border-radius:16px;background:#ffffff1a}.ord-wallet-connection-dropdown .horizontal-separator{margin:6px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal{position:relative;z-index:10}.ord-connect-wallet-modal .backdrop{position:fixed;top:0;right:0;bottom:0;left:0;background:#00000080;-webkit-backdrop-filter:blur(10px);backdrop-filter:blur(10px)}.ord-connect-wallet-modal .outer-container{position:fixed;top:0;left:0;overflow-y:auto;width:100%;height:100%}.ord-connect-wallet-modal .inner-container{display:flex;align-items:center;justify-content:center;text-align:center;height:100%}.ord-connect-wallet-modal .panel{width:100%;background-color:#121212;overflow:hidden;text-align:left;height:100%}.ord-connect-wallet-modal .panel-title-container{display:flex;justify-content:space-between;padding:32px 24px 0;align-items:center}.ord-connect-wallet-modal .panel-title{color:#fff;font-size:24px;font-style:normal;font-weight:700;line-height:32px;margin:0}.ord-connect-wallet-modal .unsupported-browser-message{color:#fff}.ord-connect-wallet-modal .close-button{display:inline-flex;background:transparent;border:0px;cursor:pointer}.ord-connect-wallet-modal .panel-content-container{margin:32px 24px 0}.ord-connect-wallet-modal .panel-content-inner-container{border-radius:20px;border:1px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .wallet-option-button{display:flex;align-items:center;background:transparent;border:0px;color:#fff;font-size:16px;font-weight:600;line-height:20px;width:100%;cursor:pointer}.ord-connect-wallet-modal .wallet-option-button:disabled .chevron-btn{opacity:.3}.waiting-cursor{cursor:wait!important}.wallet-identifier-container{position:relative;display:inline-block}.wallet-identifier-container img{position:absolute;bottom:4px;right:0;width:12px;border-radius:50%;background-color:#000;object-fit:cover}.ord-connect-wallet-modal .option-wrapper{display:flex;align-items:center;justify-content:space-between;padding:16px 4px;width:100%}.ord-connect-wallet-modal .wallet-option-button{padding:8px 16px}.ord-connect-wallet-modal .wallet-option-button:hover{background:#ffffff1a}.ord-connect-wallet-modal .wallet-option-button:active{background:#ffffff1a;opacity:.7}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-option-button:last-child{padding:8px 16px 16px;border:0px;margin-bottom:0;border-radius:0 0 20px 20px}.ord-connect-wallet-modal .wallet-option-button:only-child{padding:8px 16px;border:0px;margin-bottom:0;border-radius:20px}.ord-connect-wallet-modal .wallet-icon{width:32px;height:32px}.ord-connect-wallet-modal .wallet-option{flex-grow:1;margin-left:12px;text-align:left}.ord-connect-wallet-modal .wallet-option-connected-address{display:flex;padding:4px 8px;align-items:center;margin-left:4px;margin-right:8px;text-align:left;background-color:#00000080;border-radius:20px;-webkit-backdrop-filter:blur(15px);backdrop-filter:blur(15px)}.ord-connect-wallet-modal .wallet-option-connected-address .label{margin-left:4px;font-size:12px;font-weight:400;color:#ffffffb3}.ord-connect-wallet-modal .wallet-option-label{font-size:16px;font-weight:600;line-height:20px;margin:0}.ord-connect-wallet-modal .wallet-option-subtitle{font-size:12px;font-weight:400;line-height:16px;color:#8c8c8c;margin:0}.ord-connect-wallet-modal .horizontal-separator{margin:2px 16px;border:0px;border-top:.5px solid rgba(255,255,255,.1)}.ord-connect-wallet-modal .error-message{margin:16px 0 0;color:#e54545;font-size:14px;line-height:20px}.ord-connect-wallet-modal .preferred-label{padding:4px 12px;color:#000000b2;background-color:#ffbf18;font-size:12px;line-height:16px;font-weight:400;border-radius:20px;margin-left:4px;margin-right:8px}@media screen and (min-width: 768px){.ord-connect-wallet-modal .outer-container{top:50%;left:50%;transform:translate(-50%,-50%);width:500px;height:auto;border-radius:20px}.ord-connect-wallet-modal .panel{border:1px solid rgba(51,51,51,.5);border-radius:20px}.ord-connect-wallet-modal .panel-title-container{padding:24px 32px 0;border-bottom:0px}.ord-connect-wallet-modal .unsupported-browser-message{font-size:16px;padding-left:24px}.ord-connect-wallet-modal .panel-title{font-size:20px;font-style:normal;font-weight:600;line-height:28px;letter-spacing:.2px}.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .wallet-option{margin-left:16px}}@media screen and (min-width: 1080px){.ord-connect-wallet-modal .panel-content-container{margin:48px 32px 32px}.ord-connect-wallet-modal .option-wrapper{padding:16px}.ord-connect-wallet-modal .wallet-option-button{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-button:first-child{padding:16px 16px 8px;border:0px;margin-bottom:0;border-radius:20px 20px 0 0}.ord-connect-wallet-modal .wallet-icon{width:40px;height:40px}.ord-connect-wallet-modal .wallet-option-label{font-size:18px;font-weight:600;line-height:24px}.ord-connect-wallet-modal .wallet-option-connected-address{margin-left:16px;margin-right:16px}.ord-connect-wallet-modal .wallet-option-connected-address .label{font-size:16px}}.ord-connect-font *{font-family:Space Grotesk,sans-serif}.transition{transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}.ease-out{transition-timing-function:cubic-bezier(0,0,.2,1)}.ease-in{transition-timing-function:cubic-bezier(.4,0,1,1)}.opacity-0{opacity:0}.opacity-100{opacity:1}.duration-300{transition-duration:.3s}.duration-200{transition-duration:.2s}.scale-95{transform:scale(.95)}.scale-100{transform:scale(1)}')),document.head.appendChild(o)}}catch(t){console.error("vite-plugin-css-injected-by-js",t)}})();
import * as React from "react";
import React__default, { useState, useEffect, useCallback, createContext, useMemo, useContext, useRef, useLayoutEffect, forwardRef, Fragment, isValidElement, cloneElement, createElement, useId as useId$1, useReducer, useSyncExternalStore, createRef } from "react";
import * as ReactDOM from "react-dom";
import { createPortal, flushSync } from "react-dom";
import { BrowserWalletNotInstalledError, OrditSDKError, BrowserWalletSigningError, getAddressFormat, getAddressesFromPublicKey, ADDRESS_FORMAT_TO_TYPE, JsonRpcDatasource, PSBTBuilder, BrowserWalletRequestCancelledByUserError } from "@ordzaar/ordit-sdk";
import { getAddresses as getAddresses$1, signPsbt as signPsbt$4, signMessage as signMessage$3, LeatherAddressType } from "@ordzaar/ordit-sdk/leather";
import { getAddresses as getAddresses$2, signPsbt as signPsbt$1, signMessage as signMessage$1 } from "@ordzaar/ordit-sdk/magiceden";
import { getAddresses, signPsbt as signPsbt$5, signMessage as signMessage$4 } from "@ordzaar/ordit-sdk/okx";
import { getAddresses as getAddresses$3, signPsbt as signPsbt$2, signMessage as signMessage$2 } from "@ordzaar/ordit-sdk/unisat";
import { signPsbt as signPsbt$3 } from "@ordzaar/ordit-sdk/xverse";
function getDefaultExportFromCjs$1(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
var browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(B) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(B, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(B, 0);
  try {
    return cachedSetTimeout(B, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, B, 0);
    } catch {
      return cachedSetTimeout.call(this, B, 0);
    }
  }
}
function runClearTimeout(B) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(B);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(B);
  try {
    return cachedClearTimeout(B);
  } catch {
    try {
      return cachedClearTimeout.call(null, B);
    } catch {
      return cachedClearTimeout.call(this, B);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var B = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var z = queue.length; z; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < z; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, z = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(B);
  }
}
process.nextTick = function(B) {
  var z = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var Y = 1; Y < arguments.length; Y++)
      z[Y - 1] = arguments[Y];
  queue.push(new Item(B, z)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(B, z) {
  this.fun = B, this.array = z;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(B) {
  return [];
};
process.binding = function(B) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(B) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(B) {
  return B && B.__esModule && Object.prototype.hasOwnProperty.call(B, "default") ? B.default : B;
}
function getAugmentedNamespace(B) {
  if (B.__esModule) return B;
  var z = B.default;
  if (typeof z == "function") {
    var Y = function ie() {
      return this instanceof ie ? Reflect.construct(z, arguments, this.constructor) : z.apply(this, arguments);
    };
    Y.prototype = z.prototype;
  } else Y = {};
  return Object.defineProperty(Y, "__esModule", { value: !0 }), Object.keys(B).forEach(function(ie) {
    var se = Object.getOwnPropertyDescriptor(B, ie);
    Object.defineProperty(Y, ie, se.get ? se : {
      enumerable: !0,
      get: function() {
        return B[ie];
      }
    });
  }), Y;
}
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min) return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.fragment"), ie = Object.prototype.hasOwnProperty, se = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, ne = { key: !0, ref: !0, __self: !0, __source: !0 };
  function ae(le, ge, Ee) {
    var oe, Pe = {}, Ve = null, Ke = null;
    Ee !== void 0 && (Ve = "" + Ee), ge.key !== void 0 && (Ve = "" + ge.key), ge.ref !== void 0 && (Ke = ge.ref);
    for (oe in ge) ie.call(ge, oe) && !ne.hasOwnProperty(oe) && (Pe[oe] = ge[oe]);
    if (le && le.defaultProps) for (oe in ge = le.defaultProps, ge) Pe[oe] === void 0 && (Pe[oe] = ge[oe]);
    return { $$typeof: z, type: le, key: Ve, ref: Ke, props: Pe, _owner: se.current };
  }
  return reactJsxRuntime_production_min.Fragment = Y, reactJsxRuntime_production_min.jsx = ae, reactJsxRuntime_production_min.jsxs = ae, reactJsxRuntime_production_min;
}
var reactJsxRuntime_development = {}, hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process$1.env.NODE_ENV !== "production" && function() {
    var B = React__default, z = Symbol.for("react.element"), Y = Symbol.for("react.portal"), ie = Symbol.for("react.fragment"), se = Symbol.for("react.strict_mode"), ne = Symbol.for("react.profiler"), ae = Symbol.for("react.provider"), le = Symbol.for("react.context"), ge = Symbol.for("react.forward_ref"), Ee = Symbol.for("react.suspense"), oe = Symbol.for("react.suspense_list"), Pe = Symbol.for("react.memo"), Ve = Symbol.for("react.lazy"), Ke = Symbol.for("react.offscreen"), ht = Symbol.iterator, _t = "@@iterator";
    function Rt(tr) {
      if (tr === null || typeof tr != "object")
        return null;
      var gr = ht && tr[ht] || tr[_t];
      return typeof gr == "function" ? gr : null;
    }
    var kt = B.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function Bt(tr) {
      {
        for (var gr = arguments.length, wr = new Array(gr > 1 ? gr - 1 : 0), _r = 1; _r < gr; _r++)
          wr[_r - 1] = arguments[_r];
        Ct("error", tr, wr);
      }
    }
    function Ct(tr, gr, wr) {
      {
        var _r = kt.ReactDebugCurrentFrame, Hr = _r.getStackAddendum();
        Hr !== "" && (gr += "%s", wr = wr.concat([Hr]));
        var Cr = wr.map(function(Br) {
          return String(Br);
        });
        Cr.unshift("Warning: " + gr), Function.prototype.apply.call(console[tr], console, Cr);
      }
    }
    var qt = !1, jt = !1, Ht = !1, Yt = !1, Ut = !1, Nt;
    Nt = Symbol.for("react.module.reference");
    function Kt(tr) {
      return !!(typeof tr == "string" || typeof tr == "function" || tr === ie || tr === ne || Ut || tr === se || tr === Ee || tr === oe || Yt || tr === Ke || qt || jt || Ht || typeof tr == "object" && tr !== null && (tr.$$typeof === Ve || tr.$$typeof === Pe || tr.$$typeof === ae || tr.$$typeof === le || tr.$$typeof === ge || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      tr.$$typeof === Nt || tr.getModuleId !== void 0));
    }
    function Ft(tr, gr, wr) {
      var _r = tr.displayName;
      if (_r)
        return _r;
      var Hr = gr.displayName || gr.name || "";
      return Hr !== "" ? wr + "(" + Hr + ")" : wr;
    }
    function bt(tr) {
      return tr.displayName || "Context";
    }
    function Xe(tr) {
      if (tr == null)
        return null;
      if (typeof tr.tag == "number" && Bt("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof tr == "function")
        return tr.displayName || tr.name || null;
      if (typeof tr == "string")
        return tr;
      switch (tr) {
        case ie:
          return "Fragment";
        case Y:
          return "Portal";
        case ne:
          return "Profiler";
        case se:
          return "StrictMode";
        case Ee:
          return "Suspense";
        case oe:
          return "SuspenseList";
      }
      if (typeof tr == "object")
        switch (tr.$$typeof) {
          case le:
            var gr = tr;
            return bt(gr) + ".Consumer";
          case ae:
            var wr = tr;
            return bt(wr._context) + ".Provider";
          case ge:
            return Ft(tr, tr.render, "ForwardRef");
          case Pe:
            var _r = tr.displayName || null;
            return _r !== null ? _r : Xe(tr.type) || "Memo";
          case Ve: {
            var Hr = tr, Cr = Hr._payload, Br = Hr._init;
            try {
              return Xe(Br(Cr));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var ve = Object.assign, Ce = 0, Qe, vt, wt, $t, xt, Pt, Je;
    function Ot() {
    }
    Ot.__reactDisabledLog = !0;
    function er() {
      {
        if (Ce === 0) {
          Qe = console.log, vt = console.info, wt = console.warn, $t = console.error, xt = console.group, Pt = console.groupCollapsed, Je = console.groupEnd;
          var tr = {
            configurable: !0,
            enumerable: !0,
            value: Ot,
            writable: !0
          };
          Object.defineProperties(console, {
            info: tr,
            log: tr,
            warn: tr,
            error: tr,
            group: tr,
            groupCollapsed: tr,
            groupEnd: tr
          });
        }
        Ce++;
      }
    }
    function sr() {
      {
        if (Ce--, Ce === 0) {
          var tr = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: ve({}, tr, {
              value: Qe
            }),
            info: ve({}, tr, {
              value: vt
            }),
            warn: ve({}, tr, {
              value: wt
            }),
            error: ve({}, tr, {
              value: $t
            }),
            group: ve({}, tr, {
              value: xt
            }),
            groupCollapsed: ve({}, tr, {
              value: Pt
            }),
            groupEnd: ve({}, tr, {
              value: Je
            })
          });
        }
        Ce < 0 && Bt("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Jt = kt.ReactCurrentDispatcher, Wt;
    function Gt(tr, gr, wr) {
      {
        if (Wt === void 0)
          try {
            throw Error();
          } catch (Hr) {
            var _r = Hr.stack.trim().match(/\n( *(at )?)/);
            Wt = _r && _r[1] || "";
          }
        return `
` + Wt + tr;
      }
    }
    var rr = !1, or;
    {
      var Xt = typeof WeakMap == "function" ? WeakMap : Map;
      or = new Xt();
    }
    function zt(tr, gr) {
      if (!tr || rr)
        return "";
      {
        var wr = or.get(tr);
        if (wr !== void 0)
          return wr;
      }
      var _r;
      rr = !0;
      var Hr = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Cr;
      Cr = Jt.current, Jt.current = null, er();
      try {
        if (gr) {
          var Br = function() {
            throw Error();
          };
          if (Object.defineProperty(Br.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Br, []);
            } catch (nn) {
              _r = nn;
            }
            Reflect.construct(tr, [], Br);
          } else {
            try {
              Br.call();
            } catch (nn) {
              _r = nn;
            }
            tr.call(Br.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (nn) {
            _r = nn;
          }
          tr();
        }
      } catch (nn) {
        if (nn && _r && typeof nn.stack == "string") {
          for (var zr = nn.stack.split(`
`), tn = _r.stack.split(`
`), Qr = zr.length - 1, en = tn.length - 1; Qr >= 1 && en >= 0 && zr[Qr] !== tn[en]; )
            en--;
          for (; Qr >= 1 && en >= 0; Qr--, en--)
            if (zr[Qr] !== tn[en]) {
              if (Qr !== 1 || en !== 1)
                do
                  if (Qr--, en--, en < 0 || zr[Qr] !== tn[en]) {
                    var sn = `
` + zr[Qr].replace(" at new ", " at ");
                    return tr.displayName && sn.includes("<anonymous>") && (sn = sn.replace("<anonymous>", tr.displayName)), typeof tr == "function" && or.set(tr, sn), sn;
                  }
                while (Qr >= 1 && en >= 0);
              break;
            }
        }
      } finally {
        rr = !1, Jt.current = Cr, sr(), Error.prepareStackTrace = Hr;
      }
      var on = tr ? tr.displayName || tr.name : "", an = on ? Gt(on) : "";
      return typeof tr == "function" && or.set(tr, an), an;
    }
    function ur(tr, gr, wr) {
      return zt(tr, !1);
    }
    function hr(tr) {
      var gr = tr.prototype;
      return !!(gr && gr.isReactComponent);
    }
    function yr(tr, gr, wr) {
      if (tr == null)
        return "";
      if (typeof tr == "function")
        return zt(tr, hr(tr));
      if (typeof tr == "string")
        return Gt(tr);
      switch (tr) {
        case Ee:
          return Gt("Suspense");
        case oe:
          return Gt("SuspenseList");
      }
      if (typeof tr == "object")
        switch (tr.$$typeof) {
          case ge:
            return ur(tr.render);
          case Pe:
            return yr(tr.type, gr, wr);
          case Ve: {
            var _r = tr, Hr = _r._payload, Cr = _r._init;
            try {
              return yr(Cr(Hr), gr, wr);
            } catch {
            }
          }
        }
      return "";
    }
    var Sr = Object.prototype.hasOwnProperty, $r = {}, Mr = kt.ReactDebugCurrentFrame;
    function pr(tr) {
      if (tr) {
        var gr = tr._owner, wr = yr(tr.type, tr._source, gr ? gr.type : null);
        Mr.setExtraStackFrame(wr);
      } else
        Mr.setExtraStackFrame(null);
    }
    function Fr(tr, gr, wr, _r, Hr) {
      {
        var Cr = Function.call.bind(Sr);
        for (var Br in tr)
          if (Cr(tr, Br)) {
            var zr = void 0;
            try {
              if (typeof tr[Br] != "function") {
                var tn = Error((_r || "React class") + ": " + wr + " type `" + Br + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof tr[Br] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw tn.name = "Invariant Violation", tn;
              }
              zr = tr[Br](gr, Br, _r, wr, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Qr) {
              zr = Qr;
            }
            zr && !(zr instanceof Error) && (pr(Hr), Bt("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", _r || "React class", wr, Br, typeof zr), pr(null)), zr instanceof Error && !(zr.message in $r) && ($r[zr.message] = !0, pr(Hr), Bt("Failed %s type: %s", wr, zr.message), pr(null));
          }
      }
    }
    var Ar = Array.isArray;
    function Gr(tr) {
      return Ar(tr);
    }
    function Lr(tr) {
      {
        var gr = typeof Symbol == "function" && Symbol.toStringTag, wr = gr && tr[Symbol.toStringTag] || tr.constructor.name || "Object";
        return wr;
      }
    }
    function Rr(tr) {
      try {
        return Vr(tr), !1;
      } catch {
        return !0;
      }
    }
    function Vr(tr) {
      return "" + tr;
    }
    function jr(tr) {
      if (Rr(tr))
        return Bt("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Lr(tr)), Vr(tr);
    }
    var kr = kt.ReactCurrentOwner, Jr = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Xr, Vt;
    function Lt(tr) {
      if (Sr.call(tr, "ref")) {
        var gr = Object.getOwnPropertyDescriptor(tr, "ref").get;
        if (gr && gr.isReactWarning)
          return !1;
      }
      return tr.ref !== void 0;
    }
    function Dt(tr) {
      if (Sr.call(tr, "key")) {
        var gr = Object.getOwnPropertyDescriptor(tr, "key").get;
        if (gr && gr.isReactWarning)
          return !1;
      }
      return tr.key !== void 0;
    }
    function Qt(tr, gr) {
      typeof tr.ref == "string" && kr.current;
    }
    function fr(tr, gr) {
      {
        var wr = function() {
          Xr || (Xr = !0, Bt("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", gr));
        };
        wr.isReactWarning = !0, Object.defineProperty(tr, "key", {
          get: wr,
          configurable: !0
        });
      }
    }
    function cr(tr, gr) {
      {
        var wr = function() {
          Vt || (Vt = !0, Bt("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", gr));
        };
        wr.isReactWarning = !0, Object.defineProperty(tr, "ref", {
          get: wr,
          configurable: !0
        });
      }
    }
    var lr = function(tr, gr, wr, _r, Hr, Cr, Br) {
      var zr = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: z,
        // Built-in properties that belong on the element
        type: tr,
        key: gr,
        ref: wr,
        props: Br,
        // Record the component responsible for creating this element.
        _owner: Cr
      };
      return zr._store = {}, Object.defineProperty(zr._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(zr, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: _r
      }), Object.defineProperty(zr, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Hr
      }), Object.freeze && (Object.freeze(zr.props), Object.freeze(zr)), zr;
    };
    function Ur(tr, gr, wr, _r, Hr) {
      {
        var Cr, Br = {}, zr = null, tn = null;
        wr !== void 0 && (jr(wr), zr = "" + wr), Dt(gr) && (jr(gr.key), zr = "" + gr.key), Lt(gr) && (tn = gr.ref, Qt(gr, Hr));
        for (Cr in gr)
          Sr.call(gr, Cr) && !Jr.hasOwnProperty(Cr) && (Br[Cr] = gr[Cr]);
        if (tr && tr.defaultProps) {
          var Qr = tr.defaultProps;
          for (Cr in Qr)
            Br[Cr] === void 0 && (Br[Cr] = Qr[Cr]);
        }
        if (zr || tn) {
          var en = typeof tr == "function" ? tr.displayName || tr.name || "Unknown" : tr;
          zr && fr(Br, en), tn && cr(Br, en);
        }
        return lr(tr, zr, tn, Hr, _r, kr.current, Br);
      }
    }
    var Nr = kt.ReactCurrentOwner, Tr = kt.ReactDebugCurrentFrame;
    function Wr(tr) {
      if (tr) {
        var gr = tr._owner, wr = yr(tr.type, tr._source, gr ? gr.type : null);
        Tr.setExtraStackFrame(wr);
      } else
        Tr.setExtraStackFrame(null);
    }
    var qr;
    qr = !1;
    function Or(tr) {
      return typeof tr == "object" && tr !== null && tr.$$typeof === z;
    }
    function Zr() {
      {
        if (Nr.current) {
          var tr = Xe(Nr.current.type);
          if (tr)
            return `

Check the render method of \`` + tr + "`.";
        }
        return "";
      }
    }
    function Yr(tr) {
      return "";
    }
    var nr = {};
    function Zt(tr) {
      {
        var gr = Zr();
        if (!gr) {
          var wr = typeof tr == "string" ? tr : tr.displayName || tr.name;
          wr && (gr = `

Check the top-level render call using <` + wr + ">.");
        }
        return gr;
      }
    }
    function ir(tr, gr) {
      {
        if (!tr._store || tr._store.validated || tr.key != null)
          return;
        tr._store.validated = !0;
        var wr = Zt(gr);
        if (nr[wr])
          return;
        nr[wr] = !0;
        var _r = "";
        tr && tr._owner && tr._owner !== Nr.current && (_r = " It was passed a child from " + Xe(tr._owner.type) + "."), Wr(tr), Bt('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', wr, _r), Wr(null);
      }
    }
    function ar(tr, gr) {
      {
        if (typeof tr != "object")
          return;
        if (Gr(tr))
          for (var wr = 0; wr < tr.length; wr++) {
            var _r = tr[wr];
            Or(_r) && ir(_r, gr);
          }
        else if (Or(tr))
          tr._store && (tr._store.validated = !0);
        else if (tr) {
          var Hr = Rt(tr);
          if (typeof Hr == "function" && Hr !== tr.entries)
            for (var Cr = Hr.call(tr), Br; !(Br = Cr.next()).done; )
              Or(Br.value) && ir(Br.value, gr);
        }
      }
    }
    function dr(tr) {
      {
        var gr = tr.type;
        if (gr == null || typeof gr == "string")
          return;
        var wr;
        if (typeof gr == "function")
          wr = gr.propTypes;
        else if (typeof gr == "object" && (gr.$$typeof === ge || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        gr.$$typeof === Pe))
          wr = gr.propTypes;
        else
          return;
        if (wr) {
          var _r = Xe(gr);
          Fr(wr, tr.props, "prop", _r, tr);
        } else if (gr.PropTypes !== void 0 && !qr) {
          qr = !0;
          var Hr = Xe(gr);
          Bt("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Hr || "Unknown");
        }
        typeof gr.getDefaultProps == "function" && !gr.getDefaultProps.isReactClassApproved && Bt("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function vr(tr) {
      {
        for (var gr = Object.keys(tr.props), wr = 0; wr < gr.length; wr++) {
          var _r = gr[wr];
          if (_r !== "children" && _r !== "key") {
            Wr(tr), Bt("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", _r), Wr(null);
            break;
          }
        }
        tr.ref !== null && (Wr(tr), Bt("Invalid attribute `ref` supplied to `React.Fragment`."), Wr(null));
      }
    }
    var br = {};
    function xr(tr, gr, wr, _r, Hr, Cr) {
      {
        var Br = Kt(tr);
        if (!Br) {
          var zr = "";
          (tr === void 0 || typeof tr == "object" && tr !== null && Object.keys(tr).length === 0) && (zr += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var tn = Yr();
          tn ? zr += tn : zr += Zr();
          var Qr;
          tr === null ? Qr = "null" : Gr(tr) ? Qr = "array" : tr !== void 0 && tr.$$typeof === z ? (Qr = "<" + (Xe(tr.type) || "Unknown") + " />", zr = " Did you accidentally export a JSX literal instead of a component?") : Qr = typeof tr, Bt("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Qr, zr);
        }
        var en = Ur(tr, gr, wr, Hr, Cr);
        if (en == null)
          return en;
        if (Br) {
          var sn = gr.children;
          if (sn !== void 0)
            if (_r)
              if (Gr(sn)) {
                for (var on = 0; on < sn.length; on++)
                  ar(sn[on], tr);
                Object.freeze && Object.freeze(sn);
              } else
                Bt("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ar(sn, tr);
        }
        if (Sr.call(gr, "key")) {
          var an = Xe(tr), nn = Object.keys(gr).filter(function(cn) {
            return cn !== "key";
          }), fn = nn.length > 0 ? "{key: someKey, " + nn.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!br[an + fn]) {
            var un = nn.length > 0 ? "{" + nn.join(": ..., ") + ": ...}" : "{}";
            Bt(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fn, an, un, an), br[an + fn] = !0;
          }
        }
        return tr === ie ? vr(en) : dr(en), en;
      }
    }
    function Pr(tr, gr, wr) {
      return xr(tr, gr, wr, !0);
    }
    function Er(tr, gr, wr) {
      return xr(tr, gr, wr, !1);
    }
    var Dr = Er, Ir = Pr;
    reactJsxRuntime_development.Fragment = ie, reactJsxRuntime_development.jsx = Dr, reactJsxRuntime_development.jsxs = Ir;
  }()), reactJsxRuntime_development;
}
process$1.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
function useHasMounted() {
  const [B, z] = useState(!1);
  return useEffect(() => {
    z(!0);
  }, []), B;
}
const KEY_PREFIX = "ord-connect";
function getItemFromLocalStorage(B) {
  typeof window > "u" && console.warn(
    `Attempted to read local storage key ${B} even though environment is not a browser.`
  );
  const z = `${KEY_PREFIX}_${B}`;
  try {
    const Y = window.localStorage.getItem(z);
    return Y != null ? JSON.parse(Y) : null;
  } catch (Y) {
    return console.error(`Error retrieving ${z} from localStorage`, Y), null;
  }
}
function setItemToLocalStorage(B, z) {
  typeof window > "u" && console.warn(
    `Attempted to set local storage key ${B} even though environment is not a browser.`
  );
  const Y = `${KEY_PREFIX}_${B}`;
  try {
    z ? window.localStorage.setItem(Y, JSON.stringify(z)) : window.localStorage.removeItem(Y);
  } catch (ie) {
    console.error(`Error saving ${Y} to localStorage`, ie);
  }
}
function useLocalStorage(B, z, Y = {}) {
  const { initializeWithValue: ie = !0 } = Y, se = useCallback(() => {
    const ge = getItemFromLocalStorage(B);
    return ge || (setItemToLocalStorage(B, z), z);
  }, [z, B]), [ne, ae] = useState(() => ie ? se() : z), le = useCallback(
    (ge) => {
      setItemToLocalStorage(B, ge), ae(ge);
    },
    [B]
  );
  return useEffect(() => {
    ae(se());
  }, [B]), [ne, le];
}
var Network = /* @__PURE__ */ ((B) => (B.MAINNET = "mainnet", B.TESTNET = "testnet", B.SIGNET = "signet", B))(Network || {}), Wallet = /* @__PURE__ */ ((B) => (B.UNISAT = "unisat", B.XVERSE = "xverse", B.MAGICEDEN = "magiceden", B.LEATHER = "leather", B.OKX = "okx", B))(Wallet || {}), Chain = /* @__PURE__ */ ((B) => (B.BITCOIN = "bitcoin", B.FRACTAL_BITCOIN = "fractal-bitcoin", B))(Chain || {});
const EMPTY_BIADDRESS_OBJECT = {
  payments: null,
  ordinals: null
}, OrdConnectContext = createContext(
  void 0
), ADDRESS = "address", TESTNET_ADDRESS = "testnetAddress", WALLET = "wallet", PUBLIC_KEY = "publicKey", FORMAT = "format";
function OrdConnectProvider({
  children: B,
  network: z,
  visibleWallets: Y,
  chain: ie = "bitcoin",
  ssr: se = !1
}) {
  if (!z)
    throw new Error("Network cannot be empty");
  if (!Y || Y.length === 0)
    throw new Error("Visible wallets cannot be empty");
  const [ne, ae] = useState(z), [le, ge] = useState(Y), [Ee, oe] = useState(ie), [Pe, Ve] = useLocalStorage(
    ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !se }
  ), [Ke, ht] = useLocalStorage(
    TESTNET_ADDRESS,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !se }
  ), [_t, Rt] = useLocalStorage(WALLET, null, {
    initializeWithValue: !se
  }), [kt, Bt] = useLocalStorage(
    PUBLIC_KEY,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !se }
  ), [Ct, qt] = useLocalStorage(
    FORMAT,
    EMPTY_BIADDRESS_OBJECT,
    { initializeWithValue: !se }
  ), [jt, Ht] = useState(!1), Yt = useCallback(() => Ht(!0), []), Ut = useCallback(() => Ht(!1), []), Nt = useCallback(() => {
    Ve(EMPTY_BIADDRESS_OBJECT), ht(EMPTY_BIADDRESS_OBJECT), Bt(EMPTY_BIADDRESS_OBJECT), qt(EMPTY_BIADDRESS_OBJECT), Rt(null);
  }, [Ve, qt, Bt, Rt]), Kt = useMemo(
    () => ({
      address: Pe,
      testnetAddress: Ke,
      updateAddress: Ve,
      updateTestnetAddress: ht,
      publicKey: kt,
      updatePublicKey: Bt,
      network: ne,
      updateNetwork: ae,
      wallet: _t,
      updateWallet: Rt,
      isModalOpen: jt,
      openModal: Yt,
      closeModal: Ut,
      format: Ct,
      updateFormat: qt,
      disconnectWallet: Nt,
      chain: Ee,
      updateChain: oe,
      visibleWallets: le,
      updateVisibleWallets: ge
    }),
    [
      Pe,
      Ve,
      Ke,
      ht,
      kt,
      Bt,
      ne,
      _t,
      jt,
      Yt,
      Ut,
      Ct,
      qt,
      Nt,
      Ee,
      le,
      Rt
    ]
  );
  return useEffect(() => {
    ae(z);
  }, [z]), useEffect(() => {
    Ee !== ie && (Nt(), oe(ie));
  }, [ie, Ee, Nt]), /* @__PURE__ */ jsxRuntimeExports.jsx(OrdConnectContext.Provider, { value: Kt, children: B });
}
function useOrdConnect() {
  const B = useContext(OrdConnectContext);
  if (!B)
    throw new Error("useOrdConnect must be used within OrdConnectProvider");
  return B;
}
var build = { exports: {} };
(function(B, z) {
  (function(Y, ie) {
    B.exports = ie(React__default);
  })(commonjsGlobal, function(Y) {
    return function(ie) {
      var se = {};
      function ne(ae) {
        if (se[ae]) return se[ae].exports;
        var le = se[ae] = { i: ae, l: !1, exports: {} };
        return ie[ae].call(le.exports, le, le.exports, ne), le.l = !0, le.exports;
      }
      return ne.m = ie, ne.c = se, ne.d = function(ae, le, ge) {
        ne.o(ae, le) || Object.defineProperty(ae, le, { enumerable: !0, get: ge });
      }, ne.r = function(ae) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(ae, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(ae, "__esModule", { value: !0 });
      }, ne.t = function(ae, le) {
        if (1 & le && (ae = ne(ae)), 8 & le || 4 & le && typeof ae == "object" && ae && ae.__esModule) return ae;
        var ge = /* @__PURE__ */ Object.create(null);
        if (ne.r(ge), Object.defineProperty(ge, "default", { enumerable: !0, value: ae }), 2 & le && typeof ae != "string") for (var Ee in ae) ne.d(ge, Ee, (function(oe) {
          return ae[oe];
        }).bind(null, Ee));
        return ge;
      }, ne.n = function(ae) {
        var le = ae && ae.__esModule ? function() {
          return ae.default;
        } : function() {
          return ae;
        };
        return ne.d(le, "a", le), le;
      }, ne.o = function(ae, le) {
        return Object.prototype.hasOwnProperty.call(ae, le);
      }, ne.p = "/", ne(ne.s = 1);
    }([function(ie, se) {
      ie.exports = Y;
    }, function(ie, se, ne) {
      ie.exports = ne(2);
    }, function(ie, se, ne) {
      function ae(Bt, Ct) {
        if (Bt == null) return {};
        var qt, jt, Ht = function(Ut, Nt) {
          if (Ut == null) return {};
          var Kt, Ft, bt = {}, Xe = Object.keys(Ut);
          for (Ft = 0; Ft < Xe.length; Ft++) Kt = Xe[Ft], Nt.indexOf(Kt) >= 0 || (bt[Kt] = Ut[Kt]);
          return bt;
        }(Bt, Ct);
        if (Object.getOwnPropertySymbols) {
          var Yt = Object.getOwnPropertySymbols(Bt);
          for (jt = 0; jt < Yt.length; jt++) qt = Yt[jt], Ct.indexOf(qt) >= 0 || Object.prototype.propertyIsEnumerable.call(Bt, qt) && (Ht[qt] = Bt[qt]);
        }
        return Ht;
      }
      ne.r(se);
      var le = ne(0), ge = ne.n(le), Ee = function(Bt) {
        for (var Ct = 0, qt = 0; qt < Bt.length; qt++)
          Ct = (Ct << 5) - Ct + Bt.charCodeAt(qt), Ct &= Ct;
        return Math.abs(Ct);
      }, oe = function(Bt, Ct) {
        return Math.floor(Bt / Math.pow(10, Ct) % 10);
      }, Pe = function(Bt, Ct) {
        return !(oe(Bt, Ct) % 2);
      }, Ve = function(Bt, Ct, qt) {
        var jt = Bt % Ct;
        return qt && oe(Bt, qt) % 2 === 0 ? -jt : jt;
      }, Ke = function(Bt, Ct, qt) {
        return Ct[Bt % qt];
      }, ht = function(Bt) {
        var Ct = Bt.name, qt = Bt.colors, jt = Bt.title, Ht = Bt.square, Yt = Bt.size, Ut = ae(Bt, ["name", "colors", "title", "square", "size"]), Nt = function(Ft, bt) {
          var Xe = Ee(Ft), ve = bt && bt.length;
          return Array.from({ length: 3 }, function(Ce, Qe) {
            return { color: Ke(Xe + Qe, bt, ve), translateX: Ve(Xe * (Qe + 1), 8, 1), translateY: Ve(Xe * (Qe + 1), 8, 2), scale: 1.2 + Ve(Xe * (Qe + 1), 4) / 10, rotate: Ve(Xe * (Qe + 1), 360, 1) };
          });
        }(Ct, qt), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), jt && le.createElement("title", null, Ct), le.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: Ht ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 80, height: 80, fill: Nt[0].color }), le.createElement("path", { filter: "url(#filter_".concat(Kt, ")"), d: "M32.414 59.35L50.376 70.5H72.5v-71H33.728L26.5 13.381l19.057 27.08L32.414 59.35z", fill: Nt[1].color, transform: "translate(" + Nt[1].translateX + " " + Nt[1].translateY + ") rotate(" + Nt[1].rotate + " 40 40) scale(" + Nt[2].scale + ")" }), le.createElement("path", { filter: "url(#filter_".concat(Kt, ")"), style: { mixBlendMode: "overlay" }, d: "M22.216 24L0 46.75l14.108 38.129L78 86l-3.081-59.276-22.378 4.005 12.972 20.186-23.35 27.395L22.215 24z", fill: Nt[2].color, transform: "translate(" + Nt[2].translateX + " " + Nt[2].translateY + ") rotate(" + Nt[2].rotate + " 40 40) scale(" + Nt[2].scale + ")" })), le.createElement("defs", null, le.createElement("filter", { id: "filter_".concat(Kt), filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB" }, le.createElement("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), le.createElement("feBlend", { in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), le.createElement("feGaussianBlur", { stdDeviation: 7, result: "effect1_foregroundBlur" }))));
      }, _t = { pixel: function(Bt) {
        var Ct = Bt.name, qt = Bt.colors, jt = Bt.title, Ht = Bt.square, Yt = Bt.size, Ut = ae(Bt, ["name", "colors", "title", "square", "size"]), Nt = function(Ft, bt) {
          var Xe = Ee(Ft), ve = bt && bt.length;
          return Array.from({ length: 64 }, function(Ce, Qe) {
            return Ke(Xe % (Qe + 1), bt, ve);
          });
        }(Ct, qt), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), jt && le.createElement("title", null, Ct), le.createElement("mask", { id: Kt, "mask-type": "alpha", maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: Ht ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 10, height: 10, fill: Nt[0] }), le.createElement("rect", { x: 20, width: 10, height: 10, fill: Nt[1] }), le.createElement("rect", { x: 40, width: 10, height: 10, fill: Nt[2] }), le.createElement("rect", { x: 60, width: 10, height: 10, fill: Nt[3] }), le.createElement("rect", { x: 10, width: 10, height: 10, fill: Nt[4] }), le.createElement("rect", { x: 30, width: 10, height: 10, fill: Nt[5] }), le.createElement("rect", { x: 50, width: 10, height: 10, fill: Nt[6] }), le.createElement("rect", { x: 70, width: 10, height: 10, fill: Nt[7] }), le.createElement("rect", { y: 10, width: 10, height: 10, fill: Nt[8] }), le.createElement("rect", { y: 20, width: 10, height: 10, fill: Nt[9] }), le.createElement("rect", { y: 30, width: 10, height: 10, fill: Nt[10] }), le.createElement("rect", { y: 40, width: 10, height: 10, fill: Nt[11] }), le.createElement("rect", { y: 50, width: 10, height: 10, fill: Nt[12] }), le.createElement("rect", { y: 60, width: 10, height: 10, fill: Nt[13] }), le.createElement("rect", { y: 70, width: 10, height: 10, fill: Nt[14] }), le.createElement("rect", { x: 20, y: 10, width: 10, height: 10, fill: Nt[15] }), le.createElement("rect", { x: 20, y: 20, width: 10, height: 10, fill: Nt[16] }), le.createElement("rect", { x: 20, y: 30, width: 10, height: 10, fill: Nt[17] }), le.createElement("rect", { x: 20, y: 40, width: 10, height: 10, fill: Nt[18] }), le.createElement("rect", { x: 20, y: 50, width: 10, height: 10, fill: Nt[19] }), le.createElement("rect", { x: 20, y: 60, width: 10, height: 10, fill: Nt[20] }), le.createElement("rect", { x: 20, y: 70, width: 10, height: 10, fill: Nt[21] }), le.createElement("rect", { x: 40, y: 10, width: 10, height: 10, fill: Nt[22] }), le.createElement("rect", { x: 40, y: 20, width: 10, height: 10, fill: Nt[23] }), le.createElement("rect", { x: 40, y: 30, width: 10, height: 10, fill: Nt[24] }), le.createElement("rect", { x: 40, y: 40, width: 10, height: 10, fill: Nt[25] }), le.createElement("rect", { x: 40, y: 50, width: 10, height: 10, fill: Nt[26] }), le.createElement("rect", { x: 40, y: 60, width: 10, height: 10, fill: Nt[27] }), le.createElement("rect", { x: 40, y: 70, width: 10, height: 10, fill: Nt[28] }), le.createElement("rect", { x: 60, y: 10, width: 10, height: 10, fill: Nt[29] }), le.createElement("rect", { x: 60, y: 20, width: 10, height: 10, fill: Nt[30] }), le.createElement("rect", { x: 60, y: 30, width: 10, height: 10, fill: Nt[31] }), le.createElement("rect", { x: 60, y: 40, width: 10, height: 10, fill: Nt[32] }), le.createElement("rect", { x: 60, y: 50, width: 10, height: 10, fill: Nt[33] }), le.createElement("rect", { x: 60, y: 60, width: 10, height: 10, fill: Nt[34] }), le.createElement("rect", { x: 60, y: 70, width: 10, height: 10, fill: Nt[35] }), le.createElement("rect", { x: 10, y: 10, width: 10, height: 10, fill: Nt[36] }), le.createElement("rect", { x: 10, y: 20, width: 10, height: 10, fill: Nt[37] }), le.createElement("rect", { x: 10, y: 30, width: 10, height: 10, fill: Nt[38] }), le.createElement("rect", { x: 10, y: 40, width: 10, height: 10, fill: Nt[39] }), le.createElement("rect", { x: 10, y: 50, width: 10, height: 10, fill: Nt[40] }), le.createElement("rect", { x: 10, y: 60, width: 10, height: 10, fill: Nt[41] }), le.createElement("rect", { x: 10, y: 70, width: 10, height: 10, fill: Nt[42] }), le.createElement("rect", { x: 30, y: 10, width: 10, height: 10, fill: Nt[43] }), le.createElement("rect", { x: 30, y: 20, width: 10, height: 10, fill: Nt[44] }), le.createElement("rect", { x: 30, y: 30, width: 10, height: 10, fill: Nt[45] }), le.createElement("rect", { x: 30, y: 40, width: 10, height: 10, fill: Nt[46] }), le.createElement("rect", { x: 30, y: 50, width: 10, height: 10, fill: Nt[47] }), le.createElement("rect", { x: 30, y: 60, width: 10, height: 10, fill: Nt[48] }), le.createElement("rect", { x: 30, y: 70, width: 10, height: 10, fill: Nt[49] }), le.createElement("rect", { x: 50, y: 10, width: 10, height: 10, fill: Nt[50] }), le.createElement("rect", { x: 50, y: 20, width: 10, height: 10, fill: Nt[51] }), le.createElement("rect", { x: 50, y: 30, width: 10, height: 10, fill: Nt[52] }), le.createElement("rect", { x: 50, y: 40, width: 10, height: 10, fill: Nt[53] }), le.createElement("rect", { x: 50, y: 50, width: 10, height: 10, fill: Nt[54] }), le.createElement("rect", { x: 50, y: 60, width: 10, height: 10, fill: Nt[55] }), le.createElement("rect", { x: 50, y: 70, width: 10, height: 10, fill: Nt[56] }), le.createElement("rect", { x: 70, y: 10, width: 10, height: 10, fill: Nt[57] }), le.createElement("rect", { x: 70, y: 20, width: 10, height: 10, fill: Nt[58] }), le.createElement("rect", { x: 70, y: 30, width: 10, height: 10, fill: Nt[59] }), le.createElement("rect", { x: 70, y: 40, width: 10, height: 10, fill: Nt[60] }), le.createElement("rect", { x: 70, y: 50, width: 10, height: 10, fill: Nt[61] }), le.createElement("rect", { x: 70, y: 60, width: 10, height: 10, fill: Nt[62] }), le.createElement("rect", { x: 70, y: 70, width: 10, height: 10, fill: Nt[63] })));
      }, bauhaus: function(Bt) {
        var Ct = Bt.name, qt = Bt.colors, jt = Bt.title, Ht = Bt.square, Yt = Bt.size, Ut = ae(Bt, ["name", "colors", "title", "square", "size"]), Nt = function(Ft, bt) {
          var Xe = Ee(Ft), ve = bt && bt.length;
          return Array.from({ length: 4 }, function(Ce, Qe) {
            return { color: Ke(Xe + Qe, bt, ve), translateX: Ve(Xe * (Qe + 1), 40 - (Qe + 17), 1), translateY: Ve(Xe * (Qe + 1), 40 - (Qe + 17), 2), rotate: Ve(Xe * (Qe + 1), 360), isSquare: Pe(Xe, 2) };
          });
        }(Ct, qt), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), jt && le.createElement("title", null, Ct), le.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: Ht ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 80, height: 80, fill: Nt[0].color }), le.createElement("rect", { x: 10, y: 30, width: 80, height: Nt[1].isSquare ? 80 : 10, fill: Nt[1].color, transform: "translate(" + Nt[1].translateX + " " + Nt[1].translateY + ") rotate(" + Nt[1].rotate + " 40 40)" }), le.createElement("circle", { cx: 40, cy: 40, fill: Nt[2].color, r: 16, transform: "translate(" + Nt[2].translateX + " " + Nt[2].translateY + ")" }), le.createElement("line", { x1: 0, y1: 40, x2: 80, y2: 40, strokeWidth: 2, stroke: Nt[3].color, transform: "translate(" + Nt[3].translateX + " " + Nt[3].translateY + ") rotate(" + Nt[3].rotate + " 40 40)" })));
      }, ring: function(Bt) {
        var Ct = Bt.name, qt = Bt.colors, jt = Bt.title, Ht = Bt.square, Yt = Bt.size, Ut = ae(Bt, ["name", "colors", "title", "square", "size"]), Nt = function(Ft, bt) {
          var Xe = Ee(bt), ve = Ft && Ft.length, Ce = Array.from({ length: 5 }, function(vt, wt) {
            return Ke(Xe + wt, Ft, ve);
          }), Qe = [];
          return Qe[0] = Ce[0], Qe[1] = Ce[1], Qe[2] = Ce[1], Qe[3] = Ce[2], Qe[4] = Ce[2], Qe[5] = Ce[3], Qe[6] = Ce[3], Qe[7] = Ce[0], Qe[8] = Ce[4], Qe;
        }(qt, Ct), Kt = ge.a.useId();
        return ge.a.createElement("svg", Object.assign({ viewBox: "0 0 90 90", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), jt && ge.a.createElement("title", null, Ct), ge.a.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 90, height: 90 }, ge.a.createElement("rect", { width: 90, height: 90, rx: Ht ? void 0 : 180, fill: "#FFFFFF" })), ge.a.createElement("g", { mask: "url(#".concat(Kt, ")") }, ge.a.createElement("path", { d: "M0 0h90v45H0z", fill: Nt[0] }), ge.a.createElement("path", { d: "M0 45h90v45H0z", fill: Nt[1] }), ge.a.createElement("path", { d: "M83 45a38 38 0 00-76 0h76z", fill: Nt[2] }), ge.a.createElement("path", { d: "M83 45a38 38 0 01-76 0h76z", fill: Nt[3] }), ge.a.createElement("path", { d: "M77 45a32 32 0 10-64 0h64z", fill: Nt[4] }), ge.a.createElement("path", { d: "M77 45a32 32 0 11-64 0h64z", fill: Nt[5] }), ge.a.createElement("path", { d: "M71 45a26 26 0 00-52 0h52z", fill: Nt[6] }), ge.a.createElement("path", { d: "M71 45a26 26 0 01-52 0h52z", fill: Nt[7] }), ge.a.createElement("circle", { cx: 45, cy: 45, r: 23, fill: Nt[8] })));
      }, beam: function(Bt) {
        var Ct = Bt.name, qt = Bt.colors, jt = Bt.title, Ht = Bt.square, Yt = Bt.size, Ut = ae(Bt, ["name", "colors", "title", "square", "size"]), Nt = function(Ft, bt) {
          var Xe, ve = Ee(Ft), Ce = bt && bt.length, Qe = Ke(ve, bt, Ce), vt = Ve(ve, 10, 1), wt = vt < 5 ? vt + 4 : vt, $t = Ve(ve, 10, 2), xt = $t < 5 ? $t + 4 : $t;
          return { wrapperColor: Qe, faceColor: (Xe = Qe, Xe.slice(0, 1) === "#" && (Xe = Xe.slice(1)), (299 * parseInt(Xe.substr(0, 2), 16) + 587 * parseInt(Xe.substr(2, 2), 16) + 114 * parseInt(Xe.substr(4, 2), 16)) / 1e3 >= 128 ? "#000000" : "#FFFFFF"), backgroundColor: Ke(ve + 13, bt, Ce), wrapperTranslateX: wt, wrapperTranslateY: xt, wrapperRotate: Ve(ve, 360), wrapperScale: 1 + Ve(ve, 3) / 10, isMouthOpen: Pe(ve, 2), isCircle: Pe(ve, 1), eyeSpread: Ve(ve, 5), mouthSpread: Ve(ve, 3), faceRotate: Ve(ve, 10, 3), faceTranslateX: wt > 6 ? wt / 2 : Ve(ve, 8, 1), faceTranslateY: xt > 6 ? xt / 2 : Ve(ve, 7, 2) };
        }(Ct, qt), Kt = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 36 36", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), jt && le.createElement("title", null, Ct), le.createElement("mask", { id: Kt, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 36, height: 36 }, le.createElement("rect", { width: 36, height: 36, rx: Ht ? void 0 : 72, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Kt, ")") }, le.createElement("rect", { width: 36, height: 36, fill: Nt.backgroundColor }), le.createElement("rect", { x: "0", y: "0", width: 36, height: 36, transform: "translate(" + Nt.wrapperTranslateX + " " + Nt.wrapperTranslateY + ") rotate(" + Nt.wrapperRotate + " 18 18) scale(" + Nt.wrapperScale + ")", fill: Nt.wrapperColor, rx: Nt.isCircle ? 36 : 6 }), le.createElement("g", { transform: "translate(" + Nt.faceTranslateX + " " + Nt.faceTranslateY + ") rotate(" + Nt.faceRotate + " 18 18)" }, Nt.isMouthOpen ? le.createElement("path", { d: "M15 " + (19 + Nt.mouthSpread) + "c2 1 4 1 6 0", stroke: Nt.faceColor, fill: "none", strokeLinecap: "round" }) : le.createElement("path", { d: "M13," + (19 + Nt.mouthSpread) + " a1,0.75 0 0,0 10,0", fill: Nt.faceColor }), le.createElement("rect", { x: 14 - Nt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Nt.faceColor }), le.createElement("rect", { x: 20 + Nt.eyeSpread, y: 14, width: 1.5, height: 2, rx: 1, stroke: "none", fill: Nt.faceColor }))));
      }, sunset: function(Bt) {
        var Ct = Bt.name, qt = Bt.colors, jt = Bt.title, Ht = Bt.square, Yt = Bt.size, Ut = ae(Bt, ["name", "colors", "title", "square", "size"]), Nt = function(bt, Xe) {
          var ve = Ee(bt), Ce = Xe && Xe.length;
          return Array.from({ length: 4 }, function(Qe, vt) {
            return Ke(ve + vt, Xe, Ce);
          });
        }(Ct, qt), Kt = Ct.replace(/\s/g, ""), Ft = le.useId();
        return le.createElement("svg", Object.assign({ viewBox: "0 0 80 80", fill: "none", role: "img", xmlns: "http://www.w3.org/2000/svg", width: Yt, height: Yt }, Ut), jt && le.createElement("title", null, Ct), le.createElement("mask", { id: Ft, maskUnits: "userSpaceOnUse", x: 0, y: 0, width: 80, height: 80 }, le.createElement("rect", { width: 80, height: 80, rx: Ht ? void 0 : 160, fill: "#FFFFFF" })), le.createElement("g", { mask: "url(#".concat(Ft, ")") }, le.createElement("path", { fill: "url(#gradient_paint0_linear_" + Kt + ")", d: "M0 0h80v40H0z" }), le.createElement("path", { fill: "url(#gradient_paint1_linear_" + Kt + ")", d: "M0 40h80v40H0z" })), le.createElement("defs", null, le.createElement("linearGradient", { id: "gradient_paint0_linear_" + Kt, x1: 40, y1: 0, x2: 40, y2: 40, gradientUnits: "userSpaceOnUse" }, le.createElement("stop", { stopColor: Nt[0] }), le.createElement("stop", { offset: 1, stopColor: Nt[1] })), le.createElement("linearGradient", { id: "gradient_paint1_linear_" + Kt, x1: 40, y1: 40, x2: 40, y2: 80, gradientUnits: "userSpaceOnUse" }, le.createElement("stop", { stopColor: Nt[2] }), le.createElement("stop", { offset: 1, stopColor: Nt[3] }))));
      }, marble: ht }, Rt = { geometric: "beam", abstract: "bauhaus" }, kt = function(Bt) {
        var Ct = Bt.variant, qt = Ct === void 0 ? "marble" : Ct, jt = Bt.colors, Ht = jt === void 0 ? ["#92A1C6", "#146A7C", "#F0AB3D", "#C271B4", "#C20D90"] : jt, Yt = Bt.name, Ut = Yt === void 0 ? "Clara Barton" : Yt, Nt = Bt.title, Kt = Nt !== void 0 && Nt, Ft = Bt.size, bt = Bt.square, Xe = bt !== void 0 && bt, ve = ae(Bt, ["variant", "colors", "name", "title", "size", "square"]), Ce = _t[Rt[qt] || qt] || ht;
        return ge.a.createElement(Ce, Object.assign({ colors: Ht, name: Ut, title: Kt, size: Ft, square: Xe }, ve));
      };
      se.default = kt;
    }]);
  });
})(build);
var buildExports = build.exports;
const Avatar = /* @__PURE__ */ getDefaultExportFromCjs(buildExports), $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof document < "u" ? React__default.useLayoutEffect : () => {
};
function $8ae05eaa5c114e9c$export$7f54fc3180508a52(B) {
  const z = useRef(null);
  return $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    z.current = B;
  }, [
    B
  ]), useCallback((...Y) => {
    const ie = z.current;
    return ie == null ? void 0 : ie(...Y);
  }, []);
}
const $431fbd86ca7dc216$export$b204af158042fbac = (B) => {
  var z;
  return (z = B == null ? void 0 : B.ownerDocument) !== null && z !== void 0 ? z : document;
}, $431fbd86ca7dc216$export$f21a1ffae260145a = (B) => B && "window" in B && B.window === B ? B : $431fbd86ca7dc216$export$b204af158042fbac(B).defaultView || window;
function $c87311424ea30a05$var$testUserAgent(B) {
  var z;
  return typeof window > "u" || window.navigator == null ? !1 : ((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.brands.some((Y) => B.test(Y.brand))) || B.test(window.navigator.userAgent);
}
function $c87311424ea30a05$var$testPlatform(B) {
  var z;
  return typeof window < "u" && window.navigator != null ? B.test(((z = window.navigator.userAgentData) === null || z === void 0 ? void 0 : z.platform) || window.navigator.platform) : !1;
}
function $c87311424ea30a05$var$cached(B) {
  let z = null;
  return () => (z == null && (z = B()), z);
}
const $c87311424ea30a05$export$9ac100e40613ea10 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testPlatform(/^Mac/i);
}), $c87311424ea30a05$export$a11b0059900ceec8 = $c87311424ea30a05$var$cached(function() {
  return $c87311424ea30a05$var$testUserAgent(/Android/i);
});
function $6a7db85432448f7f$export$60278871457622de(B) {
  return B.mozInputSource === 0 && B.isTrusted ? !0 : $c87311424ea30a05$export$a11b0059900ceec8() && B.pointerType ? B.type === "click" && B.buttons === 1 : B.detail === 0 && !B.pointerType;
}
class $8a9cb279dc87e130$export$905e7fc544a71f36 {
  isDefaultPrevented() {
    return this.nativeEvent.defaultPrevented;
  }
  preventDefault() {
    this.defaultPrevented = !0, this.nativeEvent.preventDefault();
  }
  stopPropagation() {
    this.nativeEvent.stopPropagation(), this.isPropagationStopped = () => !0;
  }
  isPropagationStopped() {
    return !1;
  }
  persist() {
  }
  constructor(z, Y) {
    this.nativeEvent = Y, this.target = Y.target, this.currentTarget = Y.currentTarget, this.relatedTarget = Y.relatedTarget, this.bubbles = Y.bubbles, this.cancelable = Y.cancelable, this.defaultPrevented = Y.defaultPrevented, this.eventPhase = Y.eventPhase, this.isTrusted = Y.isTrusted, this.timeStamp = Y.timeStamp, this.type = z;
  }
}
function $8a9cb279dc87e130$export$715c682d09d639cc(B) {
  let z = useRef({
    isFocused: !1,
    observer: null
  });
  $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(() => {
    const ie = z.current;
    return () => {
      ie.observer && (ie.observer.disconnect(), ie.observer = null);
    };
  }, []);
  let Y = $8ae05eaa5c114e9c$export$7f54fc3180508a52((ie) => {
    B == null || B(ie);
  });
  return useCallback((ie) => {
    if (ie.target instanceof HTMLButtonElement || ie.target instanceof HTMLInputElement || ie.target instanceof HTMLTextAreaElement || ie.target instanceof HTMLSelectElement) {
      z.current.isFocused = !0;
      let se = ie.target, ne = (ae) => {
        z.current.isFocused = !1, se.disabled && Y(new $8a9cb279dc87e130$export$905e7fc544a71f36("blur", ae)), z.current.observer && (z.current.observer.disconnect(), z.current.observer = null);
      };
      se.addEventListener("focusout", ne, {
        once: !0
      }), z.current.observer = new MutationObserver(() => {
        if (z.current.isFocused && se.disabled) {
          var ae;
          (ae = z.current.observer) === null || ae === void 0 || ae.disconnect();
          let le = se === document.activeElement ? null : document.activeElement;
          se.dispatchEvent(new FocusEvent("blur", {
            relatedTarget: le
          })), se.dispatchEvent(new FocusEvent("focusout", {
            bubbles: !0,
            relatedTarget: le
          }));
        }
      }), z.current.observer.observe(se, {
        attributes: !0,
        attributeFilter: [
          "disabled"
        ]
      });
    }
  }, [
    Y
  ]);
}
function $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(B) {
  let { isDisabled: z, onFocus: Y, onBlur: ie, onFocusChange: se } = B;
  const ne = useCallback((ge) => {
    if (ge.target === ge.currentTarget)
      return ie && ie(ge), se && se(!1), !0;
  }, [
    ie,
    se
  ]), ae = $8a9cb279dc87e130$export$715c682d09d639cc(ne), le = useCallback((ge) => {
    const Ee = $431fbd86ca7dc216$export$b204af158042fbac(ge.target);
    ge.target === ge.currentTarget && Ee.activeElement === ge.target && (Y && Y(ge), se && se(!0), ae(ge));
  }, [
    se,
    Y,
    ae
  ]);
  return {
    focusProps: {
      onFocus: !z && (Y || se || ie) ? le : void 0,
      onBlur: !z && (ie || se) ? ne : void 0
    }
  };
}
let $507fabe10e71c6fb$var$currentModality = null, $507fabe10e71c6fb$var$changeHandlers = /* @__PURE__ */ new Set(), $507fabe10e71c6fb$export$d90243b58daecda7 = /* @__PURE__ */ new Map(), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1;
const $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {
  Tab: !0,
  Escape: !0
};
function $507fabe10e71c6fb$var$triggerChangeHandlers(B, z) {
  for (let Y of $507fabe10e71c6fb$var$changeHandlers) Y(B, z);
}
function $507fabe10e71c6fb$var$isValidKey(B) {
  return !(B.metaKey || !$c87311424ea30a05$export$9ac100e40613ea10() && B.altKey || B.ctrlKey || B.key === "Control" || B.key === "Shift" || B.key === "Meta");
}
function $507fabe10e71c6fb$var$handleKeyboardEvent(B) {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$isValidKey(B) && ($507fabe10e71c6fb$var$currentModality = "keyboard", $507fabe10e71c6fb$var$triggerChangeHandlers("keyboard", B));
}
function $507fabe10e71c6fb$var$handlePointerEvent(B) {
  $507fabe10e71c6fb$var$currentModality = "pointer", (B.type === "mousedown" || B.type === "pointerdown") && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$triggerChangeHandlers("pointer", B));
}
function $507fabe10e71c6fb$var$handleClickEvent(B) {
  $6a7db85432448f7f$export$60278871457622de(B) && ($507fabe10e71c6fb$var$hasEventBeforeFocus = !0, $507fabe10e71c6fb$var$currentModality = "virtual");
}
function $507fabe10e71c6fb$var$handleFocusEvent(B) {
  B.target === window || B.target === document || (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently && ($507fabe10e71c6fb$var$currentModality = "virtual", $507fabe10e71c6fb$var$triggerChangeHandlers("virtual", B)), $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !1);
}
function $507fabe10e71c6fb$var$handleWindowBlur() {
  $507fabe10e71c6fb$var$hasEventBeforeFocus = !1, $507fabe10e71c6fb$var$hasBlurredWindowRecently = !0;
}
function $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) {
  if (typeof window > "u" || $507fabe10e71c6fb$export$d90243b58daecda7.get($431fbd86ca7dc216$export$f21a1ffae260145a(B))) return;
  const z = $431fbd86ca7dc216$export$f21a1ffae260145a(B), Y = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let ie = z.HTMLElement.prototype.focus;
  z.HTMLElement.prototype.focus = function() {
    $507fabe10e71c6fb$var$hasEventBeforeFocus = !0, ie.apply(this, arguments);
  }, Y.addEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), Y.addEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), z.addEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), z.addEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (Y.addEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (Y.addEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), Y.addEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), z.addEventListener("beforeunload", () => {
    $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B);
  }, {
    once: !0
  }), $507fabe10e71c6fb$export$d90243b58daecda7.set(z, {
    focus: ie
  });
}
const $507fabe10e71c6fb$var$tearDownWindowFocusTracking = (B, z) => {
  const Y = $431fbd86ca7dc216$export$f21a1ffae260145a(B), ie = $431fbd86ca7dc216$export$b204af158042fbac(B);
  z && ie.removeEventListener("DOMContentLoaded", z), $507fabe10e71c6fb$export$d90243b58daecda7.has(Y) && (Y.HTMLElement.prototype.focus = $507fabe10e71c6fb$export$d90243b58daecda7.get(Y).focus, ie.removeEventListener("keydown", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ie.removeEventListener("keyup", $507fabe10e71c6fb$var$handleKeyboardEvent, !0), ie.removeEventListener("click", $507fabe10e71c6fb$var$handleClickEvent, !0), Y.removeEventListener("focus", $507fabe10e71c6fb$var$handleFocusEvent, !0), Y.removeEventListener("blur", $507fabe10e71c6fb$var$handleWindowBlur, !1), typeof PointerEvent < "u" ? (ie.removeEventListener("pointerdown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ie.removeEventListener("pointermove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ie.removeEventListener("pointerup", $507fabe10e71c6fb$var$handlePointerEvent, !0)) : (ie.removeEventListener("mousedown", $507fabe10e71c6fb$var$handlePointerEvent, !0), ie.removeEventListener("mousemove", $507fabe10e71c6fb$var$handlePointerEvent, !0), ie.removeEventListener("mouseup", $507fabe10e71c6fb$var$handlePointerEvent, !0)), $507fabe10e71c6fb$export$d90243b58daecda7.delete(Y));
};
function $507fabe10e71c6fb$export$2f1888112f558a7d(B) {
  const z = $431fbd86ca7dc216$export$b204af158042fbac(B);
  let Y;
  return z.readyState !== "loading" ? $507fabe10e71c6fb$var$setupGlobalFocusEvents(B) : (Y = () => {
    $507fabe10e71c6fb$var$setupGlobalFocusEvents(B);
  }, z.addEventListener("DOMContentLoaded", Y)), () => $507fabe10e71c6fb$var$tearDownWindowFocusTracking(B, Y);
}
typeof document < "u" && $507fabe10e71c6fb$export$2f1888112f558a7d();
function $507fabe10e71c6fb$export$b9b3dfddab17db27() {
  return $507fabe10e71c6fb$var$currentModality !== "pointer";
}
const $507fabe10e71c6fb$var$nonTextInputTypes = /* @__PURE__ */ new Set([
  "checkbox",
  "radio",
  "range",
  "color",
  "file",
  "image",
  "button",
  "submit",
  "reset"
]);
function $507fabe10e71c6fb$var$isKeyboardFocusEvent(B, z, Y) {
  var ie;
  const se = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLInputElement : HTMLInputElement, ne = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLTextAreaElement : HTMLTextAreaElement, ae = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).HTMLElement : HTMLElement, le = typeof window < "u" ? $431fbd86ca7dc216$export$f21a1ffae260145a(Y == null ? void 0 : Y.target).KeyboardEvent : KeyboardEvent;
  return B = B || (Y == null ? void 0 : Y.target) instanceof se && !$507fabe10e71c6fb$var$nonTextInputTypes.has(Y == null || (ie = Y.target) === null || ie === void 0 ? void 0 : ie.type) || (Y == null ? void 0 : Y.target) instanceof ne || (Y == null ? void 0 : Y.target) instanceof ae && (Y == null ? void 0 : Y.target.isContentEditable), !(B && z === "keyboard" && Y instanceof le && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[Y.key]);
}
function $507fabe10e71c6fb$export$ec71b4b83ac08ec3(B, z, Y) {
  $507fabe10e71c6fb$var$setupGlobalFocusEvents(), useEffect(() => {
    let ie = (se, ne) => {
      $507fabe10e71c6fb$var$isKeyboardFocusEvent(!!(Y != null && Y.isTextInput), se, ne) && B($507fabe10e71c6fb$export$b9b3dfddab17db27());
    };
    return $507fabe10e71c6fb$var$changeHandlers.add(ie), () => {
      $507fabe10e71c6fb$var$changeHandlers.delete(ie);
    };
  }, z);
}
function $9ab94262bd0047c7$export$420e68273165f4ec(B) {
  let { isDisabled: z, onBlurWithin: Y, onFocusWithin: ie, onFocusWithinChange: se } = B, ne = useRef({
    isFocusWithin: !1
  }), ae = useCallback((Ee) => {
    ne.current.isFocusWithin && !Ee.currentTarget.contains(Ee.relatedTarget) && (ne.current.isFocusWithin = !1, Y && Y(Ee), se && se(!1));
  }, [
    Y,
    se,
    ne
  ]), le = $8a9cb279dc87e130$export$715c682d09d639cc(ae), ge = useCallback((Ee) => {
    !ne.current.isFocusWithin && document.activeElement === Ee.target && (ie && ie(Ee), se && se(!0), ne.current.isFocusWithin = !0, le(Ee));
  }, [
    ie,
    se,
    le
  ]);
  return z ? {
    focusWithinProps: {
      // These should not have been null, that would conflict in mergeProps
      onFocus: void 0,
      onBlur: void 0
    }
  } : {
    focusWithinProps: {
      onFocus: ge,
      onBlur: ae
    }
  };
}
let $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1, $6179b936705e76d3$var$hoverCount = 0;
function $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {
  $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !0, setTimeout(() => {
    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = !1;
  }, 50);
}
function $6179b936705e76d3$var$handleGlobalPointerEvent(B) {
  B.pointerType === "touch" && $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();
}
function $6179b936705e76d3$var$setupGlobalTouchEvents() {
  if (!(typeof document > "u"))
    return typeof PointerEvent < "u" ? document.addEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.addEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents), $6179b936705e76d3$var$hoverCount++, () => {
      $6179b936705e76d3$var$hoverCount--, !($6179b936705e76d3$var$hoverCount > 0) && (typeof PointerEvent < "u" ? document.removeEventListener("pointerup", $6179b936705e76d3$var$handleGlobalPointerEvent) : document.removeEventListener("touchend", $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents));
    };
}
function $6179b936705e76d3$export$ae780daf29e6d456(B) {
  let { onHoverStart: z, onHoverChange: Y, onHoverEnd: ie, isDisabled: se } = B, [ne, ae] = useState(!1), le = useRef({
    isHovered: !1,
    ignoreEmulatedMouseEvents: !1,
    pointerType: "",
    target: null
  }).current;
  useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);
  let { hoverProps: ge, triggerHoverEnd: Ee } = useMemo(() => {
    let oe = (Ke, ht) => {
      if (le.pointerType = ht, se || ht === "touch" || le.isHovered || !Ke.currentTarget.contains(Ke.target)) return;
      le.isHovered = !0;
      let _t = Ke.currentTarget;
      le.target = _t, z && z({
        type: "hoverstart",
        target: _t,
        pointerType: ht
      }), Y && Y(!0), ae(!0);
    }, Pe = (Ke, ht) => {
      if (le.pointerType = "", le.target = null, ht === "touch" || !le.isHovered) return;
      le.isHovered = !1;
      let _t = Ke.currentTarget;
      ie && ie({
        type: "hoverend",
        target: _t,
        pointerType: ht
      }), Y && Y(!1), ae(!1);
    }, Ve = {};
    return typeof PointerEvent < "u" ? (Ve.onPointerEnter = (Ke) => {
      $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && Ke.pointerType === "mouse" || oe(Ke, Ke.pointerType);
    }, Ve.onPointerLeave = (Ke) => {
      !se && Ke.currentTarget.contains(Ke.target) && Pe(Ke, Ke.pointerType);
    }) : (Ve.onTouchStart = () => {
      le.ignoreEmulatedMouseEvents = !0;
    }, Ve.onMouseEnter = (Ke) => {
      !le.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && oe(Ke, "mouse"), le.ignoreEmulatedMouseEvents = !1;
    }, Ve.onMouseLeave = (Ke) => {
      !se && Ke.currentTarget.contains(Ke.target) && Pe(Ke, "mouse");
    }), {
      hoverProps: Ve,
      triggerHoverEnd: Pe
    };
  }, [
    z,
    Y,
    ie,
    se,
    le
  ]);
  return useEffect(() => {
    se && Ee({
      currentTarget: le.target
    }, le.pointerType);
  }, [
    se
  ]), {
    hoverProps: ge,
    isHovered: ne
  };
}
function $f7dceffc5ad7768b$export$4e328f61c538687f(B = {}) {
  let { autoFocus: z = !1, isTextInput: Y, within: ie } = B, se = useRef({
    isFocused: !1,
    isFocusVisible: z || $507fabe10e71c6fb$export$b9b3dfddab17db27()
  }), [ne, ae] = useState(!1), [le, ge] = useState(() => se.current.isFocused && se.current.isFocusVisible), Ee = useCallback(() => ge(se.current.isFocused && se.current.isFocusVisible), []), oe = useCallback((Ke) => {
    se.current.isFocused = Ke, ae(Ke), Ee();
  }, [
    Ee
  ]);
  $507fabe10e71c6fb$export$ec71b4b83ac08ec3((Ke) => {
    se.current.isFocusVisible = Ke, Ee();
  }, [], {
    isTextInput: Y
  });
  let { focusProps: Pe } = $a1ea59d68270f0dd$export$f8168d8dd8fd66e6({
    isDisabled: ie,
    onFocusChange: oe
  }), { focusWithinProps: Ve } = $9ab94262bd0047c7$export$420e68273165f4ec({
    isDisabled: !ie,
    onFocusWithinChange: oe
  });
  return {
    isFocused: ne,
    isFocusVisible: le,
    focusProps: ie ? Ve : Pe
  };
}
var i$7 = Object.defineProperty, d$3 = (B, z, Y) => z in B ? i$7(B, z, { enumerable: !0, configurable: !0, writable: !0, value: Y }) : B[z] = Y, r$4 = (B, z, Y) => (d$3(B, typeof z != "symbol" ? z + "" : z, Y), Y);
let o$6 = class {
  constructor() {
    r$4(this, "current", this.detect()), r$4(this, "handoffState", "pending"), r$4(this, "currentId", 0);
  }
  set(z) {
    this.current !== z && (this.handoffState = "pending", this.currentId = 0, this.current = z);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window > "u" || typeof document > "u" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
}, s$8 = new o$6();
function u$8(B) {
  return s$8.isServer ? null : B instanceof Node ? B.ownerDocument : B != null && B.hasOwnProperty("current") && B.current instanceof Node ? B.current.ownerDocument : document;
}
function t$4(B) {
  typeof queueMicrotask == "function" ? queueMicrotask(B) : Promise.resolve().then(B).catch((z) => setTimeout(() => {
    throw z;
  }));
}
function o$5() {
  let B = [], z = { addEventListener(Y, ie, se, ne) {
    return Y.addEventListener(ie, se, ne), z.add(() => Y.removeEventListener(ie, se, ne));
  }, requestAnimationFrame(...Y) {
    let ie = requestAnimationFrame(...Y);
    return z.add(() => cancelAnimationFrame(ie));
  }, nextFrame(...Y) {
    return z.requestAnimationFrame(() => z.requestAnimationFrame(...Y));
  }, setTimeout(...Y) {
    let ie = setTimeout(...Y);
    return z.add(() => clearTimeout(ie));
  }, microTask(...Y) {
    let ie = { current: !0 };
    return t$4(() => {
      ie.current && Y[0]();
    }), z.add(() => {
      ie.current = !1;
    });
  }, style(Y, ie, se) {
    let ne = Y.style.getPropertyValue(ie);
    return Object.assign(Y.style, { [ie]: se }), this.add(() => {
      Object.assign(Y.style, { [ie]: ne });
    });
  }, group(Y) {
    let ie = o$5();
    return Y(ie), this.add(() => ie.dispose());
  }, add(Y) {
    return B.includes(Y) || B.push(Y), () => {
      let ie = B.indexOf(Y);
      if (ie >= 0) for (let se of B.splice(ie, 1)) se();
    };
  }, dispose() {
    for (let Y of B.splice(0)) Y();
  } };
  return z;
}
function p$2() {
  let [B] = useState(o$5);
  return useEffect(() => () => B.dispose(), [B]), B;
}
let n$3 = (B, z) => {
  s$8.isServer ? useEffect(B, z) : useLayoutEffect(B, z);
};
function s$7(B) {
  let z = useRef(B);
  return n$3(() => {
    z.current = B;
  }, [B]), z;
}
let o$4 = function(B) {
  let z = s$7(B);
  return React__default.useCallback((...Y) => z.current(...Y), [z]);
};
function E$2(B) {
  let z = B.width / 2, Y = B.height / 2;
  return { top: B.clientY - Y, right: B.clientX + z, bottom: B.clientY + Y, left: B.clientX - z };
}
function P$3(B, z) {
  return !(!B || !z || B.right < z.left || B.left > z.right || B.bottom < z.top || B.top > z.bottom);
}
function w$5({ disabled: B = !1 } = {}) {
  let z = useRef(null), [Y, ie] = useState(!1), se = p$2(), ne = o$4(() => {
    z.current = null, ie(!1), se.dispose();
  }), ae = o$4((le) => {
    if (se.dispose(), z.current === null) {
      z.current = le.currentTarget, ie(!0);
      {
        let ge = u$8(le.currentTarget);
        se.addEventListener(ge, "pointerup", ne, !1), se.addEventListener(ge, "pointermove", (Ee) => {
          if (z.current) {
            let oe = E$2(Ee);
            ie(P$3(oe, z.current.getBoundingClientRect()));
          }
        }, !1), se.addEventListener(ge, "pointercancel", ne, !1);
      }
    }
  });
  return { pressed: Y, pressProps: B ? {} : { onPointerDown: ae, onPointerUp: ne, onClick: ne } };
}
let e$4 = createContext(void 0);
function a$b() {
  return useContext(e$4);
}
function t$3(...B) {
  return Array.from(new Set(B.flatMap((z) => typeof z == "string" ? z.split(" ") : []))).filter(Boolean).join(" ");
}
function u$7(B, z, ...Y) {
  if (B in z) {
    let se = z[B];
    return typeof se == "function" ? se(...Y) : se;
  }
  let ie = new Error(`Tried to handle "${B}" but there is no handler defined. Only defined handlers are: ${Object.keys(z).map((se) => `"${se}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(ie, u$7), ie;
}
var O$3 = ((B) => (B[B.None = 0] = "None", B[B.RenderStrategy = 1] = "RenderStrategy", B[B.Static = 2] = "Static", B))(O$3 || {}), A$1 = ((B) => (B[B.Unmount = 0] = "Unmount", B[B.Hidden = 1] = "Hidden", B))(A$1 || {});
function L$1() {
  let B = U$3();
  return useCallback((z) => C$3({ mergeRefs: B, ...z }), [B]);
}
function C$3({ ourProps: B, theirProps: z, slot: Y, defaultTag: ie, features: se, visible: ne = !0, name: ae, mergeRefs: le }) {
  le = le ?? $$1;
  let ge = P$2(z, B);
  if (ne) return F$2(ge, Y, ie, ae, le);
  let Ee = se ?? 0;
  if (Ee & 2) {
    let { static: oe = !1, ...Pe } = ge;
    if (oe) return F$2(Pe, Y, ie, ae, le);
  }
  if (Ee & 1) {
    let { unmount: oe = !0, ...Pe } = ge;
    return u$7(oe ? 0 : 1, { 0() {
      return null;
    }, 1() {
      return F$2({ ...Pe, hidden: !0, style: { display: "none" } }, Y, ie, ae, le);
    } });
  }
  return F$2(ge, Y, ie, ae, le);
}
function F$2(B, z = {}, Y, ie, se) {
  let { as: ne = Y, children: ae, refName: le = "ref", ...ge } = h$4(B, ["unmount", "static"]), Ee = B.ref !== void 0 ? { [le]: B.ref } : {}, oe = typeof ae == "function" ? ae(z) : ae;
  "className" in ge && ge.className && typeof ge.className == "function" && (ge.className = ge.className(z)), ge["aria-labelledby"] && ge["aria-labelledby"] === ge.id && (ge["aria-labelledby"] = void 0);
  let Pe = {};
  if (z) {
    let Ve = !1, Ke = [];
    for (let [ht, _t] of Object.entries(z)) typeof _t == "boolean" && (Ve = !0), _t === !0 && Ke.push(ht.replace(/([A-Z])/g, (Rt) => `-${Rt.toLowerCase()}`));
    if (Ve) {
      Pe["data-headlessui-state"] = Ke.join(" ");
      for (let ht of Ke) Pe[`data-${ht}`] = "";
    }
  }
  if (ne === Fragment && (Object.keys(m$4(ge)).length > 0 || Object.keys(m$4(Pe)).length > 0)) if (!isValidElement(oe) || Array.isArray(oe) && oe.length > 1) {
    if (Object.keys(m$4(ge)).length > 0) throw new Error(['Passing props on "Fragment"!', "", `The current component <${ie} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(m$4(ge)).concat(Object.keys(m$4(Pe))).map((Ve) => `  - ${Ve}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((Ve) => `  - ${Ve}`).join(`
`)].join(`
`));
  } else {
    let Ve = oe.props, Ke = Ve == null ? void 0 : Ve.className, ht = typeof Ke == "function" ? (...kt) => t$3(Ke(...kt), ge.className) : t$3(Ke, ge.className), _t = ht ? { className: ht } : {}, Rt = P$2(oe.props, m$4(h$4(ge, ["ref"])));
    for (let kt in Pe) kt in Rt && delete Pe[kt];
    return cloneElement(oe, Object.assign({}, Rt, Pe, Ee, { ref: se(H$3(oe), Ee.ref) }, _t));
  }
  return createElement(ne, Object.assign({}, h$4(ge, ["ref"]), ne !== Fragment && Ee, ne !== Fragment && Pe), oe);
}
function U$3() {
  let B = useRef([]), z = useCallback((Y) => {
    for (let ie of B.current) ie != null && (typeof ie == "function" ? ie(Y) : ie.current = Y);
  }, []);
  return (...Y) => {
    if (!Y.every((ie) => ie == null)) return B.current = Y, z;
  };
}
function $$1(...B) {
  return B.every((z) => z == null) ? void 0 : (z) => {
    for (let Y of B) Y != null && (typeof Y == "function" ? Y(z) : Y.current = z);
  };
}
function P$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ie of B) for (let se in ie) se.startsWith("on") && typeof ie[se] == "function" ? (Y[se] != null || (Y[se] = []), Y[se].push(ie[se])) : z[se] = ie[se];
  if (z.disabled || z["aria-disabled"]) for (let ie in Y) /^(on(?:Click|Pointer|Mouse|Key)(?:Down|Up|Press)?)$/.test(ie) && (Y[ie] = [(se) => {
    var ne;
    return (ne = se == null ? void 0 : se.preventDefault) == null ? void 0 : ne.call(se);
  }]);
  for (let ie in Y) Object.assign(z, { [ie](se, ...ne) {
    let ae = Y[ie];
    for (let le of ae) {
      if ((se instanceof Event || (se == null ? void 0 : se.nativeEvent) instanceof Event) && se.defaultPrevented) return;
      le(se, ...ne);
    }
  } });
  return z;
}
function _$2(...B) {
  if (B.length === 0) return {};
  if (B.length === 1) return B[0];
  let z = {}, Y = {};
  for (let ie of B) for (let se in ie) se.startsWith("on") && typeof ie[se] == "function" ? (Y[se] != null || (Y[se] = []), Y[se].push(ie[se])) : z[se] = ie[se];
  for (let ie in Y) Object.assign(z, { [ie](...se) {
    let ne = Y[ie];
    for (let ae of ne) ae == null || ae(...se);
  } });
  return z;
}
function K$1(B) {
  var z;
  return Object.assign(forwardRef(B), { displayName: (z = B.displayName) != null ? z : B.name });
}
function m$4(B) {
  let z = Object.assign({}, B);
  for (let Y in z) z[Y] === void 0 && delete z[Y];
  return z;
}
function h$4(B, z = []) {
  let Y = Object.assign({}, B);
  for (let ie of z) ie in Y && delete Y[ie];
  return Y;
}
function H$3(B) {
  return React__default.version.split(".")[0] >= "19" ? B.props.ref : B.ref;
}
let a$a = "span";
var s$6 = ((B) => (B[B.None = 1] = "None", B[B.Focusable = 2] = "Focusable", B[B.Hidden = 4] = "Hidden", B))(s$6 || {});
function l$2(B, z) {
  var Y;
  let { features: ie = 1, ...se } = B, ne = { ref: z, "aria-hidden": (ie & 2) === 2 ? !0 : (Y = se["aria-hidden"]) != null ? Y : void 0, hidden: (ie & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(ie & 4) === 4 && (ie & 2) !== 2 && { display: "none" } } };
  return L$1()({ ourProps: ne, theirProps: se, slot: {}, defaultTag: a$a, name: "Hidden" });
}
let f$9 = K$1(l$2), e$3 = createContext(void 0);
function u$6() {
  return useContext(e$3);
}
function r$3(B) {
  let z = B.parentElement, Y = null;
  for (; z && !(z instanceof HTMLFieldSetElement); ) z instanceof HTMLLegendElement && (Y = z), z = z.parentElement;
  let ie = (z == null ? void 0 : z.getAttribute("disabled")) === "";
  return ie && i$6(Y) ? !1 : ie;
}
function i$6(B) {
  if (!B) return !1;
  let z = B.previousElementSibling;
  for (; z !== null; ) {
    if (z instanceof HTMLLegendElement) return !1;
    z = z.previousElementSibling;
  }
  return !0;
}
let u$5 = Symbol();
function T$2(B, z = !0) {
  return Object.assign(B, { [u$5]: z });
}
function y$4(...B) {
  let z = useRef(B);
  useEffect(() => {
    z.current = B;
  }, [B]);
  let Y = o$4((ie) => {
    for (let se of z.current) se != null && (typeof se == "function" ? se(ie) : se.current = ie);
  });
  return B.every((ie) => ie == null || (ie == null ? void 0 : ie[u$5])) ? void 0 : Y;
}
let a$9 = createContext(null);
a$9.displayName = "DescriptionContext";
function f$8() {
  let B = useContext(a$9);
  if (B === null) {
    let z = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, f$8), z;
  }
  return B;
}
function w$4() {
  let [B, z] = useState([]);
  return [B.length > 0 ? B.join(" ") : void 0, useMemo(() => function(Y) {
    let ie = o$4((ne) => (z((ae) => [...ae, ne]), () => z((ae) => {
      let le = ae.slice(), ge = le.indexOf(ne);
      return ge !== -1 && le.splice(ge, 1), le;
    }))), se = useMemo(() => ({ register: ie, slot: Y.slot, name: Y.name, props: Y.props, value: Y.value }), [ie, Y.slot, Y.name, Y.props, Y.value]);
    return React__default.createElement(a$9.Provider, { value: se }, Y.children);
  }, [z])];
}
let S$2 = "p";
function C$2(B, z) {
  let Y = useId$1(), ie = a$b(), { id: se = `headlessui-description-${Y}`, ...ne } = B, ae = f$8(), le = y$4(z);
  n$3(() => ae.register(se), [se, ae.register]);
  let ge = ie || !1, Ee = useMemo(() => ({ ...ae.slot, disabled: ge }), [ae.slot, ge]), oe = { ref: le, ...ae.props, id: se };
  return L$1()({ ourProps: oe, theirProps: ne, slot: Ee, defaultTag: S$2, name: ae.name || "Description" });
}
let _$1 = K$1(C$2), H$2 = Object.assign(_$1, {});
var o$3 = ((B) => (B.Space = " ", B.Enter = "Enter", B.Escape = "Escape", B.Backspace = "Backspace", B.Delete = "Delete", B.ArrowLeft = "ArrowLeft", B.ArrowUp = "ArrowUp", B.ArrowRight = "ArrowRight", B.ArrowDown = "ArrowDown", B.Home = "Home", B.End = "End", B.PageUp = "PageUp", B.PageDown = "PageDown", B.Tab = "Tab", B))(o$3 || {});
let c$4 = createContext(null);
c$4.displayName = "LabelContext";
function P$1() {
  let B = useContext(c$4);
  if (B === null) {
    let z = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(z, P$1), z;
  }
  return B;
}
function I$3(B) {
  var z, Y, ie;
  let se = (Y = (z = useContext(c$4)) == null ? void 0 : z.value) != null ? Y : void 0;
  return ((ie = void 0) != null ? ie : 0) > 0 ? [se, ...B].filter(Boolean).join(" ") : se;
}
function K({ inherit: B = !1 } = {}) {
  let z = I$3(), [Y, ie] = useState([]), se = B ? [z, ...Y].filter(Boolean) : Y;
  return [se.length > 0 ? se.join(" ") : void 0, useMemo(() => function(ne) {
    let ae = o$4((ge) => (ie((Ee) => [...Ee, ge]), () => ie((Ee) => {
      let oe = Ee.slice(), Pe = oe.indexOf(ge);
      return Pe !== -1 && oe.splice(Pe, 1), oe;
    }))), le = useMemo(() => ({ register: ae, slot: ne.slot, name: ne.name, props: ne.props, value: ne.value }), [ae, ne.slot, ne.name, ne.props, ne.value]);
    return React__default.createElement(c$4.Provider, { value: le }, ne.children);
  }, [ie])];
}
let N$1 = "label";
function G$1(B, z) {
  var Y;
  let ie = useId$1(), se = P$1(), ne = u$6(), ae = a$b(), { id: le = `headlessui-label-${ie}`, htmlFor: ge = ne ?? ((Y = se.props) == null ? void 0 : Y.htmlFor), passive: Ee = !1, ...oe } = B, Pe = y$4(z);
  n$3(() => se.register(le), [le, se.register]);
  let Ve = o$4((Rt) => {
    let kt = Rt.currentTarget;
    if (kt instanceof HTMLLabelElement && Rt.preventDefault(), se.props && "onClick" in se.props && typeof se.props.onClick == "function" && se.props.onClick(Rt), kt instanceof HTMLLabelElement) {
      let Bt = document.getElementById(kt.htmlFor);
      if (Bt) {
        let Ct = Bt.getAttribute("disabled");
        if (Ct === "true" || Ct === "") return;
        let qt = Bt.getAttribute("aria-disabled");
        if (qt === "true" || qt === "") return;
        (Bt instanceof HTMLInputElement && (Bt.type === "radio" || Bt.type === "checkbox") || Bt.role === "radio" || Bt.role === "checkbox" || Bt.role === "switch") && Bt.click(), Bt.focus({ preventScroll: !0 });
      }
    }
  }), Ke = ae || !1, ht = useMemo(() => ({ ...se.slot, disabled: Ke }), [se.slot, Ke]), _t = { ref: Pe, ...se.props, id: le, htmlFor: ge, onClick: Ve };
  return Ee && ("onClick" in _t && (delete _t.htmlFor, delete _t.onClick), "onClick" in oe && delete oe.onClick), L$1()({ ourProps: _t, theirProps: oe, slot: ht, defaultTag: ge ? N$1 : "div", name: se.name || "Label" });
}
let U$2 = K$1(G$1);
Object.assign(U$2, {});
let e$2 = createContext(() => {
});
function C$1({ value: B, children: z }) {
  return React__default.createElement(e$2.Provider, { value: B }, z);
}
function f$7(B) {
  if (B === null) return { width: 0, height: 0 };
  let { width: z, height: Y } = B.getBoundingClientRect();
  return { width: z, height: Y };
}
function d$2(B, z = !1) {
  let [Y, ie] = useReducer(() => ({}), {}), se = useMemo(() => f$7(B), [B, Y]);
  return n$3(() => {
    if (!B) return;
    let ne = new ResizeObserver(ie);
    return ne.observe(B), () => {
      ne.disconnect();
    };
  }, [B]), z ? { width: `${se.width}px`, height: `${se.height}px` } : se;
}
let a$8 = class extends Map {
  constructor(z) {
    super(), this.factory = z;
  }
  get(z) {
    let Y = super.get(z);
    return Y === void 0 && (Y = this.factory(z), this.set(z, Y)), Y;
  }
};
function a$7(B, z) {
  let Y = B(), ie = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return Y;
  }, subscribe(se) {
    return ie.add(se), () => ie.delete(se);
  }, dispatch(se, ...ne) {
    let ae = z[se].call(Y, ...ne);
    ae && (Y = ae, ie.forEach((le) => le()));
  } };
}
function o$2(B) {
  return useSyncExternalStore(B.subscribe, B.getSnapshot, B.getSnapshot);
}
let p$1 = new a$8(() => a$7(() => [], { ADD(B) {
  return this.includes(B) ? this : [...this, B];
}, REMOVE(B) {
  let z = this.indexOf(B);
  if (z === -1) return this;
  let Y = this.slice();
  return Y.splice(z, 1), Y;
} }));
function x$3(B, z) {
  let Y = p$1.get(z), ie = useId$1(), se = o$2(Y);
  if (n$3(() => {
    if (B) return Y.dispatch("ADD", ie), () => Y.dispatch("REMOVE", ie);
  }, [Y, B]), !B) return !1;
  let ne = se.indexOf(ie), ae = se.length;
  return ne === -1 && (ne = ae, ae += 1), ne === ae - 1;
}
let f$6 = /* @__PURE__ */ new Map(), u$4 = /* @__PURE__ */ new Map();
function h$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 0;
  return u$4.set(B, Y + 1), Y !== 0 ? () => m$3(B) : (f$6.set(B, { "aria-hidden": B.getAttribute("aria-hidden"), inert: B.inert }), B.setAttribute("aria-hidden", "true"), B.inert = !0, () => m$3(B));
}
function m$3(B) {
  var z;
  let Y = (z = u$4.get(B)) != null ? z : 1;
  if (Y === 1 ? u$4.delete(B) : u$4.set(B, Y - 1), Y !== 1) return;
  let ie = f$6.get(B);
  ie && (ie["aria-hidden"] === null ? B.removeAttribute("aria-hidden") : B.setAttribute("aria-hidden", ie["aria-hidden"]), B.inert = ie.inert, f$6.delete(B));
}
function y$3(B, { allowed: z, disallowed: Y } = {}) {
  let ie = x$3(B, "inert-others");
  n$3(() => {
    var se, ne;
    if (!ie) return;
    let ae = o$5();
    for (let ge of (se = Y == null ? void 0 : Y()) != null ? se : []) ge && ae.add(h$3(ge));
    let le = (ne = z == null ? void 0 : z()) != null ? ne : [];
    for (let ge of le) {
      if (!ge) continue;
      let Ee = u$8(ge);
      if (!Ee) continue;
      let oe = ge.parentElement;
      for (; oe && oe !== Ee.body; ) {
        for (let Pe of oe.children) le.some((Ve) => Pe.contains(Ve)) || ae.add(h$3(Pe));
        oe = oe.parentElement;
      }
    }
    return ae.dispose;
  }, [ie, z, Y]);
}
function m$2(B, z, Y) {
  let ie = s$7((se) => {
    let ne = se.getBoundingClientRect();
    ne.x === 0 && ne.y === 0 && ne.width === 0 && ne.height === 0 && Y();
  });
  useEffect(() => {
    if (!B) return;
    let se = z === null ? null : z instanceof HTMLElement ? z : z.current;
    if (!se) return;
    let ne = o$5();
    if (typeof ResizeObserver < "u") {
      let ae = new ResizeObserver(() => ie.current(se));
      ae.observe(se), ne.add(() => ae.disconnect());
    }
    if (typeof IntersectionObserver < "u") {
      let ae = new IntersectionObserver(() => ie.current(se));
      ae.observe(se), ne.add(() => ae.disconnect());
    }
    return () => ne.dispose();
  }, [z, ie, B]);
}
let f$5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((B) => `${B}:not([tabindex='-1'])`).join(","), p = ["[data-autofocus]"].map((B) => `${B}:not([tabindex='-1'])`).join(",");
var F$1 = ((B) => (B[B.First = 1] = "First", B[B.Previous = 2] = "Previous", B[B.Next = 4] = "Next", B[B.Last = 8] = "Last", B[B.WrapAround = 16] = "WrapAround", B[B.NoScroll = 32] = "NoScroll", B[B.AutoFocus = 64] = "AutoFocus", B))(F$1 || {}), T$1 = ((B) => (B[B.Error = 0] = "Error", B[B.Overflow = 1] = "Overflow", B[B.Success = 2] = "Success", B[B.Underflow = 3] = "Underflow", B))(T$1 || {}), y$2 = ((B) => (B[B.Previous = -1] = "Previous", B[B.Next = 1] = "Next", B))(y$2 || {});
function b$2(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(f$5)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
function S$1(B = document.body) {
  return B == null ? [] : Array.from(B.querySelectorAll(p)).sort((z, Y) => Math.sign((z.tabIndex || Number.MAX_SAFE_INTEGER) - (Y.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var h$2 = ((B) => (B[B.Strict = 0] = "Strict", B[B.Loose = 1] = "Loose", B))(h$2 || {});
function A(B, z = 0) {
  var Y;
  return B === ((Y = u$8(B)) == null ? void 0 : Y.body) ? !1 : u$7(z, { 0() {
    return B.matches(f$5);
  }, 1() {
    let ie = B;
    for (; ie !== null; ) {
      if (ie.matches(f$5)) return !0;
      ie = ie.parentElement;
    }
    return !1;
  } });
}
function G(B) {
  let z = u$8(B);
  o$5().nextFrame(() => {
    z && !A(z.activeElement, 0) && I$2(B);
  });
}
var H$1 = ((B) => (B[B.Keyboard = 0] = "Keyboard", B[B.Mouse = 1] = "Mouse", B))(H$1 || {});
typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", (B) => {
  B.metaKey || B.altKey || B.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0), document.addEventListener("click", (B) => {
  B.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : B.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, !0));
function I$2(B) {
  B == null || B.focus({ preventScroll: !0 });
}
let w$3 = ["textarea", "input"].join(",");
function O$2(B) {
  var z, Y;
  return (Y = (z = B == null ? void 0 : B.matches) == null ? void 0 : z.call(B, w$3)) != null ? Y : !1;
}
function _(B, z = (Y) => Y) {
  return B.slice().sort((Y, ie) => {
    let se = z(Y), ne = z(ie);
    if (se === null || ne === null) return 0;
    let ae = se.compareDocumentPosition(ne);
    return ae & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : ae & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function j$3(B, z) {
  return P(b$2(), z, { relativeTo: B });
}
function P(B, z, { sorted: Y = !0, relativeTo: ie = null, skipElements: se = [] } = {}) {
  let ne = Array.isArray(B) ? B.length > 0 ? B[0].ownerDocument : document : B.ownerDocument, ae = Array.isArray(B) ? Y ? _(B) : B : z & 64 ? S$1(B) : b$2(B);
  se.length > 0 && ae.length > 1 && (ae = ae.filter((Ke) => !se.some((ht) => ht != null && "current" in ht ? (ht == null ? void 0 : ht.current) === Ke : ht === Ke))), ie = ie ?? ne.activeElement;
  let le = (() => {
    if (z & 5) return 1;
    if (z & 10) return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), ge = (() => {
    if (z & 1) return 0;
    if (z & 2) return Math.max(0, ae.indexOf(ie)) - 1;
    if (z & 4) return Math.max(0, ae.indexOf(ie)) + 1;
    if (z & 8) return ae.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), Ee = z & 32 ? { preventScroll: !0 } : {}, oe = 0, Pe = ae.length, Ve;
  do {
    if (oe >= Pe || oe + Pe <= 0) return 0;
    let Ke = ge + oe;
    if (z & 16) Ke = (Ke + Pe) % Pe;
    else {
      if (Ke < 0) return 3;
      if (Ke >= Pe) return 1;
    }
    Ve = ae[Ke], Ve == null || Ve.focus(Ee), oe += le;
  } while (Ve !== ne.activeElement);
  return z & 6 && O$2(Ve) && Ve.select(), 2;
}
function t$2() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i$5() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n$2() {
  return t$2() || i$5();
}
function i$4(B, z, Y, ie) {
  let se = s$7(Y);
  useEffect(() => {
    if (!B) return;
    function ne(ae) {
      se.current(ae);
    }
    return document.addEventListener(z, ne, ie), () => document.removeEventListener(z, ne, ie);
  }, [B, z, ie]);
}
function s$5(B, z, Y, ie) {
  let se = s$7(Y);
  useEffect(() => {
    if (!B) return;
    function ne(ae) {
      se.current(ae);
    }
    return window.addEventListener(z, ne, ie), () => window.removeEventListener(z, ne, ie);
  }, [B, z, ie]);
}
const E$1 = 30;
function R$2(B, z, Y) {
  let ie = x$3(B, "outside-click"), se = s$7(Y), ne = useCallback(function(ge, Ee) {
    if (ge.defaultPrevented) return;
    let oe = Ee(ge);
    if (oe === null || !oe.getRootNode().contains(oe) || !oe.isConnected) return;
    let Pe = function Ve(Ke) {
      return typeof Ke == "function" ? Ve(Ke()) : Array.isArray(Ke) || Ke instanceof Set ? Ke : [Ke];
    }(z);
    for (let Ve of Pe) if (Ve !== null && (Ve.contains(oe) || ge.composed && ge.composedPath().includes(Ve))) return;
    return !A(oe, h$2.Loose) && oe.tabIndex !== -1 && ge.preventDefault(), se.current(ge, oe);
  }, [se, z]), ae = useRef(null);
  i$4(ie, "pointerdown", (ge) => {
    var Ee, oe;
    ae.current = ((oe = (Ee = ge.composedPath) == null ? void 0 : Ee.call(ge)) == null ? void 0 : oe[0]) || ge.target;
  }, !0), i$4(ie, "mousedown", (ge) => {
    var Ee, oe;
    ae.current = ((oe = (Ee = ge.composedPath) == null ? void 0 : Ee.call(ge)) == null ? void 0 : oe[0]) || ge.target;
  }, !0), i$4(ie, "click", (ge) => {
    n$2() || ae.current && (ne(ge, () => ae.current), ae.current = null);
  }, !0);
  let le = useRef({ x: 0, y: 0 });
  i$4(ie, "touchstart", (ge) => {
    le.current.x = ge.touches[0].clientX, le.current.y = ge.touches[0].clientY;
  }, !0), i$4(ie, "touchend", (ge) => {
    let Ee = { x: ge.changedTouches[0].clientX, y: ge.changedTouches[0].clientY };
    if (!(Math.abs(Ee.x - le.current.x) >= E$1 || Math.abs(Ee.y - le.current.y) >= E$1)) return ne(ge, () => ge.target instanceof HTMLElement ? ge.target : null);
  }, !0), s$5(ie, "blur", (ge) => ne(ge, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);
}
function n$1(...B) {
  return useMemo(() => u$8(...B), [...B]);
}
function E(B, z, Y, ie) {
  let se = s$7(Y);
  useEffect(() => {
    B = B ?? window;
    function ne(ae) {
      se.current(ae);
    }
    return B.addEventListener(z, ne, ie), () => B.removeEventListener(z, ne, ie);
  }, [B, z, ie]);
}
function e$1(B, z) {
  return useMemo(() => {
    var Y;
    if (B.type) return B.type;
    let ie = (Y = B.as) != null ? Y : "button";
    if (typeof ie == "string" && ie.toLowerCase() === "button" || (z == null ? void 0 : z.tagName) === "BUTTON" && !z.hasAttribute("type")) return "button";
  }, [B.type, B.as, z]);
}
function d$1() {
  let B;
  return { before({ doc: z }) {
    var Y;
    let ie = z.documentElement, se = (Y = z.defaultView) != null ? Y : window;
    B = Math.max(0, se.innerWidth - ie.clientWidth);
  }, after({ doc: z, d: Y }) {
    let ie = z.documentElement, se = Math.max(0, ie.clientWidth - ie.offsetWidth), ne = Math.max(0, B - se);
    Y.style(ie, "paddingRight", `${ne}px`);
  } };
}
function d() {
  return t$2() ? { before({ doc: B, d: z, meta: Y }) {
    function ie(se) {
      return Y.containers.flatMap((ne) => ne()).some((ne) => ne.contains(se));
    }
    z.microTask(() => {
      var se;
      if (window.getComputedStyle(B.documentElement).scrollBehavior !== "auto") {
        let le = o$5();
        le.style(B.documentElement, "scrollBehavior", "auto"), z.add(() => z.microTask(() => le.dispose()));
      }
      let ne = (se = window.scrollY) != null ? se : window.pageYOffset, ae = null;
      z.addEventListener(B, "click", (le) => {
        if (le.target instanceof HTMLElement) try {
          let ge = le.target.closest("a");
          if (!ge) return;
          let { hash: Ee } = new URL(ge.href), oe = B.querySelector(Ee);
          oe && !ie(oe) && (ae = oe);
        } catch {
        }
      }, !0), z.addEventListener(B, "touchstart", (le) => {
        if (le.target instanceof HTMLElement) if (ie(le.target)) {
          let ge = le.target;
          for (; ge.parentElement && ie(ge.parentElement); ) ge = ge.parentElement;
          z.style(ge, "overscrollBehavior", "contain");
        } else z.style(le.target, "touchAction", "none");
      }), z.addEventListener(B, "touchmove", (le) => {
        if (le.target instanceof HTMLElement) {
          if (le.target.tagName === "INPUT") return;
          if (ie(le.target)) {
            let ge = le.target;
            for (; ge.parentElement && ge.dataset.headlessuiPortal !== "" && !(ge.scrollHeight > ge.clientHeight || ge.scrollWidth > ge.clientWidth); ) ge = ge.parentElement;
            ge.dataset.headlessuiPortal === "" && le.preventDefault();
          } else le.preventDefault();
        }
      }, { passive: !1 }), z.add(() => {
        var le;
        let ge = (le = window.scrollY) != null ? le : window.pageYOffset;
        ne !== ge && window.scrollTo(0, ne), ae && ae.isConnected && (ae.scrollIntoView({ block: "nearest" }), ae = null);
      });
    });
  } } : {};
}
function r$2() {
  return { before({ doc: B, d: z }) {
    z.style(B.documentElement, "overflow", "hidden");
  } };
}
function m$1(B) {
  let z = {};
  for (let Y of B) Object.assign(z, Y(z));
  return z;
}
let a$6 = a$7(() => /* @__PURE__ */ new Map(), { PUSH(B, z) {
  var Y;
  let ie = (Y = this.get(B)) != null ? Y : { doc: B, count: 0, d: o$5(), meta: /* @__PURE__ */ new Set() };
  return ie.count++, ie.meta.add(z), this.set(B, ie), this;
}, POP(B, z) {
  let Y = this.get(B);
  return Y && (Y.count--, Y.meta.delete(z)), this;
}, SCROLL_PREVENT({ doc: B, d: z, meta: Y }) {
  let ie = { doc: B, d: z, meta: m$1(Y) }, se = [d(), d$1(), r$2()];
  se.forEach(({ before: ne }) => ne == null ? void 0 : ne(ie)), se.forEach(({ after: ne }) => ne == null ? void 0 : ne(ie));
}, SCROLL_ALLOW({ d: B }) {
  B.dispose();
}, TEARDOWN({ doc: B }) {
  this.delete(B);
} });
a$6.subscribe(() => {
  let B = a$6.getSnapshot(), z = /* @__PURE__ */ new Map();
  for (let [Y] of B) z.set(Y, Y.documentElement.style.overflow);
  for (let Y of B.values()) {
    let ie = z.get(Y.doc) === "hidden", se = Y.count !== 0;
    (se && !ie || !se && ie) && a$6.dispatch(Y.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", Y), Y.count === 0 && a$6.dispatch("TEARDOWN", Y);
  }
});
function a$5(B, z, Y = () => ({ containers: [] })) {
  let ie = o$2(a$6), se = z ? ie.get(z) : void 0, ne = se ? se.count > 0 : !1;
  return n$3(() => {
    if (!(!z || !B)) return a$6.dispatch("PUSH", z, Y), () => a$6.dispatch("POP", z, Y);
  }, [B, z]), ne;
}
function f$4(B, z, Y = () => [document.body]) {
  let ie = x$3(B, "scroll-lock");
  a$5(ie, z, (se) => {
    var ne;
    return { containers: [...(ne = se.containers) != null ? ne : [], Y] };
  });
}
function t$1(B) {
  return [B.screenX, B.screenY];
}
function u$3() {
  let B = useRef([-1, -1]);
  return { wasMoved(z) {
    let Y = t$1(z);
    return B.current[0] === Y[0] && B.current[1] === Y[1] ? !1 : (B.current = Y, !0);
  }, update(z) {
    B.current = t$1(z);
  } };
}
function c$3(B = 0) {
  let [z, Y] = useState(B), ie = useCallback((ge) => Y(ge), [z]), se = useCallback((ge) => Y((Ee) => Ee | ge), [z]), ne = useCallback((ge) => (z & ge) === ge, [z]), ae = useCallback((ge) => Y((Ee) => Ee & ~ge), [Y]), le = useCallback((ge) => Y((Ee) => Ee ^ ge), [Y]);
  return { flags: z, setFlag: ie, addFlag: se, hasFlag: ne, removeFlag: ae, toggleFlag: le };
}
var T, b$1;
typeof process$1 < "u" && typeof globalThis < "u" && typeof Element < "u" && ((T = process$1 == null ? void 0 : process$1.env) == null ? void 0 : T.NODE_ENV) === "test" && typeof ((b$1 = Element == null ? void 0 : Element.prototype) == null ? void 0 : b$1.getAnimations) > "u" && (Element.prototype.getAnimations = function() {
  return console.warn(["Headless UI has polyfilled `Element.prototype.getAnimations` for your tests.", "Please install a proper polyfill e.g. `jsdom-testing-mocks`, to silence these warnings.", "", "Example usage:", "```js", "import { mockAnimationsApi } from 'jsdom-testing-mocks'", "mockAnimationsApi()", "```"].join(`
`)), [];
});
var L = ((B) => (B[B.None = 0] = "None", B[B.Closed = 1] = "Closed", B[B.Enter = 2] = "Enter", B[B.Leave = 4] = "Leave", B))(L || {});
function R$1(B) {
  let z = {};
  for (let Y in B) B[Y] === !0 && (z[`data-${Y}`] = "");
  return z;
}
function x$2(B, z, Y, ie) {
  let [se, ne] = useState(Y), { hasFlag: ae, addFlag: le, removeFlag: ge } = c$3(B && se ? 3 : 0), Ee = useRef(!1), oe = useRef(!1), Pe = p$2();
  return n$3(() => {
    var Ve;
    if (B) {
      if (Y && ne(!0), !z) {
        Y && le(3);
        return;
      }
      return (Ve = ie == null ? void 0 : ie.start) == null || Ve.call(ie, Y), C(z, { inFlight: Ee, prepare() {
        oe.current ? oe.current = !1 : oe.current = Ee.current, Ee.current = !0, !oe.current && (Y ? (le(3), ge(4)) : (le(4), ge(2)));
      }, run() {
        oe.current ? Y ? (ge(3), le(4)) : (ge(4), le(3)) : Y ? ge(1) : le(1);
      }, done() {
        var Ke;
        oe.current && typeof z.getAnimations == "function" && z.getAnimations().length > 0 || (Ee.current = !1, ge(7), Y || ne(!1), (Ke = ie == null ? void 0 : ie.end) == null || Ke.call(ie, Y));
      } });
    }
  }, [B, Y, z, Pe]), B ? [se, { closed: ae(1), enter: ae(2), leave: ae(4), transition: ae(2) || ae(4) }] : [Y, { closed: void 0, enter: void 0, leave: void 0, transition: void 0 }];
}
function C(B, { prepare: z, run: Y, done: ie, inFlight: se }) {
  let ne = o$5();
  return j$2(B, { prepare: z, inFlight: se }), ne.nextFrame(() => {
    Y(), ne.requestAnimationFrame(() => {
      ne.add(M$2(B, ie));
    });
  }), ne.dispose;
}
function M$2(B, z) {
  var Y, ie;
  let se = o$5();
  if (!B) return se.dispose;
  let ne = !1;
  se.add(() => {
    ne = !0;
  });
  let ae = (ie = (Y = B.getAnimations) == null ? void 0 : Y.call(B).filter((le) => le instanceof CSSTransition)) != null ? ie : [];
  return ae.length === 0 ? (z(), se.dispose) : (Promise.allSettled(ae.map((le) => le.finished)).then(() => {
    ne || z();
  }), se.dispose);
}
function j$2(B, { inFlight: z, prepare: Y }) {
  if (z != null && z.current) {
    Y();
    return;
  }
  let ie = B.style.transition;
  B.style.transition = "none", Y(), B.offsetHeight, B.style.transition = ie;
}
function F(B, { container: z, accept: Y, walk: ie }) {
  let se = useRef(Y), ne = useRef(ie);
  useEffect(() => {
    se.current = Y, ne.current = ie;
  }, [Y, ie]), n$3(() => {
    if (!z || !B) return;
    let ae = u$8(z);
    if (!ae) return;
    let le = se.current, ge = ne.current, Ee = Object.assign((Pe) => le(Pe), { acceptNode: le }), oe = ae.createTreeWalker(z, NodeFilter.SHOW_ELEMENT, Ee, !1);
    for (; oe.nextNode(); ) ge(oe.currentNode);
  }, [z, B, se, ne]);
}
function m(B, z) {
  let Y = useRef([]), ie = o$4(B);
  useEffect(() => {
    let se = [...Y.current];
    for (let [ne, ae] of z.entries()) if (Y.current[ne] !== ae) {
      let le = ie(z, se);
      return Y.current = z, le;
    }
  }, [ie, ...z]);
}
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(B) {
  return isNode(B) ? (B.nodeName || "").toLowerCase() : "#document";
}
function getWindow(B) {
  var z;
  return (B == null || (z = B.ownerDocument) == null ? void 0 : z.defaultView) || window;
}
function getDocumentElement(B) {
  var z;
  return (z = (isNode(B) ? B.ownerDocument : B.document) || window.document) == null ? void 0 : z.documentElement;
}
function isNode(B) {
  return hasWindow() ? B instanceof Node || B instanceof getWindow(B).Node : !1;
}
function isElement(B) {
  return hasWindow() ? B instanceof Element || B instanceof getWindow(B).Element : !1;
}
function isHTMLElement(B) {
  return hasWindow() ? B instanceof HTMLElement || B instanceof getWindow(B).HTMLElement : !1;
}
function isShadowRoot(B) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : B instanceof ShadowRoot || B instanceof getWindow(B).ShadowRoot;
}
function isOverflowElement(B) {
  const {
    overflow: z,
    overflowX: Y,
    overflowY: ie,
    display: se
  } = getComputedStyle$1(B);
  return /auto|scroll|overlay|hidden|clip/.test(z + ie + Y) && !["inline", "contents"].includes(se);
}
function isTableElement(B) {
  return ["table", "td", "th"].includes(getNodeName(B));
}
function isTopLayer(B) {
  return [":popover-open", ":modal"].some((z) => {
    try {
      return B.matches(z);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(B) {
  const z = isWebKit(), Y = isElement(B) ? getComputedStyle$1(B) : B;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((ie) => Y[ie] ? Y[ie] !== "none" : !1) || (Y.containerType ? Y.containerType !== "normal" : !1) || !z && (Y.backdropFilter ? Y.backdropFilter !== "none" : !1) || !z && (Y.filter ? Y.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((ie) => (Y.willChange || "").includes(ie)) || ["paint", "layout", "strict", "content"].some((ie) => (Y.contain || "").includes(ie));
}
function getContainingBlock(B) {
  let z = getParentNode(B);
  for (; isHTMLElement(z) && !isLastTraversableNode(z); ) {
    if (isContainingBlock(z))
      return z;
    if (isTopLayer(z))
      return null;
    z = getParentNode(z);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(B) {
  return ["html", "body", "#document"].includes(getNodeName(B));
}
function getComputedStyle$1(B) {
  return getWindow(B).getComputedStyle(B);
}
function getNodeScroll(B) {
  return isElement(B) ? {
    scrollLeft: B.scrollLeft,
    scrollTop: B.scrollTop
  } : {
    scrollLeft: B.scrollX,
    scrollTop: B.scrollY
  };
}
function getParentNode(B) {
  if (getNodeName(B) === "html")
    return B;
  const z = (
    // Step into the shadow DOM of the parent of a slotted node.
    B.assignedSlot || // DOM Element detected.
    B.parentNode || // ShadowRoot detected.
    isShadowRoot(B) && B.host || // Fallback.
    getDocumentElement(B)
  );
  return isShadowRoot(z) ? z.host : z;
}
function getNearestOverflowAncestor(B) {
  const z = getParentNode(B);
  return isLastTraversableNode(z) ? B.ownerDocument ? B.ownerDocument.body : B.body : isHTMLElement(z) && isOverflowElement(z) ? z : getNearestOverflowAncestor(z);
}
function getOverflowAncestors(B, z, Y) {
  var ie;
  z === void 0 && (z = []), Y === void 0 && (Y = !0);
  const se = getNearestOverflowAncestor(B), ne = se === ((ie = B.ownerDocument) == null ? void 0 : ie.body), ae = getWindow(se);
  if (ne) {
    const le = getFrameElement(ae);
    return z.concat(ae, ae.visualViewport || [], isOverflowElement(se) ? se : [], le && Y ? getOverflowAncestors(le) : []);
  }
  return z.concat(se, getOverflowAncestors(se, [], Y));
}
function getFrameElement(B) {
  return B.parent && Object.getPrototypeOf(B.parent) ? B.frameElement : null;
}
function getUserAgent() {
  const B = navigator.userAgentData;
  return B && Array.isArray(B.brands) ? B.brands.map((z) => {
    let {
      brand: Y,
      version: ie
    } = z;
    return Y + "/" + ie;
  }).join(" ") : navigator.userAgent;
}
const min$1 = Math.min, max$1 = Math.max, round$1 = Math.round, floor$1 = Math.floor, createCoords = (B) => ({
  x: B,
  y: B
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(B, z, Y) {
  return max$1(B, min$1(z, Y));
}
function evaluate(B, z) {
  return typeof B == "function" ? B(z) : B;
}
function getSide(B) {
  return B.split("-")[0];
}
function getAlignment(B) {
  return B.split("-")[1];
}
function getOppositeAxis(B) {
  return B === "x" ? "y" : "x";
}
function getAxisLength(B) {
  return B === "y" ? "height" : "width";
}
function getSideAxis(B) {
  return ["top", "bottom"].includes(getSide(B)) ? "y" : "x";
}
function getAlignmentAxis(B) {
  return getOppositeAxis(getSideAxis(B));
}
function getAlignmentSides(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ie = getAlignment(B), se = getAlignmentAxis(B), ne = getAxisLength(se);
  let ae = se === "x" ? ie === (Y ? "end" : "start") ? "right" : "left" : ie === "start" ? "bottom" : "top";
  return z.reference[ne] > z.floating[ne] && (ae = getOppositePlacement(ae)), [ae, getOppositePlacement(ae)];
}
function getExpandedPlacements(B) {
  const z = getOppositePlacement(B);
  return [getOppositeAlignmentPlacement(B), z, getOppositeAlignmentPlacement(z)];
}
function getOppositeAlignmentPlacement(B) {
  return B.replace(/start|end/g, (z) => oppositeAlignmentMap[z]);
}
function getSideList(B, z, Y) {
  const ie = ["left", "right"], se = ["right", "left"], ne = ["top", "bottom"], ae = ["bottom", "top"];
  switch (B) {
    case "top":
    case "bottom":
      return Y ? z ? se : ie : z ? ie : se;
    case "left":
    case "right":
      return z ? ne : ae;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(B, z, Y, ie) {
  const se = getAlignment(B);
  let ne = getSideList(getSide(B), Y === "start", ie);
  return se && (ne = ne.map((ae) => ae + "-" + se), z && (ne = ne.concat(ne.map(getOppositeAlignmentPlacement)))), ne;
}
function getOppositePlacement(B) {
  return B.replace(/left|right|bottom|top/g, (z) => oppositeSideMap[z]);
}
function expandPaddingObject(B) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...B
  };
}
function getPaddingObject(B) {
  return typeof B != "number" ? expandPaddingObject(B) : {
    top: B,
    right: B,
    bottom: B,
    left: B
  };
}
function rectToClientRect(B) {
  const {
    x: z,
    y: Y,
    width: ie,
    height: se
  } = B;
  return {
    width: ie,
    height: se,
    top: Y,
    left: z,
    right: z + ie,
    bottom: Y + se,
    x: z,
    y: Y
  };
}
function computeCoordsFromPlacement(B, z, Y) {
  let {
    reference: ie,
    floating: se
  } = B;
  const ne = getSideAxis(z), ae = getAlignmentAxis(z), le = getAxisLength(ae), ge = getSide(z), Ee = ne === "y", oe = ie.x + ie.width / 2 - se.width / 2, Pe = ie.y + ie.height / 2 - se.height / 2, Ve = ie[le] / 2 - se[le] / 2;
  let Ke;
  switch (ge) {
    case "top":
      Ke = {
        x: oe,
        y: ie.y - se.height
      };
      break;
    case "bottom":
      Ke = {
        x: oe,
        y: ie.y + ie.height
      };
      break;
    case "right":
      Ke = {
        x: ie.x + ie.width,
        y: Pe
      };
      break;
    case "left":
      Ke = {
        x: ie.x - se.width,
        y: Pe
      };
      break;
    default:
      Ke = {
        x: ie.x,
        y: ie.y
      };
  }
  switch (getAlignment(z)) {
    case "start":
      Ke[ae] -= Ve * (Y && Ee ? -1 : 1);
      break;
    case "end":
      Ke[ae] += Ve * (Y && Ee ? -1 : 1);
      break;
  }
  return Ke;
}
const computePosition$1 = async (B, z, Y) => {
  const {
    placement: ie = "bottom",
    strategy: se = "absolute",
    middleware: ne = [],
    platform: ae
  } = Y, le = ne.filter(Boolean), ge = await (ae.isRTL == null ? void 0 : ae.isRTL(z));
  let Ee = await ae.getElementRects({
    reference: B,
    floating: z,
    strategy: se
  }), {
    x: oe,
    y: Pe
  } = computeCoordsFromPlacement(Ee, ie, ge), Ve = ie, Ke = {}, ht = 0;
  for (let _t = 0; _t < le.length; _t++) {
    const {
      name: Rt,
      fn: kt
    } = le[_t], {
      x: Bt,
      y: Ct,
      data: qt,
      reset: jt
    } = await kt({
      x: oe,
      y: Pe,
      initialPlacement: ie,
      placement: Ve,
      strategy: se,
      middlewareData: Ke,
      rects: Ee,
      platform: ae,
      elements: {
        reference: B,
        floating: z
      }
    });
    oe = Bt ?? oe, Pe = Ct ?? Pe, Ke = {
      ...Ke,
      [Rt]: {
        ...Ke[Rt],
        ...qt
      }
    }, jt && ht <= 50 && (ht++, typeof jt == "object" && (jt.placement && (Ve = jt.placement), jt.rects && (Ee = jt.rects === !0 ? await ae.getElementRects({
      reference: B,
      floating: z,
      strategy: se
    }) : jt.rects), {
      x: oe,
      y: Pe
    } = computeCoordsFromPlacement(Ee, Ve, ge)), _t = -1);
  }
  return {
    x: oe,
    y: Pe,
    placement: Ve,
    strategy: se,
    middlewareData: Ke
  };
};
async function detectOverflow$1(B, z) {
  var Y;
  z === void 0 && (z = {});
  const {
    x: ie,
    y: se,
    platform: ne,
    rects: ae,
    elements: le,
    strategy: ge
  } = B, {
    boundary: Ee = "clippingAncestors",
    rootBoundary: oe = "viewport",
    elementContext: Pe = "floating",
    altBoundary: Ve = !1,
    padding: Ke = 0
  } = evaluate(z, B), ht = getPaddingObject(Ke), Rt = le[Ve ? Pe === "floating" ? "reference" : "floating" : Pe], kt = rectToClientRect(await ne.getClippingRect({
    element: (Y = await (ne.isElement == null ? void 0 : ne.isElement(Rt))) == null || Y ? Rt : Rt.contextElement || await (ne.getDocumentElement == null ? void 0 : ne.getDocumentElement(le.floating)),
    boundary: Ee,
    rootBoundary: oe,
    strategy: ge
  })), Bt = Pe === "floating" ? {
    x: ie,
    y: se,
    width: ae.floating.width,
    height: ae.floating.height
  } : ae.reference, Ct = await (ne.getOffsetParent == null ? void 0 : ne.getOffsetParent(le.floating)), qt = await (ne.isElement == null ? void 0 : ne.isElement(Ct)) ? await (ne.getScale == null ? void 0 : ne.getScale(Ct)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, jt = rectToClientRect(ne.convertOffsetParentRelativeRectToViewportRelativeRect ? await ne.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: le,
    rect: Bt,
    offsetParent: Ct,
    strategy: ge
  }) : Bt);
  return {
    top: (kt.top - jt.top + ht.top) / qt.y,
    bottom: (jt.bottom - kt.bottom + ht.bottom) / qt.y,
    left: (kt.left - jt.left + ht.left) / qt.x,
    right: (jt.right - kt.right + ht.right) / qt.x
  };
}
const flip$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "flip",
    options: B,
    async fn(z) {
      var Y, ie;
      const {
        placement: se,
        middlewareData: ne,
        rects: ae,
        initialPlacement: le,
        platform: ge,
        elements: Ee
      } = z, {
        mainAxis: oe = !0,
        crossAxis: Pe = !0,
        fallbackPlacements: Ve,
        fallbackStrategy: Ke = "bestFit",
        fallbackAxisSideDirection: ht = "none",
        flipAlignment: _t = !0,
        ...Rt
      } = evaluate(B, z);
      if ((Y = ne.arrow) != null && Y.alignmentOffset)
        return {};
      const kt = getSide(se), Bt = getSideAxis(le), Ct = getSide(le) === le, qt = await (ge.isRTL == null ? void 0 : ge.isRTL(Ee.floating)), jt = Ve || (Ct || !_t ? [getOppositePlacement(le)] : getExpandedPlacements(le)), Ht = ht !== "none";
      !Ve && Ht && jt.push(...getOppositeAxisPlacements(le, _t, ht, qt));
      const Yt = [le, ...jt], Ut = await detectOverflow$1(z, Rt), Nt = [];
      let Kt = ((ie = ne.flip) == null ? void 0 : ie.overflows) || [];
      if (oe && Nt.push(Ut[kt]), Pe) {
        const ve = getAlignmentSides(se, ae, qt);
        Nt.push(Ut[ve[0]], Ut[ve[1]]);
      }
      if (Kt = [...Kt, {
        placement: se,
        overflows: Nt
      }], !Nt.every((ve) => ve <= 0)) {
        var Ft, bt;
        const ve = (((Ft = ne.flip) == null ? void 0 : Ft.index) || 0) + 1, Ce = Yt[ve];
        if (Ce)
          return {
            data: {
              index: ve,
              overflows: Kt
            },
            reset: {
              placement: Ce
            }
          };
        let Qe = (bt = Kt.filter((vt) => vt.overflows[0] <= 0).sort((vt, wt) => vt.overflows[1] - wt.overflows[1])[0]) == null ? void 0 : bt.placement;
        if (!Qe)
          switch (Ke) {
            case "bestFit": {
              var Xe;
              const vt = (Xe = Kt.filter((wt) => {
                if (Ht) {
                  const $t = getSideAxis(wt.placement);
                  return $t === Bt || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  $t === "y";
                }
                return !0;
              }).map((wt) => [wt.placement, wt.overflows.filter(($t) => $t > 0).reduce(($t, xt) => $t + xt, 0)]).sort((wt, $t) => wt[1] - $t[1])[0]) == null ? void 0 : Xe[0];
              vt && (Qe = vt);
              break;
            }
            case "initialPlacement":
              Qe = le;
              break;
          }
        if (se !== Qe)
          return {
            reset: {
              placement: Qe
            }
          };
      }
      return {};
    }
  };
};
async function convertValueToCoords(B, z) {
  const {
    placement: Y,
    platform: ie,
    elements: se
  } = B, ne = await (ie.isRTL == null ? void 0 : ie.isRTL(se.floating)), ae = getSide(Y), le = getAlignment(Y), ge = getSideAxis(Y) === "y", Ee = ["left", "top"].includes(ae) ? -1 : 1, oe = ne && ge ? -1 : 1, Pe = evaluate(z, B);
  let {
    mainAxis: Ve,
    crossAxis: Ke,
    alignmentAxis: ht
  } = typeof Pe == "number" ? {
    mainAxis: Pe,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: Pe.mainAxis || 0,
    crossAxis: Pe.crossAxis || 0,
    alignmentAxis: Pe.alignmentAxis
  };
  return le && typeof ht == "number" && (Ke = le === "end" ? ht * -1 : ht), ge ? {
    x: Ke * oe,
    y: Ve * Ee
  } : {
    x: Ve * Ee,
    y: Ke * oe
  };
}
const offset$2 = function(B) {
  return B === void 0 && (B = 0), {
    name: "offset",
    options: B,
    async fn(z) {
      var Y, ie;
      const {
        x: se,
        y: ne,
        placement: ae,
        middlewareData: le
      } = z, ge = await convertValueToCoords(z, B);
      return ae === ((Y = le.offset) == null ? void 0 : Y.placement) && (ie = le.arrow) != null && ie.alignmentOffset ? {} : {
        x: se + ge.x,
        y: ne + ge.y,
        data: {
          ...ge,
          placement: ae
        }
      };
    }
  };
}, shift$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "shift",
    options: B,
    async fn(z) {
      const {
        x: Y,
        y: ie,
        placement: se
      } = z, {
        mainAxis: ne = !0,
        crossAxis: ae = !1,
        limiter: le = {
          fn: (Rt) => {
            let {
              x: kt,
              y: Bt
            } = Rt;
            return {
              x: kt,
              y: Bt
            };
          }
        },
        ...ge
      } = evaluate(B, z), Ee = {
        x: Y,
        y: ie
      }, oe = await detectOverflow$1(z, ge), Pe = getSideAxis(getSide(se)), Ve = getOppositeAxis(Pe);
      let Ke = Ee[Ve], ht = Ee[Pe];
      if (ne) {
        const Rt = Ve === "y" ? "top" : "left", kt = Ve === "y" ? "bottom" : "right", Bt = Ke + oe[Rt], Ct = Ke - oe[kt];
        Ke = clamp(Bt, Ke, Ct);
      }
      if (ae) {
        const Rt = Pe === "y" ? "top" : "left", kt = Pe === "y" ? "bottom" : "right", Bt = ht + oe[Rt], Ct = ht - oe[kt];
        ht = clamp(Bt, ht, Ct);
      }
      const _t = le.fn({
        ...z,
        [Ve]: Ke,
        [Pe]: ht
      });
      return {
        ..._t,
        data: {
          x: _t.x - Y,
          y: _t.y - ie,
          enabled: {
            [Ve]: ne,
            [Pe]: ae
          }
        }
      };
    }
  };
}, size$2 = function(B) {
  return B === void 0 && (B = {}), {
    name: "size",
    options: B,
    async fn(z) {
      var Y, ie;
      const {
        placement: se,
        rects: ne,
        platform: ae,
        elements: le
      } = z, {
        apply: ge = () => {
        },
        ...Ee
      } = evaluate(B, z), oe = await detectOverflow$1(z, Ee), Pe = getSide(se), Ve = getAlignment(se), Ke = getSideAxis(se) === "y", {
        width: ht,
        height: _t
      } = ne.floating;
      let Rt, kt;
      Pe === "top" || Pe === "bottom" ? (Rt = Pe, kt = Ve === (await (ae.isRTL == null ? void 0 : ae.isRTL(le.floating)) ? "start" : "end") ? "left" : "right") : (kt = Pe, Rt = Ve === "end" ? "top" : "bottom");
      const Bt = _t - oe.top - oe.bottom, Ct = ht - oe.left - oe.right, qt = min$1(_t - oe[Rt], Bt), jt = min$1(ht - oe[kt], Ct), Ht = !z.middlewareData.shift;
      let Yt = qt, Ut = jt;
      if ((Y = z.middlewareData.shift) != null && Y.enabled.x && (Ut = Ct), (ie = z.middlewareData.shift) != null && ie.enabled.y && (Yt = Bt), Ht && !Ve) {
        const Kt = max$1(oe.left, 0), Ft = max$1(oe.right, 0), bt = max$1(oe.top, 0), Xe = max$1(oe.bottom, 0);
        Ke ? Ut = ht - 2 * (Kt !== 0 || Ft !== 0 ? Kt + Ft : max$1(oe.left, oe.right)) : Yt = _t - 2 * (bt !== 0 || Xe !== 0 ? bt + Xe : max$1(oe.top, oe.bottom));
      }
      await ge({
        ...z,
        availableWidth: Ut,
        availableHeight: Yt
      });
      const Nt = await ae.getDimensions(le.floating);
      return ht !== Nt.width || _t !== Nt.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function getCssDimensions(B) {
  const z = getComputedStyle$1(B);
  let Y = parseFloat(z.width) || 0, ie = parseFloat(z.height) || 0;
  const se = isHTMLElement(B), ne = se ? B.offsetWidth : Y, ae = se ? B.offsetHeight : ie, le = round$1(Y) !== ne || round$1(ie) !== ae;
  return le && (Y = ne, ie = ae), {
    width: Y,
    height: ie,
    $: le
  };
}
function unwrapElement(B) {
  return isElement(B) ? B : B.contextElement;
}
function getScale(B) {
  const z = unwrapElement(B);
  if (!isHTMLElement(z))
    return createCoords(1);
  const Y = z.getBoundingClientRect(), {
    width: ie,
    height: se,
    $: ne
  } = getCssDimensions(z);
  let ae = (ne ? round$1(Y.width) : Y.width) / ie, le = (ne ? round$1(Y.height) : Y.height) / se;
  return (!ae || !Number.isFinite(ae)) && (ae = 1), (!le || !Number.isFinite(le)) && (le = 1), {
    x: ae,
    y: le
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(B) {
  const z = getWindow(B);
  return !isWebKit() || !z.visualViewport ? noOffsets : {
    x: z.visualViewport.offsetLeft,
    y: z.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(B, z, Y) {
  return z === void 0 && (z = !1), !Y || z && Y !== getWindow(B) ? !1 : z;
}
function getBoundingClientRect(B, z, Y, ie) {
  z === void 0 && (z = !1), Y === void 0 && (Y = !1);
  const se = B.getBoundingClientRect(), ne = unwrapElement(B);
  let ae = createCoords(1);
  z && (ie ? isElement(ie) && (ae = getScale(ie)) : ae = getScale(B));
  const le = shouldAddVisualOffsets(ne, Y, ie) ? getVisualOffsets(ne) : createCoords(0);
  let ge = (se.left + le.x) / ae.x, Ee = (se.top + le.y) / ae.y, oe = se.width / ae.x, Pe = se.height / ae.y;
  if (ne) {
    const Ve = getWindow(ne), Ke = ie && isElement(ie) ? getWindow(ie) : ie;
    let ht = Ve, _t = getFrameElement(ht);
    for (; _t && ie && Ke !== ht; ) {
      const Rt = getScale(_t), kt = _t.getBoundingClientRect(), Bt = getComputedStyle$1(_t), Ct = kt.left + (_t.clientLeft + parseFloat(Bt.paddingLeft)) * Rt.x, qt = kt.top + (_t.clientTop + parseFloat(Bt.paddingTop)) * Rt.y;
      ge *= Rt.x, Ee *= Rt.y, oe *= Rt.x, Pe *= Rt.y, ge += Ct, Ee += qt, ht = getWindow(_t), _t = getFrameElement(ht);
    }
  }
  return rectToClientRect({
    width: oe,
    height: Pe,
    x: ge,
    y: Ee
  });
}
function getWindowScrollBarX(B, z) {
  const Y = getNodeScroll(B).scrollLeft;
  return z ? z.left + Y : getBoundingClientRect(getDocumentElement(B)).left + Y;
}
function getHTMLOffset(B, z, Y) {
  Y === void 0 && (Y = !1);
  const ie = B.getBoundingClientRect(), se = ie.left + z.scrollLeft - (Y ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(B, ie)
  )), ne = ie.top + z.scrollTop;
  return {
    x: se,
    y: ne
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(B) {
  let {
    elements: z,
    rect: Y,
    offsetParent: ie,
    strategy: se
  } = B;
  const ne = se === "fixed", ae = getDocumentElement(ie), le = z ? isTopLayer(z.floating) : !1;
  if (ie === ae || le && ne)
    return Y;
  let ge = {
    scrollLeft: 0,
    scrollTop: 0
  }, Ee = createCoords(1);
  const oe = createCoords(0), Pe = isHTMLElement(ie);
  if ((Pe || !Pe && !ne) && ((getNodeName(ie) !== "body" || isOverflowElement(ae)) && (ge = getNodeScroll(ie)), isHTMLElement(ie))) {
    const Ke = getBoundingClientRect(ie);
    Ee = getScale(ie), oe.x = Ke.x + ie.clientLeft, oe.y = Ke.y + ie.clientTop;
  }
  const Ve = ae && !Pe && !ne ? getHTMLOffset(ae, ge, !0) : createCoords(0);
  return {
    width: Y.width * Ee.x,
    height: Y.height * Ee.y,
    x: Y.x * Ee.x - ge.scrollLeft * Ee.x + oe.x + Ve.x,
    y: Y.y * Ee.y - ge.scrollTop * Ee.y + oe.y + Ve.y
  };
}
function getClientRects(B) {
  return Array.from(B.getClientRects());
}
function getDocumentRect(B) {
  const z = getDocumentElement(B), Y = getNodeScroll(B), ie = B.ownerDocument.body, se = max$1(z.scrollWidth, z.clientWidth, ie.scrollWidth, ie.clientWidth), ne = max$1(z.scrollHeight, z.clientHeight, ie.scrollHeight, ie.clientHeight);
  let ae = -Y.scrollLeft + getWindowScrollBarX(B);
  const le = -Y.scrollTop;
  return getComputedStyle$1(ie).direction === "rtl" && (ae += max$1(z.clientWidth, ie.clientWidth) - se), {
    width: se,
    height: ne,
    x: ae,
    y: le
  };
}
function getViewportRect(B, z) {
  const Y = getWindow(B), ie = getDocumentElement(B), se = Y.visualViewport;
  let ne = ie.clientWidth, ae = ie.clientHeight, le = 0, ge = 0;
  if (se) {
    ne = se.width, ae = se.height;
    const Ee = isWebKit();
    (!Ee || Ee && z === "fixed") && (le = se.offsetLeft, ge = se.offsetTop);
  }
  return {
    width: ne,
    height: ae,
    x: le,
    y: ge
  };
}
function getInnerBoundingClientRect(B, z) {
  const Y = getBoundingClientRect(B, !0, z === "fixed"), ie = Y.top + B.clientTop, se = Y.left + B.clientLeft, ne = isHTMLElement(B) ? getScale(B) : createCoords(1), ae = B.clientWidth * ne.x, le = B.clientHeight * ne.y, ge = se * ne.x, Ee = ie * ne.y;
  return {
    width: ae,
    height: le,
    x: ge,
    y: Ee
  };
}
function getClientRectFromClippingAncestor(B, z, Y) {
  let ie;
  if (z === "viewport")
    ie = getViewportRect(B, Y);
  else if (z === "document")
    ie = getDocumentRect(getDocumentElement(B));
  else if (isElement(z))
    ie = getInnerBoundingClientRect(z, Y);
  else {
    const se = getVisualOffsets(B);
    ie = {
      x: z.x - se.x,
      y: z.y - se.y,
      width: z.width,
      height: z.height
    };
  }
  return rectToClientRect(ie);
}
function hasFixedPositionAncestor(B, z) {
  const Y = getParentNode(B);
  return Y === z || !isElement(Y) || isLastTraversableNode(Y) ? !1 : getComputedStyle$1(Y).position === "fixed" || hasFixedPositionAncestor(Y, z);
}
function getClippingElementAncestors(B, z) {
  const Y = z.get(B);
  if (Y)
    return Y;
  let ie = getOverflowAncestors(B, [], !1).filter((le) => isElement(le) && getNodeName(le) !== "body"), se = null;
  const ne = getComputedStyle$1(B).position === "fixed";
  let ae = ne ? getParentNode(B) : B;
  for (; isElement(ae) && !isLastTraversableNode(ae); ) {
    const le = getComputedStyle$1(ae), ge = isContainingBlock(ae);
    !ge && le.position === "fixed" && (se = null), (ne ? !ge && !se : !ge && le.position === "static" && !!se && ["absolute", "fixed"].includes(se.position) || isOverflowElement(ae) && !ge && hasFixedPositionAncestor(B, ae)) ? ie = ie.filter((oe) => oe !== ae) : se = le, ae = getParentNode(ae);
  }
  return z.set(B, ie), ie;
}
function getClippingRect(B) {
  let {
    element: z,
    boundary: Y,
    rootBoundary: ie,
    strategy: se
  } = B;
  const ae = [...Y === "clippingAncestors" ? isTopLayer(z) ? [] : getClippingElementAncestors(z, this._c) : [].concat(Y), ie], le = ae[0], ge = ae.reduce((Ee, oe) => {
    const Pe = getClientRectFromClippingAncestor(z, oe, se);
    return Ee.top = max$1(Pe.top, Ee.top), Ee.right = min$1(Pe.right, Ee.right), Ee.bottom = min$1(Pe.bottom, Ee.bottom), Ee.left = max$1(Pe.left, Ee.left), Ee;
  }, getClientRectFromClippingAncestor(z, le, se));
  return {
    width: ge.right - ge.left,
    height: ge.bottom - ge.top,
    x: ge.left,
    y: ge.top
  };
}
function getDimensions(B) {
  const {
    width: z,
    height: Y
  } = getCssDimensions(B);
  return {
    width: z,
    height: Y
  };
}
function getRectRelativeToOffsetParent(B, z, Y) {
  const ie = isHTMLElement(z), se = getDocumentElement(z), ne = Y === "fixed", ae = getBoundingClientRect(B, !0, ne, z);
  let le = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const ge = createCoords(0);
  if (ie || !ie && !ne)
    if ((getNodeName(z) !== "body" || isOverflowElement(se)) && (le = getNodeScroll(z)), ie) {
      const Ve = getBoundingClientRect(z, !0, ne, z);
      ge.x = Ve.x + z.clientLeft, ge.y = Ve.y + z.clientTop;
    } else se && (ge.x = getWindowScrollBarX(se));
  const Ee = se && !ie && !ne ? getHTMLOffset(se, le) : createCoords(0), oe = ae.left + le.scrollLeft - ge.x - Ee.x, Pe = ae.top + le.scrollTop - ge.y - Ee.y;
  return {
    x: oe,
    y: Pe,
    width: ae.width,
    height: ae.height
  };
}
function isStaticPositioned(B) {
  return getComputedStyle$1(B).position === "static";
}
function getTrueOffsetParent(B, z) {
  if (!isHTMLElement(B) || getComputedStyle$1(B).position === "fixed")
    return null;
  if (z)
    return z(B);
  let Y = B.offsetParent;
  return getDocumentElement(B) === Y && (Y = Y.ownerDocument.body), Y;
}
function getOffsetParent(B, z) {
  const Y = getWindow(B);
  if (isTopLayer(B))
    return Y;
  if (!isHTMLElement(B)) {
    let se = getParentNode(B);
    for (; se && !isLastTraversableNode(se); ) {
      if (isElement(se) && !isStaticPositioned(se))
        return se;
      se = getParentNode(se);
    }
    return Y;
  }
  let ie = getTrueOffsetParent(B, z);
  for (; ie && isTableElement(ie) && isStaticPositioned(ie); )
    ie = getTrueOffsetParent(ie, z);
  return ie && isLastTraversableNode(ie) && isStaticPositioned(ie) && !isContainingBlock(ie) ? Y : ie || getContainingBlock(B) || Y;
}
const getElementRects = async function(B) {
  const z = this.getOffsetParent || getOffsetParent, Y = this.getDimensions, ie = await Y(B.floating);
  return {
    reference: getRectRelativeToOffsetParent(B.reference, await z(B.floating), B.strategy),
    floating: {
      x: 0,
      y: 0,
      width: ie.width,
      height: ie.height
    }
  };
};
function isRTL(B) {
  return getComputedStyle$1(B).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(B, z) {
  return B.x === z.x && B.y === z.y && B.width === z.width && B.height === z.height;
}
function observeMove(B, z) {
  let Y = null, ie;
  const se = getDocumentElement(B);
  function ne() {
    var le;
    clearTimeout(ie), (le = Y) == null || le.disconnect(), Y = null;
  }
  function ae(le, ge) {
    le === void 0 && (le = !1), ge === void 0 && (ge = 1), ne();
    const Ee = B.getBoundingClientRect(), {
      left: oe,
      top: Pe,
      width: Ve,
      height: Ke
    } = Ee;
    if (le || z(), !Ve || !Ke)
      return;
    const ht = floor$1(Pe), _t = floor$1(se.clientWidth - (oe + Ve)), Rt = floor$1(se.clientHeight - (Pe + Ke)), kt = floor$1(oe), Ct = {
      rootMargin: -ht + "px " + -_t + "px " + -Rt + "px " + -kt + "px",
      threshold: max$1(0, min$1(1, ge)) || 1
    };
    let qt = !0;
    function jt(Ht) {
      const Yt = Ht[0].intersectionRatio;
      if (Yt !== ge) {
        if (!qt)
          return ae();
        Yt ? ae(!1, Yt) : ie = setTimeout(() => {
          ae(!1, 1e-7);
        }, 1e3);
      }
      Yt === 1 && !rectsAreEqual(Ee, B.getBoundingClientRect()) && ae(), qt = !1;
    }
    try {
      Y = new IntersectionObserver(jt, {
        ...Ct,
        // Handle <iframe>s
        root: se.ownerDocument
      });
    } catch {
      Y = new IntersectionObserver(jt, Ct);
    }
    Y.observe(B);
  }
  return ae(!0), ne;
}
function autoUpdate(B, z, Y, ie) {
  ie === void 0 && (ie = {});
  const {
    ancestorScroll: se = !0,
    ancestorResize: ne = !0,
    elementResize: ae = typeof ResizeObserver == "function",
    layoutShift: le = typeof IntersectionObserver == "function",
    animationFrame: ge = !1
  } = ie, Ee = unwrapElement(B), oe = se || ne ? [...Ee ? getOverflowAncestors(Ee) : [], ...getOverflowAncestors(z)] : [];
  oe.forEach((kt) => {
    se && kt.addEventListener("scroll", Y, {
      passive: !0
    }), ne && kt.addEventListener("resize", Y);
  });
  const Pe = Ee && le ? observeMove(Ee, Y) : null;
  let Ve = -1, Ke = null;
  ae && (Ke = new ResizeObserver((kt) => {
    let [Bt] = kt;
    Bt && Bt.target === Ee && Ke && (Ke.unobserve(z), cancelAnimationFrame(Ve), Ve = requestAnimationFrame(() => {
      var Ct;
      (Ct = Ke) == null || Ct.observe(z);
    })), Y();
  }), Ee && !ge && Ke.observe(Ee), Ke.observe(z));
  let ht, _t = ge ? getBoundingClientRect(B) : null;
  ge && Rt();
  function Rt() {
    const kt = getBoundingClientRect(B);
    _t && !rectsAreEqual(_t, kt) && Y(), _t = kt, ht = requestAnimationFrame(Rt);
  }
  return Y(), () => {
    var kt;
    oe.forEach((Bt) => {
      se && Bt.removeEventListener("scroll", Y), ne && Bt.removeEventListener("resize", Y);
    }), Pe == null || Pe(), (kt = Ke) == null || kt.disconnect(), Ke = null, ge && cancelAnimationFrame(ht);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, computePosition = (B, z, Y) => {
  const ie = /* @__PURE__ */ new Map(), se = {
    platform,
    ...Y
  }, ne = {
    ...se.platform,
    _c: ie
  };
  return computePosition$1(B, z, {
    ...se,
    platform: ne
  });
};
var index$1 = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(B, z) {
  if (B === z)
    return !0;
  if (typeof B != typeof z)
    return !1;
  if (typeof B == "function" && B.toString() === z.toString())
    return !0;
  let Y, ie, se;
  if (B && z && typeof B == "object") {
    if (Array.isArray(B)) {
      if (Y = B.length, Y !== z.length) return !1;
      for (ie = Y; ie-- !== 0; )
        if (!deepEqual(B[ie], z[ie]))
          return !1;
      return !0;
    }
    if (se = Object.keys(B), Y = se.length, Y !== Object.keys(z).length)
      return !1;
    for (ie = Y; ie-- !== 0; )
      if (!{}.hasOwnProperty.call(z, se[ie]))
        return !1;
    for (ie = Y; ie-- !== 0; ) {
      const ne = se[ie];
      if (!(ne === "_owner" && B.$$typeof) && !deepEqual(B[ne], z[ne]))
        return !1;
    }
    return !0;
  }
  return B !== B && z !== z;
}
function getDPR(B) {
  return typeof window > "u" ? 1 : (B.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(B, z) {
  const Y = getDPR(B);
  return Math.round(z * Y) / Y;
}
function useLatestRef(B) {
  const z = React.useRef(B);
  return index$1(() => {
    z.current = B;
  }), z;
}
function useFloating$1(B) {
  B === void 0 && (B = {});
  const {
    placement: z = "bottom",
    strategy: Y = "absolute",
    middleware: ie = [],
    platform: se,
    elements: {
      reference: ne,
      floating: ae
    } = {},
    transform: le = !0,
    whileElementsMounted: ge,
    open: Ee
  } = B, [oe, Pe] = React.useState({
    x: 0,
    y: 0,
    strategy: Y,
    placement: z,
    middlewareData: {},
    isPositioned: !1
  }), [Ve, Ke] = React.useState(ie);
  deepEqual(Ve, ie) || Ke(ie);
  const [ht, _t] = React.useState(null), [Rt, kt] = React.useState(null), Bt = React.useCallback((wt) => {
    wt !== Ht.current && (Ht.current = wt, _t(wt));
  }, []), Ct = React.useCallback((wt) => {
    wt !== Yt.current && (Yt.current = wt, kt(wt));
  }, []), qt = ne || ht, jt = ae || Rt, Ht = React.useRef(null), Yt = React.useRef(null), Ut = React.useRef(oe), Nt = ge != null, Kt = useLatestRef(ge), Ft = useLatestRef(se), bt = useLatestRef(Ee), Xe = React.useCallback(() => {
    if (!Ht.current || !Yt.current)
      return;
    const wt = {
      placement: z,
      strategy: Y,
      middleware: Ve
    };
    Ft.current && (wt.platform = Ft.current), computePosition(Ht.current, Yt.current, wt).then(($t) => {
      const xt = {
        ...$t,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: bt.current !== !1
      };
      ve.current && !deepEqual(Ut.current, xt) && (Ut.current = xt, ReactDOM.flushSync(() => {
        Pe(xt);
      }));
    });
  }, [Ve, z, Y, Ft, bt]);
  index$1(() => {
    Ee === !1 && Ut.current.isPositioned && (Ut.current.isPositioned = !1, Pe((wt) => ({
      ...wt,
      isPositioned: !1
    })));
  }, [Ee]);
  const ve = React.useRef(!1);
  index$1(() => (ve.current = !0, () => {
    ve.current = !1;
  }), []), index$1(() => {
    if (qt && (Ht.current = qt), jt && (Yt.current = jt), qt && jt) {
      if (Kt.current)
        return Kt.current(qt, jt, Xe);
      Xe();
    }
  }, [qt, jt, Xe, Kt, Nt]);
  const Ce = React.useMemo(() => ({
    reference: Ht,
    floating: Yt,
    setReference: Bt,
    setFloating: Ct
  }), [Bt, Ct]), Qe = React.useMemo(() => ({
    reference: qt,
    floating: jt
  }), [qt, jt]), vt = React.useMemo(() => {
    const wt = {
      position: Y,
      left: 0,
      top: 0
    };
    if (!Qe.floating)
      return wt;
    const $t = roundByDPR(Qe.floating, oe.x), xt = roundByDPR(Qe.floating, oe.y);
    return le ? {
      ...wt,
      transform: "translate(" + $t + "px, " + xt + "px)",
      ...getDPR(Qe.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: Y,
      left: $t,
      top: xt
    };
  }, [Y, le, Qe.floating, oe.x, oe.y]);
  return React.useMemo(() => ({
    ...oe,
    update: Xe,
    refs: Ce,
    elements: Qe,
    floatingStyles: vt
  }), [oe, Xe, Ce, Qe, vt]);
}
const offset = (B, z) => ({
  ...offset$1(B),
  options: [B, z]
}), shift = (B, z) => ({
  ...shift$1(B),
  options: [B, z]
}), flip = (B, z) => ({
  ...flip$1(B),
  options: [B, z]
}), size = (B, z) => ({
  ...size$1(B),
  options: [B, z]
}), SafeReact = {
  ...React
}, useInsertionEffect = SafeReact.useInsertionEffect, useSafeInsertionEffect = useInsertionEffect || ((B) => B());
function useEffectEvent(B) {
  const z = React.useRef(() => {
    if (process$1.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return useSafeInsertionEffect(() => {
    z.current = B;
  }), React.useCallback(function() {
    for (var Y = arguments.length, ie = new Array(Y), se = 0; se < Y; se++)
      ie[se] = arguments[se];
    return z.current == null ? void 0 : z.current(...ie);
  }, []);
}
var index = typeof document < "u" ? useLayoutEffect : useEffect;
let serverHandoffComplete = !1, count = 0;
const genId = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + count++
);
function useFloatingId() {
  const [B, z] = React.useState(() => serverHandoffComplete ? genId() : void 0);
  return index(() => {
    B == null && z(genId());
  }, []), React.useEffect(() => {
    serverHandoffComplete = !0;
  }, []), B;
}
const useReactId = SafeReact.useId, useId = useReactId || useFloatingId;
let devMessageSet;
process$1.env.NODE_ENV !== "production" && (devMessageSet = /* @__PURE__ */ new Set());
function warn() {
  for (var B, z = arguments.length, Y = new Array(z), ie = 0; ie < z; ie++)
    Y[ie] = arguments[ie];
  const se = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(se))) {
    var ne;
    (ne = devMessageSet) == null || ne.add(se), console.warn(se);
  }
}
function error() {
  for (var B, z = arguments.length, Y = new Array(z), ie = 0; ie < z; ie++)
    Y[ie] = arguments[ie];
  const se = "Floating UI: " + Y.join(" ");
  if (!((B = devMessageSet) != null && B.has(se))) {
    var ne;
    (ne = devMessageSet) == null || ne.add(se), console.error(se);
  }
}
function createPubSub() {
  const B = /* @__PURE__ */ new Map();
  return {
    emit(z, Y) {
      var ie;
      (ie = B.get(z)) == null || ie.forEach((se) => se(Y));
    },
    on(z, Y) {
      B.set(z, [...B.get(z) || [], Y]);
    },
    off(z, Y) {
      var ie;
      B.set(z, ((ie = B.get(z)) == null ? void 0 : ie.filter((se) => se !== Y)) || []);
    }
  };
}
const FloatingNodeContext = /* @__PURE__ */ React.createContext(null), FloatingTreeContext = /* @__PURE__ */ React.createContext(null), useFloatingParentNodeId = () => {
  var B;
  return ((B = React.useContext(FloatingNodeContext)) == null ? void 0 : B.id) || null;
}, useFloatingTree = () => React.useContext(FloatingTreeContext), FOCUSABLE_ATTRIBUTE = "data-floating-ui-focusable";
function useFloatingRootContext(B) {
  const {
    open: z = !1,
    onOpenChange: Y,
    elements: ie
  } = B, se = useId(), ne = React.useRef({}), [ae] = React.useState(() => createPubSub()), le = useFloatingParentNodeId() != null;
  if (process$1.env.NODE_ENV !== "production") {
    const Ke = ie.reference;
    Ke && !isElement(Ke) && error("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [ge, Ee] = React.useState(ie.reference), oe = useEffectEvent((Ke, ht, _t) => {
    ne.current.openEvent = Ke ? ht : void 0, ae.emit("openchange", {
      open: Ke,
      event: ht,
      reason: _t,
      nested: le
    }), Y == null || Y(Ke, ht, _t);
  }), Pe = React.useMemo(() => ({
    setPositionReference: Ee
  }), []), Ve = React.useMemo(() => ({
    reference: ge || ie.reference || null,
    floating: ie.floating || null,
    domReference: ie.reference
  }), [ge, ie.reference, ie.floating]);
  return React.useMemo(() => ({
    dataRef: ne,
    open: z,
    onOpenChange: oe,
    elements: Ve,
    events: ae,
    floatingId: se,
    refs: Pe
  }), [z, oe, Ve, ae, se, Pe]);
}
function useFloating(B) {
  B === void 0 && (B = {});
  const {
    nodeId: z
  } = B, Y = useFloatingRootContext({
    ...B,
    elements: {
      reference: null,
      floating: null,
      ...B.elements
    }
  }), ie = B.rootContext || Y, se = ie.elements, [ne, ae] = React.useState(null), [le, ge] = React.useState(null), oe = (se == null ? void 0 : se.domReference) || ne, Pe = React.useRef(null), Ve = useFloatingTree();
  index(() => {
    oe && (Pe.current = oe);
  }, [oe]);
  const Ke = useFloating$1({
    ...B,
    elements: {
      ...se,
      ...le && {
        reference: le
      }
    }
  }), ht = React.useCallback((Ct) => {
    const qt = isElement(Ct) ? {
      getBoundingClientRect: () => Ct.getBoundingClientRect(),
      contextElement: Ct
    } : Ct;
    ge(qt), Ke.refs.setReference(qt);
  }, [Ke.refs]), _t = React.useCallback((Ct) => {
    (isElement(Ct) || Ct === null) && (Pe.current = Ct, ae(Ct)), (isElement(Ke.refs.reference.current) || Ke.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    Ct !== null && !isElement(Ct)) && Ke.refs.setReference(Ct);
  }, [Ke.refs]), Rt = React.useMemo(() => ({
    ...Ke.refs,
    setReference: _t,
    setPositionReference: ht,
    domReference: Pe
  }), [Ke.refs, _t, ht]), kt = React.useMemo(() => ({
    ...Ke.elements,
    domReference: oe
  }), [Ke.elements, oe]), Bt = React.useMemo(() => ({
    ...Ke,
    ...ie,
    refs: Rt,
    elements: kt,
    nodeId: z
  }), [Ke, Rt, kt, z, ie]);
  return index(() => {
    ie.dataRef.current.floatingContext = Bt;
    const Ct = Ve == null ? void 0 : Ve.nodesRef.current.find((qt) => qt.id === z);
    Ct && (Ct.context = Bt);
  }), React.useMemo(() => ({
    ...Ke,
    context: Bt,
    refs: Rt,
    elements: kt
  }), [Ke, Rt, kt, Bt]);
}
const ACTIVE_KEY = "active", SELECTED_KEY = "selected";
function mergeProps(B, z, Y) {
  const ie = /* @__PURE__ */ new Map(), se = Y === "item";
  let ne = B;
  if (se && B) {
    const {
      [ACTIVE_KEY]: ae,
      [SELECTED_KEY]: le,
      ...ge
    } = B;
    ne = ge;
  }
  return {
    ...Y === "floating" && {
      tabIndex: -1,
      [FOCUSABLE_ATTRIBUTE]: ""
    },
    ...ne,
    ...z.map((ae) => {
      const le = ae ? ae[Y] : null;
      return typeof le == "function" ? B ? le(B) : null : le;
    }).concat(B).reduce((ae, le) => (le && Object.entries(le).forEach((ge) => {
      let [Ee, oe] = ge;
      if (!(se && [ACTIVE_KEY, SELECTED_KEY].includes(Ee)))
        if (Ee.indexOf("on") === 0) {
          if (ie.has(Ee) || ie.set(Ee, []), typeof oe == "function") {
            var Pe;
            (Pe = ie.get(Ee)) == null || Pe.push(oe), ae[Ee] = function() {
              for (var Ve, Ke = arguments.length, ht = new Array(Ke), _t = 0; _t < Ke; _t++)
                ht[_t] = arguments[_t];
              return (Ve = ie.get(Ee)) == null ? void 0 : Ve.map((Rt) => Rt(...ht)).find((Rt) => Rt !== void 0);
            };
          }
        } else
          ae[Ee] = oe;
    }), ae), {})
  };
}
function useInteractions(B) {
  B === void 0 && (B = []);
  const z = B.map((le) => le == null ? void 0 : le.reference), Y = B.map((le) => le == null ? void 0 : le.floating), ie = B.map((le) => le == null ? void 0 : le.item), se = React.useCallback(
    (le) => mergeProps(le, B, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    z
  ), ne = React.useCallback(
    (le) => mergeProps(le, B, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    Y
  ), ae = React.useCallback(
    (le) => mergeProps(le, B, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    ie
  );
  return React.useMemo(() => ({
    getReferenceProps: se,
    getFloatingProps: ne,
    getItemProps: ae
  }), [se, ne, ae]);
}
function getArgsWithCustomFloatingHeight(B, z) {
  return {
    ...B,
    rects: {
      ...B.rects,
      floating: {
        ...B.rects.floating,
        height: z
      }
    }
  };
}
const inner = (B) => ({
  name: "inner",
  options: B,
  async fn(z) {
    const {
      listRef: Y,
      overflowRef: ie,
      onFallbackChange: se,
      offset: ne = 0,
      index: ae = 0,
      minItemsVisible: le = 4,
      referenceOverflowThreshold: ge = 0,
      scrollRef: Ee,
      ...oe
    } = evaluate(B, z), {
      rects: Pe,
      elements: {
        floating: Ve
      }
    } = z, Ke = Y.current[ae], ht = (Ee == null ? void 0 : Ee.current) || Ve, _t = Ve.clientTop || ht.clientTop, Rt = Ve.clientTop !== 0, kt = ht.clientTop !== 0, Bt = Ve === ht;
    if (process$1.env.NODE_ENV !== "production" && (z.placement.startsWith("bottom") || warn('`placement` side must be "bottom" when using the `inner`', "middleware.")), !Ke)
      return {};
    const Ct = {
      ...z,
      ...await offset(-Ke.offsetTop - Ve.clientTop - Pe.reference.height / 2 - Ke.offsetHeight / 2 - ne).fn(z)
    }, qt = await detectOverflow(getArgsWithCustomFloatingHeight(Ct, ht.scrollHeight + _t + Ve.clientTop), oe), jt = await detectOverflow(Ct, {
      ...oe,
      elementContext: "reference"
    }), Ht = max$1(0, qt.top), Yt = Ct.y + Ht, Kt = (ht.scrollHeight > ht.clientHeight ? (Ft) => Ft : round$1)(max$1(0, ht.scrollHeight + (Rt && Bt || kt ? _t * 2 : 0) - Ht - max$1(0, qt.bottom)));
    if (ht.style.maxHeight = Kt + "px", ht.scrollTop = Ht, se) {
      const Ft = ht.offsetHeight < Ke.offsetHeight * min$1(le, Y.current.length) - 1 || jt.top >= -ge || jt.bottom >= -ge;
      ReactDOM.flushSync(() => se(Ft));
    }
    return ie && (ie.current = await detectOverflow(getArgsWithCustomFloatingHeight({
      ...Ct,
      y: Yt
    }, ht.offsetHeight + _t + Ve.clientTop), oe)), {
      y: Yt
    };
  }
});
function useInnerOffset(B, z) {
  const {
    open: Y,
    elements: ie
  } = B, {
    enabled: se = !0,
    overflowRef: ne,
    scrollRef: ae,
    onChange: le
  } = z, ge = useEffectEvent(le), Ee = React.useRef(!1), oe = React.useRef(null), Pe = React.useRef(null);
  React.useEffect(() => {
    if (!se) return;
    function Ke(_t) {
      if (_t.ctrlKey || !ht || ne.current == null)
        return;
      const Rt = _t.deltaY, kt = ne.current.top >= -0.5, Bt = ne.current.bottom >= -0.5, Ct = ht.scrollHeight - ht.clientHeight, qt = Rt < 0 ? -1 : 1, jt = Rt < 0 ? "max" : "min";
      ht.scrollHeight <= ht.clientHeight || (!kt && Rt > 0 || !Bt && Rt < 0 ? (_t.preventDefault(), ReactDOM.flushSync(() => {
        ge((Ht) => Ht + Math[jt](Rt, Ct * qt));
      })) : /firefox/i.test(getUserAgent()) && (ht.scrollTop += Rt));
    }
    const ht = (ae == null ? void 0 : ae.current) || ie.floating;
    if (Y && ht)
      return ht.addEventListener("wheel", Ke), requestAnimationFrame(() => {
        oe.current = ht.scrollTop, ne.current != null && (Pe.current = {
          ...ne.current
        });
      }), () => {
        oe.current = null, Pe.current = null, ht.removeEventListener("wheel", Ke);
      };
  }, [se, Y, ie.floating, ne, ae, ge]);
  const Ve = React.useMemo(() => ({
    onKeyDown() {
      Ee.current = !0;
    },
    onWheel() {
      Ee.current = !1;
    },
    onPointerMove() {
      Ee.current = !1;
    },
    onScroll() {
      const Ke = (ae == null ? void 0 : ae.current) || ie.floating;
      if (!(!ne.current || !Ke || !Ee.current)) {
        if (oe.current !== null) {
          const ht = Ke.scrollTop - oe.current;
          (ne.current.bottom < -0.5 && ht < -1 || ne.current.top < -0.5 && ht > 1) && ReactDOM.flushSync(() => ge((_t) => _t + ht));
        }
        requestAnimationFrame(() => {
          oe.current = Ke.scrollTop;
        });
      }
    }
  }), [ie.floating, ge, ne, ae]);
  return React.useMemo(() => se ? {
    floating: Ve
  } : {}, [se, Ve]);
}
let y$1 = createContext({ styles: void 0, setReference: () => {
}, setFloating: () => {
}, getReferenceProps: () => ({}), getFloatingProps: () => ({}), slot: {} });
y$1.displayName = "FloatingContext";
let H = createContext(null);
H.displayName = "PlacementContext";
function xe(B) {
  return useMemo(() => B ? typeof B == "string" ? { to: B } : B : null, [B]);
}
function ye$1() {
  return useContext(y$1).setReference;
}
function Fe$1() {
  return useContext(y$1).getReferenceProps;
}
function be() {
  let { getFloatingProps: B, slot: z } = useContext(y$1);
  return useCallback((...Y) => Object.assign({}, B(...Y), { "data-anchor": z.anchor }), [B, z]);
}
function Re(B = null) {
  B === !1 && (B = null), typeof B == "string" && (B = { to: B });
  let z = useContext(H), Y = useMemo(() => B, [JSON.stringify(B, (se, ne) => {
    var ae;
    return (ae = ne == null ? void 0 : ne.outerHTML) != null ? ae : ne;
  })]);
  n$3(() => {
    z == null || z(Y ?? null);
  }, [z, Y]);
  let ie = useContext(y$1);
  return useMemo(() => [ie.setFloating, B ? ie.styles : {}], [ie.setFloating, B, ie.styles]);
}
let q = 4;
function Me$1({ children: B, enabled: z = !0 }) {
  let [Y, ie] = useState(null), [se, ne] = useState(0), ae = useRef(null), [le, ge] = useState(null);
  pe(le);
  let Ee = z && Y !== null && le !== null, { to: oe = "bottom", gap: Pe = 0, offset: Ve = 0, padding: Ke = 0, inner: ht } = ce(Y, le), [_t, Rt = "center"] = oe.split(" ");
  n$3(() => {
    Ee && ne(0);
  }, [Ee]);
  let { refs: kt, floatingStyles: Bt, context: Ct } = useFloating({ open: Ee, placement: _t === "selection" ? Rt === "center" ? "bottom" : `bottom-${Rt}` : Rt === "center" ? `${_t}` : `${_t}-${Rt}`, strategy: "absolute", transform: !1, middleware: [offset({ mainAxis: _t === "selection" ? 0 : Pe, crossAxis: Ve }), shift({ padding: Ke }), _t !== "selection" && flip({ padding: Ke }), _t === "selection" && ht ? inner({ ...ht, padding: Ke, overflowRef: ae, offset: se, minItemsVisible: q, referenceOverflowThreshold: Ke, onFallbackChange(Ft) {
    var bt, Xe;
    if (!Ft) return;
    let ve = Ct.elements.floating;
    if (!ve) return;
    let Ce = parseFloat(getComputedStyle(ve).scrollPaddingBottom) || 0, Qe = Math.min(q, ve.childElementCount), vt = 0, wt = 0;
    for (let $t of (Xe = (bt = Ct.elements.floating) == null ? void 0 : bt.childNodes) != null ? Xe : []) if ($t instanceof HTMLElement) {
      let xt = $t.offsetTop, Pt = xt + $t.clientHeight + Ce, Je = ve.scrollTop, Ot = Je + ve.clientHeight;
      if (xt >= Je && Pt <= Ot) Qe--;
      else {
        wt = Math.max(0, Math.min(Pt, Ot) - Math.max(xt, Je)), vt = $t.clientHeight;
        break;
      }
    }
    Qe >= 1 && ne(($t) => {
      let xt = vt * Qe - wt + Ce;
      return $t >= xt ? $t : xt;
    });
  } }) : null, size({ padding: Ke, apply({ availableWidth: Ft, availableHeight: bt, elements: Xe }) {
    Object.assign(Xe.floating.style, { overflow: "auto", maxWidth: `${Ft}px`, maxHeight: `min(var(--anchor-max-height, 100vh), ${bt}px)` });
  } })].filter(Boolean), whileElementsMounted: autoUpdate }), [qt = _t, jt = Rt] = Ct.placement.split("-");
  _t === "selection" && (qt = "selection");
  let Ht = useMemo(() => ({ anchor: [qt, jt].filter(Boolean).join(" ") }), [qt, jt]), Yt = useInnerOffset(Ct, { overflowRef: ae, onChange: ne }), { getReferenceProps: Ut, getFloatingProps: Nt } = useInteractions([Yt]), Kt = o$4((Ft) => {
    ge(Ft), kt.setFloating(Ft);
  });
  return React.createElement(H.Provider, { value: ie }, React.createElement(y$1.Provider, { value: { setFloating: Kt, setReference: kt.setReference, styles: Bt, getReferenceProps: Ut, getFloatingProps: Nt, slot: Ht } }, B));
}
function pe(B) {
  n$3(() => {
    if (!B) return;
    let z = new MutationObserver(() => {
      let Y = window.getComputedStyle(B).maxHeight, ie = parseFloat(Y);
      if (isNaN(ie)) return;
      let se = parseInt(Y);
      isNaN(se) || ie !== se && (B.style.maxHeight = `${Math.ceil(ie)}px`);
    });
    return z.observe(B, { attributes: !0, attributeFilter: ["style"] }), () => {
      z.disconnect();
    };
  }, [B]);
}
function ce(B, z) {
  var Y, ie, se;
  let ne = V$1((Y = B == null ? void 0 : B.gap) != null ? Y : "var(--anchor-gap, 0)", z), ae = V$1((ie = B == null ? void 0 : B.offset) != null ? ie : "var(--anchor-offset, 0)", z), le = V$1((se = B == null ? void 0 : B.padding) != null ? se : "var(--anchor-padding, 0)", z);
  return { ...B, gap: ne, offset: ae, padding: le };
}
function V$1(B, z, Y = void 0) {
  let ie = p$2(), se = o$4((ge, Ee) => {
    if (ge == null) return [Y, null];
    if (typeof ge == "number") return [ge, null];
    if (typeof ge == "string") {
      if (!Ee) return [Y, null];
      let oe = J$1(ge, Ee);
      return [oe, (Pe) => {
        let Ve = D$1(ge);
        {
          let Ke = Ve.map((ht) => window.getComputedStyle(Ee).getPropertyValue(ht));
          ie.requestAnimationFrame(function ht() {
            ie.nextFrame(ht);
            let _t = !1;
            for (let [kt, Bt] of Ve.entries()) {
              let Ct = window.getComputedStyle(Ee).getPropertyValue(Bt);
              if (Ke[kt] !== Ct) {
                Ke[kt] = Ct, _t = !0;
                break;
              }
            }
            if (!_t) return;
            let Rt = J$1(ge, Ee);
            oe !== Rt && (Pe(Rt), oe = Rt);
          });
        }
        return ie.dispose;
      }];
    }
    return [Y, null];
  }), ne = useMemo(() => se(B, z)[0], [B, z]), [ae = ne, le] = useState();
  return n$3(() => {
    let [ge, Ee] = se(B, z);
    if (le(ge), !!Ee) return Ee(le);
  }, [B, z]), ae;
}
function D$1(B) {
  let z = /var\((.*)\)/.exec(B);
  if (z) {
    let Y = z[1].indexOf(",");
    if (Y === -1) return [z[1]];
    let ie = z[1].slice(0, Y).trim(), se = z[1].slice(Y + 1).trim();
    return se ? [ie, ...D$1(se)] : [ie];
  }
  return [];
}
function J$1(B, z) {
  let Y = document.createElement("div");
  z.appendChild(Y), Y.style.setProperty("margin-top", "0px", "important"), Y.style.setProperty("margin-top", B, "important");
  let ie = parseFloat(window.getComputedStyle(Y).marginTop) || 0;
  return z.removeChild(Y), ie;
}
let n = createContext(null);
n.displayName = "OpenClosedContext";
var i$3 = ((B) => (B[B.Open = 1] = "Open", B[B.Closed = 2] = "Closed", B[B.Closing = 4] = "Closing", B[B.Opening = 8] = "Opening", B))(i$3 || {});
function u$2() {
  return useContext(n);
}
function c$2({ value: B, children: z }) {
  return React__default.createElement(n.Provider, { value: B }, z);
}
function s$4({ children: B }) {
  return React__default.createElement(n.Provider, { value: null }, B);
}
function t(B) {
  function z() {
    document.readyState !== "loading" && (B(), document.removeEventListener("DOMContentLoaded", z));
  }
  typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", z), z());
}
let r$1 = [];
t(() => {
  function B(z) {
    if (!(z.target instanceof HTMLElement) || z.target === document.body || r$1[0] === z.target) return;
    let Y = z.target;
    Y = Y.closest(f$5), r$1.unshift(Y ?? z.target), r$1 = r$1.filter((ie) => ie != null && ie.isConnected), r$1.splice(10);
  }
  window.addEventListener("click", B, { capture: !0 }), window.addEventListener("mousedown", B, { capture: !0 }), window.addEventListener("focus", B, { capture: !0 }), document.body.addEventListener("click", B, { capture: !0 }), document.body.addEventListener("mousedown", B, { capture: !0 }), document.body.addEventListener("focus", B, { capture: !0 });
});
function u$1(B) {
  throw new Error("Unexpected object: " + B);
}
var c$1 = ((B) => (B[B.First = 0] = "First", B[B.Previous = 1] = "Previous", B[B.Next = 2] = "Next", B[B.Last = 3] = "Last", B[B.Specific = 4] = "Specific", B[B.Nothing = 5] = "Nothing", B))(c$1 || {});
function f$3(B, z) {
  let Y = z.resolveItems();
  if (Y.length <= 0) return null;
  let ie = z.resolveActiveIndex(), se = ie ?? -1;
  switch (B.focus) {
    case 0: {
      for (let ne = 0; ne < Y.length; ++ne) if (!z.resolveDisabled(Y[ne], ne, Y)) return ne;
      return ie;
    }
    case 1: {
      se === -1 && (se = Y.length);
      for (let ne = se - 1; ne >= 0; --ne) if (!z.resolveDisabled(Y[ne], ne, Y)) return ne;
      return ie;
    }
    case 2: {
      for (let ne = se + 1; ne < Y.length; ++ne) if (!z.resolveDisabled(Y[ne], ne, Y)) return ne;
      return ie;
    }
    case 3: {
      for (let ne = Y.length - 1; ne >= 0; --ne) if (!z.resolveDisabled(Y[ne], ne, Y)) return ne;
      return ie;
    }
    case 4: {
      for (let ne = 0; ne < Y.length; ++ne) if (z.resolveId(Y[ne], ne, Y) === B.id) return ne;
      return ie;
    }
    case 5:
      return null;
    default:
      u$1(B);
  }
}
function c(B) {
  let z = o$4(B), Y = useRef(!1);
  useEffect(() => (Y.current = !1, () => {
    Y.current = !0, t$4(() => {
      Y.current && z();
    });
  }), [z]);
}
function s$3() {
  let B = typeof document > "u";
  return "useSyncExternalStore" in React ? ((z) => z.useSyncExternalStore)(React)(() => () => {
  }, () => !1, () => !B) : !1;
}
function l$1() {
  let B = s$3(), [z, Y] = React.useState(s$8.isHandoffComplete);
  return z && s$8.isHandoffComplete === !1 && Y(!1), React.useEffect(() => {
    z !== !0 && Y(!0);
  }, [z]), React.useEffect(() => s$8.handoff(), []), B ? !1 : z;
}
let e = createContext(!1);
function a$4() {
  return useContext(e);
}
function l(B) {
  return React__default.createElement(e.Provider, { value: B.force }, B.children);
}
function N(B) {
  let z = a$4(), Y = useContext(v), ie = n$1(B), [se, ne] = useState(() => {
    var ae;
    if (!z && Y !== null) return (ae = Y.current) != null ? ae : null;
    if (s$8.isServer) return null;
    let le = ie == null ? void 0 : ie.getElementById("headlessui-portal-root");
    if (le) return le;
    if (ie === null) return null;
    let ge = ie.createElement("div");
    return ge.setAttribute("id", "headlessui-portal-root"), ie.body.appendChild(ge);
  });
  return useEffect(() => {
    se !== null && (ie != null && ie.body.contains(se) || ie == null || ie.body.appendChild(se));
  }, [se, ie]), useEffect(() => {
    z || Y !== null && ne(Y.current);
  }, [Y, ne, z]), se;
}
let M$1 = Fragment, S = K$1(function(B, z) {
  let Y = B, ie = useRef(null), se = y$4(T$2((Pe) => {
    ie.current = Pe;
  }), z), ne = n$1(ie), ae = N(ie), [le] = useState(() => {
    var Pe;
    return s$8.isServer ? null : (Pe = ne == null ? void 0 : ne.createElement("div")) != null ? Pe : null;
  }), ge = useContext(y), Ee = l$1();
  n$3(() => {
    !ae || !le || ae.contains(le) || (le.setAttribute("data-headlessui-portal", ""), ae.appendChild(le));
  }, [ae, le]), n$3(() => {
    if (le && ge) return ge.register(le);
  }, [ge, le]), c(() => {
    var Pe;
    !ae || !le || (le instanceof Node && ae.contains(le) && ae.removeChild(le), ae.childNodes.length <= 0 && ((Pe = ae.parentElement) == null || Pe.removeChild(ae)));
  });
  let oe = L$1();
  return Ee ? !ae || !le ? null : createPortal(oe({ ourProps: { ref: se }, theirProps: Y, slot: {}, defaultTag: M$1, name: "Portal" }), le) : null;
});
function j$1(B, z) {
  let Y = y$4(z), { enabled: ie = !0, ...se } = B, ne = L$1();
  return ie ? React__default.createElement(S, { ...se, ref: Y }) : ne({ ourProps: { ref: Y }, theirProps: se, slot: {}, defaultTag: M$1, name: "Portal" });
}
let W = Fragment, v = createContext(null);
function I$1(B, z) {
  let { target: Y, ...ie } = B, se = { ref: y$4(z) }, ne = L$1();
  return React__default.createElement(v.Provider, { value: Y }, ne({ ourProps: se, theirProps: ie, defaultTag: W, name: "Popover.Group" }));
}
let y = createContext(null);
function te$1() {
  let B = useContext(y), z = useRef([]), Y = o$4((ne) => (z.current.push(ne), B && B.register(ne), () => ie(ne))), ie = o$4((ne) => {
    let ae = z.current.indexOf(ne);
    ae !== -1 && z.current.splice(ae, 1), B && B.unregister(ne);
  }), se = useMemo(() => ({ register: Y, unregister: ie, portals: z }), [Y, ie, z]);
  return [z, useMemo(() => function({ children: ne }) {
    return React__default.createElement(y.Provider, { value: se }, ne);
  }, [se])];
}
let J = K$1(j$1), X$1 = K$1(I$1), re$1 = Object.assign(J, { Group: X$1 });
function a$3(B, z = typeof document < "u" ? document.defaultView : null, Y) {
  let ie = x$3(B, "escape");
  E(z, "keydown", (se) => {
    ie && (se.defaultPrevented || se.key === o$3.Escape && Y(se));
  });
}
function f$2() {
  var B;
  let [z] = useState(() => typeof window < "u" && typeof window.matchMedia == "function" ? window.matchMedia("(pointer: coarse)") : null), [Y, ie] = useState((B = z == null ? void 0 : z.matches) != null ? B : !1);
  return n$3(() => {
    if (!z) return;
    function se(ne) {
      ie(ne.matches);
    }
    return z.addEventListener("change", se), () => z.removeEventListener("change", se);
  }, [z]), Y;
}
function R({ defaultContainers: B = [], portals: z, mainTreeNode: Y } = {}) {
  let ie = n$1(Y), se = o$4(() => {
    var ne, ae;
    let le = [];
    for (let ge of B) ge !== null && (ge instanceof HTMLElement ? le.push(ge) : "current" in ge && ge.current instanceof HTMLElement && le.push(ge.current));
    if (z != null && z.current) for (let ge of z.current) le.push(ge);
    for (let ge of (ne = ie == null ? void 0 : ie.querySelectorAll("html > *, body > *")) != null ? ne : []) ge !== document.body && ge !== document.head && ge instanceof HTMLElement && ge.id !== "headlessui-portal-root" && (Y && (ge.contains(Y) || ge.contains((ae = Y == null ? void 0 : Y.getRootNode()) == null ? void 0 : ae.host)) || le.some((Ee) => ge.contains(Ee)) || le.push(ge));
    return le;
  });
  return { resolveContainers: se, contains: o$4((ne) => se().some((ae) => ae.contains(ne))) };
}
let a$2 = createContext(null);
function O$1({ children: B, node: z }) {
  let [Y, ie] = useState(null), se = b(z ?? Y);
  return React__default.createElement(a$2.Provider, { value: se }, B, se === null && React__default.createElement(f$9, { features: s$6.Hidden, ref: (ne) => {
    var ae, le;
    if (ne) {
      for (let ge of (le = (ae = u$8(ne)) == null ? void 0 : ae.querySelectorAll("html > *, body > *")) != null ? le : []) if (ge !== document.body && ge !== document.head && ge instanceof HTMLElement && ge != null && ge.contains(ne)) {
        ie(ge);
        break;
      }
    }
  } }));
}
function b(B = null) {
  var z;
  return (z = useContext(a$2)) != null ? z : B;
}
function f$1() {
  let B = useRef(!1);
  return n$3(() => (B.current = !0, () => {
    B.current = !1;
  }), []), B;
}
var a$1 = ((B) => (B[B.Forwards = 0] = "Forwards", B[B.Backwards = 1] = "Backwards", B))(a$1 || {});
function u() {
  let B = useRef(0);
  return s$5(!0, "keydown", (z) => {
    z.key === "Tab" && (B.current = z.shiftKey ? 1 : 0);
  }, !0), B;
}
function U$1(B) {
  if (!B) return /* @__PURE__ */ new Set();
  if (typeof B == "function") return new Set(B());
  let z = /* @__PURE__ */ new Set();
  for (let Y of B.current) Y.current instanceof HTMLElement && z.add(Y.current);
  return z;
}
let Z = "div";
var x$1 = ((B) => (B[B.None = 0] = "None", B[B.InitialFocus = 1] = "InitialFocus", B[B.TabLock = 2] = "TabLock", B[B.FocusLock = 4] = "FocusLock", B[B.RestoreFocus = 8] = "RestoreFocus", B[B.AutoFocus = 16] = "AutoFocus", B))(x$1 || {});
function $(B, z) {
  let Y = useRef(null), ie = y$4(Y, z), { initialFocus: se, initialFocusFallback: ne, containers: ae, features: le = 15, ...ge } = B;
  l$1() || (le = 0);
  let Ee = n$1(Y);
  ee(le, { ownerDocument: Ee });
  let oe = te(le, { ownerDocument: Ee, container: Y, initialFocus: se, initialFocusFallback: ne });
  re(le, { ownerDocument: Ee, container: Y, containers: ae, previousActiveElement: oe });
  let Pe = u(), Ve = o$4((Bt) => {
    let Ct = Y.current;
    Ct && ((qt) => qt())(() => {
      u$7(Pe.current, { [a$1.Forwards]: () => {
        P(Ct, F$1.First, { skipElements: [Bt.relatedTarget, ne] });
      }, [a$1.Backwards]: () => {
        P(Ct, F$1.Last, { skipElements: [Bt.relatedTarget, ne] });
      } });
    });
  }), Ke = x$3(!!(le & 2), "focus-trap#tab-lock"), ht = p$2(), _t = useRef(!1), Rt = { ref: ie, onKeyDown(Bt) {
    Bt.key == "Tab" && (_t.current = !0, ht.requestAnimationFrame(() => {
      _t.current = !1;
    }));
  }, onBlur(Bt) {
    if (!(le & 4)) return;
    let Ct = U$1(ae);
    Y.current instanceof HTMLElement && Ct.add(Y.current);
    let qt = Bt.relatedTarget;
    qt instanceof HTMLElement && qt.dataset.headlessuiFocusGuard !== "true" && (I(Ct, qt) || (_t.current ? P(Y.current, u$7(Pe.current, { [a$1.Forwards]: () => F$1.Next, [a$1.Backwards]: () => F$1.Previous }) | F$1.WrapAround, { relativeTo: Bt.target }) : Bt.target instanceof HTMLElement && I$2(Bt.target)));
  } }, kt = L$1();
  return React__default.createElement(React__default.Fragment, null, Ke && React__default.createElement(f$9, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ve, features: s$6.Focusable }), kt({ ourProps: Rt, theirProps: ge, defaultTag: Z, name: "FocusTrap" }), Ke && React__default.createElement(f$9, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: Ve, features: s$6.Focusable }));
}
let D = K$1($), ye = Object.assign(D, { features: x$1 });
function w$2(B = !0) {
  let z = useRef(r$1.slice());
  return m(([Y], [ie]) => {
    ie === !0 && Y === !1 && t$4(() => {
      z.current.splice(0);
    }), ie === !1 && Y === !0 && (z.current = r$1.slice());
  }, [B, r$1, z]), o$4(() => {
    var Y;
    return (Y = z.current.find((ie) => ie != null && ie.isConnected)) != null ? Y : null;
  });
}
function ee(B, { ownerDocument: z }) {
  let Y = !!(B & 8), ie = w$2(Y);
  m(() => {
    Y || (z == null ? void 0 : z.activeElement) === (z == null ? void 0 : z.body) && I$2(ie());
  }, [Y]), c(() => {
    Y && I$2(ie());
  });
}
function te(B, { ownerDocument: z, container: Y, initialFocus: ie, initialFocusFallback: se }) {
  let ne = useRef(null), ae = x$3(!!(B & 1), "focus-trap#initial-focus"), le = f$1();
  return m(() => {
    if (B === 0) return;
    if (!ae) {
      se != null && se.current && I$2(se.current);
      return;
    }
    let ge = Y.current;
    ge && t$4(() => {
      if (!le.current) return;
      let Ee = z == null ? void 0 : z.activeElement;
      if (ie != null && ie.current) {
        if ((ie == null ? void 0 : ie.current) === Ee) {
          ne.current = Ee;
          return;
        }
      } else if (ge.contains(Ee)) {
        ne.current = Ee;
        return;
      }
      if (ie != null && ie.current) I$2(ie.current);
      else {
        if (B & 16) {
          if (P(ge, F$1.First | F$1.AutoFocus) !== T$1.Error) return;
        } else if (P(ge, F$1.First) !== T$1.Error) return;
        if (se != null && se.current && (I$2(se.current), (z == null ? void 0 : z.activeElement) === se.current)) return;
        console.warn("There are no focusable elements inside the <FocusTrap />");
      }
      ne.current = z == null ? void 0 : z.activeElement;
    });
  }, [se, ae, B]), ne;
}
function re(B, { ownerDocument: z, container: Y, containers: ie, previousActiveElement: se }) {
  let ne = f$1(), ae = !!(B & 4);
  E(z == null ? void 0 : z.defaultView, "focus", (le) => {
    if (!ae || !ne.current) return;
    let ge = U$1(ie);
    Y.current instanceof HTMLElement && ge.add(Y.current);
    let Ee = se.current;
    if (!Ee) return;
    let oe = le.target;
    oe && oe instanceof HTMLElement ? I(ge, oe) ? (se.current = oe, I$2(oe)) : (le.preventDefault(), le.stopPropagation(), I$2(Ee)) : I$2(se.current);
  }, !0);
}
function I(B, z) {
  for (let Y of B) if (Y.contains(z)) return !0;
  return !1;
}
function ue(B) {
  var z;
  return !!(B.enter || B.enterFrom || B.enterTo || B.leave || B.leaveFrom || B.leaveTo) || ((z = B.as) != null ? z : de) !== Fragment || React__default.Children.count(B.children) === 1;
}
let w$1 = createContext(null);
w$1.displayName = "TransitionContext";
var _e = ((B) => (B.Visible = "visible", B.Hidden = "hidden", B))(_e || {});
function De() {
  let B = useContext(w$1);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
function He$1() {
  let B = useContext(M);
  if (B === null) throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return B;
}
let M = createContext(null);
M.displayName = "NestingContext";
function U(B) {
  return "children" in B ? U(B.children) : B.current.filter(({ el: z }) => z.current !== null).filter(({ state: z }) => z === "visible").length > 0;
}
function Te(B, z) {
  let Y = s$7(B), ie = useRef([]), se = f$1(), ne = p$2(), ae = o$4((Ke, ht = A$1.Hidden) => {
    let _t = ie.current.findIndex(({ el: Rt }) => Rt === Ke);
    _t !== -1 && (u$7(ht, { [A$1.Unmount]() {
      ie.current.splice(_t, 1);
    }, [A$1.Hidden]() {
      ie.current[_t].state = "hidden";
    } }), ne.microTask(() => {
      var Rt;
      !U(ie) && se.current && ((Rt = Y.current) == null || Rt.call(Y));
    }));
  }), le = o$4((Ke) => {
    let ht = ie.current.find(({ el: _t }) => _t === Ke);
    return ht ? ht.state !== "visible" && (ht.state = "visible") : ie.current.push({ el: Ke, state: "visible" }), () => ae(Ke, A$1.Unmount);
  }), ge = useRef([]), Ee = useRef(Promise.resolve()), oe = useRef({ enter: [], leave: [] }), Pe = o$4((Ke, ht, _t) => {
    ge.current.splice(0), z && (z.chains.current[ht] = z.chains.current[ht].filter(([Rt]) => Rt !== Ke)), z == null || z.chains.current[ht].push([Ke, new Promise((Rt) => {
      ge.current.push(Rt);
    })]), z == null || z.chains.current[ht].push([Ke, new Promise((Rt) => {
      Promise.all(oe.current[ht].map(([kt, Bt]) => Bt)).then(() => Rt());
    })]), ht === "enter" ? Ee.current = Ee.current.then(() => z == null ? void 0 : z.wait.current).then(() => _t(ht)) : _t(ht);
  }), Ve = o$4((Ke, ht, _t) => {
    Promise.all(oe.current[ht].splice(0).map(([Rt, kt]) => kt)).then(() => {
      var Rt;
      (Rt = ge.current.shift()) == null || Rt();
    }).then(() => _t(ht));
  });
  return useMemo(() => ({ children: ie, register: le, unregister: ae, onStart: Pe, onStop: Ve, wait: Ee, chains: oe }), [le, ae, ie, Pe, Ve, oe, Ee]);
}
let de = Fragment, fe = O$3.RenderStrategy;
function Ae(B, z) {
  var Y, ie;
  let { transition: se = !0, beforeEnter: ne, afterEnter: ae, beforeLeave: le, afterLeave: ge, enter: Ee, enterFrom: oe, enterTo: Pe, entered: Ve, leave: Ke, leaveFrom: ht, leaveTo: _t, ...Rt } = B, [kt, Bt] = useState(null), Ct = useRef(null), qt = ue(B), jt = y$4(...qt ? [Ct, z, Bt] : z === null ? [] : [z]), Ht = (Y = Rt.unmount) == null || Y ? A$1.Unmount : A$1.Hidden, { show: Yt, appear: Ut, initial: Nt } = De(), [Kt, Ft] = useState(Yt ? "visible" : "hidden"), bt = He$1(), { register: Xe, unregister: ve } = bt;
  n$3(() => Xe(Ct), [Xe, Ct]), n$3(() => {
    if (Ht === A$1.Hidden && Ct.current) {
      if (Yt && Kt !== "visible") {
        Ft("visible");
        return;
      }
      return u$7(Kt, { hidden: () => ve(Ct), visible: () => Xe(Ct) });
    }
  }, [Kt, Ct, Xe, ve, Yt, Ht]);
  let Ce = l$1();
  n$3(() => {
    if (qt && Ce && Kt === "visible" && Ct.current === null) throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [Ct, Kt, Ce, qt]);
  let Qe = Nt && !Ut, vt = Ut && Yt && Nt, wt = useRef(!1), $t = Te(() => {
    wt.current || (Ft("hidden"), ve(Ct));
  }, bt), xt = o$4((Wt) => {
    wt.current = !0;
    let Gt = Wt ? "enter" : "leave";
    $t.onStart(Ct, Gt, (rr) => {
      rr === "enter" ? ne == null || ne() : rr === "leave" && (le == null || le());
    });
  }), Pt = o$4((Wt) => {
    let Gt = Wt ? "enter" : "leave";
    wt.current = !1, $t.onStop(Ct, Gt, (rr) => {
      rr === "enter" ? ae == null || ae() : rr === "leave" && (ge == null || ge());
    }), Gt === "leave" && !U($t) && (Ft("hidden"), ve(Ct));
  });
  useEffect(() => {
    qt && se || (xt(Yt), Pt(Yt));
  }, [Yt, qt, se]);
  let Je = !(!se || !qt || !Ce || Qe), [, Ot] = x$2(Je, kt, Yt, { start: xt, end: Pt }), er = m$4({ ref: jt, className: ((ie = t$3(Rt.className, vt && Ee, vt && oe, Ot.enter && Ee, Ot.enter && Ot.closed && oe, Ot.enter && !Ot.closed && Pe, Ot.leave && Ke, Ot.leave && !Ot.closed && ht, Ot.leave && Ot.closed && _t, !Ot.transition && Yt && Ve)) == null ? void 0 : ie.trim()) || void 0, ...R$1(Ot) }), sr = 0;
  Kt === "visible" && (sr |= i$3.Open), Kt === "hidden" && (sr |= i$3.Closed), Ot.enter && (sr |= i$3.Opening), Ot.leave && (sr |= i$3.Closing);
  let Jt = L$1();
  return React__default.createElement(M.Provider, { value: $t }, React__default.createElement(c$2, { value: sr }, Jt({ ourProps: er, theirProps: Rt, defaultTag: de, features: fe, visible: Kt === "visible", name: "Transition.Child" })));
}
function Ie$1(B, z) {
  let { show: Y, appear: ie = !1, unmount: se = !0, ...ne } = B, ae = useRef(null), le = ue(B), ge = y$4(...le ? [ae, z] : z === null ? [] : [z]);
  l$1();
  let Ee = u$2();
  if (Y === void 0 && Ee !== null && (Y = (Ee & i$3.Open) === i$3.Open), Y === void 0) throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [oe, Pe] = useState(Y ? "visible" : "hidden"), Ve = Te(() => {
    Y || Pe("hidden");
  }), [Ke, ht] = useState(!0), _t = useRef([Y]);
  n$3(() => {
    Ke !== !1 && _t.current[_t.current.length - 1] !== Y && (_t.current.push(Y), ht(!1));
  }, [_t, Y]);
  let Rt = useMemo(() => ({ show: Y, appear: ie, initial: Ke }), [Y, ie, Ke]);
  n$3(() => {
    Y ? Pe("visible") : !U(Ve) && ae.current !== null && Pe("hidden");
  }, [Y, Ve]);
  let kt = { unmount: se }, Bt = o$4(() => {
    var jt;
    Ke && ht(!1), (jt = B.beforeEnter) == null || jt.call(B);
  }), Ct = o$4(() => {
    var jt;
    Ke && ht(!1), (jt = B.beforeLeave) == null || jt.call(B);
  }), qt = L$1();
  return React__default.createElement(M.Provider, { value: Ve }, React__default.createElement(w$1.Provider, { value: Rt }, qt({ ourProps: { ...kt, as: Fragment, children: React__default.createElement(me, { ref: ge, ...kt, ...ne, beforeEnter: Bt, beforeLeave: Ct }) }, theirProps: {}, defaultTag: Fragment, features: fe, visible: oe === "visible", name: "Transition" })));
}
function Le(B, z) {
  let Y = useContext(w$1) !== null, ie = u$2() !== null;
  return React__default.createElement(React__default.Fragment, null, !Y && ie ? React__default.createElement(X, { ref: z, ...B }) : React__default.createElement(me, { ref: z, ...B }));
}
let X = K$1(Ie$1), me = K$1(Ae), Fe = K$1(Le), ze$1 = Object.assign(X, { Child: Fe, Root: X });
var Oe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(Oe || {}), he = ((B) => (B[B.SetTitleId = 0] = "SetTitleId", B))(he || {});
let Se = { 0(B, z) {
  return B.titleId === z.id ? B : { ...B, titleId: z.id };
} }, k$1 = createContext(null);
k$1.displayName = "DialogContext";
function O(B) {
  let z = useContext(k$1);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, O), Y;
  }
  return z;
}
function Ie(B, z) {
  return u$7(z.type, Se, B, z);
}
let V = K$1(function(B, z) {
  let Y = useId$1(), { id: ie = `headlessui-dialog-${Y}`, open: se, onClose: ne, initialFocus: ae, role: le = "dialog", autoFocus: ge = !0, __demoMode: Ee = !1, unmount: oe = !1, ...Pe } = B, Ve = useRef(!1);
  le = function() {
    return le === "dialog" || le === "alertdialog" ? le : (Ve.current || (Ve.current = !0, console.warn(`Invalid role [${le}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog");
  }();
  let Ke = u$2();
  se === void 0 && Ke !== null && (se = (Ke & i$3.Open) === i$3.Open);
  let ht = useRef(null), _t = y$4(ht, z), Rt = n$1(ht), kt = se ? 0 : 1, [Bt, Ct] = useReducer(Ie, { titleId: null, descriptionId: null, panelRef: createRef() }), qt = o$4(() => ne(!1)), jt = o$4((Pt) => Ct({ type: 0, id: Pt })), Ht = l$1() ? kt === 0 : !1, [Yt, Ut] = te$1(), Nt = { get current() {
    var Pt;
    return (Pt = Bt.panelRef.current) != null ? Pt : ht.current;
  } }, Kt = b(), { resolveContainers: Ft } = R({ mainTreeNode: Kt, portals: Yt, defaultContainers: [Nt] }), bt = Ke !== null ? (Ke & i$3.Closing) === i$3.Closing : !1;
  y$3(Ee || bt ? !1 : Ht, { allowed: o$4(() => {
    var Pt, Je;
    return [(Je = (Pt = ht.current) == null ? void 0 : Pt.closest("[data-headlessui-portal]")) != null ? Je : null];
  }), disallowed: o$4(() => {
    var Pt;
    return [(Pt = Kt == null ? void 0 : Kt.closest("body > *:not(#headlessui-portal-root)")) != null ? Pt : null];
  }) }), R$2(Ht, Ft, (Pt) => {
    Pt.preventDefault(), qt();
  }), a$3(Ht, Rt == null ? void 0 : Rt.defaultView, (Pt) => {
    Pt.preventDefault(), Pt.stopPropagation(), document.activeElement && "blur" in document.activeElement && typeof document.activeElement.blur == "function" && document.activeElement.blur(), qt();
  }), f$4(Ee || bt ? !1 : Ht, Rt, Ft), m$2(Ht, ht, qt);
  let [Xe, ve] = w$4(), Ce = useMemo(() => [{ dialogState: kt, close: qt, setTitleId: jt, unmount: oe }, Bt], [kt, Bt, qt, jt, oe]), Qe = useMemo(() => ({ open: kt === 0 }), [kt]), vt = { ref: _t, id: ie, role: le, tabIndex: -1, "aria-modal": Ee ? void 0 : kt === 0 ? !0 : void 0, "aria-labelledby": Bt.titleId, "aria-describedby": Xe, unmount: oe }, wt = !f$2(), $t = x$1.None;
  Ht && !Ee && ($t |= x$1.RestoreFocus, $t |= x$1.TabLock, ge && ($t |= x$1.AutoFocus), wt && ($t |= x$1.InitialFocus));
  let xt = L$1();
  return React__default.createElement(s$4, null, React__default.createElement(l, { force: !0 }, React__default.createElement(re$1, null, React__default.createElement(k$1.Provider, { value: Ce }, React__default.createElement(X$1, { target: ht }, React__default.createElement(l, { force: !1 }, React__default.createElement(ve, { slot: Qe }, React__default.createElement(Ut, null, React__default.createElement(ye, { initialFocus: ae, initialFocusFallback: ht, containers: Ft, features: $t }, React__default.createElement(C$1, { value: qt }, xt({ ourProps: vt, theirProps: Pe, slot: Qe, defaultTag: Me, features: Ge, visible: kt === 0, name: "Dialog" })))))))))));
}), Me = "div", Ge = O$3.RenderStrategy | O$3.Static;
function ke(B, z) {
  let { transition: Y = !1, open: ie, ...se } = B, ne = u$2(), ae = B.hasOwnProperty("open") || ne !== null, le = B.hasOwnProperty("onClose");
  if (!ae && !le) throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!ae) throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!le) throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (!ne && typeof B.open != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${B.open}`);
  if (typeof B.onClose != "function") throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${B.onClose}`);
  return (ie !== void 0 || Y) && !se.static ? React__default.createElement(O$1, null, React__default.createElement(ze$1, { show: ie, transition: Y, unmount: se.unmount }, React__default.createElement(V, { ref: z, ...se }))) : React__default.createElement(O$1, null, React__default.createElement(V, { ref: z, open: ie, ...se }));
}
let we = "div";
function Be(B, z) {
  let Y = useId$1(), { id: ie = `headlessui-dialog-panel-${Y}`, transition: se = !1, ...ne } = B, [{ dialogState: ae, unmount: le }, ge] = O("Dialog.Panel"), Ee = y$4(z, ge.panelRef), oe = useMemo(() => ({ open: ae === 0 }), [ae]), Pe = o$4((Rt) => {
    Rt.stopPropagation();
  }), Ve = { ref: Ee, id: ie, onClick: Pe }, Ke = se ? Fe : Fragment, ht = se ? { unmount: le } : {}, _t = L$1();
  return React__default.createElement(Ke, { ...ht }, _t({ ourProps: Ve, theirProps: ne, slot: oe, defaultTag: we, name: "Dialog.Panel" }));
}
let Ue = "div";
function He(B, z) {
  let { transition: Y = !1, ...ie } = B, [{ dialogState: se, unmount: ne }] = O("Dialog.Backdrop"), ae = useMemo(() => ({ open: se === 0 }), [se]), le = { ref: z, "aria-hidden": !0 }, ge = Y ? Fe : Fragment, Ee = Y ? { unmount: ne } : {}, oe = L$1();
  return React__default.createElement(ge, { ...Ee }, oe({ ourProps: le, theirProps: ie, slot: ae, defaultTag: Ue, name: "Dialog.Backdrop" }));
}
let Ne = "h2";
function We(B, z) {
  let Y = useId$1(), { id: ie = `headlessui-dialog-title-${Y}`, ...se } = B, [{ dialogState: ne, setTitleId: ae }] = O("Dialog.Title"), le = y$4(z);
  useEffect(() => (ae(ie), () => ae(null)), [ie, ae]);
  let ge = useMemo(() => ({ open: ne === 0 }), [ne]), Ee = { ref: le, id: ie };
  return L$1()({ ourProps: Ee, theirProps: se, slot: ge, defaultTag: Ne, name: "Dialog.Title" });
}
let $e = K$1(ke), je = K$1(Be);
K$1(He);
let Ye$1 = K$1(We), yt$1 = Object.assign($e, { Panel: je, Title: Ye$1, Description: H$2 });
function s$2(B, z) {
  let Y = useRef({ left: 0, top: 0 });
  if (n$3(() => {
    if (!z) return;
    let se = z.getBoundingClientRect();
    se && (Y.current = se);
  }, [B, z]), z == null || !B || z === document.activeElement) return !1;
  let ie = z.getBoundingClientRect();
  return ie.top !== Y.current.top || ie.left !== Y.current.left;
}
let a = /([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g;
function o$1(B) {
  var z, Y;
  let ie = (z = B.innerText) != null ? z : "", se = B.cloneNode(!0);
  if (!(se instanceof HTMLElement)) return ie;
  let ne = !1;
  for (let le of se.querySelectorAll('[hidden],[aria-hidden],[role="img"]')) le.remove(), ne = !0;
  let ae = ne ? (Y = se.innerText) != null ? Y : "" : ie;
  return a.test(ae) && (ae = ae.replace(a, "")), ae;
}
function g(B) {
  let z = B.getAttribute("aria-label");
  if (typeof z == "string") return z.trim();
  let Y = B.getAttribute("aria-labelledby");
  if (Y) {
    let ie = Y.split(" ").map((se) => {
      let ne = document.getElementById(se);
      if (ne) {
        let ae = ne.getAttribute("aria-label");
        return typeof ae == "string" ? ae.trim() : o$1(ne).trim();
      }
      return null;
    }).filter(Boolean);
    if (ie.length > 0) return ie.join(", ");
  }
  return o$1(B).trim();
}
function s$1(B) {
  let z = useRef(""), Y = useRef("");
  return o$4(() => {
    let ie = B.current;
    if (!ie) return "";
    let se = ie.innerText;
    if (z.current === se) return Y.current;
    let ne = g(ie).trim().toLowerCase();
    return z.current = se, Y.current = ne, ne;
  });
}
var qe = ((B) => (B[B.Open = 0] = "Open", B[B.Closed = 1] = "Closed", B))(qe || {}), ze = ((B) => (B[B.Pointer = 0] = "Pointer", B[B.Other = 1] = "Other", B))(ze || {}), Ye = ((B) => (B[B.OpenMenu = 0] = "OpenMenu", B[B.CloseMenu = 1] = "CloseMenu", B[B.GoToItem = 2] = "GoToItem", B[B.Search = 3] = "Search", B[B.ClearSearch = 4] = "ClearSearch", B[B.RegisterItem = 5] = "RegisterItem", B[B.UnregisterItem = 6] = "UnregisterItem", B[B.SetButtonElement = 7] = "SetButtonElement", B[B.SetItemsElement = 8] = "SetItemsElement", B))(Ye || {});
function j(B, z = (Y) => Y) {
  let Y = B.activeItemIndex !== null ? B.items[B.activeItemIndex] : null, ie = _(z(B.items.slice()), (ne) => ne.dataRef.current.domRef.current), se = Y ? ie.indexOf(Y) : null;
  return se === -1 && (se = null), { items: ie, activeItemIndex: se };
}
let Ze = { 1(B) {
  return B.menuState === 1 ? B : { ...B, activeItemIndex: null, menuState: 1 };
}, 0(B) {
  return B.menuState === 0 ? B : { ...B, __demoMode: !1, menuState: 0 };
}, 2: (B, z) => {
  var Y, ie, se, ne, ae;
  if (B.menuState === 1) return B;
  let le = { ...B, searchQuery: "", activationTrigger: (Y = z.trigger) != null ? Y : 1, __demoMode: !1 };
  if (z.focus === c$1.Nothing) return { ...le, activeItemIndex: null };
  if (z.focus === c$1.Specific) return { ...le, activeItemIndex: B.items.findIndex((oe) => oe.id === z.id) };
  if (z.focus === c$1.Previous) {
    let oe = B.activeItemIndex;
    if (oe !== null) {
      let Pe = B.items[oe].dataRef.current.domRef, Ve = f$3(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Ke) => Ke.id, resolveDisabled: (Ke) => Ke.dataRef.current.disabled });
      if (Ve !== null) {
        let Ke = B.items[Ve].dataRef.current.domRef;
        if (((ie = Pe.current) == null ? void 0 : ie.previousElementSibling) === Ke.current || ((se = Ke.current) == null ? void 0 : se.previousElementSibling) === null) return { ...le, activeItemIndex: Ve };
      }
    }
  } else if (z.focus === c$1.Next) {
    let oe = B.activeItemIndex;
    if (oe !== null) {
      let Pe = B.items[oe].dataRef.current.domRef, Ve = f$3(z, { resolveItems: () => B.items, resolveActiveIndex: () => B.activeItemIndex, resolveId: (Ke) => Ke.id, resolveDisabled: (Ke) => Ke.dataRef.current.disabled });
      if (Ve !== null) {
        let Ke = B.items[Ve].dataRef.current.domRef;
        if (((ne = Pe.current) == null ? void 0 : ne.nextElementSibling) === Ke.current || ((ae = Ke.current) == null ? void 0 : ae.nextElementSibling) === null) return { ...le, activeItemIndex: Ve };
      }
    }
  }
  let ge = j(B), Ee = f$3(z, { resolveItems: () => ge.items, resolveActiveIndex: () => ge.activeItemIndex, resolveId: (oe) => oe.id, resolveDisabled: (oe) => oe.dataRef.current.disabled });
  return { ...le, ...ge, activeItemIndex: Ee };
}, 3: (B, z) => {
  let Y = B.searchQuery !== "" ? 0 : 1, ie = B.searchQuery + z.value.toLowerCase(), se = (B.activeItemIndex !== null ? B.items.slice(B.activeItemIndex + Y).concat(B.items.slice(0, B.activeItemIndex + Y)) : B.items).find((ae) => {
    var le;
    return ((le = ae.dataRef.current.textValue) == null ? void 0 : le.startsWith(ie)) && !ae.dataRef.current.disabled;
  }), ne = se ? B.items.indexOf(se) : -1;
  return ne === -1 || ne === B.activeItemIndex ? { ...B, searchQuery: ie } : { ...B, searchQuery: ie, activeItemIndex: ne, activationTrigger: 1 };
}, 4(B) {
  return B.searchQuery === "" ? B : { ...B, searchQuery: "", searchActiveItemIndex: null };
}, 5: (B, z) => {
  let Y = j(B, (ie) => [...ie, { id: z.id, dataRef: z.dataRef }]);
  return { ...B, ...Y };
}, 6: (B, z) => {
  let Y = j(B, (ie) => {
    let se = ie.findIndex((ne) => ne.id === z.id);
    return se !== -1 && ie.splice(se, 1), ie;
  });
  return { ...B, ...Y, activationTrigger: 1 };
}, 7: (B, z) => B.buttonElement === z.element ? B : { ...B, buttonElement: z.element }, 8: (B, z) => B.itemsElement === z.element ? B : { ...B, itemsElement: z.element } }, Q = createContext(null);
Q.displayName = "MenuContext";
function w(B) {
  let z = useContext(Q);
  if (z === null) {
    let Y = new Error(`<${B} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(Y, w), Y;
  }
  return z;
}
function et(B, z) {
  return u$7(z.type, Ze, B, z);
}
let tt = Fragment;
function nt(B, z) {
  let { __demoMode: Y = !1, ...ie } = B, se = useReducer(et, { __demoMode: Y, menuState: Y ? 0 : 1, buttonElement: null, itemsElement: null, items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: ne, itemsElement: ae, buttonElement: le }, ge] = se, Ee = y$4(z);
  R$2(ne === 0, [le, ae], (ht, _t) => {
    ge({ type: 1 }), A(_t, h$2.Loose) || (ht.preventDefault(), le == null || le.focus());
  });
  let oe = o$4(() => {
    ge({ type: 1 });
  }), Pe = useMemo(() => ({ open: ne === 0, close: oe }), [ne, oe]), Ve = { ref: Ee }, Ke = L$1();
  return React__default.createElement(Me$1, null, React__default.createElement(Q.Provider, { value: se }, React__default.createElement(c$2, { value: u$7(ne, { 0: i$3.Open, 1: i$3.Closed }) }, Ke({ ourProps: Ve, theirProps: ie, slot: Pe, defaultTag: tt, name: "Menu" }))));
}
let rt = "button";
function ot(B, z) {
  var Y;
  let ie = useId$1(), { id: se = `headlessui-menu-button-${ie}`, disabled: ne = !1, autoFocus: ae = !1, ...le } = B, [ge, Ee] = w("Menu.Button"), oe = Fe$1(), Pe = y$4(z, ye$1(), o$4((Yt) => Ee({ type: 7, element: Yt }))), Ve = o$4((Yt) => {
    switch (Yt.key) {
      case o$3.Space:
      case o$3.Enter:
      case o$3.ArrowDown:
        Yt.preventDefault(), Yt.stopPropagation(), flushSync(() => Ee({ type: 0 })), Ee({ type: 2, focus: c$1.First });
        break;
      case o$3.ArrowUp:
        Yt.preventDefault(), Yt.stopPropagation(), flushSync(() => Ee({ type: 0 })), Ee({ type: 2, focus: c$1.Last });
        break;
    }
  }), Ke = o$4((Yt) => {
    switch (Yt.key) {
      case o$3.Space:
        Yt.preventDefault();
        break;
    }
  }), ht = o$4((Yt) => {
    var Ut;
    if (r$3(Yt.currentTarget)) return Yt.preventDefault();
    ne || (ge.menuState === 0 ? (flushSync(() => Ee({ type: 1 })), (Ut = ge.buttonElement) == null || Ut.focus({ preventScroll: !0 })) : (Yt.preventDefault(), Ee({ type: 0 })));
  }), { isFocusVisible: _t, focusProps: Rt } = $f7dceffc5ad7768b$export$4e328f61c538687f({ autoFocus: ae }), { isHovered: kt, hoverProps: Bt } = $6179b936705e76d3$export$ae780daf29e6d456({ isDisabled: ne }), { pressed: Ct, pressProps: qt } = w$5({ disabled: ne }), jt = useMemo(() => ({ open: ge.menuState === 0, active: Ct || ge.menuState === 0, disabled: ne, hover: kt, focus: _t, autofocus: ae }), [ge, kt, _t, Ct, ne, ae]), Ht = _$2(oe(), { ref: Pe, id: se, type: e$1(B, ge.buttonElement), "aria-haspopup": "menu", "aria-controls": (Y = ge.itemsElement) == null ? void 0 : Y.id, "aria-expanded": ge.menuState === 0, disabled: ne || void 0, autoFocus: ae, onKeyDown: Ve, onKeyUp: Ke, onClick: ht }, Rt, Bt, qt);
  return L$1()({ ourProps: Ht, theirProps: le, slot: jt, defaultTag: rt, name: "Menu.Button" });
}
let at = "div", lt = O$3.RenderStrategy | O$3.Static;
function it(B, z) {
  var Y, ie;
  let se = useId$1(), { id: ne = `headlessui-menu-items-${se}`, anchor: ae, portal: le = !1, modal: ge = !0, transition: Ee = !1, ...oe } = B, Pe = xe(ae), [Ve, Ke] = w("Menu.Items"), [ht, _t] = Re(Pe), Rt = be(), [kt, Bt] = useState(null), Ct = y$4(z, Pe ? ht : null, o$4((wt) => Ke({ type: 8, element: wt })), Bt), qt = n$1(Ve.itemsElement);
  Pe && (le = !0);
  let jt = u$2(), [Ht, Yt] = x$2(Ee, kt, jt !== null ? (jt & i$3.Open) === i$3.Open : Ve.menuState === 0);
  m$2(Ht, Ve.buttonElement, () => {
    Ke({ type: 1 });
  });
  let Ut = Ve.__demoMode ? !1 : ge && Ve.menuState === 0;
  f$4(Ut, qt);
  let Nt = Ve.__demoMode ? !1 : ge && Ve.menuState === 0;
  y$3(Nt, { allowed: useCallback(() => [Ve.buttonElement, Ve.itemsElement], [Ve.buttonElement, Ve.itemsElement]) });
  let Kt = Ve.menuState !== 0, Ft = s$2(Kt, Ve.buttonElement) ? !1 : Ht;
  useEffect(() => {
    let wt = Ve.itemsElement;
    wt && Ve.menuState === 0 && wt !== (qt == null ? void 0 : qt.activeElement) && wt.focus({ preventScroll: !0 });
  }, [Ve.menuState, Ve.itemsElement, qt]), F(Ve.menuState === 0, { container: Ve.itemsElement, accept(wt) {
    return wt.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : wt.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(wt) {
    wt.setAttribute("role", "none");
  } });
  let bt = p$2(), Xe = o$4((wt) => {
    var $t, xt, Pt;
    switch (bt.dispose(), wt.key) {
      case o$3.Space:
        if (Ve.searchQuery !== "") return wt.preventDefault(), wt.stopPropagation(), Ke({ type: 3, value: wt.key });
      case o$3.Enter:
        if (wt.preventDefault(), wt.stopPropagation(), Ke({ type: 1 }), Ve.activeItemIndex !== null) {
          let { dataRef: Je } = Ve.items[Ve.activeItemIndex];
          (xt = ($t = Je.current) == null ? void 0 : $t.domRef.current) == null || xt.click();
        }
        G(Ve.buttonElement);
        break;
      case o$3.ArrowDown:
        return wt.preventDefault(), wt.stopPropagation(), Ke({ type: 2, focus: c$1.Next });
      case o$3.ArrowUp:
        return wt.preventDefault(), wt.stopPropagation(), Ke({ type: 2, focus: c$1.Previous });
      case o$3.Home:
      case o$3.PageUp:
        return wt.preventDefault(), wt.stopPropagation(), Ke({ type: 2, focus: c$1.First });
      case o$3.End:
      case o$3.PageDown:
        return wt.preventDefault(), wt.stopPropagation(), Ke({ type: 2, focus: c$1.Last });
      case o$3.Escape:
        wt.preventDefault(), wt.stopPropagation(), flushSync(() => Ke({ type: 1 })), (Pt = Ve.buttonElement) == null || Pt.focus({ preventScroll: !0 });
        break;
      case o$3.Tab:
        wt.preventDefault(), wt.stopPropagation(), flushSync(() => Ke({ type: 1 })), j$3(Ve.buttonElement, wt.shiftKey ? F$1.Previous : F$1.Next);
        break;
      default:
        wt.key.length === 1 && (Ke({ type: 3, value: wt.key }), bt.setTimeout(() => Ke({ type: 4 }), 350));
        break;
    }
  }), ve = o$4((wt) => {
    switch (wt.key) {
      case o$3.Space:
        wt.preventDefault();
        break;
    }
  }), Ce = useMemo(() => ({ open: Ve.menuState === 0 }), [Ve.menuState]), Qe = _$2(Pe ? Rt() : {}, { "aria-activedescendant": Ve.activeItemIndex === null || (Y = Ve.items[Ve.activeItemIndex]) == null ? void 0 : Y.id, "aria-labelledby": (ie = Ve.buttonElement) == null ? void 0 : ie.id, id: ne, onKeyDown: Xe, onKeyUp: ve, role: "menu", tabIndex: Ve.menuState === 0 ? 0 : void 0, ref: Ct, style: { ...oe.style, ..._t, "--button-width": d$2(Ve.buttonElement, !0).width }, ...R$1(Yt) }), vt = L$1();
  return React__default.createElement(re$1, { enabled: le ? B.static || Ht : !1 }, vt({ ourProps: Qe, theirProps: oe, slot: Ce, defaultTag: at, features: lt, visible: Ft, name: "Menu.Items" }));
}
let st = Fragment;
function ut(B, z) {
  let Y = useId$1(), { id: ie = `headlessui-menu-item-${Y}`, disabled: se = !1, ...ne } = B, [ae, le] = w("Menu.Item"), ge = ae.activeItemIndex !== null ? ae.items[ae.activeItemIndex].id === ie : !1, Ee = useRef(null), oe = y$4(z, Ee);
  n$3(() => {
    if (!ae.__demoMode && ae.menuState === 0 && ge && ae.activationTrigger !== 0) return o$5().requestAnimationFrame(() => {
      var Ft, bt;
      (bt = (Ft = Ee.current) == null ? void 0 : Ft.scrollIntoView) == null || bt.call(Ft, { block: "nearest" });
    });
  }, [ae.__demoMode, Ee, ge, ae.menuState, ae.activationTrigger, ae.activeItemIndex]);
  let Pe = s$1(Ee), Ve = useRef({ disabled: se, domRef: Ee, get textValue() {
    return Pe();
  } });
  n$3(() => {
    Ve.current.disabled = se;
  }, [Ve, se]), n$3(() => (le({ type: 5, id: ie, dataRef: Ve }), () => le({ type: 6, id: ie })), [Ve, ie]);
  let Ke = o$4(() => {
    le({ type: 1 });
  }), ht = o$4((Ft) => {
    if (se) return Ft.preventDefault();
    le({ type: 1 }), G(ae.buttonElement);
  }), _t = o$4(() => {
    if (se) return le({ type: 2, focus: c$1.Nothing });
    le({ type: 2, focus: c$1.Specific, id: ie });
  }), Rt = u$3(), kt = o$4((Ft) => {
    Rt.update(Ft), !se && (ge || le({ type: 2, focus: c$1.Specific, id: ie, trigger: 0 }));
  }), Bt = o$4((Ft) => {
    Rt.wasMoved(Ft) && (se || ge || le({ type: 2, focus: c$1.Specific, id: ie, trigger: 0 }));
  }), Ct = o$4((Ft) => {
    Rt.wasMoved(Ft) && (se || ge && le({ type: 2, focus: c$1.Nothing }));
  }), [qt, jt] = K(), [Ht, Yt] = w$4(), Ut = useMemo(() => ({ active: ge, focus: ge, disabled: se, close: Ke }), [ge, se, Ke]), Nt = { id: ie, ref: oe, role: "menuitem", tabIndex: se === !0 ? void 0 : -1, "aria-disabled": se === !0 ? !0 : void 0, "aria-labelledby": qt, "aria-describedby": Ht, disabled: void 0, onClick: ht, onFocus: _t, onPointerEnter: kt, onMouseEnter: kt, onPointerMove: Bt, onMouseMove: Bt, onPointerLeave: Ct, onMouseLeave: Ct }, Kt = L$1();
  return React__default.createElement(jt, null, React__default.createElement(Yt, null, Kt({ ourProps: Nt, theirProps: ne, slot: Ut, defaultTag: st, name: "Menu.Item" })));
}
let pt = "div";
function mt(B, z) {
  let [Y, ie] = K(), se = B, ne = { ref: z, "aria-labelledby": Y, role: "group" }, ae = L$1();
  return React__default.createElement(ie, null, ae({ ourProps: ne, theirProps: se, slot: {}, defaultTag: pt, name: "Menu.Section" }));
}
let dt = "header";
function ct(B, z) {
  let Y = useId$1(), { id: ie = `headlessui-menu-heading-${Y}`, ...se } = B, ne = P$1();
  n$3(() => ne.register(ie), [ie, ne.register]);
  let ae = { id: ie, ref: z, role: "presentation", ...ne.props };
  return L$1()({ ourProps: ae, theirProps: se, slot: {}, defaultTag: dt, name: "Menu.Heading" });
}
let ft = "div";
function Tt(B, z) {
  let Y = B, ie = { ref: z, role: "separator" };
  return L$1()({ ourProps: ie, theirProps: Y, slot: {}, defaultTag: ft, name: "Menu.Separator" });
}
let yt = K$1(nt), It = K$1(ot), gt = K$1(it), Et = K$1(ut), Mt = K$1(mt), St = K$1(ct), At = K$1(Tt), rn = Object.assign(yt, { Button: It, Items: gt, Item: Et, Section: Mt, Heading: St, Separator: At });
const ChevronDownIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M5%207.5L10%2012.5L15%207.5'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LeatherWalletIcon = "data:image/svg+xml,%3csvg%20width='41'%20height='40'%20viewBox='0%200%2041%2040'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3crect%20x='0.5'%20width='40'%20height='40'%20rx='20'%20fill='url(%23pattern0)'/%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_21497_326778'%20transform='translate(-0.00625)%20scale(0.0125)'/%3e%3c/pattern%3e%3cimage%20id='image0_21497_326778'%20width='81'%20height='80'%20xlink:href='data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFEAAABQCAYAAABh05mTAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAi3SURBVHgB7Z1dbBRVFMfPLJVuE1lGFNOENi5v2sbY8kIbEymJtJiYSIVq9AEKrQm+0A+Q+KBpqz5ppIU3Ywvti4kWktaYQFsTi4nZ8sTyQH3TIa0JD0Km2wQWkB3Pf3Zms/Oxu7Mfszvb7i9Zdjt7Zzfz33PuOffcOxeBSowoisEtRG0KUZAo9pJAQjD+mkTtkYzED1lQH0I4RnTHRxR+lh+SLMtUIgQqMkFWbZ3okEKxffz1h8gqVK6EfSQs8vPsv7K8SEWkKCJqwrURKX2K+uw6kkDKokC+qWII6qqIEC9CsT7+mn4qnMVlCwsqjNyT5UlyCVdE9Ih4ZlwTs+Ai7hADEG+YvCOeGYg5wGLOUIEomIg7RbHpKSmX+GUTlQHcZ04+Q76Ru7IsUZ4URETN+sao/JA4oh/PN/hsoTxA37fFX32VBTxJ5YnI2UJ3jb+aHkYfXaccydkSazlJfkzKbxRPjMseFmJmG1tlLkl7TiJq/R8E9GrwyJXwVhI6s+0nsxZxAwuoI7GQ+7MRMisRN4GAOlKAhGanru0jh6AP3CQCgmCErxWB00ljR9E5KYjU0uahlq+5lqP2bKaGjkTc6q+GgC/TpkNoqvHXrD2MRpfStcrozpxID1GZjELcQRl9QRTb0rVIG1i0QHKTKqQNNGnd2e+vDtHmCCSZEJ+Q4n8QfTRn92ZKd9bcOEgVVGJc1kvl1rburEXjv6mCARZr8Z68tt983NYSnxANUQULmNqws0aLJVasMD121mixxIoVpsfOGg2WWI5W2NrSQu3tb9LBjnaqq6tTj4WWlmj68hWanr5CbmC2RoOIz4titxIv8XueQCBA5779mjra21O2mb58mQZPnyU34Gi9W9YqPYY8kSu8ENDz42NY3M8zV2hPc3Pado0NDRSJROjmzTAVGp7swnBwMf5ao5SuPDT0OR1sP2A41vHW26oAZiDg9I8/JFw3E/iMxlddGbVK9+W13XiRCCyPiQ5RCYBb9p44roqiP0JLN2wFBHBhOwHRD45PXKLV1VXL59fXOxM8S1ApU3+dKv0ITyG+o1DxaW3Zazk2N79g27an54QaSJKB2L0fnVRFBMvLyyz0N1QMfPElMWHVEllRsUhrZCw0cL9lZnVl1XIM1td7otty/L33P0wICAKB7ZY2a2v2Vp0vMDw8qyJWlbDUZeeakXXrRQ/2n7K0HRn5km6z5SV/Vm9Pt6EN3DtV15AviqabKmLMY/XCul1WYVtbjW4MccYvGrOx4aHPLEKPT0ySi8CJg6qIHKL3UYlYXv7Tcqyr613j30cOW8Q5N3Yh8RrvXbv6iyVnhNDIFd2Ec8QmLTorJasZLie5o07XkSPUwxE78XfXYcP7qjjTcXEQbOZYwEabvhUBxy1X1sGqXjXZrvH7h6lExVcI0tq6l+pNltbWto9Tk13xFIiFSmaFz9n54k6a+P47tr4DVF1dbflcjFQWr+e8MiQLlLtqsr1D3F6K7CYB0pafOIEuBOaUx20UEma3oGdkJT+lEgJrXI+ss/W9QfkA4Y4ePW6I2G7jI+GuEI8u3qjcIDDYRdhMQLzR0QtFsz4TkqdE1EFgGRw4lVZMWO+1uQWa59FNicTT8aaIOoP9fTQw0Gc8duYTmmPx3I66WSBVkYdpaHzF8DeEc6vQmgey4wVNpcBcbAiFbpDX4LqiXIXqLKc4VEyQE7Zw9Ubv89C/ra7+Y+jbICByxGTmFhbIi+juLFERJuohzAAHDLOF6UDMc2Pn1T6v3VSkBUuhkgaQVNzSk22st3G1CIEAgUDhBL2wmhydkfsd5Gq39xBGtD5RuEUuggKCUwGBXuFOJuTACmHhK3f+MjxSWX2hYCsM6+6MmZxj5BKDA1YBEWkxDQDq6nbZFhCSmZ//lbzIUz3FwT3DMXIHWILZqlCBGf7iK0OuhzawVnPFRsdJXmhXJXc5n+S4LMenB/6LW6IrtNjMoUxcnLRcHPpBNZFOMb+CAkWHTbBJxlzVBm6Oo3HjOp5VESEnZvXJBSJcWDBjJyzSGUydphIK749z6QuzffU2w0EELks/6vJwkEtf6nruxLzzDlEc5sMFX4eTqsyFC0TyHAhso8bGhqwDAM6/fTtuZanOHzxzNlG8dYMYCc1w54SIbo6hQ3/8nnVlRj2Phco1uqrF3tfzK61lwDp5j5GLWy6dy3qY0dHz6nQohDBPyGcC7XGum3B/mLg1w7QWpwbKtlGBwUVhQmrPnibLUM4MrO80i45VXQABaOLiJXVY2MgFiUznI5CgMLuSpfDZwq78QTQaVRfCG1aFocqtubQr8y1waSyBw1I45IUQBCLhgtE/OqkNotaI2UD9fIAfCTknKjzFqC2yFS7ek2X7pXWAA8wYdg2hCilhETuTtz+wiOjlIq1HSAQUHUs9Mb5wUZiiCrZgRxPrMRs0a0Rlp3IjkBGLFQLbO6oQdThS11CJVop5FSTXekROxpf6BMLuIhJVUGE3Pi+nuBs/pYgYT2O7E6oAJC55Dad6M+0Nkg+iUYnd+jl+6W5l0+OwG++X0+wJkXG2774s97s1HCwPhBEUGdK1cDRl+jTu1hJtMtAPshENZ27nkE2Y9oQ1N864I4njyXv0CfhQvKSND66104mAIOvNhXDvhm+Dby6UKZCYyXoZCTpZzSIl2niEsxUQ5LQWZyMKyUFkKhcBQc5b/2H4U+2vmfXFV04EqawRRpDK8TVFKQfy2j8RQj6MPprihBx9axuVH9iEsjPffWZz2vrPDi0FKpv9FJEDYijnNAKn/6wCw5Xxfq0yHiRvgk3NBwq5/3Ze7mwH9tVCX8m/NMbcXrrdTd3VmOuBH6MmQAWk4JaYjHbfGywTd2MGqQQI8a30p8pus3I7sL8Ei3msSLcEy5ji4B9wpuy3zbdD/18vYmydQkHTI3Vx0fViCWf4ZioxmqhNivpQXvOp2zYLQe2mTdPQUpDwL7cLC6SwtfluYVkgVrUVIsrmyv91DJTKn0hYjQAAAABJRU5ErkJggg=='/%3e%3c/defs%3e%3c/svg%3e", LogoutIcon = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M7.5%2017.5H4.16667C3.72464%2017.5%203.30072%2017.3244%202.98816%2017.0118C2.67559%2016.6993%202.5%2016.2754%202.5%2015.8333V4.16667C2.5%203.72464%202.67559%203.30072%202.98816%202.98816C3.30072%202.67559%203.72464%202.5%204.16667%202.5H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M13.333%2014.1667L17.4997%2010L13.333%205.83337'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M17.5%2010H7.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", MagicEdenWalletIcon = "data:image/svg+xml,%3csvg%20width='25'%20height='24'%20viewBox='0%200%2025%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20x='0.423462'%20width='24'%20height='24'%20rx='12'%20fill='%231C1326'/%3e%3cpath%20d='M15.6787%209.69931L16.5929%2010.7735C16.6976%2010.8942%2016.7904%2010.9934%2016.8279%2011.0499C17.1013%2011.3216%2017.2546%2011.6889%2017.2544%2012.0716C17.2288%2012.523%2016.9345%2012.8305%2016.662%2013.1594L16.0222%2013.9106L15.6885%2014.2998C15.6765%2014.3132%2015.6688%2014.3298%2015.6663%2014.3475C15.6638%2014.3652%2015.6666%2014.3832%2015.6743%2014.3993C15.6821%2014.4155%2015.6945%2014.429%2015.71%2014.4383C15.7255%2014.4476%2015.7434%2014.4522%2015.7616%2014.4515H19.0968C19.6062%2014.4515%2020.248%2014.8797%2020.2105%2015.5297C20.2095%2015.8251%2020.0899%2016.1081%2019.8779%2016.317C19.6659%2016.5259%2019.3788%2016.6437%2019.079%2016.6447H13.856C13.5124%2016.6447%2012.5883%2016.6817%2012.3296%2015.8936C12.2746%2015.7289%2012.2671%2015.5524%2012.3079%2015.3837C12.3831%2015.1343%2012.502%2014.8998%2012.6594%2014.6909C12.922%2014.3017%2013.2064%2013.9125%2013.4868%2013.535C13.8481%2013.0407%2014.2194%2012.5619%2014.5847%2012.0579C14.5977%2012.0415%2014.6047%2012.0213%2014.6047%2012.0005C14.6047%2011.9797%2014.5977%2011.9595%2014.5847%2011.9431L13.2577%2010.3863C13.2491%2010.375%2013.2379%2010.3658%2013.225%2010.3595C13.2122%2010.3532%2013.198%2010.3499%2013.1836%2010.3499C13.1693%2010.3499%2013.1551%2010.3532%2013.1423%2010.3595C13.1295%2010.3658%2013.1182%2010.375%2013.1096%2010.3863C12.7542%2010.8591%2011.1982%2012.9531%2010.8664%2013.3773C10.5346%2013.8016%209.71714%2013.8249%209.26493%2013.3773L7.18959%2011.3243C7.17633%2011.3112%207.1594%2011.3022%207.14103%2011.2986C7.12261%2011.295%207.10348%2011.2968%207.08614%2011.3039C7.06879%2011.311%207.05398%2011.323%207.04358%2011.3384C7.03317%2011.3538%207.02764%2011.3719%207.02768%2011.3904V15.3389C7.03256%2015.6192%206.94837%2015.8938%206.78689%2016.1245C6.6254%2016.3552%206.39473%2016.5303%206.12722%2016.6253C5.95626%2016.6839%205.77359%2016.7014%205.59439%2016.6763C5.41518%2016.6513%205.24465%2016.5843%205.09704%2016.4811C4.94943%2016.3779%204.82898%2016.2414%204.74575%2016.083C4.66252%2015.9246%204.61892%2015.7489%204.61859%2015.5705V8.47138C4.63049%208.21553%204.7239%207.96991%204.88554%207.76938C5.04719%207.56885%205.26884%207.42363%205.51901%207.35435C5.73365%207.298%205.95954%207.29856%206.17386%207.35599C6.38817%207.41341%206.58326%207.52563%206.73936%207.6813L9.93042%2010.83C9.93998%2010.8395%209.95151%2010.8469%209.96431%2010.8516C9.97706%2010.8562%209.9907%2010.8581%2010.0043%2010.857C10.0178%2010.8559%2010.031%2010.8518%2010.0428%2010.8451C10.0546%2010.8385%2010.0648%2010.8293%2010.0726%2010.8183L12.3395%207.72606C12.4442%207.60053%2012.5756%207.49905%2012.7243%207.42883C12.873%207.35856%2013.0355%207.32121%2013.2005%207.31933H19.0968C19.2581%207.31956%2019.4176%207.35378%2019.5644%207.41969C19.7113%207.48555%2019.8422%207.5816%2019.9484%207.70131C20.0546%207.82108%2020.1336%207.9618%2020.1802%208.11405C20.2267%208.2663%2020.2397%208.42661%2020.2184%208.58425C20.1768%208.85767%2020.0361%209.107%2019.8222%209.28592C19.6083%209.46485%2019.3358%209.56127%2019.0553%209.55728H15.7537C15.7371%209.55766%2015.7209%209.56244%2015.7068%209.57111C15.6928%209.57974%2015.6813%209.59197%2015.6736%209.60645C15.666%209.62099%2015.6624%209.63725%2015.6632%209.65356C15.6641%209.66992%2015.6695%209.68572%2015.6787%209.69931Z'%20fill='url(%23paint0_radial_6204_5907)'/%3e%3cdefs%3e%3cradialGradient%20id='paint0_radial_6204_5907'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(4.66396%207.31249)%20rotate(31.8526)%20scale(18.4306%2015.0426)'%3e%3cstop%20stop-color='%237500EB'/%3e%3cstop%20offset='0.48642'%20stop-color='%23E42575'/%3e%3cstop%20offset='0.791667'%20stop-color='%23E42575'/%3e%3cstop%20offset='1'%20stop-color='%23FF6914'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", OKXWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cg%20clip-path='url(%23clip0_6327_5988)'%3e%3crect%20width='24'%20height='24'%20rx='12'%20fill='black'/%3e%3crect%20x='5.37042'%20y='5.10571'%20width='14.1245'%20height='14.3972'%20fill='url(%23pattern0)'/%3e%3c/g%3e%3cdefs%3e%3cpattern%20id='pattern0'%20patternContentUnits='objectBoundingBox'%20width='1'%20height='1'%3e%3cuse%20xlink:href='%23image0_6327_5988'%20transform='matrix(0.00331001%200%200%200.00324732%20-0.161%20-0.168981)'/%3e%3c/pattern%3e%3cclipPath%20id='clip0_6327_5988'%3e%3crect%20width='24'%20height='24'%20fill='white'/%3e%3c/clipPath%3e%3cimage%20id='image0_6327_5988'%20width='399'%20height='399'%20xlink:href='data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/4gKgSUNDX1BST0ZJTEUAAQEAAAKQbGNtcwQwAABtbnRyUkdCIFhZWiAAAAAAAAAAAAAAAABhY3NwQVBQTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWxjbXMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAADhjcHJ0AAABQAAAAE53dHB0AAABkAAAABRjaGFkAAABpAAAACxyWFlaAAAB0AAAABRiWFlaAAAB5AAAABRnWFlaAAAB+AAAABRyVFJDAAACDAAAACBnVFJDAAACLAAAACBiVFJDAAACTAAAACBjaHJtAAACbAAAACRtbHVjAAAAAAAAAAEAAAAMZW5VUwAAABwAAAAcAHMAUgBHAEIAIABiAHUAaQBsAHQALQBpAG4AAG1sdWMAAAAAAAAAAQAAAAxlblVTAAAAMgAAABwATgBvACAAYwBvAHAAeQByAGkAZwBoAHQALAAgAHUAcwBlACAAZgByAGUAZQBsAHkAAAAAWFlaIAAAAAAAAPbWAAEAAAAA0y1zZjMyAAAAAAABDEoAAAXj///zKgAAB5sAAP2H///7ov///aMAAAPYAADAlFhZWiAAAAAAAABvlAAAOO4AAAOQWFlaIAAAAAAAACSdAAAPgwAAtr5YWVogAAAAAAAAYqUAALeQAAAY3nBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbcGFyYQAAAAAAAwAAAAJmZgAA8qcAAA1ZAAAT0AAACltwYXJhAAAAAAADAAAAAmZmAADypwAADVkAABPQAAAKW2Nocm0AAAAAAAMAAAAAo9cAAFR7AABMzQAAmZoAACZmAAAPXP/bAEMABQMEBAQDBQQEBAUFBQYHDAgHBwcHDwsLCQwRDxISEQ8RERMWHBcTFBoVEREYIRgaHR0fHx8TFyIkIh4kHB4fHv/bAEMBBQUFBwYHDggIDh4UERQeHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHv/CABEIAY8BjwMBIgACEQEDEQH/xAAbAAEBAQEBAQEBAAAAAAAAAAAACAYHBQECBP/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAeMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAf2K5JLV2JEV2JEV2JE+V4IzbnDAAAA2Jnf1XYkRXYkRXYkRXYkD+KxpMPMAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyJXYAAABO/O+ic7AAAG6wu6KSAAAAk2spNPFAAAAAAAAAB6NdyHXgAAABO/O+hc9AAAG6wu5KTAAAAk2spMPGAAAAAAAAAA3OGHRHOx0RzsdEc7HRPnPB1TauhnPHQxzx0Mc8dDHPMd3TDHLf3zsdEc7HRHOx0RzsbvDfkAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAAAAAAAUT0PnnQwAABhtzhibAAAAAAAAAAAAAAADYGPboYVuhhW6GFbr4dQ6Hwvdm5YYblhhuWGG5wzEnIm4/RhW6GFboYVuhhWyxoAAAAAAAAAB/fXsiV2AAAATpz7onOwAABuMPuikgAAAJLrSTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAejXciV2AAAATvzvonOwAABusLuikgAAAJNrKTTxQAAAAAAAAAf21zHPqFcJNFZJNFZJNFZJN+Gjwf34AAANljRZiS/0Vkk0Vkk0Vkk0VdJjygAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/8QAJRAAAAMIAwEBAQEAAAAAAAAAAAUwAQIDBAYWNTYHFEAVUIAR/9oACAEBAAEFAv7/AIUtMRXelOjpTo6U6OlOjpTo6U6OlOh6Tm3WJOyk0870p0dKdHSnR0p0dKdHSnR0p0RZaZhO+WUhsizcGE5BhIVtLwpc+QpCBCmD9CI45EcNITsAy8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+Qvax2fRr5rG1AhQ7WMqNE7ax458spVBvLwLwOBeBwLwOBeBwLwOBeBwLwOA2rzj/KaJGHbLPJxZ5OLPJxZ5OLPJxZ5OLPJxZ5OKlIHCiC5Vxwx28DgXgcC8DgXgcC8DgXgcC8DgTFVG8aF7+P9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/yOP9fQrrW/fK04bzMG1DsWodi1DsWodi1DsWodi1DsNpU6YylTuEUOXWSC6yQXWSC6yQXWSC6yQXWSC6yQVSfwDKVdpY7ay1DsWodi1DsWodi1DsWodi1DsTFNHMCF5ZB1j88jXzrGVAhRDrHqjROXWOHHkLcijyBsCFC7Iie5vyFuRR5A2BChdkRPc35C3Io8gbAhQuyInub8hbkUeQNgQoXZET3N+QtyKPIGwIULsiJ7m/IW5FHkDYEKF2RE9zfkLcijyBsCFC7Iie5vySb7IU5DfciOIVxGhxj9Cjo0OBUKDWsdYaxHYxp5YM/PQHPrGg+saD6xoPrGg+saD6xoPrGgeNDJ5iThmZOu/WNB9Y0H1jQfWNB9Y0H1jQfWNBGMJ+ND/v8A/8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAwEBPwEcf//EABQRAQAAAAAAAAAAAAAAAAAAAJD/2gAIAQIBAT8BHH//xAA5EAABAQUDCQcCBQUAAAAAAAACAQADBDCTETSyNUBEcnN0g5KxBRITITFQUUFhFDJxkaFCY4CBkP/aAAgBAQAGPwL/AD/tduHpp8iKq10iKatdIimrXSIpq10iKatdIimrXSIpq10iKat3ihX6Js1loQwr5UX0VAVrpEU1a6RFNWukRTVrpEU1a6RFNWukRTVrpEU1bvPHD0B+SBUzZy6L0M0FWF06FAAUsRE+kl4jkEBDFDVE+ZMOD4UIUtKxfsklQMUISSxUX6tFOHf5Hb4hT/S5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw6qtiI9HrKWxfR0NsmHtX1QsMqNJPRYg8S5sLlHoPEHyRTG1W0fkbR+RtH5G0fkbR+RtH5G0fkb1cJw2e9odovnhIp2eS+ZL8tpHO2kc7aRztpHO2kc7aRztpHO2kc7B2j2c+eD4Zpair5p90ZEUnJfdXbaPyNo/I2j8jaPyNo/I2j8jaPyMTvxQd976gNi+wcUpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxe08UpL/WHF7TxSkv9YcXtPFKS/1hxe08UpL/AFhxewI9CEsEvTvEiNdwqC13CoLXcKgtdwqC13CoLXcKgtdwqC1v4YV4gs97O7RA3dhqqLZ6L8KjXg6ZNeDpk14OmTXg6ZNeDpk14OmTXg6ZNeDpkw9n9ngb3xCS1e7/AAjW/hRT9XgtdwqC13CoLXcKgtdwqC13CoLXcKgtdwqCxPChbRHzXukirmzgS80V4KL+8olRLLXYqsmHtS2xCX+JUaApYiRBonNmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5rDbUesrhDJcapYZUfvLzEuaw21HrK4QyXGqWGVH7y8xLmsNtR6yuEMlxqlhlR+8vMS5q5eF6AaEv7shgSEJJaip9ZLzwyQu4CAtnzJhyekgito2r90kqqrYiNFvna2gb4yH9FXNu45jYh0PwD1URspRlcmylGVybKUZXJspRlcmylGVybKUZXJspRlcmsLtGLVF/vFLQQ7QixFPREfE2UoyuTZSjK5NlKMrk2UoyuTZSjK5NlKMrk2UoyuTeG+jol4K/wBJPVVP+AH/xAAoEAABAgUDBAIDAQAAAAAAAAABAPARMFFxwSFAYTFBUKGBsYCR0ZD/2gAIAQEAAT8h/P8A4J2T0nVhOrCdWE6sJ1YTqwnVhEoL6kgA9S9fFxED6TqwnVhOrCdWE6sJ1YTqwuEdA9jbRoBAyhMFC+2bQJIclZQALr9Rk6bVK0JIRH5kwD3GiAPYoPBFlygbVzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwHOiU6vJYat/Ac6JTq8lhq38BzolOryWGrfwBHCEmmiUMQEiBQ6mSNoEGLxSimxIg7YGgrRYL9/lczbrmbdczbrmbdczbrmbdczbowgDT0I6P2UWbMNLqCRprCC4m2XE2y4m2XE2y4m2XE2y4m2XE2y6tWBFjoS8NOUVDDlH9LmbdczbrmbdczbrmbdczbrmbdQuIIHQvB7I6mJ37q0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPEurSXGjxLq0lxo8S6tJcaPAFnDRj0isCYp1ZTqynVlOrKdWU6sp1ZR5onYf2QiPHWTpA9R2TqwnVhOrCdWE6sJ1YTqwnVhFzcVkIwOgOpMUNaj2ivtOrKdWU6sp1ZTqynVlOrKhN5o6FgYn42wJoOKghKBzI5Hc6j6AkwooGiOhjlDhBpQAtq50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4DnRKdXksNW/gOdEp1eSw1b+A50SnV5LDVv4EeP4sAFRD3GiAPcSYbaa6hB1HuTTmpESAe5IywESSYABR8BqpJG2FRr/ACYFNzKbmU3MpuZTcym5lNzKJes4Ew+5egkAAA9puZTcym5lNzKbmU3MpuZRl1HFb4J/wA//2gAMAwEAAgADAAAAEPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPNPPPPNPPPOPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPHPPPOPPPPPPPPPPPPPPPLDDDDHPPPOLDDDLPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPPPPPPPPPKPPPPPPPPPPPPPPPPMMMNOMMMJMMMMPPPPPPPPPPPPPPPPNPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPPPPPPFPPPPPPPPPPPPPPPPPPPGPPPPNPPPPPPPPJPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP/xAAUEQEAAAAAAAAAAAAAAAAAAACQ/9oACAEDAQE/EBx//8QAFBEBAAAAAAAAAAAAAAAAAAAAkP/aAAgBAgEBPxAcf//EACYQAQABAwQBBQEBAQEAAAAAAAERACExMFDw8UFAUWFxgZGhgJD/2gAIAQEAAT8Q/wC/7iwi5HtITQrVq1atWrCYGTo91YGmFR4LPuJBNCtWrVq1ashDEGcXFwPTMgkmUNR+NBDFHgkAGjGQMElGBYlk+V0Z5/JGGs5ADHmL2oAINBHwCRqEGyJkowgOspMT9B689m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m533LVRHs3O+5aqI9m532jVRKGE+AMr9aRbEZ5iB/Ef3REhc/ylj/ADSBSf8AhFB/npgQrBGWBKMPeT812GvYa9hr2GvYa9hr2Gpvwi7fIkP6NGdVgHBWMCAAY8AD0GvQa9Br0GvQa9Br0GvQaoA4tpWaDaBQ+Uxag7pCD7WQfwrsNew17DXsNew17DXsNVC+nwRDKqvkhPCUlElbq+vxc7blW4udtyrcXO25VuLnbcq3FztuVbi523Ktxc7blW4udtprQPDZ/YhgPiQnJbQq1atWrVqnZQW6PwSalFaSYDLLyEHLNodGrVq1atWrVYBaqOR+8hLB7EzZWRExA+wcaFWrVq1atUQqIDAlRkHwX0xHUpwCT9KACDROYeHikfmB+aPkbIkEb9njSCi7bBED6D157NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvuWqiPZud9y1UR7NzvtGqigkRZmQf4UD4BI1IhZEw6MktLQEshaSx9kTJowshWgFKuJQfbotXweCJVWwBlr5etjM/RPTY2XGH0I86AMGDBgwYMKoQ8D2Ri0qsukbFYO/sAQNAGDBgwYMH/q6K5SP8/8AP/Z'/%3e%3c/defs%3e%3c/svg%3e", UnisatWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M14.8742%204.5804L18.5392%208.15088C18.8511%208.45416%2019.0047%208.76103%2018.9999%209.07026C18.995%209.3795%2018.8608%209.66136%2018.5984%209.91707C18.3239%2010.1847%2018.0277%2010.3203%2017.7109%2010.3262C17.3941%2010.331%2017.0797%2010.1811%2016.7677%209.87785L13.0193%206.22648C12.5937%205.8114%2012.1825%205.51762%2011.7872%205.34516C11.3917%205.1727%2010.9758%205.14535%2010.5405%205.26428C10.104%205.38203%209.63603%205.68532%209.13422%206.17295C8.44258%206.84733%208.11246%207.48007%208.14634%208.0712C8.18018%208.6623%208.52358%209.27602%209.17534%209.90996L12.954%2013.5922C13.2696%2013.8991%2013.4244%2014.2059%2013.4195%2014.5104C13.4147%2014.8161%2013.2793%2015.098%2013.012%2015.3584C12.746%2015.6177%2012.4522%2015.7533%2012.133%2015.764C11.8137%2015.7747%2011.4957%2015.6261%2011.1813%2015.3192L7.51634%2011.7487C6.92022%2011.1683%206.48975%2010.6188%206.22495%2010.1002C5.96014%209.58168%205.86099%208.99533%205.92991%208.34118C5.99158%207.78099%206.17416%207.23864%206.47887%206.71294C6.78237%206.18723%207.21768%205.64964%207.78237%205.09896C8.45466%204.44362%209.09673%203.94171%209.70858%203.59203C10.3192%203.24236%2010.9105%203.04849%2011.4812%203.00806C12.0532%202.96762%2012.6166%203.07942%2013.1741%203.34346C13.7315%203.6075%2014.2974%204.01902%2014.873%204.5804H14.8742Z'%20fill='url(%23paint0_linear_4212_6487)'/%3e%3cpath%20d='M9.12459%2018.9872L5.46081%2015.4167C5.14884%2015.1122%204.99527%2014.8066%205.00011%2014.4973C5.00495%2014.1881%205.13917%2013.9062%205.40156%2013.6505C5.67604%2013.3829%205.97229%2013.2473%206.28909%2013.2414C6.60589%2013.2366%206.92028%2013.3853%207.23225%2013.6897L10.9795%2017.3411C11.4063%2017.7562%2011.8162%2018.05%2012.2116%2018.2224C12.607%2018.3949%2013.023%2018.421%2013.4595%2018.3033C13.896%2018.1856%2014.3639%2017.8823%2014.8657%2017.3934C15.5574%2016.7191%2015.8875%2016.0863%2015.8537%2015.4952C15.8198%2014.9041%2015.4764%2014.2904%2014.8247%2013.6553L12.8114%2011.7106C12.4958%2011.4038%2012.341%2011.0969%2012.3458%2010.7925C12.3507%2010.4868%2012.4861%2010.2049%2012.7533%209.94445C13.0194%209.68514%2013.3132%209.54957%2013.6324%209.53887C13.9516%209.52816%2014.2696%209.67682%2014.584%209.9837L16.4824%2011.8165C17.0785%2012.3969%2017.509%2012.9464%2017.7738%2013.465C18.0386%2013.9835%2018.1378%2014.5699%2018.0688%2015.224C18.0072%2015.7842%2017.8246%2016.3266%2017.5199%2016.8523C17.2164%2017.378%2016.7811%2017.9156%2016.2164%2018.4663C15.5441%2019.1216%2014.902%2019.6235%2014.2902%2019.9732C13.6783%2020.3229%2013.0871%2020.5179%2012.5151%2020.5583C11.9432%2020.5988%2011.3797%2020.487%2010.8223%2020.2229C10.2648%2019.9589%209.69894%2019.5474%209.12338%2018.986L9.12459%2018.9872Z'%20fill='url(%23paint1_linear_4212_6487)'/%3e%3cpath%20d='M11.4098%209.77448C12.153%209.77448%2012.7556%209.18182%2012.7556%208.4507C12.7556%207.71962%2012.153%207.12695%2011.4098%207.12695C10.6665%207.12695%2010.064%207.71962%2010.064%208.4507C10.064%209.18182%2010.6665%209.77448%2011.4098%209.77448Z'%20fill='url(%23paint2_radial_4212_6487)'/%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_4212_6487'%20x1='17.9364'%20y1='6.66057'%20x2='6.64095'%20y2='11.7639'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%23201C1B'/%3e%3cstop%20offset='0.36'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4B852'/%3e%3c/linearGradient%3e%3clinearGradient%20id='paint1_linear_4212_6487'%20x1='6.3763'%20y1='17.0541'%20x2='19.5023'%20y2='13.0825'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20stop-color='%231F1D1C'/%3e%3cstop%20offset='0.37'%20stop-color='%2377390D'/%3e%3cstop%20offset='0.67'%20stop-color='%23EA8101'/%3e%3cstop%20offset='1'%20stop-color='%23F4FB52'/%3e%3c/linearGradient%3e%3cradialGradient%20id='paint2_radial_4212_6487'%20cx='0'%20cy='0'%20r='1'%20gradientUnits='userSpaceOnUse'%20gradientTransform='translate(11.4098%208.45191)%20scale(1.34581%201.32377)'%3e%3cstop%20stop-color='%23F4B852'/%3e%3cstop%20offset='0.33'%20stop-color='%23EA8101'/%3e%3cstop%20offset='0.64'%20stop-color='%2377390D'/%3e%3cstop%20offset='1'%20stop-color='%23211C1D'/%3e%3c/radialGradient%3e%3c/defs%3e%3c/svg%3e", XverseWalletIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M19.4283%2019.185V16.4677C19.4283%2016.36%2019.3855%2016.2572%2019.3092%2016.1809L7.74741%204.61916C7.67106%204.54281%207.56829%204.5%207.46055%204.5H4.74332C4.60917%204.5%204.5%204.60917%204.5%204.74332V7.26787C4.5%207.37562%204.54281%207.47837%204.61916%207.55472L8.76923%2011.7047C8.86412%2011.7997%208.86412%2011.9538%208.76923%2012.0487L4.57136%2016.2465C4.52569%2016.2922%204.5%2016.3543%204.5%2016.4185V19.185C4.5%2019.319%204.60917%2019.4283%204.74332%2019.4283H9.28369C9.41784%2019.4283%209.527%2019.319%209.527%2019.185V17.5552C9.527%2017.491%209.55271%2017.4289%209.59838%2017.3832L11.8504%2015.1312C11.9453%2015.0363%2012.0994%2015.0363%2012.1943%2015.1312L16.3729%2019.3099C16.4492%2019.3862%2016.552%2019.429%2016.6597%2019.429H19.1843C19.3185%2019.429%2019.4276%2019.3198%2019.4276%2019.1857L19.4283%2019.185Z'%20fill='white'/%3e%3cpath%20d='M13.372%208.09816H15.6461C15.781%208.09816%2015.8909%208.20805%2015.8909%208.34292V10.617C15.8909%2010.8353%2016.1549%2010.9445%2016.309%2010.7897L19.4287%207.66505C19.4743%207.61937%2019.5001%207.5573%2019.5001%207.49236V4.75588C19.5001%204.62102%2019.3908%204.51114%2019.2553%204.51114L16.4781%204.50757C16.4132%204.50757%2016.3511%204.53326%2016.3047%204.57892L13.1986%207.68003C13.0445%207.83415%2013.1537%208.09816%2013.3713%208.09816H13.372Z'%20fill='%23EE7A30'/%3e%3c/svg%3e";
function truncateMiddle(B, z = 4, Y = 5) {
  if (B.length <= z + Y)
    return B;
  const ie = B.slice(0, z), se = B.slice(B.length - Y);
  return `${ie}...${se}`;
}
const WALLET_TO_ICON = {
  [Wallet.MAGICEDEN]: MagicEdenWalletIcon,
  [Wallet.UNISAT]: UnisatWalletIcon,
  [Wallet.XVERSE]: XverseWalletIcon,
  [Wallet.LEATHER]: LeatherWalletIcon,
  [Wallet.OKX]: OKXWalletIcon
}, NETWORK_DISPLAY_NAME = {
  [Network.MAINNET]: "Mainnet",
  [Network.TESTNET]: "Testnet",
  [Network.SIGNET]: "Signet"
};
function PostConnectButton({
  address: B,
  network: z,
  onViewProfile: Y,
  onChangeWallet: ie,
  onDisconnectWallet: se,
  renderAvatar: ne
}) {
  const { wallet: ae } = useOrdConnect();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    rn,
    {
      as: "section",
      className: "ord-connect-font ord-wallet-connected-container relative inline-block text-left",
      children: ({ open: le }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Button, { className: "ord-wallet-connected-button", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-identifier-container", children: [
            ne ? ne(B, "large") : /* @__PURE__ */ jsxRuntimeExports.jsx(
              Avatar,
              {
                size: 28,
                variant: "beam",
                name: B,
                colors: ["#1C2DCB", "#F226B8"]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: WALLET_TO_ICON[ae],
                alt: `${ae} is connected`
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "address-container", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "address", children: truncateMiddle(B) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "network-container", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "status-indicator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "network", children: NETWORK_DISPLAY_NAME[z] ?? z })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "img",
            {
              src: ChevronDownIcon,
              className: `dropdown-button ${le ? "close-dropdown-button" : "expand-dropdown-button"}`,
              alt: ""
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1,
          {
            as: Fragment,
            enter: "transition ease-out duration-100",
            enterFrom: "transform opacity-0 scale-95",
            enterTo: "transform opacity-100 scale-100",
            leave: "transition ease-in duration-75",
            leaveFrom: "transform opacity-100 scale-100",
            leaveTo: "transform opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(rn.Items, { className: "ord-wallet-connection-dropdown", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => Y == null ? void 0 : Y(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "View profile" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "value", children: truncateMiddle(B) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => ie == null ? void 0 : ie(),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "change-wallet-label", children: "Change wallet" })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                rn.Item,
                {
                  as: "button",
                  className: "dropdown-button",
                  onClick: () => se == null ? void 0 : se(),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: "Disconnect wallet" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: LogoutIcon, className: "logout-icon", alt: "" })
                  ]
                }
              )
            ] })
          }
        )
      ] })
    }
  );
}
function PreConnectButton({
  openModal: B,
  disabled: z
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      onClick: B,
      disabled: z,
      "data-testid": "connect-wallet-button",
      className: "ord-connect-font ord-connect-wallet-button",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {})
    }
  );
}
const CloseModalIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M12%2022C17.5228%2022%2022%2017.5228%2022%2012C22%206.47715%2017.5228%202%2012%202C6.47715%202%202%206.47715%202%2012C2%2017.5228%206.47715%2022%2012%2022Z'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M15%209L9%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3cpath%20d='M9%209L15%2015'%20stroke='%23F2F2F2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function isMobileUserAgent() {
  return typeof window > "u" ? !1 : /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
    window.navigator.userAgent
  );
}
var buffer$1 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength$1;
base64Js$1.toByteArray = toByteArray$1;
base64Js$1.fromByteArray = fromByteArray$1;
var lookup$1 = [], revLookup$1 = [], Arr$1 = typeof Uint8Array < "u" ? Uint8Array : Array, code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len$1 = code$1.length; i$2 < len$1; ++i$2)
  lookup$1[i$2] = code$1[i$2], revLookup$1[code$1.charCodeAt(i$2)] = i$2;
revLookup$1[45] = 62;
revLookup$1[95] = 63;
function getLens$1(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ie = Y === z ? 0 : 4 - Y % 4;
  return [Y, ie];
}
function byteLength$1(B) {
  var z = getLens$1(B), Y = z[0], ie = z[1];
  return (Y + ie) * 3 / 4 - ie;
}
function _byteLength$1(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray$1(B) {
  var z, Y = getLens$1(B), ie = Y[0], se = Y[1], ne = new Arr$1(_byteLength$1(B, ie, se)), ae = 0, le = se > 0 ? ie - 4 : ie, ge;
  for (ge = 0; ge < le; ge += 4)
    z = revLookup$1[B.charCodeAt(ge)] << 18 | revLookup$1[B.charCodeAt(ge + 1)] << 12 | revLookup$1[B.charCodeAt(ge + 2)] << 6 | revLookup$1[B.charCodeAt(ge + 3)], ne[ae++] = z >> 16 & 255, ne[ae++] = z >> 8 & 255, ne[ae++] = z & 255;
  return se === 2 && (z = revLookup$1[B.charCodeAt(ge)] << 2 | revLookup$1[B.charCodeAt(ge + 1)] >> 4, ne[ae++] = z & 255), se === 1 && (z = revLookup$1[B.charCodeAt(ge)] << 10 | revLookup$1[B.charCodeAt(ge + 1)] << 4 | revLookup$1[B.charCodeAt(ge + 2)] >> 2, ne[ae++] = z >> 8 & 255, ne[ae++] = z & 255), ne;
}
function tripletToBase64$1(B) {
  return lookup$1[B >> 18 & 63] + lookup$1[B >> 12 & 63] + lookup$1[B >> 6 & 63] + lookup$1[B & 63];
}
function encodeChunk$1(B, z, Y) {
  for (var ie, se = [], ne = z; ne < Y; ne += 3)
    ie = (B[ne] << 16 & 16711680) + (B[ne + 1] << 8 & 65280) + (B[ne + 2] & 255), se.push(tripletToBase64$1(ie));
  return se.join("");
}
function fromByteArray$1(B) {
  for (var z, Y = B.length, ie = Y % 3, se = [], ne = 16383, ae = 0, le = Y - ie; ae < le; ae += ne)
    se.push(encodeChunk$1(B, ae, ae + ne > le ? le : ae + ne));
  return ie === 1 ? (z = B[Y - 1], se.push(
    lookup$1[z >> 2] + lookup$1[z << 4 & 63] + "=="
  )) : ie === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], se.push(
    lookup$1[z >> 10] + lookup$1[z >> 4 & 63] + lookup$1[z << 2 & 63] + "="
  )), se.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(B, z, Y, ie, se) {
  var ne, ae, le = se * 8 - ie - 1, ge = (1 << le) - 1, Ee = ge >> 1, oe = -7, Pe = Y ? se - 1 : 0, Ve = Y ? -1 : 1, Ke = B[z + Pe];
  for (Pe += Ve, ne = Ke & (1 << -oe) - 1, Ke >>= -oe, oe += le; oe > 0; ne = ne * 256 + B[z + Pe], Pe += Ve, oe -= 8)
    ;
  for (ae = ne & (1 << -oe) - 1, ne >>= -oe, oe += ie; oe > 0; ae = ae * 256 + B[z + Pe], Pe += Ve, oe -= 8)
    ;
  if (ne === 0)
    ne = 1 - Ee;
  else {
    if (ne === ge)
      return ae ? NaN : (Ke ? -1 : 1) * (1 / 0);
    ae = ae + Math.pow(2, ie), ne = ne - Ee;
  }
  return (Ke ? -1 : 1) * ae * Math.pow(2, ne - ie);
};
ieee754.write = function(B, z, Y, ie, se, ne) {
  var ae, le, ge, Ee = ne * 8 - se - 1, oe = (1 << Ee) - 1, Pe = oe >> 1, Ve = se === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, Ke = ie ? 0 : ne - 1, ht = ie ? 1 : -1, _t = z < 0 || z === 0 && 1 / z < 0 ? 1 : 0;
  for (z = Math.abs(z), isNaN(z) || z === 1 / 0 ? (le = isNaN(z) ? 1 : 0, ae = oe) : (ae = Math.floor(Math.log(z) / Math.LN2), z * (ge = Math.pow(2, -ae)) < 1 && (ae--, ge *= 2), ae + Pe >= 1 ? z += Ve / ge : z += Ve * Math.pow(2, 1 - Pe), z * ge >= 2 && (ae++, ge /= 2), ae + Pe >= oe ? (le = 0, ae = oe) : ae + Pe >= 1 ? (le = (z * ge - 1) * Math.pow(2, se), ae = ae + Pe) : (le = z * Math.pow(2, Pe - 1) * Math.pow(2, se), ae = 0)); se >= 8; B[Y + Ke] = le & 255, Ke += ht, le /= 256, se -= 8)
    ;
  for (ae = ae << se | le, Ee += se; Ee > 0; B[Y + Ke] = ae & 255, Ke += ht, ae /= 256, Ee -= 8)
    ;
  B[Y + Ke - ht] |= _t * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(B) {
  const z = base64Js$1, Y = ieee754, ie = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  B.Buffer = oe, B.SlowBuffer = jt, B.INSPECT_MAX_BYTES = 50;
  const se = 2147483647;
  B.kMaxLength = se;
  const { Uint8Array: ne, ArrayBuffer: ae, SharedArrayBuffer: le } = globalThis;
  oe.TYPED_ARRAY_SUPPORT = ge(), !oe.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function ge() {
    try {
      const Vt = new ne(1), Lt = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(Lt, ne.prototype), Object.setPrototypeOf(Vt, Lt), Vt.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(oe.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (oe.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(oe.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (oe.isBuffer(this))
        return this.byteOffset;
    }
  });
  function Ee(Vt) {
    if (Vt > se)
      throw new RangeError('The value "' + Vt + '" is invalid for option "size"');
    const Lt = new ne(Vt);
    return Object.setPrototypeOf(Lt, oe.prototype), Lt;
  }
  function oe(Vt, Lt, Dt) {
    if (typeof Vt == "number") {
      if (typeof Lt == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return ht(Vt);
    }
    return Pe(Vt, Lt, Dt);
  }
  oe.poolSize = 8192;
  function Pe(Vt, Lt, Dt) {
    if (typeof Vt == "string")
      return _t(Vt, Lt);
    if (ae.isView(Vt))
      return kt(Vt);
    if (Vt == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Vt
      );
    if (Vr(Vt, ae) || Vt && Vr(Vt.buffer, ae) || typeof le < "u" && (Vr(Vt, le) || Vt && Vr(Vt.buffer, le)))
      return Bt(Vt, Lt, Dt);
    if (typeof Vt == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const Qt = Vt.valueOf && Vt.valueOf();
    if (Qt != null && Qt !== Vt)
      return oe.from(Qt, Lt, Dt);
    const fr = Ct(Vt);
    if (fr) return fr;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof Vt[Symbol.toPrimitive] == "function")
      return oe.from(Vt[Symbol.toPrimitive]("string"), Lt, Dt);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof Vt
    );
  }
  oe.from = function(Vt, Lt, Dt) {
    return Pe(Vt, Lt, Dt);
  }, Object.setPrototypeOf(oe.prototype, ne.prototype), Object.setPrototypeOf(oe, ne);
  function Ve(Vt) {
    if (typeof Vt != "number")
      throw new TypeError('"size" argument must be of type number');
    if (Vt < 0)
      throw new RangeError('The value "' + Vt + '" is invalid for option "size"');
  }
  function Ke(Vt, Lt, Dt) {
    return Ve(Vt), Vt <= 0 ? Ee(Vt) : Lt !== void 0 ? typeof Dt == "string" ? Ee(Vt).fill(Lt, Dt) : Ee(Vt).fill(Lt) : Ee(Vt);
  }
  oe.alloc = function(Vt, Lt, Dt) {
    return Ke(Vt, Lt, Dt);
  };
  function ht(Vt) {
    return Ve(Vt), Ee(Vt < 0 ? 0 : qt(Vt) | 0);
  }
  oe.allocUnsafe = function(Vt) {
    return ht(Vt);
  }, oe.allocUnsafeSlow = function(Vt) {
    return ht(Vt);
  };
  function _t(Vt, Lt) {
    if ((typeof Lt != "string" || Lt === "") && (Lt = "utf8"), !oe.isEncoding(Lt))
      throw new TypeError("Unknown encoding: " + Lt);
    const Dt = Ht(Vt, Lt) | 0;
    let Qt = Ee(Dt);
    const fr = Qt.write(Vt, Lt);
    return fr !== Dt && (Qt = Qt.slice(0, fr)), Qt;
  }
  function Rt(Vt) {
    const Lt = Vt.length < 0 ? 0 : qt(Vt.length) | 0, Dt = Ee(Lt);
    for (let Qt = 0; Qt < Lt; Qt += 1)
      Dt[Qt] = Vt[Qt] & 255;
    return Dt;
  }
  function kt(Vt) {
    if (Vr(Vt, ne)) {
      const Lt = new ne(Vt);
      return Bt(Lt.buffer, Lt.byteOffset, Lt.byteLength);
    }
    return Rt(Vt);
  }
  function Bt(Vt, Lt, Dt) {
    if (Lt < 0 || Vt.byteLength < Lt)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (Vt.byteLength < Lt + (Dt || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let Qt;
    return Lt === void 0 && Dt === void 0 ? Qt = new ne(Vt) : Dt === void 0 ? Qt = new ne(Vt, Lt) : Qt = new ne(Vt, Lt, Dt), Object.setPrototypeOf(Qt, oe.prototype), Qt;
  }
  function Ct(Vt) {
    if (oe.isBuffer(Vt)) {
      const Lt = qt(Vt.length) | 0, Dt = Ee(Lt);
      return Dt.length === 0 || Vt.copy(Dt, 0, 0, Lt), Dt;
    }
    if (Vt.length !== void 0)
      return typeof Vt.length != "number" || jr(Vt.length) ? Ee(0) : Rt(Vt);
    if (Vt.type === "Buffer" && Array.isArray(Vt.data))
      return Rt(Vt.data);
  }
  function qt(Vt) {
    if (Vt >= se)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + se.toString(16) + " bytes");
    return Vt | 0;
  }
  function jt(Vt) {
    return +Vt != Vt && (Vt = 0), oe.alloc(+Vt);
  }
  oe.isBuffer = function(Lt) {
    return Lt != null && Lt._isBuffer === !0 && Lt !== oe.prototype;
  }, oe.compare = function(Lt, Dt) {
    if (Vr(Lt, ne) && (Lt = oe.from(Lt, Lt.offset, Lt.byteLength)), Vr(Dt, ne) && (Dt = oe.from(Dt, Dt.offset, Dt.byteLength)), !oe.isBuffer(Lt) || !oe.isBuffer(Dt))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (Lt === Dt) return 0;
    let Qt = Lt.length, fr = Dt.length;
    for (let cr = 0, lr = Math.min(Qt, fr); cr < lr; ++cr)
      if (Lt[cr] !== Dt[cr]) {
        Qt = Lt[cr], fr = Dt[cr];
        break;
      }
    return Qt < fr ? -1 : fr < Qt ? 1 : 0;
  }, oe.isEncoding = function(Lt) {
    switch (String(Lt).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, oe.concat = function(Lt, Dt) {
    if (!Array.isArray(Lt))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (Lt.length === 0)
      return oe.alloc(0);
    let Qt;
    if (Dt === void 0)
      for (Dt = 0, Qt = 0; Qt < Lt.length; ++Qt)
        Dt += Lt[Qt].length;
    const fr = oe.allocUnsafe(Dt);
    let cr = 0;
    for (Qt = 0; Qt < Lt.length; ++Qt) {
      let lr = Lt[Qt];
      if (Vr(lr, ne))
        cr + lr.length > fr.length ? (oe.isBuffer(lr) || (lr = oe.from(lr)), lr.copy(fr, cr)) : ne.prototype.set.call(
          fr,
          lr,
          cr
        );
      else if (oe.isBuffer(lr))
        lr.copy(fr, cr);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      cr += lr.length;
    }
    return fr;
  };
  function Ht(Vt, Lt) {
    if (oe.isBuffer(Vt))
      return Vt.length;
    if (ae.isView(Vt) || Vr(Vt, ae))
      return Vt.byteLength;
    if (typeof Vt != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Vt
      );
    const Dt = Vt.length, Qt = arguments.length > 2 && arguments[2] === !0;
    if (!Qt && Dt === 0) return 0;
    let fr = !1;
    for (; ; )
      switch (Lt) {
        case "ascii":
        case "latin1":
        case "binary":
          return Dt;
        case "utf8":
        case "utf-8":
          return Fr(Vt).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Dt * 2;
        case "hex":
          return Dt >>> 1;
        case "base64":
          return Lr(Vt).length;
        default:
          if (fr)
            return Qt ? -1 : Fr(Vt).length;
          Lt = ("" + Lt).toLowerCase(), fr = !0;
      }
  }
  oe.byteLength = Ht;
  function Yt(Vt, Lt, Dt) {
    let Qt = !1;
    if ((Lt === void 0 || Lt < 0) && (Lt = 0), Lt > this.length || ((Dt === void 0 || Dt > this.length) && (Dt = this.length), Dt <= 0) || (Dt >>>= 0, Lt >>>= 0, Dt <= Lt))
      return "";
    for (Vt || (Vt = "utf8"); ; )
      switch (Vt) {
        case "hex":
          return Je(this, Lt, Dt);
        case "utf8":
        case "utf-8":
          return vt(this, Lt, Dt);
        case "ascii":
          return xt(this, Lt, Dt);
        case "latin1":
        case "binary":
          return Pt(this, Lt, Dt);
        case "base64":
          return Qe(this, Lt, Dt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ot(this, Lt, Dt);
        default:
          if (Qt) throw new TypeError("Unknown encoding: " + Vt);
          Vt = (Vt + "").toLowerCase(), Qt = !0;
      }
  }
  oe.prototype._isBuffer = !0;
  function Ut(Vt, Lt, Dt) {
    const Qt = Vt[Lt];
    Vt[Lt] = Vt[Dt], Vt[Dt] = Qt;
  }
  oe.prototype.swap16 = function() {
    const Lt = this.length;
    if (Lt % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let Dt = 0; Dt < Lt; Dt += 2)
      Ut(this, Dt, Dt + 1);
    return this;
  }, oe.prototype.swap32 = function() {
    const Lt = this.length;
    if (Lt % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let Dt = 0; Dt < Lt; Dt += 4)
      Ut(this, Dt, Dt + 3), Ut(this, Dt + 1, Dt + 2);
    return this;
  }, oe.prototype.swap64 = function() {
    const Lt = this.length;
    if (Lt % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let Dt = 0; Dt < Lt; Dt += 8)
      Ut(this, Dt, Dt + 7), Ut(this, Dt + 1, Dt + 6), Ut(this, Dt + 2, Dt + 5), Ut(this, Dt + 3, Dt + 4);
    return this;
  }, oe.prototype.toString = function() {
    const Lt = this.length;
    return Lt === 0 ? "" : arguments.length === 0 ? vt(this, 0, Lt) : Yt.apply(this, arguments);
  }, oe.prototype.toLocaleString = oe.prototype.toString, oe.prototype.equals = function(Lt) {
    if (!oe.isBuffer(Lt)) throw new TypeError("Argument must be a Buffer");
    return this === Lt ? !0 : oe.compare(this, Lt) === 0;
  }, oe.prototype.inspect = function() {
    let Lt = "";
    const Dt = B.INSPECT_MAX_BYTES;
    return Lt = this.toString("hex", 0, Dt).replace(/(.{2})/g, "$1 ").trim(), this.length > Dt && (Lt += " ... "), "<Buffer " + Lt + ">";
  }, ie && (oe.prototype[ie] = oe.prototype.inspect), oe.prototype.compare = function(Lt, Dt, Qt, fr, cr) {
    if (Vr(Lt, ne) && (Lt = oe.from(Lt, Lt.offset, Lt.byteLength)), !oe.isBuffer(Lt))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Lt
      );
    if (Dt === void 0 && (Dt = 0), Qt === void 0 && (Qt = Lt ? Lt.length : 0), fr === void 0 && (fr = 0), cr === void 0 && (cr = this.length), Dt < 0 || Qt > Lt.length || fr < 0 || cr > this.length)
      throw new RangeError("out of range index");
    if (fr >= cr && Dt >= Qt)
      return 0;
    if (fr >= cr)
      return -1;
    if (Dt >= Qt)
      return 1;
    if (Dt >>>= 0, Qt >>>= 0, fr >>>= 0, cr >>>= 0, this === Lt) return 0;
    let lr = cr - fr, Ur = Qt - Dt;
    const Nr = Math.min(lr, Ur), Tr = this.slice(fr, cr), Wr = Lt.slice(Dt, Qt);
    for (let qr = 0; qr < Nr; ++qr)
      if (Tr[qr] !== Wr[qr]) {
        lr = Tr[qr], Ur = Wr[qr];
        break;
      }
    return lr < Ur ? -1 : Ur < lr ? 1 : 0;
  };
  function Nt(Vt, Lt, Dt, Qt, fr) {
    if (Vt.length === 0) return -1;
    if (typeof Dt == "string" ? (Qt = Dt, Dt = 0) : Dt > 2147483647 ? Dt = 2147483647 : Dt < -2147483648 && (Dt = -2147483648), Dt = +Dt, jr(Dt) && (Dt = fr ? 0 : Vt.length - 1), Dt < 0 && (Dt = Vt.length + Dt), Dt >= Vt.length) {
      if (fr) return -1;
      Dt = Vt.length - 1;
    } else if (Dt < 0)
      if (fr) Dt = 0;
      else return -1;
    if (typeof Lt == "string" && (Lt = oe.from(Lt, Qt)), oe.isBuffer(Lt))
      return Lt.length === 0 ? -1 : Kt(Vt, Lt, Dt, Qt, fr);
    if (typeof Lt == "number")
      return Lt = Lt & 255, typeof ne.prototype.indexOf == "function" ? fr ? ne.prototype.indexOf.call(Vt, Lt, Dt) : ne.prototype.lastIndexOf.call(Vt, Lt, Dt) : Kt(Vt, [Lt], Dt, Qt, fr);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Kt(Vt, Lt, Dt, Qt, fr) {
    let cr = 1, lr = Vt.length, Ur = Lt.length;
    if (Qt !== void 0 && (Qt = String(Qt).toLowerCase(), Qt === "ucs2" || Qt === "ucs-2" || Qt === "utf16le" || Qt === "utf-16le")) {
      if (Vt.length < 2 || Lt.length < 2)
        return -1;
      cr = 2, lr /= 2, Ur /= 2, Dt /= 2;
    }
    function Nr(Wr, qr) {
      return cr === 1 ? Wr[qr] : Wr.readUInt16BE(qr * cr);
    }
    let Tr;
    if (fr) {
      let Wr = -1;
      for (Tr = Dt; Tr < lr; Tr++)
        if (Nr(Vt, Tr) === Nr(Lt, Wr === -1 ? 0 : Tr - Wr)) {
          if (Wr === -1 && (Wr = Tr), Tr - Wr + 1 === Ur) return Wr * cr;
        } else
          Wr !== -1 && (Tr -= Tr - Wr), Wr = -1;
    } else
      for (Dt + Ur > lr && (Dt = lr - Ur), Tr = Dt; Tr >= 0; Tr--) {
        let Wr = !0;
        for (let qr = 0; qr < Ur; qr++)
          if (Nr(Vt, Tr + qr) !== Nr(Lt, qr)) {
            Wr = !1;
            break;
          }
        if (Wr) return Tr;
      }
    return -1;
  }
  oe.prototype.includes = function(Lt, Dt, Qt) {
    return this.indexOf(Lt, Dt, Qt) !== -1;
  }, oe.prototype.indexOf = function(Lt, Dt, Qt) {
    return Nt(this, Lt, Dt, Qt, !0);
  }, oe.prototype.lastIndexOf = function(Lt, Dt, Qt) {
    return Nt(this, Lt, Dt, Qt, !1);
  };
  function Ft(Vt, Lt, Dt, Qt) {
    Dt = Number(Dt) || 0;
    const fr = Vt.length - Dt;
    Qt ? (Qt = Number(Qt), Qt > fr && (Qt = fr)) : Qt = fr;
    const cr = Lt.length;
    Qt > cr / 2 && (Qt = cr / 2);
    let lr;
    for (lr = 0; lr < Qt; ++lr) {
      const Ur = parseInt(Lt.substr(lr * 2, 2), 16);
      if (jr(Ur)) return lr;
      Vt[Dt + lr] = Ur;
    }
    return lr;
  }
  function bt(Vt, Lt, Dt, Qt) {
    return Rr(Fr(Lt, Vt.length - Dt), Vt, Dt, Qt);
  }
  function Xe(Vt, Lt, Dt, Qt) {
    return Rr(Ar(Lt), Vt, Dt, Qt);
  }
  function ve(Vt, Lt, Dt, Qt) {
    return Rr(Lr(Lt), Vt, Dt, Qt);
  }
  function Ce(Vt, Lt, Dt, Qt) {
    return Rr(Gr(Lt, Vt.length - Dt), Vt, Dt, Qt);
  }
  oe.prototype.write = function(Lt, Dt, Qt, fr) {
    if (Dt === void 0)
      fr = "utf8", Qt = this.length, Dt = 0;
    else if (Qt === void 0 && typeof Dt == "string")
      fr = Dt, Qt = this.length, Dt = 0;
    else if (isFinite(Dt))
      Dt = Dt >>> 0, isFinite(Qt) ? (Qt = Qt >>> 0, fr === void 0 && (fr = "utf8")) : (fr = Qt, Qt = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const cr = this.length - Dt;
    if ((Qt === void 0 || Qt > cr) && (Qt = cr), Lt.length > 0 && (Qt < 0 || Dt < 0) || Dt > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    fr || (fr = "utf8");
    let lr = !1;
    for (; ; )
      switch (fr) {
        case "hex":
          return Ft(this, Lt, Dt, Qt);
        case "utf8":
        case "utf-8":
          return bt(this, Lt, Dt, Qt);
        case "ascii":
        case "latin1":
        case "binary":
          return Xe(this, Lt, Dt, Qt);
        case "base64":
          return ve(this, Lt, Dt, Qt);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Ce(this, Lt, Dt, Qt);
        default:
          if (lr) throw new TypeError("Unknown encoding: " + fr);
          fr = ("" + fr).toLowerCase(), lr = !0;
      }
  }, oe.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Qe(Vt, Lt, Dt) {
    return Lt === 0 && Dt === Vt.length ? z.fromByteArray(Vt) : z.fromByteArray(Vt.slice(Lt, Dt));
  }
  function vt(Vt, Lt, Dt) {
    Dt = Math.min(Vt.length, Dt);
    const Qt = [];
    let fr = Lt;
    for (; fr < Dt; ) {
      const cr = Vt[fr];
      let lr = null, Ur = cr > 239 ? 4 : cr > 223 ? 3 : cr > 191 ? 2 : 1;
      if (fr + Ur <= Dt) {
        let Nr, Tr, Wr, qr;
        switch (Ur) {
          case 1:
            cr < 128 && (lr = cr);
            break;
          case 2:
            Nr = Vt[fr + 1], (Nr & 192) === 128 && (qr = (cr & 31) << 6 | Nr & 63, qr > 127 && (lr = qr));
            break;
          case 3:
            Nr = Vt[fr + 1], Tr = Vt[fr + 2], (Nr & 192) === 128 && (Tr & 192) === 128 && (qr = (cr & 15) << 12 | (Nr & 63) << 6 | Tr & 63, qr > 2047 && (qr < 55296 || qr > 57343) && (lr = qr));
            break;
          case 4:
            Nr = Vt[fr + 1], Tr = Vt[fr + 2], Wr = Vt[fr + 3], (Nr & 192) === 128 && (Tr & 192) === 128 && (Wr & 192) === 128 && (qr = (cr & 15) << 18 | (Nr & 63) << 12 | (Tr & 63) << 6 | Wr & 63, qr > 65535 && qr < 1114112 && (lr = qr));
        }
      }
      lr === null ? (lr = 65533, Ur = 1) : lr > 65535 && (lr -= 65536, Qt.push(lr >>> 10 & 1023 | 55296), lr = 56320 | lr & 1023), Qt.push(lr), fr += Ur;
    }
    return $t(Qt);
  }
  const wt = 4096;
  function $t(Vt) {
    const Lt = Vt.length;
    if (Lt <= wt)
      return String.fromCharCode.apply(String, Vt);
    let Dt = "", Qt = 0;
    for (; Qt < Lt; )
      Dt += String.fromCharCode.apply(
        String,
        Vt.slice(Qt, Qt += wt)
      );
    return Dt;
  }
  function xt(Vt, Lt, Dt) {
    let Qt = "";
    Dt = Math.min(Vt.length, Dt);
    for (let fr = Lt; fr < Dt; ++fr)
      Qt += String.fromCharCode(Vt[fr] & 127);
    return Qt;
  }
  function Pt(Vt, Lt, Dt) {
    let Qt = "";
    Dt = Math.min(Vt.length, Dt);
    for (let fr = Lt; fr < Dt; ++fr)
      Qt += String.fromCharCode(Vt[fr]);
    return Qt;
  }
  function Je(Vt, Lt, Dt) {
    const Qt = Vt.length;
    (!Lt || Lt < 0) && (Lt = 0), (!Dt || Dt < 0 || Dt > Qt) && (Dt = Qt);
    let fr = "";
    for (let cr = Lt; cr < Dt; ++cr)
      fr += kr[Vt[cr]];
    return fr;
  }
  function Ot(Vt, Lt, Dt) {
    const Qt = Vt.slice(Lt, Dt);
    let fr = "";
    for (let cr = 0; cr < Qt.length - 1; cr += 2)
      fr += String.fromCharCode(Qt[cr] + Qt[cr + 1] * 256);
    return fr;
  }
  oe.prototype.slice = function(Lt, Dt) {
    const Qt = this.length;
    Lt = ~~Lt, Dt = Dt === void 0 ? Qt : ~~Dt, Lt < 0 ? (Lt += Qt, Lt < 0 && (Lt = 0)) : Lt > Qt && (Lt = Qt), Dt < 0 ? (Dt += Qt, Dt < 0 && (Dt = 0)) : Dt > Qt && (Dt = Qt), Dt < Lt && (Dt = Lt);
    const fr = this.subarray(Lt, Dt);
    return Object.setPrototypeOf(fr, oe.prototype), fr;
  };
  function er(Vt, Lt, Dt) {
    if (Vt % 1 !== 0 || Vt < 0) throw new RangeError("offset is not uint");
    if (Vt + Lt > Dt) throw new RangeError("Trying to access beyond buffer length");
  }
  oe.prototype.readUintLE = oe.prototype.readUIntLE = function(Lt, Dt, Qt) {
    Lt = Lt >>> 0, Dt = Dt >>> 0, Qt || er(Lt, Dt, this.length);
    let fr = this[Lt], cr = 1, lr = 0;
    for (; ++lr < Dt && (cr *= 256); )
      fr += this[Lt + lr] * cr;
    return fr;
  }, oe.prototype.readUintBE = oe.prototype.readUIntBE = function(Lt, Dt, Qt) {
    Lt = Lt >>> 0, Dt = Dt >>> 0, Qt || er(Lt, Dt, this.length);
    let fr = this[Lt + --Dt], cr = 1;
    for (; Dt > 0 && (cr *= 256); )
      fr += this[Lt + --Dt] * cr;
    return fr;
  }, oe.prototype.readUint8 = oe.prototype.readUInt8 = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 1, this.length), this[Lt];
  }, oe.prototype.readUint16LE = oe.prototype.readUInt16LE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 2, this.length), this[Lt] | this[Lt + 1] << 8;
  }, oe.prototype.readUint16BE = oe.prototype.readUInt16BE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 2, this.length), this[Lt] << 8 | this[Lt + 1];
  }, oe.prototype.readUint32LE = oe.prototype.readUInt32LE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 4, this.length), (this[Lt] | this[Lt + 1] << 8 | this[Lt + 2] << 16) + this[Lt + 3] * 16777216;
  }, oe.prototype.readUint32BE = oe.prototype.readUInt32BE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 4, this.length), this[Lt] * 16777216 + (this[Lt + 1] << 16 | this[Lt + 2] << 8 | this[Lt + 3]);
  }, oe.prototype.readBigUInt64LE = Jr(function(Lt) {
    Lt = Lt >>> 0, Sr(Lt, "offset");
    const Dt = this[Lt], Qt = this[Lt + 7];
    (Dt === void 0 || Qt === void 0) && $r(Lt, this.length - 8);
    const fr = Dt + this[++Lt] * 2 ** 8 + this[++Lt] * 2 ** 16 + this[++Lt] * 2 ** 24, cr = this[++Lt] + this[++Lt] * 2 ** 8 + this[++Lt] * 2 ** 16 + Qt * 2 ** 24;
    return BigInt(fr) + (BigInt(cr) << BigInt(32));
  }), oe.prototype.readBigUInt64BE = Jr(function(Lt) {
    Lt = Lt >>> 0, Sr(Lt, "offset");
    const Dt = this[Lt], Qt = this[Lt + 7];
    (Dt === void 0 || Qt === void 0) && $r(Lt, this.length - 8);
    const fr = Dt * 2 ** 24 + this[++Lt] * 2 ** 16 + this[++Lt] * 2 ** 8 + this[++Lt], cr = this[++Lt] * 2 ** 24 + this[++Lt] * 2 ** 16 + this[++Lt] * 2 ** 8 + Qt;
    return (BigInt(fr) << BigInt(32)) + BigInt(cr);
  }), oe.prototype.readIntLE = function(Lt, Dt, Qt) {
    Lt = Lt >>> 0, Dt = Dt >>> 0, Qt || er(Lt, Dt, this.length);
    let fr = this[Lt], cr = 1, lr = 0;
    for (; ++lr < Dt && (cr *= 256); )
      fr += this[Lt + lr] * cr;
    return cr *= 128, fr >= cr && (fr -= Math.pow(2, 8 * Dt)), fr;
  }, oe.prototype.readIntBE = function(Lt, Dt, Qt) {
    Lt = Lt >>> 0, Dt = Dt >>> 0, Qt || er(Lt, Dt, this.length);
    let fr = Dt, cr = 1, lr = this[Lt + --fr];
    for (; fr > 0 && (cr *= 256); )
      lr += this[Lt + --fr] * cr;
    return cr *= 128, lr >= cr && (lr -= Math.pow(2, 8 * Dt)), lr;
  }, oe.prototype.readInt8 = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 1, this.length), this[Lt] & 128 ? (255 - this[Lt] + 1) * -1 : this[Lt];
  }, oe.prototype.readInt16LE = function(Lt, Dt) {
    Lt = Lt >>> 0, Dt || er(Lt, 2, this.length);
    const Qt = this[Lt] | this[Lt + 1] << 8;
    return Qt & 32768 ? Qt | 4294901760 : Qt;
  }, oe.prototype.readInt16BE = function(Lt, Dt) {
    Lt = Lt >>> 0, Dt || er(Lt, 2, this.length);
    const Qt = this[Lt + 1] | this[Lt] << 8;
    return Qt & 32768 ? Qt | 4294901760 : Qt;
  }, oe.prototype.readInt32LE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 4, this.length), this[Lt] | this[Lt + 1] << 8 | this[Lt + 2] << 16 | this[Lt + 3] << 24;
  }, oe.prototype.readInt32BE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 4, this.length), this[Lt] << 24 | this[Lt + 1] << 16 | this[Lt + 2] << 8 | this[Lt + 3];
  }, oe.prototype.readBigInt64LE = Jr(function(Lt) {
    Lt = Lt >>> 0, Sr(Lt, "offset");
    const Dt = this[Lt], Qt = this[Lt + 7];
    (Dt === void 0 || Qt === void 0) && $r(Lt, this.length - 8);
    const fr = this[Lt + 4] + this[Lt + 5] * 2 ** 8 + this[Lt + 6] * 2 ** 16 + (Qt << 24);
    return (BigInt(fr) << BigInt(32)) + BigInt(Dt + this[++Lt] * 2 ** 8 + this[++Lt] * 2 ** 16 + this[++Lt] * 2 ** 24);
  }), oe.prototype.readBigInt64BE = Jr(function(Lt) {
    Lt = Lt >>> 0, Sr(Lt, "offset");
    const Dt = this[Lt], Qt = this[Lt + 7];
    (Dt === void 0 || Qt === void 0) && $r(Lt, this.length - 8);
    const fr = (Dt << 24) + // Overflow
    this[++Lt] * 2 ** 16 + this[++Lt] * 2 ** 8 + this[++Lt];
    return (BigInt(fr) << BigInt(32)) + BigInt(this[++Lt] * 2 ** 24 + this[++Lt] * 2 ** 16 + this[++Lt] * 2 ** 8 + Qt);
  }), oe.prototype.readFloatLE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 4, this.length), Y.read(this, Lt, !0, 23, 4);
  }, oe.prototype.readFloatBE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 4, this.length), Y.read(this, Lt, !1, 23, 4);
  }, oe.prototype.readDoubleLE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 8, this.length), Y.read(this, Lt, !0, 52, 8);
  }, oe.prototype.readDoubleBE = function(Lt, Dt) {
    return Lt = Lt >>> 0, Dt || er(Lt, 8, this.length), Y.read(this, Lt, !1, 52, 8);
  };
  function sr(Vt, Lt, Dt, Qt, fr, cr) {
    if (!oe.isBuffer(Vt)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (Lt > fr || Lt < cr) throw new RangeError('"value" argument is out of bounds');
    if (Dt + Qt > Vt.length) throw new RangeError("Index out of range");
  }
  oe.prototype.writeUintLE = oe.prototype.writeUIntLE = function(Lt, Dt, Qt, fr) {
    if (Lt = +Lt, Dt = Dt >>> 0, Qt = Qt >>> 0, !fr) {
      const Ur = Math.pow(2, 8 * Qt) - 1;
      sr(this, Lt, Dt, Qt, Ur, 0);
    }
    let cr = 1, lr = 0;
    for (this[Dt] = Lt & 255; ++lr < Qt && (cr *= 256); )
      this[Dt + lr] = Lt / cr & 255;
    return Dt + Qt;
  }, oe.prototype.writeUintBE = oe.prototype.writeUIntBE = function(Lt, Dt, Qt, fr) {
    if (Lt = +Lt, Dt = Dt >>> 0, Qt = Qt >>> 0, !fr) {
      const Ur = Math.pow(2, 8 * Qt) - 1;
      sr(this, Lt, Dt, Qt, Ur, 0);
    }
    let cr = Qt - 1, lr = 1;
    for (this[Dt + cr] = Lt & 255; --cr >= 0 && (lr *= 256); )
      this[Dt + cr] = Lt / lr & 255;
    return Dt + Qt;
  }, oe.prototype.writeUint8 = oe.prototype.writeUInt8 = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 1, 255, 0), this[Dt] = Lt & 255, Dt + 1;
  }, oe.prototype.writeUint16LE = oe.prototype.writeUInt16LE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 2, 65535, 0), this[Dt] = Lt & 255, this[Dt + 1] = Lt >>> 8, Dt + 2;
  }, oe.prototype.writeUint16BE = oe.prototype.writeUInt16BE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 2, 65535, 0), this[Dt] = Lt >>> 8, this[Dt + 1] = Lt & 255, Dt + 2;
  }, oe.prototype.writeUint32LE = oe.prototype.writeUInt32LE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 4, 4294967295, 0), this[Dt + 3] = Lt >>> 24, this[Dt + 2] = Lt >>> 16, this[Dt + 1] = Lt >>> 8, this[Dt] = Lt & 255, Dt + 4;
  }, oe.prototype.writeUint32BE = oe.prototype.writeUInt32BE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 4, 4294967295, 0), this[Dt] = Lt >>> 24, this[Dt + 1] = Lt >>> 16, this[Dt + 2] = Lt >>> 8, this[Dt + 3] = Lt & 255, Dt + 4;
  };
  function Jt(Vt, Lt, Dt, Qt, fr) {
    yr(Lt, Qt, fr, Vt, Dt, 7);
    let cr = Number(Lt & BigInt(4294967295));
    Vt[Dt++] = cr, cr = cr >> 8, Vt[Dt++] = cr, cr = cr >> 8, Vt[Dt++] = cr, cr = cr >> 8, Vt[Dt++] = cr;
    let lr = Number(Lt >> BigInt(32) & BigInt(4294967295));
    return Vt[Dt++] = lr, lr = lr >> 8, Vt[Dt++] = lr, lr = lr >> 8, Vt[Dt++] = lr, lr = lr >> 8, Vt[Dt++] = lr, Dt;
  }
  function Wt(Vt, Lt, Dt, Qt, fr) {
    yr(Lt, Qt, fr, Vt, Dt, 7);
    let cr = Number(Lt & BigInt(4294967295));
    Vt[Dt + 7] = cr, cr = cr >> 8, Vt[Dt + 6] = cr, cr = cr >> 8, Vt[Dt + 5] = cr, cr = cr >> 8, Vt[Dt + 4] = cr;
    let lr = Number(Lt >> BigInt(32) & BigInt(4294967295));
    return Vt[Dt + 3] = lr, lr = lr >> 8, Vt[Dt + 2] = lr, lr = lr >> 8, Vt[Dt + 1] = lr, lr = lr >> 8, Vt[Dt] = lr, Dt + 8;
  }
  oe.prototype.writeBigUInt64LE = Jr(function(Lt, Dt = 0) {
    return Jt(this, Lt, Dt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeBigUInt64BE = Jr(function(Lt, Dt = 0) {
    return Wt(this, Lt, Dt, BigInt(0), BigInt("0xffffffffffffffff"));
  }), oe.prototype.writeIntLE = function(Lt, Dt, Qt, fr) {
    if (Lt = +Lt, Dt = Dt >>> 0, !fr) {
      const Nr = Math.pow(2, 8 * Qt - 1);
      sr(this, Lt, Dt, Qt, Nr - 1, -Nr);
    }
    let cr = 0, lr = 1, Ur = 0;
    for (this[Dt] = Lt & 255; ++cr < Qt && (lr *= 256); )
      Lt < 0 && Ur === 0 && this[Dt + cr - 1] !== 0 && (Ur = 1), this[Dt + cr] = (Lt / lr >> 0) - Ur & 255;
    return Dt + Qt;
  }, oe.prototype.writeIntBE = function(Lt, Dt, Qt, fr) {
    if (Lt = +Lt, Dt = Dt >>> 0, !fr) {
      const Nr = Math.pow(2, 8 * Qt - 1);
      sr(this, Lt, Dt, Qt, Nr - 1, -Nr);
    }
    let cr = Qt - 1, lr = 1, Ur = 0;
    for (this[Dt + cr] = Lt & 255; --cr >= 0 && (lr *= 256); )
      Lt < 0 && Ur === 0 && this[Dt + cr + 1] !== 0 && (Ur = 1), this[Dt + cr] = (Lt / lr >> 0) - Ur & 255;
    return Dt + Qt;
  }, oe.prototype.writeInt8 = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 1, 127, -128), Lt < 0 && (Lt = 255 + Lt + 1), this[Dt] = Lt & 255, Dt + 1;
  }, oe.prototype.writeInt16LE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 2, 32767, -32768), this[Dt] = Lt & 255, this[Dt + 1] = Lt >>> 8, Dt + 2;
  }, oe.prototype.writeInt16BE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 2, 32767, -32768), this[Dt] = Lt >>> 8, this[Dt + 1] = Lt & 255, Dt + 2;
  }, oe.prototype.writeInt32LE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 4, 2147483647, -2147483648), this[Dt] = Lt & 255, this[Dt + 1] = Lt >>> 8, this[Dt + 2] = Lt >>> 16, this[Dt + 3] = Lt >>> 24, Dt + 4;
  }, oe.prototype.writeInt32BE = function(Lt, Dt, Qt) {
    return Lt = +Lt, Dt = Dt >>> 0, Qt || sr(this, Lt, Dt, 4, 2147483647, -2147483648), Lt < 0 && (Lt = 4294967295 + Lt + 1), this[Dt] = Lt >>> 24, this[Dt + 1] = Lt >>> 16, this[Dt + 2] = Lt >>> 8, this[Dt + 3] = Lt & 255, Dt + 4;
  }, oe.prototype.writeBigInt64LE = Jr(function(Lt, Dt = 0) {
    return Jt(this, Lt, Dt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), oe.prototype.writeBigInt64BE = Jr(function(Lt, Dt = 0) {
    return Wt(this, Lt, Dt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Gt(Vt, Lt, Dt, Qt, fr, cr) {
    if (Dt + Qt > Vt.length) throw new RangeError("Index out of range");
    if (Dt < 0) throw new RangeError("Index out of range");
  }
  function rr(Vt, Lt, Dt, Qt, fr) {
    return Lt = +Lt, Dt = Dt >>> 0, fr || Gt(Vt, Lt, Dt, 4), Y.write(Vt, Lt, Dt, Qt, 23, 4), Dt + 4;
  }
  oe.prototype.writeFloatLE = function(Lt, Dt, Qt) {
    return rr(this, Lt, Dt, !0, Qt);
  }, oe.prototype.writeFloatBE = function(Lt, Dt, Qt) {
    return rr(this, Lt, Dt, !1, Qt);
  };
  function or(Vt, Lt, Dt, Qt, fr) {
    return Lt = +Lt, Dt = Dt >>> 0, fr || Gt(Vt, Lt, Dt, 8), Y.write(Vt, Lt, Dt, Qt, 52, 8), Dt + 8;
  }
  oe.prototype.writeDoubleLE = function(Lt, Dt, Qt) {
    return or(this, Lt, Dt, !0, Qt);
  }, oe.prototype.writeDoubleBE = function(Lt, Dt, Qt) {
    return or(this, Lt, Dt, !1, Qt);
  }, oe.prototype.copy = function(Lt, Dt, Qt, fr) {
    if (!oe.isBuffer(Lt)) throw new TypeError("argument should be a Buffer");
    if (Qt || (Qt = 0), !fr && fr !== 0 && (fr = this.length), Dt >= Lt.length && (Dt = Lt.length), Dt || (Dt = 0), fr > 0 && fr < Qt && (fr = Qt), fr === Qt || Lt.length === 0 || this.length === 0) return 0;
    if (Dt < 0)
      throw new RangeError("targetStart out of bounds");
    if (Qt < 0 || Qt >= this.length) throw new RangeError("Index out of range");
    if (fr < 0) throw new RangeError("sourceEnd out of bounds");
    fr > this.length && (fr = this.length), Lt.length - Dt < fr - Qt && (fr = Lt.length - Dt + Qt);
    const cr = fr - Qt;
    return this === Lt && typeof ne.prototype.copyWithin == "function" ? this.copyWithin(Dt, Qt, fr) : ne.prototype.set.call(
      Lt,
      this.subarray(Qt, fr),
      Dt
    ), cr;
  }, oe.prototype.fill = function(Lt, Dt, Qt, fr) {
    if (typeof Lt == "string") {
      if (typeof Dt == "string" ? (fr = Dt, Dt = 0, Qt = this.length) : typeof Qt == "string" && (fr = Qt, Qt = this.length), fr !== void 0 && typeof fr != "string")
        throw new TypeError("encoding must be a string");
      if (typeof fr == "string" && !oe.isEncoding(fr))
        throw new TypeError("Unknown encoding: " + fr);
      if (Lt.length === 1) {
        const lr = Lt.charCodeAt(0);
        (fr === "utf8" && lr < 128 || fr === "latin1") && (Lt = lr);
      }
    } else typeof Lt == "number" ? Lt = Lt & 255 : typeof Lt == "boolean" && (Lt = Number(Lt));
    if (Dt < 0 || this.length < Dt || this.length < Qt)
      throw new RangeError("Out of range index");
    if (Qt <= Dt)
      return this;
    Dt = Dt >>> 0, Qt = Qt === void 0 ? this.length : Qt >>> 0, Lt || (Lt = 0);
    let cr;
    if (typeof Lt == "number")
      for (cr = Dt; cr < Qt; ++cr)
        this[cr] = Lt;
    else {
      const lr = oe.isBuffer(Lt) ? Lt : oe.from(Lt, fr), Ur = lr.length;
      if (Ur === 0)
        throw new TypeError('The value "' + Lt + '" is invalid for argument "value"');
      for (cr = 0; cr < Qt - Dt; ++cr)
        this[cr + Dt] = lr[cr % Ur];
    }
    return this;
  };
  const Xt = {};
  function zt(Vt, Lt, Dt) {
    Xt[Vt] = class extends Dt {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: Lt.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${Vt}]`, this.stack, delete this.name;
      }
      get code() {
        return Vt;
      }
      set code(fr) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: fr,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${Vt}]: ${this.message}`;
      }
    };
  }
  zt(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(Vt) {
      return Vt ? `${Vt} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), zt(
    "ERR_INVALID_ARG_TYPE",
    function(Vt, Lt) {
      return `The "${Vt}" argument must be of type number. Received type ${typeof Lt}`;
    },
    TypeError
  ), zt(
    "ERR_OUT_OF_RANGE",
    function(Vt, Lt, Dt) {
      let Qt = `The value of "${Vt}" is out of range.`, fr = Dt;
      return Number.isInteger(Dt) && Math.abs(Dt) > 2 ** 32 ? fr = ur(String(Dt)) : typeof Dt == "bigint" && (fr = String(Dt), (Dt > BigInt(2) ** BigInt(32) || Dt < -(BigInt(2) ** BigInt(32))) && (fr = ur(fr)), fr += "n"), Qt += ` It must be ${Lt}. Received ${fr}`, Qt;
    },
    RangeError
  );
  function ur(Vt) {
    let Lt = "", Dt = Vt.length;
    const Qt = Vt[0] === "-" ? 1 : 0;
    for (; Dt >= Qt + 4; Dt -= 3)
      Lt = `_${Vt.slice(Dt - 3, Dt)}${Lt}`;
    return `${Vt.slice(0, Dt)}${Lt}`;
  }
  function hr(Vt, Lt, Dt) {
    Sr(Lt, "offset"), (Vt[Lt] === void 0 || Vt[Lt + Dt] === void 0) && $r(Lt, Vt.length - (Dt + 1));
  }
  function yr(Vt, Lt, Dt, Qt, fr, cr) {
    if (Vt > Dt || Vt < Lt) {
      const lr = typeof Lt == "bigint" ? "n" : "";
      let Ur;
      throw Lt === 0 || Lt === BigInt(0) ? Ur = `>= 0${lr} and < 2${lr} ** ${(cr + 1) * 8}${lr}` : Ur = `>= -(2${lr} ** ${(cr + 1) * 8 - 1}${lr}) and < 2 ** ${(cr + 1) * 8 - 1}${lr}`, new Xt.ERR_OUT_OF_RANGE("value", Ur, Vt);
    }
    hr(Qt, fr, cr);
  }
  function Sr(Vt, Lt) {
    if (typeof Vt != "number")
      throw new Xt.ERR_INVALID_ARG_TYPE(Lt, "number", Vt);
  }
  function $r(Vt, Lt, Dt) {
    throw Math.floor(Vt) !== Vt ? (Sr(Vt, Dt), new Xt.ERR_OUT_OF_RANGE("offset", "an integer", Vt)) : Lt < 0 ? new Xt.ERR_BUFFER_OUT_OF_BOUNDS() : new Xt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${Lt}`,
      Vt
    );
  }
  const Mr = /[^+/0-9A-Za-z-_]/g;
  function pr(Vt) {
    if (Vt = Vt.split("=")[0], Vt = Vt.trim().replace(Mr, ""), Vt.length < 2) return "";
    for (; Vt.length % 4 !== 0; )
      Vt = Vt + "=";
    return Vt;
  }
  function Fr(Vt, Lt) {
    Lt = Lt || 1 / 0;
    let Dt;
    const Qt = Vt.length;
    let fr = null;
    const cr = [];
    for (let lr = 0; lr < Qt; ++lr) {
      if (Dt = Vt.charCodeAt(lr), Dt > 55295 && Dt < 57344) {
        if (!fr) {
          if (Dt > 56319) {
            (Lt -= 3) > -1 && cr.push(239, 191, 189);
            continue;
          } else if (lr + 1 === Qt) {
            (Lt -= 3) > -1 && cr.push(239, 191, 189);
            continue;
          }
          fr = Dt;
          continue;
        }
        if (Dt < 56320) {
          (Lt -= 3) > -1 && cr.push(239, 191, 189), fr = Dt;
          continue;
        }
        Dt = (fr - 55296 << 10 | Dt - 56320) + 65536;
      } else fr && (Lt -= 3) > -1 && cr.push(239, 191, 189);
      if (fr = null, Dt < 128) {
        if ((Lt -= 1) < 0) break;
        cr.push(Dt);
      } else if (Dt < 2048) {
        if ((Lt -= 2) < 0) break;
        cr.push(
          Dt >> 6 | 192,
          Dt & 63 | 128
        );
      } else if (Dt < 65536) {
        if ((Lt -= 3) < 0) break;
        cr.push(
          Dt >> 12 | 224,
          Dt >> 6 & 63 | 128,
          Dt & 63 | 128
        );
      } else if (Dt < 1114112) {
        if ((Lt -= 4) < 0) break;
        cr.push(
          Dt >> 18 | 240,
          Dt >> 12 & 63 | 128,
          Dt >> 6 & 63 | 128,
          Dt & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return cr;
  }
  function Ar(Vt) {
    const Lt = [];
    for (let Dt = 0; Dt < Vt.length; ++Dt)
      Lt.push(Vt.charCodeAt(Dt) & 255);
    return Lt;
  }
  function Gr(Vt, Lt) {
    let Dt, Qt, fr;
    const cr = [];
    for (let lr = 0; lr < Vt.length && !((Lt -= 2) < 0); ++lr)
      Dt = Vt.charCodeAt(lr), Qt = Dt >> 8, fr = Dt % 256, cr.push(fr), cr.push(Qt);
    return cr;
  }
  function Lr(Vt) {
    return z.toByteArray(pr(Vt));
  }
  function Rr(Vt, Lt, Dt, Qt) {
    let fr;
    for (fr = 0; fr < Qt && !(fr + Dt >= Lt.length || fr >= Vt.length); ++fr)
      Lt[fr + Dt] = Vt[fr];
    return fr;
  }
  function Vr(Vt, Lt) {
    return Vt instanceof Lt || Vt != null && Vt.constructor != null && Vt.constructor.name != null && Vt.constructor.name === Lt.name;
  }
  function jr(Vt) {
    return Vt !== Vt;
  }
  const kr = function() {
    const Vt = "0123456789abcdef", Lt = new Array(256);
    for (let Dt = 0; Dt < 16; ++Dt) {
      const Qt = Dt * 16;
      for (let fr = 0; fr < 16; ++fr)
        Lt[Qt + fr] = Vt[Dt] + Vt[fr];
    }
    return Lt;
  }();
  function Jr(Vt) {
    return typeof BigInt > "u" ? Xr : Vt;
  }
  function Xr() {
    throw new Error("BigInt not supported");
  }
})(buffer$1);
const Buffer$1 = buffer$1.Buffer, Blob = buffer$1.Blob, BlobOptions = buffer$1.BlobOptions, Buffer$1$1 = buffer$1.Buffer, File = buffer$1.File, FileOptions = buffer$1.FileOptions, INSPECT_MAX_BYTES = buffer$1.INSPECT_MAX_BYTES, SlowBuffer = buffer$1.SlowBuffer, TranscodeEncoding = buffer$1.TranscodeEncoding, atob = buffer$1.atob, btoa = buffer$1.btoa, constants$1 = buffer$1.constants, isAscii = buffer$1.isAscii, isUtf8 = buffer$1.isUtf8, kMaxLength = buffer$1.kMaxLength, kStringMaxLength = buffer$1.kStringMaxLength, resolveObjectURL = buffer$1.resolveObjectURL, transcode = buffer$1.transcode, dist$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Blob,
  BlobOptions,
  Buffer: Buffer$1$1,
  File,
  FileOptions,
  INSPECT_MAX_BYTES,
  SlowBuffer,
  TranscodeEncoding,
  atob,
  btoa,
  constants: constants$1,
  default: Buffer$1,
  isAscii,
  isUtf8,
  kMaxLength,
  kStringMaxLength,
  resolveObjectURL,
  transcode
}, Symbol.toStringTag, { value: "Module" }));
var store2;
function getGlobalMessage(B) {
  return store2 == null ? void 0 : store2.get(B);
}
var store3;
function getSchemaMessage(B) {
  return store3 == null ? void 0 : store3.get(B);
}
var store4;
function getSpecificMessage(B, z) {
  var Y;
  return (Y = store4 == null ? void 0 : store4.get(B)) == null ? void 0 : Y.get(z);
}
function _stringify(B) {
  var Y, ie;
  const z = typeof B;
  return z === "string" ? `"${B}"` : z === "number" || z === "bigint" || z === "boolean" ? `${B}` : z === "object" || z === "function" ? (B && ((ie = (Y = Object.getPrototypeOf(B)) == null ? void 0 : Y.constructor) == null ? void 0 : ie.name)) ?? "null" : z;
}
function _addIssue(B, z, Y, ie, se) {
  const ne = se && "input" in se ? se.input : Y.value, ae = (se == null ? void 0 : se.expected) ?? B.expects ?? null, le = (se == null ? void 0 : se.received) ?? _stringify(ne), ge = {
    kind: B.kind,
    type: B.type,
    input: ne,
    expected: ae,
    received: le,
    message: `Invalid ${z}: ${ae ? `Expected ${ae} but r` : "R"}eceived ${le}`,
    requirement: B.requirement,
    path: se == null ? void 0 : se.path,
    issues: se == null ? void 0 : se.issues,
    lang: ie.lang,
    abortEarly: ie.abortEarly,
    abortPipeEarly: ie.abortPipeEarly
  }, Ee = B.kind === "schema", oe = (se == null ? void 0 : se.message) ?? B.message ?? getSpecificMessage(B.reference, ge.lang) ?? (Ee ? getSchemaMessage(ge.lang) : null) ?? ie.message ?? getGlobalMessage(ge.lang);
  oe && (ge.message = typeof oe == "function" ? (
    // @ts-expect-error
    oe(ge)
  ) : oe), Ee && (Y.typed = !1), Y.issues ? Y.issues.push(ge) : Y.issues = [ge];
}
function _isValidObjectKey(B, z) {
  return Object.hasOwn(B, z) && z !== "__proto__" && z !== "prototype" && z !== "constructor";
}
function _joinExpects(B, z) {
  const Y = [...new Set(B)];
  return Y.length > 1 ? `(${Y.join(` ${z} `)})` : Y[0] ?? "never";
}
function check$e(B, z) {
  return {
    kind: "validation",
    type: "check",
    reference: check$e,
    async: !1,
    expects: null,
    requirement: B,
    message: z,
    _run(Y, ie) {
      return Y.typed && !this.requirement(Y.value) && _addIssue(this, "input", Y, ie), Y;
    }
  };
}
function maxLength(B, z) {
  return {
    kind: "validation",
    type: "max_length",
    reference: maxLength,
    async: !1,
    expects: `<=${B}`,
    requirement: B,
    message: z,
    _run(Y, ie) {
      return Y.typed && Y.value.length > this.requirement && _addIssue(this, "length", Y, ie, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function minLength(B, z) {
  return {
    kind: "validation",
    type: "min_length",
    reference: minLength,
    async: !1,
    expects: `>=${B}`,
    requirement: B,
    message: z,
    _run(Y, ie) {
      return Y.typed && Y.value.length < this.requirement && _addIssue(this, "length", Y, ie, {
        received: `${Y.value.length}`
      }), Y;
    }
  };
}
function getDefault(B, z, Y) {
  return typeof B.default == "function" ? (
    // @ts-expect-error
    B.default(z, Y)
  ) : (
    // @ts-expect-error
    B.default
  );
}
function is(B, z) {
  return !B._run({ typed: !1, value: z }, { abortEarly: !0 }).issues;
}
function array(B, z) {
  return {
    kind: "schema",
    type: "array",
    reference: array,
    expects: "Array",
    async: !1,
    item: B,
    message: z,
    _run(Y, ie) {
      var ne;
      const se = Y.value;
      if (Array.isArray(se)) {
        Y.typed = !0, Y.value = [];
        for (let ae = 0; ae < se.length; ae++) {
          const le = se[ae], ge = this.item._run({ typed: !1, value: le }, ie);
          if (ge.issues) {
            const Ee = {
              type: "array",
              origin: "value",
              input: se,
              key: ae,
              value: le
            };
            for (const oe of ge.issues)
              oe.path ? oe.path.unshift(Ee) : oe.path = [Ee], (ne = Y.issues) == null || ne.push(oe);
            if (Y.issues || (Y.issues = ge.issues), ie.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ge.typed || (Y.typed = !1), Y.value.push(ge.value);
        }
      } else
        _addIssue(this, "type", Y, ie);
      return Y;
    }
  };
}
function boolean(B) {
  return {
    kind: "schema",
    type: "boolean",
    reference: boolean,
    expects: "boolean",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "boolean" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function enum_(B, z) {
  const Y = Object.entries(B).filter(([ie]) => isNaN(+ie)).map(([, ie]) => ie);
  return {
    kind: "schema",
    type: "enum",
    reference: enum_,
    expects: _joinExpects(Y.map(_stringify), "|"),
    async: !1,
    enum: B,
    options: Y,
    message: z,
    _run(ie, se) {
      return this.options.includes(ie.value) ? ie.typed = !0 : _addIssue(this, "type", ie, se), ie;
    }
  };
}
function literal(B, z) {
  return {
    kind: "schema",
    type: "literal",
    reference: literal,
    expects: _stringify(B),
    async: !1,
    literal: B,
    message: z,
    _run(Y, ie) {
      return Y.value === this.literal ? Y.typed = !0 : _addIssue(this, "type", Y, ie), Y;
    }
  };
}
function looseObject(B, z) {
  return {
    kind: "schema",
    type: "loose_object",
    reference: looseObject,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ie) {
      var ne;
      const se = Y.value;
      if (se && typeof se == "object") {
        Y.typed = !0, Y.value = {};
        for (const ae in this.entries) {
          const le = se[ae], ge = this.entries[ae]._run(
            { typed: !1, value: le },
            ie
          );
          if (ge.issues) {
            const Ee = {
              type: "object",
              origin: "value",
              input: se,
              key: ae,
              value: le
            };
            for (const oe of ge.issues)
              oe.path ? oe.path.unshift(Ee) : oe.path = [Ee], (ne = Y.issues) == null || ne.push(oe);
            if (Y.issues || (Y.issues = ge.issues), ie.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ge.typed || (Y.typed = !1), (ge.value !== void 0 || ae in se) && (Y.value[ae] = ge.value);
        }
        if (!Y.issues || !ie.abortEarly)
          for (const ae in se)
            _isValidObjectKey(se, ae) && !(ae in this.entries) && (Y.value[ae] = se[ae]);
      } else
        _addIssue(this, "type", Y, ie);
      return Y;
    }
  };
}
function nonOptional(B, z) {
  return {
    kind: "schema",
    type: "non_optional",
    reference: nonOptional,
    expects: "!undefined",
    async: !1,
    wrapped: B,
    message: z,
    _run(Y, ie) {
      return Y.value === void 0 ? (_addIssue(this, "type", Y, ie), Y) : this.wrapped._run(Y, ie);
    }
  };
}
function null_(B) {
  return {
    kind: "schema",
    type: "null",
    reference: null_,
    expects: "null",
    async: !1,
    message: B,
    _run(z, Y) {
      return z.value === null ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function nullish(B, ...z) {
  const Y = {
    kind: "schema",
    type: "nullish",
    reference: nullish,
    expects: `(${B.expects} | null | undefined)`,
    async: !1,
    wrapped: B,
    _run(ie, se) {
      return (ie.value === null || ie.value === void 0) && ("default" in this && (ie.value = getDefault(
        this,
        ie,
        se
      )), ie.value === null || ie.value === void 0) ? (ie.typed = !0, ie) : this.wrapped._run(ie, se);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function number(B) {
  return {
    kind: "schema",
    type: "number",
    reference: number,
    expects: "number",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "number" && !isNaN(z.value) ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function object(B, z) {
  return {
    kind: "schema",
    type: "object",
    reference: object,
    expects: "Object",
    async: !1,
    entries: B,
    message: z,
    _run(Y, ie) {
      var ne;
      const se = Y.value;
      if (se && typeof se == "object") {
        Y.typed = !0, Y.value = {};
        for (const ae in this.entries) {
          const le = se[ae], ge = this.entries[ae]._run(
            { typed: !1, value: le },
            ie
          );
          if (ge.issues) {
            const Ee = {
              type: "object",
              origin: "value",
              input: se,
              key: ae,
              value: le
            };
            for (const oe of ge.issues)
              oe.path ? oe.path.unshift(Ee) : oe.path = [Ee], (ne = Y.issues) == null || ne.push(oe);
            if (Y.issues || (Y.issues = ge.issues), ie.abortEarly) {
              Y.typed = !1;
              break;
            }
          }
          ge.typed || (Y.typed = !1), (ge.value !== void 0 || ae in se) && (Y.value[ae] = ge.value);
        }
      } else
        _addIssue(this, "type", Y, ie);
      return Y;
    }
  };
}
function optional(B, ...z) {
  const Y = {
    kind: "schema",
    type: "optional",
    reference: optional,
    expects: `(${B.expects} | undefined)`,
    async: !1,
    wrapped: B,
    _run(ie, se) {
      return ie.value === void 0 && ("default" in this && (ie.value = getDefault(
        this,
        ie,
        se
      )), ie.value === void 0) ? (ie.typed = !0, ie) : this.wrapped._run(ie, se);
    }
  };
  return 0 in z && (Y.default = z[0]), Y;
}
function picklist(B, z) {
  return {
    kind: "schema",
    type: "picklist",
    reference: picklist,
    expects: _joinExpects(B.map(_stringify), "|"),
    async: !1,
    options: B,
    message: z,
    _run(Y, ie) {
      return this.options.includes(Y.value) ? Y.typed = !0 : _addIssue(this, "type", Y, ie), Y;
    }
  };
}
function record(B, z, Y) {
  return {
    kind: "schema",
    type: "record",
    reference: record,
    expects: "Object",
    async: !1,
    key: B,
    value: z,
    message: Y,
    _run(ie, se) {
      var ae, le;
      const ne = ie.value;
      if (ne && typeof ne == "object") {
        ie.typed = !0, ie.value = {};
        for (const ge in ne)
          if (_isValidObjectKey(ne, ge)) {
            const Ee = ne[ge], oe = this.key._run(
              { typed: !1, value: ge },
              se
            );
            if (oe.issues) {
              const Ve = {
                type: "object",
                origin: "key",
                input: ne,
                key: ge,
                value: Ee
              };
              for (const Ke of oe.issues)
                Ke.path = [Ve], (ae = ie.issues) == null || ae.push(Ke);
              if (ie.issues || (ie.issues = oe.issues), se.abortEarly) {
                ie.typed = !1;
                break;
              }
            }
            const Pe = this.value._run(
              { typed: !1, value: Ee },
              se
            );
            if (Pe.issues) {
              const Ve = {
                type: "object",
                origin: "value",
                input: ne,
                key: ge,
                value: Ee
              };
              for (const Ke of Pe.issues)
                Ke.path ? Ke.path.unshift(Ve) : Ke.path = [Ve], (le = ie.issues) == null || le.push(Ke);
              if (ie.issues || (ie.issues = Pe.issues), se.abortEarly) {
                ie.typed = !1;
                break;
              }
            }
            (!oe.typed || !Pe.typed) && (ie.typed = !1), oe.typed && (ie.value[oe.value] = Pe.value);
          }
      } else
        _addIssue(this, "type", ie, se);
      return ie;
    }
  };
}
function string(B) {
  return {
    kind: "schema",
    type: "string",
    reference: string,
    expects: "string",
    async: !1,
    message: B,
    _run(z, Y) {
      return typeof z.value == "string" ? z.typed = !0 : _addIssue(this, "type", z, Y), z;
    }
  };
}
function _subIssues(B) {
  let z;
  if (B)
    for (const Y of B)
      z ? z.push(...Y.issues) : z = Y.issues;
  return z;
}
function union(B, z) {
  return {
    kind: "schema",
    type: "union",
    reference: union,
    expects: _joinExpects(
      B.map((Y) => Y.expects),
      "|"
    ),
    async: !1,
    options: B,
    message: z,
    _run(Y, ie) {
      let se, ne, ae;
      for (const le of this.options) {
        const ge = le._run(
          { typed: !1, value: Y.value },
          ie
        );
        if (ge.typed)
          if (ge.issues)
            ne ? ne.push(ge) : ne = [ge];
          else {
            se = ge;
            break;
          }
        else
          ae ? ae.push(ge) : ae = [ge];
      }
      if (se)
        return se;
      if (ne) {
        if (ne.length === 1)
          return ne[0];
        _addIssue(this, "type", Y, ie, {
          issues: _subIssues(ne)
        }), Y.typed = !0;
      } else {
        if ((ae == null ? void 0 : ae.length) === 1)
          return ae[0];
        _addIssue(this, "type", Y, ie, {
          issues: _subIssues(ae)
        });
      }
      return Y;
    }
  };
}
function unknown() {
  return {
    kind: "schema",
    type: "unknown",
    reference: unknown,
    expects: "unknown",
    async: !1,
    _run(B) {
      return B.typed = !0, B;
    }
  };
}
function variant(B, z, Y) {
  return {
    kind: "schema",
    type: "variant",
    reference: variant,
    expects: "Object",
    async: !1,
    key: B,
    options: z,
    message: Y,
    _run(ie, se) {
      const ne = ie.value;
      if (ne && typeof ne == "object") {
        let ae, le = 0, ge = this.key, Ee = [];
        const oe = (Pe, Ve) => {
          for (const Ke of Pe.options) {
            if (Ke.type === "variant")
              oe(Ke, new Set(Ve).add(Ke.key));
            else {
              let ht = !0, _t = 0;
              for (const Rt of Ve) {
                if (Ke.entries[Rt]._run(
                  // @ts-expect-error
                  { typed: !1, value: ne[Rt] },
                  se
                ).issues) {
                  ht = !1, ge !== Rt && (le < _t || le === _t && Rt in ne && !(ge in ne)) && (le = _t, ge = Rt, Ee = []), ge === Rt && Ee.push(
                    Ke.entries[Rt].expects
                  );
                  break;
                }
                _t++;
              }
              if (ht) {
                const Rt = Ke._run(
                  { typed: !1, value: ne },
                  se
                );
                (!ae || !ae.typed && Rt.typed) && (ae = Rt);
              }
            }
            if (ae && !ae.issues)
              break;
          }
        };
        if (oe(this, /* @__PURE__ */ new Set([this.key])), ae)
          return ae;
        _addIssue(this, "type", ie, se, {
          // @ts-expect-error
          input: ne[ge],
          expected: _joinExpects(Ee, "|"),
          path: [
            {
              type: "object",
              origin: "value",
              input: ne,
              key: ge,
              // @ts-expect-error
              value: ne[ge]
            }
          ]
        });
      } else
        _addIssue(this, "type", ie, se);
      return ie;
    }
  };
}
function omit(B, z) {
  const Y = {
    ...B.entries
  };
  for (const ie of z)
    delete Y[ie];
  return { ...B, entries: Y };
}
function pipe(...B) {
  return {
    ...B[0],
    pipe: B,
    _run(z, Y) {
      for (const ie of B)
        if (ie.kind !== "metadata") {
          if (z.issues && (ie.kind === "schema" || ie.kind === "transformation")) {
            z.typed = !1;
            break;
          }
          (!z.issues || !Y.abortEarly && !Y.abortPipeEarly) && (z = ie._run(z, Y));
        }
      return z;
    }
  };
}
function unwrap(B) {
  return B.wrapped;
}
var lib$1 = {}, signer = {}, base64Url = {}, base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1)
  lookup[i$1] = code[i$1], revLookup[code.charCodeAt(i$1)] = i$1;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(B) {
  var z = B.length;
  if (z % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var Y = B.indexOf("=");
  Y === -1 && (Y = z);
  var ie = Y === z ? 0 : 4 - Y % 4;
  return [Y, ie];
}
function byteLength(B) {
  var z = getLens(B), Y = z[0], ie = z[1];
  return (Y + ie) * 3 / 4 - ie;
}
function _byteLength(B, z, Y) {
  return (z + Y) * 3 / 4 - Y;
}
function toByteArray(B) {
  var z, Y = getLens(B), ie = Y[0], se = Y[1], ne = new Arr(_byteLength(B, ie, se)), ae = 0, le = se > 0 ? ie - 4 : ie, ge;
  for (ge = 0; ge < le; ge += 4)
    z = revLookup[B.charCodeAt(ge)] << 18 | revLookup[B.charCodeAt(ge + 1)] << 12 | revLookup[B.charCodeAt(ge + 2)] << 6 | revLookup[B.charCodeAt(ge + 3)], ne[ae++] = z >> 16 & 255, ne[ae++] = z >> 8 & 255, ne[ae++] = z & 255;
  return se === 2 && (z = revLookup[B.charCodeAt(ge)] << 2 | revLookup[B.charCodeAt(ge + 1)] >> 4, ne[ae++] = z & 255), se === 1 && (z = revLookup[B.charCodeAt(ge)] << 10 | revLookup[B.charCodeAt(ge + 1)] << 4 | revLookup[B.charCodeAt(ge + 2)] >> 2, ne[ae++] = z >> 8 & 255, ne[ae++] = z & 255), ne;
}
function tripletToBase64(B) {
  return lookup[B >> 18 & 63] + lookup[B >> 12 & 63] + lookup[B >> 6 & 63] + lookup[B & 63];
}
function encodeChunk(B, z, Y) {
  for (var ie, se = [], ne = z; ne < Y; ne += 3)
    ie = (B[ne] << 16 & 16711680) + (B[ne + 1] << 8 & 65280) + (B[ne + 2] & 255), se.push(tripletToBase64(ie));
  return se.join("");
}
function fromByteArray(B) {
  for (var z, Y = B.length, ie = Y % 3, se = [], ne = 16383, ae = 0, le = Y - ie; ae < le; ae += ne)
    se.push(encodeChunk(B, ae, ae + ne > le ? le : ae + ne));
  return ie === 1 ? (z = B[Y - 1], se.push(
    lookup[z >> 2] + lookup[z << 4 & 63] + "=="
  )) : ie === 2 && (z = (B[Y - 2] << 8) + B[Y - 1], se.push(
    lookup[z >> 10] + lookup[z >> 4 & 63] + lookup[z << 2 & 63] + "="
  )), se.join("");
}
Object.defineProperty(base64Url, "__esModule", { value: !0 });
base64Url.decode = base64Url.encode = base64Url.unescape = base64Url.escape = base64Url.pad = void 0;
const base64_js_1$1 = base64Js;
function pad(B) {
  return `${B}${"=".repeat(4 - (B.length % 4 || 4))}`;
}
base64Url.pad = pad;
function escape(B) {
  return B.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
base64Url.escape = escape;
function unescape(B) {
  return pad(B).replace(/-/g, "+").replace(/_/g, "/");
}
base64Url.unescape = unescape;
function encode$j(B) {
  return escape((0, base64_js_1$1.fromByteArray)(new TextEncoder().encode(B)));
}
base64Url.encode = encode$j;
function decode$j(B) {
  return new TextDecoder().decode((0, base64_js_1$1.toByteArray)(pad(unescape(B))));
}
base64Url.decode = decode$j;
var cryptoClients = {}, secp256k1$1 = {}, hmac$1 = {}, _assert = {};
Object.defineProperty(_assert, "__esModule", { value: !0 });
_assert.anumber = anumber;
_assert.abytes = abytes;
_assert.ahash = ahash;
_assert.aexists = aexists;
_assert.aoutput = aoutput;
function anumber(B) {
  if (!Number.isSafeInteger(B) || B < 0)
    throw new Error("positive integer expected, got " + B);
}
function isBytes(B) {
  return B instanceof Uint8Array || ArrayBuffer.isView(B) && B.constructor.name === "Uint8Array";
}
function abytes(B, ...z) {
  if (!isBytes(B))
    throw new Error("Uint8Array expected");
  if (z.length > 0 && !z.includes(B.length))
    throw new Error("Uint8Array expected of length " + z + ", got length=" + B.length);
}
function ahash(B) {
  if (typeof B != "function" || typeof B.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber(B.outputLen), anumber(B.blockLen);
}
function aexists(B, z = !0) {
  if (B.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (z && B.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(B, z) {
  abytes(B);
  const Y = z.outputLen;
  if (B.length < Y)
    throw new Error("digestInto() expects output buffer of length at least " + Y);
}
var utils$5 = {}, crypto$2 = {};
Object.defineProperty(crypto$2, "__esModule", { value: !0 });
crypto$2.crypto = void 0;
crypto$2.crypto = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
(function(B) {
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.Hash = B.nextTick = B.byteSwapIfBE = B.isLE = void 0, B.isBytes = ie, B.u8 = se, B.u32 = ne, B.createView = ae, B.rotr = le, B.rotl = ge, B.byteSwap = Ee, B.byteSwap32 = oe, B.bytesToHex = Ve, B.hexToBytes = _t, B.asyncLoop = kt, B.utf8ToBytes = Bt, B.toBytes = Ct, B.concatBytes = qt, B.checkOpts = Ht, B.wrapConstructor = Yt, B.wrapConstructorWithOpts = Ut, B.wrapXOFConstructorWithOpts = Nt, B.randomBytes = Kt;
  const z = crypto$2, Y = _assert;
  function ie(Ft) {
    return Ft instanceof Uint8Array || ArrayBuffer.isView(Ft) && Ft.constructor.name === "Uint8Array";
  }
  function se(Ft) {
    return new Uint8Array(Ft.buffer, Ft.byteOffset, Ft.byteLength);
  }
  function ne(Ft) {
    return new Uint32Array(Ft.buffer, Ft.byteOffset, Math.floor(Ft.byteLength / 4));
  }
  function ae(Ft) {
    return new DataView(Ft.buffer, Ft.byteOffset, Ft.byteLength);
  }
  function le(Ft, bt) {
    return Ft << 32 - bt | Ft >>> bt;
  }
  function ge(Ft, bt) {
    return Ft << bt | Ft >>> 32 - bt >>> 0;
  }
  B.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  function Ee(Ft) {
    return Ft << 24 & 4278190080 | Ft << 8 & 16711680 | Ft >>> 8 & 65280 | Ft >>> 24 & 255;
  }
  B.byteSwapIfBE = B.isLE ? (Ft) => Ft : (Ft) => Ee(Ft);
  function oe(Ft) {
    for (let bt = 0; bt < Ft.length; bt++)
      Ft[bt] = Ee(Ft[bt]);
  }
  const Pe = /* @__PURE__ */ Array.from({ length: 256 }, (Ft, bt) => bt.toString(16).padStart(2, "0"));
  function Ve(Ft) {
    (0, Y.abytes)(Ft);
    let bt = "";
    for (let Xe = 0; Xe < Ft.length; Xe++)
      bt += Pe[Ft[Xe]];
    return bt;
  }
  const Ke = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
  function ht(Ft) {
    if (Ft >= Ke._0 && Ft <= Ke._9)
      return Ft - Ke._0;
    if (Ft >= Ke.A && Ft <= Ke.F)
      return Ft - (Ke.A - 10);
    if (Ft >= Ke.a && Ft <= Ke.f)
      return Ft - (Ke.a - 10);
  }
  function _t(Ft) {
    if (typeof Ft != "string")
      throw new Error("hex string expected, got " + typeof Ft);
    const bt = Ft.length, Xe = bt / 2;
    if (bt % 2)
      throw new Error("hex string expected, got unpadded hex of length " + bt);
    const ve = new Uint8Array(Xe);
    for (let Ce = 0, Qe = 0; Ce < Xe; Ce++, Qe += 2) {
      const vt = ht(Ft.charCodeAt(Qe)), wt = ht(Ft.charCodeAt(Qe + 1));
      if (vt === void 0 || wt === void 0) {
        const $t = Ft[Qe] + Ft[Qe + 1];
        throw new Error('hex string expected, got non-hex character "' + $t + '" at index ' + Qe);
      }
      ve[Ce] = vt * 16 + wt;
    }
    return ve;
  }
  const Rt = async () => {
  };
  B.nextTick = Rt;
  async function kt(Ft, bt, Xe) {
    let ve = Date.now();
    for (let Ce = 0; Ce < Ft; Ce++) {
      Xe(Ce);
      const Qe = Date.now() - ve;
      Qe >= 0 && Qe < bt || (await (0, B.nextTick)(), ve += Qe);
    }
  }
  function Bt(Ft) {
    if (typeof Ft != "string")
      throw new Error("utf8ToBytes expected string, got " + typeof Ft);
    return new Uint8Array(new TextEncoder().encode(Ft));
  }
  function Ct(Ft) {
    return typeof Ft == "string" && (Ft = Bt(Ft)), (0, Y.abytes)(Ft), Ft;
  }
  function qt(...Ft) {
    let bt = 0;
    for (let ve = 0; ve < Ft.length; ve++) {
      const Ce = Ft[ve];
      (0, Y.abytes)(Ce), bt += Ce.length;
    }
    const Xe = new Uint8Array(bt);
    for (let ve = 0, Ce = 0; ve < Ft.length; ve++) {
      const Qe = Ft[ve];
      Xe.set(Qe, Ce), Ce += Qe.length;
    }
    return Xe;
  }
  class jt {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  }
  B.Hash = jt;
  function Ht(Ft, bt) {
    if (bt !== void 0 && {}.toString.call(bt) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    return Object.assign(Ft, bt);
  }
  function Yt(Ft) {
    const bt = (ve) => Ft().update(Ct(ve)).digest(), Xe = Ft();
    return bt.outputLen = Xe.outputLen, bt.blockLen = Xe.blockLen, bt.create = () => Ft(), bt;
  }
  function Ut(Ft) {
    const bt = (ve, Ce) => Ft(Ce).update(Ct(ve)).digest(), Xe = Ft({});
    return bt.outputLen = Xe.outputLen, bt.blockLen = Xe.blockLen, bt.create = (ve) => Ft(ve), bt;
  }
  function Nt(Ft) {
    const bt = (ve, Ce) => Ft(Ce).update(Ct(ve)).digest(), Xe = Ft({});
    return bt.outputLen = Xe.outputLen, bt.blockLen = Xe.blockLen, bt.create = (ve) => Ft(ve), bt;
  }
  function Kt(Ft = 32) {
    if (z.crypto && typeof z.crypto.getRandomValues == "function")
      return z.crypto.getRandomValues(new Uint8Array(Ft));
    if (z.crypto && typeof z.crypto.randomBytes == "function")
      return z.crypto.randomBytes(Ft);
    throw new Error("crypto.getRandomValues must be defined");
  }
})(utils$5);
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.hmac = B.HMAC = void 0;
  const z = _assert, Y = utils$5;
  class ie extends Y.Hash {
    constructor(ae, le) {
      super(), this.finished = !1, this.destroyed = !1, (0, z.ahash)(ae);
      const ge = (0, Y.toBytes)(le);
      if (this.iHash = ae.create(), typeof this.iHash.update != "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
      const Ee = this.blockLen, oe = new Uint8Array(Ee);
      oe.set(ge.length > Ee ? ae.create().update(ge).digest() : ge);
      for (let Pe = 0; Pe < oe.length; Pe++)
        oe[Pe] ^= 54;
      this.iHash.update(oe), this.oHash = ae.create();
      for (let Pe = 0; Pe < oe.length; Pe++)
        oe[Pe] ^= 106;
      this.oHash.update(oe), oe.fill(0);
    }
    update(ae) {
      return (0, z.aexists)(this), this.iHash.update(ae), this;
    }
    digestInto(ae) {
      (0, z.aexists)(this), (0, z.abytes)(ae, this.outputLen), this.finished = !0, this.iHash.digestInto(ae), this.oHash.update(ae), this.oHash.digestInto(ae), this.destroy();
    }
    digest() {
      const ae = new Uint8Array(this.oHash.outputLen);
      return this.digestInto(ae), ae;
    }
    _cloneInto(ae) {
      ae || (ae = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash: le, iHash: ge, finished: Ee, destroyed: oe, blockLen: Pe, outputLen: Ve } = this;
      return ae = ae, ae.finished = Ee, ae.destroyed = oe, ae.blockLen = Pe, ae.outputLen = Ve, ae.oHash = le._cloneInto(ae.oHash), ae.iHash = ge._cloneInto(ae.iHash), ae;
    }
    destroy() {
      this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
    }
  }
  B.HMAC = ie;
  const se = (ne, ae, le) => new ie(ne, ae).update(le).digest();
  B.hmac = se, B.hmac.create = (ne, ae) => new ie(ne, ae);
})(hmac$1);
var sha256$4 = {}, _md = {};
Object.defineProperty(_md, "__esModule", { value: !0 });
_md.HashMD = void 0;
_md.setBigUint64 = setBigUint64;
_md.Chi = Chi;
_md.Maj = Maj;
const _assert_js_1 = _assert, utils_js_1$3 = utils$5;
function setBigUint64(B, z, Y, ie) {
  if (typeof B.setBigUint64 == "function")
    return B.setBigUint64(z, Y, ie);
  const se = BigInt(32), ne = BigInt(4294967295), ae = Number(Y >> se & ne), le = Number(Y & ne), ge = ie ? 4 : 0, Ee = ie ? 0 : 4;
  B.setUint32(z + ge, ae, ie), B.setUint32(z + Ee, le, ie);
}
function Chi(B, z, Y) {
  return B & z ^ ~B & Y;
}
function Maj(B, z, Y) {
  return B & z ^ B & Y ^ z & Y;
}
class HashMD extends utils_js_1$3.Hash {
  constructor(z, Y, ie, se) {
    super(), this.blockLen = z, this.outputLen = Y, this.padOffset = ie, this.isLE = se, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(z), this.view = (0, utils_js_1$3.createView)(this.buffer);
  }
  update(z) {
    (0, _assert_js_1.aexists)(this);
    const { view: Y, buffer: ie, blockLen: se } = this;
    z = (0, utils_js_1$3.toBytes)(z);
    const ne = z.length;
    for (let ae = 0; ae < ne; ) {
      const le = Math.min(se - this.pos, ne - ae);
      if (le === se) {
        const ge = (0, utils_js_1$3.createView)(z);
        for (; se <= ne - ae; ae += se)
          this.process(ge, ae);
        continue;
      }
      ie.set(z.subarray(ae, ae + le), this.pos), this.pos += le, ae += le, this.pos === se && (this.process(Y, 0), this.pos = 0);
    }
    return this.length += z.length, this.roundClean(), this;
  }
  digestInto(z) {
    (0, _assert_js_1.aexists)(this), (0, _assert_js_1.aoutput)(z, this), this.finished = !0;
    const { buffer: Y, view: ie, blockLen: se, isLE: ne } = this;
    let { pos: ae } = this;
    Y[ae++] = 128, this.buffer.subarray(ae).fill(0), this.padOffset > se - ae && (this.process(ie, 0), ae = 0);
    for (let Pe = ae; Pe < se; Pe++)
      Y[Pe] = 0;
    setBigUint64(ie, se - 8, BigInt(this.length * 8), ne), this.process(ie, 0);
    const le = (0, utils_js_1$3.createView)(z), ge = this.outputLen;
    if (ge % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const Ee = ge / 4, oe = this.get();
    if (Ee > oe.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let Pe = 0; Pe < Ee; Pe++)
      le.setUint32(4 * Pe, oe[Pe], ne);
  }
  digest() {
    const { buffer: z, outputLen: Y } = this;
    this.digestInto(z);
    const ie = z.slice(0, Y);
    return this.destroy(), ie;
  }
  _cloneInto(z) {
    z || (z = new this.constructor()), z.set(...this.get());
    const { blockLen: Y, buffer: ie, length: se, finished: ne, destroyed: ae, pos: le } = this;
    return z.length = se, z.pos = le, z.finished = ne, z.destroyed = ae, se % Y && z.buffer.set(ie), z;
  }
}
_md.HashMD = HashMD;
Object.defineProperty(sha256$4, "__esModule", { value: !0 });
sha256$4.sha224 = sha256$4.sha256 = sha256$4.SHA256 = void 0;
const _md_js_1$2 = _md, utils_js_1$2 = utils$5, SHA256_K = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), SHA256_IV = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends _md_js_1$2.HashMD {
  constructor() {
    super(64, 32, 8, !1), this.A = SHA256_IV[0] | 0, this.B = SHA256_IV[1] | 0, this.C = SHA256_IV[2] | 0, this.D = SHA256_IV[3] | 0, this.E = SHA256_IV[4] | 0, this.F = SHA256_IV[5] | 0, this.G = SHA256_IV[6] | 0, this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: z, B: Y, C: ie, D: se, E: ne, F: ae, G: le, H: ge } = this;
    return [z, Y, ie, se, ne, ae, le, ge];
  }
  // prettier-ignore
  set(z, Y, ie, se, ne, ae, le, ge) {
    this.A = z | 0, this.B = Y | 0, this.C = ie | 0, this.D = se | 0, this.E = ne | 0, this.F = ae | 0, this.G = le | 0, this.H = ge | 0;
  }
  process(z, Y) {
    for (let Pe = 0; Pe < 16; Pe++, Y += 4)
      SHA256_W[Pe] = z.getUint32(Y, !1);
    for (let Pe = 16; Pe < 64; Pe++) {
      const Ve = SHA256_W[Pe - 15], Ke = SHA256_W[Pe - 2], ht = (0, utils_js_1$2.rotr)(Ve, 7) ^ (0, utils_js_1$2.rotr)(Ve, 18) ^ Ve >>> 3, _t = (0, utils_js_1$2.rotr)(Ke, 17) ^ (0, utils_js_1$2.rotr)(Ke, 19) ^ Ke >>> 10;
      SHA256_W[Pe] = _t + SHA256_W[Pe - 7] + ht + SHA256_W[Pe - 16] | 0;
    }
    let { A: ie, B: se, C: ne, D: ae, E: le, F: ge, G: Ee, H: oe } = this;
    for (let Pe = 0; Pe < 64; Pe++) {
      const Ve = (0, utils_js_1$2.rotr)(le, 6) ^ (0, utils_js_1$2.rotr)(le, 11) ^ (0, utils_js_1$2.rotr)(le, 25), Ke = oe + Ve + (0, _md_js_1$2.Chi)(le, ge, Ee) + SHA256_K[Pe] + SHA256_W[Pe] | 0, _t = ((0, utils_js_1$2.rotr)(ie, 2) ^ (0, utils_js_1$2.rotr)(ie, 13) ^ (0, utils_js_1$2.rotr)(ie, 22)) + (0, _md_js_1$2.Maj)(ie, se, ne) | 0;
      oe = Ee, Ee = ge, ge = le, le = ae + Ke | 0, ae = ne, ne = se, se = ie, ie = Ke + _t | 0;
    }
    ie = ie + this.A | 0, se = se + this.B | 0, ne = ne + this.C | 0, ae = ae + this.D | 0, le = le + this.E | 0, ge = ge + this.F | 0, Ee = Ee + this.G | 0, oe = oe + this.H | 0, this.set(ie, se, ne, ae, le, ge, Ee, oe);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha256$4.SHA256 = SHA256;
class SHA224 extends SHA256 {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
}
sha256$4.sha256 = (0, utils_js_1$2.wrapConstructor)(() => new SHA256());
sha256$4.sha224 = (0, utils_js_1$2.wrapConstructor)(() => new SHA224());
var lib = {}, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} };
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(dist$1);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(B, z) {
  var Y = require$$0$1, ie = Y.Buffer;
  function se(ae, le) {
    for (var ge in ae)
      le[ge] = ae[ge];
  }
  ie.from && ie.alloc && ie.allocUnsafe && ie.allocUnsafeSlow ? B.exports = Y : (se(Y, z), z.Buffer = ne);
  function ne(ae, le, ge) {
    return ie(ae, le, ge);
  }
  ne.prototype = Object.create(ie.prototype), se(ie, ne), ne.from = function(ae, le, ge) {
    if (typeof ae == "number")
      throw new TypeError("Argument must not be a number");
    return ie(ae, le, ge);
  }, ne.alloc = function(ae, le, ge) {
    if (typeof ae != "number")
      throw new TypeError("Argument must be a number");
    var Ee = ie(ae);
    return le !== void 0 ? typeof ge == "string" ? Ee.fill(le, ge) : Ee.fill(le) : Ee.fill(0), Ee;
  }, ne.allocUnsafe = function(ae) {
    if (typeof ae != "number")
      throw new TypeError("Argument must be a number");
    return ie(ae);
  }, ne.allocUnsafeSlow = function(ae) {
    if (typeof ae != "number")
      throw new TypeError("Argument must be a number");
    return Y.SlowBuffer(ae);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b) return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var B = 65536, z = 4294967295;
  function Y() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var ie = safeBufferExports.Buffer, se = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  se && se.getRandomValues ? browser$b.exports = ne : browser$b.exports = Y;
  function ne(ae, le) {
    if (ae > z) throw new RangeError("requested too many random bytes");
    var ge = ie.allocUnsafe(ae);
    if (ae > 0)
      if (ae > B)
        for (var Ee = 0; Ee < ae; Ee += B)
          se.getRandomValues(ge.slice(Ee, Ee + B));
      else
        se.getRandomValues(ge);
    return typeof le == "function" ? process$1.nextTick(function() {
      le(null, ge);
    }) : ge;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(z, Y) {
    Y && (z.super_ = Y, z.prototype = Object.create(Y.prototype, {
      constructor: {
        value: z,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(z, Y) {
    if (Y) {
      z.super_ = Y;
      var ie = function() {
      };
      ie.prototype = Y.prototype, z.prototype = new ie(), z.prototype.constructor = z;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var B = typeof Reflect == "object" ? Reflect : null, z = B && typeof B.apply == "function" ? B.apply : function(jt, Ht, Yt) {
    return Function.prototype.apply.call(jt, Ht, Yt);
  }, Y;
  B && typeof B.ownKeys == "function" ? Y = B.ownKeys : Object.getOwnPropertySymbols ? Y = function(jt) {
    return Object.getOwnPropertyNames(jt).concat(Object.getOwnPropertySymbols(jt));
  } : Y = function(jt) {
    return Object.getOwnPropertyNames(jt);
  };
  function ie(qt) {
    console && console.warn && console.warn(qt);
  }
  var se = Number.isNaN || function(jt) {
    return jt !== jt;
  };
  function ne() {
    ne.init.call(this);
  }
  events.exports = ne, events.exports.once = kt, ne.EventEmitter = ne, ne.prototype._events = void 0, ne.prototype._eventsCount = 0, ne.prototype._maxListeners = void 0;
  var ae = 10;
  function le(qt) {
    if (typeof qt != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof qt);
  }
  Object.defineProperty(ne, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return ae;
    },
    set: function(qt) {
      if (typeof qt != "number" || qt < 0 || se(qt))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + qt + ".");
      ae = qt;
    }
  }), ne.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, ne.prototype.setMaxListeners = function(jt) {
    if (typeof jt != "number" || jt < 0 || se(jt))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + jt + ".");
    return this._maxListeners = jt, this;
  };
  function ge(qt) {
    return qt._maxListeners === void 0 ? ne.defaultMaxListeners : qt._maxListeners;
  }
  ne.prototype.getMaxListeners = function() {
    return ge(this);
  }, ne.prototype.emit = function(jt) {
    for (var Ht = [], Yt = 1; Yt < arguments.length; Yt++) Ht.push(arguments[Yt]);
    var Ut = jt === "error", Nt = this._events;
    if (Nt !== void 0)
      Ut = Ut && Nt.error === void 0;
    else if (!Ut)
      return !1;
    if (Ut) {
      var Kt;
      if (Ht.length > 0 && (Kt = Ht[0]), Kt instanceof Error)
        throw Kt;
      var Ft = new Error("Unhandled error." + (Kt ? " (" + Kt.message + ")" : ""));
      throw Ft.context = Kt, Ft;
    }
    var bt = Nt[jt];
    if (bt === void 0)
      return !1;
    if (typeof bt == "function")
      z(bt, this, Ht);
    else
      for (var Xe = bt.length, ve = ht(bt, Xe), Yt = 0; Yt < Xe; ++Yt)
        z(ve[Yt], this, Ht);
    return !0;
  };
  function Ee(qt, jt, Ht, Yt) {
    var Ut, Nt, Kt;
    if (le(Ht), Nt = qt._events, Nt === void 0 ? (Nt = qt._events = /* @__PURE__ */ Object.create(null), qt._eventsCount = 0) : (Nt.newListener !== void 0 && (qt.emit(
      "newListener",
      jt,
      Ht.listener ? Ht.listener : Ht
    ), Nt = qt._events), Kt = Nt[jt]), Kt === void 0)
      Kt = Nt[jt] = Ht, ++qt._eventsCount;
    else if (typeof Kt == "function" ? Kt = Nt[jt] = Yt ? [Ht, Kt] : [Kt, Ht] : Yt ? Kt.unshift(Ht) : Kt.push(Ht), Ut = ge(qt), Ut > 0 && Kt.length > Ut && !Kt.warned) {
      Kt.warned = !0;
      var Ft = new Error("Possible EventEmitter memory leak detected. " + Kt.length + " " + String(jt) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      Ft.name = "MaxListenersExceededWarning", Ft.emitter = qt, Ft.type = jt, Ft.count = Kt.length, ie(Ft);
    }
    return qt;
  }
  ne.prototype.addListener = function(jt, Ht) {
    return Ee(this, jt, Ht, !1);
  }, ne.prototype.on = ne.prototype.addListener, ne.prototype.prependListener = function(jt, Ht) {
    return Ee(this, jt, Ht, !0);
  };
  function oe() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Pe(qt, jt, Ht) {
    var Yt = { fired: !1, wrapFn: void 0, target: qt, type: jt, listener: Ht }, Ut = oe.bind(Yt);
    return Ut.listener = Ht, Yt.wrapFn = Ut, Ut;
  }
  ne.prototype.once = function(jt, Ht) {
    return le(Ht), this.on(jt, Pe(this, jt, Ht)), this;
  }, ne.prototype.prependOnceListener = function(jt, Ht) {
    return le(Ht), this.prependListener(jt, Pe(this, jt, Ht)), this;
  }, ne.prototype.removeListener = function(jt, Ht) {
    var Yt, Ut, Nt, Kt, Ft;
    if (le(Ht), Ut = this._events, Ut === void 0)
      return this;
    if (Yt = Ut[jt], Yt === void 0)
      return this;
    if (Yt === Ht || Yt.listener === Ht)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Ut[jt], Ut.removeListener && this.emit("removeListener", jt, Yt.listener || Ht));
    else if (typeof Yt != "function") {
      for (Nt = -1, Kt = Yt.length - 1; Kt >= 0; Kt--)
        if (Yt[Kt] === Ht || Yt[Kt].listener === Ht) {
          Ft = Yt[Kt].listener, Nt = Kt;
          break;
        }
      if (Nt < 0)
        return this;
      Nt === 0 ? Yt.shift() : _t(Yt, Nt), Yt.length === 1 && (Ut[jt] = Yt[0]), Ut.removeListener !== void 0 && this.emit("removeListener", jt, Ft || Ht);
    }
    return this;
  }, ne.prototype.off = ne.prototype.removeListener, ne.prototype.removeAllListeners = function(jt) {
    var Ht, Yt, Ut;
    if (Yt = this._events, Yt === void 0)
      return this;
    if (Yt.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Yt[jt] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Yt[jt]), this;
    if (arguments.length === 0) {
      var Nt = Object.keys(Yt), Kt;
      for (Ut = 0; Ut < Nt.length; ++Ut)
        Kt = Nt[Ut], Kt !== "removeListener" && this.removeAllListeners(Kt);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (Ht = Yt[jt], typeof Ht == "function")
      this.removeListener(jt, Ht);
    else if (Ht !== void 0)
      for (Ut = Ht.length - 1; Ut >= 0; Ut--)
        this.removeListener(jt, Ht[Ut]);
    return this;
  };
  function Ve(qt, jt, Ht) {
    var Yt = qt._events;
    if (Yt === void 0)
      return [];
    var Ut = Yt[jt];
    return Ut === void 0 ? [] : typeof Ut == "function" ? Ht ? [Ut.listener || Ut] : [Ut] : Ht ? Rt(Ut) : ht(Ut, Ut.length);
  }
  ne.prototype.listeners = function(jt) {
    return Ve(this, jt, !0);
  }, ne.prototype.rawListeners = function(jt) {
    return Ve(this, jt, !1);
  }, ne.listenerCount = function(qt, jt) {
    return typeof qt.listenerCount == "function" ? qt.listenerCount(jt) : Ke.call(qt, jt);
  }, ne.prototype.listenerCount = Ke;
  function Ke(qt) {
    var jt = this._events;
    if (jt !== void 0) {
      var Ht = jt[qt];
      if (typeof Ht == "function")
        return 1;
      if (Ht !== void 0)
        return Ht.length;
    }
    return 0;
  }
  ne.prototype.eventNames = function() {
    return this._eventsCount > 0 ? Y(this._events) : [];
  };
  function ht(qt, jt) {
    for (var Ht = new Array(jt), Yt = 0; Yt < jt; ++Yt)
      Ht[Yt] = qt[Yt];
    return Ht;
  }
  function _t(qt, jt) {
    for (; jt + 1 < qt.length; jt++)
      qt[jt] = qt[jt + 1];
    qt.pop();
  }
  function Rt(qt) {
    for (var jt = new Array(qt.length), Ht = 0; Ht < jt.length; ++Ht)
      jt[Ht] = qt[Ht].listener || qt[Ht];
    return jt;
  }
  function kt(qt, jt) {
    return new Promise(function(Ht, Yt) {
      function Ut(Kt) {
        qt.removeListener(jt, Nt), Yt(Kt);
      }
      function Nt() {
        typeof qt.removeListener == "function" && qt.removeListener("error", Ut), Ht([].slice.call(arguments));
      }
      Ct(qt, jt, Nt, { once: !0 }), jt !== "error" && Bt(qt, Ut, { once: !0 });
    });
  }
  function Bt(qt, jt, Ht) {
    typeof qt.on == "function" && Ct(qt, "error", jt, Ht);
  }
  function Ct(qt, jt, Ht, Yt) {
    if (typeof qt.on == "function")
      Yt.once ? qt.once(jt, Ht) : qt.on(jt, Ht);
    else if (typeof qt.addEventListener == "function")
      qt.addEventListener(jt, function Ut(Nt) {
        Yt.once && qt.removeEventListener(jt, Ut), Ht(Nt);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof qt);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types$5 = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var z = {}, Y = Symbol("test"), ie = Object(Y);
    if (typeof Y == "string" || Object.prototype.toString.call(Y) !== "[object Symbol]" || Object.prototype.toString.call(ie) !== "[object Symbol]")
      return !1;
    var se = 42;
    z[Y] = se;
    for (var ne in z)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(z).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(z).length !== 0)
      return !1;
    var ae = Object.getOwnPropertySymbols(z);
    if (ae.length !== 1 || ae[0] !== Y || !Object.prototype.propertyIsEnumerable.call(z, Y))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var le = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(z, Y)
      );
      if (le.value !== se || le.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var B = requireShams$1();
  return shams = function() {
    return B() && !!Symbol.toStringTag;
  }, shams;
}
var esObjectAtoms, hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  return hasRequiredEsObjectAtoms || (hasRequiredEsObjectAtoms = 1, esObjectAtoms = Object), esObjectAtoms;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range$3, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range$3 = RangeError), range$3;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var abs, hasRequiredAbs;
function requireAbs() {
  return hasRequiredAbs || (hasRequiredAbs = 1, abs = Math.abs), abs;
}
var floor, hasRequiredFloor;
function requireFloor() {
  return hasRequiredFloor || (hasRequiredFloor = 1, floor = Math.floor), floor;
}
var max, hasRequiredMax;
function requireMax() {
  return hasRequiredMax || (hasRequiredMax = 1, max = Math.max), max;
}
var min, hasRequiredMin;
function requireMin() {
  return hasRequiredMin || (hasRequiredMin = 1, min = Math.min), min;
}
var pow, hasRequiredPow;
function requirePow() {
  return hasRequiredPow || (hasRequiredPow = 1, pow = Math.pow), pow;
}
var round, hasRequiredRound;
function requireRound() {
  return hasRequiredRound || (hasRequiredRound = 1, round = Math.round), round;
}
var _isNaN, hasRequired_isNaN;
function require_isNaN() {
  return hasRequired_isNaN || (hasRequired_isNaN = 1, _isNaN = Number.isNaN || function(z) {
    return z !== z;
  }), _isNaN;
}
var sign$1, hasRequiredSign$1;
function requireSign$1() {
  if (hasRequiredSign$1) return sign$1;
  hasRequiredSign$1 = 1;
  var B = require_isNaN();
  return sign$1 = function(Y) {
    return B(Y) || Y === 0 ? Y : Y < 0 ? -1 : 1;
  }, sign$1;
}
var gOPD, hasRequiredGOPD;
function requireGOPD() {
  return hasRequiredGOPD || (hasRequiredGOPD = 1, gOPD = Object.getOwnPropertyDescriptor), gOPD;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var B = requireGOPD();
  if (B)
    try {
      B([], "length");
    } catch {
      B = null;
    }
  return gopd = B, gopd;
}
var esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var B = Object.defineProperty || !1;
  if (B)
    try {
      B({}, "a", { value: 1 });
    } catch {
      B = !1;
    }
  return esDefineProperty = B, esDefineProperty;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var B = typeof Symbol < "u" && Symbol, z = requireShams$1();
  return hasSymbols = function() {
    return typeof B != "function" || typeof Symbol != "function" || typeof B("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : z();
  }, hasSymbols;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var B = requireEsObjectAtoms();
  return Object_getPrototypeOf = B.getPrototypeOf || null, Object_getPrototypeOf;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var B = "Function.prototype.bind called on incompatible ", z = Object.prototype.toString, Y = Math.max, ie = "[object Function]", se = function(ge, Ee) {
    for (var oe = [], Pe = 0; Pe < ge.length; Pe += 1)
      oe[Pe] = ge[Pe];
    for (var Ve = 0; Ve < Ee.length; Ve += 1)
      oe[Ve + ge.length] = Ee[Ve];
    return oe;
  }, ne = function(ge, Ee) {
    for (var oe = [], Pe = Ee, Ve = 0; Pe < ge.length; Pe += 1, Ve += 1)
      oe[Ve] = ge[Pe];
    return oe;
  }, ae = function(le, ge) {
    for (var Ee = "", oe = 0; oe < le.length; oe += 1)
      Ee += le[oe], oe + 1 < le.length && (Ee += ge);
    return Ee;
  };
  return implementation = function(ge) {
    var Ee = this;
    if (typeof Ee != "function" || z.apply(Ee) !== ie)
      throw new TypeError(B + Ee);
    for (var oe = ne(arguments, 1), Pe, Ve = function() {
      if (this instanceof Pe) {
        var kt = Ee.apply(
          this,
          se(oe, arguments)
        );
        return Object(kt) === kt ? kt : this;
      }
      return Ee.apply(
        ge,
        se(oe, arguments)
      );
    }, Ke = Y(0, Ee.length - oe.length), ht = [], _t = 0; _t < Ke; _t++)
      ht[_t] = "$" + _t;
    if (Pe = Function("binder", "return function (" + ae(ht, ",") + "){ return binder.apply(this,arguments); }")(Ve), Ee.prototype) {
      var Rt = function() {
      };
      Rt.prototype = Ee.prototype, Pe.prototype = new Rt(), Rt.prototype = null;
    }
    return Pe;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var B = requireImplementation();
  return functionBind = Function.prototype.bind || B, functionBind;
}
var functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply, hasRequiredReflectApply;
function requireReflectApply() {
  return hasRequiredReflectApply || (hasRequiredReflectApply = 1, reflectApply = typeof Reflect < "u" && Reflect && Reflect.apply), reflectApply;
}
var actualApply, hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var B = requireFunctionBind(), z = requireFunctionApply(), Y = requireFunctionCall(), ie = requireReflectApply();
  return actualApply = ie || B.call(Y, z), actualApply;
}
var callBindApplyHelpers, hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var B = requireFunctionBind(), z = requireType(), Y = requireFunctionCall(), ie = requireActualApply();
  return callBindApplyHelpers = function(ne) {
    if (ne.length < 1 || typeof ne[0] != "function")
      throw new z("a function is required");
    return ie(B, Y, ne);
  }, callBindApplyHelpers;
}
var get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var B = requireCallBindApplyHelpers(), z = requireGopd(), Y;
  try {
    Y = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (ae) {
    if (!ae || typeof ae != "object" || !("code" in ae) || ae.code !== "ERR_PROTO_ACCESS")
      throw ae;
  }
  var ie = !!Y && z && z(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), se = Object, ne = se.getPrototypeOf;
  return get = ie && typeof ie.get == "function" ? B([ie.get]) : typeof ne == "function" ? (
    /** @type {import('./get')} */
    function(le) {
      return ne(le == null ? le : se(le));
    }
  ) : !1, get;
}
var getProto, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var B = requireReflect_getPrototypeOf(), z = requireObject_getPrototypeOf(), Y = requireGet();
  return getProto = B ? function(se) {
    return B(se);
  } : z ? function(se) {
    if (!se || typeof se != "object" && typeof se != "function")
      throw new TypeError("getProto: not an object");
    return z(se);
  } : Y ? function(se) {
    return Y(se);
  } : null, getProto;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var B = Function.prototype.call, z = Object.prototype.hasOwnProperty, Y = requireFunctionBind();
  return hasown = Y.call(B, z), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var B, z = requireEsObjectAtoms(), Y = requireEsErrors(), ie = require_eval(), se = requireRange(), ne = requireRef(), ae = requireSyntax(), le = requireType(), ge = requireUri(), Ee = requireAbs(), oe = requireFloor(), Pe = requireMax(), Ve = requireMin(), Ke = requirePow(), ht = requireRound(), _t = requireSign$1(), Rt = Function, kt = function(rr) {
    try {
      return Rt('"use strict"; return (' + rr + ").constructor;")();
    } catch {
    }
  }, Bt = requireGopd(), Ct = requireEsDefineProperty(), qt = function() {
    throw new le();
  }, jt = Bt ? function() {
    try {
      return arguments.callee, qt;
    } catch {
      try {
        return Bt(arguments, "callee").get;
      } catch {
        return qt;
      }
    }
  }() : qt, Ht = requireHasSymbols()(), Yt = requireGetProto(), Ut = requireObject_getPrototypeOf(), Nt = requireReflect_getPrototypeOf(), Kt = requireFunctionApply(), Ft = requireFunctionCall(), bt = {}, Xe = typeof Uint8Array > "u" || !Yt ? B : Yt(Uint8Array), ve = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? B : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? B : ArrayBuffer,
    "%ArrayIteratorPrototype%": Ht && Yt ? Yt([][Symbol.iterator]()) : B,
    "%AsyncFromSyncIteratorPrototype%": B,
    "%AsyncFunction%": bt,
    "%AsyncGenerator%": bt,
    "%AsyncGeneratorFunction%": bt,
    "%AsyncIteratorPrototype%": bt,
    "%Atomics%": typeof Atomics > "u" ? B : Atomics,
    "%BigInt%": typeof BigInt > "u" ? B : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? B : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? B : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? B : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Y,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": ie,
    "%Float16Array%": typeof Float16Array > "u" ? B : Float16Array,
    "%Float32Array%": typeof Float32Array > "u" ? B : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? B : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? B : FinalizationRegistry,
    "%Function%": Rt,
    "%GeneratorFunction%": bt,
    "%Int8Array%": typeof Int8Array > "u" ? B : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? B : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? B : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Ht && Yt ? Yt(Yt([][Symbol.iterator]())) : B,
    "%JSON%": typeof JSON == "object" ? JSON : B,
    "%Map%": typeof Map > "u" ? B : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Ht || !Yt ? B : Yt((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": z,
    "%Object.getOwnPropertyDescriptor%": Bt,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? B : Promise,
    "%Proxy%": typeof Proxy > "u" ? B : Proxy,
    "%RangeError%": se,
    "%ReferenceError%": ne,
    "%Reflect%": typeof Reflect > "u" ? B : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? B : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Ht || !Yt ? B : Yt((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? B : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Ht && Yt ? Yt(""[Symbol.iterator]()) : B,
    "%Symbol%": Ht ? Symbol : B,
    "%SyntaxError%": ae,
    "%ThrowTypeError%": jt,
    "%TypedArray%": Xe,
    "%TypeError%": le,
    "%Uint8Array%": typeof Uint8Array > "u" ? B : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? B : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? B : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? B : Uint32Array,
    "%URIError%": ge,
    "%WeakMap%": typeof WeakMap > "u" ? B : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? B : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? B : WeakSet,
    "%Function.prototype.call%": Ft,
    "%Function.prototype.apply%": Kt,
    "%Object.defineProperty%": Ct,
    "%Object.getPrototypeOf%": Ut,
    "%Math.abs%": Ee,
    "%Math.floor%": oe,
    "%Math.max%": Pe,
    "%Math.min%": Ve,
    "%Math.pow%": Ke,
    "%Math.round%": ht,
    "%Math.sign%": _t,
    "%Reflect.getPrototypeOf%": Nt
  };
  if (Yt)
    try {
      null.error;
    } catch (rr) {
      var Ce = Yt(Yt(rr));
      ve["%Error.prototype%"] = Ce;
    }
  var Qe = function rr(or) {
    var Xt;
    if (or === "%AsyncFunction%")
      Xt = kt("async function () {}");
    else if (or === "%GeneratorFunction%")
      Xt = kt("function* () {}");
    else if (or === "%AsyncGeneratorFunction%")
      Xt = kt("async function* () {}");
    else if (or === "%AsyncGenerator%") {
      var zt = rr("%AsyncGeneratorFunction%");
      zt && (Xt = zt.prototype);
    } else if (or === "%AsyncIteratorPrototype%") {
      var ur = rr("%AsyncGenerator%");
      ur && Yt && (Xt = Yt(ur.prototype));
    }
    return ve[or] = Xt, Xt;
  }, vt = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, wt = requireFunctionBind(), $t = requireHasown(), xt = wt.call(Ft, Array.prototype.concat), Pt = wt.call(Kt, Array.prototype.splice), Je = wt.call(Ft, String.prototype.replace), Ot = wt.call(Ft, String.prototype.slice), er = wt.call(Ft, RegExp.prototype.exec), sr = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Jt = /\\(\\)?/g, Wt = function(or) {
    var Xt = Ot(or, 0, 1), zt = Ot(or, -1);
    if (Xt === "%" && zt !== "%")
      throw new ae("invalid intrinsic syntax, expected closing `%`");
    if (zt === "%" && Xt !== "%")
      throw new ae("invalid intrinsic syntax, expected opening `%`");
    var ur = [];
    return Je(or, sr, function(hr, yr, Sr, $r) {
      ur[ur.length] = Sr ? Je($r, Jt, "$1") : yr || hr;
    }), ur;
  }, Gt = function(or, Xt) {
    var zt = or, ur;
    if ($t(vt, zt) && (ur = vt[zt], zt = "%" + ur[0] + "%"), $t(ve, zt)) {
      var hr = ve[zt];
      if (hr === bt && (hr = Qe(zt)), typeof hr > "u" && !Xt)
        throw new le("intrinsic " + or + " exists, but is not available. Please file an issue!");
      return {
        alias: ur,
        name: zt,
        value: hr
      };
    }
    throw new ae("intrinsic " + or + " does not exist!");
  };
  return getIntrinsic = function(or, Xt) {
    if (typeof or != "string" || or.length === 0)
      throw new le("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof Xt != "boolean")
      throw new le('"allowMissing" argument must be a boolean');
    if (er(/^%?[^%]*%?$/, or) === null)
      throw new ae("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var zt = Wt(or), ur = zt.length > 0 ? zt[0] : "", hr = Gt("%" + ur + "%", Xt), yr = hr.name, Sr = hr.value, $r = !1, Mr = hr.alias;
    Mr && (ur = Mr[0], Pt(zt, xt([0, 1], Mr)));
    for (var pr = 1, Fr = !0; pr < zt.length; pr += 1) {
      var Ar = zt[pr], Gr = Ot(Ar, 0, 1), Lr = Ot(Ar, -1);
      if ((Gr === '"' || Gr === "'" || Gr === "`" || Lr === '"' || Lr === "'" || Lr === "`") && Gr !== Lr)
        throw new ae("property names with quotes must have matching quotes");
      if ((Ar === "constructor" || !Fr) && ($r = !0), ur += "." + Ar, yr = "%" + ur + "%", $t(ve, yr))
        Sr = ve[yr];
      else if (Sr != null) {
        if (!(Ar in Sr)) {
          if (!Xt)
            throw new le("base intrinsic for " + or + " exists, but the property is not available.");
          return;
        }
        if (Bt && pr + 1 >= zt.length) {
          var Rr = Bt(Sr, Ar);
          Fr = !!Rr, Fr && "get" in Rr && !("originalValue" in Rr.get) ? Sr = Rr.get : Sr = Sr[Ar];
        } else
          Fr = $t(Sr, Ar), Sr = Sr[Ar];
        Fr && !$r && (ve[yr] = Sr);
      }
    }
    return Sr;
  }, getIntrinsic;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var B = requireGetIntrinsic(), z = requireCallBindApplyHelpers(), Y = z([B("%String.prototype.indexOf%")]);
  return callBound = function(se, ne) {
    var ae = (
      /** @type {Parameters<typeof callBindBasic>[0][0]} */
      B(se, !!ne)
    );
    return typeof ae == "function" && Y(se, ".prototype.") > -1 ? z([ae]) : ae;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var B = requireShams()(), z = requireCallBound(), Y = z("Object.prototype.toString"), ie = function(le) {
    return B && le && typeof le == "object" && Symbol.toStringTag in le ? !1 : Y(le) === "[object Arguments]";
  }, se = function(le) {
    return ie(le) ? !0 : le !== null && typeof le == "object" && "length" in le && typeof le.length == "number" && le.length >= 0 && Y(le) !== "[object Array]" && "callee" in le && Y(le.callee) === "[object Function]";
  }, ne = function() {
    return ie(arguments);
  }();
  return ie.isLegacyArguments = se, isArguments = ne ? ie : se, isArguments;
}
var isRegex, hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var B = requireCallBound(), z = requireShams()(), Y = requireHasown(), ie = requireGopd(), se;
  if (z) {
    var ne = B("RegExp.prototype.exec"), ae = {}, le = function() {
      throw ae;
    }, ge = {
      toString: le,
      valueOf: le
    };
    typeof Symbol.toPrimitive == "symbol" && (ge[Symbol.toPrimitive] = le), se = function(Ve) {
      if (!Ve || typeof Ve != "object")
        return !1;
      var Ke = (
        /** @type {NonNullable<typeof gOPD>} */
        ie(
          /** @type {{ lastIndex?: unknown }} */
          Ve,
          "lastIndex"
        )
      ), ht = Ke && Y(Ke, "value");
      if (!ht)
        return !1;
      try {
        ne(
          Ve,
          /** @type {string} */
          /** @type {unknown} */
          ge
        );
      } catch (_t) {
        return _t === ae;
      }
    };
  } else {
    var Ee = B("Object.prototype.toString"), oe = "[object RegExp]";
    se = function(Ve) {
      return !Ve || typeof Ve != "object" && typeof Ve != "function" ? !1 : Ee(Ve) === oe;
    };
  }
  return isRegex = se, isRegex;
}
var safeRegexTest, hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var B = requireCallBound(), z = requireIsRegex(), Y = B("RegExp.prototype.exec"), ie = requireType();
  return safeRegexTest = function(ne) {
    if (!z(ne))
      throw new ie("`regex` must be a RegExp");
    return function(le) {
      return Y(ne, le) !== null;
    };
  }, safeRegexTest;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var B = requireCallBound(), z = requireSafeRegexTest(), Y = z(/^\s*(?:function)?\*/), ie = requireShams()(), se = requireGetProto(), ne = B("Object.prototype.toString"), ae = B("Function.prototype.toString"), le = function() {
    if (!ie)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, ge;
  return isGeneratorFunction = function(oe) {
    if (typeof oe != "function")
      return !1;
    if (Y(ae(oe)))
      return !0;
    if (!ie) {
      var Pe = ne(oe);
      return Pe === "[object GeneratorFunction]";
    }
    if (!se)
      return !1;
    if (typeof ge > "u") {
      var Ve = le();
      ge = Ve ? (
        /** @type {GeneratorFunctionConstructor} */
        se(Ve)
      ) : !1;
    }
    return se(oe) === ge;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var B = Function.prototype.toString, z = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Y, ie;
  if (typeof z == "function" && typeof Object.defineProperty == "function")
    try {
      Y = Object.defineProperty({}, "length", {
        get: function() {
          throw ie;
        }
      }), ie = {}, z(function() {
        throw 42;
      }, null, Y);
    } catch (Bt) {
      Bt !== ie && (z = null);
    }
  else
    z = null;
  var se = /^\s*class\b/, ne = function(Ct) {
    try {
      var qt = B.call(Ct);
      return se.test(qt);
    } catch {
      return !1;
    }
  }, ae = function(Ct) {
    try {
      return ne(Ct) ? !1 : (B.call(Ct), !0);
    } catch {
      return !1;
    }
  }, le = Object.prototype.toString, ge = "[object Object]", Ee = "[object Function]", oe = "[object GeneratorFunction]", Pe = "[object HTMLAllCollection]", Ve = "[object HTML document.all class]", Ke = "[object HTMLCollection]", ht = typeof Symbol == "function" && !!Symbol.toStringTag, _t = !(0 in [,]), Rt = function() {
    return !1;
  };
  if (typeof document == "object") {
    var kt = document.all;
    le.call(kt) === le.call(document.all) && (Rt = function(Ct) {
      if ((_t || !Ct) && (typeof Ct > "u" || typeof Ct == "object"))
        try {
          var qt = le.call(Ct);
          return (qt === Pe || qt === Ve || qt === Ke || qt === ge) && Ct("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = z ? function(Ct) {
    if (Rt(Ct))
      return !0;
    if (!Ct || typeof Ct != "function" && typeof Ct != "object")
      return !1;
    try {
      z(Ct, null, Y);
    } catch (qt) {
      if (qt !== ie)
        return !1;
    }
    return !ne(Ct) && ae(Ct);
  } : function(Ct) {
    if (Rt(Ct))
      return !0;
    if (!Ct || typeof Ct != "function" && typeof Ct != "object")
      return !1;
    if (ht)
      return ae(Ct);
    if (ne(Ct))
      return !1;
    var qt = le.call(Ct);
    return qt !== Ee && qt !== oe && !/^\[object HTML/.test(qt) ? !1 : ae(Ct);
  }, isCallable;
}
var forEach, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var B = requireIsCallable(), z = Object.prototype.toString, Y = Object.prototype.hasOwnProperty, ie = function(ge, Ee, oe) {
    for (var Pe = 0, Ve = ge.length; Pe < Ve; Pe++)
      Y.call(ge, Pe) && (oe == null ? Ee(ge[Pe], Pe, ge) : Ee.call(oe, ge[Pe], Pe, ge));
  }, se = function(ge, Ee, oe) {
    for (var Pe = 0, Ve = ge.length; Pe < Ve; Pe++)
      oe == null ? Ee(ge.charAt(Pe), Pe, ge) : Ee.call(oe, ge.charAt(Pe), Pe, ge);
  }, ne = function(ge, Ee, oe) {
    for (var Pe in ge)
      Y.call(ge, Pe) && (oe == null ? Ee(ge[Pe], Pe, ge) : Ee.call(oe, ge[Pe], Pe, ge));
  };
  function ae(le) {
    return z.call(le) === "[object Array]";
  }
  return forEach = function(ge, Ee, oe) {
    if (!B(Ee))
      throw new TypeError("iterator must be a function");
    var Pe;
    arguments.length >= 3 && (Pe = oe), ae(ge) ? ie(ge, Ee, Pe) : typeof ge == "string" ? se(ge, Ee, Pe) : ne(ge, Ee, Pe);
  }, forEach;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var B = requirePossibleTypedArrayNames(), z = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var ie = [], se = 0; se < B.length; se++)
      typeof z[B[se]] == "function" && (ie[ie.length] = B[se]);
    return ie;
  }, availableTypedArrays;
}
var callBind = { exports: {} }, defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var B = requireEsDefineProperty(), z = requireSyntax(), Y = requireType(), ie = requireGopd();
  return defineDataProperty = function(ne, ae, le) {
    if (!ne || typeof ne != "object" && typeof ne != "function")
      throw new Y("`obj` must be an object or a function`");
    if (typeof ae != "string" && typeof ae != "symbol")
      throw new Y("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new Y("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new Y("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new Y("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new Y("`loose`, if provided, must be a boolean");
    var ge = arguments.length > 3 ? arguments[3] : null, Ee = arguments.length > 4 ? arguments[4] : null, oe = arguments.length > 5 ? arguments[5] : null, Pe = arguments.length > 6 ? arguments[6] : !1, Ve = !!ie && ie(ne, ae);
    if (B)
      B(ne, ae, {
        configurable: oe === null && Ve ? Ve.configurable : !oe,
        enumerable: ge === null && Ve ? Ve.enumerable : !ge,
        value: le,
        writable: Ee === null && Ve ? Ve.writable : !Ee
      });
    else if (Pe || !ge && !Ee && !oe)
      ne[ae] = le;
    else
      throw new z("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var B = requireEsDefineProperty(), z = function() {
    return !!B;
  };
  return z.hasArrayLengthDefineBug = function() {
    if (!B)
      return null;
    try {
      return B([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = z, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var B = requireGetIntrinsic(), z = requireDefineDataProperty(), Y = requireHasPropertyDescriptors()(), ie = requireGopd(), se = requireType(), ne = B("%Math.floor%");
  return setFunctionLength = function(le, ge) {
    if (typeof le != "function")
      throw new se("`fn` is not a function");
    if (typeof ge != "number" || ge < 0 || ge > 4294967295 || ne(ge) !== ge)
      throw new se("`length` must be a positive 32-bit integer");
    var Ee = arguments.length > 2 && !!arguments[2], oe = !0, Pe = !0;
    if ("length" in le && ie) {
      var Ve = ie(le, "length");
      Ve && !Ve.configurable && (oe = !1), Ve && !Ve.writable && (Pe = !1);
    }
    return (oe || Pe || !Ee) && (Y ? z(
      /** @type {Parameters<define>[0]} */
      le,
      "length",
      ge,
      !0,
      !0
    ) : z(
      /** @type {Parameters<define>[0]} */
      le,
      "length",
      ge
    )), le;
  }, setFunctionLength;
}
var applyBind, hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var B = requireFunctionBind(), z = requireFunctionApply(), Y = requireActualApply();
  return applyBind = function() {
    return Y(B, z, arguments);
  }, applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(B) {
    var z = requireSetFunctionLength(), Y = requireEsDefineProperty(), ie = requireCallBindApplyHelpers(), se = requireApplyBind();
    B.exports = function(ae) {
      var le = ie(arguments), ge = ae.length - (arguments.length - 1);
      return z(
        le,
        1 + (ge > 0 ? ge : 0),
        !0
      );
    }, Y ? Y(B.exports, "apply", { value: se }) : B.exports.apply = se;
  }(callBind)), callBind.exports;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var B = requireForEach(), z = requireAvailableTypedArrays(), Y = requireCallBind(), ie = requireCallBound(), se = requireGopd(), ne = ie("Object.prototype.toString"), ae = requireShams()(), le = typeof globalThis > "u" ? commonjsGlobal : globalThis, ge = z(), Ee = ie("String.prototype.slice"), oe = Object.getPrototypeOf, Pe = ie("Array.prototype.indexOf", !0) || function(Rt, kt) {
    for (var Bt = 0; Bt < Rt.length; Bt += 1)
      if (Rt[Bt] === kt)
        return Bt;
    return -1;
  }, Ve = { __proto__: null };
  ae && se && oe ? B(ge, function(_t) {
    var Rt = new le[_t]();
    if (Symbol.toStringTag in Rt) {
      var kt = oe(Rt), Bt = se(kt, Symbol.toStringTag);
      if (!Bt) {
        var Ct = oe(kt);
        Bt = se(Ct, Symbol.toStringTag);
      }
      Ve["$" + _t] = Y(Bt.get);
    }
  }) : B(ge, function(_t) {
    var Rt = new le[_t](), kt = Rt.slice || Rt.set;
    kt && (Ve["$" + _t] = Y(kt));
  });
  var Ke = function(Rt) {
    var kt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ve,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(Bt, Ct) {
        if (!kt)
          try {
            "$" + Bt(Rt) === Ct && (kt = Ee(Ct, 1));
          } catch {
          }
      }
    ), kt;
  }, ht = function(Rt) {
    var kt = !1;
    return B(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Ve,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(Bt, Ct) {
        if (!kt)
          try {
            Bt(Rt), kt = Ee(Ct, 1);
          } catch {
          }
      }
    ), kt;
  };
  return whichTypedArray = function(Rt) {
    if (!Rt || typeof Rt != "object")
      return !1;
    if (!ae) {
      var kt = Ee(ne(Rt), 8, -1);
      return Pe(ge, kt) > -1 ? kt : kt !== "Object" ? !1 : ht(Rt);
    }
    return se ? Ke(Rt) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var B = requireWhichTypedArray();
  return isTypedArray = function(Y) {
    return !!B(Y);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(B) {
    var z = requireIsArguments(), Y = requireIsGeneratorFunction(), ie = requireWhichTypedArray(), se = requireIsTypedArray();
    function ne(pr) {
      return pr.call.bind(pr);
    }
    var ae = typeof BigInt < "u", le = typeof Symbol < "u", ge = ne(Object.prototype.toString), Ee = ne(Number.prototype.valueOf), oe = ne(String.prototype.valueOf), Pe = ne(Boolean.prototype.valueOf);
    if (ae)
      var Ve = ne(BigInt.prototype.valueOf);
    if (le)
      var Ke = ne(Symbol.prototype.valueOf);
    function ht(pr, Fr) {
      if (typeof pr != "object")
        return !1;
      try {
        return Fr(pr), !0;
      } catch {
        return !1;
      }
    }
    B.isArgumentsObject = z, B.isGeneratorFunction = Y, B.isTypedArray = se;
    function _t(pr) {
      return typeof Promise < "u" && pr instanceof Promise || pr !== null && typeof pr == "object" && typeof pr.then == "function" && typeof pr.catch == "function";
    }
    B.isPromise = _t;
    function Rt(pr) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(pr) : se(pr) || Ot(pr);
    }
    B.isArrayBufferView = Rt;
    function kt(pr) {
      return ie(pr) === "Uint8Array";
    }
    B.isUint8Array = kt;
    function Bt(pr) {
      return ie(pr) === "Uint8ClampedArray";
    }
    B.isUint8ClampedArray = Bt;
    function Ct(pr) {
      return ie(pr) === "Uint16Array";
    }
    B.isUint16Array = Ct;
    function qt(pr) {
      return ie(pr) === "Uint32Array";
    }
    B.isUint32Array = qt;
    function jt(pr) {
      return ie(pr) === "Int8Array";
    }
    B.isInt8Array = jt;
    function Ht(pr) {
      return ie(pr) === "Int16Array";
    }
    B.isInt16Array = Ht;
    function Yt(pr) {
      return ie(pr) === "Int32Array";
    }
    B.isInt32Array = Yt;
    function Ut(pr) {
      return ie(pr) === "Float32Array";
    }
    B.isFloat32Array = Ut;
    function Nt(pr) {
      return ie(pr) === "Float64Array";
    }
    B.isFloat64Array = Nt;
    function Kt(pr) {
      return ie(pr) === "BigInt64Array";
    }
    B.isBigInt64Array = Kt;
    function Ft(pr) {
      return ie(pr) === "BigUint64Array";
    }
    B.isBigUint64Array = Ft;
    function bt(pr) {
      return ge(pr) === "[object Map]";
    }
    bt.working = typeof Map < "u" && bt(/* @__PURE__ */ new Map());
    function Xe(pr) {
      return typeof Map > "u" ? !1 : bt.working ? bt(pr) : pr instanceof Map;
    }
    B.isMap = Xe;
    function ve(pr) {
      return ge(pr) === "[object Set]";
    }
    ve.working = typeof Set < "u" && ve(/* @__PURE__ */ new Set());
    function Ce(pr) {
      return typeof Set > "u" ? !1 : ve.working ? ve(pr) : pr instanceof Set;
    }
    B.isSet = Ce;
    function Qe(pr) {
      return ge(pr) === "[object WeakMap]";
    }
    Qe.working = typeof WeakMap < "u" && Qe(/* @__PURE__ */ new WeakMap());
    function vt(pr) {
      return typeof WeakMap > "u" ? !1 : Qe.working ? Qe(pr) : pr instanceof WeakMap;
    }
    B.isWeakMap = vt;
    function wt(pr) {
      return ge(pr) === "[object WeakSet]";
    }
    wt.working = typeof WeakSet < "u" && wt(/* @__PURE__ */ new WeakSet());
    function $t(pr) {
      return wt(pr);
    }
    B.isWeakSet = $t;
    function xt(pr) {
      return ge(pr) === "[object ArrayBuffer]";
    }
    xt.working = typeof ArrayBuffer < "u" && xt(new ArrayBuffer());
    function Pt(pr) {
      return typeof ArrayBuffer > "u" ? !1 : xt.working ? xt(pr) : pr instanceof ArrayBuffer;
    }
    B.isArrayBuffer = Pt;
    function Je(pr) {
      return ge(pr) === "[object DataView]";
    }
    Je.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && Je(new DataView(new ArrayBuffer(1), 0, 1));
    function Ot(pr) {
      return typeof DataView > "u" ? !1 : Je.working ? Je(pr) : pr instanceof DataView;
    }
    B.isDataView = Ot;
    var er = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function sr(pr) {
      return ge(pr) === "[object SharedArrayBuffer]";
    }
    function Jt(pr) {
      return typeof er > "u" ? !1 : (typeof sr.working > "u" && (sr.working = sr(new er())), sr.working ? sr(pr) : pr instanceof er);
    }
    B.isSharedArrayBuffer = Jt;
    function Wt(pr) {
      return ge(pr) === "[object AsyncFunction]";
    }
    B.isAsyncFunction = Wt;
    function Gt(pr) {
      return ge(pr) === "[object Map Iterator]";
    }
    B.isMapIterator = Gt;
    function rr(pr) {
      return ge(pr) === "[object Set Iterator]";
    }
    B.isSetIterator = rr;
    function or(pr) {
      return ge(pr) === "[object Generator]";
    }
    B.isGeneratorObject = or;
    function Xt(pr) {
      return ge(pr) === "[object WebAssembly.Module]";
    }
    B.isWebAssemblyCompiledModule = Xt;
    function zt(pr) {
      return ht(pr, Ee);
    }
    B.isNumberObject = zt;
    function ur(pr) {
      return ht(pr, oe);
    }
    B.isStringObject = ur;
    function hr(pr) {
      return ht(pr, Pe);
    }
    B.isBooleanObject = hr;
    function yr(pr) {
      return ae && ht(pr, Ve);
    }
    B.isBigIntObject = yr;
    function Sr(pr) {
      return le && ht(pr, Ke);
    }
    B.isSymbolObject = Sr;
    function $r(pr) {
      return zt(pr) || ur(pr) || hr(pr) || yr(pr) || Sr(pr);
    }
    B.isBoxedPrimitive = $r;
    function Mr(pr) {
      return typeof Uint8Array < "u" && (Pt(pr) || Jt(pr));
    }
    B.isAnyArrayBuffer = Mr, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(pr) {
      Object.defineProperty(B, pr, {
        enumerable: !1,
        value: function() {
          throw new Error(pr + " is not supported in userland");
        }
      });
    });
  }(types$5)), types$5;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(z) {
    return z && typeof z == "object" && typeof z.copy == "function" && typeof z.fill == "function" && typeof z.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(B) {
    var z = Object.getOwnPropertyDescriptors || function(Ot) {
      for (var er = Object.keys(Ot), sr = {}, Jt = 0; Jt < er.length; Jt++)
        sr[er[Jt]] = Object.getOwnPropertyDescriptor(Ot, er[Jt]);
      return sr;
    }, Y = /%[sdj%]/g;
    B.format = function(Je) {
      if (!jt(Je)) {
        for (var Ot = [], er = 0; er < arguments.length; er++)
          Ot.push(ae(arguments[er]));
        return Ot.join(" ");
      }
      for (var er = 1, sr = arguments, Jt = sr.length, Wt = String(Je).replace(Y, function(rr) {
        if (rr === "%%") return "%";
        if (er >= Jt) return rr;
        switch (rr) {
          case "%s":
            return String(sr[er++]);
          case "%d":
            return Number(sr[er++]);
          case "%j":
            try {
              return JSON.stringify(sr[er++]);
            } catch {
              return "[Circular]";
            }
          default:
            return rr;
        }
      }), Gt = sr[er]; er < Jt; Gt = sr[++er])
        Bt(Gt) || !Nt(Gt) ? Wt += " " + Gt : Wt += " " + ae(Gt);
      return Wt;
    }, B.deprecate = function(Je, Ot) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return Je;
      if (typeof process$1 > "u")
        return function() {
          return B.deprecate(Je, Ot).apply(this, arguments);
        };
      var er = !1;
      function sr() {
        if (!er) {
          if (process$1.throwDeprecation)
            throw new Error(Ot);
          process$1.traceDeprecation ? console.trace(Ot) : console.error(Ot), er = !0;
        }
        return Je.apply(this, arguments);
      }
      return sr;
    };
    var ie = {}, se = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var ne = process$1.env.NODE_DEBUG;
      ne = ne.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), se = new RegExp("^" + ne + "$", "i");
    }
    B.debuglog = function(Je) {
      if (Je = Je.toUpperCase(), !ie[Je])
        if (se.test(Je)) {
          var Ot = process$1.pid;
          ie[Je] = function() {
            var er = B.format.apply(B, arguments);
            console.error("%s %d: %s", Je, Ot, er);
          };
        } else
          ie[Je] = function() {
          };
      return ie[Je];
    };
    function ae(Je, Ot) {
      var er = {
        seen: [],
        stylize: ge
      };
      return arguments.length >= 3 && (er.depth = arguments[2]), arguments.length >= 4 && (er.colors = arguments[3]), kt(Ot) ? er.showHidden = Ot : Ot && B._extend(er, Ot), Yt(er.showHidden) && (er.showHidden = !1), Yt(er.depth) && (er.depth = 2), Yt(er.colors) && (er.colors = !1), Yt(er.customInspect) && (er.customInspect = !0), er.colors && (er.stylize = le), oe(er, Je, er.depth);
    }
    B.inspect = ae, ae.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, ae.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function le(Je, Ot) {
      var er = ae.styles[Ot];
      return er ? "\x1B[" + ae.colors[er][0] + "m" + Je + "\x1B[" + ae.colors[er][1] + "m" : Je;
    }
    function ge(Je, Ot) {
      return Je;
    }
    function Ee(Je) {
      var Ot = {};
      return Je.forEach(function(er, sr) {
        Ot[er] = !0;
      }), Ot;
    }
    function oe(Je, Ot, er) {
      if (Je.customInspect && Ot && bt(Ot.inspect) && // Filter out the util module, it's inspect function is special
      Ot.inspect !== B.inspect && // Also filter out any prototype objects using the circular check.
      !(Ot.constructor && Ot.constructor.prototype === Ot)) {
        var sr = Ot.inspect(er, Je);
        return jt(sr) || (sr = oe(Je, sr, er)), sr;
      }
      var Jt = Pe(Je, Ot);
      if (Jt)
        return Jt;
      var Wt = Object.keys(Ot), Gt = Ee(Wt);
      if (Je.showHidden && (Wt = Object.getOwnPropertyNames(Ot)), Ft(Ot) && (Wt.indexOf("message") >= 0 || Wt.indexOf("description") >= 0))
        return Ve(Ot);
      if (Wt.length === 0) {
        if (bt(Ot)) {
          var rr = Ot.name ? ": " + Ot.name : "";
          return Je.stylize("[Function" + rr + "]", "special");
        }
        if (Ut(Ot))
          return Je.stylize(RegExp.prototype.toString.call(Ot), "regexp");
        if (Kt(Ot))
          return Je.stylize(Date.prototype.toString.call(Ot), "date");
        if (Ft(Ot))
          return Ve(Ot);
      }
      var or = "", Xt = !1, zt = ["{", "}"];
      if (Rt(Ot) && (Xt = !0, zt = ["[", "]"]), bt(Ot)) {
        var ur = Ot.name ? ": " + Ot.name : "";
        or = " [Function" + ur + "]";
      }
      if (Ut(Ot) && (or = " " + RegExp.prototype.toString.call(Ot)), Kt(Ot) && (or = " " + Date.prototype.toUTCString.call(Ot)), Ft(Ot) && (or = " " + Ve(Ot)), Wt.length === 0 && (!Xt || Ot.length == 0))
        return zt[0] + or + zt[1];
      if (er < 0)
        return Ut(Ot) ? Je.stylize(RegExp.prototype.toString.call(Ot), "regexp") : Je.stylize("[Object]", "special");
      Je.seen.push(Ot);
      var hr;
      return Xt ? hr = Ke(Je, Ot, er, Gt, Wt) : hr = Wt.map(function(yr) {
        return ht(Je, Ot, er, Gt, yr, Xt);
      }), Je.seen.pop(), _t(hr, or, zt);
    }
    function Pe(Je, Ot) {
      if (Yt(Ot))
        return Je.stylize("undefined", "undefined");
      if (jt(Ot)) {
        var er = "'" + JSON.stringify(Ot).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return Je.stylize(er, "string");
      }
      if (qt(Ot))
        return Je.stylize("" + Ot, "number");
      if (kt(Ot))
        return Je.stylize("" + Ot, "boolean");
      if (Bt(Ot))
        return Je.stylize("null", "null");
    }
    function Ve(Je) {
      return "[" + Error.prototype.toString.call(Je) + "]";
    }
    function Ke(Je, Ot, er, sr, Jt) {
      for (var Wt = [], Gt = 0, rr = Ot.length; Gt < rr; ++Gt)
        wt(Ot, String(Gt)) ? Wt.push(ht(
          Je,
          Ot,
          er,
          sr,
          String(Gt),
          !0
        )) : Wt.push("");
      return Jt.forEach(function(or) {
        or.match(/^\d+$/) || Wt.push(ht(
          Je,
          Ot,
          er,
          sr,
          or,
          !0
        ));
      }), Wt;
    }
    function ht(Je, Ot, er, sr, Jt, Wt) {
      var Gt, rr, or;
      if (or = Object.getOwnPropertyDescriptor(Ot, Jt) || { value: Ot[Jt] }, or.get ? or.set ? rr = Je.stylize("[Getter/Setter]", "special") : rr = Je.stylize("[Getter]", "special") : or.set && (rr = Je.stylize("[Setter]", "special")), wt(sr, Jt) || (Gt = "[" + Jt + "]"), rr || (Je.seen.indexOf(or.value) < 0 ? (Bt(er) ? rr = oe(Je, or.value, null) : rr = oe(Je, or.value, er - 1), rr.indexOf(`
`) > -1 && (Wt ? rr = rr.split(`
`).map(function(Xt) {
        return "  " + Xt;
      }).join(`
`).slice(2) : rr = `
` + rr.split(`
`).map(function(Xt) {
        return "   " + Xt;
      }).join(`
`))) : rr = Je.stylize("[Circular]", "special")), Yt(Gt)) {
        if (Wt && Jt.match(/^\d+$/))
          return rr;
        Gt = JSON.stringify("" + Jt), Gt.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Gt = Gt.slice(1, -1), Gt = Je.stylize(Gt, "name")) : (Gt = Gt.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Gt = Je.stylize(Gt, "string"));
      }
      return Gt + ": " + rr;
    }
    function _t(Je, Ot, er) {
      var sr = Je.reduce(function(Jt, Wt) {
        return Wt.indexOf(`
`) >= 0, Jt + Wt.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return sr > 60 ? er[0] + (Ot === "" ? "" : Ot + `
 `) + " " + Je.join(`,
  `) + " " + er[1] : er[0] + Ot + " " + Je.join(", ") + " " + er[1];
    }
    B.types = requireTypes();
    function Rt(Je) {
      return Array.isArray(Je);
    }
    B.isArray = Rt;
    function kt(Je) {
      return typeof Je == "boolean";
    }
    B.isBoolean = kt;
    function Bt(Je) {
      return Je === null;
    }
    B.isNull = Bt;
    function Ct(Je) {
      return Je == null;
    }
    B.isNullOrUndefined = Ct;
    function qt(Je) {
      return typeof Je == "number";
    }
    B.isNumber = qt;
    function jt(Je) {
      return typeof Je == "string";
    }
    B.isString = jt;
    function Ht(Je) {
      return typeof Je == "symbol";
    }
    B.isSymbol = Ht;
    function Yt(Je) {
      return Je === void 0;
    }
    B.isUndefined = Yt;
    function Ut(Je) {
      return Nt(Je) && ve(Je) === "[object RegExp]";
    }
    B.isRegExp = Ut, B.types.isRegExp = Ut;
    function Nt(Je) {
      return typeof Je == "object" && Je !== null;
    }
    B.isObject = Nt;
    function Kt(Je) {
      return Nt(Je) && ve(Je) === "[object Date]";
    }
    B.isDate = Kt, B.types.isDate = Kt;
    function Ft(Je) {
      return Nt(Je) && (ve(Je) === "[object Error]" || Je instanceof Error);
    }
    B.isError = Ft, B.types.isNativeError = Ft;
    function bt(Je) {
      return typeof Je == "function";
    }
    B.isFunction = bt;
    function Xe(Je) {
      return Je === null || typeof Je == "boolean" || typeof Je == "number" || typeof Je == "string" || typeof Je == "symbol" || // ES6 symbol
      typeof Je > "u";
    }
    B.isPrimitive = Xe, B.isBuffer = requireIsBufferBrowser();
    function ve(Je) {
      return Object.prototype.toString.call(Je);
    }
    function Ce(Je) {
      return Je < 10 ? "0" + Je.toString(10) : Je.toString(10);
    }
    var Qe = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function vt() {
      var Je = /* @__PURE__ */ new Date(), Ot = [
        Ce(Je.getHours()),
        Ce(Je.getMinutes()),
        Ce(Je.getSeconds())
      ].join(":");
      return [Je.getDate(), Qe[Je.getMonth()], Ot].join(" ");
    }
    B.log = function() {
      console.log("%s - %s", vt(), B.format.apply(B, arguments));
    }, B.inherits = requireInherits_browser(), B._extend = function(Je, Ot) {
      if (!Ot || !Nt(Ot)) return Je;
      for (var er = Object.keys(Ot), sr = er.length; sr--; )
        Je[er[sr]] = Ot[er[sr]];
      return Je;
    };
    function wt(Je, Ot) {
      return Object.prototype.hasOwnProperty.call(Je, Ot);
    }
    var $t = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    B.promisify = function(Ot) {
      if (typeof Ot != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if ($t && Ot[$t]) {
        var er = Ot[$t];
        if (typeof er != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(er, $t, {
          value: er,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), er;
      }
      function er() {
        for (var sr, Jt, Wt = new Promise(function(or, Xt) {
          sr = or, Jt = Xt;
        }), Gt = [], rr = 0; rr < arguments.length; rr++)
          Gt.push(arguments[rr]);
        Gt.push(function(or, Xt) {
          or ? Jt(or) : sr(Xt);
        });
        try {
          Ot.apply(this, Gt);
        } catch (or) {
          Jt(or);
        }
        return Wt;
      }
      return Object.setPrototypeOf(er, Object.getPrototypeOf(Ot)), $t && Object.defineProperty(er, $t, {
        value: er,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        er,
        z(Ot)
      );
    }, B.promisify.custom = $t;
    function xt(Je, Ot) {
      if (!Je) {
        var er = new Error("Promise was rejected with a falsy value");
        er.reason = Je, Je = er;
      }
      return Ot(Je);
    }
    function Pt(Je) {
      if (typeof Je != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function Ot() {
        for (var er = [], sr = 0; sr < arguments.length; sr++)
          er.push(arguments[sr]);
        var Jt = er.pop();
        if (typeof Jt != "function")
          throw new TypeError("The last argument must be of type Function");
        var Wt = this, Gt = function() {
          return Jt.apply(Wt, arguments);
        };
        Je.apply(this, er).then(
          function(rr) {
            process$1.nextTick(Gt.bind(null, null, rr));
          },
          function(rr) {
            process$1.nextTick(xt.bind(null, rr, Gt));
          }
        );
      }
      return Object.setPrototypeOf(Ot, Object.getPrototypeOf(Je)), Object.defineProperties(
        Ot,
        z(Je)
      ), Ot;
    }
    B.callbackify = Pt;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function B(ht, _t) {
    var Rt = Object.keys(ht);
    if (Object.getOwnPropertySymbols) {
      var kt = Object.getOwnPropertySymbols(ht);
      _t && (kt = kt.filter(function(Bt) {
        return Object.getOwnPropertyDescriptor(ht, Bt).enumerable;
      })), Rt.push.apply(Rt, kt);
    }
    return Rt;
  }
  function z(ht) {
    for (var _t = 1; _t < arguments.length; _t++) {
      var Rt = arguments[_t] != null ? arguments[_t] : {};
      _t % 2 ? B(Object(Rt), !0).forEach(function(kt) {
        Y(ht, kt, Rt[kt]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ht, Object.getOwnPropertyDescriptors(Rt)) : B(Object(Rt)).forEach(function(kt) {
        Object.defineProperty(ht, kt, Object.getOwnPropertyDescriptor(Rt, kt));
      });
    }
    return ht;
  }
  function Y(ht, _t, Rt) {
    return _t = ae(_t), _t in ht ? Object.defineProperty(ht, _t, { value: Rt, enumerable: !0, configurable: !0, writable: !0 }) : ht[_t] = Rt, ht;
  }
  function ie(ht, _t) {
    if (!(ht instanceof _t))
      throw new TypeError("Cannot call a class as a function");
  }
  function se(ht, _t) {
    for (var Rt = 0; Rt < _t.length; Rt++) {
      var kt = _t[Rt];
      kt.enumerable = kt.enumerable || !1, kt.configurable = !0, "value" in kt && (kt.writable = !0), Object.defineProperty(ht, ae(kt.key), kt);
    }
  }
  function ne(ht, _t, Rt) {
    return _t && se(ht.prototype, _t), Object.defineProperty(ht, "prototype", { writable: !1 }), ht;
  }
  function ae(ht) {
    var _t = le(ht, "string");
    return typeof _t == "symbol" ? _t : String(_t);
  }
  function le(ht, _t) {
    if (typeof ht != "object" || ht === null) return ht;
    var Rt = ht[Symbol.toPrimitive];
    if (Rt !== void 0) {
      var kt = Rt.call(ht, _t);
      if (typeof kt != "object") return kt;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(ht);
  }
  var ge = require$$0$1, Ee = ge.Buffer, oe = requireUtil$1(), Pe = oe.inspect, Ve = Pe && Pe.custom || "inspect";
  function Ke(ht, _t, Rt) {
    Ee.prototype.copy.call(ht, _t, Rt);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function ht() {
      ie(this, ht), this.head = null, this.tail = null, this.length = 0;
    }
    return ne(ht, [{
      key: "push",
      value: function(Rt) {
        var kt = {
          data: Rt,
          next: null
        };
        this.length > 0 ? this.tail.next = kt : this.head = kt, this.tail = kt, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(Rt) {
        var kt = {
          data: Rt,
          next: this.head
        };
        this.length === 0 && (this.tail = kt), this.head = kt, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var Rt = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, Rt;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(Rt) {
        if (this.length === 0) return "";
        for (var kt = this.head, Bt = "" + kt.data; kt = kt.next; ) Bt += Rt + kt.data;
        return Bt;
      }
    }, {
      key: "concat",
      value: function(Rt) {
        if (this.length === 0) return Ee.alloc(0);
        for (var kt = Ee.allocUnsafe(Rt >>> 0), Bt = this.head, Ct = 0; Bt; )
          Ke(Bt.data, kt, Ct), Ct += Bt.data.length, Bt = Bt.next;
        return kt;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(Rt, kt) {
        var Bt;
        return Rt < this.head.data.length ? (Bt = this.head.data.slice(0, Rt), this.head.data = this.head.data.slice(Rt)) : Rt === this.head.data.length ? Bt = this.shift() : Bt = kt ? this._getString(Rt) : this._getBuffer(Rt), Bt;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(Rt) {
        var kt = this.head, Bt = 1, Ct = kt.data;
        for (Rt -= Ct.length; kt = kt.next; ) {
          var qt = kt.data, jt = Rt > qt.length ? qt.length : Rt;
          if (jt === qt.length ? Ct += qt : Ct += qt.slice(0, Rt), Rt -= jt, Rt === 0) {
            jt === qt.length ? (++Bt, kt.next ? this.head = kt.next : this.head = this.tail = null) : (this.head = kt, kt.data = qt.slice(jt));
            break;
          }
          ++Bt;
        }
        return this.length -= Bt, Ct;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(Rt) {
        var kt = Ee.allocUnsafe(Rt), Bt = this.head, Ct = 1;
        for (Bt.data.copy(kt), Rt -= Bt.data.length; Bt = Bt.next; ) {
          var qt = Bt.data, jt = Rt > qt.length ? qt.length : Rt;
          if (qt.copy(kt, kt.length - Rt, 0, jt), Rt -= jt, Rt === 0) {
            jt === qt.length ? (++Ct, Bt.next ? this.head = Bt.next : this.head = this.tail = null) : (this.head = Bt, Bt.data = qt.slice(jt));
            break;
          }
          ++Ct;
        }
        return this.length -= Ct, kt;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Ve,
      value: function(Rt, kt) {
        return Pe(this, z(z({}, kt), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), ht;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function B(ae, le) {
    var ge = this, Ee = this._readableState && this._readableState.destroyed, oe = this._writableState && this._writableState.destroyed;
    return Ee || oe ? (le ? le(ae) : ae && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(se, this, ae)) : process$1.nextTick(se, this, ae)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(ae || null, function(Pe) {
      !le && Pe ? ge._writableState ? ge._writableState.errorEmitted ? process$1.nextTick(Y, ge) : (ge._writableState.errorEmitted = !0, process$1.nextTick(z, ge, Pe)) : process$1.nextTick(z, ge, Pe) : le ? (process$1.nextTick(Y, ge), le(Pe)) : process$1.nextTick(Y, ge);
    }), this);
  }
  function z(ae, le) {
    se(ae, le), Y(ae);
  }
  function Y(ae) {
    ae._writableState && !ae._writableState.emitClose || ae._readableState && !ae._readableState.emitClose || ae.emit("close");
  }
  function ie() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function se(ae, le) {
    ae.emit("error", le);
  }
  function ne(ae, le) {
    var ge = ae._readableState, Ee = ae._writableState;
    ge && ge.autoDestroy || Ee && Ee.autoDestroy ? ae.destroy(le) : ae.emit("error", le);
  }
  return destroy_1$1 = {
    destroy: B,
    undestroy: ie,
    errorOrDestroy: ne
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function B(le, ge) {
    le.prototype = Object.create(ge.prototype), le.prototype.constructor = le, le.__proto__ = ge;
  }
  var z = {};
  function Y(le, ge, Ee) {
    Ee || (Ee = Error);
    function oe(Ve, Ke, ht) {
      return typeof ge == "string" ? ge : ge(Ve, Ke, ht);
    }
    var Pe = /* @__PURE__ */ function(Ve) {
      B(Ke, Ve);
      function Ke(ht, _t, Rt) {
        return Ve.call(this, oe(ht, _t, Rt)) || this;
      }
      return Ke;
    }(Ee);
    Pe.prototype.name = Ee.name, Pe.prototype.code = le, z[le] = Pe;
  }
  function ie(le, ge) {
    if (Array.isArray(le)) {
      var Ee = le.length;
      return le = le.map(function(oe) {
        return String(oe);
      }), Ee > 2 ? "one of ".concat(ge, " ").concat(le.slice(0, Ee - 1).join(", "), ", or ") + le[Ee - 1] : Ee === 2 ? "one of ".concat(ge, " ").concat(le[0], " or ").concat(le[1]) : "of ".concat(ge, " ").concat(le[0]);
    } else
      return "of ".concat(ge, " ").concat(String(le));
  }
  function se(le, ge, Ee) {
    return le.substr(0, ge.length) === ge;
  }
  function ne(le, ge, Ee) {
    return (Ee === void 0 || Ee > le.length) && (Ee = le.length), le.substring(Ee - ge.length, Ee) === ge;
  }
  function ae(le, ge, Ee) {
    return typeof Ee != "number" && (Ee = 0), Ee + ge.length > le.length ? !1 : le.indexOf(ge, Ee) !== -1;
  }
  return Y("ERR_INVALID_OPT_VALUE", function(le, ge) {
    return 'The value "' + ge + '" is invalid for option "' + le + '"';
  }, TypeError), Y("ERR_INVALID_ARG_TYPE", function(le, ge, Ee) {
    var oe;
    typeof ge == "string" && se(ge, "not ") ? (oe = "must not be", ge = ge.replace(/^not /, "")) : oe = "must be";
    var Pe;
    if (ne(le, " argument"))
      Pe = "The ".concat(le, " ").concat(oe, " ").concat(ie(ge, "type"));
    else {
      var Ve = ae(le, ".") ? "property" : "argument";
      Pe = 'The "'.concat(le, '" ').concat(Ve, " ").concat(oe, " ").concat(ie(ge, "type"));
    }
    return Pe += ". Received type ".concat(typeof Ee), Pe;
  }, TypeError), Y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), Y("ERR_METHOD_NOT_IMPLEMENTED", function(le) {
    return "The " + le + " method is not implemented";
  }), Y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), Y("ERR_STREAM_DESTROYED", function(le) {
    return "Cannot call " + le + " after a stream was destroyed";
  }), Y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), Y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), Y("ERR_STREAM_WRITE_AFTER_END", "write after end"), Y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), Y("ERR_UNKNOWN_ENCODING", function(le) {
    return "Unknown encoding: " + le;
  }, TypeError), Y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = z, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var B = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function z(ie, se, ne) {
    return ie.highWaterMark != null ? ie.highWaterMark : se ? ie[ne] : null;
  }
  function Y(ie, se, ne, ae) {
    var le = z(se, ae, ne);
    if (le != null) {
      if (!(isFinite(le) && Math.floor(le) === le) || le < 0) {
        var ge = ae ? ne : "highWaterMark";
        throw new B(ge, le);
      }
      return Math.floor(le);
    }
    return ie.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: Y
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a) return browser$a;
  hasRequiredBrowser$a = 1, browser$a = B;
  function B(Y, ie) {
    if (z("noDeprecation"))
      return Y;
    var se = !1;
    function ne() {
      if (!se) {
        if (z("throwDeprecation"))
          throw new Error(ie);
        z("traceDeprecation") ? console.trace(ie) : console.warn(ie), se = !0;
      }
      return Y.apply(this, arguments);
    }
    return ne;
  }
  function z(Y) {
    try {
      if (!commonjsGlobal.localStorage) return !1;
    } catch {
      return !1;
    }
    var ie = commonjsGlobal.localStorage[Y];
    return ie == null ? !1 : String(ie).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Ut;
  function B(Jt) {
    var Wt = this;
    this.next = null, this.entry = null, this.finish = function() {
      sr(Wt, Jt);
    };
  }
  var z;
  Ut.WritableState = Ht;
  var Y = {
    deprecate: requireBrowser$a()
  }, ie = requireStreamBrowser$1(), se = require$$0$1.Buffer, ne = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ae(Jt) {
    return se.from(Jt);
  }
  function le(Jt) {
    return se.isBuffer(Jt) || Jt instanceof ne;
  }
  var ge = requireDestroy$1(), Ee = requireState(), oe = Ee.getHighWaterMark, Pe = requireErrorsBrowser().codes, Ve = Pe.ERR_INVALID_ARG_TYPE, Ke = Pe.ERR_METHOD_NOT_IMPLEMENTED, ht = Pe.ERR_MULTIPLE_CALLBACK, _t = Pe.ERR_STREAM_CANNOT_PIPE, Rt = Pe.ERR_STREAM_DESTROYED, kt = Pe.ERR_STREAM_NULL_VALUES, Bt = Pe.ERR_STREAM_WRITE_AFTER_END, Ct = Pe.ERR_UNKNOWN_ENCODING, qt = ge.errorOrDestroy;
  requireInherits_browser()(Ut, ie);
  function jt() {
  }
  function Ht(Jt, Wt, Gt) {
    z = z || require_stream_duplex$1(), Jt = Jt || {}, typeof Gt != "boolean" && (Gt = Wt instanceof z), this.objectMode = !!Jt.objectMode, Gt && (this.objectMode = this.objectMode || !!Jt.writableObjectMode), this.highWaterMark = oe(this, Jt, "writableHighWaterMark", Gt), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var rr = Jt.decodeStrings === !1;
    this.decodeStrings = !rr, this.defaultEncoding = Jt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(or) {
      Qe(Wt, or);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Jt.emitClose !== !1, this.autoDestroy = !!Jt.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new B(this);
  }
  Ht.prototype.getBuffer = function() {
    for (var Wt = this.bufferedRequest, Gt = []; Wt; )
      Gt.push(Wt), Wt = Wt.next;
    return Gt;
  }, function() {
    try {
      Object.defineProperty(Ht.prototype, "buffer", {
        get: Y.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Yt;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Yt = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ut, Symbol.hasInstance, {
    value: function(Wt) {
      return Yt.call(this, Wt) ? !0 : this !== Ut ? !1 : Wt && Wt._writableState instanceof Ht;
    }
  })) : Yt = function(Wt) {
    return Wt instanceof this;
  };
  function Ut(Jt) {
    z = z || require_stream_duplex$1();
    var Wt = this instanceof z;
    if (!Wt && !Yt.call(Ut, this)) return new Ut(Jt);
    this._writableState = new Ht(Jt, this, Wt), this.writable = !0, Jt && (typeof Jt.write == "function" && (this._write = Jt.write), typeof Jt.writev == "function" && (this._writev = Jt.writev), typeof Jt.destroy == "function" && (this._destroy = Jt.destroy), typeof Jt.final == "function" && (this._final = Jt.final)), ie.call(this);
  }
  Ut.prototype.pipe = function() {
    qt(this, new _t());
  };
  function Nt(Jt, Wt) {
    var Gt = new Bt();
    qt(Jt, Gt), process$1.nextTick(Wt, Gt);
  }
  function Kt(Jt, Wt, Gt, rr) {
    var or;
    return Gt === null ? or = new kt() : typeof Gt != "string" && !Wt.objectMode && (or = new Ve("chunk", ["string", "Buffer"], Gt)), or ? (qt(Jt, or), process$1.nextTick(rr, or), !1) : !0;
  }
  Ut.prototype.write = function(Jt, Wt, Gt) {
    var rr = this._writableState, or = !1, Xt = !rr.objectMode && le(Jt);
    return Xt && !se.isBuffer(Jt) && (Jt = ae(Jt)), typeof Wt == "function" && (Gt = Wt, Wt = null), Xt ? Wt = "buffer" : Wt || (Wt = rr.defaultEncoding), typeof Gt != "function" && (Gt = jt), rr.ending ? Nt(this, Gt) : (Xt || Kt(this, rr, Jt, Gt)) && (rr.pendingcb++, or = bt(this, rr, Xt, Jt, Wt, Gt)), or;
  }, Ut.prototype.cork = function() {
    this._writableState.corked++;
  }, Ut.prototype.uncork = function() {
    var Jt = this._writableState;
    Jt.corked && (Jt.corked--, !Jt.writing && !Jt.corked && !Jt.bufferProcessing && Jt.bufferedRequest && $t(this, Jt));
  }, Ut.prototype.setDefaultEncoding = function(Wt) {
    if (typeof Wt == "string" && (Wt = Wt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Wt + "").toLowerCase()) > -1)) throw new Ct(Wt);
    return this._writableState.defaultEncoding = Wt, this;
  }, Object.defineProperty(Ut.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Ft(Jt, Wt, Gt) {
    return !Jt.objectMode && Jt.decodeStrings !== !1 && typeof Wt == "string" && (Wt = se.from(Wt, Gt)), Wt;
  }
  Object.defineProperty(Ut.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function bt(Jt, Wt, Gt, rr, or, Xt) {
    if (!Gt) {
      var zt = Ft(Wt, rr, or);
      rr !== zt && (Gt = !0, or = "buffer", rr = zt);
    }
    var ur = Wt.objectMode ? 1 : rr.length;
    Wt.length += ur;
    var hr = Wt.length < Wt.highWaterMark;
    if (hr || (Wt.needDrain = !0), Wt.writing || Wt.corked) {
      var yr = Wt.lastBufferedRequest;
      Wt.lastBufferedRequest = {
        chunk: rr,
        encoding: or,
        isBuf: Gt,
        callback: Xt,
        next: null
      }, yr ? yr.next = Wt.lastBufferedRequest : Wt.bufferedRequest = Wt.lastBufferedRequest, Wt.bufferedRequestCount += 1;
    } else
      Xe(Jt, Wt, !1, ur, rr, or, Xt);
    return hr;
  }
  function Xe(Jt, Wt, Gt, rr, or, Xt, zt) {
    Wt.writelen = rr, Wt.writecb = zt, Wt.writing = !0, Wt.sync = !0, Wt.destroyed ? Wt.onwrite(new Rt("write")) : Gt ? Jt._writev(or, Wt.onwrite) : Jt._write(or, Xt, Wt.onwrite), Wt.sync = !1;
  }
  function ve(Jt, Wt, Gt, rr, or) {
    --Wt.pendingcb, Gt ? (process$1.nextTick(or, rr), process$1.nextTick(Ot, Jt, Wt), Jt._writableState.errorEmitted = !0, qt(Jt, rr)) : (or(rr), Jt._writableState.errorEmitted = !0, qt(Jt, rr), Ot(Jt, Wt));
  }
  function Ce(Jt) {
    Jt.writing = !1, Jt.writecb = null, Jt.length -= Jt.writelen, Jt.writelen = 0;
  }
  function Qe(Jt, Wt) {
    var Gt = Jt._writableState, rr = Gt.sync, or = Gt.writecb;
    if (typeof or != "function") throw new ht();
    if (Ce(Gt), Wt) ve(Jt, Gt, rr, Wt, or);
    else {
      var Xt = xt(Gt) || Jt.destroyed;
      !Xt && !Gt.corked && !Gt.bufferProcessing && Gt.bufferedRequest && $t(Jt, Gt), rr ? process$1.nextTick(vt, Jt, Gt, Xt, or) : vt(Jt, Gt, Xt, or);
    }
  }
  function vt(Jt, Wt, Gt, rr) {
    Gt || wt(Jt, Wt), Wt.pendingcb--, rr(), Ot(Jt, Wt);
  }
  function wt(Jt, Wt) {
    Wt.length === 0 && Wt.needDrain && (Wt.needDrain = !1, Jt.emit("drain"));
  }
  function $t(Jt, Wt) {
    Wt.bufferProcessing = !0;
    var Gt = Wt.bufferedRequest;
    if (Jt._writev && Gt && Gt.next) {
      var rr = Wt.bufferedRequestCount, or = new Array(rr), Xt = Wt.corkedRequestsFree;
      Xt.entry = Gt;
      for (var zt = 0, ur = !0; Gt; )
        or[zt] = Gt, Gt.isBuf || (ur = !1), Gt = Gt.next, zt += 1;
      or.allBuffers = ur, Xe(Jt, Wt, !0, Wt.length, or, "", Xt.finish), Wt.pendingcb++, Wt.lastBufferedRequest = null, Xt.next ? (Wt.corkedRequestsFree = Xt.next, Xt.next = null) : Wt.corkedRequestsFree = new B(Wt), Wt.bufferedRequestCount = 0;
    } else {
      for (; Gt; ) {
        var hr = Gt.chunk, yr = Gt.encoding, Sr = Gt.callback, $r = Wt.objectMode ? 1 : hr.length;
        if (Xe(Jt, Wt, !1, $r, hr, yr, Sr), Gt = Gt.next, Wt.bufferedRequestCount--, Wt.writing)
          break;
      }
      Gt === null && (Wt.lastBufferedRequest = null);
    }
    Wt.bufferedRequest = Gt, Wt.bufferProcessing = !1;
  }
  Ut.prototype._write = function(Jt, Wt, Gt) {
    Gt(new Ke("_write()"));
  }, Ut.prototype._writev = null, Ut.prototype.end = function(Jt, Wt, Gt) {
    var rr = this._writableState;
    return typeof Jt == "function" ? (Gt = Jt, Jt = null, Wt = null) : typeof Wt == "function" && (Gt = Wt, Wt = null), Jt != null && this.write(Jt, Wt), rr.corked && (rr.corked = 1, this.uncork()), rr.ending || er(this, rr, Gt), this;
  }, Object.defineProperty(Ut.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function xt(Jt) {
    return Jt.ending && Jt.length === 0 && Jt.bufferedRequest === null && !Jt.finished && !Jt.writing;
  }
  function Pt(Jt, Wt) {
    Jt._final(function(Gt) {
      Wt.pendingcb--, Gt && qt(Jt, Gt), Wt.prefinished = !0, Jt.emit("prefinish"), Ot(Jt, Wt);
    });
  }
  function Je(Jt, Wt) {
    !Wt.prefinished && !Wt.finalCalled && (typeof Jt._final == "function" && !Wt.destroyed ? (Wt.pendingcb++, Wt.finalCalled = !0, process$1.nextTick(Pt, Jt, Wt)) : (Wt.prefinished = !0, Jt.emit("prefinish")));
  }
  function Ot(Jt, Wt) {
    var Gt = xt(Wt);
    if (Gt && (Je(Jt, Wt), Wt.pendingcb === 0 && (Wt.finished = !0, Jt.emit("finish"), Wt.autoDestroy))) {
      var rr = Jt._readableState;
      (!rr || rr.autoDestroy && rr.endEmitted) && Jt.destroy();
    }
    return Gt;
  }
  function er(Jt, Wt, Gt) {
    Wt.ending = !0, Ot(Jt, Wt), Gt && (Wt.finished ? process$1.nextTick(Gt) : Jt.once("finish", Gt)), Wt.ended = !0, Jt.writable = !1;
  }
  function sr(Jt, Wt, Gt) {
    var rr = Jt.entry;
    for (Jt.entry = null; rr; ) {
      var or = rr.callback;
      Wt.pendingcb--, or(Gt), rr = rr.next;
    }
    Wt.corkedRequestsFree.next = Jt;
  }
  return Object.defineProperty(Ut.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Wt) {
      this._writableState && (this._writableState.destroyed = Wt);
    }
  }), Ut.prototype.destroy = ge.destroy, Ut.prototype._undestroy = ge.undestroy, Ut.prototype._destroy = function(Jt, Wt) {
    Wt(Jt);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var B = Object.keys || function(Ee) {
    var oe = [];
    for (var Pe in Ee) oe.push(Pe);
    return oe;
  };
  _stream_duplex$1 = ae;
  var z = require_stream_readable$1(), Y = require_stream_writable$1();
  requireInherits_browser()(ae, z);
  for (var ie = B(Y.prototype), se = 0; se < ie.length; se++) {
    var ne = ie[se];
    ae.prototype[ne] || (ae.prototype[ne] = Y.prototype[ne]);
  }
  function ae(Ee) {
    if (!(this instanceof ae)) return new ae(Ee);
    z.call(this, Ee), Y.call(this, Ee), this.allowHalfOpen = !0, Ee && (Ee.readable === !1 && (this.readable = !1), Ee.writable === !1 && (this.writable = !1), Ee.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", le)));
  }
  Object.defineProperty(ae.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(ae.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(ae.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function le() {
    this._writableState.ended || process$1.nextTick(ge, this);
  }
  function ge(Ee) {
    Ee.end();
  }
  return Object.defineProperty(ae.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(oe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = oe, this._writableState.destroyed = oe);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var B = safeBufferExports.Buffer, z = B.isEncoding || function(kt) {
    switch (kt = "" + kt, kt && kt.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function Y(kt) {
    if (!kt) return "utf8";
    for (var Bt; ; )
      switch (kt) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return kt;
        default:
          if (Bt) return;
          kt = ("" + kt).toLowerCase(), Bt = !0;
      }
  }
  function ie(kt) {
    var Bt = Y(kt);
    if (typeof Bt != "string" && (B.isEncoding === z || !z(kt))) throw new Error("Unknown encoding: " + kt);
    return Bt || kt;
  }
  string_decoder.StringDecoder = se;
  function se(kt) {
    this.encoding = ie(kt);
    var Bt;
    switch (this.encoding) {
      case "utf16le":
        this.text = Pe, this.end = Ve, Bt = 4;
        break;
      case "utf8":
        this.fillLast = ge, Bt = 4;
        break;
      case "base64":
        this.text = Ke, this.end = ht, Bt = 3;
        break;
      default:
        this.write = _t, this.end = Rt;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = B.allocUnsafe(Bt);
  }
  se.prototype.write = function(kt) {
    if (kt.length === 0) return "";
    var Bt, Ct;
    if (this.lastNeed) {
      if (Bt = this.fillLast(kt), Bt === void 0) return "";
      Ct = this.lastNeed, this.lastNeed = 0;
    } else
      Ct = 0;
    return Ct < kt.length ? Bt ? Bt + this.text(kt, Ct) : this.text(kt, Ct) : Bt || "";
  }, se.prototype.end = oe, se.prototype.text = Ee, se.prototype.fillLast = function(kt) {
    if (this.lastNeed <= kt.length)
      return kt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    kt.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, kt.length), this.lastNeed -= kt.length;
  };
  function ne(kt) {
    return kt <= 127 ? 0 : kt >> 5 === 6 ? 2 : kt >> 4 === 14 ? 3 : kt >> 3 === 30 ? 4 : kt >> 6 === 2 ? -1 : -2;
  }
  function ae(kt, Bt, Ct) {
    var qt = Bt.length - 1;
    if (qt < Ct) return 0;
    var jt = ne(Bt[qt]);
    return jt >= 0 ? (jt > 0 && (kt.lastNeed = jt - 1), jt) : --qt < Ct || jt === -2 ? 0 : (jt = ne(Bt[qt]), jt >= 0 ? (jt > 0 && (kt.lastNeed = jt - 2), jt) : --qt < Ct || jt === -2 ? 0 : (jt = ne(Bt[qt]), jt >= 0 ? (jt > 0 && (jt === 2 ? jt = 0 : kt.lastNeed = jt - 3), jt) : 0));
  }
  function le(kt, Bt, Ct) {
    if ((Bt[0] & 192) !== 128)
      return kt.lastNeed = 0, "";
    if (kt.lastNeed > 1 && Bt.length > 1) {
      if ((Bt[1] & 192) !== 128)
        return kt.lastNeed = 1, "";
      if (kt.lastNeed > 2 && Bt.length > 2 && (Bt[2] & 192) !== 128)
        return kt.lastNeed = 2, "";
    }
  }
  function ge(kt) {
    var Bt = this.lastTotal - this.lastNeed, Ct = le(this, kt);
    if (Ct !== void 0) return Ct;
    if (this.lastNeed <= kt.length)
      return kt.copy(this.lastChar, Bt, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    kt.copy(this.lastChar, Bt, 0, kt.length), this.lastNeed -= kt.length;
  }
  function Ee(kt, Bt) {
    var Ct = ae(this, kt, Bt);
    if (!this.lastNeed) return kt.toString("utf8", Bt);
    this.lastTotal = Ct;
    var qt = kt.length - (Ct - this.lastNeed);
    return kt.copy(this.lastChar, 0, qt), kt.toString("utf8", Bt, qt);
  }
  function oe(kt) {
    var Bt = kt && kt.length ? this.write(kt) : "";
    return this.lastNeed ? Bt + "" : Bt;
  }
  function Pe(kt, Bt) {
    if ((kt.length - Bt) % 2 === 0) {
      var Ct = kt.toString("utf16le", Bt);
      if (Ct) {
        var qt = Ct.charCodeAt(Ct.length - 1);
        if (qt >= 55296 && qt <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = kt[kt.length - 2], this.lastChar[1] = kt[kt.length - 1], Ct.slice(0, -1);
      }
      return Ct;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = kt[kt.length - 1], kt.toString("utf16le", Bt, kt.length - 1);
  }
  function Ve(kt) {
    var Bt = kt && kt.length ? this.write(kt) : "";
    if (this.lastNeed) {
      var Ct = this.lastTotal - this.lastNeed;
      return Bt + this.lastChar.toString("utf16le", 0, Ct);
    }
    return Bt;
  }
  function Ke(kt, Bt) {
    var Ct = (kt.length - Bt) % 3;
    return Ct === 0 ? kt.toString("base64", Bt) : (this.lastNeed = 3 - Ct, this.lastTotal = 3, Ct === 1 ? this.lastChar[0] = kt[kt.length - 1] : (this.lastChar[0] = kt[kt.length - 2], this.lastChar[1] = kt[kt.length - 1]), kt.toString("base64", Bt, kt.length - Ct));
  }
  function ht(kt) {
    var Bt = kt && kt.length ? this.write(kt) : "";
    return this.lastNeed ? Bt + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : Bt;
  }
  function _t(kt) {
    return kt.toString(this.encoding);
  }
  function Rt(kt) {
    return kt && kt.length ? this.write(kt) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var B = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function z(ne) {
    var ae = !1;
    return function() {
      if (!ae) {
        ae = !0;
        for (var le = arguments.length, ge = new Array(le), Ee = 0; Ee < le; Ee++)
          ge[Ee] = arguments[Ee];
        ne.apply(this, ge);
      }
    };
  }
  function Y() {
  }
  function ie(ne) {
    return ne.setHeader && typeof ne.abort == "function";
  }
  function se(ne, ae, le) {
    if (typeof ae == "function") return se(ne, null, ae);
    ae || (ae = {}), le = z(le || Y);
    var ge = ae.readable || ae.readable !== !1 && ne.readable, Ee = ae.writable || ae.writable !== !1 && ne.writable, oe = function() {
      ne.writable || Ve();
    }, Pe = ne._writableState && ne._writableState.finished, Ve = function() {
      Ee = !1, Pe = !0, ge || le.call(ne);
    }, Ke = ne._readableState && ne._readableState.endEmitted, ht = function() {
      ge = !1, Ke = !0, Ee || le.call(ne);
    }, _t = function(Ct) {
      le.call(ne, Ct);
    }, Rt = function() {
      var Ct;
      if (ge && !Ke)
        return (!ne._readableState || !ne._readableState.ended) && (Ct = new B()), le.call(ne, Ct);
      if (Ee && !Pe)
        return (!ne._writableState || !ne._writableState.ended) && (Ct = new B()), le.call(ne, Ct);
    }, kt = function() {
      ne.req.on("finish", Ve);
    };
    return ie(ne) ? (ne.on("complete", Ve), ne.on("abort", Rt), ne.req ? kt() : ne.on("request", kt)) : Ee && !ne._writableState && (ne.on("end", oe), ne.on("close", oe)), ne.on("end", ht), ne.on("finish", Ve), ae.error !== !1 && ne.on("error", _t), ne.on("close", Rt), function() {
      ne.removeListener("complete", Ve), ne.removeListener("abort", Rt), ne.removeListener("request", kt), ne.req && ne.req.removeListener("finish", Ve), ne.removeListener("end", oe), ne.removeListener("close", oe), ne.removeListener("finish", Ve), ne.removeListener("end", ht), ne.removeListener("error", _t), ne.removeListener("close", Rt);
    };
  }
  return endOfStream = se, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var B;
  function z(Ct, qt, jt) {
    return qt = Y(qt), qt in Ct ? Object.defineProperty(Ct, qt, { value: jt, enumerable: !0, configurable: !0, writable: !0 }) : Ct[qt] = jt, Ct;
  }
  function Y(Ct) {
    var qt = ie(Ct, "string");
    return typeof qt == "symbol" ? qt : String(qt);
  }
  function ie(Ct, qt) {
    if (typeof Ct != "object" || Ct === null) return Ct;
    var jt = Ct[Symbol.toPrimitive];
    if (jt !== void 0) {
      var Ht = jt.call(Ct, qt);
      if (typeof Ht != "object") return Ht;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (qt === "string" ? String : Number)(Ct);
  }
  var se = requireEndOfStream(), ne = Symbol("lastResolve"), ae = Symbol("lastReject"), le = Symbol("error"), ge = Symbol("ended"), Ee = Symbol("lastPromise"), oe = Symbol("handlePromise"), Pe = Symbol("stream");
  function Ve(Ct, qt) {
    return {
      value: Ct,
      done: qt
    };
  }
  function Ke(Ct) {
    var qt = Ct[ne];
    if (qt !== null) {
      var jt = Ct[Pe].read();
      jt !== null && (Ct[Ee] = null, Ct[ne] = null, Ct[ae] = null, qt(Ve(jt, !1)));
    }
  }
  function ht(Ct) {
    process$1.nextTick(Ke, Ct);
  }
  function _t(Ct, qt) {
    return function(jt, Ht) {
      Ct.then(function() {
        if (qt[ge]) {
          jt(Ve(void 0, !0));
          return;
        }
        qt[oe](jt, Ht);
      }, Ht);
    };
  }
  var Rt = Object.getPrototypeOf(function() {
  }), kt = Object.setPrototypeOf((B = {
    get stream() {
      return this[Pe];
    },
    next: function() {
      var qt = this, jt = this[le];
      if (jt !== null)
        return Promise.reject(jt);
      if (this[ge])
        return Promise.resolve(Ve(void 0, !0));
      if (this[Pe].destroyed)
        return new Promise(function(Nt, Kt) {
          process$1.nextTick(function() {
            qt[le] ? Kt(qt[le]) : Nt(Ve(void 0, !0));
          });
        });
      var Ht = this[Ee], Yt;
      if (Ht)
        Yt = new Promise(_t(Ht, this));
      else {
        var Ut = this[Pe].read();
        if (Ut !== null)
          return Promise.resolve(Ve(Ut, !1));
        Yt = new Promise(this[oe]);
      }
      return this[Ee] = Yt, Yt;
    }
  }, z(B, Symbol.asyncIterator, function() {
    return this;
  }), z(B, "return", function() {
    var qt = this;
    return new Promise(function(jt, Ht) {
      qt[Pe].destroy(null, function(Yt) {
        if (Yt) {
          Ht(Yt);
          return;
        }
        jt(Ve(void 0, !0));
      });
    });
  }), B), Rt), Bt = function(qt) {
    var jt, Ht = Object.create(kt, (jt = {}, z(jt, Pe, {
      value: qt,
      writable: !0
    }), z(jt, ne, {
      value: null,
      writable: !0
    }), z(jt, ae, {
      value: null,
      writable: !0
    }), z(jt, le, {
      value: null,
      writable: !0
    }), z(jt, ge, {
      value: qt._readableState.endEmitted,
      writable: !0
    }), z(jt, oe, {
      value: function(Ut, Nt) {
        var Kt = Ht[Pe].read();
        Kt ? (Ht[Ee] = null, Ht[ne] = null, Ht[ae] = null, Ut(Ve(Kt, !1))) : (Ht[ne] = Ut, Ht[ae] = Nt);
      },
      writable: !0
    }), jt));
    return Ht[Ee] = null, se(qt, function(Yt) {
      if (Yt && Yt.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Ut = Ht[ae];
        Ut !== null && (Ht[Ee] = null, Ht[ne] = null, Ht[ae] = null, Ut(Yt)), Ht[le] = Yt;
        return;
      }
      var Nt = Ht[ne];
      Nt !== null && (Ht[Ee] = null, Ht[ne] = null, Ht[ae] = null, Nt(Ve(void 0, !0))), Ht[ge] = !0;
    }), qt.on("readable", ht.bind(null, Ht)), Ht;
  };
  return async_iterator = Bt, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Nt;
  var B;
  Nt.ReadableState = Ut, requireEvents().EventEmitter;
  var z = function(zt, ur) {
    return zt.listeners(ur).length;
  }, Y = requireStreamBrowser$1(), ie = require$$0$1.Buffer, se = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function ne(Xt) {
    return ie.from(Xt);
  }
  function ae(Xt) {
    return ie.isBuffer(Xt) || Xt instanceof se;
  }
  var le = requireUtil$1(), ge;
  le && le.debuglog ? ge = le.debuglog("stream") : ge = function() {
  };
  var Ee = requireBuffer_list(), oe = requireDestroy$1(), Pe = requireState(), Ve = Pe.getHighWaterMark, Ke = requireErrorsBrowser().codes, ht = Ke.ERR_INVALID_ARG_TYPE, _t = Ke.ERR_STREAM_PUSH_AFTER_EOF, Rt = Ke.ERR_METHOD_NOT_IMPLEMENTED, kt = Ke.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, Bt, Ct, qt;
  requireInherits_browser()(Nt, Y);
  var jt = oe.errorOrDestroy, Ht = ["error", "close", "destroy", "pause", "resume"];
  function Yt(Xt, zt, ur) {
    if (typeof Xt.prependListener == "function") return Xt.prependListener(zt, ur);
    !Xt._events || !Xt._events[zt] ? Xt.on(zt, ur) : Array.isArray(Xt._events[zt]) ? Xt._events[zt].unshift(ur) : Xt._events[zt] = [ur, Xt._events[zt]];
  }
  function Ut(Xt, zt, ur) {
    B = B || require_stream_duplex$1(), Xt = Xt || {}, typeof ur != "boolean" && (ur = zt instanceof B), this.objectMode = !!Xt.objectMode, ur && (this.objectMode = this.objectMode || !!Xt.readableObjectMode), this.highWaterMark = Ve(this, Xt, "readableHighWaterMark", ur), this.buffer = new Ee(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Xt.emitClose !== !1, this.autoDestroy = !!Xt.autoDestroy, this.destroyed = !1, this.defaultEncoding = Xt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Xt.encoding && (Bt || (Bt = requireString_decoder().StringDecoder), this.decoder = new Bt(Xt.encoding), this.encoding = Xt.encoding);
  }
  function Nt(Xt) {
    if (B = B || require_stream_duplex$1(), !(this instanceof Nt)) return new Nt(Xt);
    var zt = this instanceof B;
    this._readableState = new Ut(Xt, this, zt), this.readable = !0, Xt && (typeof Xt.read == "function" && (this._read = Xt.read), typeof Xt.destroy == "function" && (this._destroy = Xt.destroy)), Y.call(this);
  }
  Object.defineProperty(Nt.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(zt) {
      this._readableState && (this._readableState.destroyed = zt);
    }
  }), Nt.prototype.destroy = oe.destroy, Nt.prototype._undestroy = oe.undestroy, Nt.prototype._destroy = function(Xt, zt) {
    zt(Xt);
  }, Nt.prototype.push = function(Xt, zt) {
    var ur = this._readableState, hr;
    return ur.objectMode ? hr = !0 : typeof Xt == "string" && (zt = zt || ur.defaultEncoding, zt !== ur.encoding && (Xt = ie.from(Xt, zt), zt = ""), hr = !0), Kt(this, Xt, zt, !1, hr);
  }, Nt.prototype.unshift = function(Xt) {
    return Kt(this, Xt, null, !0, !1);
  };
  function Kt(Xt, zt, ur, hr, yr) {
    ge("readableAddChunk", zt);
    var Sr = Xt._readableState;
    if (zt === null)
      Sr.reading = !1, Qe(Xt, Sr);
    else {
      var $r;
      if (yr || ($r = bt(Sr, zt)), $r)
        jt(Xt, $r);
      else if (Sr.objectMode || zt && zt.length > 0)
        if (typeof zt != "string" && !Sr.objectMode && Object.getPrototypeOf(zt) !== ie.prototype && (zt = ne(zt)), hr)
          Sr.endEmitted ? jt(Xt, new kt()) : Ft(Xt, Sr, zt, !0);
        else if (Sr.ended)
          jt(Xt, new _t());
        else {
          if (Sr.destroyed)
            return !1;
          Sr.reading = !1, Sr.decoder && !ur ? (zt = Sr.decoder.write(zt), Sr.objectMode || zt.length !== 0 ? Ft(Xt, Sr, zt, !1) : $t(Xt, Sr)) : Ft(Xt, Sr, zt, !1);
        }
      else hr || (Sr.reading = !1, $t(Xt, Sr));
    }
    return !Sr.ended && (Sr.length < Sr.highWaterMark || Sr.length === 0);
  }
  function Ft(Xt, zt, ur, hr) {
    zt.flowing && zt.length === 0 && !zt.sync ? (zt.awaitDrain = 0, Xt.emit("data", ur)) : (zt.length += zt.objectMode ? 1 : ur.length, hr ? zt.buffer.unshift(ur) : zt.buffer.push(ur), zt.needReadable && vt(Xt)), $t(Xt, zt);
  }
  function bt(Xt, zt) {
    var ur;
    return !ae(zt) && typeof zt != "string" && zt !== void 0 && !Xt.objectMode && (ur = new ht("chunk", ["string", "Buffer", "Uint8Array"], zt)), ur;
  }
  Nt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Nt.prototype.setEncoding = function(Xt) {
    Bt || (Bt = requireString_decoder().StringDecoder);
    var zt = new Bt(Xt);
    this._readableState.decoder = zt, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var ur = this._readableState.buffer.head, hr = ""; ur !== null; )
      hr += zt.write(ur.data), ur = ur.next;
    return this._readableState.buffer.clear(), hr !== "" && this._readableState.buffer.push(hr), this._readableState.length = hr.length, this;
  };
  var Xe = 1073741824;
  function ve(Xt) {
    return Xt >= Xe ? Xt = Xe : (Xt--, Xt |= Xt >>> 1, Xt |= Xt >>> 2, Xt |= Xt >>> 4, Xt |= Xt >>> 8, Xt |= Xt >>> 16, Xt++), Xt;
  }
  function Ce(Xt, zt) {
    return Xt <= 0 || zt.length === 0 && zt.ended ? 0 : zt.objectMode ? 1 : Xt !== Xt ? zt.flowing && zt.length ? zt.buffer.head.data.length : zt.length : (Xt > zt.highWaterMark && (zt.highWaterMark = ve(Xt)), Xt <= zt.length ? Xt : zt.ended ? zt.length : (zt.needReadable = !0, 0));
  }
  Nt.prototype.read = function(Xt) {
    ge("read", Xt), Xt = parseInt(Xt, 10);
    var zt = this._readableState, ur = Xt;
    if (Xt !== 0 && (zt.emittedReadable = !1), Xt === 0 && zt.needReadable && ((zt.highWaterMark !== 0 ? zt.length >= zt.highWaterMark : zt.length > 0) || zt.ended))
      return ge("read: emitReadable", zt.length, zt.ended), zt.length === 0 && zt.ended ? Gt(this) : vt(this), null;
    if (Xt = Ce(Xt, zt), Xt === 0 && zt.ended)
      return zt.length === 0 && Gt(this), null;
    var hr = zt.needReadable;
    ge("need readable", hr), (zt.length === 0 || zt.length - Xt < zt.highWaterMark) && (hr = !0, ge("length less than watermark", hr)), zt.ended || zt.reading ? (hr = !1, ge("reading or ended", hr)) : hr && (ge("do read"), zt.reading = !0, zt.sync = !0, zt.length === 0 && (zt.needReadable = !0), this._read(zt.highWaterMark), zt.sync = !1, zt.reading || (Xt = Ce(ur, zt)));
    var yr;
    return Xt > 0 ? yr = Wt(Xt, zt) : yr = null, yr === null ? (zt.needReadable = zt.length <= zt.highWaterMark, Xt = 0) : (zt.length -= Xt, zt.awaitDrain = 0), zt.length === 0 && (zt.ended || (zt.needReadable = !0), ur !== Xt && zt.ended && Gt(this)), yr !== null && this.emit("data", yr), yr;
  };
  function Qe(Xt, zt) {
    if (ge("onEofChunk"), !zt.ended) {
      if (zt.decoder) {
        var ur = zt.decoder.end();
        ur && ur.length && (zt.buffer.push(ur), zt.length += zt.objectMode ? 1 : ur.length);
      }
      zt.ended = !0, zt.sync ? vt(Xt) : (zt.needReadable = !1, zt.emittedReadable || (zt.emittedReadable = !0, wt(Xt)));
    }
  }
  function vt(Xt) {
    var zt = Xt._readableState;
    ge("emitReadable", zt.needReadable, zt.emittedReadable), zt.needReadable = !1, zt.emittedReadable || (ge("emitReadable", zt.flowing), zt.emittedReadable = !0, process$1.nextTick(wt, Xt));
  }
  function wt(Xt) {
    var zt = Xt._readableState;
    ge("emitReadable_", zt.destroyed, zt.length, zt.ended), !zt.destroyed && (zt.length || zt.ended) && (Xt.emit("readable"), zt.emittedReadable = !1), zt.needReadable = !zt.flowing && !zt.ended && zt.length <= zt.highWaterMark, Jt(Xt);
  }
  function $t(Xt, zt) {
    zt.readingMore || (zt.readingMore = !0, process$1.nextTick(xt, Xt, zt));
  }
  function xt(Xt, zt) {
    for (; !zt.reading && !zt.ended && (zt.length < zt.highWaterMark || zt.flowing && zt.length === 0); ) {
      var ur = zt.length;
      if (ge("maybeReadMore read 0"), Xt.read(0), ur === zt.length)
        break;
    }
    zt.readingMore = !1;
  }
  Nt.prototype._read = function(Xt) {
    jt(this, new Rt("_read()"));
  }, Nt.prototype.pipe = function(Xt, zt) {
    var ur = this, hr = this._readableState;
    switch (hr.pipesCount) {
      case 0:
        hr.pipes = Xt;
        break;
      case 1:
        hr.pipes = [hr.pipes, Xt];
        break;
      default:
        hr.pipes.push(Xt);
        break;
    }
    hr.pipesCount += 1, ge("pipe count=%d opts=%j", hr.pipesCount, zt);
    var yr = (!zt || zt.end !== !1) && Xt !== process$1.stdout && Xt !== process$1.stderr, Sr = yr ? Mr : jr;
    hr.endEmitted ? process$1.nextTick(Sr) : ur.once("end", Sr), Xt.on("unpipe", $r);
    function $r(kr, Jr) {
      ge("onunpipe"), kr === ur && Jr && Jr.hasUnpiped === !1 && (Jr.hasUnpiped = !0, Ar());
    }
    function Mr() {
      ge("onend"), Xt.end();
    }
    var pr = Pt(ur);
    Xt.on("drain", pr);
    var Fr = !1;
    function Ar() {
      ge("cleanup"), Xt.removeListener("close", Rr), Xt.removeListener("finish", Vr), Xt.removeListener("drain", pr), Xt.removeListener("error", Lr), Xt.removeListener("unpipe", $r), ur.removeListener("end", Mr), ur.removeListener("end", jr), ur.removeListener("data", Gr), Fr = !0, hr.awaitDrain && (!Xt._writableState || Xt._writableState.needDrain) && pr();
    }
    ur.on("data", Gr);
    function Gr(kr) {
      ge("ondata");
      var Jr = Xt.write(kr);
      ge("dest.write", Jr), Jr === !1 && ((hr.pipesCount === 1 && hr.pipes === Xt || hr.pipesCount > 1 && or(hr.pipes, Xt) !== -1) && !Fr && (ge("false write response, pause", hr.awaitDrain), hr.awaitDrain++), ur.pause());
    }
    function Lr(kr) {
      ge("onerror", kr), jr(), Xt.removeListener("error", Lr), z(Xt, "error") === 0 && jt(Xt, kr);
    }
    Yt(Xt, "error", Lr);
    function Rr() {
      Xt.removeListener("finish", Vr), jr();
    }
    Xt.once("close", Rr);
    function Vr() {
      ge("onfinish"), Xt.removeListener("close", Rr), jr();
    }
    Xt.once("finish", Vr);
    function jr() {
      ge("unpipe"), ur.unpipe(Xt);
    }
    return Xt.emit("pipe", ur), hr.flowing || (ge("pipe resume"), ur.resume()), Xt;
  };
  function Pt(Xt) {
    return function() {
      var ur = Xt._readableState;
      ge("pipeOnDrain", ur.awaitDrain), ur.awaitDrain && ur.awaitDrain--, ur.awaitDrain === 0 && z(Xt, "data") && (ur.flowing = !0, Jt(Xt));
    };
  }
  Nt.prototype.unpipe = function(Xt) {
    var zt = this._readableState, ur = {
      hasUnpiped: !1
    };
    if (zt.pipesCount === 0) return this;
    if (zt.pipesCount === 1)
      return Xt && Xt !== zt.pipes ? this : (Xt || (Xt = zt.pipes), zt.pipes = null, zt.pipesCount = 0, zt.flowing = !1, Xt && Xt.emit("unpipe", this, ur), this);
    if (!Xt) {
      var hr = zt.pipes, yr = zt.pipesCount;
      zt.pipes = null, zt.pipesCount = 0, zt.flowing = !1;
      for (var Sr = 0; Sr < yr; Sr++) hr[Sr].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var $r = or(zt.pipes, Xt);
    return $r === -1 ? this : (zt.pipes.splice($r, 1), zt.pipesCount -= 1, zt.pipesCount === 1 && (zt.pipes = zt.pipes[0]), Xt.emit("unpipe", this, ur), this);
  }, Nt.prototype.on = function(Xt, zt) {
    var ur = Y.prototype.on.call(this, Xt, zt), hr = this._readableState;
    return Xt === "data" ? (hr.readableListening = this.listenerCount("readable") > 0, hr.flowing !== !1 && this.resume()) : Xt === "readable" && !hr.endEmitted && !hr.readableListening && (hr.readableListening = hr.needReadable = !0, hr.flowing = !1, hr.emittedReadable = !1, ge("on readable", hr.length, hr.reading), hr.length ? vt(this) : hr.reading || process$1.nextTick(Ot, this)), ur;
  }, Nt.prototype.addListener = Nt.prototype.on, Nt.prototype.removeListener = function(Xt, zt) {
    var ur = Y.prototype.removeListener.call(this, Xt, zt);
    return Xt === "readable" && process$1.nextTick(Je, this), ur;
  }, Nt.prototype.removeAllListeners = function(Xt) {
    var zt = Y.prototype.removeAllListeners.apply(this, arguments);
    return (Xt === "readable" || Xt === void 0) && process$1.nextTick(Je, this), zt;
  };
  function Je(Xt) {
    var zt = Xt._readableState;
    zt.readableListening = Xt.listenerCount("readable") > 0, zt.resumeScheduled && !zt.paused ? zt.flowing = !0 : Xt.listenerCount("data") > 0 && Xt.resume();
  }
  function Ot(Xt) {
    ge("readable nexttick read 0"), Xt.read(0);
  }
  Nt.prototype.resume = function() {
    var Xt = this._readableState;
    return Xt.flowing || (ge("resume"), Xt.flowing = !Xt.readableListening, er(this, Xt)), Xt.paused = !1, this;
  };
  function er(Xt, zt) {
    zt.resumeScheduled || (zt.resumeScheduled = !0, process$1.nextTick(sr, Xt, zt));
  }
  function sr(Xt, zt) {
    ge("resume", zt.reading), zt.reading || Xt.read(0), zt.resumeScheduled = !1, Xt.emit("resume"), Jt(Xt), zt.flowing && !zt.reading && Xt.read(0);
  }
  Nt.prototype.pause = function() {
    return ge("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (ge("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Jt(Xt) {
    var zt = Xt._readableState;
    for (ge("flow", zt.flowing); zt.flowing && Xt.read() !== null; ) ;
  }
  Nt.prototype.wrap = function(Xt) {
    var zt = this, ur = this._readableState, hr = !1;
    Xt.on("end", function() {
      if (ge("wrapped end"), ur.decoder && !ur.ended) {
        var $r = ur.decoder.end();
        $r && $r.length && zt.push($r);
      }
      zt.push(null);
    }), Xt.on("data", function($r) {
      if (ge("wrapped data"), ur.decoder && ($r = ur.decoder.write($r)), !(ur.objectMode && $r == null) && !(!ur.objectMode && (!$r || !$r.length))) {
        var Mr = zt.push($r);
        Mr || (hr = !0, Xt.pause());
      }
    });
    for (var yr in Xt)
      this[yr] === void 0 && typeof Xt[yr] == "function" && (this[yr] = /* @__PURE__ */ function(Mr) {
        return function() {
          return Xt[Mr].apply(Xt, arguments);
        };
      }(yr));
    for (var Sr = 0; Sr < Ht.length; Sr++)
      Xt.on(Ht[Sr], this.emit.bind(this, Ht[Sr]));
    return this._read = function($r) {
      ge("wrapped _read", $r), hr && (hr = !1, Xt.resume());
    }, this;
  }, typeof Symbol == "function" && (Nt.prototype[Symbol.asyncIterator] = function() {
    return Ct === void 0 && (Ct = requireAsync_iterator()), Ct(this);
  }), Object.defineProperty(Nt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Nt.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Nt.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(zt) {
      this._readableState && (this._readableState.flowing = zt);
    }
  }), Nt._fromList = Wt, Object.defineProperty(Nt.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Wt(Xt, zt) {
    if (zt.length === 0) return null;
    var ur;
    return zt.objectMode ? ur = zt.buffer.shift() : !Xt || Xt >= zt.length ? (zt.decoder ? ur = zt.buffer.join("") : zt.buffer.length === 1 ? ur = zt.buffer.first() : ur = zt.buffer.concat(zt.length), zt.buffer.clear()) : ur = zt.buffer.consume(Xt, zt.decoder), ur;
  }
  function Gt(Xt) {
    var zt = Xt._readableState;
    ge("endReadable", zt.endEmitted), zt.endEmitted || (zt.ended = !0, process$1.nextTick(rr, zt, Xt));
  }
  function rr(Xt, zt) {
    if (ge("endReadableNT", Xt.endEmitted, Xt.length), !Xt.endEmitted && Xt.length === 0 && (Xt.endEmitted = !0, zt.readable = !1, zt.emit("end"), Xt.autoDestroy)) {
      var ur = zt._writableState;
      (!ur || ur.autoDestroy && ur.finished) && zt.destroy();
    }
  }
  typeof Symbol == "function" && (Nt.from = function(Xt, zt) {
    return qt === void 0 && (qt = requireFromBrowser()), qt(Nt, Xt, zt);
  });
  function or(Xt, zt) {
    for (var ur = 0, hr = Xt.length; ur < hr; ur++)
      if (Xt[ur] === zt) return ur;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = le;
  var B = requireErrorsBrowser().codes, z = B.ERR_METHOD_NOT_IMPLEMENTED, Y = B.ERR_MULTIPLE_CALLBACK, ie = B.ERR_TRANSFORM_ALREADY_TRANSFORMING, se = B.ERR_TRANSFORM_WITH_LENGTH_0, ne = require_stream_duplex$1();
  requireInherits_browser()(le, ne);
  function ae(oe, Pe) {
    var Ve = this._transformState;
    Ve.transforming = !1;
    var Ke = Ve.writecb;
    if (Ke === null)
      return this.emit("error", new Y());
    Ve.writechunk = null, Ve.writecb = null, Pe != null && this.push(Pe), Ke(oe);
    var ht = this._readableState;
    ht.reading = !1, (ht.needReadable || ht.length < ht.highWaterMark) && this._read(ht.highWaterMark);
  }
  function le(oe) {
    if (!(this instanceof le)) return new le(oe);
    ne.call(this, oe), this._transformState = {
      afterTransform: ae.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, oe && (typeof oe.transform == "function" && (this._transform = oe.transform), typeof oe.flush == "function" && (this._flush = oe.flush)), this.on("prefinish", ge);
  }
  function ge() {
    var oe = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Pe, Ve) {
      Ee(oe, Pe, Ve);
    }) : Ee(this, null, null);
  }
  le.prototype.push = function(oe, Pe) {
    return this._transformState.needTransform = !1, ne.prototype.push.call(this, oe, Pe);
  }, le.prototype._transform = function(oe, Pe, Ve) {
    Ve(new z("_transform()"));
  }, le.prototype._write = function(oe, Pe, Ve) {
    var Ke = this._transformState;
    if (Ke.writecb = Ve, Ke.writechunk = oe, Ke.writeencoding = Pe, !Ke.transforming) {
      var ht = this._readableState;
      (Ke.needTransform || ht.needReadable || ht.length < ht.highWaterMark) && this._read(ht.highWaterMark);
    }
  }, le.prototype._read = function(oe) {
    var Pe = this._transformState;
    Pe.writechunk !== null && !Pe.transforming ? (Pe.transforming = !0, this._transform(Pe.writechunk, Pe.writeencoding, Pe.afterTransform)) : Pe.needTransform = !0;
  }, le.prototype._destroy = function(oe, Pe) {
    ne.prototype._destroy.call(this, oe, function(Ve) {
      Pe(Ve);
    });
  };
  function Ee(oe, Pe, Ve) {
    if (Pe) return oe.emit("error", Pe);
    if (Ve != null && oe.push(Ve), oe._writableState.length) throw new se();
    if (oe._transformState.transforming) throw new ie();
    return oe.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = z;
  var B = require_stream_transform$1();
  requireInherits_browser()(z, B);
  function z(Y) {
    if (!(this instanceof z)) return new z(Y);
    B.call(this, Y);
  }
  return z.prototype._transform = function(Y, ie, se) {
    se(null, Y);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var B;
  function z(Ve) {
    var Ke = !1;
    return function() {
      Ke || (Ke = !0, Ve.apply(void 0, arguments));
    };
  }
  var Y = requireErrorsBrowser().codes, ie = Y.ERR_MISSING_ARGS, se = Y.ERR_STREAM_DESTROYED;
  function ne(Ve) {
    if (Ve) throw Ve;
  }
  function ae(Ve) {
    return Ve.setHeader && typeof Ve.abort == "function";
  }
  function le(Ve, Ke, ht, _t) {
    _t = z(_t);
    var Rt = !1;
    Ve.on("close", function() {
      Rt = !0;
    }), B === void 0 && (B = requireEndOfStream()), B(Ve, {
      readable: Ke,
      writable: ht
    }, function(Bt) {
      if (Bt) return _t(Bt);
      Rt = !0, _t();
    });
    var kt = !1;
    return function(Bt) {
      if (!Rt && !kt) {
        if (kt = !0, ae(Ve)) return Ve.abort();
        if (typeof Ve.destroy == "function") return Ve.destroy();
        _t(Bt || new se("pipe"));
      }
    };
  }
  function ge(Ve) {
    Ve();
  }
  function Ee(Ve, Ke) {
    return Ve.pipe(Ke);
  }
  function oe(Ve) {
    return !Ve.length || typeof Ve[Ve.length - 1] != "function" ? ne : Ve.pop();
  }
  function Pe() {
    for (var Ve = arguments.length, Ke = new Array(Ve), ht = 0; ht < Ve; ht++)
      Ke[ht] = arguments[ht];
    var _t = oe(Ke);
    if (Array.isArray(Ke[0]) && (Ke = Ke[0]), Ke.length < 2)
      throw new ie("streams");
    var Rt, kt = Ke.map(function(Bt, Ct) {
      var qt = Ct < Ke.length - 1, jt = Ct > 0;
      return le(Bt, qt, jt, function(Ht) {
        Rt || (Rt = Ht), Ht && kt.forEach(ge), !qt && (kt.forEach(ge), _t(Rt));
      });
    });
    return Ke.reduce(Ee);
  }
  return pipeline_1 = Pe, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(B, z) {
    z = B.exports = require_stream_readable$1(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable$1(), z.Duplex = require_stream_duplex$1(), z.Transform = require_stream_transform$1(), z.PassThrough = require_stream_passthrough$1(), z.finished = requireEndOfStream(), z.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase) return hashBase;
  hasRequiredHashBase = 1;
  var B = safeBufferExports.Buffer, z = requireReadableBrowser$1().Transform, Y = requireInherits_browser();
  function ie(ne, ae) {
    if (!B.isBuffer(ne) && typeof ne != "string")
      throw new TypeError(ae + " must be a string or a buffer");
  }
  function se(ne) {
    z.call(this), this._block = B.allocUnsafe(ne), this._blockSize = ne, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return Y(se, z), se.prototype._transform = function(ne, ae, le) {
    var ge = null;
    try {
      this.update(ne, ae);
    } catch (Ee) {
      ge = Ee;
    }
    le(ge);
  }, se.prototype._flush = function(ne) {
    var ae = null;
    try {
      this.push(this.digest());
    } catch (le) {
      ae = le;
    }
    ne(ae);
  }, se.prototype.update = function(ne, ae) {
    if (ie(ne, "Data"), this._finalized) throw new Error("Digest already called");
    B.isBuffer(ne) || (ne = B.from(ne, ae));
    for (var le = this._block, ge = 0; this._blockOffset + ne.length - ge >= this._blockSize; ) {
      for (var Ee = this._blockOffset; Ee < this._blockSize; ) le[Ee++] = ne[ge++];
      this._update(), this._blockOffset = 0;
    }
    for (; ge < ne.length; ) le[this._blockOffset++] = ne[ge++];
    for (var oe = 0, Pe = ne.length * 8; Pe > 0; ++oe)
      this._length[oe] += Pe, Pe = this._length[oe] / 4294967296 | 0, Pe > 0 && (this._length[oe] -= 4294967296 * Pe);
    return this;
  }, se.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, se.prototype.digest = function(ne) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = !0;
    var ae = this._digest();
    ne !== void 0 && (ae = ae.toString(ne)), this._block.fill(0), this._blockOffset = 0;
    for (var le = 0; le < 4; ++le) this._length[le] = 0;
    return ae;
  }, se.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = se, hashBase;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js) return md5_js;
  hasRequiredMd5_js = 1;
  var B = requireInherits_browser(), z = requireHashBase(), Y = safeBufferExports.Buffer, ie = new Array(16);
  function se() {
    z.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  B(se, z), se.prototype._update = function() {
    for (var oe = ie, Pe = 0; Pe < 16; ++Pe) oe[Pe] = this._block.readInt32LE(Pe * 4);
    var Ve = this._a, Ke = this._b, ht = this._c, _t = this._d;
    Ve = ae(Ve, Ke, ht, _t, oe[0], 3614090360, 7), _t = ae(_t, Ve, Ke, ht, oe[1], 3905402710, 12), ht = ae(ht, _t, Ve, Ke, oe[2], 606105819, 17), Ke = ae(Ke, ht, _t, Ve, oe[3], 3250441966, 22), Ve = ae(Ve, Ke, ht, _t, oe[4], 4118548399, 7), _t = ae(_t, Ve, Ke, ht, oe[5], 1200080426, 12), ht = ae(ht, _t, Ve, Ke, oe[6], 2821735955, 17), Ke = ae(Ke, ht, _t, Ve, oe[7], 4249261313, 22), Ve = ae(Ve, Ke, ht, _t, oe[8], 1770035416, 7), _t = ae(_t, Ve, Ke, ht, oe[9], 2336552879, 12), ht = ae(ht, _t, Ve, Ke, oe[10], 4294925233, 17), Ke = ae(Ke, ht, _t, Ve, oe[11], 2304563134, 22), Ve = ae(Ve, Ke, ht, _t, oe[12], 1804603682, 7), _t = ae(_t, Ve, Ke, ht, oe[13], 4254626195, 12), ht = ae(ht, _t, Ve, Ke, oe[14], 2792965006, 17), Ke = ae(Ke, ht, _t, Ve, oe[15], 1236535329, 22), Ve = le(Ve, Ke, ht, _t, oe[1], 4129170786, 5), _t = le(_t, Ve, Ke, ht, oe[6], 3225465664, 9), ht = le(ht, _t, Ve, Ke, oe[11], 643717713, 14), Ke = le(Ke, ht, _t, Ve, oe[0], 3921069994, 20), Ve = le(Ve, Ke, ht, _t, oe[5], 3593408605, 5), _t = le(_t, Ve, Ke, ht, oe[10], 38016083, 9), ht = le(ht, _t, Ve, Ke, oe[15], 3634488961, 14), Ke = le(Ke, ht, _t, Ve, oe[4], 3889429448, 20), Ve = le(Ve, Ke, ht, _t, oe[9], 568446438, 5), _t = le(_t, Ve, Ke, ht, oe[14], 3275163606, 9), ht = le(ht, _t, Ve, Ke, oe[3], 4107603335, 14), Ke = le(Ke, ht, _t, Ve, oe[8], 1163531501, 20), Ve = le(Ve, Ke, ht, _t, oe[13], 2850285829, 5), _t = le(_t, Ve, Ke, ht, oe[2], 4243563512, 9), ht = le(ht, _t, Ve, Ke, oe[7], 1735328473, 14), Ke = le(Ke, ht, _t, Ve, oe[12], 2368359562, 20), Ve = ge(Ve, Ke, ht, _t, oe[5], 4294588738, 4), _t = ge(_t, Ve, Ke, ht, oe[8], 2272392833, 11), ht = ge(ht, _t, Ve, Ke, oe[11], 1839030562, 16), Ke = ge(Ke, ht, _t, Ve, oe[14], 4259657740, 23), Ve = ge(Ve, Ke, ht, _t, oe[1], 2763975236, 4), _t = ge(_t, Ve, Ke, ht, oe[4], 1272893353, 11), ht = ge(ht, _t, Ve, Ke, oe[7], 4139469664, 16), Ke = ge(Ke, ht, _t, Ve, oe[10], 3200236656, 23), Ve = ge(Ve, Ke, ht, _t, oe[13], 681279174, 4), _t = ge(_t, Ve, Ke, ht, oe[0], 3936430074, 11), ht = ge(ht, _t, Ve, Ke, oe[3], 3572445317, 16), Ke = ge(Ke, ht, _t, Ve, oe[6], 76029189, 23), Ve = ge(Ve, Ke, ht, _t, oe[9], 3654602809, 4), _t = ge(_t, Ve, Ke, ht, oe[12], 3873151461, 11), ht = ge(ht, _t, Ve, Ke, oe[15], 530742520, 16), Ke = ge(Ke, ht, _t, Ve, oe[2], 3299628645, 23), Ve = Ee(Ve, Ke, ht, _t, oe[0], 4096336452, 6), _t = Ee(_t, Ve, Ke, ht, oe[7], 1126891415, 10), ht = Ee(ht, _t, Ve, Ke, oe[14], 2878612391, 15), Ke = Ee(Ke, ht, _t, Ve, oe[5], 4237533241, 21), Ve = Ee(Ve, Ke, ht, _t, oe[12], 1700485571, 6), _t = Ee(_t, Ve, Ke, ht, oe[3], 2399980690, 10), ht = Ee(ht, _t, Ve, Ke, oe[10], 4293915773, 15), Ke = Ee(Ke, ht, _t, Ve, oe[1], 2240044497, 21), Ve = Ee(Ve, Ke, ht, _t, oe[8], 1873313359, 6), _t = Ee(_t, Ve, Ke, ht, oe[15], 4264355552, 10), ht = Ee(ht, _t, Ve, Ke, oe[6], 2734768916, 15), Ke = Ee(Ke, ht, _t, Ve, oe[13], 1309151649, 21), Ve = Ee(Ve, Ke, ht, _t, oe[4], 4149444226, 6), _t = Ee(_t, Ve, Ke, ht, oe[11], 3174756917, 10), ht = Ee(ht, _t, Ve, Ke, oe[2], 718787259, 15), Ke = Ee(Ke, ht, _t, Ve, oe[9], 3951481745, 21), this._a = this._a + Ve | 0, this._b = this._b + Ke | 0, this._c = this._c + ht | 0, this._d = this._d + _t | 0;
  }, se.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var oe = Y.allocUnsafe(16);
    return oe.writeInt32LE(this._a, 0), oe.writeInt32LE(this._b, 4), oe.writeInt32LE(this._c, 8), oe.writeInt32LE(this._d, 12), oe;
  };
  function ne(oe, Pe) {
    return oe << Pe | oe >>> 32 - Pe;
  }
  function ae(oe, Pe, Ve, Ke, ht, _t, Rt) {
    return ne(oe + (Pe & Ve | ~Pe & Ke) + ht + _t | 0, Rt) + Pe | 0;
  }
  function le(oe, Pe, Ve, Ke, ht, _t, Rt) {
    return ne(oe + (Pe & Ke | Ve & ~Ke) + ht + _t | 0, Rt) + Pe | 0;
  }
  function ge(oe, Pe, Ve, Ke, ht, _t, Rt) {
    return ne(oe + (Pe ^ Ve ^ Ke) + ht + _t | 0, Rt) + Pe | 0;
  }
  function Ee(oe, Pe, Ve, Ke, ht, _t, Rt) {
    return ne(oe + (Ve ^ (Pe | ~Ke)) + ht + _t | 0, Rt) + Pe | 0;
  }
  return md5_js = se, md5_js;
}
var ripemd160$1, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160$1;
  hasRequiredRipemd160 = 1;
  var B = require$$0$1.Buffer, z = requireInherits_browser(), Y = requireHashBase(), ie = new Array(16), se = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], ne = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], ae = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], le = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], ge = [0, 1518500249, 1859775393, 2400959708, 2840853838], Ee = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function oe() {
    Y.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  z(oe, Y), oe.prototype._update = function() {
    for (var kt = ie, Bt = 0; Bt < 16; ++Bt) kt[Bt] = this._block.readInt32LE(Bt * 4);
    for (var Ct = this._a | 0, qt = this._b | 0, jt = this._c | 0, Ht = this._d | 0, Yt = this._e | 0, Ut = this._a | 0, Nt = this._b | 0, Kt = this._c | 0, Ft = this._d | 0, bt = this._e | 0, Xe = 0; Xe < 80; Xe += 1) {
      var ve, Ce;
      Xe < 16 ? (ve = Ve(Ct, qt, jt, Ht, Yt, kt[se[Xe]], ge[0], ae[Xe]), Ce = Rt(Ut, Nt, Kt, Ft, bt, kt[ne[Xe]], Ee[0], le[Xe])) : Xe < 32 ? (ve = Ke(Ct, qt, jt, Ht, Yt, kt[se[Xe]], ge[1], ae[Xe]), Ce = _t(Ut, Nt, Kt, Ft, bt, kt[ne[Xe]], Ee[1], le[Xe])) : Xe < 48 ? (ve = ht(Ct, qt, jt, Ht, Yt, kt[se[Xe]], ge[2], ae[Xe]), Ce = ht(Ut, Nt, Kt, Ft, bt, kt[ne[Xe]], Ee[2], le[Xe])) : Xe < 64 ? (ve = _t(Ct, qt, jt, Ht, Yt, kt[se[Xe]], ge[3], ae[Xe]), Ce = Ke(Ut, Nt, Kt, Ft, bt, kt[ne[Xe]], Ee[3], le[Xe])) : (ve = Rt(Ct, qt, jt, Ht, Yt, kt[se[Xe]], ge[4], ae[Xe]), Ce = Ve(Ut, Nt, Kt, Ft, bt, kt[ne[Xe]], Ee[4], le[Xe])), Ct = Yt, Yt = Ht, Ht = Pe(jt, 10), jt = qt, qt = ve, Ut = bt, bt = Ft, Ft = Pe(Kt, 10), Kt = Nt, Nt = Ce;
    }
    var Qe = this._b + jt + Ft | 0;
    this._b = this._c + Ht + bt | 0, this._c = this._d + Yt + Ut | 0, this._d = this._e + Ct + Nt | 0, this._e = this._a + qt + Kt | 0, this._a = Qe;
  }, oe.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var kt = B.alloc ? B.alloc(20) : new B(20);
    return kt.writeInt32LE(this._a, 0), kt.writeInt32LE(this._b, 4), kt.writeInt32LE(this._c, 8), kt.writeInt32LE(this._d, 12), kt.writeInt32LE(this._e, 16), kt;
  };
  function Pe(kt, Bt) {
    return kt << Bt | kt >>> 32 - Bt;
  }
  function Ve(kt, Bt, Ct, qt, jt, Ht, Yt, Ut) {
    return Pe(kt + (Bt ^ Ct ^ qt) + Ht + Yt | 0, Ut) + jt | 0;
  }
  function Ke(kt, Bt, Ct, qt, jt, Ht, Yt, Ut) {
    return Pe(kt + (Bt & Ct | ~Bt & qt) + Ht + Yt | 0, Ut) + jt | 0;
  }
  function ht(kt, Bt, Ct, qt, jt, Ht, Yt, Ut) {
    return Pe(kt + ((Bt | ~Ct) ^ qt) + Ht + Yt | 0, Ut) + jt | 0;
  }
  function _t(kt, Bt, Ct, qt, jt, Ht, Yt, Ut) {
    return Pe(kt + (Bt & qt | Ct & ~qt) + Ht + Yt | 0, Ut) + jt | 0;
  }
  function Rt(kt, Bt, Ct, qt, jt, Ht, Yt, Ut) {
    return Pe(kt + (Bt ^ (Ct | ~qt)) + Ht + Yt | 0, Ut) + jt | 0;
  }
  return ripemd160$1 = oe, ripemd160$1;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1) return hash$1;
  hasRequiredHash$1 = 1;
  var B = safeBufferExports.Buffer;
  function z(Y, ie) {
    this._block = B.alloc(Y), this._finalSize = ie, this._blockSize = Y, this._len = 0;
  }
  return z.prototype.update = function(Y, ie) {
    typeof Y == "string" && (ie = ie || "utf8", Y = B.from(Y, ie));
    for (var se = this._block, ne = this._blockSize, ae = Y.length, le = this._len, ge = 0; ge < ae; ) {
      for (var Ee = le % ne, oe = Math.min(ae - ge, ne - Ee), Pe = 0; Pe < oe; Pe++)
        se[Ee + Pe] = Y[ge + Pe];
      le += oe, ge += oe, le % ne === 0 && this._update(se);
    }
    return this._len += ae, this;
  }, z.prototype.digest = function(Y) {
    var ie = this._len % this._blockSize;
    this._block[ie] = 128, this._block.fill(0, ie + 1), ie >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var se = this._len * 8;
    if (se <= 4294967295)
      this._block.writeUInt32BE(se, this._blockSize - 4);
    else {
      var ne = (se & 4294967295) >>> 0, ae = (se - ne) / 4294967296;
      this._block.writeUInt32BE(ae, this._blockSize - 8), this._block.writeUInt32BE(ne, this._blockSize - 4);
    }
    this._update(this._block);
    var le = this._hash();
    return Y ? le.toString(Y) : le;
  }, z.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = z, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1) return sha$1;
  hasRequiredSha$1 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ie = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], se = new Array(80);
  function ne() {
    this.init(), this._w = se, z.call(this, 64, 56);
  }
  B(ne, z), ne.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function ae(Ee) {
    return Ee << 5 | Ee >>> 27;
  }
  function le(Ee) {
    return Ee << 30 | Ee >>> 2;
  }
  function ge(Ee, oe, Pe, Ve) {
    return Ee === 0 ? oe & Pe | ~oe & Ve : Ee === 2 ? oe & Pe | oe & Ve | Pe & Ve : oe ^ Pe ^ Ve;
  }
  return ne.prototype._update = function(Ee) {
    for (var oe = this._w, Pe = this._a | 0, Ve = this._b | 0, Ke = this._c | 0, ht = this._d | 0, _t = this._e | 0, Rt = 0; Rt < 16; ++Rt) oe[Rt] = Ee.readInt32BE(Rt * 4);
    for (; Rt < 80; ++Rt) oe[Rt] = oe[Rt - 3] ^ oe[Rt - 8] ^ oe[Rt - 14] ^ oe[Rt - 16];
    for (var kt = 0; kt < 80; ++kt) {
      var Bt = ~~(kt / 20), Ct = ae(Pe) + ge(Bt, Ve, Ke, ht) + _t + oe[kt] + ie[Bt] | 0;
      _t = ht, ht = Ke, Ke = le(Ve), Ve = Pe, Pe = Ct;
    }
    this._a = Pe + this._a | 0, this._b = Ve + this._b | 0, this._c = Ke + this._c | 0, this._d = ht + this._d | 0, this._e = _t + this._e | 0;
  }, ne.prototype._hash = function() {
    var Ee = Y.allocUnsafe(20);
    return Ee.writeInt32BE(this._a | 0, 0), Ee.writeInt32BE(this._b | 0, 4), Ee.writeInt32BE(this._c | 0, 8), Ee.writeInt32BE(this._d | 0, 12), Ee.writeInt32BE(this._e | 0, 16), Ee;
  }, sha$1 = ne, sha$1;
}
var sha1$1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1;
  hasRequiredSha1 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ie = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], se = new Array(80);
  function ne() {
    this.init(), this._w = se, z.call(this, 64, 56);
  }
  B(ne, z), ne.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function ae(oe) {
    return oe << 1 | oe >>> 31;
  }
  function le(oe) {
    return oe << 5 | oe >>> 27;
  }
  function ge(oe) {
    return oe << 30 | oe >>> 2;
  }
  function Ee(oe, Pe, Ve, Ke) {
    return oe === 0 ? Pe & Ve | ~Pe & Ke : oe === 2 ? Pe & Ve | Pe & Ke | Ve & Ke : Pe ^ Ve ^ Ke;
  }
  return ne.prototype._update = function(oe) {
    for (var Pe = this._w, Ve = this._a | 0, Ke = this._b | 0, ht = this._c | 0, _t = this._d | 0, Rt = this._e | 0, kt = 0; kt < 16; ++kt) Pe[kt] = oe.readInt32BE(kt * 4);
    for (; kt < 80; ++kt) Pe[kt] = ae(Pe[kt - 3] ^ Pe[kt - 8] ^ Pe[kt - 14] ^ Pe[kt - 16]);
    for (var Bt = 0; Bt < 80; ++Bt) {
      var Ct = ~~(Bt / 20), qt = le(Ve) + Ee(Ct, Ke, ht, _t) + Rt + Pe[Bt] + ie[Ct] | 0;
      Rt = _t, _t = ht, ht = ge(Ke), Ke = Ve, Ve = qt;
    }
    this._a = Ve + this._a | 0, this._b = Ke + this._b | 0, this._c = ht + this._c | 0, this._d = _t + this._d | 0, this._e = Rt + this._e | 0;
  }, ne.prototype._hash = function() {
    var oe = Y.allocUnsafe(20);
    return oe.writeInt32BE(this._a | 0, 0), oe.writeInt32BE(this._b | 0, 4), oe.writeInt32BE(this._c | 0, 8), oe.writeInt32BE(this._d | 0, 12), oe.writeInt32BE(this._e | 0, 16), oe;
  }, sha1$1 = ne, sha1$1;
}
var sha256$3, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$3;
  hasRequiredSha256 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ie = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], se = new Array(64);
  function ne() {
    this.init(), this._w = se, z.call(this, 64, 56);
  }
  B(ne, z), ne.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function ae(Ve, Ke, ht) {
    return ht ^ Ve & (Ke ^ ht);
  }
  function le(Ve, Ke, ht) {
    return Ve & Ke | ht & (Ve | Ke);
  }
  function ge(Ve) {
    return (Ve >>> 2 | Ve << 30) ^ (Ve >>> 13 | Ve << 19) ^ (Ve >>> 22 | Ve << 10);
  }
  function Ee(Ve) {
    return (Ve >>> 6 | Ve << 26) ^ (Ve >>> 11 | Ve << 21) ^ (Ve >>> 25 | Ve << 7);
  }
  function oe(Ve) {
    return (Ve >>> 7 | Ve << 25) ^ (Ve >>> 18 | Ve << 14) ^ Ve >>> 3;
  }
  function Pe(Ve) {
    return (Ve >>> 17 | Ve << 15) ^ (Ve >>> 19 | Ve << 13) ^ Ve >>> 10;
  }
  return ne.prototype._update = function(Ve) {
    for (var Ke = this._w, ht = this._a | 0, _t = this._b | 0, Rt = this._c | 0, kt = this._d | 0, Bt = this._e | 0, Ct = this._f | 0, qt = this._g | 0, jt = this._h | 0, Ht = 0; Ht < 16; ++Ht) Ke[Ht] = Ve.readInt32BE(Ht * 4);
    for (; Ht < 64; ++Ht) Ke[Ht] = Pe(Ke[Ht - 2]) + Ke[Ht - 7] + oe(Ke[Ht - 15]) + Ke[Ht - 16] | 0;
    for (var Yt = 0; Yt < 64; ++Yt) {
      var Ut = jt + Ee(Bt) + ae(Bt, Ct, qt) + ie[Yt] + Ke[Yt] | 0, Nt = ge(ht) + le(ht, _t, Rt) | 0;
      jt = qt, qt = Ct, Ct = Bt, Bt = kt + Ut | 0, kt = Rt, Rt = _t, _t = ht, ht = Ut + Nt | 0;
    }
    this._a = ht + this._a | 0, this._b = _t + this._b | 0, this._c = Rt + this._c | 0, this._d = kt + this._d | 0, this._e = Bt + this._e | 0, this._f = Ct + this._f | 0, this._g = qt + this._g | 0, this._h = jt + this._h | 0;
  }, ne.prototype._hash = function() {
    var Ve = Y.allocUnsafe(32);
    return Ve.writeInt32BE(this._a, 0), Ve.writeInt32BE(this._b, 4), Ve.writeInt32BE(this._c, 8), Ve.writeInt32BE(this._d, 12), Ve.writeInt32BE(this._e, 16), Ve.writeInt32BE(this._f, 20), Ve.writeInt32BE(this._g, 24), Ve.writeInt32BE(this._h, 28), Ve;
  }, sha256$3 = ne, sha256$3;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224$1;
  hasRequiredSha224 = 1;
  var B = requireInherits_browser(), z = requireSha256(), Y = requireHash$1(), ie = safeBufferExports.Buffer, se = new Array(64);
  function ne() {
    this.init(), this._w = se, Y.call(this, 64, 56);
  }
  return B(ne, z), ne.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, ne.prototype._hash = function() {
    var ae = ie.allocUnsafe(28);
    return ae.writeInt32BE(this._a, 0), ae.writeInt32BE(this._b, 4), ae.writeInt32BE(this._c, 8), ae.writeInt32BE(this._d, 12), ae.writeInt32BE(this._e, 16), ae.writeInt32BE(this._f, 20), ae.writeInt32BE(this._g, 24), ae;
  }, sha224$1 = ne, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$1;
  hasRequiredSha512 = 1;
  var B = requireInherits_browser(), z = requireHash$1(), Y = safeBufferExports.Buffer, ie = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], se = new Array(160);
  function ne() {
    this.init(), this._w = se, z.call(this, 128, 112);
  }
  B(ne, z), ne.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function ae(_t, Rt, kt) {
    return kt ^ _t & (Rt ^ kt);
  }
  function le(_t, Rt, kt) {
    return _t & Rt | kt & (_t | Rt);
  }
  function ge(_t, Rt) {
    return (_t >>> 28 | Rt << 4) ^ (Rt >>> 2 | _t << 30) ^ (Rt >>> 7 | _t << 25);
  }
  function Ee(_t, Rt) {
    return (_t >>> 14 | Rt << 18) ^ (_t >>> 18 | Rt << 14) ^ (Rt >>> 9 | _t << 23);
  }
  function oe(_t, Rt) {
    return (_t >>> 1 | Rt << 31) ^ (_t >>> 8 | Rt << 24) ^ _t >>> 7;
  }
  function Pe(_t, Rt) {
    return (_t >>> 1 | Rt << 31) ^ (_t >>> 8 | Rt << 24) ^ (_t >>> 7 | Rt << 25);
  }
  function Ve(_t, Rt) {
    return (_t >>> 19 | Rt << 13) ^ (Rt >>> 29 | _t << 3) ^ _t >>> 6;
  }
  function Ke(_t, Rt) {
    return (_t >>> 19 | Rt << 13) ^ (Rt >>> 29 | _t << 3) ^ (_t >>> 6 | Rt << 26);
  }
  function ht(_t, Rt) {
    return _t >>> 0 < Rt >>> 0 ? 1 : 0;
  }
  return ne.prototype._update = function(_t) {
    for (var Rt = this._w, kt = this._ah | 0, Bt = this._bh | 0, Ct = this._ch | 0, qt = this._dh | 0, jt = this._eh | 0, Ht = this._fh | 0, Yt = this._gh | 0, Ut = this._hh | 0, Nt = this._al | 0, Kt = this._bl | 0, Ft = this._cl | 0, bt = this._dl | 0, Xe = this._el | 0, ve = this._fl | 0, Ce = this._gl | 0, Qe = this._hl | 0, vt = 0; vt < 32; vt += 2)
      Rt[vt] = _t.readInt32BE(vt * 4), Rt[vt + 1] = _t.readInt32BE(vt * 4 + 4);
    for (; vt < 160; vt += 2) {
      var wt = Rt[vt - 30], $t = Rt[vt - 15 * 2 + 1], xt = oe(wt, $t), Pt = Pe($t, wt);
      wt = Rt[vt - 2 * 2], $t = Rt[vt - 2 * 2 + 1];
      var Je = Ve(wt, $t), Ot = Ke($t, wt), er = Rt[vt - 7 * 2], sr = Rt[vt - 7 * 2 + 1], Jt = Rt[vt - 16 * 2], Wt = Rt[vt - 16 * 2 + 1], Gt = Pt + sr | 0, rr = xt + er + ht(Gt, Pt) | 0;
      Gt = Gt + Ot | 0, rr = rr + Je + ht(Gt, Ot) | 0, Gt = Gt + Wt | 0, rr = rr + Jt + ht(Gt, Wt) | 0, Rt[vt] = rr, Rt[vt + 1] = Gt;
    }
    for (var or = 0; or < 160; or += 2) {
      rr = Rt[or], Gt = Rt[or + 1];
      var Xt = le(kt, Bt, Ct), zt = le(Nt, Kt, Ft), ur = ge(kt, Nt), hr = ge(Nt, kt), yr = Ee(jt, Xe), Sr = Ee(Xe, jt), $r = ie[or], Mr = ie[or + 1], pr = ae(jt, Ht, Yt), Fr = ae(Xe, ve, Ce), Ar = Qe + Sr | 0, Gr = Ut + yr + ht(Ar, Qe) | 0;
      Ar = Ar + Fr | 0, Gr = Gr + pr + ht(Ar, Fr) | 0, Ar = Ar + Mr | 0, Gr = Gr + $r + ht(Ar, Mr) | 0, Ar = Ar + Gt | 0, Gr = Gr + rr + ht(Ar, Gt) | 0;
      var Lr = hr + zt | 0, Rr = ur + Xt + ht(Lr, hr) | 0;
      Ut = Yt, Qe = Ce, Yt = Ht, Ce = ve, Ht = jt, ve = Xe, Xe = bt + Ar | 0, jt = qt + Gr + ht(Xe, bt) | 0, qt = Ct, bt = Ft, Ct = Bt, Ft = Kt, Bt = kt, Kt = Nt, Nt = Ar + Lr | 0, kt = Gr + Rr + ht(Nt, Ar) | 0;
    }
    this._al = this._al + Nt | 0, this._bl = this._bl + Kt | 0, this._cl = this._cl + Ft | 0, this._dl = this._dl + bt | 0, this._el = this._el + Xe | 0, this._fl = this._fl + ve | 0, this._gl = this._gl + Ce | 0, this._hl = this._hl + Qe | 0, this._ah = this._ah + kt + ht(this._al, Nt) | 0, this._bh = this._bh + Bt + ht(this._bl, Kt) | 0, this._ch = this._ch + Ct + ht(this._cl, Ft) | 0, this._dh = this._dh + qt + ht(this._dl, bt) | 0, this._eh = this._eh + jt + ht(this._el, Xe) | 0, this._fh = this._fh + Ht + ht(this._fl, ve) | 0, this._gh = this._gh + Yt + ht(this._gl, Ce) | 0, this._hh = this._hh + Ut + ht(this._hl, Qe) | 0;
  }, ne.prototype._hash = function() {
    var _t = Y.allocUnsafe(64);
    function Rt(kt, Bt, Ct) {
      _t.writeInt32BE(kt, Ct), _t.writeInt32BE(Bt, Ct + 4);
    }
    return Rt(this._ah, this._al, 0), Rt(this._bh, this._bl, 8), Rt(this._ch, this._cl, 16), Rt(this._dh, this._dl, 24), Rt(this._eh, this._el, 32), Rt(this._fh, this._fl, 40), Rt(this._gh, this._gl, 48), Rt(this._hh, this._hl, 56), _t;
  }, sha512$1 = ne, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1;
  hasRequiredSha384 = 1;
  var B = requireInherits_browser(), z = requireSha512(), Y = requireHash$1(), ie = safeBufferExports.Buffer, se = new Array(160);
  function ne() {
    this.init(), this._w = se, Y.call(this, 128, 112);
  }
  return B(ne, z), ne.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, ne.prototype._hash = function() {
    var ae = ie.allocUnsafe(48);
    function le(ge, Ee, oe) {
      ae.writeInt32BE(ge, oe), ae.writeInt32BE(Ee, oe + 4);
    }
    return le(this._ah, this._al, 0), le(this._bh, this._bl, 8), le(this._ch, this._cl, 16), le(this._dh, this._dl, 24), le(this._eh, this._el, 32), le(this._fh, this._fl, 40), ae;
  }, sha384$1 = ne, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js) return sha_js.exports;
  hasRequiredSha_js = 1;
  var B = sha_js.exports = function(Y) {
    Y = Y.toLowerCase();
    var ie = B[Y];
    if (!ie) throw new Error(Y + " is not supported (we accept pull requests)");
    return new ie();
  };
  return B.sha = requireSha$1(), B.sha1 = requireSha1(), B.sha224 = requireSha224(), B.sha256 = requireSha256(), B.sha384 = requireSha384(), B.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = Y;
  var B = requireEvents().EventEmitter, z = requireInherits_browser();
  z(Y, B), Y.Readable = require_stream_readable$1(), Y.Writable = require_stream_writable$1(), Y.Duplex = require_stream_duplex$1(), Y.Transform = require_stream_transform$1(), Y.PassThrough = require_stream_passthrough$1(), Y.finished = requireEndOfStream(), Y.pipeline = requirePipeline(), Y.Stream = Y;
  function Y() {
    B.call(this);
  }
  return Y.prototype.pipe = function(ie, se) {
    var ne = this;
    function ae(Ke) {
      ie.writable && ie.write(Ke) === !1 && ne.pause && ne.pause();
    }
    ne.on("data", ae);
    function le() {
      ne.readable && ne.resume && ne.resume();
    }
    ie.on("drain", le), !ie._isStdio && (!se || se.end !== !1) && (ne.on("end", Ee), ne.on("close", oe));
    var ge = !1;
    function Ee() {
      ge || (ge = !0, ie.end());
    }
    function oe() {
      ge || (ge = !0, typeof ie.destroy == "function" && ie.destroy());
    }
    function Pe(Ke) {
      if (Ve(), B.listenerCount(this, "error") === 0)
        throw Ke;
    }
    ne.on("error", Pe), ie.on("error", Pe);
    function Ve() {
      ne.removeListener("data", ae), ie.removeListener("drain", le), ne.removeListener("end", Ee), ne.removeListener("close", oe), ne.removeListener("error", Pe), ie.removeListener("error", Pe), ne.removeListener("end", Ve), ne.removeListener("close", Ve), ie.removeListener("close", Ve);
    }
    return ne.on("end", Ve), ne.on("close", Ve), ie.on("close", Ve), ie.emit("pipe", ne), ie;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase) return cipherBase;
  hasRequiredCipherBase = 1;
  var B = safeBufferExports.Buffer, z = requireStreamBrowserify().Transform, Y = requireString_decoder().StringDecoder, ie = requireInherits_browser();
  function se(ge) {
    z.call(this), this.hashMode = typeof ge == "string", this.hashMode ? this[ge] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  ie(se, z);
  var ne = typeof Uint8Array < "u", ae = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (B.prototype instanceof Uint8Array || B.TYPED_ARRAY_SUPPORT);
  function le(ge, Ee) {
    if (ge instanceof B)
      return ge;
    if (typeof ge == "string")
      return B.from(ge, Ee);
    if (ae && ArrayBuffer.isView(ge)) {
      if (ge.byteLength === 0)
        return B.alloc(0);
      var oe = B.from(ge.buffer, ge.byteOffset, ge.byteLength);
      if (oe.byteLength === ge.byteLength)
        return oe;
    }
    if (ne && ge instanceof Uint8Array || B.isBuffer(ge) && ge.constructor && typeof ge.constructor.isBuffer == "function" && ge.constructor.isBuffer(ge))
      return B.from(ge);
    throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
  }
  return se.prototype.update = function(ge, Ee, oe) {
    var Pe = le(ge, Ee), Ve = this._update(Pe);
    return this.hashMode ? this : (oe && (Ve = this._toString(Ve, oe)), Ve);
  }, se.prototype.setAutoPadding = function() {
  }, se.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, se.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, se.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, se.prototype._transform = function(ge, Ee, oe) {
    var Pe;
    try {
      this.hashMode ? this._update(ge) : this.push(this._update(ge));
    } catch (Ve) {
      Pe = Ve;
    } finally {
      oe(Pe);
    }
  }, se.prototype._flush = function(ge) {
    var Ee;
    try {
      this.push(this.__final());
    } catch (oe) {
      Ee = oe;
    }
    ge(Ee);
  }, se.prototype._finalOrDigest = function(ge) {
    var Ee = this.__final() || B.alloc(0);
    return ge && (Ee = this._toString(Ee, ge, !0)), Ee;
  }, se.prototype._toString = function(ge, Ee, oe) {
    if (this._decoder || (this._decoder = new Y(Ee), this._encoding = Ee), this._encoding !== Ee)
      throw new Error("cant switch encodings");
    var Pe = this._decoder.write(ge);
    return oe && (Pe += this._decoder.end()), Pe;
  }, cipherBase = se, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9) return browser$9;
  hasRequiredBrowser$9 = 1;
  var B = requireInherits_browser(), z = requireMd5_js(), Y = requireRipemd160(), ie = requireSha_js(), se = requireCipherBase();
  function ne(ae) {
    se.call(this, "digest"), this._hash = ae;
  }
  return B(ne, se), ne.prototype._update = function(ae) {
    this._hash.update(ae);
  }, ne.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(le) {
    return le = le.toLowerCase(), le === "md5" ? new z() : le === "rmd160" || le === "ripemd160" ? new Y() : new ne(ie(le));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy) return legacy;
  hasRequiredLegacy = 1;
  var B = requireInherits_browser(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ie = z.alloc(128), se = 64;
  function ne(ae, le) {
    Y.call(this, "digest"), typeof le == "string" && (le = z.from(le)), this._alg = ae, this._key = le, le.length > se ? le = ae(le) : le.length < se && (le = z.concat([le, ie], se));
    for (var ge = this._ipad = z.allocUnsafe(se), Ee = this._opad = z.allocUnsafe(se), oe = 0; oe < se; oe++)
      ge[oe] = le[oe] ^ 54, Ee[oe] = le[oe] ^ 92;
    this._hash = [ge];
  }
  return B(ne, Y), ne.prototype._update = function(ae) {
    this._hash.push(ae);
  }, ne.prototype._final = function() {
    var ae = this._alg(z.concat(this._hash));
    return this._alg(z.concat([this._opad, ae]));
  }, legacy = ne, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  var B = requireMd5_js();
  return md5 = function(z) {
    return new B().update(z).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8) return browser$8;
  hasRequiredBrowser$8 = 1;
  var B = requireInherits_browser(), z = requireLegacy(), Y = requireCipherBase(), ie = safeBufferExports.Buffer, se = requireMd5(), ne = requireRipemd160(), ae = requireSha_js(), le = ie.alloc(128);
  function ge(Ee, oe) {
    Y.call(this, "digest"), typeof oe == "string" && (oe = ie.from(oe));
    var Pe = Ee === "sha512" || Ee === "sha384" ? 128 : 64;
    if (this._alg = Ee, this._key = oe, oe.length > Pe) {
      var Ve = Ee === "rmd160" ? new ne() : ae(Ee);
      oe = Ve.update(oe).digest();
    } else oe.length < Pe && (oe = ie.concat([oe, le], Pe));
    for (var Ke = this._ipad = ie.allocUnsafe(Pe), ht = this._opad = ie.allocUnsafe(Pe), _t = 0; _t < Pe; _t++)
      Ke[_t] = oe[_t] ^ 54, ht[_t] = oe[_t] ^ 92;
    this._hash = Ee === "rmd160" ? new ne() : ae(Ee), this._hash.update(Ke);
  }
  return B(ge, Y), ge.prototype._update = function(Ee) {
    this._hash.update(Ee);
  }, ge.prototype._final = function() {
    var Ee = this._hash.digest(), oe = this._alg === "rmd160" ? new ne() : ae(this._alg);
    return oe.update(this._opad).update(Ee).digest();
  }, browser$8 = function(oe, Pe) {
    return oe = oe.toLowerCase(), oe === "rmd160" || oe === "ripemd160" ? new ge("rmd160", Pe) : oe === "md5" ? new z(se, Pe) : new ge(oe, Pe);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256$2 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: sha256$2,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition) return precondition;
  hasRequiredPrecondition = 1;
  var B = Math.pow(2, 30) - 1;
  return precondition = function(z, Y) {
    if (typeof z != "number")
      throw new TypeError("Iterations not a number");
    if (z < 0)
      throw new TypeError("Bad iterations");
    if (typeof Y != "number")
      throw new TypeError("Key length not a number");
    if (Y < 0 || Y > B || Y !== Y)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding) return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var B;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    B = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var z = parseInt(process$1.version.split(".")[0].slice(1), 10);
    B = z >= 6 ? "utf-8" : "binary";
  } else
    B = "utf-8";
  return defaultEncoding_1 = B, defaultEncoding_1;
}
var toBuffer$1, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer) return toBuffer$1;
  hasRequiredToBuffer = 1;
  var B = safeBufferExports.Buffer;
  return toBuffer$1 = function(z, Y, ie) {
    if (B.isBuffer(z))
      return z;
    if (typeof z == "string")
      return B.from(z, Y);
    if (ArrayBuffer.isView(z))
      return B.from(z.buffer);
    throw new TypeError(ie + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer$1;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser) return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var B = requireMd5(), z = requireRipemd160(), Y = requireSha_js(), ie = safeBufferExports.Buffer, se = requirePrecondition(), ne = requireDefaultEncoding(), ae = requireToBuffer(), le = ie.alloc(128), ge = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function Ee(Ve, Ke, ht) {
    var _t = oe(Ve), Rt = Ve === "sha512" || Ve === "sha384" ? 128 : 64;
    Ke.length > Rt ? Ke = _t(Ke) : Ke.length < Rt && (Ke = ie.concat([Ke, le], Rt));
    for (var kt = ie.allocUnsafe(Rt + ge[Ve]), Bt = ie.allocUnsafe(Rt + ge[Ve]), Ct = 0; Ct < Rt; Ct++)
      kt[Ct] = Ke[Ct] ^ 54, Bt[Ct] = Ke[Ct] ^ 92;
    var qt = ie.allocUnsafe(Rt + ht + 4);
    kt.copy(qt, 0, 0, Rt), this.ipad1 = qt, this.ipad2 = kt, this.opad = Bt, this.alg = Ve, this.blocksize = Rt, this.hash = _t, this.size = ge[Ve];
  }
  Ee.prototype.run = function(Ve, Ke) {
    Ve.copy(Ke, this.blocksize);
    var ht = this.hash(Ke);
    return ht.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function oe(Ve) {
    function Ke(_t) {
      return Y(Ve).update(_t).digest();
    }
    function ht(_t) {
      return new z().update(_t).digest();
    }
    return Ve === "rmd160" || Ve === "ripemd160" ? ht : Ve === "md5" ? B : Ke;
  }
  function Pe(Ve, Ke, ht, _t, Rt) {
    se(ht, _t), Ve = ae(Ve, ne, "Password"), Ke = ae(Ke, ne, "Salt"), Rt = Rt || "sha1";
    var kt = new Ee(Rt, Ve, Ke.length), Bt = ie.allocUnsafe(_t), Ct = ie.allocUnsafe(Ke.length + 4);
    Ke.copy(Ct, 0, 0, Ke.length);
    for (var qt = 0, jt = ge[Rt], Ht = Math.ceil(_t / jt), Yt = 1; Yt <= Ht; Yt++) {
      Ct.writeUInt32BE(Yt, Ke.length);
      for (var Ut = kt.run(Ct, kt.ipad1), Nt = Ut, Kt = 1; Kt < ht; Kt++) {
        Nt = kt.run(Nt, kt.ipad2);
        for (var Ft = 0; Ft < jt; Ft++) Ut[Ft] ^= Nt[Ft];
      }
      Ut.copy(Bt, qt), qt += jt;
    }
    return Bt;
  }
  return syncBrowser = Pe, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var B = safeBufferExports.Buffer, z = requirePrecondition(), Y = requireDefaultEncoding(), ie = requireSyncBrowser(), se = requireToBuffer(), ne, ae = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, le = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, ge = [];
  function Ee(ht) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !ae || !ae.importKey || !ae.deriveBits)
      return Promise.resolve(!1);
    if (ge[ht] !== void 0)
      return ge[ht];
    ne = ne || B.alloc(8);
    var _t = Ve(ne, ne, 10, 128, ht).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return ge[ht] = _t, _t;
  }
  var oe;
  function Pe() {
    return oe || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? oe = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? oe = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? oe = commonjsGlobal.setImmediate : oe = commonjsGlobal.setTimeout, oe);
  }
  function Ve(ht, _t, Rt, kt, Bt) {
    return ae.importKey(
      "raw",
      ht,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(Ct) {
      return ae.deriveBits({
        name: "PBKDF2",
        salt: _t,
        iterations: Rt,
        hash: {
          name: Bt
        }
      }, Ct, kt << 3);
    }).then(function(Ct) {
      return B.from(Ct);
    });
  }
  function Ke(ht, _t) {
    ht.then(function(Rt) {
      Pe()(function() {
        _t(null, Rt);
      });
    }, function(Rt) {
      Pe()(function() {
        _t(Rt);
      });
    });
  }
  return async = function(ht, _t, Rt, kt, Bt, Ct) {
    typeof Bt == "function" && (Ct = Bt, Bt = void 0), Bt = Bt || "sha1";
    var qt = le[Bt.toLowerCase()];
    if (!qt || typeof commonjsGlobal.Promise != "function") {
      Pe()(function() {
        var jt;
        try {
          jt = ie(ht, _t, Rt, kt, Bt);
        } catch (Ht) {
          return Ct(Ht);
        }
        Ct(null, jt);
      });
      return;
    }
    if (z(Rt, kt), ht = se(ht, Y, "Password"), _t = se(_t, Y, "Salt"), typeof Ct != "function") throw new Error("No callback provided to pbkdf2");
    Ke(Ee(qt).then(function(jt) {
      return jt ? Ve(ht, _t, Rt, kt, qt) : ie(ht, _t, Rt, kt, Bt);
    }), Ct);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$4 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3) return utils$4;
  hasRequiredUtils$3 = 1, utils$4.readUInt32BE = function(se, ne) {
    var ae = se[0 + ne] << 24 | se[1 + ne] << 16 | se[2 + ne] << 8 | se[3 + ne];
    return ae >>> 0;
  }, utils$4.writeUInt32BE = function(se, ne, ae) {
    se[0 + ae] = ne >>> 24, se[1 + ae] = ne >>> 16 & 255, se[2 + ae] = ne >>> 8 & 255, se[3 + ae] = ne & 255;
  }, utils$4.ip = function(se, ne, ae, le) {
    for (var ge = 0, Ee = 0, oe = 6; oe >= 0; oe -= 2) {
      for (var Pe = 0; Pe <= 24; Pe += 8)
        ge <<= 1, ge |= ne >>> Pe + oe & 1;
      for (var Pe = 0; Pe <= 24; Pe += 8)
        ge <<= 1, ge |= se >>> Pe + oe & 1;
    }
    for (var oe = 6; oe >= 0; oe -= 2) {
      for (var Pe = 1; Pe <= 25; Pe += 8)
        Ee <<= 1, Ee |= ne >>> Pe + oe & 1;
      for (var Pe = 1; Pe <= 25; Pe += 8)
        Ee <<= 1, Ee |= se >>> Pe + oe & 1;
    }
    ae[le + 0] = ge >>> 0, ae[le + 1] = Ee >>> 0;
  }, utils$4.rip = function(se, ne, ae, le) {
    for (var ge = 0, Ee = 0, oe = 0; oe < 4; oe++)
      for (var Pe = 24; Pe >= 0; Pe -= 8)
        ge <<= 1, ge |= ne >>> Pe + oe & 1, ge <<= 1, ge |= se >>> Pe + oe & 1;
    for (var oe = 4; oe < 8; oe++)
      for (var Pe = 24; Pe >= 0; Pe -= 8)
        Ee <<= 1, Ee |= ne >>> Pe + oe & 1, Ee <<= 1, Ee |= se >>> Pe + oe & 1;
    ae[le + 0] = ge >>> 0, ae[le + 1] = Ee >>> 0;
  }, utils$4.pc1 = function(se, ne, ae, le) {
    for (var ge = 0, Ee = 0, oe = 7; oe >= 5; oe--) {
      for (var Pe = 0; Pe <= 24; Pe += 8)
        ge <<= 1, ge |= ne >> Pe + oe & 1;
      for (var Pe = 0; Pe <= 24; Pe += 8)
        ge <<= 1, ge |= se >> Pe + oe & 1;
    }
    for (var Pe = 0; Pe <= 24; Pe += 8)
      ge <<= 1, ge |= ne >> Pe + oe & 1;
    for (var oe = 1; oe <= 3; oe++) {
      for (var Pe = 0; Pe <= 24; Pe += 8)
        Ee <<= 1, Ee |= ne >> Pe + oe & 1;
      for (var Pe = 0; Pe <= 24; Pe += 8)
        Ee <<= 1, Ee |= se >> Pe + oe & 1;
    }
    for (var Pe = 0; Pe <= 24; Pe += 8)
      Ee <<= 1, Ee |= se >> Pe + oe & 1;
    ae[le + 0] = ge >>> 0, ae[le + 1] = Ee >>> 0;
  }, utils$4.r28shl = function(se, ne) {
    return se << ne & 268435455 | se >>> 28 - ne;
  };
  var B = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$4.pc2 = function(se, ne, ae, le) {
    for (var ge = 0, Ee = 0, oe = B.length >>> 1, Pe = 0; Pe < oe; Pe++)
      ge <<= 1, ge |= se >>> B[Pe] & 1;
    for (var Pe = oe; Pe < B.length; Pe++)
      Ee <<= 1, Ee |= ne >>> B[Pe] & 1;
    ae[le + 0] = ge >>> 0, ae[le + 1] = Ee >>> 0;
  }, utils$4.expand = function(se, ne, ae) {
    var le = 0, ge = 0;
    le = (se & 1) << 5 | se >>> 27;
    for (var Ee = 23; Ee >= 15; Ee -= 4)
      le <<= 6, le |= se >>> Ee & 63;
    for (var Ee = 11; Ee >= 3; Ee -= 4)
      ge |= se >>> Ee & 63, ge <<= 6;
    ge |= (se & 31) << 1 | se >>> 31, ne[ae + 0] = le >>> 0, ne[ae + 1] = ge >>> 0;
  };
  var z = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$4.substitute = function(se, ne) {
    for (var ae = 0, le = 0; le < 4; le++) {
      var ge = se >>> 18 - le * 6 & 63, Ee = z[le * 64 + ge];
      ae <<= 4, ae |= Ee;
    }
    for (var le = 0; le < 4; le++) {
      var ge = ne >>> 18 - le * 6 & 63, Ee = z[4 * 64 + le * 64 + ge];
      ae <<= 4, ae |= Ee;
    }
    return ae >>> 0;
  };
  var Y = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$4.permute = function(se) {
    for (var ne = 0, ae = 0; ae < Y.length; ae++)
      ne <<= 1, ne |= se >>> Y[ae] & 1;
    return ne >>> 0;
  }, utils$4.padSplit = function(se, ne, ae) {
    for (var le = se.toString(2); le.length < ne; )
      le = "0" + le;
    for (var ge = [], Ee = 0; Ee < ne; Ee += ae)
      ge.push(le.slice(Ee, Ee + ae));
    return ge.join(" ");
  }, utils$4;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert) return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = B;
  function B(z, Y) {
    if (!z)
      throw new Error(Y || "Assertion failed");
  }
  return B.equal = function(Y, ie, se) {
    if (Y != ie)
      throw new Error(se || "Assertion failed: " + Y + " != " + ie);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher) return cipher;
  hasRequiredCipher = 1;
  var B = requireMinimalisticAssert();
  function z(Y) {
    this.options = Y, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = Y.padding !== !1;
  }
  return cipher = z, z.prototype._init = function() {
  }, z.prototype.update = function(ie) {
    return ie.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(ie) : this._updateEncrypt(ie);
  }, z.prototype._buffer = function(ie, se) {
    for (var ne = Math.min(this.buffer.length - this.bufferOff, ie.length - se), ae = 0; ae < ne; ae++)
      this.buffer[this.bufferOff + ae] = ie[se + ae];
    return this.bufferOff += ne, ne;
  }, z.prototype._flushBuffer = function(ie, se) {
    return this._update(this.buffer, 0, ie, se), this.bufferOff = 0, this.blockSize;
  }, z.prototype._updateEncrypt = function(ie) {
    var se = 0, ne = 0, ae = (this.bufferOff + ie.length) / this.blockSize | 0, le = new Array(ae * this.blockSize);
    this.bufferOff !== 0 && (se += this._buffer(ie, se), this.bufferOff === this.buffer.length && (ne += this._flushBuffer(le, ne)));
    for (var ge = ie.length - (ie.length - se) % this.blockSize; se < ge; se += this.blockSize)
      this._update(ie, se, le, ne), ne += this.blockSize;
    for (; se < ie.length; se++, this.bufferOff++)
      this.buffer[this.bufferOff] = ie[se];
    return le;
  }, z.prototype._updateDecrypt = function(ie) {
    for (var se = 0, ne = 0, ae = Math.ceil((this.bufferOff + ie.length) / this.blockSize) - 1, le = new Array(ae * this.blockSize); ae > 0; ae--)
      se += this._buffer(ie, se), ne += this._flushBuffer(le, ne);
    return se += this._buffer(ie, se), le;
  }, z.prototype.final = function(ie) {
    var se;
    ie && (se = this.update(ie));
    var ne;
    return this.type === "encrypt" ? ne = this._finalEncrypt() : ne = this._finalDecrypt(), se ? se.concat(ne) : ne;
  }, z.prototype._pad = function(ie, se) {
    if (se === 0)
      return !1;
    for (; se < ie.length; )
      ie[se++] = 0;
    return !0;
  }, z.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var ie = new Array(this.blockSize);
    return this._update(this.buffer, 0, ie, 0), ie;
  }, z.prototype._unpad = function(ie) {
    return ie;
  }, z.prototype._finalDecrypt = function() {
    B.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var ie = new Array(this.blockSize);
    return this._flushBuffer(ie, 0), this._unpad(ie);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1) return des;
  hasRequiredDes$1 = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = requireUtils$3(), ie = requireCipher();
  function se() {
    this.tmp = new Array(2), this.keys = null;
  }
  function ne(le) {
    ie.call(this, le);
    var ge = new se();
    this._desState = ge, this.deriveKeys(ge, le.key);
  }
  z(ne, ie), des = ne, ne.create = function(ge) {
    return new ne(ge);
  };
  var ae = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return ne.prototype.deriveKeys = function(ge, Ee) {
    ge.keys = new Array(16 * 2), B.equal(Ee.length, this.blockSize, "Invalid key length");
    var oe = Y.readUInt32BE(Ee, 0), Pe = Y.readUInt32BE(Ee, 4);
    Y.pc1(oe, Pe, ge.tmp, 0), oe = ge.tmp[0], Pe = ge.tmp[1];
    for (var Ve = 0; Ve < ge.keys.length; Ve += 2) {
      var Ke = ae[Ve >>> 1];
      oe = Y.r28shl(oe, Ke), Pe = Y.r28shl(Pe, Ke), Y.pc2(oe, Pe, ge.keys, Ve);
    }
  }, ne.prototype._update = function(ge, Ee, oe, Pe) {
    var Ve = this._desState, Ke = Y.readUInt32BE(ge, Ee), ht = Y.readUInt32BE(ge, Ee + 4);
    Y.ip(Ke, ht, Ve.tmp, 0), Ke = Ve.tmp[0], ht = Ve.tmp[1], this.type === "encrypt" ? this._encrypt(Ve, Ke, ht, Ve.tmp, 0) : this._decrypt(Ve, Ke, ht, Ve.tmp, 0), Ke = Ve.tmp[0], ht = Ve.tmp[1], Y.writeUInt32BE(oe, Ke, Pe), Y.writeUInt32BE(oe, ht, Pe + 4);
  }, ne.prototype._pad = function(ge, Ee) {
    if (this.padding === !1)
      return !1;
    for (var oe = ge.length - Ee, Pe = Ee; Pe < ge.length; Pe++)
      ge[Pe] = oe;
    return !0;
  }, ne.prototype._unpad = function(ge) {
    if (this.padding === !1)
      return ge;
    for (var Ee = ge[ge.length - 1], oe = ge.length - Ee; oe < ge.length; oe++)
      B.equal(ge[oe], Ee);
    return ge.slice(0, ge.length - Ee);
  }, ne.prototype._encrypt = function(ge, Ee, oe, Pe, Ve) {
    for (var Ke = Ee, ht = oe, _t = 0; _t < ge.keys.length; _t += 2) {
      var Rt = ge.keys[_t], kt = ge.keys[_t + 1];
      Y.expand(ht, ge.tmp, 0), Rt ^= ge.tmp[0], kt ^= ge.tmp[1];
      var Bt = Y.substitute(Rt, kt), Ct = Y.permute(Bt), qt = ht;
      ht = (Ke ^ Ct) >>> 0, Ke = qt;
    }
    Y.rip(ht, Ke, Pe, Ve);
  }, ne.prototype._decrypt = function(ge, Ee, oe, Pe, Ve) {
    for (var Ke = oe, ht = Ee, _t = ge.keys.length - 2; _t >= 0; _t -= 2) {
      var Rt = ge.keys[_t], kt = ge.keys[_t + 1];
      Y.expand(Ke, ge.tmp, 0), Rt ^= ge.tmp[0], kt ^= ge.tmp[1];
      var Bt = Y.substitute(Rt, kt), Ct = Y.permute(Bt), qt = Ke;
      Ke = (ht ^ Ct) >>> 0, ht = qt;
    }
    Y.rip(Ke, ht, Pe, Ve);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1) return cbc$1;
  hasRequiredCbc$1 = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = {};
  function ie(ne) {
    B.equal(ne.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var ae = 0; ae < this.iv.length; ae++)
      this.iv[ae] = ne[ae];
  }
  function se(ne) {
    function ae(oe) {
      ne.call(this, oe), this._cbcInit();
    }
    z(ae, ne);
    for (var le = Object.keys(Y), ge = 0; ge < le.length; ge++) {
      var Ee = le[ge];
      ae.prototype[Ee] = Y[Ee];
    }
    return ae.create = function(Pe) {
      return new ae(Pe);
    }, ae;
  }
  return cbc$1.instantiate = se, Y._cbcInit = function() {
    var ae = new ie(this.options.iv);
    this._cbcState = ae;
  }, Y._update = function(ae, le, ge, Ee) {
    var oe = this._cbcState, Pe = this.constructor.super_.prototype, Ve = oe.iv;
    if (this.type === "encrypt") {
      for (var Ke = 0; Ke < this.blockSize; Ke++)
        Ve[Ke] ^= ae[le + Ke];
      Pe._update.call(this, Ve, 0, ge, Ee);
      for (var Ke = 0; Ke < this.blockSize; Ke++)
        Ve[Ke] = ge[Ee + Ke];
    } else {
      Pe._update.call(this, ae, le, ge, Ee);
      for (var Ke = 0; Ke < this.blockSize; Ke++)
        ge[Ee + Ke] ^= Ve[Ke];
      for (var Ke = 0; Ke < this.blockSize; Ke++)
        Ve[Ke] = ae[le + Ke];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde) return ede;
  hasRequiredEde = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser(), Y = requireCipher(), ie = requireDes$1();
  function se(ae, le) {
    B.equal(le.length, 24, "Invalid key length");
    var ge = le.slice(0, 8), Ee = le.slice(8, 16), oe = le.slice(16, 24);
    ae === "encrypt" ? this.ciphers = [
      ie.create({ type: "encrypt", key: ge }),
      ie.create({ type: "decrypt", key: Ee }),
      ie.create({ type: "encrypt", key: oe })
    ] : this.ciphers = [
      ie.create({ type: "decrypt", key: oe }),
      ie.create({ type: "encrypt", key: Ee }),
      ie.create({ type: "decrypt", key: ge })
    ];
  }
  function ne(ae) {
    Y.call(this, ae);
    var le = new se(this.type, this.options.key);
    this._edeState = le;
  }
  return z(ne, Y), ede = ne, ne.create = function(le) {
    return new ne(le);
  }, ne.prototype._update = function(le, ge, Ee, oe) {
    var Pe = this._edeState;
    Pe.ciphers[0]._update(le, ge, Ee, oe), Pe.ciphers[1]._update(Ee, oe, Ee, oe), Pe.ciphers[2]._update(Ee, oe, Ee, oe);
  }, ne.prototype._pad = ie.prototype._pad, ne.prototype._unpad = ie.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes) return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var B = requireCipherBase(), z = requireDes(), Y = requireInherits_browser(), ie = safeBufferExports.Buffer, se = {
    "des-ede3-cbc": z.CBC.instantiate(z.EDE),
    "des-ede3": z.EDE,
    "des-ede-cbc": z.CBC.instantiate(z.EDE),
    "des-ede": z.EDE,
    "des-cbc": z.CBC.instantiate(z.DES),
    "des-ecb": z.DES
  };
  se.des = se["des-cbc"], se.des3 = se["des-ede3-cbc"], browserifyDes = ne, Y(ne, B);
  function ne(ae) {
    B.call(this);
    var le = ae.mode.toLowerCase(), ge = se[le], Ee;
    ae.decrypt ? Ee = "decrypt" : Ee = "encrypt";
    var oe = ae.key;
    ie.isBuffer(oe) || (oe = ie.from(oe)), (le === "des-ede" || le === "des-ede-cbc") && (oe = ie.concat([oe, oe.slice(0, 8)]));
    var Pe = ae.iv;
    ie.isBuffer(Pe) || (Pe = ie.from(Pe)), this._des = ge.create({
      key: oe,
      iv: Pe,
      type: Ee
    });
  }
  return ne.prototype._update = function(ae) {
    return ie.from(this._des.update(ae));
  }, ne.prototype._final = function() {
    return ie.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(B, z) {
    return B._cipher.encryptBlock(z);
  }, ecb.decrypt = function(B, z) {
    return B._cipher.decryptBlock(z);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(z, Y) {
    for (var ie = Math.min(z.length, Y.length), se = new Buffer$1(ie), ne = 0; ne < ie; ++ne)
      se[ne] = z[ne] ^ Y[ne];
    return se;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc) return cbc;
  hasRequiredCbc = 1;
  var B = requireBufferXor();
  return cbc.encrypt = function(z, Y) {
    var ie = B(Y, z._prev);
    return z._prev = z._cipher.encryptBlock(ie), z._prev;
  }, cbc.decrypt = function(z, Y) {
    var ie = z._prev;
    z._prev = Y;
    var se = z._cipher.decryptBlock(Y);
    return B(se, ie);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb) return cfb;
  hasRequiredCfb = 1;
  var B = safeBufferExports.Buffer, z = requireBufferXor();
  function Y(ie, se, ne) {
    var ae = se.length, le = z(se, ie._cache);
    return ie._cache = ie._cache.slice(ae), ie._prev = B.concat([ie._prev, ne ? se : le]), le;
  }
  return cfb.encrypt = function(ie, se, ne) {
    for (var ae = B.allocUnsafe(0), le; se.length; )
      if (ie._cache.length === 0 && (ie._cache = ie._cipher.encryptBlock(ie._prev), ie._prev = B.allocUnsafe(0)), ie._cache.length <= se.length)
        le = ie._cache.length, ae = B.concat([ae, Y(ie, se.slice(0, le), ne)]), se = se.slice(le);
      else {
        ae = B.concat([ae, Y(ie, se, ne)]);
        break;
      }
    return ae;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8) return cfb8;
  hasRequiredCfb8 = 1;
  var B = safeBufferExports.Buffer;
  function z(Y, ie, se) {
    var ne = Y._cipher.encryptBlock(Y._prev), ae = ne[0] ^ ie;
    return Y._prev = B.concat([
      Y._prev.slice(1),
      B.from([se ? ie : ae])
    ]), ae;
  }
  return cfb8.encrypt = function(Y, ie, se) {
    for (var ne = ie.length, ae = B.allocUnsafe(ne), le = -1; ++le < ne; )
      ae[le] = z(Y, ie[le], se);
    return ae;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1) return cfb1;
  hasRequiredCfb1 = 1;
  var B = safeBufferExports.Buffer;
  function z(ie, se, ne) {
    for (var ae, le = -1, ge = 8, Ee = 0, oe, Pe; ++le < ge; )
      ae = ie._cipher.encryptBlock(ie._prev), oe = se & 1 << 7 - le ? 128 : 0, Pe = ae[0] ^ oe, Ee += (Pe & 128) >> le % 8, ie._prev = Y(ie._prev, ne ? oe : Pe);
    return Ee;
  }
  function Y(ie, se) {
    var ne = ie.length, ae = -1, le = B.allocUnsafe(ie.length);
    for (ie = B.concat([ie, B.from([se])]); ++ae < ne; )
      le[ae] = ie[ae] << 1 | ie[ae + 1] >> 7;
    return le;
  }
  return cfb1.encrypt = function(ie, se, ne) {
    for (var ae = se.length, le = B.allocUnsafe(ae), ge = -1; ++ge < ae; )
      le[ge] = z(ie, se[ge], ne);
    return le;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb) return ofb;
  hasRequiredOfb = 1;
  var B = requireBufferXor();
  function z(Y) {
    return Y._prev = Y._cipher.encryptBlock(Y._prev), Y._prev;
  }
  return ofb.encrypt = function(Y, ie) {
    for (; Y._cache.length < ie.length; )
      Y._cache = Buffer$1.concat([Y._cache, z(Y)]);
    var se = Y._cache.slice(0, ie.length);
    return Y._cache = Y._cache.slice(ie.length), B(ie, se);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32) return incr32_1;
  hasRequiredIncr32 = 1;
  function B(z) {
    for (var Y = z.length, ie; Y--; )
      if (ie = z.readUInt8(Y), ie === 255)
        z.writeUInt8(0, Y);
      else {
        ie++, z.writeUInt8(ie, Y);
        break;
      }
  }
  return incr32_1 = B, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr) return ctr;
  hasRequiredCtr = 1;
  var B = requireBufferXor(), z = safeBufferExports.Buffer, Y = requireIncr32();
  function ie(ne) {
    var ae = ne._cipher.encryptBlockRaw(ne._prev);
    return Y(ne._prev), ae;
  }
  var se = 16;
  return ctr.encrypt = function(ne, ae) {
    var le = Math.ceil(ae.length / se), ge = ne._cache.length;
    ne._cache = z.concat([
      ne._cache,
      z.allocUnsafe(le * se)
    ]);
    for (var Ee = 0; Ee < le; Ee++) {
      var oe = ie(ne), Pe = ge + Ee * se;
      ne._cache.writeUInt32BE(oe[0], Pe + 0), ne._cache.writeUInt32BE(oe[1], Pe + 4), ne._cache.writeUInt32BE(oe[2], Pe + 8), ne._cache.writeUInt32BE(oe[3], Pe + 12);
    }
    var Ve = ne._cache.slice(0, ae.length);
    return ne._cache = ne._cache.slice(ae.length), B(ae, Ve);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1) return modes_1;
  hasRequiredModes$1 = 1;
  var B = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, z = require$$2;
  for (var Y in z)
    z[Y].module = B[z[Y].mode];
  return modes_1 = z, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes;
  hasRequiredAes = 1;
  var B = safeBufferExports.Buffer;
  function z(le) {
    B.isBuffer(le) || (le = B.from(le));
    for (var ge = le.length / 4 | 0, Ee = new Array(ge), oe = 0; oe < ge; oe++)
      Ee[oe] = le.readUInt32BE(oe * 4);
    return Ee;
  }
  function Y(le) {
    for (var ge = 0; ge < le.length; le++)
      le[ge] = 0;
  }
  function ie(le, ge, Ee, oe, Pe) {
    for (var Ve = Ee[0], Ke = Ee[1], ht = Ee[2], _t = Ee[3], Rt = le[0] ^ ge[0], kt = le[1] ^ ge[1], Bt = le[2] ^ ge[2], Ct = le[3] ^ ge[3], qt, jt, Ht, Yt, Ut = 4, Nt = 1; Nt < Pe; Nt++)
      qt = Ve[Rt >>> 24] ^ Ke[kt >>> 16 & 255] ^ ht[Bt >>> 8 & 255] ^ _t[Ct & 255] ^ ge[Ut++], jt = Ve[kt >>> 24] ^ Ke[Bt >>> 16 & 255] ^ ht[Ct >>> 8 & 255] ^ _t[Rt & 255] ^ ge[Ut++], Ht = Ve[Bt >>> 24] ^ Ke[Ct >>> 16 & 255] ^ ht[Rt >>> 8 & 255] ^ _t[kt & 255] ^ ge[Ut++], Yt = Ve[Ct >>> 24] ^ Ke[Rt >>> 16 & 255] ^ ht[kt >>> 8 & 255] ^ _t[Bt & 255] ^ ge[Ut++], Rt = qt, kt = jt, Bt = Ht, Ct = Yt;
    return qt = (oe[Rt >>> 24] << 24 | oe[kt >>> 16 & 255] << 16 | oe[Bt >>> 8 & 255] << 8 | oe[Ct & 255]) ^ ge[Ut++], jt = (oe[kt >>> 24] << 24 | oe[Bt >>> 16 & 255] << 16 | oe[Ct >>> 8 & 255] << 8 | oe[Rt & 255]) ^ ge[Ut++], Ht = (oe[Bt >>> 24] << 24 | oe[Ct >>> 16 & 255] << 16 | oe[Rt >>> 8 & 255] << 8 | oe[kt & 255]) ^ ge[Ut++], Yt = (oe[Ct >>> 24] << 24 | oe[Rt >>> 16 & 255] << 16 | oe[kt >>> 8 & 255] << 8 | oe[Bt & 255]) ^ ge[Ut++], qt = qt >>> 0, jt = jt >>> 0, Ht = Ht >>> 0, Yt = Yt >>> 0, [qt, jt, Ht, Yt];
  }
  var se = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], ne = function() {
    for (var le = new Array(256), ge = 0; ge < 256; ge++)
      ge < 128 ? le[ge] = ge << 1 : le[ge] = ge << 1 ^ 283;
    for (var Ee = [], oe = [], Pe = [[], [], [], []], Ve = [[], [], [], []], Ke = 0, ht = 0, _t = 0; _t < 256; ++_t) {
      var Rt = ht ^ ht << 1 ^ ht << 2 ^ ht << 3 ^ ht << 4;
      Rt = Rt >>> 8 ^ Rt & 255 ^ 99, Ee[Ke] = Rt, oe[Rt] = Ke;
      var kt = le[Ke], Bt = le[kt], Ct = le[Bt], qt = le[Rt] * 257 ^ Rt * 16843008;
      Pe[0][Ke] = qt << 24 | qt >>> 8, Pe[1][Ke] = qt << 16 | qt >>> 16, Pe[2][Ke] = qt << 8 | qt >>> 24, Pe[3][Ke] = qt, qt = Ct * 16843009 ^ Bt * 65537 ^ kt * 257 ^ Ke * 16843008, Ve[0][Rt] = qt << 24 | qt >>> 8, Ve[1][Rt] = qt << 16 | qt >>> 16, Ve[2][Rt] = qt << 8 | qt >>> 24, Ve[3][Rt] = qt, Ke === 0 ? Ke = ht = 1 : (Ke = kt ^ le[le[le[Ct ^ kt]]], ht ^= le[le[ht]]);
    }
    return {
      SBOX: Ee,
      INV_SBOX: oe,
      SUB_MIX: Pe,
      INV_SUB_MIX: Ve
    };
  }();
  function ae(le) {
    this._key = z(le), this._reset();
  }
  return ae.blockSize = 4 * 4, ae.keySize = 256 / 8, ae.prototype.blockSize = ae.blockSize, ae.prototype.keySize = ae.keySize, ae.prototype._reset = function() {
    for (var le = this._key, ge = le.length, Ee = ge + 6, oe = (Ee + 1) * 4, Pe = [], Ve = 0; Ve < ge; Ve++)
      Pe[Ve] = le[Ve];
    for (Ve = ge; Ve < oe; Ve++) {
      var Ke = Pe[Ve - 1];
      Ve % ge === 0 ? (Ke = Ke << 8 | Ke >>> 24, Ke = ne.SBOX[Ke >>> 24] << 24 | ne.SBOX[Ke >>> 16 & 255] << 16 | ne.SBOX[Ke >>> 8 & 255] << 8 | ne.SBOX[Ke & 255], Ke ^= se[Ve / ge | 0] << 24) : ge > 6 && Ve % ge === 4 && (Ke = ne.SBOX[Ke >>> 24] << 24 | ne.SBOX[Ke >>> 16 & 255] << 16 | ne.SBOX[Ke >>> 8 & 255] << 8 | ne.SBOX[Ke & 255]), Pe[Ve] = Pe[Ve - ge] ^ Ke;
    }
    for (var ht = [], _t = 0; _t < oe; _t++) {
      var Rt = oe - _t, kt = Pe[Rt - (_t % 4 ? 0 : 4)];
      _t < 4 || Rt <= 4 ? ht[_t] = kt : ht[_t] = ne.INV_SUB_MIX[0][ne.SBOX[kt >>> 24]] ^ ne.INV_SUB_MIX[1][ne.SBOX[kt >>> 16 & 255]] ^ ne.INV_SUB_MIX[2][ne.SBOX[kt >>> 8 & 255]] ^ ne.INV_SUB_MIX[3][ne.SBOX[kt & 255]];
    }
    this._nRounds = Ee, this._keySchedule = Pe, this._invKeySchedule = ht;
  }, ae.prototype.encryptBlockRaw = function(le) {
    return le = z(le), ie(le, this._keySchedule, ne.SUB_MIX, ne.SBOX, this._nRounds);
  }, ae.prototype.encryptBlock = function(le) {
    var ge = this.encryptBlockRaw(le), Ee = B.allocUnsafe(16);
    return Ee.writeUInt32BE(ge[0], 0), Ee.writeUInt32BE(ge[1], 4), Ee.writeUInt32BE(ge[2], 8), Ee.writeUInt32BE(ge[3], 12), Ee;
  }, ae.prototype.decryptBlock = function(le) {
    le = z(le);
    var ge = le[1];
    le[1] = le[3], le[3] = ge;
    var Ee = ie(le, this._invKeySchedule, ne.INV_SUB_MIX, ne.INV_SBOX, this._nRounds), oe = B.allocUnsafe(16);
    return oe.writeUInt32BE(Ee[0], 0), oe.writeUInt32BE(Ee[3], 4), oe.writeUInt32BE(Ee[2], 8), oe.writeUInt32BE(Ee[1], 12), oe;
  }, ae.prototype.scrub = function() {
    Y(this._keySchedule), Y(this._invKeySchedule), Y(this._key);
  }, aes.AES = ae, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash) return ghash;
  hasRequiredGhash = 1;
  var B = safeBufferExports.Buffer, z = B.alloc(16, 0);
  function Y(ne) {
    return [
      ne.readUInt32BE(0),
      ne.readUInt32BE(4),
      ne.readUInt32BE(8),
      ne.readUInt32BE(12)
    ];
  }
  function ie(ne) {
    var ae = B.allocUnsafe(16);
    return ae.writeUInt32BE(ne[0] >>> 0, 0), ae.writeUInt32BE(ne[1] >>> 0, 4), ae.writeUInt32BE(ne[2] >>> 0, 8), ae.writeUInt32BE(ne[3] >>> 0, 12), ae;
  }
  function se(ne) {
    this.h = ne, this.state = B.alloc(16, 0), this.cache = B.allocUnsafe(0);
  }
  return se.prototype.ghash = function(ne) {
    for (var ae = -1; ++ae < ne.length; )
      this.state[ae] ^= ne[ae];
    this._multiply();
  }, se.prototype._multiply = function() {
    for (var ne = Y(this.h), ae = [0, 0, 0, 0], le, ge, Ee, oe = -1; ++oe < 128; ) {
      for (ge = (this.state[~~(oe / 8)] & 1 << 7 - oe % 8) !== 0, ge && (ae[0] ^= ne[0], ae[1] ^= ne[1], ae[2] ^= ne[2], ae[3] ^= ne[3]), Ee = (ne[3] & 1) !== 0, le = 3; le > 0; le--)
        ne[le] = ne[le] >>> 1 | (ne[le - 1] & 1) << 31;
      ne[0] = ne[0] >>> 1, Ee && (ne[0] = ne[0] ^ 225 << 24);
    }
    this.state = ie(ae);
  }, se.prototype.update = function(ne) {
    this.cache = B.concat([this.cache, ne]);
    for (var ae; this.cache.length >= 16; )
      ae = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(ae);
  }, se.prototype.final = function(ne, ae) {
    return this.cache.length && this.ghash(B.concat([this.cache, z], 16)), this.ghash(ie([0, ne, 0, ae])), this.state;
  }, ghash = se, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher) return authCipher;
  hasRequiredAuthCipher = 1;
  var B = requireAes(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ie = requireInherits_browser(), se = requireGhash(), ne = requireBufferXor(), ae = requireIncr32();
  function le(oe, Pe) {
    var Ve = 0;
    oe.length !== Pe.length && Ve++;
    for (var Ke = Math.min(oe.length, Pe.length), ht = 0; ht < Ke; ++ht)
      Ve += oe[ht] ^ Pe[ht];
    return Ve;
  }
  function ge(oe, Pe, Ve) {
    if (Pe.length === 12)
      return oe._finID = z.concat([Pe, z.from([0, 0, 0, 1])]), z.concat([Pe, z.from([0, 0, 0, 2])]);
    var Ke = new se(Ve), ht = Pe.length, _t = ht % 16;
    Ke.update(Pe), _t && (_t = 16 - _t, Ke.update(z.alloc(_t, 0))), Ke.update(z.alloc(8, 0));
    var Rt = ht * 8, kt = z.alloc(8);
    kt.writeUIntBE(Rt, 0, 8), Ke.update(kt), oe._finID = Ke.state;
    var Bt = z.from(oe._finID);
    return ae(Bt), Bt;
  }
  function Ee(oe, Pe, Ve, Ke) {
    Y.call(this);
    var ht = z.alloc(4, 0);
    this._cipher = new B.AES(Pe);
    var _t = this._cipher.encryptBlock(ht);
    this._ghash = new se(_t), Ve = ge(this, Ve, _t), this._prev = z.from(Ve), this._cache = z.allocUnsafe(0), this._secCache = z.allocUnsafe(0), this._decrypt = Ke, this._alen = 0, this._len = 0, this._mode = oe, this._authTag = null, this._called = !1;
  }
  return ie(Ee, Y), Ee.prototype._update = function(oe) {
    if (!this._called && this._alen) {
      var Pe = 16 - this._alen % 16;
      Pe < 16 && (Pe = z.alloc(Pe, 0), this._ghash.update(Pe));
    }
    this._called = !0;
    var Ve = this._mode.encrypt(this, oe);
    return this._decrypt ? this._ghash.update(oe) : this._ghash.update(Ve), this._len += oe.length, Ve;
  }, Ee.prototype._final = function() {
    if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var oe = ne(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && le(oe, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = oe, this._cipher.scrub();
  }, Ee.prototype.getAuthTag = function() {
    if (this._decrypt || !z.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, Ee.prototype.setAuthTag = function(Pe) {
    if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = Pe;
  }, Ee.prototype.setAAD = function(Pe) {
    if (this._called) throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(Pe), this._alen += Pe.length;
  }, authCipher = Ee, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher) return streamCipher;
  hasRequiredStreamCipher = 1;
  var B = requireAes(), z = safeBufferExports.Buffer, Y = requireCipherBase(), ie = requireInherits_browser();
  function se(ne, ae, le, ge) {
    Y.call(this), this._cipher = new B.AES(ae), this._prev = z.from(le), this._cache = z.allocUnsafe(0), this._secCache = z.allocUnsafe(0), this._decrypt = ge, this._mode = ne;
  }
  return ie(se, Y), se.prototype._update = function(ne) {
    return this._mode.encrypt(this, ne, this._decrypt);
  }, se.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = se, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey) return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var B = safeBufferExports.Buffer, z = requireMd5_js();
  function Y(ie, se, ne, ae) {
    if (B.isBuffer(ie) || (ie = B.from(ie, "binary")), se && (B.isBuffer(se) || (se = B.from(se, "binary")), se.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var le = ne / 8, ge = B.alloc(le), Ee = B.alloc(ae || 0), oe = B.alloc(0); le > 0 || ae > 0; ) {
      var Pe = new z();
      Pe.update(oe), Pe.update(ie), se && Pe.update(se), oe = Pe.digest();
      var Ve = 0;
      if (le > 0) {
        var Ke = ge.length - le;
        Ve = Math.min(le, oe.length), oe.copy(ge, Ke, 0, Ve), le -= Ve;
      }
      if (Ve < oe.length && ae > 0) {
        var ht = Ee.length - ae, _t = Math.min(ae, oe.length - Ve);
        oe.copy(Ee, ht, Ve, Ve + _t), ae -= _t;
      }
    }
    return oe.fill(0), { key: ge, iv: Ee };
  }
  return evp_bytestokey = Y, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter) return encrypter;
  hasRequiredEncrypter = 1;
  var B = requireModes$1(), z = requireAuthCipher(), Y = safeBufferExports.Buffer, ie = requireStreamCipher(), se = requireCipherBase(), ne = requireAes(), ae = requireEvp_bytestokey(), le = requireInherits_browser();
  function ge(Ke, ht, _t) {
    se.call(this), this._cache = new oe(), this._cipher = new ne.AES(ht), this._prev = Y.from(_t), this._mode = Ke, this._autopadding = !0;
  }
  le(ge, se), ge.prototype._update = function(Ke) {
    this._cache.add(Ke);
    for (var ht, _t, Rt = []; ht = this._cache.get(); )
      _t = this._mode.encrypt(this, ht), Rt.push(_t);
    return Y.concat(Rt);
  };
  var Ee = Y.alloc(16, 16);
  ge.prototype._final = function() {
    var Ke = this._cache.flush();
    if (this._autopadding)
      return Ke = this._mode.encrypt(this, Ke), this._cipher.scrub(), Ke;
    if (!Ke.equals(Ee))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, ge.prototype.setAutoPadding = function(Ke) {
    return this._autopadding = !!Ke, this;
  };
  function oe() {
    this.cache = Y.allocUnsafe(0);
  }
  oe.prototype.add = function(Ke) {
    this.cache = Y.concat([this.cache, Ke]);
  }, oe.prototype.get = function() {
    if (this.cache.length > 15) {
      var Ke = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), Ke;
    }
    return null;
  }, oe.prototype.flush = function() {
    for (var Ke = 16 - this.cache.length, ht = Y.allocUnsafe(Ke), _t = -1; ++_t < Ke; )
      ht.writeUInt8(Ke, _t);
    return Y.concat([this.cache, ht]);
  };
  function Pe(Ke, ht, _t) {
    var Rt = B[Ke.toLowerCase()];
    if (!Rt) throw new TypeError("invalid suite type");
    if (typeof ht == "string" && (ht = Y.from(ht)), ht.length !== Rt.key / 8) throw new TypeError("invalid key length " + ht.length);
    if (typeof _t == "string" && (_t = Y.from(_t)), Rt.mode !== "GCM" && _t.length !== Rt.iv) throw new TypeError("invalid iv length " + _t.length);
    return Rt.type === "stream" ? new ie(Rt.module, ht, _t) : Rt.type === "auth" ? new z(Rt.module, ht, _t) : new ge(Rt.module, ht, _t);
  }
  function Ve(Ke, ht) {
    var _t = B[Ke.toLowerCase()];
    if (!_t) throw new TypeError("invalid suite type");
    var Rt = ae(ht, !1, _t.key, _t.iv);
    return Pe(Ke, Rt.key, Rt.iv);
  }
  return encrypter.createCipheriv = Pe, encrypter.createCipher = Ve, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter) return decrypter;
  hasRequiredDecrypter = 1;
  var B = requireAuthCipher(), z = safeBufferExports.Buffer, Y = requireModes$1(), ie = requireStreamCipher(), se = requireCipherBase(), ne = requireAes(), ae = requireEvp_bytestokey(), le = requireInherits_browser();
  function ge(Ke, ht, _t) {
    se.call(this), this._cache = new Ee(), this._last = void 0, this._cipher = new ne.AES(ht), this._prev = z.from(_t), this._mode = Ke, this._autopadding = !0;
  }
  le(ge, se), ge.prototype._update = function(Ke) {
    this._cache.add(Ke);
    for (var ht, _t, Rt = []; ht = this._cache.get(this._autopadding); )
      _t = this._mode.decrypt(this, ht), Rt.push(_t);
    return z.concat(Rt);
  }, ge.prototype._final = function() {
    var Ke = this._cache.flush();
    if (this._autopadding)
      return oe(this._mode.decrypt(this, Ke));
    if (Ke)
      throw new Error("data not multiple of block length");
  }, ge.prototype.setAutoPadding = function(Ke) {
    return this._autopadding = !!Ke, this;
  };
  function Ee() {
    this.cache = z.allocUnsafe(0);
  }
  Ee.prototype.add = function(Ke) {
    this.cache = z.concat([this.cache, Ke]);
  }, Ee.prototype.get = function(Ke) {
    var ht;
    if (Ke) {
      if (this.cache.length > 16)
        return ht = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ht;
    } else if (this.cache.length >= 16)
      return ht = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ht;
    return null;
  }, Ee.prototype.flush = function() {
    if (this.cache.length) return this.cache;
  };
  function oe(Ke) {
    var ht = Ke[15];
    if (ht < 1 || ht > 16)
      throw new Error("unable to decrypt data");
    for (var _t = -1; ++_t < ht; )
      if (Ke[_t + (16 - ht)] !== ht)
        throw new Error("unable to decrypt data");
    if (ht !== 16)
      return Ke.slice(0, 16 - ht);
  }
  function Pe(Ke, ht, _t) {
    var Rt = Y[Ke.toLowerCase()];
    if (!Rt) throw new TypeError("invalid suite type");
    if (typeof _t == "string" && (_t = z.from(_t)), Rt.mode !== "GCM" && _t.length !== Rt.iv) throw new TypeError("invalid iv length " + _t.length);
    if (typeof ht == "string" && (ht = z.from(ht)), ht.length !== Rt.key / 8) throw new TypeError("invalid key length " + ht.length);
    return Rt.type === "stream" ? new ie(Rt.module, ht, _t, !0) : Rt.type === "auth" ? new B(Rt.module, ht, _t, !0) : new ge(Rt.module, ht, _t);
  }
  function Ve(Ke, ht) {
    var _t = Y[Ke.toLowerCase()];
    if (!_t) throw new TypeError("invalid suite type");
    var Rt = ae(ht, !1, _t.key, _t.iv);
    return Pe(Ke, Rt.key, Rt.iv);
  }
  return decrypter.createDecipher = Ve, decrypter.createDecipheriv = Pe, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6) return browser$5;
  hasRequiredBrowser$6 = 1;
  var B = requireEncrypter(), z = requireDecrypter(), Y = require$$2;
  function ie() {
    return Object.keys(Y);
  }
  return browser$5.createCipher = browser$5.Cipher = B.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = B.createCipheriv, browser$5.createDecipher = browser$5.Decipher = z.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = z.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = ie, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(B) {
    B["des-ecb"] = {
      key: 8,
      iv: 0
    }, B["des-cbc"] = B.des = {
      key: 8,
      iv: 8
    }, B["des-ede3-cbc"] = B.des3 = {
      key: 24,
      iv: 8
    }, B["des-ede3"] = {
      key: 24,
      iv: 0
    }, B["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, B["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5) return browser$6;
  hasRequiredBrowser$5 = 1;
  var B = requireBrowserifyDes(), z = requireBrowser$6(), Y = requireModes$1(), ie = requireModes(), se = requireEvp_bytestokey();
  function ne(oe, Pe) {
    oe = oe.toLowerCase();
    var Ve, Ke;
    if (Y[oe])
      Ve = Y[oe].key, Ke = Y[oe].iv;
    else if (ie[oe])
      Ve = ie[oe].key * 8, Ke = ie[oe].iv;
    else
      throw new TypeError("invalid suite type");
    var ht = se(Pe, !1, Ve, Ke);
    return le(oe, ht.key, ht.iv);
  }
  function ae(oe, Pe) {
    oe = oe.toLowerCase();
    var Ve, Ke;
    if (Y[oe])
      Ve = Y[oe].key, Ke = Y[oe].iv;
    else if (ie[oe])
      Ve = ie[oe].key * 8, Ke = ie[oe].iv;
    else
      throw new TypeError("invalid suite type");
    var ht = se(Pe, !1, Ve, Ke);
    return ge(oe, ht.key, ht.iv);
  }
  function le(oe, Pe, Ve) {
    if (oe = oe.toLowerCase(), Y[oe]) return z.createCipheriv(oe, Pe, Ve);
    if (ie[oe]) return new B({ key: Pe, iv: Ve, mode: oe });
    throw new TypeError("invalid suite type");
  }
  function ge(oe, Pe, Ve) {
    if (oe = oe.toLowerCase(), Y[oe]) return z.createDecipheriv(oe, Pe, Ve);
    if (ie[oe]) return new B({ key: Pe, iv: Ve, mode: oe, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function Ee() {
    return Object.keys(ie).concat(z.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = ne, browser$6.createCipheriv = browser$6.Cipheriv = le, browser$6.createDecipher = browser$6.Decipher = ae, browser$6.createDecipheriv = browser$6.Decipheriv = ge, browser$6.listCiphers = browser$6.getCiphers = Ee, browser$6;
}
var browser$4 = {}, bn$2 = { exports: {} };
bn$2.exports;
var hasRequiredBn$2;
function requireBn$2() {
  return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function(B) {
    (function(z, Y) {
      function ie(Ft, bt) {
        if (!Ft) throw new Error(bt || "Assertion failed");
      }
      function se(Ft, bt) {
        Ft.super_ = bt;
        var Xe = function() {
        };
        Xe.prototype = bt.prototype, Ft.prototype = new Xe(), Ft.prototype.constructor = Ft;
      }
      function ne(Ft, bt, Xe) {
        if (ne.isBN(Ft))
          return Ft;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Ft !== null && ((bt === "le" || bt === "be") && (Xe = bt, bt = 10), this._init(Ft || 0, bt || 10, Xe || "be"));
      }
      typeof z == "object" ? z.exports = ne : Y.BN = ne, ne.BN = ne, ne.wordSize = 26;
      var ae;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? ae = window.Buffer : ae = require$$0$1.Buffer;
      } catch {
      }
      ne.isBN = function(bt) {
        return bt instanceof ne ? !0 : bt !== null && typeof bt == "object" && bt.constructor.wordSize === ne.wordSize && Array.isArray(bt.words);
      }, ne.max = function(bt, Xe) {
        return bt.cmp(Xe) > 0 ? bt : Xe;
      }, ne.min = function(bt, Xe) {
        return bt.cmp(Xe) < 0 ? bt : Xe;
      }, ne.prototype._init = function(bt, Xe, ve) {
        if (typeof bt == "number")
          return this._initNumber(bt, Xe, ve);
        if (typeof bt == "object")
          return this._initArray(bt, Xe, ve);
        Xe === "hex" && (Xe = 16), ie(Xe === (Xe | 0) && Xe >= 2 && Xe <= 36), bt = bt.toString().replace(/\s+/g, "");
        var Ce = 0;
        bt[0] === "-" && (Ce++, this.negative = 1), Ce < bt.length && (Xe === 16 ? this._parseHex(bt, Ce, ve) : (this._parseBase(bt, Xe, Ce), ve === "le" && this._initArray(this.toArray(), Xe, ve)));
      }, ne.prototype._initNumber = function(bt, Xe, ve) {
        bt < 0 && (this.negative = 1, bt = -bt), bt < 67108864 ? (this.words = [bt & 67108863], this.length = 1) : bt < 4503599627370496 ? (this.words = [
          bt & 67108863,
          bt / 67108864 & 67108863
        ], this.length = 2) : (ie(bt < 9007199254740992), this.words = [
          bt & 67108863,
          bt / 67108864 & 67108863,
          1
        ], this.length = 3), ve === "le" && this._initArray(this.toArray(), Xe, ve);
      }, ne.prototype._initArray = function(bt, Xe, ve) {
        if (ie(typeof bt.length == "number"), bt.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(bt.length / 3), this.words = new Array(this.length);
        for (var Ce = 0; Ce < this.length; Ce++)
          this.words[Ce] = 0;
        var Qe, vt, wt = 0;
        if (ve === "be")
          for (Ce = bt.length - 1, Qe = 0; Ce >= 0; Ce -= 3)
            vt = bt[Ce] | bt[Ce - 1] << 8 | bt[Ce - 2] << 16, this.words[Qe] |= vt << wt & 67108863, this.words[Qe + 1] = vt >>> 26 - wt & 67108863, wt += 24, wt >= 26 && (wt -= 26, Qe++);
        else if (ve === "le")
          for (Ce = 0, Qe = 0; Ce < bt.length; Ce += 3)
            vt = bt[Ce] | bt[Ce + 1] << 8 | bt[Ce + 2] << 16, this.words[Qe] |= vt << wt & 67108863, this.words[Qe + 1] = vt >>> 26 - wt & 67108863, wt += 24, wt >= 26 && (wt -= 26, Qe++);
        return this.strip();
      };
      function le(Ft, bt) {
        var Xe = Ft.charCodeAt(bt);
        return Xe >= 65 && Xe <= 70 ? Xe - 55 : Xe >= 97 && Xe <= 102 ? Xe - 87 : Xe - 48 & 15;
      }
      function ge(Ft, bt, Xe) {
        var ve = le(Ft, Xe);
        return Xe - 1 >= bt && (ve |= le(Ft, Xe - 1) << 4), ve;
      }
      ne.prototype._parseHex = function(bt, Xe, ve) {
        this.length = Math.ceil((bt.length - Xe) / 6), this.words = new Array(this.length);
        for (var Ce = 0; Ce < this.length; Ce++)
          this.words[Ce] = 0;
        var Qe = 0, vt = 0, wt;
        if (ve === "be")
          for (Ce = bt.length - 1; Ce >= Xe; Ce -= 2)
            wt = ge(bt, Xe, Ce) << Qe, this.words[vt] |= wt & 67108863, Qe >= 18 ? (Qe -= 18, vt += 1, this.words[vt] |= wt >>> 26) : Qe += 8;
        else {
          var $t = bt.length - Xe;
          for (Ce = $t % 2 === 0 ? Xe + 1 : Xe; Ce < bt.length; Ce += 2)
            wt = ge(bt, Xe, Ce) << Qe, this.words[vt] |= wt & 67108863, Qe >= 18 ? (Qe -= 18, vt += 1, this.words[vt] |= wt >>> 26) : Qe += 8;
        }
        this.strip();
      };
      function Ee(Ft, bt, Xe, ve) {
        for (var Ce = 0, Qe = Math.min(Ft.length, Xe), vt = bt; vt < Qe; vt++) {
          var wt = Ft.charCodeAt(vt) - 48;
          Ce *= ve, wt >= 49 ? Ce += wt - 49 + 10 : wt >= 17 ? Ce += wt - 17 + 10 : Ce += wt;
        }
        return Ce;
      }
      ne.prototype._parseBase = function(bt, Xe, ve) {
        this.words = [0], this.length = 1;
        for (var Ce = 0, Qe = 1; Qe <= 67108863; Qe *= Xe)
          Ce++;
        Ce--, Qe = Qe / Xe | 0;
        for (var vt = bt.length - ve, wt = vt % Ce, $t = Math.min(vt, vt - wt) + ve, xt = 0, Pt = ve; Pt < $t; Pt += Ce)
          xt = Ee(bt, Pt, Pt + Ce, Xe), this.imuln(Qe), this.words[0] + xt < 67108864 ? this.words[0] += xt : this._iaddn(xt);
        if (wt !== 0) {
          var Je = 1;
          for (xt = Ee(bt, Pt, bt.length, Xe), Pt = 0; Pt < wt; Pt++)
            Je *= Xe;
          this.imuln(Je), this.words[0] + xt < 67108864 ? this.words[0] += xt : this._iaddn(xt);
        }
        this.strip();
      }, ne.prototype.copy = function(bt) {
        bt.words = new Array(this.length);
        for (var Xe = 0; Xe < this.length; Xe++)
          bt.words[Xe] = this.words[Xe];
        bt.length = this.length, bt.negative = this.negative, bt.red = this.red;
      }, ne.prototype.clone = function() {
        var bt = new ne(null);
        return this.copy(bt), bt;
      }, ne.prototype._expand = function(bt) {
        for (; this.length < bt; )
          this.words[this.length++] = 0;
        return this;
      }, ne.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ne.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, ne.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var oe = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Pe = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Ve = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ne.prototype.toString = function(bt, Xe) {
        bt = bt || 10, Xe = Xe | 0 || 1;
        var ve;
        if (bt === 16 || bt === "hex") {
          ve = "";
          for (var Ce = 0, Qe = 0, vt = 0; vt < this.length; vt++) {
            var wt = this.words[vt], $t = ((wt << Ce | Qe) & 16777215).toString(16);
            Qe = wt >>> 24 - Ce & 16777215, Ce += 2, Ce >= 26 && (Ce -= 26, vt--), Qe !== 0 || vt !== this.length - 1 ? ve = oe[6 - $t.length] + $t + ve : ve = $t + ve;
          }
          for (Qe !== 0 && (ve = Qe.toString(16) + ve); ve.length % Xe !== 0; )
            ve = "0" + ve;
          return this.negative !== 0 && (ve = "-" + ve), ve;
        }
        if (bt === (bt | 0) && bt >= 2 && bt <= 36) {
          var xt = Pe[bt], Pt = Ve[bt];
          ve = "";
          var Je = this.clone();
          for (Je.negative = 0; !Je.isZero(); ) {
            var Ot = Je.modn(Pt).toString(bt);
            Je = Je.idivn(Pt), Je.isZero() ? ve = Ot + ve : ve = oe[xt - Ot.length] + Ot + ve;
          }
          for (this.isZero() && (ve = "0" + ve); ve.length % Xe !== 0; )
            ve = "0" + ve;
          return this.negative !== 0 && (ve = "-" + ve), ve;
        }
        ie(!1, "Base should be between 2 and 36");
      }, ne.prototype.toNumber = function() {
        var bt = this.words[0];
        return this.length === 2 ? bt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? bt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ie(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -bt : bt;
      }, ne.prototype.toJSON = function() {
        return this.toString(16);
      }, ne.prototype.toBuffer = function(bt, Xe) {
        return ie(typeof ae < "u"), this.toArrayLike(ae, bt, Xe);
      }, ne.prototype.toArray = function(bt, Xe) {
        return this.toArrayLike(Array, bt, Xe);
      }, ne.prototype.toArrayLike = function(bt, Xe, ve) {
        var Ce = this.byteLength(), Qe = ve || Math.max(1, Ce);
        ie(Ce <= Qe, "byte array longer than desired length"), ie(Qe > 0, "Requested array length <= 0"), this.strip();
        var vt = Xe === "le", wt = new bt(Qe), $t, xt, Pt = this.clone();
        if (vt) {
          for (xt = 0; !Pt.isZero(); xt++)
            $t = Pt.andln(255), Pt.iushrn(8), wt[xt] = $t;
          for (; xt < Qe; xt++)
            wt[xt] = 0;
        } else {
          for (xt = 0; xt < Qe - Ce; xt++)
            wt[xt] = 0;
          for (xt = 0; !Pt.isZero(); xt++)
            $t = Pt.andln(255), Pt.iushrn(8), wt[Qe - xt - 1] = $t;
        }
        return wt;
      }, Math.clz32 ? ne.prototype._countBits = function(bt) {
        return 32 - Math.clz32(bt);
      } : ne.prototype._countBits = function(bt) {
        var Xe = bt, ve = 0;
        return Xe >= 4096 && (ve += 13, Xe >>>= 13), Xe >= 64 && (ve += 7, Xe >>>= 7), Xe >= 8 && (ve += 4, Xe >>>= 4), Xe >= 2 && (ve += 2, Xe >>>= 2), ve + Xe;
      }, ne.prototype._zeroBits = function(bt) {
        if (bt === 0) return 26;
        var Xe = bt, ve = 0;
        return Xe & 8191 || (ve += 13, Xe >>>= 13), Xe & 127 || (ve += 7, Xe >>>= 7), Xe & 15 || (ve += 4, Xe >>>= 4), Xe & 3 || (ve += 2, Xe >>>= 2), Xe & 1 || ve++, ve;
      }, ne.prototype.bitLength = function() {
        var bt = this.words[this.length - 1], Xe = this._countBits(bt);
        return (this.length - 1) * 26 + Xe;
      };
      function Ke(Ft) {
        for (var bt = new Array(Ft.bitLength()), Xe = 0; Xe < bt.length; Xe++) {
          var ve = Xe / 26 | 0, Ce = Xe % 26;
          bt[Xe] = (Ft.words[ve] & 1 << Ce) >>> Ce;
        }
        return bt;
      }
      ne.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var bt = 0, Xe = 0; Xe < this.length; Xe++) {
          var ve = this._zeroBits(this.words[Xe]);
          if (bt += ve, ve !== 26) break;
        }
        return bt;
      }, ne.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ne.prototype.toTwos = function(bt) {
        return this.negative !== 0 ? this.abs().inotn(bt).iaddn(1) : this.clone();
      }, ne.prototype.fromTwos = function(bt) {
        return this.testn(bt - 1) ? this.notn(bt).iaddn(1).ineg() : this.clone();
      }, ne.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ne.prototype.neg = function() {
        return this.clone().ineg();
      }, ne.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ne.prototype.iuor = function(bt) {
        for (; this.length < bt.length; )
          this.words[this.length++] = 0;
        for (var Xe = 0; Xe < bt.length; Xe++)
          this.words[Xe] = this.words[Xe] | bt.words[Xe];
        return this.strip();
      }, ne.prototype.ior = function(bt) {
        return ie((this.negative | bt.negative) === 0), this.iuor(bt);
      }, ne.prototype.or = function(bt) {
        return this.length > bt.length ? this.clone().ior(bt) : bt.clone().ior(this);
      }, ne.prototype.uor = function(bt) {
        return this.length > bt.length ? this.clone().iuor(bt) : bt.clone().iuor(this);
      }, ne.prototype.iuand = function(bt) {
        var Xe;
        this.length > bt.length ? Xe = bt : Xe = this;
        for (var ve = 0; ve < Xe.length; ve++)
          this.words[ve] = this.words[ve] & bt.words[ve];
        return this.length = Xe.length, this.strip();
      }, ne.prototype.iand = function(bt) {
        return ie((this.negative | bt.negative) === 0), this.iuand(bt);
      }, ne.prototype.and = function(bt) {
        return this.length > bt.length ? this.clone().iand(bt) : bt.clone().iand(this);
      }, ne.prototype.uand = function(bt) {
        return this.length > bt.length ? this.clone().iuand(bt) : bt.clone().iuand(this);
      }, ne.prototype.iuxor = function(bt) {
        var Xe, ve;
        this.length > bt.length ? (Xe = this, ve = bt) : (Xe = bt, ve = this);
        for (var Ce = 0; Ce < ve.length; Ce++)
          this.words[Ce] = Xe.words[Ce] ^ ve.words[Ce];
        if (this !== Xe)
          for (; Ce < Xe.length; Ce++)
            this.words[Ce] = Xe.words[Ce];
        return this.length = Xe.length, this.strip();
      }, ne.prototype.ixor = function(bt) {
        return ie((this.negative | bt.negative) === 0), this.iuxor(bt);
      }, ne.prototype.xor = function(bt) {
        return this.length > bt.length ? this.clone().ixor(bt) : bt.clone().ixor(this);
      }, ne.prototype.uxor = function(bt) {
        return this.length > bt.length ? this.clone().iuxor(bt) : bt.clone().iuxor(this);
      }, ne.prototype.inotn = function(bt) {
        ie(typeof bt == "number" && bt >= 0);
        var Xe = Math.ceil(bt / 26) | 0, ve = bt % 26;
        this._expand(Xe), ve > 0 && Xe--;
        for (var Ce = 0; Ce < Xe; Ce++)
          this.words[Ce] = ~this.words[Ce] & 67108863;
        return ve > 0 && (this.words[Ce] = ~this.words[Ce] & 67108863 >> 26 - ve), this.strip();
      }, ne.prototype.notn = function(bt) {
        return this.clone().inotn(bt);
      }, ne.prototype.setn = function(bt, Xe) {
        ie(typeof bt == "number" && bt >= 0);
        var ve = bt / 26 | 0, Ce = bt % 26;
        return this._expand(ve + 1), Xe ? this.words[ve] = this.words[ve] | 1 << Ce : this.words[ve] = this.words[ve] & ~(1 << Ce), this.strip();
      }, ne.prototype.iadd = function(bt) {
        var Xe;
        if (this.negative !== 0 && bt.negative === 0)
          return this.negative = 0, Xe = this.isub(bt), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && bt.negative !== 0)
          return bt.negative = 0, Xe = this.isub(bt), bt.negative = 1, Xe._normSign();
        var ve, Ce;
        this.length > bt.length ? (ve = this, Ce = bt) : (ve = bt, Ce = this);
        for (var Qe = 0, vt = 0; vt < Ce.length; vt++)
          Xe = (ve.words[vt] | 0) + (Ce.words[vt] | 0) + Qe, this.words[vt] = Xe & 67108863, Qe = Xe >>> 26;
        for (; Qe !== 0 && vt < ve.length; vt++)
          Xe = (ve.words[vt] | 0) + Qe, this.words[vt] = Xe & 67108863, Qe = Xe >>> 26;
        if (this.length = ve.length, Qe !== 0)
          this.words[this.length] = Qe, this.length++;
        else if (ve !== this)
          for (; vt < ve.length; vt++)
            this.words[vt] = ve.words[vt];
        return this;
      }, ne.prototype.add = function(bt) {
        var Xe;
        return bt.negative !== 0 && this.negative === 0 ? (bt.negative = 0, Xe = this.sub(bt), bt.negative ^= 1, Xe) : bt.negative === 0 && this.negative !== 0 ? (this.negative = 0, Xe = bt.sub(this), this.negative = 1, Xe) : this.length > bt.length ? this.clone().iadd(bt) : bt.clone().iadd(this);
      }, ne.prototype.isub = function(bt) {
        if (bt.negative !== 0) {
          bt.negative = 0;
          var Xe = this.iadd(bt);
          return bt.negative = 1, Xe._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(bt), this.negative = 1, this._normSign();
        var ve = this.cmp(bt);
        if (ve === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var Ce, Qe;
        ve > 0 ? (Ce = this, Qe = bt) : (Ce = bt, Qe = this);
        for (var vt = 0, wt = 0; wt < Qe.length; wt++)
          Xe = (Ce.words[wt] | 0) - (Qe.words[wt] | 0) + vt, vt = Xe >> 26, this.words[wt] = Xe & 67108863;
        for (; vt !== 0 && wt < Ce.length; wt++)
          Xe = (Ce.words[wt] | 0) + vt, vt = Xe >> 26, this.words[wt] = Xe & 67108863;
        if (vt === 0 && wt < Ce.length && Ce !== this)
          for (; wt < Ce.length; wt++)
            this.words[wt] = Ce.words[wt];
        return this.length = Math.max(this.length, wt), Ce !== this && (this.negative = 1), this.strip();
      }, ne.prototype.sub = function(bt) {
        return this.clone().isub(bt);
      };
      function ht(Ft, bt, Xe) {
        Xe.negative = bt.negative ^ Ft.negative;
        var ve = Ft.length + bt.length | 0;
        Xe.length = ve, ve = ve - 1 | 0;
        var Ce = Ft.words[0] | 0, Qe = bt.words[0] | 0, vt = Ce * Qe, wt = vt & 67108863, $t = vt / 67108864 | 0;
        Xe.words[0] = wt;
        for (var xt = 1; xt < ve; xt++) {
          for (var Pt = $t >>> 26, Je = $t & 67108863, Ot = Math.min(xt, bt.length - 1), er = Math.max(0, xt - Ft.length + 1); er <= Ot; er++) {
            var sr = xt - er | 0;
            Ce = Ft.words[sr] | 0, Qe = bt.words[er] | 0, vt = Ce * Qe + Je, Pt += vt / 67108864 | 0, Je = vt & 67108863;
          }
          Xe.words[xt] = Je | 0, $t = Pt | 0;
        }
        return $t !== 0 ? Xe.words[xt] = $t | 0 : Xe.length--, Xe.strip();
      }
      var _t = function(bt, Xe, ve) {
        var Ce = bt.words, Qe = Xe.words, vt = ve.words, wt = 0, $t, xt, Pt, Je = Ce[0] | 0, Ot = Je & 8191, er = Je >>> 13, sr = Ce[1] | 0, Jt = sr & 8191, Wt = sr >>> 13, Gt = Ce[2] | 0, rr = Gt & 8191, or = Gt >>> 13, Xt = Ce[3] | 0, zt = Xt & 8191, ur = Xt >>> 13, hr = Ce[4] | 0, yr = hr & 8191, Sr = hr >>> 13, $r = Ce[5] | 0, Mr = $r & 8191, pr = $r >>> 13, Fr = Ce[6] | 0, Ar = Fr & 8191, Gr = Fr >>> 13, Lr = Ce[7] | 0, Rr = Lr & 8191, Vr = Lr >>> 13, jr = Ce[8] | 0, kr = jr & 8191, Jr = jr >>> 13, Xr = Ce[9] | 0, Vt = Xr & 8191, Lt = Xr >>> 13, Dt = Qe[0] | 0, Qt = Dt & 8191, fr = Dt >>> 13, cr = Qe[1] | 0, lr = cr & 8191, Ur = cr >>> 13, Nr = Qe[2] | 0, Tr = Nr & 8191, Wr = Nr >>> 13, qr = Qe[3] | 0, Or = qr & 8191, Zr = qr >>> 13, Yr = Qe[4] | 0, nr = Yr & 8191, Zt = Yr >>> 13, ir = Qe[5] | 0, ar = ir & 8191, dr = ir >>> 13, vr = Qe[6] | 0, br = vr & 8191, xr = vr >>> 13, Pr = Qe[7] | 0, Er = Pr & 8191, Dr = Pr >>> 13, Ir = Qe[8] | 0, tr = Ir & 8191, gr = Ir >>> 13, wr = Qe[9] | 0, _r = wr & 8191, Hr = wr >>> 13;
        ve.negative = bt.negative ^ Xe.negative, ve.length = 19, $t = Math.imul(Ot, Qt), xt = Math.imul(Ot, fr), xt = xt + Math.imul(er, Qt) | 0, Pt = Math.imul(er, fr);
        var Cr = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (Cr >>> 26) | 0, Cr &= 67108863, $t = Math.imul(Jt, Qt), xt = Math.imul(Jt, fr), xt = xt + Math.imul(Wt, Qt) | 0, Pt = Math.imul(Wt, fr), $t = $t + Math.imul(Ot, lr) | 0, xt = xt + Math.imul(Ot, Ur) | 0, xt = xt + Math.imul(er, lr) | 0, Pt = Pt + Math.imul(er, Ur) | 0;
        var Br = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (Br >>> 26) | 0, Br &= 67108863, $t = Math.imul(rr, Qt), xt = Math.imul(rr, fr), xt = xt + Math.imul(or, Qt) | 0, Pt = Math.imul(or, fr), $t = $t + Math.imul(Jt, lr) | 0, xt = xt + Math.imul(Jt, Ur) | 0, xt = xt + Math.imul(Wt, lr) | 0, Pt = Pt + Math.imul(Wt, Ur) | 0, $t = $t + Math.imul(Ot, Tr) | 0, xt = xt + Math.imul(Ot, Wr) | 0, xt = xt + Math.imul(er, Tr) | 0, Pt = Pt + Math.imul(er, Wr) | 0;
        var zr = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, $t = Math.imul(zt, Qt), xt = Math.imul(zt, fr), xt = xt + Math.imul(ur, Qt) | 0, Pt = Math.imul(ur, fr), $t = $t + Math.imul(rr, lr) | 0, xt = xt + Math.imul(rr, Ur) | 0, xt = xt + Math.imul(or, lr) | 0, Pt = Pt + Math.imul(or, Ur) | 0, $t = $t + Math.imul(Jt, Tr) | 0, xt = xt + Math.imul(Jt, Wr) | 0, xt = xt + Math.imul(Wt, Tr) | 0, Pt = Pt + Math.imul(Wt, Wr) | 0, $t = $t + Math.imul(Ot, Or) | 0, xt = xt + Math.imul(Ot, Zr) | 0, xt = xt + Math.imul(er, Or) | 0, Pt = Pt + Math.imul(er, Zr) | 0;
        var tn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, $t = Math.imul(yr, Qt), xt = Math.imul(yr, fr), xt = xt + Math.imul(Sr, Qt) | 0, Pt = Math.imul(Sr, fr), $t = $t + Math.imul(zt, lr) | 0, xt = xt + Math.imul(zt, Ur) | 0, xt = xt + Math.imul(ur, lr) | 0, Pt = Pt + Math.imul(ur, Ur) | 0, $t = $t + Math.imul(rr, Tr) | 0, xt = xt + Math.imul(rr, Wr) | 0, xt = xt + Math.imul(or, Tr) | 0, Pt = Pt + Math.imul(or, Wr) | 0, $t = $t + Math.imul(Jt, Or) | 0, xt = xt + Math.imul(Jt, Zr) | 0, xt = xt + Math.imul(Wt, Or) | 0, Pt = Pt + Math.imul(Wt, Zr) | 0, $t = $t + Math.imul(Ot, nr) | 0, xt = xt + Math.imul(Ot, Zt) | 0, xt = xt + Math.imul(er, nr) | 0, Pt = Pt + Math.imul(er, Zt) | 0;
        var Qr = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, $t = Math.imul(Mr, Qt), xt = Math.imul(Mr, fr), xt = xt + Math.imul(pr, Qt) | 0, Pt = Math.imul(pr, fr), $t = $t + Math.imul(yr, lr) | 0, xt = xt + Math.imul(yr, Ur) | 0, xt = xt + Math.imul(Sr, lr) | 0, Pt = Pt + Math.imul(Sr, Ur) | 0, $t = $t + Math.imul(zt, Tr) | 0, xt = xt + Math.imul(zt, Wr) | 0, xt = xt + Math.imul(ur, Tr) | 0, Pt = Pt + Math.imul(ur, Wr) | 0, $t = $t + Math.imul(rr, Or) | 0, xt = xt + Math.imul(rr, Zr) | 0, xt = xt + Math.imul(or, Or) | 0, Pt = Pt + Math.imul(or, Zr) | 0, $t = $t + Math.imul(Jt, nr) | 0, xt = xt + Math.imul(Jt, Zt) | 0, xt = xt + Math.imul(Wt, nr) | 0, Pt = Pt + Math.imul(Wt, Zt) | 0, $t = $t + Math.imul(Ot, ar) | 0, xt = xt + Math.imul(Ot, dr) | 0, xt = xt + Math.imul(er, ar) | 0, Pt = Pt + Math.imul(er, dr) | 0;
        var en = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, $t = Math.imul(Ar, Qt), xt = Math.imul(Ar, fr), xt = xt + Math.imul(Gr, Qt) | 0, Pt = Math.imul(Gr, fr), $t = $t + Math.imul(Mr, lr) | 0, xt = xt + Math.imul(Mr, Ur) | 0, xt = xt + Math.imul(pr, lr) | 0, Pt = Pt + Math.imul(pr, Ur) | 0, $t = $t + Math.imul(yr, Tr) | 0, xt = xt + Math.imul(yr, Wr) | 0, xt = xt + Math.imul(Sr, Tr) | 0, Pt = Pt + Math.imul(Sr, Wr) | 0, $t = $t + Math.imul(zt, Or) | 0, xt = xt + Math.imul(zt, Zr) | 0, xt = xt + Math.imul(ur, Or) | 0, Pt = Pt + Math.imul(ur, Zr) | 0, $t = $t + Math.imul(rr, nr) | 0, xt = xt + Math.imul(rr, Zt) | 0, xt = xt + Math.imul(or, nr) | 0, Pt = Pt + Math.imul(or, Zt) | 0, $t = $t + Math.imul(Jt, ar) | 0, xt = xt + Math.imul(Jt, dr) | 0, xt = xt + Math.imul(Wt, ar) | 0, Pt = Pt + Math.imul(Wt, dr) | 0, $t = $t + Math.imul(Ot, br) | 0, xt = xt + Math.imul(Ot, xr) | 0, xt = xt + Math.imul(er, br) | 0, Pt = Pt + Math.imul(er, xr) | 0;
        var sn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, $t = Math.imul(Rr, Qt), xt = Math.imul(Rr, fr), xt = xt + Math.imul(Vr, Qt) | 0, Pt = Math.imul(Vr, fr), $t = $t + Math.imul(Ar, lr) | 0, xt = xt + Math.imul(Ar, Ur) | 0, xt = xt + Math.imul(Gr, lr) | 0, Pt = Pt + Math.imul(Gr, Ur) | 0, $t = $t + Math.imul(Mr, Tr) | 0, xt = xt + Math.imul(Mr, Wr) | 0, xt = xt + Math.imul(pr, Tr) | 0, Pt = Pt + Math.imul(pr, Wr) | 0, $t = $t + Math.imul(yr, Or) | 0, xt = xt + Math.imul(yr, Zr) | 0, xt = xt + Math.imul(Sr, Or) | 0, Pt = Pt + Math.imul(Sr, Zr) | 0, $t = $t + Math.imul(zt, nr) | 0, xt = xt + Math.imul(zt, Zt) | 0, xt = xt + Math.imul(ur, nr) | 0, Pt = Pt + Math.imul(ur, Zt) | 0, $t = $t + Math.imul(rr, ar) | 0, xt = xt + Math.imul(rr, dr) | 0, xt = xt + Math.imul(or, ar) | 0, Pt = Pt + Math.imul(or, dr) | 0, $t = $t + Math.imul(Jt, br) | 0, xt = xt + Math.imul(Jt, xr) | 0, xt = xt + Math.imul(Wt, br) | 0, Pt = Pt + Math.imul(Wt, xr) | 0, $t = $t + Math.imul(Ot, Er) | 0, xt = xt + Math.imul(Ot, Dr) | 0, xt = xt + Math.imul(er, Er) | 0, Pt = Pt + Math.imul(er, Dr) | 0;
        var on = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, $t = Math.imul(kr, Qt), xt = Math.imul(kr, fr), xt = xt + Math.imul(Jr, Qt) | 0, Pt = Math.imul(Jr, fr), $t = $t + Math.imul(Rr, lr) | 0, xt = xt + Math.imul(Rr, Ur) | 0, xt = xt + Math.imul(Vr, lr) | 0, Pt = Pt + Math.imul(Vr, Ur) | 0, $t = $t + Math.imul(Ar, Tr) | 0, xt = xt + Math.imul(Ar, Wr) | 0, xt = xt + Math.imul(Gr, Tr) | 0, Pt = Pt + Math.imul(Gr, Wr) | 0, $t = $t + Math.imul(Mr, Or) | 0, xt = xt + Math.imul(Mr, Zr) | 0, xt = xt + Math.imul(pr, Or) | 0, Pt = Pt + Math.imul(pr, Zr) | 0, $t = $t + Math.imul(yr, nr) | 0, xt = xt + Math.imul(yr, Zt) | 0, xt = xt + Math.imul(Sr, nr) | 0, Pt = Pt + Math.imul(Sr, Zt) | 0, $t = $t + Math.imul(zt, ar) | 0, xt = xt + Math.imul(zt, dr) | 0, xt = xt + Math.imul(ur, ar) | 0, Pt = Pt + Math.imul(ur, dr) | 0, $t = $t + Math.imul(rr, br) | 0, xt = xt + Math.imul(rr, xr) | 0, xt = xt + Math.imul(or, br) | 0, Pt = Pt + Math.imul(or, xr) | 0, $t = $t + Math.imul(Jt, Er) | 0, xt = xt + Math.imul(Jt, Dr) | 0, xt = xt + Math.imul(Wt, Er) | 0, Pt = Pt + Math.imul(Wt, Dr) | 0, $t = $t + Math.imul(Ot, tr) | 0, xt = xt + Math.imul(Ot, gr) | 0, xt = xt + Math.imul(er, tr) | 0, Pt = Pt + Math.imul(er, gr) | 0;
        var an = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, $t = Math.imul(Vt, Qt), xt = Math.imul(Vt, fr), xt = xt + Math.imul(Lt, Qt) | 0, Pt = Math.imul(Lt, fr), $t = $t + Math.imul(kr, lr) | 0, xt = xt + Math.imul(kr, Ur) | 0, xt = xt + Math.imul(Jr, lr) | 0, Pt = Pt + Math.imul(Jr, Ur) | 0, $t = $t + Math.imul(Rr, Tr) | 0, xt = xt + Math.imul(Rr, Wr) | 0, xt = xt + Math.imul(Vr, Tr) | 0, Pt = Pt + Math.imul(Vr, Wr) | 0, $t = $t + Math.imul(Ar, Or) | 0, xt = xt + Math.imul(Ar, Zr) | 0, xt = xt + Math.imul(Gr, Or) | 0, Pt = Pt + Math.imul(Gr, Zr) | 0, $t = $t + Math.imul(Mr, nr) | 0, xt = xt + Math.imul(Mr, Zt) | 0, xt = xt + Math.imul(pr, nr) | 0, Pt = Pt + Math.imul(pr, Zt) | 0, $t = $t + Math.imul(yr, ar) | 0, xt = xt + Math.imul(yr, dr) | 0, xt = xt + Math.imul(Sr, ar) | 0, Pt = Pt + Math.imul(Sr, dr) | 0, $t = $t + Math.imul(zt, br) | 0, xt = xt + Math.imul(zt, xr) | 0, xt = xt + Math.imul(ur, br) | 0, Pt = Pt + Math.imul(ur, xr) | 0, $t = $t + Math.imul(rr, Er) | 0, xt = xt + Math.imul(rr, Dr) | 0, xt = xt + Math.imul(or, Er) | 0, Pt = Pt + Math.imul(or, Dr) | 0, $t = $t + Math.imul(Jt, tr) | 0, xt = xt + Math.imul(Jt, gr) | 0, xt = xt + Math.imul(Wt, tr) | 0, Pt = Pt + Math.imul(Wt, gr) | 0, $t = $t + Math.imul(Ot, _r) | 0, xt = xt + Math.imul(Ot, Hr) | 0, xt = xt + Math.imul(er, _r) | 0, Pt = Pt + Math.imul(er, Hr) | 0;
        var nn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, $t = Math.imul(Vt, lr), xt = Math.imul(Vt, Ur), xt = xt + Math.imul(Lt, lr) | 0, Pt = Math.imul(Lt, Ur), $t = $t + Math.imul(kr, Tr) | 0, xt = xt + Math.imul(kr, Wr) | 0, xt = xt + Math.imul(Jr, Tr) | 0, Pt = Pt + Math.imul(Jr, Wr) | 0, $t = $t + Math.imul(Rr, Or) | 0, xt = xt + Math.imul(Rr, Zr) | 0, xt = xt + Math.imul(Vr, Or) | 0, Pt = Pt + Math.imul(Vr, Zr) | 0, $t = $t + Math.imul(Ar, nr) | 0, xt = xt + Math.imul(Ar, Zt) | 0, xt = xt + Math.imul(Gr, nr) | 0, Pt = Pt + Math.imul(Gr, Zt) | 0, $t = $t + Math.imul(Mr, ar) | 0, xt = xt + Math.imul(Mr, dr) | 0, xt = xt + Math.imul(pr, ar) | 0, Pt = Pt + Math.imul(pr, dr) | 0, $t = $t + Math.imul(yr, br) | 0, xt = xt + Math.imul(yr, xr) | 0, xt = xt + Math.imul(Sr, br) | 0, Pt = Pt + Math.imul(Sr, xr) | 0, $t = $t + Math.imul(zt, Er) | 0, xt = xt + Math.imul(zt, Dr) | 0, xt = xt + Math.imul(ur, Er) | 0, Pt = Pt + Math.imul(ur, Dr) | 0, $t = $t + Math.imul(rr, tr) | 0, xt = xt + Math.imul(rr, gr) | 0, xt = xt + Math.imul(or, tr) | 0, Pt = Pt + Math.imul(or, gr) | 0, $t = $t + Math.imul(Jt, _r) | 0, xt = xt + Math.imul(Jt, Hr) | 0, xt = xt + Math.imul(Wt, _r) | 0, Pt = Pt + Math.imul(Wt, Hr) | 0;
        var fn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, $t = Math.imul(Vt, Tr), xt = Math.imul(Vt, Wr), xt = xt + Math.imul(Lt, Tr) | 0, Pt = Math.imul(Lt, Wr), $t = $t + Math.imul(kr, Or) | 0, xt = xt + Math.imul(kr, Zr) | 0, xt = xt + Math.imul(Jr, Or) | 0, Pt = Pt + Math.imul(Jr, Zr) | 0, $t = $t + Math.imul(Rr, nr) | 0, xt = xt + Math.imul(Rr, Zt) | 0, xt = xt + Math.imul(Vr, nr) | 0, Pt = Pt + Math.imul(Vr, Zt) | 0, $t = $t + Math.imul(Ar, ar) | 0, xt = xt + Math.imul(Ar, dr) | 0, xt = xt + Math.imul(Gr, ar) | 0, Pt = Pt + Math.imul(Gr, dr) | 0, $t = $t + Math.imul(Mr, br) | 0, xt = xt + Math.imul(Mr, xr) | 0, xt = xt + Math.imul(pr, br) | 0, Pt = Pt + Math.imul(pr, xr) | 0, $t = $t + Math.imul(yr, Er) | 0, xt = xt + Math.imul(yr, Dr) | 0, xt = xt + Math.imul(Sr, Er) | 0, Pt = Pt + Math.imul(Sr, Dr) | 0, $t = $t + Math.imul(zt, tr) | 0, xt = xt + Math.imul(zt, gr) | 0, xt = xt + Math.imul(ur, tr) | 0, Pt = Pt + Math.imul(ur, gr) | 0, $t = $t + Math.imul(rr, _r) | 0, xt = xt + Math.imul(rr, Hr) | 0, xt = xt + Math.imul(or, _r) | 0, Pt = Pt + Math.imul(or, Hr) | 0;
        var un = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, $t = Math.imul(Vt, Or), xt = Math.imul(Vt, Zr), xt = xt + Math.imul(Lt, Or) | 0, Pt = Math.imul(Lt, Zr), $t = $t + Math.imul(kr, nr) | 0, xt = xt + Math.imul(kr, Zt) | 0, xt = xt + Math.imul(Jr, nr) | 0, Pt = Pt + Math.imul(Jr, Zt) | 0, $t = $t + Math.imul(Rr, ar) | 0, xt = xt + Math.imul(Rr, dr) | 0, xt = xt + Math.imul(Vr, ar) | 0, Pt = Pt + Math.imul(Vr, dr) | 0, $t = $t + Math.imul(Ar, br) | 0, xt = xt + Math.imul(Ar, xr) | 0, xt = xt + Math.imul(Gr, br) | 0, Pt = Pt + Math.imul(Gr, xr) | 0, $t = $t + Math.imul(Mr, Er) | 0, xt = xt + Math.imul(Mr, Dr) | 0, xt = xt + Math.imul(pr, Er) | 0, Pt = Pt + Math.imul(pr, Dr) | 0, $t = $t + Math.imul(yr, tr) | 0, xt = xt + Math.imul(yr, gr) | 0, xt = xt + Math.imul(Sr, tr) | 0, Pt = Pt + Math.imul(Sr, gr) | 0, $t = $t + Math.imul(zt, _r) | 0, xt = xt + Math.imul(zt, Hr) | 0, xt = xt + Math.imul(ur, _r) | 0, Pt = Pt + Math.imul(ur, Hr) | 0;
        var cn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, $t = Math.imul(Vt, nr), xt = Math.imul(Vt, Zt), xt = xt + Math.imul(Lt, nr) | 0, Pt = Math.imul(Lt, Zt), $t = $t + Math.imul(kr, ar) | 0, xt = xt + Math.imul(kr, dr) | 0, xt = xt + Math.imul(Jr, ar) | 0, Pt = Pt + Math.imul(Jr, dr) | 0, $t = $t + Math.imul(Rr, br) | 0, xt = xt + Math.imul(Rr, xr) | 0, xt = xt + Math.imul(Vr, br) | 0, Pt = Pt + Math.imul(Vr, xr) | 0, $t = $t + Math.imul(Ar, Er) | 0, xt = xt + Math.imul(Ar, Dr) | 0, xt = xt + Math.imul(Gr, Er) | 0, Pt = Pt + Math.imul(Gr, Dr) | 0, $t = $t + Math.imul(Mr, tr) | 0, xt = xt + Math.imul(Mr, gr) | 0, xt = xt + Math.imul(pr, tr) | 0, Pt = Pt + Math.imul(pr, gr) | 0, $t = $t + Math.imul(yr, _r) | 0, xt = xt + Math.imul(yr, Hr) | 0, xt = xt + Math.imul(Sr, _r) | 0, Pt = Pt + Math.imul(Sr, Hr) | 0;
        var ln = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, $t = Math.imul(Vt, ar), xt = Math.imul(Vt, dr), xt = xt + Math.imul(Lt, ar) | 0, Pt = Math.imul(Lt, dr), $t = $t + Math.imul(kr, br) | 0, xt = xt + Math.imul(kr, xr) | 0, xt = xt + Math.imul(Jr, br) | 0, Pt = Pt + Math.imul(Jr, xr) | 0, $t = $t + Math.imul(Rr, Er) | 0, xt = xt + Math.imul(Rr, Dr) | 0, xt = xt + Math.imul(Vr, Er) | 0, Pt = Pt + Math.imul(Vr, Dr) | 0, $t = $t + Math.imul(Ar, tr) | 0, xt = xt + Math.imul(Ar, gr) | 0, xt = xt + Math.imul(Gr, tr) | 0, Pt = Pt + Math.imul(Gr, gr) | 0, $t = $t + Math.imul(Mr, _r) | 0, xt = xt + Math.imul(Mr, Hr) | 0, xt = xt + Math.imul(pr, _r) | 0, Pt = Pt + Math.imul(pr, Hr) | 0;
        var hn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, $t = Math.imul(Vt, br), xt = Math.imul(Vt, xr), xt = xt + Math.imul(Lt, br) | 0, Pt = Math.imul(Lt, xr), $t = $t + Math.imul(kr, Er) | 0, xt = xt + Math.imul(kr, Dr) | 0, xt = xt + Math.imul(Jr, Er) | 0, Pt = Pt + Math.imul(Jr, Dr) | 0, $t = $t + Math.imul(Rr, tr) | 0, xt = xt + Math.imul(Rr, gr) | 0, xt = xt + Math.imul(Vr, tr) | 0, Pt = Pt + Math.imul(Vr, gr) | 0, $t = $t + Math.imul(Ar, _r) | 0, xt = xt + Math.imul(Ar, Hr) | 0, xt = xt + Math.imul(Gr, _r) | 0, Pt = Pt + Math.imul(Gr, Hr) | 0;
        var dn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, $t = Math.imul(Vt, Er), xt = Math.imul(Vt, Dr), xt = xt + Math.imul(Lt, Er) | 0, Pt = Math.imul(Lt, Dr), $t = $t + Math.imul(kr, tr) | 0, xt = xt + Math.imul(kr, gr) | 0, xt = xt + Math.imul(Jr, tr) | 0, Pt = Pt + Math.imul(Jr, gr) | 0, $t = $t + Math.imul(Rr, _r) | 0, xt = xt + Math.imul(Rr, Hr) | 0, xt = xt + Math.imul(Vr, _r) | 0, Pt = Pt + Math.imul(Vr, Hr) | 0;
        var pn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, $t = Math.imul(Vt, tr), xt = Math.imul(Vt, gr), xt = xt + Math.imul(Lt, tr) | 0, Pt = Math.imul(Lt, gr), $t = $t + Math.imul(kr, _r) | 0, xt = xt + Math.imul(kr, Hr) | 0, xt = xt + Math.imul(Jr, _r) | 0, Pt = Pt + Math.imul(Jr, Hr) | 0;
        var vn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        wt = (Pt + (xt >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, $t = Math.imul(Vt, _r), xt = Math.imul(Vt, Hr), xt = xt + Math.imul(Lt, _r) | 0, Pt = Math.imul(Lt, Hr);
        var yn = (wt + $t | 0) + ((xt & 8191) << 13) | 0;
        return wt = (Pt + (xt >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, vt[0] = Cr, vt[1] = Br, vt[2] = zr, vt[3] = tn, vt[4] = Qr, vt[5] = en, vt[6] = sn, vt[7] = on, vt[8] = an, vt[9] = nn, vt[10] = fn, vt[11] = un, vt[12] = cn, vt[13] = ln, vt[14] = hn, vt[15] = dn, vt[16] = pn, vt[17] = vn, vt[18] = yn, wt !== 0 && (vt[19] = wt, ve.length++), ve;
      };
      Math.imul || (_t = ht);
      function Rt(Ft, bt, Xe) {
        Xe.negative = bt.negative ^ Ft.negative, Xe.length = Ft.length + bt.length;
        for (var ve = 0, Ce = 0, Qe = 0; Qe < Xe.length - 1; Qe++) {
          var vt = Ce;
          Ce = 0;
          for (var wt = ve & 67108863, $t = Math.min(Qe, bt.length - 1), xt = Math.max(0, Qe - Ft.length + 1); xt <= $t; xt++) {
            var Pt = Qe - xt, Je = Ft.words[Pt] | 0, Ot = bt.words[xt] | 0, er = Je * Ot, sr = er & 67108863;
            vt = vt + (er / 67108864 | 0) | 0, sr = sr + wt | 0, wt = sr & 67108863, vt = vt + (sr >>> 26) | 0, Ce += vt >>> 26, vt &= 67108863;
          }
          Xe.words[Qe] = wt, ve = vt, vt = Ce;
        }
        return ve !== 0 ? Xe.words[Qe] = ve : Xe.length--, Xe.strip();
      }
      function kt(Ft, bt, Xe) {
        var ve = new Bt();
        return ve.mulp(Ft, bt, Xe);
      }
      ne.prototype.mulTo = function(bt, Xe) {
        var ve, Ce = this.length + bt.length;
        return this.length === 10 && bt.length === 10 ? ve = _t(this, bt, Xe) : Ce < 63 ? ve = ht(this, bt, Xe) : Ce < 1024 ? ve = Rt(this, bt, Xe) : ve = kt(this, bt, Xe), ve;
      };
      function Bt(Ft, bt) {
        this.x = Ft, this.y = bt;
      }
      Bt.prototype.makeRBT = function(bt) {
        for (var Xe = new Array(bt), ve = ne.prototype._countBits(bt) - 1, Ce = 0; Ce < bt; Ce++)
          Xe[Ce] = this.revBin(Ce, ve, bt);
        return Xe;
      }, Bt.prototype.revBin = function(bt, Xe, ve) {
        if (bt === 0 || bt === ve - 1) return bt;
        for (var Ce = 0, Qe = 0; Qe < Xe; Qe++)
          Ce |= (bt & 1) << Xe - Qe - 1, bt >>= 1;
        return Ce;
      }, Bt.prototype.permute = function(bt, Xe, ve, Ce, Qe, vt) {
        for (var wt = 0; wt < vt; wt++)
          Ce[wt] = Xe[bt[wt]], Qe[wt] = ve[bt[wt]];
      }, Bt.prototype.transform = function(bt, Xe, ve, Ce, Qe, vt) {
        this.permute(vt, bt, Xe, ve, Ce, Qe);
        for (var wt = 1; wt < Qe; wt <<= 1)
          for (var $t = wt << 1, xt = Math.cos(2 * Math.PI / $t), Pt = Math.sin(2 * Math.PI / $t), Je = 0; Je < Qe; Je += $t)
            for (var Ot = xt, er = Pt, sr = 0; sr < wt; sr++) {
              var Jt = ve[Je + sr], Wt = Ce[Je + sr], Gt = ve[Je + sr + wt], rr = Ce[Je + sr + wt], or = Ot * Gt - er * rr;
              rr = Ot * rr + er * Gt, Gt = or, ve[Je + sr] = Jt + Gt, Ce[Je + sr] = Wt + rr, ve[Je + sr + wt] = Jt - Gt, Ce[Je + sr + wt] = Wt - rr, sr !== $t && (or = xt * Ot - Pt * er, er = xt * er + Pt * Ot, Ot = or);
            }
      }, Bt.prototype.guessLen13b = function(bt, Xe) {
        var ve = Math.max(Xe, bt) | 1, Ce = ve & 1, Qe = 0;
        for (ve = ve / 2 | 0; ve; ve = ve >>> 1)
          Qe++;
        return 1 << Qe + 1 + Ce;
      }, Bt.prototype.conjugate = function(bt, Xe, ve) {
        if (!(ve <= 1))
          for (var Ce = 0; Ce < ve / 2; Ce++) {
            var Qe = bt[Ce];
            bt[Ce] = bt[ve - Ce - 1], bt[ve - Ce - 1] = Qe, Qe = Xe[Ce], Xe[Ce] = -Xe[ve - Ce - 1], Xe[ve - Ce - 1] = -Qe;
          }
      }, Bt.prototype.normalize13b = function(bt, Xe) {
        for (var ve = 0, Ce = 0; Ce < Xe / 2; Ce++) {
          var Qe = Math.round(bt[2 * Ce + 1] / Xe) * 8192 + Math.round(bt[2 * Ce] / Xe) + ve;
          bt[Ce] = Qe & 67108863, Qe < 67108864 ? ve = 0 : ve = Qe / 67108864 | 0;
        }
        return bt;
      }, Bt.prototype.convert13b = function(bt, Xe, ve, Ce) {
        for (var Qe = 0, vt = 0; vt < Xe; vt++)
          Qe = Qe + (bt[vt] | 0), ve[2 * vt] = Qe & 8191, Qe = Qe >>> 13, ve[2 * vt + 1] = Qe & 8191, Qe = Qe >>> 13;
        for (vt = 2 * Xe; vt < Ce; ++vt)
          ve[vt] = 0;
        ie(Qe === 0), ie((Qe & -8192) === 0);
      }, Bt.prototype.stub = function(bt) {
        for (var Xe = new Array(bt), ve = 0; ve < bt; ve++)
          Xe[ve] = 0;
        return Xe;
      }, Bt.prototype.mulp = function(bt, Xe, ve) {
        var Ce = 2 * this.guessLen13b(bt.length, Xe.length), Qe = this.makeRBT(Ce), vt = this.stub(Ce), wt = new Array(Ce), $t = new Array(Ce), xt = new Array(Ce), Pt = new Array(Ce), Je = new Array(Ce), Ot = new Array(Ce), er = ve.words;
        er.length = Ce, this.convert13b(bt.words, bt.length, wt, Ce), this.convert13b(Xe.words, Xe.length, Pt, Ce), this.transform(wt, vt, $t, xt, Ce, Qe), this.transform(Pt, vt, Je, Ot, Ce, Qe);
        for (var sr = 0; sr < Ce; sr++) {
          var Jt = $t[sr] * Je[sr] - xt[sr] * Ot[sr];
          xt[sr] = $t[sr] * Ot[sr] + xt[sr] * Je[sr], $t[sr] = Jt;
        }
        return this.conjugate($t, xt, Ce), this.transform($t, xt, er, vt, Ce, Qe), this.conjugate(er, vt, Ce), this.normalize13b(er, Ce), ve.negative = bt.negative ^ Xe.negative, ve.length = bt.length + Xe.length, ve.strip();
      }, ne.prototype.mul = function(bt) {
        var Xe = new ne(null);
        return Xe.words = new Array(this.length + bt.length), this.mulTo(bt, Xe);
      }, ne.prototype.mulf = function(bt) {
        var Xe = new ne(null);
        return Xe.words = new Array(this.length + bt.length), kt(this, bt, Xe);
      }, ne.prototype.imul = function(bt) {
        return this.clone().mulTo(bt, this);
      }, ne.prototype.imuln = function(bt) {
        ie(typeof bt == "number"), ie(bt < 67108864);
        for (var Xe = 0, ve = 0; ve < this.length; ve++) {
          var Ce = (this.words[ve] | 0) * bt, Qe = (Ce & 67108863) + (Xe & 67108863);
          Xe >>= 26, Xe += Ce / 67108864 | 0, Xe += Qe >>> 26, this.words[ve] = Qe & 67108863;
        }
        return Xe !== 0 && (this.words[ve] = Xe, this.length++), this;
      }, ne.prototype.muln = function(bt) {
        return this.clone().imuln(bt);
      }, ne.prototype.sqr = function() {
        return this.mul(this);
      }, ne.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ne.prototype.pow = function(bt) {
        var Xe = Ke(bt);
        if (Xe.length === 0) return new ne(1);
        for (var ve = this, Ce = 0; Ce < Xe.length && Xe[Ce] === 0; Ce++, ve = ve.sqr())
          ;
        if (++Ce < Xe.length)
          for (var Qe = ve.sqr(); Ce < Xe.length; Ce++, Qe = Qe.sqr())
            Xe[Ce] !== 0 && (ve = ve.mul(Qe));
        return ve;
      }, ne.prototype.iushln = function(bt) {
        ie(typeof bt == "number" && bt >= 0);
        var Xe = bt % 26, ve = (bt - Xe) / 26, Ce = 67108863 >>> 26 - Xe << 26 - Xe, Qe;
        if (Xe !== 0) {
          var vt = 0;
          for (Qe = 0; Qe < this.length; Qe++) {
            var wt = this.words[Qe] & Ce, $t = (this.words[Qe] | 0) - wt << Xe;
            this.words[Qe] = $t | vt, vt = wt >>> 26 - Xe;
          }
          vt && (this.words[Qe] = vt, this.length++);
        }
        if (ve !== 0) {
          for (Qe = this.length - 1; Qe >= 0; Qe--)
            this.words[Qe + ve] = this.words[Qe];
          for (Qe = 0; Qe < ve; Qe++)
            this.words[Qe] = 0;
          this.length += ve;
        }
        return this.strip();
      }, ne.prototype.ishln = function(bt) {
        return ie(this.negative === 0), this.iushln(bt);
      }, ne.prototype.iushrn = function(bt, Xe, ve) {
        ie(typeof bt == "number" && bt >= 0);
        var Ce;
        Xe ? Ce = (Xe - Xe % 26) / 26 : Ce = 0;
        var Qe = bt % 26, vt = Math.min((bt - Qe) / 26, this.length), wt = 67108863 ^ 67108863 >>> Qe << Qe, $t = ve;
        if (Ce -= vt, Ce = Math.max(0, Ce), $t) {
          for (var xt = 0; xt < vt; xt++)
            $t.words[xt] = this.words[xt];
          $t.length = vt;
        }
        if (vt !== 0) if (this.length > vt)
          for (this.length -= vt, xt = 0; xt < this.length; xt++)
            this.words[xt] = this.words[xt + vt];
        else
          this.words[0] = 0, this.length = 1;
        var Pt = 0;
        for (xt = this.length - 1; xt >= 0 && (Pt !== 0 || xt >= Ce); xt--) {
          var Je = this.words[xt] | 0;
          this.words[xt] = Pt << 26 - Qe | Je >>> Qe, Pt = Je & wt;
        }
        return $t && Pt !== 0 && ($t.words[$t.length++] = Pt), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, ne.prototype.ishrn = function(bt, Xe, ve) {
        return ie(this.negative === 0), this.iushrn(bt, Xe, ve);
      }, ne.prototype.shln = function(bt) {
        return this.clone().ishln(bt);
      }, ne.prototype.ushln = function(bt) {
        return this.clone().iushln(bt);
      }, ne.prototype.shrn = function(bt) {
        return this.clone().ishrn(bt);
      }, ne.prototype.ushrn = function(bt) {
        return this.clone().iushrn(bt);
      }, ne.prototype.testn = function(bt) {
        ie(typeof bt == "number" && bt >= 0);
        var Xe = bt % 26, ve = (bt - Xe) / 26, Ce = 1 << Xe;
        if (this.length <= ve) return !1;
        var Qe = this.words[ve];
        return !!(Qe & Ce);
      }, ne.prototype.imaskn = function(bt) {
        ie(typeof bt == "number" && bt >= 0);
        var Xe = bt % 26, ve = (bt - Xe) / 26;
        if (ie(this.negative === 0, "imaskn works only with positive numbers"), this.length <= ve)
          return this;
        if (Xe !== 0 && ve++, this.length = Math.min(ve, this.length), Xe !== 0) {
          var Ce = 67108863 ^ 67108863 >>> Xe << Xe;
          this.words[this.length - 1] &= Ce;
        }
        return this.strip();
      }, ne.prototype.maskn = function(bt) {
        return this.clone().imaskn(bt);
      }, ne.prototype.iaddn = function(bt) {
        return ie(typeof bt == "number"), ie(bt < 67108864), bt < 0 ? this.isubn(-bt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < bt ? (this.words[0] = bt - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(bt), this.negative = 1, this) : this._iaddn(bt);
      }, ne.prototype._iaddn = function(bt) {
        this.words[0] += bt;
        for (var Xe = 0; Xe < this.length && this.words[Xe] >= 67108864; Xe++)
          this.words[Xe] -= 67108864, Xe === this.length - 1 ? this.words[Xe + 1] = 1 : this.words[Xe + 1]++;
        return this.length = Math.max(this.length, Xe + 1), this;
      }, ne.prototype.isubn = function(bt) {
        if (ie(typeof bt == "number"), ie(bt < 67108864), bt < 0) return this.iaddn(-bt);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(bt), this.negative = 1, this;
        if (this.words[0] -= bt, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Xe = 0; Xe < this.length && this.words[Xe] < 0; Xe++)
            this.words[Xe] += 67108864, this.words[Xe + 1] -= 1;
        return this.strip();
      }, ne.prototype.addn = function(bt) {
        return this.clone().iaddn(bt);
      }, ne.prototype.subn = function(bt) {
        return this.clone().isubn(bt);
      }, ne.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ne.prototype.abs = function() {
        return this.clone().iabs();
      }, ne.prototype._ishlnsubmul = function(bt, Xe, ve) {
        var Ce = bt.length + ve, Qe;
        this._expand(Ce);
        var vt, wt = 0;
        for (Qe = 0; Qe < bt.length; Qe++) {
          vt = (this.words[Qe + ve] | 0) + wt;
          var $t = (bt.words[Qe] | 0) * Xe;
          vt -= $t & 67108863, wt = (vt >> 26) - ($t / 67108864 | 0), this.words[Qe + ve] = vt & 67108863;
        }
        for (; Qe < this.length - ve; Qe++)
          vt = (this.words[Qe + ve] | 0) + wt, wt = vt >> 26, this.words[Qe + ve] = vt & 67108863;
        if (wt === 0) return this.strip();
        for (ie(wt === -1), wt = 0, Qe = 0; Qe < this.length; Qe++)
          vt = -(this.words[Qe] | 0) + wt, wt = vt >> 26, this.words[Qe] = vt & 67108863;
        return this.negative = 1, this.strip();
      }, ne.prototype._wordDiv = function(bt, Xe) {
        var ve = this.length - bt.length, Ce = this.clone(), Qe = bt, vt = Qe.words[Qe.length - 1] | 0, wt = this._countBits(vt);
        ve = 26 - wt, ve !== 0 && (Qe = Qe.ushln(ve), Ce.iushln(ve), vt = Qe.words[Qe.length - 1] | 0);
        var $t = Ce.length - Qe.length, xt;
        if (Xe !== "mod") {
          xt = new ne(null), xt.length = $t + 1, xt.words = new Array(xt.length);
          for (var Pt = 0; Pt < xt.length; Pt++)
            xt.words[Pt] = 0;
        }
        var Je = Ce.clone()._ishlnsubmul(Qe, 1, $t);
        Je.negative === 0 && (Ce = Je, xt && (xt.words[$t] = 1));
        for (var Ot = $t - 1; Ot >= 0; Ot--) {
          var er = (Ce.words[Qe.length + Ot] | 0) * 67108864 + (Ce.words[Qe.length + Ot - 1] | 0);
          for (er = Math.min(er / vt | 0, 67108863), Ce._ishlnsubmul(Qe, er, Ot); Ce.negative !== 0; )
            er--, Ce.negative = 0, Ce._ishlnsubmul(Qe, 1, Ot), Ce.isZero() || (Ce.negative ^= 1);
          xt && (xt.words[Ot] = er);
        }
        return xt && xt.strip(), Ce.strip(), Xe !== "div" && ve !== 0 && Ce.iushrn(ve), {
          div: xt || null,
          mod: Ce
        };
      }, ne.prototype.divmod = function(bt, Xe, ve) {
        if (ie(!bt.isZero()), this.isZero())
          return {
            div: new ne(0),
            mod: new ne(0)
          };
        var Ce, Qe, vt;
        return this.negative !== 0 && bt.negative === 0 ? (vt = this.neg().divmod(bt, Xe), Xe !== "mod" && (Ce = vt.div.neg()), Xe !== "div" && (Qe = vt.mod.neg(), ve && Qe.negative !== 0 && Qe.iadd(bt)), {
          div: Ce,
          mod: Qe
        }) : this.negative === 0 && bt.negative !== 0 ? (vt = this.divmod(bt.neg(), Xe), Xe !== "mod" && (Ce = vt.div.neg()), {
          div: Ce,
          mod: vt.mod
        }) : this.negative & bt.negative ? (vt = this.neg().divmod(bt.neg(), Xe), Xe !== "div" && (Qe = vt.mod.neg(), ve && Qe.negative !== 0 && Qe.isub(bt)), {
          div: vt.div,
          mod: Qe
        }) : bt.length > this.length || this.cmp(bt) < 0 ? {
          div: new ne(0),
          mod: this
        } : bt.length === 1 ? Xe === "div" ? {
          div: this.divn(bt.words[0]),
          mod: null
        } : Xe === "mod" ? {
          div: null,
          mod: new ne(this.modn(bt.words[0]))
        } : {
          div: this.divn(bt.words[0]),
          mod: new ne(this.modn(bt.words[0]))
        } : this._wordDiv(bt, Xe);
      }, ne.prototype.div = function(bt) {
        return this.divmod(bt, "div", !1).div;
      }, ne.prototype.mod = function(bt) {
        return this.divmod(bt, "mod", !1).mod;
      }, ne.prototype.umod = function(bt) {
        return this.divmod(bt, "mod", !0).mod;
      }, ne.prototype.divRound = function(bt) {
        var Xe = this.divmod(bt);
        if (Xe.mod.isZero()) return Xe.div;
        var ve = Xe.div.negative !== 0 ? Xe.mod.isub(bt) : Xe.mod, Ce = bt.ushrn(1), Qe = bt.andln(1), vt = ve.cmp(Ce);
        return vt < 0 || Qe === 1 && vt === 0 ? Xe.div : Xe.div.negative !== 0 ? Xe.div.isubn(1) : Xe.div.iaddn(1);
      }, ne.prototype.modn = function(bt) {
        ie(bt <= 67108863);
        for (var Xe = (1 << 26) % bt, ve = 0, Ce = this.length - 1; Ce >= 0; Ce--)
          ve = (Xe * ve + (this.words[Ce] | 0)) % bt;
        return ve;
      }, ne.prototype.idivn = function(bt) {
        ie(bt <= 67108863);
        for (var Xe = 0, ve = this.length - 1; ve >= 0; ve--) {
          var Ce = (this.words[ve] | 0) + Xe * 67108864;
          this.words[ve] = Ce / bt | 0, Xe = Ce % bt;
        }
        return this.strip();
      }, ne.prototype.divn = function(bt) {
        return this.clone().idivn(bt);
      }, ne.prototype.egcd = function(bt) {
        ie(bt.negative === 0), ie(!bt.isZero());
        var Xe = this, ve = bt.clone();
        Xe.negative !== 0 ? Xe = Xe.umod(bt) : Xe = Xe.clone();
        for (var Ce = new ne(1), Qe = new ne(0), vt = new ne(0), wt = new ne(1), $t = 0; Xe.isEven() && ve.isEven(); )
          Xe.iushrn(1), ve.iushrn(1), ++$t;
        for (var xt = ve.clone(), Pt = Xe.clone(); !Xe.isZero(); ) {
          for (var Je = 0, Ot = 1; !(Xe.words[0] & Ot) && Je < 26; ++Je, Ot <<= 1) ;
          if (Je > 0)
            for (Xe.iushrn(Je); Je-- > 0; )
              (Ce.isOdd() || Qe.isOdd()) && (Ce.iadd(xt), Qe.isub(Pt)), Ce.iushrn(1), Qe.iushrn(1);
          for (var er = 0, sr = 1; !(ve.words[0] & sr) && er < 26; ++er, sr <<= 1) ;
          if (er > 0)
            for (ve.iushrn(er); er-- > 0; )
              (vt.isOdd() || wt.isOdd()) && (vt.iadd(xt), wt.isub(Pt)), vt.iushrn(1), wt.iushrn(1);
          Xe.cmp(ve) >= 0 ? (Xe.isub(ve), Ce.isub(vt), Qe.isub(wt)) : (ve.isub(Xe), vt.isub(Ce), wt.isub(Qe));
        }
        return {
          a: vt,
          b: wt,
          gcd: ve.iushln($t)
        };
      }, ne.prototype._invmp = function(bt) {
        ie(bt.negative === 0), ie(!bt.isZero());
        var Xe = this, ve = bt.clone();
        Xe.negative !== 0 ? Xe = Xe.umod(bt) : Xe = Xe.clone();
        for (var Ce = new ne(1), Qe = new ne(0), vt = ve.clone(); Xe.cmpn(1) > 0 && ve.cmpn(1) > 0; ) {
          for (var wt = 0, $t = 1; !(Xe.words[0] & $t) && wt < 26; ++wt, $t <<= 1) ;
          if (wt > 0)
            for (Xe.iushrn(wt); wt-- > 0; )
              Ce.isOdd() && Ce.iadd(vt), Ce.iushrn(1);
          for (var xt = 0, Pt = 1; !(ve.words[0] & Pt) && xt < 26; ++xt, Pt <<= 1) ;
          if (xt > 0)
            for (ve.iushrn(xt); xt-- > 0; )
              Qe.isOdd() && Qe.iadd(vt), Qe.iushrn(1);
          Xe.cmp(ve) >= 0 ? (Xe.isub(ve), Ce.isub(Qe)) : (ve.isub(Xe), Qe.isub(Ce));
        }
        var Je;
        return Xe.cmpn(1) === 0 ? Je = Ce : Je = Qe, Je.cmpn(0) < 0 && Je.iadd(bt), Je;
      }, ne.prototype.gcd = function(bt) {
        if (this.isZero()) return bt.abs();
        if (bt.isZero()) return this.abs();
        var Xe = this.clone(), ve = bt.clone();
        Xe.negative = 0, ve.negative = 0;
        for (var Ce = 0; Xe.isEven() && ve.isEven(); Ce++)
          Xe.iushrn(1), ve.iushrn(1);
        do {
          for (; Xe.isEven(); )
            Xe.iushrn(1);
          for (; ve.isEven(); )
            ve.iushrn(1);
          var Qe = Xe.cmp(ve);
          if (Qe < 0) {
            var vt = Xe;
            Xe = ve, ve = vt;
          } else if (Qe === 0 || ve.cmpn(1) === 0)
            break;
          Xe.isub(ve);
        } while (!0);
        return ve.iushln(Ce);
      }, ne.prototype.invm = function(bt) {
        return this.egcd(bt).a.umod(bt);
      }, ne.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ne.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ne.prototype.andln = function(bt) {
        return this.words[0] & bt;
      }, ne.prototype.bincn = function(bt) {
        ie(typeof bt == "number");
        var Xe = bt % 26, ve = (bt - Xe) / 26, Ce = 1 << Xe;
        if (this.length <= ve)
          return this._expand(ve + 1), this.words[ve] |= Ce, this;
        for (var Qe = Ce, vt = ve; Qe !== 0 && vt < this.length; vt++) {
          var wt = this.words[vt] | 0;
          wt += Qe, Qe = wt >>> 26, wt &= 67108863, this.words[vt] = wt;
        }
        return Qe !== 0 && (this.words[vt] = Qe, this.length++), this;
      }, ne.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ne.prototype.cmpn = function(bt) {
        var Xe = bt < 0;
        if (this.negative !== 0 && !Xe) return -1;
        if (this.negative === 0 && Xe) return 1;
        this.strip();
        var ve;
        if (this.length > 1)
          ve = 1;
        else {
          Xe && (bt = -bt), ie(bt <= 67108863, "Number is too big");
          var Ce = this.words[0] | 0;
          ve = Ce === bt ? 0 : Ce < bt ? -1 : 1;
        }
        return this.negative !== 0 ? -ve | 0 : ve;
      }, ne.prototype.cmp = function(bt) {
        if (this.negative !== 0 && bt.negative === 0) return -1;
        if (this.negative === 0 && bt.negative !== 0) return 1;
        var Xe = this.ucmp(bt);
        return this.negative !== 0 ? -Xe | 0 : Xe;
      }, ne.prototype.ucmp = function(bt) {
        if (this.length > bt.length) return 1;
        if (this.length < bt.length) return -1;
        for (var Xe = 0, ve = this.length - 1; ve >= 0; ve--) {
          var Ce = this.words[ve] | 0, Qe = bt.words[ve] | 0;
          if (Ce !== Qe) {
            Ce < Qe ? Xe = -1 : Ce > Qe && (Xe = 1);
            break;
          }
        }
        return Xe;
      }, ne.prototype.gtn = function(bt) {
        return this.cmpn(bt) === 1;
      }, ne.prototype.gt = function(bt) {
        return this.cmp(bt) === 1;
      }, ne.prototype.gten = function(bt) {
        return this.cmpn(bt) >= 0;
      }, ne.prototype.gte = function(bt) {
        return this.cmp(bt) >= 0;
      }, ne.prototype.ltn = function(bt) {
        return this.cmpn(bt) === -1;
      }, ne.prototype.lt = function(bt) {
        return this.cmp(bt) === -1;
      }, ne.prototype.lten = function(bt) {
        return this.cmpn(bt) <= 0;
      }, ne.prototype.lte = function(bt) {
        return this.cmp(bt) <= 0;
      }, ne.prototype.eqn = function(bt) {
        return this.cmpn(bt) === 0;
      }, ne.prototype.eq = function(bt) {
        return this.cmp(bt) === 0;
      }, ne.red = function(bt) {
        return new Nt(bt);
      }, ne.prototype.toRed = function(bt) {
        return ie(!this.red, "Already a number in reduction context"), ie(this.negative === 0, "red works only with positives"), bt.convertTo(this)._forceRed(bt);
      }, ne.prototype.fromRed = function() {
        return ie(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ne.prototype._forceRed = function(bt) {
        return this.red = bt, this;
      }, ne.prototype.forceRed = function(bt) {
        return ie(!this.red, "Already a number in reduction context"), this._forceRed(bt);
      }, ne.prototype.redAdd = function(bt) {
        return ie(this.red, "redAdd works only with red numbers"), this.red.add(this, bt);
      }, ne.prototype.redIAdd = function(bt) {
        return ie(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, bt);
      }, ne.prototype.redSub = function(bt) {
        return ie(this.red, "redSub works only with red numbers"), this.red.sub(this, bt);
      }, ne.prototype.redISub = function(bt) {
        return ie(this.red, "redISub works only with red numbers"), this.red.isub(this, bt);
      }, ne.prototype.redShl = function(bt) {
        return ie(this.red, "redShl works only with red numbers"), this.red.shl(this, bt);
      }, ne.prototype.redMul = function(bt) {
        return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, bt), this.red.mul(this, bt);
      }, ne.prototype.redIMul = function(bt) {
        return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, bt), this.red.imul(this, bt);
      }, ne.prototype.redSqr = function() {
        return ie(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ne.prototype.redISqr = function() {
        return ie(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ne.prototype.redSqrt = function() {
        return ie(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ne.prototype.redInvm = function() {
        return ie(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ne.prototype.redNeg = function() {
        return ie(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ne.prototype.redPow = function(bt) {
        return ie(this.red && !bt.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, bt);
      };
      var Ct = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function qt(Ft, bt) {
        this.name = Ft, this.p = new ne(bt, 16), this.n = this.p.bitLength(), this.k = new ne(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      qt.prototype._tmp = function() {
        var bt = new ne(null);
        return bt.words = new Array(Math.ceil(this.n / 13)), bt;
      }, qt.prototype.ireduce = function(bt) {
        var Xe = bt, ve;
        do
          this.split(Xe, this.tmp), Xe = this.imulK(Xe), Xe = Xe.iadd(this.tmp), ve = Xe.bitLength();
        while (ve > this.n);
        var Ce = ve < this.n ? -1 : Xe.ucmp(this.p);
        return Ce === 0 ? (Xe.words[0] = 0, Xe.length = 1) : Ce > 0 ? Xe.isub(this.p) : Xe.strip !== void 0 ? Xe.strip() : Xe._strip(), Xe;
      }, qt.prototype.split = function(bt, Xe) {
        bt.iushrn(this.n, 0, Xe);
      }, qt.prototype.imulK = function(bt) {
        return bt.imul(this.k);
      };
      function jt() {
        qt.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      se(jt, qt), jt.prototype.split = function(bt, Xe) {
        for (var ve = 4194303, Ce = Math.min(bt.length, 9), Qe = 0; Qe < Ce; Qe++)
          Xe.words[Qe] = bt.words[Qe];
        if (Xe.length = Ce, bt.length <= 9) {
          bt.words[0] = 0, bt.length = 1;
          return;
        }
        var vt = bt.words[9];
        for (Xe.words[Xe.length++] = vt & ve, Qe = 10; Qe < bt.length; Qe++) {
          var wt = bt.words[Qe] | 0;
          bt.words[Qe - 10] = (wt & ve) << 4 | vt >>> 22, vt = wt;
        }
        vt >>>= 22, bt.words[Qe - 10] = vt, vt === 0 && bt.length > 10 ? bt.length -= 10 : bt.length -= 9;
      }, jt.prototype.imulK = function(bt) {
        bt.words[bt.length] = 0, bt.words[bt.length + 1] = 0, bt.length += 2;
        for (var Xe = 0, ve = 0; ve < bt.length; ve++) {
          var Ce = bt.words[ve] | 0;
          Xe += Ce * 977, bt.words[ve] = Xe & 67108863, Xe = Ce * 64 + (Xe / 67108864 | 0);
        }
        return bt.words[bt.length - 1] === 0 && (bt.length--, bt.words[bt.length - 1] === 0 && bt.length--), bt;
      };
      function Ht() {
        qt.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      se(Ht, qt);
      function Yt() {
        qt.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      se(Yt, qt);
      function Ut() {
        qt.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      se(Ut, qt), Ut.prototype.imulK = function(bt) {
        for (var Xe = 0, ve = 0; ve < bt.length; ve++) {
          var Ce = (bt.words[ve] | 0) * 19 + Xe, Qe = Ce & 67108863;
          Ce >>>= 26, bt.words[ve] = Qe, Xe = Ce;
        }
        return Xe !== 0 && (bt.words[bt.length++] = Xe), bt;
      }, ne._prime = function(bt) {
        if (Ct[bt]) return Ct[bt];
        var Xe;
        if (bt === "k256")
          Xe = new jt();
        else if (bt === "p224")
          Xe = new Ht();
        else if (bt === "p192")
          Xe = new Yt();
        else if (bt === "p25519")
          Xe = new Ut();
        else
          throw new Error("Unknown prime " + bt);
        return Ct[bt] = Xe, Xe;
      };
      function Nt(Ft) {
        if (typeof Ft == "string") {
          var bt = ne._prime(Ft);
          this.m = bt.p, this.prime = bt;
        } else
          ie(Ft.gtn(1), "modulus must be greater than 1"), this.m = Ft, this.prime = null;
      }
      Nt.prototype._verify1 = function(bt) {
        ie(bt.negative === 0, "red works only with positives"), ie(bt.red, "red works only with red numbers");
      }, Nt.prototype._verify2 = function(bt, Xe) {
        ie((bt.negative | Xe.negative) === 0, "red works only with positives"), ie(
          bt.red && bt.red === Xe.red,
          "red works only with red numbers"
        );
      }, Nt.prototype.imod = function(bt) {
        return this.prime ? this.prime.ireduce(bt)._forceRed(this) : bt.umod(this.m)._forceRed(this);
      }, Nt.prototype.neg = function(bt) {
        return bt.isZero() ? bt.clone() : this.m.sub(bt)._forceRed(this);
      }, Nt.prototype.add = function(bt, Xe) {
        this._verify2(bt, Xe);
        var ve = bt.add(Xe);
        return ve.cmp(this.m) >= 0 && ve.isub(this.m), ve._forceRed(this);
      }, Nt.prototype.iadd = function(bt, Xe) {
        this._verify2(bt, Xe);
        var ve = bt.iadd(Xe);
        return ve.cmp(this.m) >= 0 && ve.isub(this.m), ve;
      }, Nt.prototype.sub = function(bt, Xe) {
        this._verify2(bt, Xe);
        var ve = bt.sub(Xe);
        return ve.cmpn(0) < 0 && ve.iadd(this.m), ve._forceRed(this);
      }, Nt.prototype.isub = function(bt, Xe) {
        this._verify2(bt, Xe);
        var ve = bt.isub(Xe);
        return ve.cmpn(0) < 0 && ve.iadd(this.m), ve;
      }, Nt.prototype.shl = function(bt, Xe) {
        return this._verify1(bt), this.imod(bt.ushln(Xe));
      }, Nt.prototype.imul = function(bt, Xe) {
        return this._verify2(bt, Xe), this.imod(bt.imul(Xe));
      }, Nt.prototype.mul = function(bt, Xe) {
        return this._verify2(bt, Xe), this.imod(bt.mul(Xe));
      }, Nt.prototype.isqr = function(bt) {
        return this.imul(bt, bt.clone());
      }, Nt.prototype.sqr = function(bt) {
        return this.mul(bt, bt);
      }, Nt.prototype.sqrt = function(bt) {
        if (bt.isZero()) return bt.clone();
        var Xe = this.m.andln(3);
        if (ie(Xe % 2 === 1), Xe === 3) {
          var ve = this.m.add(new ne(1)).iushrn(2);
          return this.pow(bt, ve);
        }
        for (var Ce = this.m.subn(1), Qe = 0; !Ce.isZero() && Ce.andln(1) === 0; )
          Qe++, Ce.iushrn(1);
        ie(!Ce.isZero());
        var vt = new ne(1).toRed(this), wt = vt.redNeg(), $t = this.m.subn(1).iushrn(1), xt = this.m.bitLength();
        for (xt = new ne(2 * xt * xt).toRed(this); this.pow(xt, $t).cmp(wt) !== 0; )
          xt.redIAdd(wt);
        for (var Pt = this.pow(xt, Ce), Je = this.pow(bt, Ce.addn(1).iushrn(1)), Ot = this.pow(bt, Ce), er = Qe; Ot.cmp(vt) !== 0; ) {
          for (var sr = Ot, Jt = 0; sr.cmp(vt) !== 0; Jt++)
            sr = sr.redSqr();
          ie(Jt < er);
          var Wt = this.pow(Pt, new ne(1).iushln(er - Jt - 1));
          Je = Je.redMul(Wt), Pt = Wt.redSqr(), Ot = Ot.redMul(Pt), er = Jt;
        }
        return Je;
      }, Nt.prototype.invm = function(bt) {
        var Xe = bt._invmp(this.m);
        return Xe.negative !== 0 ? (Xe.negative = 0, this.imod(Xe).redNeg()) : this.imod(Xe);
      }, Nt.prototype.pow = function(bt, Xe) {
        if (Xe.isZero()) return new ne(1).toRed(this);
        if (Xe.cmpn(1) === 0) return bt.clone();
        var ve = 4, Ce = new Array(1 << ve);
        Ce[0] = new ne(1).toRed(this), Ce[1] = bt;
        for (var Qe = 2; Qe < Ce.length; Qe++)
          Ce[Qe] = this.mul(Ce[Qe - 1], bt);
        var vt = Ce[0], wt = 0, $t = 0, xt = Xe.bitLength() % 26;
        for (xt === 0 && (xt = 26), Qe = Xe.length - 1; Qe >= 0; Qe--) {
          for (var Pt = Xe.words[Qe], Je = xt - 1; Je >= 0; Je--) {
            var Ot = Pt >> Je & 1;
            if (vt !== Ce[0] && (vt = this.sqr(vt)), Ot === 0 && wt === 0) {
              $t = 0;
              continue;
            }
            wt <<= 1, wt |= Ot, $t++, !($t !== ve && (Qe !== 0 || Je !== 0)) && (vt = this.mul(vt, Ce[wt]), $t = 0, wt = 0);
          }
          xt = 26;
        }
        return vt;
      }, Nt.prototype.convertTo = function(bt) {
        var Xe = bt.umod(this.m);
        return Xe === bt ? Xe.clone() : Xe;
      }, Nt.prototype.convertFrom = function(bt) {
        var Xe = bt.clone();
        return Xe.red = null, Xe;
      }, ne.mont = function(bt) {
        return new Kt(bt);
      };
      function Kt(Ft) {
        Nt.call(this, Ft), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ne(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      se(Kt, Nt), Kt.prototype.convertTo = function(bt) {
        return this.imod(bt.ushln(this.shift));
      }, Kt.prototype.convertFrom = function(bt) {
        var Xe = this.imod(bt.mul(this.rinv));
        return Xe.red = null, Xe;
      }, Kt.prototype.imul = function(bt, Xe) {
        if (bt.isZero() || Xe.isZero())
          return bt.words[0] = 0, bt.length = 1, bt;
        var ve = bt.imul(Xe), Ce = ve.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Qe = ve.isub(Ce).iushrn(this.shift), vt = Qe;
        return Qe.cmp(this.m) >= 0 ? vt = Qe.isub(this.m) : Qe.cmpn(0) < 0 && (vt = Qe.iadd(this.m)), vt._forceRed(this);
      }, Kt.prototype.mul = function(bt, Xe) {
        if (bt.isZero() || Xe.isZero()) return new ne(0)._forceRed(this);
        var ve = bt.mul(Xe), Ce = ve.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Qe = ve.isub(Ce).iushrn(this.shift), vt = Qe;
        return Qe.cmp(this.m) >= 0 ? vt = Qe.isub(this.m) : Qe.cmpn(0) < 0 && (vt = Qe.iadd(this.m)), vt._forceRed(this);
      }, Kt.prototype.invm = function(bt) {
        var Xe = this.imod(bt._invmp(this.m).mul(this.r2));
        return Xe._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn$2)), bn$2.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var B;
  brorand.exports = function(se) {
    return B || (B = new z(null)), B.generate(se);
  };
  function z(ie) {
    this.rand = ie;
  }
  if (brorand.exports.Rand = z, z.prototype.generate = function(se) {
    return this._rand(se);
  }, z.prototype._rand = function(se) {
    if (this.rand.getBytes)
      return this.rand.getBytes(se);
    for (var ne = new Uint8Array(se), ae = 0; ae < ne.length; ae++)
      ne[ae] = this.rand.getByte();
    return ne;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? z.prototype._rand = function(se) {
      var ne = new Uint8Array(se);
      return self.crypto.getRandomValues(ne), ne;
    } : self.msCrypto && self.msCrypto.getRandomValues ? z.prototype._rand = function(se) {
      var ne = new Uint8Array(se);
      return self.msCrypto.getRandomValues(ne), ne;
    } : typeof window == "object" && (z.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var Y = requireCryptoBrowserify();
      if (typeof Y.randomBytes != "function")
        throw new Error("Not supported");
      z.prototype._rand = function(se) {
        return Y.randomBytes(se);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var B = requireBn$2(), z = requireBrorand();
  function Y(ie) {
    this.rand = ie || new z.Rand();
  }
  return mr = Y, Y.create = function(se) {
    return new Y(se);
  }, Y.prototype._randbelow = function(se) {
    var ne = se.bitLength(), ae = Math.ceil(ne / 8);
    do
      var le = new B(this.rand.generate(ae));
    while (le.cmp(se) >= 0);
    return le;
  }, Y.prototype._randrange = function(se, ne) {
    var ae = ne.sub(se);
    return se.add(this._randbelow(ae));
  }, Y.prototype.test = function(se, ne, ae) {
    var le = se.bitLength(), ge = B.mont(se), Ee = new B(1).toRed(ge);
    ne || (ne = Math.max(1, le / 48 | 0));
    for (var oe = se.subn(1), Pe = 0; !oe.testn(Pe); Pe++)
      ;
    for (var Ve = se.shrn(Pe), Ke = oe.toRed(ge), ht = !0; ne > 0; ne--) {
      var _t = this._randrange(new B(2), oe);
      ae && ae(_t);
      var Rt = _t.toRed(ge).redPow(Ve);
      if (!(Rt.cmp(Ee) === 0 || Rt.cmp(Ke) === 0)) {
        for (var kt = 1; kt < Pe; kt++) {
          if (Rt = Rt.redSqr(), Rt.cmp(Ee) === 0)
            return !1;
          if (Rt.cmp(Ke) === 0)
            break;
        }
        if (kt === Pe)
          return !1;
      }
    }
    return ht;
  }, Y.prototype.getDivisor = function(se, ne) {
    var ae = se.bitLength(), le = B.mont(se), ge = new B(1).toRed(le);
    ne || (ne = Math.max(1, ae / 48 | 0));
    for (var Ee = se.subn(1), oe = 0; !Ee.testn(oe); oe++)
      ;
    for (var Pe = se.shrn(oe), Ve = Ee.toRed(le); ne > 0; ne--) {
      var Ke = this._randrange(new B(2), Ee), ht = se.gcd(Ke);
      if (ht.cmpn(1) !== 0)
        return ht;
      var _t = Ke.toRed(le).redPow(Pe);
      if (!(_t.cmp(ge) === 0 || _t.cmp(Ve) === 0)) {
        for (var Rt = 1; Rt < oe; Rt++) {
          if (_t = _t.redSqr(), _t.cmp(ge) === 0)
            return _t.fromRed().subn(1).gcd(se);
          if (_t.cmp(Ve) === 0)
            break;
        }
        if (Rt === oe)
          return _t = _t.redSqr(), _t.fromRed().subn(1).gcd(se);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var B = requireBrowser$b();
  generatePrime = Rt, Rt.simpleSieve = ht, Rt.fermatTest = _t;
  var z = requireBn$2(), Y = new z(24), ie = requireMr(), se = new ie(), ne = new z(1), ae = new z(2), le = new z(5);
  new z(16), new z(8);
  var ge = new z(10), Ee = new z(3);
  new z(7);
  var oe = new z(11), Pe = new z(4);
  new z(12);
  var Ve = null;
  function Ke() {
    if (Ve !== null)
      return Ve;
    var kt = 1048576, Bt = [];
    Bt[0] = 2;
    for (var Ct = 1, qt = 3; qt < kt; qt += 2) {
      for (var jt = Math.ceil(Math.sqrt(qt)), Ht = 0; Ht < Ct && Bt[Ht] <= jt && qt % Bt[Ht] !== 0; Ht++)
        ;
      Ct !== Ht && Bt[Ht] <= jt || (Bt[Ct++] = qt);
    }
    return Ve = Bt, Bt;
  }
  function ht(kt) {
    for (var Bt = Ke(), Ct = 0; Ct < Bt.length; Ct++)
      if (kt.modn(Bt[Ct]) === 0)
        return kt.cmpn(Bt[Ct]) === 0;
    return !0;
  }
  function _t(kt) {
    var Bt = z.mont(kt);
    return ae.toRed(Bt).redPow(kt.subn(1)).fromRed().cmpn(1) === 0;
  }
  function Rt(kt, Bt) {
    if (kt < 16)
      return Bt === 2 || Bt === 5 ? new z([140, 123]) : new z([140, 39]);
    Bt = new z(Bt);
    for (var Ct, qt; ; ) {
      for (Ct = new z(B(Math.ceil(kt / 8))); Ct.bitLength() > kt; )
        Ct.ishrn(1);
      if (Ct.isEven() && Ct.iadd(ne), Ct.testn(1) || Ct.iadd(ae), Bt.cmp(ae)) {
        if (!Bt.cmp(le))
          for (; Ct.mod(ge).cmp(Ee); )
            Ct.iadd(Pe);
      } else for (; Ct.mod(Y).cmp(oe); )
        Ct.iadd(Pe);
      if (qt = Ct.shrn(1), ht(qt) && ht(Ct) && _t(qt) && _t(Ct) && se.test(qt) && se.test(Ct))
        return Ct;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var B = requireBn$2(), z = requireMr(), Y = new z(), ie = new B(24), se = new B(11), ne = new B(10), ae = new B(3), le = new B(7), ge = requireGeneratePrime(), Ee = requireBrowser$b();
  dh = ht;
  function oe(Rt, kt) {
    return kt = kt || "utf8", Buffer$1.isBuffer(Rt) || (Rt = new Buffer$1(Rt, kt)), this._pub = new B(Rt), this;
  }
  function Pe(Rt, kt) {
    return kt = kt || "utf8", Buffer$1.isBuffer(Rt) || (Rt = new Buffer$1(Rt, kt)), this._priv = new B(Rt), this;
  }
  var Ve = {};
  function Ke(Rt, kt) {
    var Bt = kt.toString("hex"), Ct = [Bt, Rt.toString(16)].join("_");
    if (Ct in Ve)
      return Ve[Ct];
    var qt = 0;
    if (Rt.isEven() || !ge.simpleSieve || !ge.fermatTest(Rt) || !Y.test(Rt))
      return qt += 1, Bt === "02" || Bt === "05" ? qt += 8 : qt += 4, Ve[Ct] = qt, qt;
    Y.test(Rt.shrn(1)) || (qt += 2);
    var jt;
    switch (Bt) {
      case "02":
        Rt.mod(ie).cmp(se) && (qt += 8);
        break;
      case "05":
        jt = Rt.mod(ne), jt.cmp(ae) && jt.cmp(le) && (qt += 8);
        break;
      default:
        qt += 4;
    }
    return Ve[Ct] = qt, qt;
  }
  function ht(Rt, kt, Bt) {
    this.setGenerator(kt), this.__prime = new B(Rt), this._prime = B.mont(this.__prime), this._primeLen = Rt.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, Bt ? (this.setPublicKey = oe, this.setPrivateKey = Pe) : this._primeCode = 8;
  }
  Object.defineProperty(ht.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Ke(this.__prime, this.__gen)), this._primeCode;
    }
  }), ht.prototype.generateKeys = function() {
    return this._priv || (this._priv = new B(Ee(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, ht.prototype.computeSecret = function(Rt) {
    Rt = new B(Rt), Rt = Rt.toRed(this._prime);
    var kt = Rt.redPow(this._priv).fromRed(), Bt = new Buffer$1(kt.toArray()), Ct = this.getPrime();
    if (Bt.length < Ct.length) {
      var qt = new Buffer$1(Ct.length - Bt.length);
      qt.fill(0), Bt = Buffer$1.concat([qt, Bt]);
    }
    return Bt;
  }, ht.prototype.getPublicKey = function(kt) {
    return _t(this._pub, kt);
  }, ht.prototype.getPrivateKey = function(kt) {
    return _t(this._priv, kt);
  }, ht.prototype.getPrime = function(Rt) {
    return _t(this.__prime, Rt);
  }, ht.prototype.getGenerator = function(Rt) {
    return _t(this._gen, Rt);
  }, ht.prototype.setGenerator = function(Rt, kt) {
    return kt = kt || "utf8", Buffer$1.isBuffer(Rt) || (Rt = new Buffer$1(Rt, kt)), this.__gen = Rt, this._gen = new B(Rt), this;
  };
  function _t(Rt, kt) {
    var Bt = new Buffer$1(Rt.toArray());
    return kt ? Bt.toString(kt) : Bt;
  }
  return dh;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4;
  hasRequiredBrowser$4 = 1;
  var B = requireGeneratePrime(), z = require$$1$1, Y = requireDh();
  function ie(ae) {
    var le = new Buffer$1(z[ae].prime, "hex"), ge = new Buffer$1(z[ae].gen, "hex");
    return new Y(le, ge);
  }
  var se = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function ne(ae, le, ge, Ee) {
    return Buffer$1.isBuffer(le) || se[le] === void 0 ? ne(ae, "binary", le, ge) : (le = le || "binary", Ee = Ee || "binary", ge = ge || new Buffer$1([2]), Buffer$1.isBuffer(ge) || (ge = new Buffer$1(ge, Ee)), typeof ae == "number" ? new Y(B(ae, ge), ge, !0) : (Buffer$1.isBuffer(ae) || (ae = new Buffer$1(ae, le)), new Y(ae, ge, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = ie, browser$4.createDiffieHellman = browser$4.DiffieHellman = ne, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: B } : processNextickArgs.exports = process$1;
  function B(z, Y, ie, se) {
    if (typeof z != "function")
      throw new TypeError('"callback" argument must be a function');
    var ne = arguments.length, ae, le;
    switch (ne) {
      case 0:
      case 1:
        return process$1.nextTick(z);
      case 2:
        return process$1.nextTick(function() {
          z.call(null, Y);
        });
      case 3:
        return process$1.nextTick(function() {
          z.call(null, Y, ie);
        });
      case 4:
        return process$1.nextTick(function() {
          z.call(null, Y, ie, se);
        });
      default:
        for (ae = new Array(ne - 1), le = 0; le < ae.length; )
          ae[le++] = arguments[le];
        return process$1.nextTick(function() {
          z.apply(null, ae);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var B = {}.toString;
  return isarray = Array.isArray || function(z) {
    return B.call(z) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(B, z) {
    var Y = require$$0$1, ie = Y.Buffer;
    function se(ae, le) {
      for (var ge in ae)
        le[ge] = ae[ge];
    }
    ie.from && ie.alloc && ie.allocUnsafe && ie.allocUnsafeSlow ? B.exports = Y : (se(Y, z), z.Buffer = ne);
    function ne(ae, le, ge) {
      return ie(ae, le, ge);
    }
    se(ie, ne), ne.from = function(ae, le, ge) {
      if (typeof ae == "number")
        throw new TypeError("Argument must not be a number");
      return ie(ae, le, ge);
    }, ne.alloc = function(ae, le, ge) {
      if (typeof ae != "number")
        throw new TypeError("Argument must be a number");
      var Ee = ie(ae);
      return le !== void 0 ? typeof ge == "string" ? Ee.fill(le, ge) : Ee.fill(le) : Ee.fill(0), Ee;
    }, ne.allocUnsafe = function(ae) {
      if (typeof ae != "number")
        throw new TypeError("Argument must be a number");
      return ie(ae);
    }, ne.allocUnsafeSlow = function(ae) {
      if (typeof ae != "number")
        throw new TypeError("Argument must be a number");
      return Y.SlowBuffer(ae);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function B(_t) {
    return Array.isArray ? Array.isArray(_t) : ht(_t) === "[object Array]";
  }
  util.isArray = B;
  function z(_t) {
    return typeof _t == "boolean";
  }
  util.isBoolean = z;
  function Y(_t) {
    return _t === null;
  }
  util.isNull = Y;
  function ie(_t) {
    return _t == null;
  }
  util.isNullOrUndefined = ie;
  function se(_t) {
    return typeof _t == "number";
  }
  util.isNumber = se;
  function ne(_t) {
    return typeof _t == "string";
  }
  util.isString = ne;
  function ae(_t) {
    return typeof _t == "symbol";
  }
  util.isSymbol = ae;
  function le(_t) {
    return _t === void 0;
  }
  util.isUndefined = le;
  function ge(_t) {
    return ht(_t) === "[object RegExp]";
  }
  util.isRegExp = ge;
  function Ee(_t) {
    return typeof _t == "object" && _t !== null;
  }
  util.isObject = Ee;
  function oe(_t) {
    return ht(_t) === "[object Date]";
  }
  util.isDate = oe;
  function Pe(_t) {
    return ht(_t) === "[object Error]" || _t instanceof Error;
  }
  util.isError = Pe;
  function Ve(_t) {
    return typeof _t == "function";
  }
  util.isFunction = Ve;
  function Ke(_t) {
    return _t === null || typeof _t == "boolean" || typeof _t == "number" || typeof _t == "string" || typeof _t == "symbol" || // ES6 symbol
    typeof _t > "u";
  }
  util.isPrimitive = Ke, util.isBuffer = require$$0$1.Buffer.isBuffer;
  function ht(_t) {
    return Object.prototype.toString.call(_t);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(B) {
    function z(ne, ae) {
      if (!(ne instanceof ae))
        throw new TypeError("Cannot call a class as a function");
    }
    var Y = requireSafeBuffer().Buffer, ie = requireUtil$1();
    function se(ne, ae, le) {
      ne.copy(ae, le);
    }
    B.exports = function() {
      function ne() {
        z(this, ne), this.head = null, this.tail = null, this.length = 0;
      }
      return ne.prototype.push = function(le) {
        var ge = { data: le, next: null };
        this.length > 0 ? this.tail.next = ge : this.head = ge, this.tail = ge, ++this.length;
      }, ne.prototype.unshift = function(le) {
        var ge = { data: le, next: this.head };
        this.length === 0 && (this.tail = ge), this.head = ge, ++this.length;
      }, ne.prototype.shift = function() {
        if (this.length !== 0) {
          var le = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, le;
        }
      }, ne.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, ne.prototype.join = function(le) {
        if (this.length === 0) return "";
        for (var ge = this.head, Ee = "" + ge.data; ge = ge.next; )
          Ee += le + ge.data;
        return Ee;
      }, ne.prototype.concat = function(le) {
        if (this.length === 0) return Y.alloc(0);
        for (var ge = Y.allocUnsafe(le >>> 0), Ee = this.head, oe = 0; Ee; )
          se(Ee.data, ge, oe), oe += Ee.data.length, Ee = Ee.next;
        return ge;
      }, ne;
    }(), ie && ie.inspect && ie.inspect.custom && (B.exports.prototype[ie.inspect.custom] = function() {
      var ne = ie.inspect({ length: this.length });
      return this.constructor.name + " " + ne;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var B = requireProcessNextickArgs();
  function z(se, ne) {
    var ae = this, le = this._readableState && this._readableState.destroyed, ge = this._writableState && this._writableState.destroyed;
    return le || ge ? (ne ? ne(se) : se && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, B.nextTick(ie, this, se)) : B.nextTick(ie, this, se)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(se || null, function(Ee) {
      !ne && Ee ? ae._writableState ? ae._writableState.errorEmitted || (ae._writableState.errorEmitted = !0, B.nextTick(ie, ae, Ee)) : B.nextTick(ie, ae, Ee) : ne && ne(Ee);
    }), this);
  }
  function Y() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function ie(se, ne) {
    se.emit("error", ne);
  }
  return destroy_1 = {
    destroy: z,
    undestroy: Y
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var B = requireProcessNextickArgs();
  _stream_writable = _t;
  function z(vt) {
    var wt = this;
    this.next = null, this.entry = null, this.finish = function() {
      Qe(wt, vt);
    };
  }
  var Y = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : B.nextTick, ie;
  _t.WritableState = Ke;
  var se = Object.create(requireUtil());
  se.inherits = requireInherits_browser();
  var ne = {
    deprecate: requireBrowser$a()
  }, ae = requireStreamBrowser(), le = requireSafeBuffer().Buffer, ge = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Ee(vt) {
    return le.from(vt);
  }
  function oe(vt) {
    return le.isBuffer(vt) || vt instanceof ge;
  }
  var Pe = requireDestroy();
  se.inherits(_t, ae);
  function Ve() {
  }
  function Ke(vt, wt) {
    ie = ie || require_stream_duplex(), vt = vt || {};
    var $t = wt instanceof ie;
    this.objectMode = !!vt.objectMode, $t && (this.objectMode = this.objectMode || !!vt.writableObjectMode);
    var xt = vt.highWaterMark, Pt = vt.writableHighWaterMark, Je = this.objectMode ? 16 : 16 * 1024;
    xt || xt === 0 ? this.highWaterMark = xt : $t && (Pt || Pt === 0) ? this.highWaterMark = Pt : this.highWaterMark = Je, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Ot = vt.decodeStrings === !1;
    this.decodeStrings = !Ot, this.defaultEncoding = vt.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(er) {
      Yt(wt, er);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new z(this);
  }
  Ke.prototype.getBuffer = function() {
    for (var wt = this.bufferedRequest, $t = []; wt; )
      $t.push(wt), wt = wt.next;
    return $t;
  }, function() {
    try {
      Object.defineProperty(Ke.prototype, "buffer", {
        get: ne.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ht;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ht = Function.prototype[Symbol.hasInstance], Object.defineProperty(_t, Symbol.hasInstance, {
    value: function(vt) {
      return ht.call(this, vt) ? !0 : this !== _t ? !1 : vt && vt._writableState instanceof Ke;
    }
  })) : ht = function(vt) {
    return vt instanceof this;
  };
  function _t(vt) {
    if (ie = ie || require_stream_duplex(), !ht.call(_t, this) && !(this instanceof ie))
      return new _t(vt);
    this._writableState = new Ke(vt, this), this.writable = !0, vt && (typeof vt.write == "function" && (this._write = vt.write), typeof vt.writev == "function" && (this._writev = vt.writev), typeof vt.destroy == "function" && (this._destroy = vt.destroy), typeof vt.final == "function" && (this._final = vt.final)), ae.call(this);
  }
  _t.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function Rt(vt, wt) {
    var $t = new Error("write after end");
    vt.emit("error", $t), B.nextTick(wt, $t);
  }
  function kt(vt, wt, $t, xt) {
    var Pt = !0, Je = !1;
    return $t === null ? Je = new TypeError("May not write null values to stream") : typeof $t != "string" && $t !== void 0 && !wt.objectMode && (Je = new TypeError("Invalid non-string/buffer chunk")), Je && (vt.emit("error", Je), B.nextTick(xt, Je), Pt = !1), Pt;
  }
  _t.prototype.write = function(vt, wt, $t) {
    var xt = this._writableState, Pt = !1, Je = !xt.objectMode && oe(vt);
    return Je && !le.isBuffer(vt) && (vt = Ee(vt)), typeof wt == "function" && ($t = wt, wt = null), Je ? wt = "buffer" : wt || (wt = xt.defaultEncoding), typeof $t != "function" && ($t = Ve), xt.ended ? Rt(this, $t) : (Je || kt(this, xt, vt, $t)) && (xt.pendingcb++, Pt = Ct(this, xt, Je, vt, wt, $t)), Pt;
  }, _t.prototype.cork = function() {
    var vt = this._writableState;
    vt.corked++;
  }, _t.prototype.uncork = function() {
    var vt = this._writableState;
    vt.corked && (vt.corked--, !vt.writing && !vt.corked && !vt.bufferProcessing && vt.bufferedRequest && Kt(this, vt));
  }, _t.prototype.setDefaultEncoding = function(wt) {
    if (typeof wt == "string" && (wt = wt.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((wt + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + wt);
    return this._writableState.defaultEncoding = wt, this;
  };
  function Bt(vt, wt, $t) {
    return !vt.objectMode && vt.decodeStrings !== !1 && typeof wt == "string" && (wt = le.from(wt, $t)), wt;
  }
  Object.defineProperty(_t.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ct(vt, wt, $t, xt, Pt, Je) {
    if (!$t) {
      var Ot = Bt(wt, xt, Pt);
      xt !== Ot && ($t = !0, Pt = "buffer", xt = Ot);
    }
    var er = wt.objectMode ? 1 : xt.length;
    wt.length += er;
    var sr = wt.length < wt.highWaterMark;
    if (sr || (wt.needDrain = !0), wt.writing || wt.corked) {
      var Jt = wt.lastBufferedRequest;
      wt.lastBufferedRequest = {
        chunk: xt,
        encoding: Pt,
        isBuf: $t,
        callback: Je,
        next: null
      }, Jt ? Jt.next = wt.lastBufferedRequest : wt.bufferedRequest = wt.lastBufferedRequest, wt.bufferedRequestCount += 1;
    } else
      qt(vt, wt, !1, er, xt, Pt, Je);
    return sr;
  }
  function qt(vt, wt, $t, xt, Pt, Je, Ot) {
    wt.writelen = xt, wt.writecb = Ot, wt.writing = !0, wt.sync = !0, $t ? vt._writev(Pt, wt.onwrite) : vt._write(Pt, Je, wt.onwrite), wt.sync = !1;
  }
  function jt(vt, wt, $t, xt, Pt) {
    --wt.pendingcb, $t ? (B.nextTick(Pt, xt), B.nextTick(ve, vt, wt), vt._writableState.errorEmitted = !0, vt.emit("error", xt)) : (Pt(xt), vt._writableState.errorEmitted = !0, vt.emit("error", xt), ve(vt, wt));
  }
  function Ht(vt) {
    vt.writing = !1, vt.writecb = null, vt.length -= vt.writelen, vt.writelen = 0;
  }
  function Yt(vt, wt) {
    var $t = vt._writableState, xt = $t.sync, Pt = $t.writecb;
    if (Ht($t), wt) jt(vt, $t, xt, wt, Pt);
    else {
      var Je = Ft($t);
      !Je && !$t.corked && !$t.bufferProcessing && $t.bufferedRequest && Kt(vt, $t), xt ? Y(Ut, vt, $t, Je, Pt) : Ut(vt, $t, Je, Pt);
    }
  }
  function Ut(vt, wt, $t, xt) {
    $t || Nt(vt, wt), wt.pendingcb--, xt(), ve(vt, wt);
  }
  function Nt(vt, wt) {
    wt.length === 0 && wt.needDrain && (wt.needDrain = !1, vt.emit("drain"));
  }
  function Kt(vt, wt) {
    wt.bufferProcessing = !0;
    var $t = wt.bufferedRequest;
    if (vt._writev && $t && $t.next) {
      var xt = wt.bufferedRequestCount, Pt = new Array(xt), Je = wt.corkedRequestsFree;
      Je.entry = $t;
      for (var Ot = 0, er = !0; $t; )
        Pt[Ot] = $t, $t.isBuf || (er = !1), $t = $t.next, Ot += 1;
      Pt.allBuffers = er, qt(vt, wt, !0, wt.length, Pt, "", Je.finish), wt.pendingcb++, wt.lastBufferedRequest = null, Je.next ? (wt.corkedRequestsFree = Je.next, Je.next = null) : wt.corkedRequestsFree = new z(wt), wt.bufferedRequestCount = 0;
    } else {
      for (; $t; ) {
        var sr = $t.chunk, Jt = $t.encoding, Wt = $t.callback, Gt = wt.objectMode ? 1 : sr.length;
        if (qt(vt, wt, !1, Gt, sr, Jt, Wt), $t = $t.next, wt.bufferedRequestCount--, wt.writing)
          break;
      }
      $t === null && (wt.lastBufferedRequest = null);
    }
    wt.bufferedRequest = $t, wt.bufferProcessing = !1;
  }
  _t.prototype._write = function(vt, wt, $t) {
    $t(new Error("_write() is not implemented"));
  }, _t.prototype._writev = null, _t.prototype.end = function(vt, wt, $t) {
    var xt = this._writableState;
    typeof vt == "function" ? ($t = vt, vt = null, wt = null) : typeof wt == "function" && ($t = wt, wt = null), vt != null && this.write(vt, wt), xt.corked && (xt.corked = 1, this.uncork()), xt.ending || Ce(this, xt, $t);
  };
  function Ft(vt) {
    return vt.ending && vt.length === 0 && vt.bufferedRequest === null && !vt.finished && !vt.writing;
  }
  function bt(vt, wt) {
    vt._final(function($t) {
      wt.pendingcb--, $t && vt.emit("error", $t), wt.prefinished = !0, vt.emit("prefinish"), ve(vt, wt);
    });
  }
  function Xe(vt, wt) {
    !wt.prefinished && !wt.finalCalled && (typeof vt._final == "function" ? (wt.pendingcb++, wt.finalCalled = !0, B.nextTick(bt, vt, wt)) : (wt.prefinished = !0, vt.emit("prefinish")));
  }
  function ve(vt, wt) {
    var $t = Ft(wt);
    return $t && (Xe(vt, wt), wt.pendingcb === 0 && (wt.finished = !0, vt.emit("finish"))), $t;
  }
  function Ce(vt, wt, $t) {
    wt.ending = !0, ve(vt, wt), $t && (wt.finished ? B.nextTick($t) : vt.once("finish", $t)), wt.ended = !0, vt.writable = !1;
  }
  function Qe(vt, wt, $t) {
    var xt = vt.entry;
    for (vt.entry = null; xt; ) {
      var Pt = xt.callback;
      wt.pendingcb--, Pt($t), xt = xt.next;
    }
    wt.corkedRequestsFree.next = vt;
  }
  return Object.defineProperty(_t.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(vt) {
      this._writableState && (this._writableState.destroyed = vt);
    }
  }), _t.prototype.destroy = Pe.destroy, _t.prototype._undestroy = Pe.undestroy, _t.prototype._destroy = function(vt, wt) {
    this.end(), wt(vt);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var B = requireProcessNextickArgs(), z = Object.keys || function(Pe) {
    var Ve = [];
    for (var Ke in Pe)
      Ve.push(Ke);
    return Ve;
  };
  _stream_duplex = ge;
  var Y = Object.create(requireUtil());
  Y.inherits = requireInherits_browser();
  var ie = require_stream_readable(), se = require_stream_writable();
  Y.inherits(ge, ie);
  for (var ne = z(se.prototype), ae = 0; ae < ne.length; ae++) {
    var le = ne[ae];
    ge.prototype[le] || (ge.prototype[le] = se.prototype[le]);
  }
  function ge(Pe) {
    if (!(this instanceof ge)) return new ge(Pe);
    ie.call(this, Pe), se.call(this, Pe), Pe && Pe.readable === !1 && (this.readable = !1), Pe && Pe.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Pe && Pe.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", Ee);
  }
  Object.defineProperty(ge.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Ee() {
    this.allowHalfOpen || this._writableState.ended || B.nextTick(oe, this);
  }
  function oe(Pe) {
    Pe.end();
  }
  return Object.defineProperty(ge.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Pe) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Pe, this._writableState.destroyed = Pe);
    }
  }), ge.prototype._destroy = function(Pe, Ve) {
    this.push(null), this.end(), B.nextTick(Ve, Pe);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var B = requireProcessNextickArgs();
  _stream_readable = Bt;
  var z = requireIsarray(), Y;
  Bt.ReadableState = kt, requireEvents().EventEmitter;
  var ie = function(Wt, Gt) {
    return Wt.listeners(Gt).length;
  }, se = requireStreamBrowser(), ne = requireSafeBuffer().Buffer, ae = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function le(Wt) {
    return ne.from(Wt);
  }
  function ge(Wt) {
    return ne.isBuffer(Wt) || Wt instanceof ae;
  }
  var Ee = Object.create(requireUtil());
  Ee.inherits = requireInherits_browser();
  var oe = requireUtil$1(), Pe = void 0;
  oe && oe.debuglog ? Pe = oe.debuglog("stream") : Pe = function() {
  };
  var Ve = requireBufferList(), Ke = requireDestroy(), ht;
  Ee.inherits(Bt, se);
  var _t = ["error", "close", "destroy", "pause", "resume"];
  function Rt(Wt, Gt, rr) {
    if (typeof Wt.prependListener == "function") return Wt.prependListener(Gt, rr);
    !Wt._events || !Wt._events[Gt] ? Wt.on(Gt, rr) : z(Wt._events[Gt]) ? Wt._events[Gt].unshift(rr) : Wt._events[Gt] = [rr, Wt._events[Gt]];
  }
  function kt(Wt, Gt) {
    Y = Y || require_stream_duplex(), Wt = Wt || {};
    var rr = Gt instanceof Y;
    this.objectMode = !!Wt.objectMode, rr && (this.objectMode = this.objectMode || !!Wt.readableObjectMode);
    var or = Wt.highWaterMark, Xt = Wt.readableHighWaterMark, zt = this.objectMode ? 16 : 16 * 1024;
    or || or === 0 ? this.highWaterMark = or : rr && (Xt || Xt === 0) ? this.highWaterMark = Xt : this.highWaterMark = zt, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Ve(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Wt.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Wt.encoding && (ht || (ht = requireString_decoder().StringDecoder), this.decoder = new ht(Wt.encoding), this.encoding = Wt.encoding);
  }
  function Bt(Wt) {
    if (Y = Y || require_stream_duplex(), !(this instanceof Bt)) return new Bt(Wt);
    this._readableState = new kt(Wt, this), this.readable = !0, Wt && (typeof Wt.read == "function" && (this._read = Wt.read), typeof Wt.destroy == "function" && (this._destroy = Wt.destroy)), se.call(this);
  }
  Object.defineProperty(Bt.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Wt) {
      this._readableState && (this._readableState.destroyed = Wt);
    }
  }), Bt.prototype.destroy = Ke.destroy, Bt.prototype._undestroy = Ke.undestroy, Bt.prototype._destroy = function(Wt, Gt) {
    this.push(null), Gt(Wt);
  }, Bt.prototype.push = function(Wt, Gt) {
    var rr = this._readableState, or;
    return rr.objectMode ? or = !0 : typeof Wt == "string" && (Gt = Gt || rr.defaultEncoding, Gt !== rr.encoding && (Wt = ne.from(Wt, Gt), Gt = ""), or = !0), Ct(this, Wt, Gt, !1, or);
  }, Bt.prototype.unshift = function(Wt) {
    return Ct(this, Wt, null, !0, !1);
  };
  function Ct(Wt, Gt, rr, or, Xt) {
    var zt = Wt._readableState;
    if (Gt === null)
      zt.reading = !1, Kt(Wt, zt);
    else {
      var ur;
      Xt || (ur = jt(zt, Gt)), ur ? Wt.emit("error", ur) : zt.objectMode || Gt && Gt.length > 0 ? (typeof Gt != "string" && !zt.objectMode && Object.getPrototypeOf(Gt) !== ne.prototype && (Gt = le(Gt)), or ? zt.endEmitted ? Wt.emit("error", new Error("stream.unshift() after end event")) : qt(Wt, zt, Gt, !0) : zt.ended ? Wt.emit("error", new Error("stream.push() after EOF")) : (zt.reading = !1, zt.decoder && !rr ? (Gt = zt.decoder.write(Gt), zt.objectMode || Gt.length !== 0 ? qt(Wt, zt, Gt, !1) : Xe(Wt, zt)) : qt(Wt, zt, Gt, !1))) : or || (zt.reading = !1);
    }
    return Ht(zt);
  }
  function qt(Wt, Gt, rr, or) {
    Gt.flowing && Gt.length === 0 && !Gt.sync ? (Wt.emit("data", rr), Wt.read(0)) : (Gt.length += Gt.objectMode ? 1 : rr.length, or ? Gt.buffer.unshift(rr) : Gt.buffer.push(rr), Gt.needReadable && Ft(Wt)), Xe(Wt, Gt);
  }
  function jt(Wt, Gt) {
    var rr;
    return !ge(Gt) && typeof Gt != "string" && Gt !== void 0 && !Wt.objectMode && (rr = new TypeError("Invalid non-string/buffer chunk")), rr;
  }
  function Ht(Wt) {
    return !Wt.ended && (Wt.needReadable || Wt.length < Wt.highWaterMark || Wt.length === 0);
  }
  Bt.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Bt.prototype.setEncoding = function(Wt) {
    return ht || (ht = requireString_decoder().StringDecoder), this._readableState.decoder = new ht(Wt), this._readableState.encoding = Wt, this;
  };
  var Yt = 8388608;
  function Ut(Wt) {
    return Wt >= Yt ? Wt = Yt : (Wt--, Wt |= Wt >>> 1, Wt |= Wt >>> 2, Wt |= Wt >>> 4, Wt |= Wt >>> 8, Wt |= Wt >>> 16, Wt++), Wt;
  }
  function Nt(Wt, Gt) {
    return Wt <= 0 || Gt.length === 0 && Gt.ended ? 0 : Gt.objectMode ? 1 : Wt !== Wt ? Gt.flowing && Gt.length ? Gt.buffer.head.data.length : Gt.length : (Wt > Gt.highWaterMark && (Gt.highWaterMark = Ut(Wt)), Wt <= Gt.length ? Wt : Gt.ended ? Gt.length : (Gt.needReadable = !0, 0));
  }
  Bt.prototype.read = function(Wt) {
    Pe("read", Wt), Wt = parseInt(Wt, 10);
    var Gt = this._readableState, rr = Wt;
    if (Wt !== 0 && (Gt.emittedReadable = !1), Wt === 0 && Gt.needReadable && (Gt.length >= Gt.highWaterMark || Gt.ended))
      return Pe("read: emitReadable", Gt.length, Gt.ended), Gt.length === 0 && Gt.ended ? er(this) : Ft(this), null;
    if (Wt = Nt(Wt, Gt), Wt === 0 && Gt.ended)
      return Gt.length === 0 && er(this), null;
    var or = Gt.needReadable;
    Pe("need readable", or), (Gt.length === 0 || Gt.length - Wt < Gt.highWaterMark) && (or = !0, Pe("length less than watermark", or)), Gt.ended || Gt.reading ? (or = !1, Pe("reading or ended", or)) : or && (Pe("do read"), Gt.reading = !0, Gt.sync = !0, Gt.length === 0 && (Gt.needReadable = !0), this._read(Gt.highWaterMark), Gt.sync = !1, Gt.reading || (Wt = Nt(rr, Gt)));
    var Xt;
    return Wt > 0 ? Xt = xt(Wt, Gt) : Xt = null, Xt === null ? (Gt.needReadable = !0, Wt = 0) : Gt.length -= Wt, Gt.length === 0 && (Gt.ended || (Gt.needReadable = !0), rr !== Wt && Gt.ended && er(this)), Xt !== null && this.emit("data", Xt), Xt;
  };
  function Kt(Wt, Gt) {
    if (!Gt.ended) {
      if (Gt.decoder) {
        var rr = Gt.decoder.end();
        rr && rr.length && (Gt.buffer.push(rr), Gt.length += Gt.objectMode ? 1 : rr.length);
      }
      Gt.ended = !0, Ft(Wt);
    }
  }
  function Ft(Wt) {
    var Gt = Wt._readableState;
    Gt.needReadable = !1, Gt.emittedReadable || (Pe("emitReadable", Gt.flowing), Gt.emittedReadable = !0, Gt.sync ? B.nextTick(bt, Wt) : bt(Wt));
  }
  function bt(Wt) {
    Pe("emit readable"), Wt.emit("readable"), $t(Wt);
  }
  function Xe(Wt, Gt) {
    Gt.readingMore || (Gt.readingMore = !0, B.nextTick(ve, Wt, Gt));
  }
  function ve(Wt, Gt) {
    for (var rr = Gt.length; !Gt.reading && !Gt.flowing && !Gt.ended && Gt.length < Gt.highWaterMark && (Pe("maybeReadMore read 0"), Wt.read(0), rr !== Gt.length); )
      rr = Gt.length;
    Gt.readingMore = !1;
  }
  Bt.prototype._read = function(Wt) {
    this.emit("error", new Error("_read() is not implemented"));
  }, Bt.prototype.pipe = function(Wt, Gt) {
    var rr = this, or = this._readableState;
    switch (or.pipesCount) {
      case 0:
        or.pipes = Wt;
        break;
      case 1:
        or.pipes = [or.pipes, Wt];
        break;
      default:
        or.pipes.push(Wt);
        break;
    }
    or.pipesCount += 1, Pe("pipe count=%d opts=%j", or.pipesCount, Gt);
    var Xt = (!Gt || Gt.end !== !1) && Wt !== process$1.stdout && Wt !== process$1.stderr, zt = Xt ? hr : Lr;
    or.endEmitted ? B.nextTick(zt) : rr.once("end", zt), Wt.on("unpipe", ur);
    function ur(Rr, Vr) {
      Pe("onunpipe"), Rr === rr && Vr && Vr.hasUnpiped === !1 && (Vr.hasUnpiped = !0, $r());
    }
    function hr() {
      Pe("onend"), Wt.end();
    }
    var yr = Ce(rr);
    Wt.on("drain", yr);
    var Sr = !1;
    function $r() {
      Pe("cleanup"), Wt.removeListener("close", Ar), Wt.removeListener("finish", Gr), Wt.removeListener("drain", yr), Wt.removeListener("error", Fr), Wt.removeListener("unpipe", ur), rr.removeListener("end", hr), rr.removeListener("end", Lr), rr.removeListener("data", pr), Sr = !0, or.awaitDrain && (!Wt._writableState || Wt._writableState.needDrain) && yr();
    }
    var Mr = !1;
    rr.on("data", pr);
    function pr(Rr) {
      Pe("ondata"), Mr = !1;
      var Vr = Wt.write(Rr);
      Vr === !1 && !Mr && ((or.pipesCount === 1 && or.pipes === Wt || or.pipesCount > 1 && Jt(or.pipes, Wt) !== -1) && !Sr && (Pe("false write response, pause", or.awaitDrain), or.awaitDrain++, Mr = !0), rr.pause());
    }
    function Fr(Rr) {
      Pe("onerror", Rr), Lr(), Wt.removeListener("error", Fr), ie(Wt, "error") === 0 && Wt.emit("error", Rr);
    }
    Rt(Wt, "error", Fr);
    function Ar() {
      Wt.removeListener("finish", Gr), Lr();
    }
    Wt.once("close", Ar);
    function Gr() {
      Pe("onfinish"), Wt.removeListener("close", Ar), Lr();
    }
    Wt.once("finish", Gr);
    function Lr() {
      Pe("unpipe"), rr.unpipe(Wt);
    }
    return Wt.emit("pipe", rr), or.flowing || (Pe("pipe resume"), rr.resume()), Wt;
  };
  function Ce(Wt) {
    return function() {
      var Gt = Wt._readableState;
      Pe("pipeOnDrain", Gt.awaitDrain), Gt.awaitDrain && Gt.awaitDrain--, Gt.awaitDrain === 0 && ie(Wt, "data") && (Gt.flowing = !0, $t(Wt));
    };
  }
  Bt.prototype.unpipe = function(Wt) {
    var Gt = this._readableState, rr = { hasUnpiped: !1 };
    if (Gt.pipesCount === 0) return this;
    if (Gt.pipesCount === 1)
      return Wt && Wt !== Gt.pipes ? this : (Wt || (Wt = Gt.pipes), Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1, Wt && Wt.emit("unpipe", this, rr), this);
    if (!Wt) {
      var or = Gt.pipes, Xt = Gt.pipesCount;
      Gt.pipes = null, Gt.pipesCount = 0, Gt.flowing = !1;
      for (var zt = 0; zt < Xt; zt++)
        or[zt].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var ur = Jt(Gt.pipes, Wt);
    return ur === -1 ? this : (Gt.pipes.splice(ur, 1), Gt.pipesCount -= 1, Gt.pipesCount === 1 && (Gt.pipes = Gt.pipes[0]), Wt.emit("unpipe", this, rr), this);
  }, Bt.prototype.on = function(Wt, Gt) {
    var rr = se.prototype.on.call(this, Wt, Gt);
    if (Wt === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Wt === "readable") {
      var or = this._readableState;
      !or.endEmitted && !or.readableListening && (or.readableListening = or.needReadable = !0, or.emittedReadable = !1, or.reading ? or.length && Ft(this) : B.nextTick(Qe, this));
    }
    return rr;
  }, Bt.prototype.addListener = Bt.prototype.on;
  function Qe(Wt) {
    Pe("readable nexttick read 0"), Wt.read(0);
  }
  Bt.prototype.resume = function() {
    var Wt = this._readableState;
    return Wt.flowing || (Pe("resume"), Wt.flowing = !0, vt(this, Wt)), this;
  };
  function vt(Wt, Gt) {
    Gt.resumeScheduled || (Gt.resumeScheduled = !0, B.nextTick(wt, Wt, Gt));
  }
  function wt(Wt, Gt) {
    Gt.reading || (Pe("resume read 0"), Wt.read(0)), Gt.resumeScheduled = !1, Gt.awaitDrain = 0, Wt.emit("resume"), $t(Wt), Gt.flowing && !Gt.reading && Wt.read(0);
  }
  Bt.prototype.pause = function() {
    return Pe("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Pe("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function $t(Wt) {
    var Gt = Wt._readableState;
    for (Pe("flow", Gt.flowing); Gt.flowing && Wt.read() !== null; )
      ;
  }
  Bt.prototype.wrap = function(Wt) {
    var Gt = this, rr = this._readableState, or = !1;
    Wt.on("end", function() {
      if (Pe("wrapped end"), rr.decoder && !rr.ended) {
        var ur = rr.decoder.end();
        ur && ur.length && Gt.push(ur);
      }
      Gt.push(null);
    }), Wt.on("data", function(ur) {
      if (Pe("wrapped data"), rr.decoder && (ur = rr.decoder.write(ur)), !(rr.objectMode && ur == null) && !(!rr.objectMode && (!ur || !ur.length))) {
        var hr = Gt.push(ur);
        hr || (or = !0, Wt.pause());
      }
    });
    for (var Xt in Wt)
      this[Xt] === void 0 && typeof Wt[Xt] == "function" && (this[Xt] = /* @__PURE__ */ function(ur) {
        return function() {
          return Wt[ur].apply(Wt, arguments);
        };
      }(Xt));
    for (var zt = 0; zt < _t.length; zt++)
      Wt.on(_t[zt], this.emit.bind(this, _t[zt]));
    return this._read = function(ur) {
      Pe("wrapped _read", ur), or && (or = !1, Wt.resume());
    }, this;
  }, Object.defineProperty(Bt.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Bt._fromList = xt;
  function xt(Wt, Gt) {
    if (Gt.length === 0) return null;
    var rr;
    return Gt.objectMode ? rr = Gt.buffer.shift() : !Wt || Wt >= Gt.length ? (Gt.decoder ? rr = Gt.buffer.join("") : Gt.buffer.length === 1 ? rr = Gt.buffer.head.data : rr = Gt.buffer.concat(Gt.length), Gt.buffer.clear()) : rr = Pt(Wt, Gt.buffer, Gt.decoder), rr;
  }
  function Pt(Wt, Gt, rr) {
    var or;
    return Wt < Gt.head.data.length ? (or = Gt.head.data.slice(0, Wt), Gt.head.data = Gt.head.data.slice(Wt)) : Wt === Gt.head.data.length ? or = Gt.shift() : or = rr ? Je(Wt, Gt) : Ot(Wt, Gt), or;
  }
  function Je(Wt, Gt) {
    var rr = Gt.head, or = 1, Xt = rr.data;
    for (Wt -= Xt.length; rr = rr.next; ) {
      var zt = rr.data, ur = Wt > zt.length ? zt.length : Wt;
      if (ur === zt.length ? Xt += zt : Xt += zt.slice(0, Wt), Wt -= ur, Wt === 0) {
        ur === zt.length ? (++or, rr.next ? Gt.head = rr.next : Gt.head = Gt.tail = null) : (Gt.head = rr, rr.data = zt.slice(ur));
        break;
      }
      ++or;
    }
    return Gt.length -= or, Xt;
  }
  function Ot(Wt, Gt) {
    var rr = ne.allocUnsafe(Wt), or = Gt.head, Xt = 1;
    for (or.data.copy(rr), Wt -= or.data.length; or = or.next; ) {
      var zt = or.data, ur = Wt > zt.length ? zt.length : Wt;
      if (zt.copy(rr, rr.length - Wt, 0, ur), Wt -= ur, Wt === 0) {
        ur === zt.length ? (++Xt, or.next ? Gt.head = or.next : Gt.head = Gt.tail = null) : (Gt.head = or, or.data = zt.slice(ur));
        break;
      }
      ++Xt;
    }
    return Gt.length -= Xt, rr;
  }
  function er(Wt) {
    var Gt = Wt._readableState;
    if (Gt.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    Gt.endEmitted || (Gt.ended = !0, B.nextTick(sr, Gt, Wt));
  }
  function sr(Wt, Gt) {
    !Wt.endEmitted && Wt.length === 0 && (Wt.endEmitted = !0, Gt.readable = !1, Gt.emit("end"));
  }
  function Jt(Wt, Gt) {
    for (var rr = 0, or = Wt.length; rr < or; rr++)
      if (Wt[rr] === Gt) return rr;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = ie;
  var B = require_stream_duplex(), z = Object.create(requireUtil());
  z.inherits = requireInherits_browser(), z.inherits(ie, B);
  function Y(ae, le) {
    var ge = this._transformState;
    ge.transforming = !1;
    var Ee = ge.writecb;
    if (!Ee)
      return this.emit("error", new Error("write callback called multiple times"));
    ge.writechunk = null, ge.writecb = null, le != null && this.push(le), Ee(ae);
    var oe = this._readableState;
    oe.reading = !1, (oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
  }
  function ie(ae) {
    if (!(this instanceof ie)) return new ie(ae);
    B.call(this, ae), this._transformState = {
      afterTransform: Y.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, ae && (typeof ae.transform == "function" && (this._transform = ae.transform), typeof ae.flush == "function" && (this._flush = ae.flush)), this.on("prefinish", se);
  }
  function se() {
    var ae = this;
    typeof this._flush == "function" ? this._flush(function(le, ge) {
      ne(ae, le, ge);
    }) : ne(this, null, null);
  }
  ie.prototype.push = function(ae, le) {
    return this._transformState.needTransform = !1, B.prototype.push.call(this, ae, le);
  }, ie.prototype._transform = function(ae, le, ge) {
    throw new Error("_transform() is not implemented");
  }, ie.prototype._write = function(ae, le, ge) {
    var Ee = this._transformState;
    if (Ee.writecb = ge, Ee.writechunk = ae, Ee.writeencoding = le, !Ee.transforming) {
      var oe = this._readableState;
      (Ee.needTransform || oe.needReadable || oe.length < oe.highWaterMark) && this._read(oe.highWaterMark);
    }
  }, ie.prototype._read = function(ae) {
    var le = this._transformState;
    le.writechunk !== null && le.writecb && !le.transforming ? (le.transforming = !0, this._transform(le.writechunk, le.writeencoding, le.afterTransform)) : le.needTransform = !0;
  }, ie.prototype._destroy = function(ae, le) {
    var ge = this;
    B.prototype._destroy.call(this, ae, function(Ee) {
      le(Ee), ge.emit("close");
    });
  };
  function ne(ae, le, ge) {
    if (le) return ae.emit("error", le);
    if (ge != null && ae.push(ge), ae._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (ae._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return ae.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = Y;
  var B = require_stream_transform(), z = Object.create(requireUtil());
  z.inherits = requireInherits_browser(), z.inherits(Y, B);
  function Y(ie) {
    if (!(this instanceof Y)) return new Y(ie);
    B.call(this, ie);
  }
  return Y.prototype._transform = function(ie, se, ne) {
    ne(null, ie);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(B, z) {
    z = B.exports = require_stream_readable(), z.Stream = z, z.Readable = z, z.Writable = require_stream_writable(), z.Duplex = require_stream_duplex(), z.Transform = require_stream_transform(), z.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn$1 = { exports: {} };
bn$1.exports;
var hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(B) {
    (function(z, Y) {
      function ie(Xe, ve) {
        if (!Xe) throw new Error(ve || "Assertion failed");
      }
      function se(Xe, ve) {
        Xe.super_ = ve;
        var Ce = function() {
        };
        Ce.prototype = ve.prototype, Xe.prototype = new Ce(), Xe.prototype.constructor = Xe;
      }
      function ne(Xe, ve, Ce) {
        if (ne.isBN(Xe))
          return Xe;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Xe !== null && ((ve === "le" || ve === "be") && (Ce = ve, ve = 10), this._init(Xe || 0, ve || 10, Ce || "be"));
      }
      typeof z == "object" ? z.exports = ne : Y.BN = ne, ne.BN = ne, ne.wordSize = 26;
      var ae;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? ae = window.Buffer : ae = require$$0$1.Buffer;
      } catch {
      }
      ne.isBN = function(ve) {
        return ve instanceof ne ? !0 : ve !== null && typeof ve == "object" && ve.constructor.wordSize === ne.wordSize && Array.isArray(ve.words);
      }, ne.max = function(ve, Ce) {
        return ve.cmp(Ce) > 0 ? ve : Ce;
      }, ne.min = function(ve, Ce) {
        return ve.cmp(Ce) < 0 ? ve : Ce;
      }, ne.prototype._init = function(ve, Ce, Qe) {
        if (typeof ve == "number")
          return this._initNumber(ve, Ce, Qe);
        if (typeof ve == "object")
          return this._initArray(ve, Ce, Qe);
        Ce === "hex" && (Ce = 16), ie(Ce === (Ce | 0) && Ce >= 2 && Ce <= 36), ve = ve.toString().replace(/\s+/g, "");
        var vt = 0;
        ve[0] === "-" && (vt++, this.negative = 1), vt < ve.length && (Ce === 16 ? this._parseHex(ve, vt, Qe) : (this._parseBase(ve, Ce, vt), Qe === "le" && this._initArray(this.toArray(), Ce, Qe)));
      }, ne.prototype._initNumber = function(ve, Ce, Qe) {
        ve < 0 && (this.negative = 1, ve = -ve), ve < 67108864 ? (this.words = [ve & 67108863], this.length = 1) : ve < 4503599627370496 ? (this.words = [
          ve & 67108863,
          ve / 67108864 & 67108863
        ], this.length = 2) : (ie(ve < 9007199254740992), this.words = [
          ve & 67108863,
          ve / 67108864 & 67108863,
          1
        ], this.length = 3), Qe === "le" && this._initArray(this.toArray(), Ce, Qe);
      }, ne.prototype._initArray = function(ve, Ce, Qe) {
        if (ie(typeof ve.length == "number"), ve.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(ve.length / 3), this.words = new Array(this.length);
        for (var vt = 0; vt < this.length; vt++)
          this.words[vt] = 0;
        var wt, $t, xt = 0;
        if (Qe === "be")
          for (vt = ve.length - 1, wt = 0; vt >= 0; vt -= 3)
            $t = ve[vt] | ve[vt - 1] << 8 | ve[vt - 2] << 16, this.words[wt] |= $t << xt & 67108863, this.words[wt + 1] = $t >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, wt++);
        else if (Qe === "le")
          for (vt = 0, wt = 0; vt < ve.length; vt += 3)
            $t = ve[vt] | ve[vt + 1] << 8 | ve[vt + 2] << 16, this.words[wt] |= $t << xt & 67108863, this.words[wt + 1] = $t >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, wt++);
        return this._strip();
      };
      function le(Xe, ve) {
        var Ce = Xe.charCodeAt(ve);
        if (Ce >= 48 && Ce <= 57)
          return Ce - 48;
        if (Ce >= 65 && Ce <= 70)
          return Ce - 55;
        if (Ce >= 97 && Ce <= 102)
          return Ce - 87;
        ie(!1, "Invalid character in " + Xe);
      }
      function ge(Xe, ve, Ce) {
        var Qe = le(Xe, Ce);
        return Ce - 1 >= ve && (Qe |= le(Xe, Ce - 1) << 4), Qe;
      }
      ne.prototype._parseHex = function(ve, Ce, Qe) {
        this.length = Math.ceil((ve.length - Ce) / 6), this.words = new Array(this.length);
        for (var vt = 0; vt < this.length; vt++)
          this.words[vt] = 0;
        var wt = 0, $t = 0, xt;
        if (Qe === "be")
          for (vt = ve.length - 1; vt >= Ce; vt -= 2)
            xt = ge(ve, Ce, vt) << wt, this.words[$t] |= xt & 67108863, wt >= 18 ? (wt -= 18, $t += 1, this.words[$t] |= xt >>> 26) : wt += 8;
        else {
          var Pt = ve.length - Ce;
          for (vt = Pt % 2 === 0 ? Ce + 1 : Ce; vt < ve.length; vt += 2)
            xt = ge(ve, Ce, vt) << wt, this.words[$t] |= xt & 67108863, wt >= 18 ? (wt -= 18, $t += 1, this.words[$t] |= xt >>> 26) : wt += 8;
        }
        this._strip();
      };
      function Ee(Xe, ve, Ce, Qe) {
        for (var vt = 0, wt = 0, $t = Math.min(Xe.length, Ce), xt = ve; xt < $t; xt++) {
          var Pt = Xe.charCodeAt(xt) - 48;
          vt *= Qe, Pt >= 49 ? wt = Pt - 49 + 10 : Pt >= 17 ? wt = Pt - 17 + 10 : wt = Pt, ie(Pt >= 0 && wt < Qe, "Invalid character"), vt += wt;
        }
        return vt;
      }
      ne.prototype._parseBase = function(ve, Ce, Qe) {
        this.words = [0], this.length = 1;
        for (var vt = 0, wt = 1; wt <= 67108863; wt *= Ce)
          vt++;
        vt--, wt = wt / Ce | 0;
        for (var $t = ve.length - Qe, xt = $t % vt, Pt = Math.min($t, $t - xt) + Qe, Je = 0, Ot = Qe; Ot < Pt; Ot += vt)
          Je = Ee(ve, Ot, Ot + vt, Ce), this.imuln(wt), this.words[0] + Je < 67108864 ? this.words[0] += Je : this._iaddn(Je);
        if (xt !== 0) {
          var er = 1;
          for (Je = Ee(ve, Ot, ve.length, Ce), Ot = 0; Ot < xt; Ot++)
            er *= Ce;
          this.imuln(er), this.words[0] + Je < 67108864 ? this.words[0] += Je : this._iaddn(Je);
        }
        this._strip();
      }, ne.prototype.copy = function(ve) {
        ve.words = new Array(this.length);
        for (var Ce = 0; Ce < this.length; Ce++)
          ve.words[Ce] = this.words[Ce];
        ve.length = this.length, ve.negative = this.negative, ve.red = this.red;
      };
      function oe(Xe, ve) {
        Xe.words = ve.words, Xe.length = ve.length, Xe.negative = ve.negative, Xe.red = ve.red;
      }
      if (ne.prototype._move = function(ve) {
        oe(ve, this);
      }, ne.prototype.clone = function() {
        var ve = new ne(null);
        return this.copy(ve), ve;
      }, ne.prototype._expand = function(ve) {
        for (; this.length < ve; )
          this.words[this.length++] = 0;
        return this;
      }, ne.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ne.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          ne.prototype[Symbol.for("nodejs.util.inspect.custom")] = Pe;
        } catch {
          ne.prototype.inspect = Pe;
        }
      else
        ne.prototype.inspect = Pe;
      function Pe() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Ve = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ke = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ht = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ne.prototype.toString = function(ve, Ce) {
        ve = ve || 10, Ce = Ce | 0 || 1;
        var Qe;
        if (ve === 16 || ve === "hex") {
          Qe = "";
          for (var vt = 0, wt = 0, $t = 0; $t < this.length; $t++) {
            var xt = this.words[$t], Pt = ((xt << vt | wt) & 16777215).toString(16);
            wt = xt >>> 24 - vt & 16777215, vt += 2, vt >= 26 && (vt -= 26, $t--), wt !== 0 || $t !== this.length - 1 ? Qe = Ve[6 - Pt.length] + Pt + Qe : Qe = Pt + Qe;
          }
          for (wt !== 0 && (Qe = wt.toString(16) + Qe); Qe.length % Ce !== 0; )
            Qe = "0" + Qe;
          return this.negative !== 0 && (Qe = "-" + Qe), Qe;
        }
        if (ve === (ve | 0) && ve >= 2 && ve <= 36) {
          var Je = Ke[ve], Ot = ht[ve];
          Qe = "";
          var er = this.clone();
          for (er.negative = 0; !er.isZero(); ) {
            var sr = er.modrn(Ot).toString(ve);
            er = er.idivn(Ot), er.isZero() ? Qe = sr + Qe : Qe = Ve[Je - sr.length] + sr + Qe;
          }
          for (this.isZero() && (Qe = "0" + Qe); Qe.length % Ce !== 0; )
            Qe = "0" + Qe;
          return this.negative !== 0 && (Qe = "-" + Qe), Qe;
        }
        ie(!1, "Base should be between 2 and 36");
      }, ne.prototype.toNumber = function() {
        var ve = this.words[0];
        return this.length === 2 ? ve += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ve += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ie(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ve : ve;
      }, ne.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, ae && (ne.prototype.toBuffer = function(ve, Ce) {
        return this.toArrayLike(ae, ve, Ce);
      }), ne.prototype.toArray = function(ve, Ce) {
        return this.toArrayLike(Array, ve, Ce);
      };
      var _t = function(ve, Ce) {
        return ve.allocUnsafe ? ve.allocUnsafe(Ce) : new ve(Ce);
      };
      ne.prototype.toArrayLike = function(ve, Ce, Qe) {
        this._strip();
        var vt = this.byteLength(), wt = Qe || Math.max(1, vt);
        ie(vt <= wt, "byte array longer than desired length"), ie(wt > 0, "Requested array length <= 0");
        var $t = _t(ve, wt), xt = Ce === "le" ? "LE" : "BE";
        return this["_toArrayLike" + xt]($t, vt), $t;
      }, ne.prototype._toArrayLikeLE = function(ve, Ce) {
        for (var Qe = 0, vt = 0, wt = 0, $t = 0; wt < this.length; wt++) {
          var xt = this.words[wt] << $t | vt;
          ve[Qe++] = xt & 255, Qe < ve.length && (ve[Qe++] = xt >> 8 & 255), Qe < ve.length && (ve[Qe++] = xt >> 16 & 255), $t === 6 ? (Qe < ve.length && (ve[Qe++] = xt >> 24 & 255), vt = 0, $t = 0) : (vt = xt >>> 24, $t += 2);
        }
        if (Qe < ve.length)
          for (ve[Qe++] = vt; Qe < ve.length; )
            ve[Qe++] = 0;
      }, ne.prototype._toArrayLikeBE = function(ve, Ce) {
        for (var Qe = ve.length - 1, vt = 0, wt = 0, $t = 0; wt < this.length; wt++) {
          var xt = this.words[wt] << $t | vt;
          ve[Qe--] = xt & 255, Qe >= 0 && (ve[Qe--] = xt >> 8 & 255), Qe >= 0 && (ve[Qe--] = xt >> 16 & 255), $t === 6 ? (Qe >= 0 && (ve[Qe--] = xt >> 24 & 255), vt = 0, $t = 0) : (vt = xt >>> 24, $t += 2);
        }
        if (Qe >= 0)
          for (ve[Qe--] = vt; Qe >= 0; )
            ve[Qe--] = 0;
      }, Math.clz32 ? ne.prototype._countBits = function(ve) {
        return 32 - Math.clz32(ve);
      } : ne.prototype._countBits = function(ve) {
        var Ce = ve, Qe = 0;
        return Ce >= 4096 && (Qe += 13, Ce >>>= 13), Ce >= 64 && (Qe += 7, Ce >>>= 7), Ce >= 8 && (Qe += 4, Ce >>>= 4), Ce >= 2 && (Qe += 2, Ce >>>= 2), Qe + Ce;
      }, ne.prototype._zeroBits = function(ve) {
        if (ve === 0) return 26;
        var Ce = ve, Qe = 0;
        return Ce & 8191 || (Qe += 13, Ce >>>= 13), Ce & 127 || (Qe += 7, Ce >>>= 7), Ce & 15 || (Qe += 4, Ce >>>= 4), Ce & 3 || (Qe += 2, Ce >>>= 2), Ce & 1 || Qe++, Qe;
      }, ne.prototype.bitLength = function() {
        var ve = this.words[this.length - 1], Ce = this._countBits(ve);
        return (this.length - 1) * 26 + Ce;
      };
      function Rt(Xe) {
        for (var ve = new Array(Xe.bitLength()), Ce = 0; Ce < ve.length; Ce++) {
          var Qe = Ce / 26 | 0, vt = Ce % 26;
          ve[Ce] = Xe.words[Qe] >>> vt & 1;
        }
        return ve;
      }
      ne.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var ve = 0, Ce = 0; Ce < this.length; Ce++) {
          var Qe = this._zeroBits(this.words[Ce]);
          if (ve += Qe, Qe !== 26) break;
        }
        return ve;
      }, ne.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ne.prototype.toTwos = function(ve) {
        return this.negative !== 0 ? this.abs().inotn(ve).iaddn(1) : this.clone();
      }, ne.prototype.fromTwos = function(ve) {
        return this.testn(ve - 1) ? this.notn(ve).iaddn(1).ineg() : this.clone();
      }, ne.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ne.prototype.neg = function() {
        return this.clone().ineg();
      }, ne.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ne.prototype.iuor = function(ve) {
        for (; this.length < ve.length; )
          this.words[this.length++] = 0;
        for (var Ce = 0; Ce < ve.length; Ce++)
          this.words[Ce] = this.words[Ce] | ve.words[Ce];
        return this._strip();
      }, ne.prototype.ior = function(ve) {
        return ie((this.negative | ve.negative) === 0), this.iuor(ve);
      }, ne.prototype.or = function(ve) {
        return this.length > ve.length ? this.clone().ior(ve) : ve.clone().ior(this);
      }, ne.prototype.uor = function(ve) {
        return this.length > ve.length ? this.clone().iuor(ve) : ve.clone().iuor(this);
      }, ne.prototype.iuand = function(ve) {
        var Ce;
        this.length > ve.length ? Ce = ve : Ce = this;
        for (var Qe = 0; Qe < Ce.length; Qe++)
          this.words[Qe] = this.words[Qe] & ve.words[Qe];
        return this.length = Ce.length, this._strip();
      }, ne.prototype.iand = function(ve) {
        return ie((this.negative | ve.negative) === 0), this.iuand(ve);
      }, ne.prototype.and = function(ve) {
        return this.length > ve.length ? this.clone().iand(ve) : ve.clone().iand(this);
      }, ne.prototype.uand = function(ve) {
        return this.length > ve.length ? this.clone().iuand(ve) : ve.clone().iuand(this);
      }, ne.prototype.iuxor = function(ve) {
        var Ce, Qe;
        this.length > ve.length ? (Ce = this, Qe = ve) : (Ce = ve, Qe = this);
        for (var vt = 0; vt < Qe.length; vt++)
          this.words[vt] = Ce.words[vt] ^ Qe.words[vt];
        if (this !== Ce)
          for (; vt < Ce.length; vt++)
            this.words[vt] = Ce.words[vt];
        return this.length = Ce.length, this._strip();
      }, ne.prototype.ixor = function(ve) {
        return ie((this.negative | ve.negative) === 0), this.iuxor(ve);
      }, ne.prototype.xor = function(ve) {
        return this.length > ve.length ? this.clone().ixor(ve) : ve.clone().ixor(this);
      }, ne.prototype.uxor = function(ve) {
        return this.length > ve.length ? this.clone().iuxor(ve) : ve.clone().iuxor(this);
      }, ne.prototype.inotn = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = Math.ceil(ve / 26) | 0, Qe = ve % 26;
        this._expand(Ce), Qe > 0 && Ce--;
        for (var vt = 0; vt < Ce; vt++)
          this.words[vt] = ~this.words[vt] & 67108863;
        return Qe > 0 && (this.words[vt] = ~this.words[vt] & 67108863 >> 26 - Qe), this._strip();
      }, ne.prototype.notn = function(ve) {
        return this.clone().inotn(ve);
      }, ne.prototype.setn = function(ve, Ce) {
        ie(typeof ve == "number" && ve >= 0);
        var Qe = ve / 26 | 0, vt = ve % 26;
        return this._expand(Qe + 1), Ce ? this.words[Qe] = this.words[Qe] | 1 << vt : this.words[Qe] = this.words[Qe] & ~(1 << vt), this._strip();
      }, ne.prototype.iadd = function(ve) {
        var Ce;
        if (this.negative !== 0 && ve.negative === 0)
          return this.negative = 0, Ce = this.isub(ve), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && ve.negative !== 0)
          return ve.negative = 0, Ce = this.isub(ve), ve.negative = 1, Ce._normSign();
        var Qe, vt;
        this.length > ve.length ? (Qe = this, vt = ve) : (Qe = ve, vt = this);
        for (var wt = 0, $t = 0; $t < vt.length; $t++)
          Ce = (Qe.words[$t] | 0) + (vt.words[$t] | 0) + wt, this.words[$t] = Ce & 67108863, wt = Ce >>> 26;
        for (; wt !== 0 && $t < Qe.length; $t++)
          Ce = (Qe.words[$t] | 0) + wt, this.words[$t] = Ce & 67108863, wt = Ce >>> 26;
        if (this.length = Qe.length, wt !== 0)
          this.words[this.length] = wt, this.length++;
        else if (Qe !== this)
          for (; $t < Qe.length; $t++)
            this.words[$t] = Qe.words[$t];
        return this;
      }, ne.prototype.add = function(ve) {
        var Ce;
        return ve.negative !== 0 && this.negative === 0 ? (ve.negative = 0, Ce = this.sub(ve), ve.negative ^= 1, Ce) : ve.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ce = ve.sub(this), this.negative = 1, Ce) : this.length > ve.length ? this.clone().iadd(ve) : ve.clone().iadd(this);
      }, ne.prototype.isub = function(ve) {
        if (ve.negative !== 0) {
          ve.negative = 0;
          var Ce = this.iadd(ve);
          return ve.negative = 1, Ce._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(ve), this.negative = 1, this._normSign();
        var Qe = this.cmp(ve);
        if (Qe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var vt, wt;
        Qe > 0 ? (vt = this, wt = ve) : (vt = ve, wt = this);
        for (var $t = 0, xt = 0; xt < wt.length; xt++)
          Ce = (vt.words[xt] | 0) - (wt.words[xt] | 0) + $t, $t = Ce >> 26, this.words[xt] = Ce & 67108863;
        for (; $t !== 0 && xt < vt.length; xt++)
          Ce = (vt.words[xt] | 0) + $t, $t = Ce >> 26, this.words[xt] = Ce & 67108863;
        if ($t === 0 && xt < vt.length && vt !== this)
          for (; xt < vt.length; xt++)
            this.words[xt] = vt.words[xt];
        return this.length = Math.max(this.length, xt), vt !== this && (this.negative = 1), this._strip();
      }, ne.prototype.sub = function(ve) {
        return this.clone().isub(ve);
      };
      function kt(Xe, ve, Ce) {
        Ce.negative = ve.negative ^ Xe.negative;
        var Qe = Xe.length + ve.length | 0;
        Ce.length = Qe, Qe = Qe - 1 | 0;
        var vt = Xe.words[0] | 0, wt = ve.words[0] | 0, $t = vt * wt, xt = $t & 67108863, Pt = $t / 67108864 | 0;
        Ce.words[0] = xt;
        for (var Je = 1; Je < Qe; Je++) {
          for (var Ot = Pt >>> 26, er = Pt & 67108863, sr = Math.min(Je, ve.length - 1), Jt = Math.max(0, Je - Xe.length + 1); Jt <= sr; Jt++) {
            var Wt = Je - Jt | 0;
            vt = Xe.words[Wt] | 0, wt = ve.words[Jt] | 0, $t = vt * wt + er, Ot += $t / 67108864 | 0, er = $t & 67108863;
          }
          Ce.words[Je] = er | 0, Pt = Ot | 0;
        }
        return Pt !== 0 ? Ce.words[Je] = Pt | 0 : Ce.length--, Ce._strip();
      }
      var Bt = function(ve, Ce, Qe) {
        var vt = ve.words, wt = Ce.words, $t = Qe.words, xt = 0, Pt, Je, Ot, er = vt[0] | 0, sr = er & 8191, Jt = er >>> 13, Wt = vt[1] | 0, Gt = Wt & 8191, rr = Wt >>> 13, or = vt[2] | 0, Xt = or & 8191, zt = or >>> 13, ur = vt[3] | 0, hr = ur & 8191, yr = ur >>> 13, Sr = vt[4] | 0, $r = Sr & 8191, Mr = Sr >>> 13, pr = vt[5] | 0, Fr = pr & 8191, Ar = pr >>> 13, Gr = vt[6] | 0, Lr = Gr & 8191, Rr = Gr >>> 13, Vr = vt[7] | 0, jr = Vr & 8191, kr = Vr >>> 13, Jr = vt[8] | 0, Xr = Jr & 8191, Vt = Jr >>> 13, Lt = vt[9] | 0, Dt = Lt & 8191, Qt = Lt >>> 13, fr = wt[0] | 0, cr = fr & 8191, lr = fr >>> 13, Ur = wt[1] | 0, Nr = Ur & 8191, Tr = Ur >>> 13, Wr = wt[2] | 0, qr = Wr & 8191, Or = Wr >>> 13, Zr = wt[3] | 0, Yr = Zr & 8191, nr = Zr >>> 13, Zt = wt[4] | 0, ir = Zt & 8191, ar = Zt >>> 13, dr = wt[5] | 0, vr = dr & 8191, br = dr >>> 13, xr = wt[6] | 0, Pr = xr & 8191, Er = xr >>> 13, Dr = wt[7] | 0, Ir = Dr & 8191, tr = Dr >>> 13, gr = wt[8] | 0, wr = gr & 8191, _r = gr >>> 13, Hr = wt[9] | 0, Cr = Hr & 8191, Br = Hr >>> 13;
        Qe.negative = ve.negative ^ Ce.negative, Qe.length = 19, Pt = Math.imul(sr, cr), Je = Math.imul(sr, lr), Je = Je + Math.imul(Jt, cr) | 0, Ot = Math.imul(Jt, lr);
        var zr = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, Pt = Math.imul(Gt, cr), Je = Math.imul(Gt, lr), Je = Je + Math.imul(rr, cr) | 0, Ot = Math.imul(rr, lr), Pt = Pt + Math.imul(sr, Nr) | 0, Je = Je + Math.imul(sr, Tr) | 0, Je = Je + Math.imul(Jt, Nr) | 0, Ot = Ot + Math.imul(Jt, Tr) | 0;
        var tn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, Pt = Math.imul(Xt, cr), Je = Math.imul(Xt, lr), Je = Je + Math.imul(zt, cr) | 0, Ot = Math.imul(zt, lr), Pt = Pt + Math.imul(Gt, Nr) | 0, Je = Je + Math.imul(Gt, Tr) | 0, Je = Je + Math.imul(rr, Nr) | 0, Ot = Ot + Math.imul(rr, Tr) | 0, Pt = Pt + Math.imul(sr, qr) | 0, Je = Je + Math.imul(sr, Or) | 0, Je = Je + Math.imul(Jt, qr) | 0, Ot = Ot + Math.imul(Jt, Or) | 0;
        var Qr = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, Pt = Math.imul(hr, cr), Je = Math.imul(hr, lr), Je = Je + Math.imul(yr, cr) | 0, Ot = Math.imul(yr, lr), Pt = Pt + Math.imul(Xt, Nr) | 0, Je = Je + Math.imul(Xt, Tr) | 0, Je = Je + Math.imul(zt, Nr) | 0, Ot = Ot + Math.imul(zt, Tr) | 0, Pt = Pt + Math.imul(Gt, qr) | 0, Je = Je + Math.imul(Gt, Or) | 0, Je = Je + Math.imul(rr, qr) | 0, Ot = Ot + Math.imul(rr, Or) | 0, Pt = Pt + Math.imul(sr, Yr) | 0, Je = Je + Math.imul(sr, nr) | 0, Je = Je + Math.imul(Jt, Yr) | 0, Ot = Ot + Math.imul(Jt, nr) | 0;
        var en = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, Pt = Math.imul($r, cr), Je = Math.imul($r, lr), Je = Je + Math.imul(Mr, cr) | 0, Ot = Math.imul(Mr, lr), Pt = Pt + Math.imul(hr, Nr) | 0, Je = Je + Math.imul(hr, Tr) | 0, Je = Je + Math.imul(yr, Nr) | 0, Ot = Ot + Math.imul(yr, Tr) | 0, Pt = Pt + Math.imul(Xt, qr) | 0, Je = Je + Math.imul(Xt, Or) | 0, Je = Je + Math.imul(zt, qr) | 0, Ot = Ot + Math.imul(zt, Or) | 0, Pt = Pt + Math.imul(Gt, Yr) | 0, Je = Je + Math.imul(Gt, nr) | 0, Je = Je + Math.imul(rr, Yr) | 0, Ot = Ot + Math.imul(rr, nr) | 0, Pt = Pt + Math.imul(sr, ir) | 0, Je = Je + Math.imul(sr, ar) | 0, Je = Je + Math.imul(Jt, ir) | 0, Ot = Ot + Math.imul(Jt, ar) | 0;
        var sn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, Pt = Math.imul(Fr, cr), Je = Math.imul(Fr, lr), Je = Je + Math.imul(Ar, cr) | 0, Ot = Math.imul(Ar, lr), Pt = Pt + Math.imul($r, Nr) | 0, Je = Je + Math.imul($r, Tr) | 0, Je = Je + Math.imul(Mr, Nr) | 0, Ot = Ot + Math.imul(Mr, Tr) | 0, Pt = Pt + Math.imul(hr, qr) | 0, Je = Je + Math.imul(hr, Or) | 0, Je = Je + Math.imul(yr, qr) | 0, Ot = Ot + Math.imul(yr, Or) | 0, Pt = Pt + Math.imul(Xt, Yr) | 0, Je = Je + Math.imul(Xt, nr) | 0, Je = Je + Math.imul(zt, Yr) | 0, Ot = Ot + Math.imul(zt, nr) | 0, Pt = Pt + Math.imul(Gt, ir) | 0, Je = Je + Math.imul(Gt, ar) | 0, Je = Je + Math.imul(rr, ir) | 0, Ot = Ot + Math.imul(rr, ar) | 0, Pt = Pt + Math.imul(sr, vr) | 0, Je = Je + Math.imul(sr, br) | 0, Je = Je + Math.imul(Jt, vr) | 0, Ot = Ot + Math.imul(Jt, br) | 0;
        var on = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, Pt = Math.imul(Lr, cr), Je = Math.imul(Lr, lr), Je = Je + Math.imul(Rr, cr) | 0, Ot = Math.imul(Rr, lr), Pt = Pt + Math.imul(Fr, Nr) | 0, Je = Je + Math.imul(Fr, Tr) | 0, Je = Je + Math.imul(Ar, Nr) | 0, Ot = Ot + Math.imul(Ar, Tr) | 0, Pt = Pt + Math.imul($r, qr) | 0, Je = Je + Math.imul($r, Or) | 0, Je = Je + Math.imul(Mr, qr) | 0, Ot = Ot + Math.imul(Mr, Or) | 0, Pt = Pt + Math.imul(hr, Yr) | 0, Je = Je + Math.imul(hr, nr) | 0, Je = Je + Math.imul(yr, Yr) | 0, Ot = Ot + Math.imul(yr, nr) | 0, Pt = Pt + Math.imul(Xt, ir) | 0, Je = Je + Math.imul(Xt, ar) | 0, Je = Je + Math.imul(zt, ir) | 0, Ot = Ot + Math.imul(zt, ar) | 0, Pt = Pt + Math.imul(Gt, vr) | 0, Je = Je + Math.imul(Gt, br) | 0, Je = Je + Math.imul(rr, vr) | 0, Ot = Ot + Math.imul(rr, br) | 0, Pt = Pt + Math.imul(sr, Pr) | 0, Je = Je + Math.imul(sr, Er) | 0, Je = Je + Math.imul(Jt, Pr) | 0, Ot = Ot + Math.imul(Jt, Er) | 0;
        var an = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, Pt = Math.imul(jr, cr), Je = Math.imul(jr, lr), Je = Je + Math.imul(kr, cr) | 0, Ot = Math.imul(kr, lr), Pt = Pt + Math.imul(Lr, Nr) | 0, Je = Je + Math.imul(Lr, Tr) | 0, Je = Je + Math.imul(Rr, Nr) | 0, Ot = Ot + Math.imul(Rr, Tr) | 0, Pt = Pt + Math.imul(Fr, qr) | 0, Je = Je + Math.imul(Fr, Or) | 0, Je = Je + Math.imul(Ar, qr) | 0, Ot = Ot + Math.imul(Ar, Or) | 0, Pt = Pt + Math.imul($r, Yr) | 0, Je = Je + Math.imul($r, nr) | 0, Je = Je + Math.imul(Mr, Yr) | 0, Ot = Ot + Math.imul(Mr, nr) | 0, Pt = Pt + Math.imul(hr, ir) | 0, Je = Je + Math.imul(hr, ar) | 0, Je = Je + Math.imul(yr, ir) | 0, Ot = Ot + Math.imul(yr, ar) | 0, Pt = Pt + Math.imul(Xt, vr) | 0, Je = Je + Math.imul(Xt, br) | 0, Je = Je + Math.imul(zt, vr) | 0, Ot = Ot + Math.imul(zt, br) | 0, Pt = Pt + Math.imul(Gt, Pr) | 0, Je = Je + Math.imul(Gt, Er) | 0, Je = Je + Math.imul(rr, Pr) | 0, Ot = Ot + Math.imul(rr, Er) | 0, Pt = Pt + Math.imul(sr, Ir) | 0, Je = Je + Math.imul(sr, tr) | 0, Je = Je + Math.imul(Jt, Ir) | 0, Ot = Ot + Math.imul(Jt, tr) | 0;
        var nn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, Pt = Math.imul(Xr, cr), Je = Math.imul(Xr, lr), Je = Je + Math.imul(Vt, cr) | 0, Ot = Math.imul(Vt, lr), Pt = Pt + Math.imul(jr, Nr) | 0, Je = Je + Math.imul(jr, Tr) | 0, Je = Je + Math.imul(kr, Nr) | 0, Ot = Ot + Math.imul(kr, Tr) | 0, Pt = Pt + Math.imul(Lr, qr) | 0, Je = Je + Math.imul(Lr, Or) | 0, Je = Je + Math.imul(Rr, qr) | 0, Ot = Ot + Math.imul(Rr, Or) | 0, Pt = Pt + Math.imul(Fr, Yr) | 0, Je = Je + Math.imul(Fr, nr) | 0, Je = Je + Math.imul(Ar, Yr) | 0, Ot = Ot + Math.imul(Ar, nr) | 0, Pt = Pt + Math.imul($r, ir) | 0, Je = Je + Math.imul($r, ar) | 0, Je = Je + Math.imul(Mr, ir) | 0, Ot = Ot + Math.imul(Mr, ar) | 0, Pt = Pt + Math.imul(hr, vr) | 0, Je = Je + Math.imul(hr, br) | 0, Je = Je + Math.imul(yr, vr) | 0, Ot = Ot + Math.imul(yr, br) | 0, Pt = Pt + Math.imul(Xt, Pr) | 0, Je = Je + Math.imul(Xt, Er) | 0, Je = Je + Math.imul(zt, Pr) | 0, Ot = Ot + Math.imul(zt, Er) | 0, Pt = Pt + Math.imul(Gt, Ir) | 0, Je = Je + Math.imul(Gt, tr) | 0, Je = Je + Math.imul(rr, Ir) | 0, Ot = Ot + Math.imul(rr, tr) | 0, Pt = Pt + Math.imul(sr, wr) | 0, Je = Je + Math.imul(sr, _r) | 0, Je = Je + Math.imul(Jt, wr) | 0, Ot = Ot + Math.imul(Jt, _r) | 0;
        var fn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, Pt = Math.imul(Dt, cr), Je = Math.imul(Dt, lr), Je = Je + Math.imul(Qt, cr) | 0, Ot = Math.imul(Qt, lr), Pt = Pt + Math.imul(Xr, Nr) | 0, Je = Je + Math.imul(Xr, Tr) | 0, Je = Je + Math.imul(Vt, Nr) | 0, Ot = Ot + Math.imul(Vt, Tr) | 0, Pt = Pt + Math.imul(jr, qr) | 0, Je = Je + Math.imul(jr, Or) | 0, Je = Je + Math.imul(kr, qr) | 0, Ot = Ot + Math.imul(kr, Or) | 0, Pt = Pt + Math.imul(Lr, Yr) | 0, Je = Je + Math.imul(Lr, nr) | 0, Je = Je + Math.imul(Rr, Yr) | 0, Ot = Ot + Math.imul(Rr, nr) | 0, Pt = Pt + Math.imul(Fr, ir) | 0, Je = Je + Math.imul(Fr, ar) | 0, Je = Je + Math.imul(Ar, ir) | 0, Ot = Ot + Math.imul(Ar, ar) | 0, Pt = Pt + Math.imul($r, vr) | 0, Je = Je + Math.imul($r, br) | 0, Je = Je + Math.imul(Mr, vr) | 0, Ot = Ot + Math.imul(Mr, br) | 0, Pt = Pt + Math.imul(hr, Pr) | 0, Je = Je + Math.imul(hr, Er) | 0, Je = Je + Math.imul(yr, Pr) | 0, Ot = Ot + Math.imul(yr, Er) | 0, Pt = Pt + Math.imul(Xt, Ir) | 0, Je = Je + Math.imul(Xt, tr) | 0, Je = Je + Math.imul(zt, Ir) | 0, Ot = Ot + Math.imul(zt, tr) | 0, Pt = Pt + Math.imul(Gt, wr) | 0, Je = Je + Math.imul(Gt, _r) | 0, Je = Je + Math.imul(rr, wr) | 0, Ot = Ot + Math.imul(rr, _r) | 0, Pt = Pt + Math.imul(sr, Cr) | 0, Je = Je + Math.imul(sr, Br) | 0, Je = Je + Math.imul(Jt, Cr) | 0, Ot = Ot + Math.imul(Jt, Br) | 0;
        var un = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, Pt = Math.imul(Dt, Nr), Je = Math.imul(Dt, Tr), Je = Je + Math.imul(Qt, Nr) | 0, Ot = Math.imul(Qt, Tr), Pt = Pt + Math.imul(Xr, qr) | 0, Je = Je + Math.imul(Xr, Or) | 0, Je = Je + Math.imul(Vt, qr) | 0, Ot = Ot + Math.imul(Vt, Or) | 0, Pt = Pt + Math.imul(jr, Yr) | 0, Je = Je + Math.imul(jr, nr) | 0, Je = Je + Math.imul(kr, Yr) | 0, Ot = Ot + Math.imul(kr, nr) | 0, Pt = Pt + Math.imul(Lr, ir) | 0, Je = Je + Math.imul(Lr, ar) | 0, Je = Je + Math.imul(Rr, ir) | 0, Ot = Ot + Math.imul(Rr, ar) | 0, Pt = Pt + Math.imul(Fr, vr) | 0, Je = Je + Math.imul(Fr, br) | 0, Je = Je + Math.imul(Ar, vr) | 0, Ot = Ot + Math.imul(Ar, br) | 0, Pt = Pt + Math.imul($r, Pr) | 0, Je = Je + Math.imul($r, Er) | 0, Je = Je + Math.imul(Mr, Pr) | 0, Ot = Ot + Math.imul(Mr, Er) | 0, Pt = Pt + Math.imul(hr, Ir) | 0, Je = Je + Math.imul(hr, tr) | 0, Je = Je + Math.imul(yr, Ir) | 0, Ot = Ot + Math.imul(yr, tr) | 0, Pt = Pt + Math.imul(Xt, wr) | 0, Je = Je + Math.imul(Xt, _r) | 0, Je = Je + Math.imul(zt, wr) | 0, Ot = Ot + Math.imul(zt, _r) | 0, Pt = Pt + Math.imul(Gt, Cr) | 0, Je = Je + Math.imul(Gt, Br) | 0, Je = Je + Math.imul(rr, Cr) | 0, Ot = Ot + Math.imul(rr, Br) | 0;
        var cn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, Pt = Math.imul(Dt, qr), Je = Math.imul(Dt, Or), Je = Je + Math.imul(Qt, qr) | 0, Ot = Math.imul(Qt, Or), Pt = Pt + Math.imul(Xr, Yr) | 0, Je = Je + Math.imul(Xr, nr) | 0, Je = Je + Math.imul(Vt, Yr) | 0, Ot = Ot + Math.imul(Vt, nr) | 0, Pt = Pt + Math.imul(jr, ir) | 0, Je = Je + Math.imul(jr, ar) | 0, Je = Je + Math.imul(kr, ir) | 0, Ot = Ot + Math.imul(kr, ar) | 0, Pt = Pt + Math.imul(Lr, vr) | 0, Je = Je + Math.imul(Lr, br) | 0, Je = Je + Math.imul(Rr, vr) | 0, Ot = Ot + Math.imul(Rr, br) | 0, Pt = Pt + Math.imul(Fr, Pr) | 0, Je = Je + Math.imul(Fr, Er) | 0, Je = Je + Math.imul(Ar, Pr) | 0, Ot = Ot + Math.imul(Ar, Er) | 0, Pt = Pt + Math.imul($r, Ir) | 0, Je = Je + Math.imul($r, tr) | 0, Je = Je + Math.imul(Mr, Ir) | 0, Ot = Ot + Math.imul(Mr, tr) | 0, Pt = Pt + Math.imul(hr, wr) | 0, Je = Je + Math.imul(hr, _r) | 0, Je = Je + Math.imul(yr, wr) | 0, Ot = Ot + Math.imul(yr, _r) | 0, Pt = Pt + Math.imul(Xt, Cr) | 0, Je = Je + Math.imul(Xt, Br) | 0, Je = Je + Math.imul(zt, Cr) | 0, Ot = Ot + Math.imul(zt, Br) | 0;
        var ln = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, Pt = Math.imul(Dt, Yr), Je = Math.imul(Dt, nr), Je = Je + Math.imul(Qt, Yr) | 0, Ot = Math.imul(Qt, nr), Pt = Pt + Math.imul(Xr, ir) | 0, Je = Je + Math.imul(Xr, ar) | 0, Je = Je + Math.imul(Vt, ir) | 0, Ot = Ot + Math.imul(Vt, ar) | 0, Pt = Pt + Math.imul(jr, vr) | 0, Je = Je + Math.imul(jr, br) | 0, Je = Je + Math.imul(kr, vr) | 0, Ot = Ot + Math.imul(kr, br) | 0, Pt = Pt + Math.imul(Lr, Pr) | 0, Je = Je + Math.imul(Lr, Er) | 0, Je = Je + Math.imul(Rr, Pr) | 0, Ot = Ot + Math.imul(Rr, Er) | 0, Pt = Pt + Math.imul(Fr, Ir) | 0, Je = Je + Math.imul(Fr, tr) | 0, Je = Je + Math.imul(Ar, Ir) | 0, Ot = Ot + Math.imul(Ar, tr) | 0, Pt = Pt + Math.imul($r, wr) | 0, Je = Je + Math.imul($r, _r) | 0, Je = Je + Math.imul(Mr, wr) | 0, Ot = Ot + Math.imul(Mr, _r) | 0, Pt = Pt + Math.imul(hr, Cr) | 0, Je = Je + Math.imul(hr, Br) | 0, Je = Je + Math.imul(yr, Cr) | 0, Ot = Ot + Math.imul(yr, Br) | 0;
        var hn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, Pt = Math.imul(Dt, ir), Je = Math.imul(Dt, ar), Je = Je + Math.imul(Qt, ir) | 0, Ot = Math.imul(Qt, ar), Pt = Pt + Math.imul(Xr, vr) | 0, Je = Je + Math.imul(Xr, br) | 0, Je = Je + Math.imul(Vt, vr) | 0, Ot = Ot + Math.imul(Vt, br) | 0, Pt = Pt + Math.imul(jr, Pr) | 0, Je = Je + Math.imul(jr, Er) | 0, Je = Je + Math.imul(kr, Pr) | 0, Ot = Ot + Math.imul(kr, Er) | 0, Pt = Pt + Math.imul(Lr, Ir) | 0, Je = Je + Math.imul(Lr, tr) | 0, Je = Je + Math.imul(Rr, Ir) | 0, Ot = Ot + Math.imul(Rr, tr) | 0, Pt = Pt + Math.imul(Fr, wr) | 0, Je = Je + Math.imul(Fr, _r) | 0, Je = Je + Math.imul(Ar, wr) | 0, Ot = Ot + Math.imul(Ar, _r) | 0, Pt = Pt + Math.imul($r, Cr) | 0, Je = Je + Math.imul($r, Br) | 0, Je = Je + Math.imul(Mr, Cr) | 0, Ot = Ot + Math.imul(Mr, Br) | 0;
        var dn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, Pt = Math.imul(Dt, vr), Je = Math.imul(Dt, br), Je = Je + Math.imul(Qt, vr) | 0, Ot = Math.imul(Qt, br), Pt = Pt + Math.imul(Xr, Pr) | 0, Je = Je + Math.imul(Xr, Er) | 0, Je = Je + Math.imul(Vt, Pr) | 0, Ot = Ot + Math.imul(Vt, Er) | 0, Pt = Pt + Math.imul(jr, Ir) | 0, Je = Je + Math.imul(jr, tr) | 0, Je = Je + Math.imul(kr, Ir) | 0, Ot = Ot + Math.imul(kr, tr) | 0, Pt = Pt + Math.imul(Lr, wr) | 0, Je = Je + Math.imul(Lr, _r) | 0, Je = Je + Math.imul(Rr, wr) | 0, Ot = Ot + Math.imul(Rr, _r) | 0, Pt = Pt + Math.imul(Fr, Cr) | 0, Je = Je + Math.imul(Fr, Br) | 0, Je = Je + Math.imul(Ar, Cr) | 0, Ot = Ot + Math.imul(Ar, Br) | 0;
        var pn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, Pt = Math.imul(Dt, Pr), Je = Math.imul(Dt, Er), Je = Je + Math.imul(Qt, Pr) | 0, Ot = Math.imul(Qt, Er), Pt = Pt + Math.imul(Xr, Ir) | 0, Je = Je + Math.imul(Xr, tr) | 0, Je = Je + Math.imul(Vt, Ir) | 0, Ot = Ot + Math.imul(Vt, tr) | 0, Pt = Pt + Math.imul(jr, wr) | 0, Je = Je + Math.imul(jr, _r) | 0, Je = Je + Math.imul(kr, wr) | 0, Ot = Ot + Math.imul(kr, _r) | 0, Pt = Pt + Math.imul(Lr, Cr) | 0, Je = Je + Math.imul(Lr, Br) | 0, Je = Je + Math.imul(Rr, Cr) | 0, Ot = Ot + Math.imul(Rr, Br) | 0;
        var vn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, Pt = Math.imul(Dt, Ir), Je = Math.imul(Dt, tr), Je = Je + Math.imul(Qt, Ir) | 0, Ot = Math.imul(Qt, tr), Pt = Pt + Math.imul(Xr, wr) | 0, Je = Je + Math.imul(Xr, _r) | 0, Je = Je + Math.imul(Vt, wr) | 0, Ot = Ot + Math.imul(Vt, _r) | 0, Pt = Pt + Math.imul(jr, Cr) | 0, Je = Je + Math.imul(jr, Br) | 0, Je = Je + Math.imul(kr, Cr) | 0, Ot = Ot + Math.imul(kr, Br) | 0;
        var yn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, Pt = Math.imul(Dt, wr), Je = Math.imul(Dt, _r), Je = Je + Math.imul(Qt, wr) | 0, Ot = Math.imul(Qt, _r), Pt = Pt + Math.imul(Xr, Cr) | 0, Je = Je + Math.imul(Xr, Br) | 0, Je = Je + Math.imul(Vt, Cr) | 0, Ot = Ot + Math.imul(Vt, Br) | 0;
        var mn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, Pt = Math.imul(Dt, Cr), Je = Math.imul(Dt, Br), Je = Je + Math.imul(Qt, Cr) | 0, Ot = Math.imul(Qt, Br);
        var gn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        return xt = (Ot + (Je >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, $t[0] = zr, $t[1] = tn, $t[2] = Qr, $t[3] = en, $t[4] = sn, $t[5] = on, $t[6] = an, $t[7] = nn, $t[8] = fn, $t[9] = un, $t[10] = cn, $t[11] = ln, $t[12] = hn, $t[13] = dn, $t[14] = pn, $t[15] = vn, $t[16] = yn, $t[17] = mn, $t[18] = gn, xt !== 0 && ($t[19] = xt, Qe.length++), Qe;
      };
      Math.imul || (Bt = kt);
      function Ct(Xe, ve, Ce) {
        Ce.negative = ve.negative ^ Xe.negative, Ce.length = Xe.length + ve.length;
        for (var Qe = 0, vt = 0, wt = 0; wt < Ce.length - 1; wt++) {
          var $t = vt;
          vt = 0;
          for (var xt = Qe & 67108863, Pt = Math.min(wt, ve.length - 1), Je = Math.max(0, wt - Xe.length + 1); Je <= Pt; Je++) {
            var Ot = wt - Je, er = Xe.words[Ot] | 0, sr = ve.words[Je] | 0, Jt = er * sr, Wt = Jt & 67108863;
            $t = $t + (Jt / 67108864 | 0) | 0, Wt = Wt + xt | 0, xt = Wt & 67108863, $t = $t + (Wt >>> 26) | 0, vt += $t >>> 26, $t &= 67108863;
          }
          Ce.words[wt] = xt, Qe = $t, $t = vt;
        }
        return Qe !== 0 ? Ce.words[wt] = Qe : Ce.length--, Ce._strip();
      }
      function qt(Xe, ve, Ce) {
        return Ct(Xe, ve, Ce);
      }
      ne.prototype.mulTo = function(ve, Ce) {
        var Qe, vt = this.length + ve.length;
        return this.length === 10 && ve.length === 10 ? Qe = Bt(this, ve, Ce) : vt < 63 ? Qe = kt(this, ve, Ce) : vt < 1024 ? Qe = Ct(this, ve, Ce) : Qe = qt(this, ve, Ce), Qe;
      }, ne.prototype.mul = function(ve) {
        var Ce = new ne(null);
        return Ce.words = new Array(this.length + ve.length), this.mulTo(ve, Ce);
      }, ne.prototype.mulf = function(ve) {
        var Ce = new ne(null);
        return Ce.words = new Array(this.length + ve.length), qt(this, ve, Ce);
      }, ne.prototype.imul = function(ve) {
        return this.clone().mulTo(ve, this);
      }, ne.prototype.imuln = function(ve) {
        var Ce = ve < 0;
        Ce && (ve = -ve), ie(typeof ve == "number"), ie(ve < 67108864);
        for (var Qe = 0, vt = 0; vt < this.length; vt++) {
          var wt = (this.words[vt] | 0) * ve, $t = (wt & 67108863) + (Qe & 67108863);
          Qe >>= 26, Qe += wt / 67108864 | 0, Qe += $t >>> 26, this.words[vt] = $t & 67108863;
        }
        return Qe !== 0 && (this.words[vt] = Qe, this.length++), Ce ? this.ineg() : this;
      }, ne.prototype.muln = function(ve) {
        return this.clone().imuln(ve);
      }, ne.prototype.sqr = function() {
        return this.mul(this);
      }, ne.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ne.prototype.pow = function(ve) {
        var Ce = Rt(ve);
        if (Ce.length === 0) return new ne(1);
        for (var Qe = this, vt = 0; vt < Ce.length && Ce[vt] === 0; vt++, Qe = Qe.sqr())
          ;
        if (++vt < Ce.length)
          for (var wt = Qe.sqr(); vt < Ce.length; vt++, wt = wt.sqr())
            Ce[vt] !== 0 && (Qe = Qe.mul(wt));
        return Qe;
      }, ne.prototype.iushln = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = ve % 26, Qe = (ve - Ce) / 26, vt = 67108863 >>> 26 - Ce << 26 - Ce, wt;
        if (Ce !== 0) {
          var $t = 0;
          for (wt = 0; wt < this.length; wt++) {
            var xt = this.words[wt] & vt, Pt = (this.words[wt] | 0) - xt << Ce;
            this.words[wt] = Pt | $t, $t = xt >>> 26 - Ce;
          }
          $t && (this.words[wt] = $t, this.length++);
        }
        if (Qe !== 0) {
          for (wt = this.length - 1; wt >= 0; wt--)
            this.words[wt + Qe] = this.words[wt];
          for (wt = 0; wt < Qe; wt++)
            this.words[wt] = 0;
          this.length += Qe;
        }
        return this._strip();
      }, ne.prototype.ishln = function(ve) {
        return ie(this.negative === 0), this.iushln(ve);
      }, ne.prototype.iushrn = function(ve, Ce, Qe) {
        ie(typeof ve == "number" && ve >= 0);
        var vt;
        Ce ? vt = (Ce - Ce % 26) / 26 : vt = 0;
        var wt = ve % 26, $t = Math.min((ve - wt) / 26, this.length), xt = 67108863 ^ 67108863 >>> wt << wt, Pt = Qe;
        if (vt -= $t, vt = Math.max(0, vt), Pt) {
          for (var Je = 0; Je < $t; Je++)
            Pt.words[Je] = this.words[Je];
          Pt.length = $t;
        }
        if ($t !== 0) if (this.length > $t)
          for (this.length -= $t, Je = 0; Je < this.length; Je++)
            this.words[Je] = this.words[Je + $t];
        else
          this.words[0] = 0, this.length = 1;
        var Ot = 0;
        for (Je = this.length - 1; Je >= 0 && (Ot !== 0 || Je >= vt); Je--) {
          var er = this.words[Je] | 0;
          this.words[Je] = Ot << 26 - wt | er >>> wt, Ot = er & xt;
        }
        return Pt && Ot !== 0 && (Pt.words[Pt.length++] = Ot), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, ne.prototype.ishrn = function(ve, Ce, Qe) {
        return ie(this.negative === 0), this.iushrn(ve, Ce, Qe);
      }, ne.prototype.shln = function(ve) {
        return this.clone().ishln(ve);
      }, ne.prototype.ushln = function(ve) {
        return this.clone().iushln(ve);
      }, ne.prototype.shrn = function(ve) {
        return this.clone().ishrn(ve);
      }, ne.prototype.ushrn = function(ve) {
        return this.clone().iushrn(ve);
      }, ne.prototype.testn = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = ve % 26, Qe = (ve - Ce) / 26, vt = 1 << Ce;
        if (this.length <= Qe) return !1;
        var wt = this.words[Qe];
        return !!(wt & vt);
      }, ne.prototype.imaskn = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = ve % 26, Qe = (ve - Ce) / 26;
        if (ie(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Qe)
          return this;
        if (Ce !== 0 && Qe++, this.length = Math.min(Qe, this.length), Ce !== 0) {
          var vt = 67108863 ^ 67108863 >>> Ce << Ce;
          this.words[this.length - 1] &= vt;
        }
        return this._strip();
      }, ne.prototype.maskn = function(ve) {
        return this.clone().imaskn(ve);
      }, ne.prototype.iaddn = function(ve) {
        return ie(typeof ve == "number"), ie(ve < 67108864), ve < 0 ? this.isubn(-ve) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ve ? (this.words[0] = ve - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ve), this.negative = 1, this) : this._iaddn(ve);
      }, ne.prototype._iaddn = function(ve) {
        this.words[0] += ve;
        for (var Ce = 0; Ce < this.length && this.words[Ce] >= 67108864; Ce++)
          this.words[Ce] -= 67108864, Ce === this.length - 1 ? this.words[Ce + 1] = 1 : this.words[Ce + 1]++;
        return this.length = Math.max(this.length, Ce + 1), this;
      }, ne.prototype.isubn = function(ve) {
        if (ie(typeof ve == "number"), ie(ve < 67108864), ve < 0) return this.iaddn(-ve);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(ve), this.negative = 1, this;
        if (this.words[0] -= ve, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Ce = 0; Ce < this.length && this.words[Ce] < 0; Ce++)
            this.words[Ce] += 67108864, this.words[Ce + 1] -= 1;
        return this._strip();
      }, ne.prototype.addn = function(ve) {
        return this.clone().iaddn(ve);
      }, ne.prototype.subn = function(ve) {
        return this.clone().isubn(ve);
      }, ne.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ne.prototype.abs = function() {
        return this.clone().iabs();
      }, ne.prototype._ishlnsubmul = function(ve, Ce, Qe) {
        var vt = ve.length + Qe, wt;
        this._expand(vt);
        var $t, xt = 0;
        for (wt = 0; wt < ve.length; wt++) {
          $t = (this.words[wt + Qe] | 0) + xt;
          var Pt = (ve.words[wt] | 0) * Ce;
          $t -= Pt & 67108863, xt = ($t >> 26) - (Pt / 67108864 | 0), this.words[wt + Qe] = $t & 67108863;
        }
        for (; wt < this.length - Qe; wt++)
          $t = (this.words[wt + Qe] | 0) + xt, xt = $t >> 26, this.words[wt + Qe] = $t & 67108863;
        if (xt === 0) return this._strip();
        for (ie(xt === -1), xt = 0, wt = 0; wt < this.length; wt++)
          $t = -(this.words[wt] | 0) + xt, xt = $t >> 26, this.words[wt] = $t & 67108863;
        return this.negative = 1, this._strip();
      }, ne.prototype._wordDiv = function(ve, Ce) {
        var Qe = this.length - ve.length, vt = this.clone(), wt = ve, $t = wt.words[wt.length - 1] | 0, xt = this._countBits($t);
        Qe = 26 - xt, Qe !== 0 && (wt = wt.ushln(Qe), vt.iushln(Qe), $t = wt.words[wt.length - 1] | 0);
        var Pt = vt.length - wt.length, Je;
        if (Ce !== "mod") {
          Je = new ne(null), Je.length = Pt + 1, Je.words = new Array(Je.length);
          for (var Ot = 0; Ot < Je.length; Ot++)
            Je.words[Ot] = 0;
        }
        var er = vt.clone()._ishlnsubmul(wt, 1, Pt);
        er.negative === 0 && (vt = er, Je && (Je.words[Pt] = 1));
        for (var sr = Pt - 1; sr >= 0; sr--) {
          var Jt = (vt.words[wt.length + sr] | 0) * 67108864 + (vt.words[wt.length + sr - 1] | 0);
          for (Jt = Math.min(Jt / $t | 0, 67108863), vt._ishlnsubmul(wt, Jt, sr); vt.negative !== 0; )
            Jt--, vt.negative = 0, vt._ishlnsubmul(wt, 1, sr), vt.isZero() || (vt.negative ^= 1);
          Je && (Je.words[sr] = Jt);
        }
        return Je && Je._strip(), vt._strip(), Ce !== "div" && Qe !== 0 && vt.iushrn(Qe), {
          div: Je || null,
          mod: vt
        };
      }, ne.prototype.divmod = function(ve, Ce, Qe) {
        if (ie(!ve.isZero()), this.isZero())
          return {
            div: new ne(0),
            mod: new ne(0)
          };
        var vt, wt, $t;
        return this.negative !== 0 && ve.negative === 0 ? ($t = this.neg().divmod(ve, Ce), Ce !== "mod" && (vt = $t.div.neg()), Ce !== "div" && (wt = $t.mod.neg(), Qe && wt.negative !== 0 && wt.iadd(ve)), {
          div: vt,
          mod: wt
        }) : this.negative === 0 && ve.negative !== 0 ? ($t = this.divmod(ve.neg(), Ce), Ce !== "mod" && (vt = $t.div.neg()), {
          div: vt,
          mod: $t.mod
        }) : this.negative & ve.negative ? ($t = this.neg().divmod(ve.neg(), Ce), Ce !== "div" && (wt = $t.mod.neg(), Qe && wt.negative !== 0 && wt.isub(ve)), {
          div: $t.div,
          mod: wt
        }) : ve.length > this.length || this.cmp(ve) < 0 ? {
          div: new ne(0),
          mod: this
        } : ve.length === 1 ? Ce === "div" ? {
          div: this.divn(ve.words[0]),
          mod: null
        } : Ce === "mod" ? {
          div: null,
          mod: new ne(this.modrn(ve.words[0]))
        } : {
          div: this.divn(ve.words[0]),
          mod: new ne(this.modrn(ve.words[0]))
        } : this._wordDiv(ve, Ce);
      }, ne.prototype.div = function(ve) {
        return this.divmod(ve, "div", !1).div;
      }, ne.prototype.mod = function(ve) {
        return this.divmod(ve, "mod", !1).mod;
      }, ne.prototype.umod = function(ve) {
        return this.divmod(ve, "mod", !0).mod;
      }, ne.prototype.divRound = function(ve) {
        var Ce = this.divmod(ve);
        if (Ce.mod.isZero()) return Ce.div;
        var Qe = Ce.div.negative !== 0 ? Ce.mod.isub(ve) : Ce.mod, vt = ve.ushrn(1), wt = ve.andln(1), $t = Qe.cmp(vt);
        return $t < 0 || wt === 1 && $t === 0 ? Ce.div : Ce.div.negative !== 0 ? Ce.div.isubn(1) : Ce.div.iaddn(1);
      }, ne.prototype.modrn = function(ve) {
        var Ce = ve < 0;
        Ce && (ve = -ve), ie(ve <= 67108863);
        for (var Qe = (1 << 26) % ve, vt = 0, wt = this.length - 1; wt >= 0; wt--)
          vt = (Qe * vt + (this.words[wt] | 0)) % ve;
        return Ce ? -vt : vt;
      }, ne.prototype.modn = function(ve) {
        return this.modrn(ve);
      }, ne.prototype.idivn = function(ve) {
        var Ce = ve < 0;
        Ce && (ve = -ve), ie(ve <= 67108863);
        for (var Qe = 0, vt = this.length - 1; vt >= 0; vt--) {
          var wt = (this.words[vt] | 0) + Qe * 67108864;
          this.words[vt] = wt / ve | 0, Qe = wt % ve;
        }
        return this._strip(), Ce ? this.ineg() : this;
      }, ne.prototype.divn = function(ve) {
        return this.clone().idivn(ve);
      }, ne.prototype.egcd = function(ve) {
        ie(ve.negative === 0), ie(!ve.isZero());
        var Ce = this, Qe = ve.clone();
        Ce.negative !== 0 ? Ce = Ce.umod(ve) : Ce = Ce.clone();
        for (var vt = new ne(1), wt = new ne(0), $t = new ne(0), xt = new ne(1), Pt = 0; Ce.isEven() && Qe.isEven(); )
          Ce.iushrn(1), Qe.iushrn(1), ++Pt;
        for (var Je = Qe.clone(), Ot = Ce.clone(); !Ce.isZero(); ) {
          for (var er = 0, sr = 1; !(Ce.words[0] & sr) && er < 26; ++er, sr <<= 1) ;
          if (er > 0)
            for (Ce.iushrn(er); er-- > 0; )
              (vt.isOdd() || wt.isOdd()) && (vt.iadd(Je), wt.isub(Ot)), vt.iushrn(1), wt.iushrn(1);
          for (var Jt = 0, Wt = 1; !(Qe.words[0] & Wt) && Jt < 26; ++Jt, Wt <<= 1) ;
          if (Jt > 0)
            for (Qe.iushrn(Jt); Jt-- > 0; )
              ($t.isOdd() || xt.isOdd()) && ($t.iadd(Je), xt.isub(Ot)), $t.iushrn(1), xt.iushrn(1);
          Ce.cmp(Qe) >= 0 ? (Ce.isub(Qe), vt.isub($t), wt.isub(xt)) : (Qe.isub(Ce), $t.isub(vt), xt.isub(wt));
        }
        return {
          a: $t,
          b: xt,
          gcd: Qe.iushln(Pt)
        };
      }, ne.prototype._invmp = function(ve) {
        ie(ve.negative === 0), ie(!ve.isZero());
        var Ce = this, Qe = ve.clone();
        Ce.negative !== 0 ? Ce = Ce.umod(ve) : Ce = Ce.clone();
        for (var vt = new ne(1), wt = new ne(0), $t = Qe.clone(); Ce.cmpn(1) > 0 && Qe.cmpn(1) > 0; ) {
          for (var xt = 0, Pt = 1; !(Ce.words[0] & Pt) && xt < 26; ++xt, Pt <<= 1) ;
          if (xt > 0)
            for (Ce.iushrn(xt); xt-- > 0; )
              vt.isOdd() && vt.iadd($t), vt.iushrn(1);
          for (var Je = 0, Ot = 1; !(Qe.words[0] & Ot) && Je < 26; ++Je, Ot <<= 1) ;
          if (Je > 0)
            for (Qe.iushrn(Je); Je-- > 0; )
              wt.isOdd() && wt.iadd($t), wt.iushrn(1);
          Ce.cmp(Qe) >= 0 ? (Ce.isub(Qe), vt.isub(wt)) : (Qe.isub(Ce), wt.isub(vt));
        }
        var er;
        return Ce.cmpn(1) === 0 ? er = vt : er = wt, er.cmpn(0) < 0 && er.iadd(ve), er;
      }, ne.prototype.gcd = function(ve) {
        if (this.isZero()) return ve.abs();
        if (ve.isZero()) return this.abs();
        var Ce = this.clone(), Qe = ve.clone();
        Ce.negative = 0, Qe.negative = 0;
        for (var vt = 0; Ce.isEven() && Qe.isEven(); vt++)
          Ce.iushrn(1), Qe.iushrn(1);
        do {
          for (; Ce.isEven(); )
            Ce.iushrn(1);
          for (; Qe.isEven(); )
            Qe.iushrn(1);
          var wt = Ce.cmp(Qe);
          if (wt < 0) {
            var $t = Ce;
            Ce = Qe, Qe = $t;
          } else if (wt === 0 || Qe.cmpn(1) === 0)
            break;
          Ce.isub(Qe);
        } while (!0);
        return Qe.iushln(vt);
      }, ne.prototype.invm = function(ve) {
        return this.egcd(ve).a.umod(ve);
      }, ne.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ne.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ne.prototype.andln = function(ve) {
        return this.words[0] & ve;
      }, ne.prototype.bincn = function(ve) {
        ie(typeof ve == "number");
        var Ce = ve % 26, Qe = (ve - Ce) / 26, vt = 1 << Ce;
        if (this.length <= Qe)
          return this._expand(Qe + 1), this.words[Qe] |= vt, this;
        for (var wt = vt, $t = Qe; wt !== 0 && $t < this.length; $t++) {
          var xt = this.words[$t] | 0;
          xt += wt, wt = xt >>> 26, xt &= 67108863, this.words[$t] = xt;
        }
        return wt !== 0 && (this.words[$t] = wt, this.length++), this;
      }, ne.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ne.prototype.cmpn = function(ve) {
        var Ce = ve < 0;
        if (this.negative !== 0 && !Ce) return -1;
        if (this.negative === 0 && Ce) return 1;
        this._strip();
        var Qe;
        if (this.length > 1)
          Qe = 1;
        else {
          Ce && (ve = -ve), ie(ve <= 67108863, "Number is too big");
          var vt = this.words[0] | 0;
          Qe = vt === ve ? 0 : vt < ve ? -1 : 1;
        }
        return this.negative !== 0 ? -Qe | 0 : Qe;
      }, ne.prototype.cmp = function(ve) {
        if (this.negative !== 0 && ve.negative === 0) return -1;
        if (this.negative === 0 && ve.negative !== 0) return 1;
        var Ce = this.ucmp(ve);
        return this.negative !== 0 ? -Ce | 0 : Ce;
      }, ne.prototype.ucmp = function(ve) {
        if (this.length > ve.length) return 1;
        if (this.length < ve.length) return -1;
        for (var Ce = 0, Qe = this.length - 1; Qe >= 0; Qe--) {
          var vt = this.words[Qe] | 0, wt = ve.words[Qe] | 0;
          if (vt !== wt) {
            vt < wt ? Ce = -1 : vt > wt && (Ce = 1);
            break;
          }
        }
        return Ce;
      }, ne.prototype.gtn = function(ve) {
        return this.cmpn(ve) === 1;
      }, ne.prototype.gt = function(ve) {
        return this.cmp(ve) === 1;
      }, ne.prototype.gten = function(ve) {
        return this.cmpn(ve) >= 0;
      }, ne.prototype.gte = function(ve) {
        return this.cmp(ve) >= 0;
      }, ne.prototype.ltn = function(ve) {
        return this.cmpn(ve) === -1;
      }, ne.prototype.lt = function(ve) {
        return this.cmp(ve) === -1;
      }, ne.prototype.lten = function(ve) {
        return this.cmpn(ve) <= 0;
      }, ne.prototype.lte = function(ve) {
        return this.cmp(ve) <= 0;
      }, ne.prototype.eqn = function(ve) {
        return this.cmpn(ve) === 0;
      }, ne.prototype.eq = function(ve) {
        return this.cmp(ve) === 0;
      }, ne.red = function(ve) {
        return new Ft(ve);
      }, ne.prototype.toRed = function(ve) {
        return ie(!this.red, "Already a number in reduction context"), ie(this.negative === 0, "red works only with positives"), ve.convertTo(this)._forceRed(ve);
      }, ne.prototype.fromRed = function() {
        return ie(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ne.prototype._forceRed = function(ve) {
        return this.red = ve, this;
      }, ne.prototype.forceRed = function(ve) {
        return ie(!this.red, "Already a number in reduction context"), this._forceRed(ve);
      }, ne.prototype.redAdd = function(ve) {
        return ie(this.red, "redAdd works only with red numbers"), this.red.add(this, ve);
      }, ne.prototype.redIAdd = function(ve) {
        return ie(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ve);
      }, ne.prototype.redSub = function(ve) {
        return ie(this.red, "redSub works only with red numbers"), this.red.sub(this, ve);
      }, ne.prototype.redISub = function(ve) {
        return ie(this.red, "redISub works only with red numbers"), this.red.isub(this, ve);
      }, ne.prototype.redShl = function(ve) {
        return ie(this.red, "redShl works only with red numbers"), this.red.shl(this, ve);
      }, ne.prototype.redMul = function(ve) {
        return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, ve), this.red.mul(this, ve);
      }, ne.prototype.redIMul = function(ve) {
        return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, ve), this.red.imul(this, ve);
      }, ne.prototype.redSqr = function() {
        return ie(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ne.prototype.redISqr = function() {
        return ie(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ne.prototype.redSqrt = function() {
        return ie(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ne.prototype.redInvm = function() {
        return ie(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ne.prototype.redNeg = function() {
        return ie(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ne.prototype.redPow = function(ve) {
        return ie(this.red && !ve.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ve);
      };
      var jt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Ht(Xe, ve) {
        this.name = Xe, this.p = new ne(ve, 16), this.n = this.p.bitLength(), this.k = new ne(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ht.prototype._tmp = function() {
        var ve = new ne(null);
        return ve.words = new Array(Math.ceil(this.n / 13)), ve;
      }, Ht.prototype.ireduce = function(ve) {
        var Ce = ve, Qe;
        do
          this.split(Ce, this.tmp), Ce = this.imulK(Ce), Ce = Ce.iadd(this.tmp), Qe = Ce.bitLength();
        while (Qe > this.n);
        var vt = Qe < this.n ? -1 : Ce.ucmp(this.p);
        return vt === 0 ? (Ce.words[0] = 0, Ce.length = 1) : vt > 0 ? Ce.isub(this.p) : Ce.strip !== void 0 ? Ce.strip() : Ce._strip(), Ce;
      }, Ht.prototype.split = function(ve, Ce) {
        ve.iushrn(this.n, 0, Ce);
      }, Ht.prototype.imulK = function(ve) {
        return ve.imul(this.k);
      };
      function Yt() {
        Ht.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      se(Yt, Ht), Yt.prototype.split = function(ve, Ce) {
        for (var Qe = 4194303, vt = Math.min(ve.length, 9), wt = 0; wt < vt; wt++)
          Ce.words[wt] = ve.words[wt];
        if (Ce.length = vt, ve.length <= 9) {
          ve.words[0] = 0, ve.length = 1;
          return;
        }
        var $t = ve.words[9];
        for (Ce.words[Ce.length++] = $t & Qe, wt = 10; wt < ve.length; wt++) {
          var xt = ve.words[wt] | 0;
          ve.words[wt - 10] = (xt & Qe) << 4 | $t >>> 22, $t = xt;
        }
        $t >>>= 22, ve.words[wt - 10] = $t, $t === 0 && ve.length > 10 ? ve.length -= 10 : ve.length -= 9;
      }, Yt.prototype.imulK = function(ve) {
        ve.words[ve.length] = 0, ve.words[ve.length + 1] = 0, ve.length += 2;
        for (var Ce = 0, Qe = 0; Qe < ve.length; Qe++) {
          var vt = ve.words[Qe] | 0;
          Ce += vt * 977, ve.words[Qe] = Ce & 67108863, Ce = vt * 64 + (Ce / 67108864 | 0);
        }
        return ve.words[ve.length - 1] === 0 && (ve.length--, ve.words[ve.length - 1] === 0 && ve.length--), ve;
      };
      function Ut() {
        Ht.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      se(Ut, Ht);
      function Nt() {
        Ht.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      se(Nt, Ht);
      function Kt() {
        Ht.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      se(Kt, Ht), Kt.prototype.imulK = function(ve) {
        for (var Ce = 0, Qe = 0; Qe < ve.length; Qe++) {
          var vt = (ve.words[Qe] | 0) * 19 + Ce, wt = vt & 67108863;
          vt >>>= 26, ve.words[Qe] = wt, Ce = vt;
        }
        return Ce !== 0 && (ve.words[ve.length++] = Ce), ve;
      }, ne._prime = function(ve) {
        if (jt[ve]) return jt[ve];
        var Ce;
        if (ve === "k256")
          Ce = new Yt();
        else if (ve === "p224")
          Ce = new Ut();
        else if (ve === "p192")
          Ce = new Nt();
        else if (ve === "p25519")
          Ce = new Kt();
        else
          throw new Error("Unknown prime " + ve);
        return jt[ve] = Ce, Ce;
      };
      function Ft(Xe) {
        if (typeof Xe == "string") {
          var ve = ne._prime(Xe);
          this.m = ve.p, this.prime = ve;
        } else
          ie(Xe.gtn(1), "modulus must be greater than 1"), this.m = Xe, this.prime = null;
      }
      Ft.prototype._verify1 = function(ve) {
        ie(ve.negative === 0, "red works only with positives"), ie(ve.red, "red works only with red numbers");
      }, Ft.prototype._verify2 = function(ve, Ce) {
        ie((ve.negative | Ce.negative) === 0, "red works only with positives"), ie(
          ve.red && ve.red === Ce.red,
          "red works only with red numbers"
        );
      }, Ft.prototype.imod = function(ve) {
        return this.prime ? this.prime.ireduce(ve)._forceRed(this) : (oe(ve, ve.umod(this.m)._forceRed(this)), ve);
      }, Ft.prototype.neg = function(ve) {
        return ve.isZero() ? ve.clone() : this.m.sub(ve)._forceRed(this);
      }, Ft.prototype.add = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.add(Ce);
        return Qe.cmp(this.m) >= 0 && Qe.isub(this.m), Qe._forceRed(this);
      }, Ft.prototype.iadd = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.iadd(Ce);
        return Qe.cmp(this.m) >= 0 && Qe.isub(this.m), Qe;
      }, Ft.prototype.sub = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.sub(Ce);
        return Qe.cmpn(0) < 0 && Qe.iadd(this.m), Qe._forceRed(this);
      }, Ft.prototype.isub = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.isub(Ce);
        return Qe.cmpn(0) < 0 && Qe.iadd(this.m), Qe;
      }, Ft.prototype.shl = function(ve, Ce) {
        return this._verify1(ve), this.imod(ve.ushln(Ce));
      }, Ft.prototype.imul = function(ve, Ce) {
        return this._verify2(ve, Ce), this.imod(ve.imul(Ce));
      }, Ft.prototype.mul = function(ve, Ce) {
        return this._verify2(ve, Ce), this.imod(ve.mul(Ce));
      }, Ft.prototype.isqr = function(ve) {
        return this.imul(ve, ve.clone());
      }, Ft.prototype.sqr = function(ve) {
        return this.mul(ve, ve);
      }, Ft.prototype.sqrt = function(ve) {
        if (ve.isZero()) return ve.clone();
        var Ce = this.m.andln(3);
        if (ie(Ce % 2 === 1), Ce === 3) {
          var Qe = this.m.add(new ne(1)).iushrn(2);
          return this.pow(ve, Qe);
        }
        for (var vt = this.m.subn(1), wt = 0; !vt.isZero() && vt.andln(1) === 0; )
          wt++, vt.iushrn(1);
        ie(!vt.isZero());
        var $t = new ne(1).toRed(this), xt = $t.redNeg(), Pt = this.m.subn(1).iushrn(1), Je = this.m.bitLength();
        for (Je = new ne(2 * Je * Je).toRed(this); this.pow(Je, Pt).cmp(xt) !== 0; )
          Je.redIAdd(xt);
        for (var Ot = this.pow(Je, vt), er = this.pow(ve, vt.addn(1).iushrn(1)), sr = this.pow(ve, vt), Jt = wt; sr.cmp($t) !== 0; ) {
          for (var Wt = sr, Gt = 0; Wt.cmp($t) !== 0; Gt++)
            Wt = Wt.redSqr();
          ie(Gt < Jt);
          var rr = this.pow(Ot, new ne(1).iushln(Jt - Gt - 1));
          er = er.redMul(rr), Ot = rr.redSqr(), sr = sr.redMul(Ot), Jt = Gt;
        }
        return er;
      }, Ft.prototype.invm = function(ve) {
        var Ce = ve._invmp(this.m);
        return Ce.negative !== 0 ? (Ce.negative = 0, this.imod(Ce).redNeg()) : this.imod(Ce);
      }, Ft.prototype.pow = function(ve, Ce) {
        if (Ce.isZero()) return new ne(1).toRed(this);
        if (Ce.cmpn(1) === 0) return ve.clone();
        var Qe = 4, vt = new Array(1 << Qe);
        vt[0] = new ne(1).toRed(this), vt[1] = ve;
        for (var wt = 2; wt < vt.length; wt++)
          vt[wt] = this.mul(vt[wt - 1], ve);
        var $t = vt[0], xt = 0, Pt = 0, Je = Ce.bitLength() % 26;
        for (Je === 0 && (Je = 26), wt = Ce.length - 1; wt >= 0; wt--) {
          for (var Ot = Ce.words[wt], er = Je - 1; er >= 0; er--) {
            var sr = Ot >> er & 1;
            if ($t !== vt[0] && ($t = this.sqr($t)), sr === 0 && xt === 0) {
              Pt = 0;
              continue;
            }
            xt <<= 1, xt |= sr, Pt++, !(Pt !== Qe && (wt !== 0 || er !== 0)) && ($t = this.mul($t, vt[xt]), Pt = 0, xt = 0);
          }
          Je = 26;
        }
        return $t;
      }, Ft.prototype.convertTo = function(ve) {
        var Ce = ve.umod(this.m);
        return Ce === ve ? Ce.clone() : Ce;
      }, Ft.prototype.convertFrom = function(ve) {
        var Ce = ve.clone();
        return Ce.red = null, Ce;
      }, ne.mont = function(ve) {
        return new bt(ve);
      };
      function bt(Xe) {
        Ft.call(this, Xe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ne(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      se(bt, Ft), bt.prototype.convertTo = function(ve) {
        return this.imod(ve.ushln(this.shift));
      }, bt.prototype.convertFrom = function(ve) {
        var Ce = this.imod(ve.mul(this.rinv));
        return Ce.red = null, Ce;
      }, bt.prototype.imul = function(ve, Ce) {
        if (ve.isZero() || Ce.isZero())
          return ve.words[0] = 0, ve.length = 1, ve;
        var Qe = ve.imul(Ce), vt = Qe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), wt = Qe.isub(vt).iushrn(this.shift), $t = wt;
        return wt.cmp(this.m) >= 0 ? $t = wt.isub(this.m) : wt.cmpn(0) < 0 && ($t = wt.iadd(this.m)), $t._forceRed(this);
      }, bt.prototype.mul = function(ve, Ce) {
        if (ve.isZero() || Ce.isZero()) return new ne(0)._forceRed(this);
        var Qe = ve.mul(Ce), vt = Qe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), wt = Qe.isub(vt).iushrn(this.shift), $t = wt;
        return wt.cmp(this.m) >= 0 ? $t = wt.isub(this.m) : wt.cmpn(0) < 0 && ($t = wt.iadd(this.m)), $t._forceRed(this);
      }, bt.prototype.invm = function(ve) {
        var Ce = this.imod(ve._invmp(this.m).mul(this.r2));
        return Ce._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa) return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var B = requireBn$1(), z = requireBrowser$b(), Y = safeBufferExports.Buffer;
  function ie(ae) {
    var le = ae.modulus.byteLength(), ge;
    do
      ge = new B(z(le));
    while (ge.cmp(ae.modulus) >= 0 || !ge.umod(ae.prime1) || !ge.umod(ae.prime2));
    return ge;
  }
  function se(ae) {
    var le = ie(ae), ge = le.toRed(B.mont(ae.modulus)).redPow(new B(ae.publicExponent)).fromRed();
    return { blinder: ge, unblinder: le.invm(ae.modulus) };
  }
  function ne(ae, le) {
    var ge = se(le), Ee = le.modulus.byteLength(), oe = new B(ae).mul(ge.blinder).umod(le.modulus), Pe = oe.toRed(B.mont(le.prime1)), Ve = oe.toRed(B.mont(le.prime2)), Ke = le.coefficient, ht = le.prime1, _t = le.prime2, Rt = Pe.redPow(le.exponent1).fromRed(), kt = Ve.redPow(le.exponent2).fromRed(), Bt = Rt.isub(kt).imul(Ke).umod(ht).imul(_t);
    return kt.iadd(Bt).imul(ge.unblinder).umod(le.modulus).toArrayLike(Y, "be", Ee);
  }
  return ne.getr = ie, browserifyRsa = ne, browserifyRsa;
}
var elliptic = {};
const version = "6.6.1", require$$0 = {
  version
};
var utils$3 = {}, utils$2 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(B) {
    var z = B;
    function Y(ne, ae) {
      if (Array.isArray(ne))
        return ne.slice();
      if (!ne)
        return [];
      var le = [];
      if (typeof ne != "string") {
        for (var ge = 0; ge < ne.length; ge++)
          le[ge] = ne[ge] | 0;
        return le;
      }
      if (ae === "hex") {
        ne = ne.replace(/[^a-z0-9]+/ig, ""), ne.length % 2 !== 0 && (ne = "0" + ne);
        for (var ge = 0; ge < ne.length; ge += 2)
          le.push(parseInt(ne[ge] + ne[ge + 1], 16));
      } else
        for (var ge = 0; ge < ne.length; ge++) {
          var Ee = ne.charCodeAt(ge), oe = Ee >> 8, Pe = Ee & 255;
          oe ? le.push(oe, Pe) : le.push(Pe);
        }
      return le;
    }
    z.toArray = Y;
    function ie(ne) {
      return ne.length === 1 ? "0" + ne : ne;
    }
    z.zero2 = ie;
    function se(ne) {
      for (var ae = "", le = 0; le < ne.length; le++)
        ae += ie(ne[le].toString(16));
      return ae;
    }
    z.toHex = se, z.encode = function(ae, le) {
      return le === "hex" ? se(ae) : ae;
    };
  }(utils$2)), utils$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(B) {
    var z = B, Y = requireBn$2(), ie = requireMinimalisticAssert(), se = requireUtils$2();
    z.assert = ie, z.toArray = se.toArray, z.zero2 = se.zero2, z.toHex = se.toHex, z.encode = se.encode;
    function ne(oe, Pe, Ve) {
      var Ke = new Array(Math.max(oe.bitLength(), Ve) + 1), ht;
      for (ht = 0; ht < Ke.length; ht += 1)
        Ke[ht] = 0;
      var _t = 1 << Pe + 1, Rt = oe.clone();
      for (ht = 0; ht < Ke.length; ht++) {
        var kt, Bt = Rt.andln(_t - 1);
        Rt.isOdd() ? (Bt > (_t >> 1) - 1 ? kt = (_t >> 1) - Bt : kt = Bt, Rt.isubn(kt)) : kt = 0, Ke[ht] = kt, Rt.iushrn(1);
      }
      return Ke;
    }
    z.getNAF = ne;
    function ae(oe, Pe) {
      var Ve = [
        [],
        []
      ];
      oe = oe.clone(), Pe = Pe.clone();
      for (var Ke = 0, ht = 0, _t; oe.cmpn(-Ke) > 0 || Pe.cmpn(-ht) > 0; ) {
        var Rt = oe.andln(3) + Ke & 3, kt = Pe.andln(3) + ht & 3;
        Rt === 3 && (Rt = -1), kt === 3 && (kt = -1);
        var Bt;
        Rt & 1 ? (_t = oe.andln(7) + Ke & 7, (_t === 3 || _t === 5) && kt === 2 ? Bt = -Rt : Bt = Rt) : Bt = 0, Ve[0].push(Bt);
        var Ct;
        kt & 1 ? (_t = Pe.andln(7) + ht & 7, (_t === 3 || _t === 5) && Rt === 2 ? Ct = -kt : Ct = kt) : Ct = 0, Ve[1].push(Ct), 2 * Ke === Bt + 1 && (Ke = 1 - Ke), 2 * ht === Ct + 1 && (ht = 1 - ht), oe.iushrn(1), Pe.iushrn(1);
      }
      return Ve;
    }
    z.getJSF = ae;
    function le(oe, Pe, Ve) {
      var Ke = "_" + Pe;
      oe.prototype[Pe] = function() {
        return this[Ke] !== void 0 ? this[Ke] : this[Ke] = Ve.call(this);
      };
    }
    z.cachedProperty = le;
    function ge(oe) {
      return typeof oe == "string" ? z.toArray(oe, "hex") : oe;
    }
    z.parseBytes = ge;
    function Ee(oe) {
      return new Y(oe, "hex", "le");
    }
    z.intFromLE = Ee;
  }(utils$3)), utils$3;
}
var curve = {}, base$3, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1) return base$3;
  hasRequiredBase$1 = 1;
  var B = requireBn$2(), z = requireUtils$1(), Y = z.getNAF, ie = z.getJSF, se = z.assert;
  function ne(le, ge) {
    this.type = le, this.p = new B(ge.p, 16), this.red = ge.prime ? B.red(ge.prime) : B.mont(this.p), this.zero = new B(0).toRed(this.red), this.one = new B(1).toRed(this.red), this.two = new B(2).toRed(this.red), this.n = ge.n && new B(ge.n, 16), this.g = ge.g && this.pointFromJSON(ge.g, ge.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var Ee = this.n && this.p.div(this.n);
    !Ee || Ee.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$3 = ne, ne.prototype.point = function() {
    throw new Error("Not implemented");
  }, ne.prototype.validate = function() {
    throw new Error("Not implemented");
  }, ne.prototype._fixedNafMul = function(ge, Ee) {
    se(ge.precomputed);
    var oe = ge._getDoubles(), Pe = Y(Ee, 1, this._bitLength), Ve = (1 << oe.step + 1) - (oe.step % 2 === 0 ? 2 : 1);
    Ve /= 3;
    var Ke = [], ht, _t;
    for (ht = 0; ht < Pe.length; ht += oe.step) {
      _t = 0;
      for (var Rt = ht + oe.step - 1; Rt >= ht; Rt--)
        _t = (_t << 1) + Pe[Rt];
      Ke.push(_t);
    }
    for (var kt = this.jpoint(null, null, null), Bt = this.jpoint(null, null, null), Ct = Ve; Ct > 0; Ct--) {
      for (ht = 0; ht < Ke.length; ht++)
        _t = Ke[ht], _t === Ct ? Bt = Bt.mixedAdd(oe.points[ht]) : _t === -Ct && (Bt = Bt.mixedAdd(oe.points[ht].neg()));
      kt = kt.add(Bt);
    }
    return kt.toP();
  }, ne.prototype._wnafMul = function(ge, Ee) {
    var oe = 4, Pe = ge._getNAFPoints(oe);
    oe = Pe.wnd;
    for (var Ve = Pe.points, Ke = Y(Ee, oe, this._bitLength), ht = this.jpoint(null, null, null), _t = Ke.length - 1; _t >= 0; _t--) {
      for (var Rt = 0; _t >= 0 && Ke[_t] === 0; _t--)
        Rt++;
      if (_t >= 0 && Rt++, ht = ht.dblp(Rt), _t < 0)
        break;
      var kt = Ke[_t];
      se(kt !== 0), ge.type === "affine" ? kt > 0 ? ht = ht.mixedAdd(Ve[kt - 1 >> 1]) : ht = ht.mixedAdd(Ve[-kt - 1 >> 1].neg()) : kt > 0 ? ht = ht.add(Ve[kt - 1 >> 1]) : ht = ht.add(Ve[-kt - 1 >> 1].neg());
    }
    return ge.type === "affine" ? ht.toP() : ht;
  }, ne.prototype._wnafMulAdd = function(ge, Ee, oe, Pe, Ve) {
    var Ke = this._wnafT1, ht = this._wnafT2, _t = this._wnafT3, Rt = 0, kt, Bt, Ct;
    for (kt = 0; kt < Pe; kt++) {
      Ct = Ee[kt];
      var qt = Ct._getNAFPoints(ge);
      Ke[kt] = qt.wnd, ht[kt] = qt.points;
    }
    for (kt = Pe - 1; kt >= 1; kt -= 2) {
      var jt = kt - 1, Ht = kt;
      if (Ke[jt] !== 1 || Ke[Ht] !== 1) {
        _t[jt] = Y(oe[jt], Ke[jt], this._bitLength), _t[Ht] = Y(oe[Ht], Ke[Ht], this._bitLength), Rt = Math.max(_t[jt].length, Rt), Rt = Math.max(_t[Ht].length, Rt);
        continue;
      }
      var Yt = [
        Ee[jt],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        Ee[Ht]
        /* 7 */
      ];
      Ee[jt].y.cmp(Ee[Ht].y) === 0 ? (Yt[1] = Ee[jt].add(Ee[Ht]), Yt[2] = Ee[jt].toJ().mixedAdd(Ee[Ht].neg())) : Ee[jt].y.cmp(Ee[Ht].y.redNeg()) === 0 ? (Yt[1] = Ee[jt].toJ().mixedAdd(Ee[Ht]), Yt[2] = Ee[jt].add(Ee[Ht].neg())) : (Yt[1] = Ee[jt].toJ().mixedAdd(Ee[Ht]), Yt[2] = Ee[jt].toJ().mixedAdd(Ee[Ht].neg()));
      var Ut = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Nt = ie(oe[jt], oe[Ht]);
      for (Rt = Math.max(Nt[0].length, Rt), _t[jt] = new Array(Rt), _t[Ht] = new Array(Rt), Bt = 0; Bt < Rt; Bt++) {
        var Kt = Nt[0][Bt] | 0, Ft = Nt[1][Bt] | 0;
        _t[jt][Bt] = Ut[(Kt + 1) * 3 + (Ft + 1)], _t[Ht][Bt] = 0, ht[jt] = Yt;
      }
    }
    var bt = this.jpoint(null, null, null), Xe = this._wnafT4;
    for (kt = Rt; kt >= 0; kt--) {
      for (var ve = 0; kt >= 0; ) {
        var Ce = !0;
        for (Bt = 0; Bt < Pe; Bt++)
          Xe[Bt] = _t[Bt][kt] | 0, Xe[Bt] !== 0 && (Ce = !1);
        if (!Ce)
          break;
        ve++, kt--;
      }
      if (kt >= 0 && ve++, bt = bt.dblp(ve), kt < 0)
        break;
      for (Bt = 0; Bt < Pe; Bt++) {
        var Qe = Xe[Bt];
        Qe !== 0 && (Qe > 0 ? Ct = ht[Bt][Qe - 1 >> 1] : Qe < 0 && (Ct = ht[Bt][-Qe - 1 >> 1].neg()), Ct.type === "affine" ? bt = bt.mixedAdd(Ct) : bt = bt.add(Ct));
      }
    }
    for (kt = 0; kt < Pe; kt++)
      ht[kt] = null;
    return Ve ? bt : bt.toP();
  };
  function ae(le, ge) {
    this.curve = le, this.type = ge, this.precomputed = null;
  }
  return ne.BasePoint = ae, ae.prototype.eq = function() {
    throw new Error("Not implemented");
  }, ae.prototype.validate = function() {
    return this.curve.validate(this);
  }, ne.prototype.decodePoint = function(ge, Ee) {
    ge = z.toArray(ge, Ee);
    var oe = this.p.byteLength();
    if ((ge[0] === 4 || ge[0] === 6 || ge[0] === 7) && ge.length - 1 === 2 * oe) {
      ge[0] === 6 ? se(ge[ge.length - 1] % 2 === 0) : ge[0] === 7 && se(ge[ge.length - 1] % 2 === 1);
      var Pe = this.point(
        ge.slice(1, 1 + oe),
        ge.slice(1 + oe, 1 + 2 * oe)
      );
      return Pe;
    } else if ((ge[0] === 2 || ge[0] === 3) && ge.length - 1 === oe)
      return this.pointFromX(ge.slice(1, 1 + oe), ge[0] === 3);
    throw new Error("Unknown point format");
  }, ae.prototype.encodeCompressed = function(ge) {
    return this.encode(ge, !0);
  }, ae.prototype._encode = function(ge) {
    var Ee = this.curve.p.byteLength(), oe = this.getX().toArray("be", Ee);
    return ge ? [this.getY().isEven() ? 2 : 3].concat(oe) : [4].concat(oe, this.getY().toArray("be", Ee));
  }, ae.prototype.encode = function(ge, Ee) {
    return z.encode(this._encode(Ee), ge);
  }, ae.prototype.precompute = function(ge) {
    if (this.precomputed)
      return this;
    var Ee = {
      doubles: null,
      naf: null,
      beta: null
    };
    return Ee.naf = this._getNAFPoints(8), Ee.doubles = this._getDoubles(4, ge), Ee.beta = this._getBeta(), this.precomputed = Ee, this;
  }, ae.prototype._hasDoubles = function(ge) {
    if (!this.precomputed)
      return !1;
    var Ee = this.precomputed.doubles;
    return Ee ? Ee.points.length >= Math.ceil((ge.bitLength() + 1) / Ee.step) : !1;
  }, ae.prototype._getDoubles = function(ge, Ee) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var oe = [this], Pe = this, Ve = 0; Ve < Ee; Ve += ge) {
      for (var Ke = 0; Ke < ge; Ke++)
        Pe = Pe.dbl();
      oe.push(Pe);
    }
    return {
      step: ge,
      points: oe
    };
  }, ae.prototype._getNAFPoints = function(ge) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var Ee = [this], oe = (1 << ge) - 1, Pe = oe === 1 ? null : this.dbl(), Ve = 1; Ve < oe; Ve++)
      Ee[Ve] = Ee[Ve - 1].add(Pe);
    return {
      wnd: ge,
      points: Ee
    };
  }, ae.prototype._getBeta = function() {
    return null;
  }, ae.prototype.dblp = function(ge) {
    for (var Ee = this, oe = 0; oe < ge; oe++)
      Ee = Ee.dbl();
    return Ee;
  }, base$3;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort) return short;
  hasRequiredShort = 1;
  var B = requireUtils$1(), z = requireBn$2(), Y = requireInherits_browser(), ie = requireBase$1(), se = B.assert;
  function ne(ge) {
    ie.call(this, "short", ge), this.a = new z(ge.a, 16).toRed(this.red), this.b = new z(ge.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(ge), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  Y(ne, ie), short = ne, ne.prototype._getEndomorphism = function(Ee) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var oe, Pe;
      if (Ee.beta)
        oe = new z(Ee.beta, 16).toRed(this.red);
      else {
        var Ve = this._getEndoRoots(this.p);
        oe = Ve[0].cmp(Ve[1]) < 0 ? Ve[0] : Ve[1], oe = oe.toRed(this.red);
      }
      if (Ee.lambda)
        Pe = new z(Ee.lambda, 16);
      else {
        var Ke = this._getEndoRoots(this.n);
        this.g.mul(Ke[0]).x.cmp(this.g.x.redMul(oe)) === 0 ? Pe = Ke[0] : (Pe = Ke[1], se(this.g.mul(Pe).x.cmp(this.g.x.redMul(oe)) === 0));
      }
      var ht;
      return Ee.basis ? ht = Ee.basis.map(function(_t) {
        return {
          a: new z(_t.a, 16),
          b: new z(_t.b, 16)
        };
      }) : ht = this._getEndoBasis(Pe), {
        beta: oe,
        lambda: Pe,
        basis: ht
      };
    }
  }, ne.prototype._getEndoRoots = function(Ee) {
    var oe = Ee === this.p ? this.red : z.mont(Ee), Pe = new z(2).toRed(oe).redInvm(), Ve = Pe.redNeg(), Ke = new z(3).toRed(oe).redNeg().redSqrt().redMul(Pe), ht = Ve.redAdd(Ke).fromRed(), _t = Ve.redSub(Ke).fromRed();
    return [ht, _t];
  }, ne.prototype._getEndoBasis = function(Ee) {
    for (var oe = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), Pe = Ee, Ve = this.n.clone(), Ke = new z(1), ht = new z(0), _t = new z(0), Rt = new z(1), kt, Bt, Ct, qt, jt, Ht, Yt, Ut = 0, Nt, Kt; Pe.cmpn(0) !== 0; ) {
      var Ft = Ve.div(Pe);
      Nt = Ve.sub(Ft.mul(Pe)), Kt = _t.sub(Ft.mul(Ke));
      var bt = Rt.sub(Ft.mul(ht));
      if (!Ct && Nt.cmp(oe) < 0)
        kt = Yt.neg(), Bt = Ke, Ct = Nt.neg(), qt = Kt;
      else if (Ct && ++Ut === 2)
        break;
      Yt = Nt, Ve = Pe, Pe = Nt, _t = Ke, Ke = Kt, Rt = ht, ht = bt;
    }
    jt = Nt.neg(), Ht = Kt;
    var Xe = Ct.sqr().add(qt.sqr()), ve = jt.sqr().add(Ht.sqr());
    return ve.cmp(Xe) >= 0 && (jt = kt, Ht = Bt), Ct.negative && (Ct = Ct.neg(), qt = qt.neg()), jt.negative && (jt = jt.neg(), Ht = Ht.neg()), [
      { a: Ct, b: qt },
      { a: jt, b: Ht }
    ];
  }, ne.prototype._endoSplit = function(Ee) {
    var oe = this.endo.basis, Pe = oe[0], Ve = oe[1], Ke = Ve.b.mul(Ee).divRound(this.n), ht = Pe.b.neg().mul(Ee).divRound(this.n), _t = Ke.mul(Pe.a), Rt = ht.mul(Ve.a), kt = Ke.mul(Pe.b), Bt = ht.mul(Ve.b), Ct = Ee.sub(_t).sub(Rt), qt = kt.add(Bt).neg();
    return { k1: Ct, k2: qt };
  }, ne.prototype.pointFromX = function(Ee, oe) {
    Ee = new z(Ee, 16), Ee.red || (Ee = Ee.toRed(this.red));
    var Pe = Ee.redSqr().redMul(Ee).redIAdd(Ee.redMul(this.a)).redIAdd(this.b), Ve = Pe.redSqrt();
    if (Ve.redSqr().redSub(Pe).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Ke = Ve.fromRed().isOdd();
    return (oe && !Ke || !oe && Ke) && (Ve = Ve.redNeg()), this.point(Ee, Ve);
  }, ne.prototype.validate = function(Ee) {
    if (Ee.inf)
      return !0;
    var oe = Ee.x, Pe = Ee.y, Ve = this.a.redMul(oe), Ke = oe.redSqr().redMul(oe).redIAdd(Ve).redIAdd(this.b);
    return Pe.redSqr().redISub(Ke).cmpn(0) === 0;
  }, ne.prototype._endoWnafMulAdd = function(Ee, oe, Pe) {
    for (var Ve = this._endoWnafT1, Ke = this._endoWnafT2, ht = 0; ht < Ee.length; ht++) {
      var _t = this._endoSplit(oe[ht]), Rt = Ee[ht], kt = Rt._getBeta();
      _t.k1.negative && (_t.k1.ineg(), Rt = Rt.neg(!0)), _t.k2.negative && (_t.k2.ineg(), kt = kt.neg(!0)), Ve[ht * 2] = Rt, Ve[ht * 2 + 1] = kt, Ke[ht * 2] = _t.k1, Ke[ht * 2 + 1] = _t.k2;
    }
    for (var Bt = this._wnafMulAdd(1, Ve, Ke, ht * 2, Pe), Ct = 0; Ct < ht * 2; Ct++)
      Ve[Ct] = null, Ke[Ct] = null;
    return Bt;
  };
  function ae(ge, Ee, oe, Pe) {
    ie.BasePoint.call(this, ge, "affine"), Ee === null && oe === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new z(Ee, 16), this.y = new z(oe, 16), Pe && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  Y(ae, ie.BasePoint), ne.prototype.point = function(Ee, oe, Pe) {
    return new ae(this, Ee, oe, Pe);
  }, ne.prototype.pointFromJSON = function(Ee, oe) {
    return ae.fromJSON(this, Ee, oe);
  }, ae.prototype._getBeta = function() {
    if (this.curve.endo) {
      var Ee = this.precomputed;
      if (Ee && Ee.beta)
        return Ee.beta;
      var oe = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (Ee) {
        var Pe = this.curve, Ve = function(Ke) {
          return Pe.point(Ke.x.redMul(Pe.endo.beta), Ke.y);
        };
        Ee.beta = oe, oe.precomputed = {
          beta: null,
          naf: Ee.naf && {
            wnd: Ee.naf.wnd,
            points: Ee.naf.points.map(Ve)
          },
          doubles: Ee.doubles && {
            step: Ee.doubles.step,
            points: Ee.doubles.points.map(Ve)
          }
        };
      }
      return oe;
    }
  }, ae.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, ae.fromJSON = function(Ee, oe, Pe) {
    typeof oe == "string" && (oe = JSON.parse(oe));
    var Ve = Ee.point(oe[0], oe[1], Pe);
    if (!oe[2])
      return Ve;
    function Ke(_t) {
      return Ee.point(_t[0], _t[1], Pe);
    }
    var ht = oe[2];
    return Ve.precomputed = {
      beta: null,
      doubles: ht.doubles && {
        step: ht.doubles.step,
        points: [Ve].concat(ht.doubles.points.map(Ke))
      },
      naf: ht.naf && {
        wnd: ht.naf.wnd,
        points: [Ve].concat(ht.naf.points.map(Ke))
      }
    }, Ve;
  }, ae.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, ae.prototype.isInfinity = function() {
    return this.inf;
  }, ae.prototype.add = function(Ee) {
    if (this.inf)
      return Ee;
    if (Ee.inf)
      return this;
    if (this.eq(Ee))
      return this.dbl();
    if (this.neg().eq(Ee))
      return this.curve.point(null, null);
    if (this.x.cmp(Ee.x) === 0)
      return this.curve.point(null, null);
    var oe = this.y.redSub(Ee.y);
    oe.cmpn(0) !== 0 && (oe = oe.redMul(this.x.redSub(Ee.x).redInvm()));
    var Pe = oe.redSqr().redISub(this.x).redISub(Ee.x), Ve = oe.redMul(this.x.redSub(Pe)).redISub(this.y);
    return this.curve.point(Pe, Ve);
  }, ae.prototype.dbl = function() {
    if (this.inf)
      return this;
    var Ee = this.y.redAdd(this.y);
    if (Ee.cmpn(0) === 0)
      return this.curve.point(null, null);
    var oe = this.curve.a, Pe = this.x.redSqr(), Ve = Ee.redInvm(), Ke = Pe.redAdd(Pe).redIAdd(Pe).redIAdd(oe).redMul(Ve), ht = Ke.redSqr().redISub(this.x.redAdd(this.x)), _t = Ke.redMul(this.x.redSub(ht)).redISub(this.y);
    return this.curve.point(ht, _t);
  }, ae.prototype.getX = function() {
    return this.x.fromRed();
  }, ae.prototype.getY = function() {
    return this.y.fromRed();
  }, ae.prototype.mul = function(Ee) {
    return Ee = new z(Ee, 16), this.isInfinity() ? this : this._hasDoubles(Ee) ? this.curve._fixedNafMul(this, Ee) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [Ee]) : this.curve._wnafMul(this, Ee);
  }, ae.prototype.mulAdd = function(Ee, oe, Pe) {
    var Ve = [this, oe], Ke = [Ee, Pe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ve, Ke) : this.curve._wnafMulAdd(1, Ve, Ke, 2);
  }, ae.prototype.jmulAdd = function(Ee, oe, Pe) {
    var Ve = [this, oe], Ke = [Ee, Pe];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Ve, Ke, !0) : this.curve._wnafMulAdd(1, Ve, Ke, 2, !0);
  }, ae.prototype.eq = function(Ee) {
    return this === Ee || this.inf === Ee.inf && (this.inf || this.x.cmp(Ee.x) === 0 && this.y.cmp(Ee.y) === 0);
  }, ae.prototype.neg = function(Ee) {
    if (this.inf)
      return this;
    var oe = this.curve.point(this.x, this.y.redNeg());
    if (Ee && this.precomputed) {
      var Pe = this.precomputed, Ve = function(Ke) {
        return Ke.neg();
      };
      oe.precomputed = {
        naf: Pe.naf && {
          wnd: Pe.naf.wnd,
          points: Pe.naf.points.map(Ve)
        },
        doubles: Pe.doubles && {
          step: Pe.doubles.step,
          points: Pe.doubles.points.map(Ve)
        }
      };
    }
    return oe;
  }, ae.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var Ee = this.curve.jpoint(this.x, this.y, this.curve.one);
    return Ee;
  };
  function le(ge, Ee, oe, Pe) {
    ie.BasePoint.call(this, ge, "jacobian"), Ee === null && oe === null && Pe === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new z(0)) : (this.x = new z(Ee, 16), this.y = new z(oe, 16), this.z = new z(Pe, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return Y(le, ie.BasePoint), ne.prototype.jpoint = function(Ee, oe, Pe) {
    return new le(this, Ee, oe, Pe);
  }, le.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var Ee = this.z.redInvm(), oe = Ee.redSqr(), Pe = this.x.redMul(oe), Ve = this.y.redMul(oe).redMul(Ee);
    return this.curve.point(Pe, Ve);
  }, le.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, le.prototype.add = function(Ee) {
    if (this.isInfinity())
      return Ee;
    if (Ee.isInfinity())
      return this;
    var oe = Ee.z.redSqr(), Pe = this.z.redSqr(), Ve = this.x.redMul(oe), Ke = Ee.x.redMul(Pe), ht = this.y.redMul(oe.redMul(Ee.z)), _t = Ee.y.redMul(Pe.redMul(this.z)), Rt = Ve.redSub(Ke), kt = ht.redSub(_t);
    if (Rt.cmpn(0) === 0)
      return kt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var Bt = Rt.redSqr(), Ct = Bt.redMul(Rt), qt = Ve.redMul(Bt), jt = kt.redSqr().redIAdd(Ct).redISub(qt).redISub(qt), Ht = kt.redMul(qt.redISub(jt)).redISub(ht.redMul(Ct)), Yt = this.z.redMul(Ee.z).redMul(Rt);
    return this.curve.jpoint(jt, Ht, Yt);
  }, le.prototype.mixedAdd = function(Ee) {
    if (this.isInfinity())
      return Ee.toJ();
    if (Ee.isInfinity())
      return this;
    var oe = this.z.redSqr(), Pe = this.x, Ve = Ee.x.redMul(oe), Ke = this.y, ht = Ee.y.redMul(oe).redMul(this.z), _t = Pe.redSub(Ve), Rt = Ke.redSub(ht);
    if (_t.cmpn(0) === 0)
      return Rt.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var kt = _t.redSqr(), Bt = kt.redMul(_t), Ct = Pe.redMul(kt), qt = Rt.redSqr().redIAdd(Bt).redISub(Ct).redISub(Ct), jt = Rt.redMul(Ct.redISub(qt)).redISub(Ke.redMul(Bt)), Ht = this.z.redMul(_t);
    return this.curve.jpoint(qt, jt, Ht);
  }, le.prototype.dblp = function(Ee) {
    if (Ee === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!Ee)
      return this.dbl();
    var oe;
    if (this.curve.zeroA || this.curve.threeA) {
      var Pe = this;
      for (oe = 0; oe < Ee; oe++)
        Pe = Pe.dbl();
      return Pe;
    }
    var Ve = this.curve.a, Ke = this.curve.tinv, ht = this.x, _t = this.y, Rt = this.z, kt = Rt.redSqr().redSqr(), Bt = _t.redAdd(_t);
    for (oe = 0; oe < Ee; oe++) {
      var Ct = ht.redSqr(), qt = Bt.redSqr(), jt = qt.redSqr(), Ht = Ct.redAdd(Ct).redIAdd(Ct).redIAdd(Ve.redMul(kt)), Yt = ht.redMul(qt), Ut = Ht.redSqr().redISub(Yt.redAdd(Yt)), Nt = Yt.redISub(Ut), Kt = Ht.redMul(Nt);
      Kt = Kt.redIAdd(Kt).redISub(jt);
      var Ft = Bt.redMul(Rt);
      oe + 1 < Ee && (kt = kt.redMul(jt)), ht = Ut, Rt = Ft, Bt = Kt;
    }
    return this.curve.jpoint(ht, Bt.redMul(Ke), Rt);
  }, le.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, le.prototype._zeroDbl = function() {
    var Ee, oe, Pe;
    if (this.zOne) {
      var Ve = this.x.redSqr(), Ke = this.y.redSqr(), ht = Ke.redSqr(), _t = this.x.redAdd(Ke).redSqr().redISub(Ve).redISub(ht);
      _t = _t.redIAdd(_t);
      var Rt = Ve.redAdd(Ve).redIAdd(Ve), kt = Rt.redSqr().redISub(_t).redISub(_t), Bt = ht.redIAdd(ht);
      Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt), Ee = kt, oe = Rt.redMul(_t.redISub(kt)).redISub(Bt), Pe = this.y.redAdd(this.y);
    } else {
      var Ct = this.x.redSqr(), qt = this.y.redSqr(), jt = qt.redSqr(), Ht = this.x.redAdd(qt).redSqr().redISub(Ct).redISub(jt);
      Ht = Ht.redIAdd(Ht);
      var Yt = Ct.redAdd(Ct).redIAdd(Ct), Ut = Yt.redSqr(), Nt = jt.redIAdd(jt);
      Nt = Nt.redIAdd(Nt), Nt = Nt.redIAdd(Nt), Ee = Ut.redISub(Ht).redISub(Ht), oe = Yt.redMul(Ht.redISub(Ee)).redISub(Nt), Pe = this.y.redMul(this.z), Pe = Pe.redIAdd(Pe);
    }
    return this.curve.jpoint(Ee, oe, Pe);
  }, le.prototype._threeDbl = function() {
    var Ee, oe, Pe;
    if (this.zOne) {
      var Ve = this.x.redSqr(), Ke = this.y.redSqr(), ht = Ke.redSqr(), _t = this.x.redAdd(Ke).redSqr().redISub(Ve).redISub(ht);
      _t = _t.redIAdd(_t);
      var Rt = Ve.redAdd(Ve).redIAdd(Ve).redIAdd(this.curve.a), kt = Rt.redSqr().redISub(_t).redISub(_t);
      Ee = kt;
      var Bt = ht.redIAdd(ht);
      Bt = Bt.redIAdd(Bt), Bt = Bt.redIAdd(Bt), oe = Rt.redMul(_t.redISub(kt)).redISub(Bt), Pe = this.y.redAdd(this.y);
    } else {
      var Ct = this.z.redSqr(), qt = this.y.redSqr(), jt = this.x.redMul(qt), Ht = this.x.redSub(Ct).redMul(this.x.redAdd(Ct));
      Ht = Ht.redAdd(Ht).redIAdd(Ht);
      var Yt = jt.redIAdd(jt);
      Yt = Yt.redIAdd(Yt);
      var Ut = Yt.redAdd(Yt);
      Ee = Ht.redSqr().redISub(Ut), Pe = this.y.redAdd(this.z).redSqr().redISub(qt).redISub(Ct);
      var Nt = qt.redSqr();
      Nt = Nt.redIAdd(Nt), Nt = Nt.redIAdd(Nt), Nt = Nt.redIAdd(Nt), oe = Ht.redMul(Yt.redISub(Ee)).redISub(Nt);
    }
    return this.curve.jpoint(Ee, oe, Pe);
  }, le.prototype._dbl = function() {
    var Ee = this.curve.a, oe = this.x, Pe = this.y, Ve = this.z, Ke = Ve.redSqr().redSqr(), ht = oe.redSqr(), _t = Pe.redSqr(), Rt = ht.redAdd(ht).redIAdd(ht).redIAdd(Ee.redMul(Ke)), kt = oe.redAdd(oe);
    kt = kt.redIAdd(kt);
    var Bt = kt.redMul(_t), Ct = Rt.redSqr().redISub(Bt.redAdd(Bt)), qt = Bt.redISub(Ct), jt = _t.redSqr();
    jt = jt.redIAdd(jt), jt = jt.redIAdd(jt), jt = jt.redIAdd(jt);
    var Ht = Rt.redMul(qt).redISub(jt), Yt = Pe.redAdd(Pe).redMul(Ve);
    return this.curve.jpoint(Ct, Ht, Yt);
  }, le.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var Ee = this.x.redSqr(), oe = this.y.redSqr(), Pe = this.z.redSqr(), Ve = oe.redSqr(), Ke = Ee.redAdd(Ee).redIAdd(Ee), ht = Ke.redSqr(), _t = this.x.redAdd(oe).redSqr().redISub(Ee).redISub(Ve);
    _t = _t.redIAdd(_t), _t = _t.redAdd(_t).redIAdd(_t), _t = _t.redISub(ht);
    var Rt = _t.redSqr(), kt = Ve.redIAdd(Ve);
    kt = kt.redIAdd(kt), kt = kt.redIAdd(kt), kt = kt.redIAdd(kt);
    var Bt = Ke.redIAdd(_t).redSqr().redISub(ht).redISub(Rt).redISub(kt), Ct = oe.redMul(Bt);
    Ct = Ct.redIAdd(Ct), Ct = Ct.redIAdd(Ct);
    var qt = this.x.redMul(Rt).redISub(Ct);
    qt = qt.redIAdd(qt), qt = qt.redIAdd(qt);
    var jt = this.y.redMul(Bt.redMul(kt.redISub(Bt)).redISub(_t.redMul(Rt)));
    jt = jt.redIAdd(jt), jt = jt.redIAdd(jt), jt = jt.redIAdd(jt);
    var Ht = this.z.redAdd(_t).redSqr().redISub(Pe).redISub(Rt);
    return this.curve.jpoint(qt, jt, Ht);
  }, le.prototype.mul = function(Ee, oe) {
    return Ee = new z(Ee, oe), this.curve._wnafMul(this, Ee);
  }, le.prototype.eq = function(Ee) {
    if (Ee.type === "affine")
      return this.eq(Ee.toJ());
    if (this === Ee)
      return !0;
    var oe = this.z.redSqr(), Pe = Ee.z.redSqr();
    if (this.x.redMul(Pe).redISub(Ee.x.redMul(oe)).cmpn(0) !== 0)
      return !1;
    var Ve = oe.redMul(this.z), Ke = Pe.redMul(Ee.z);
    return this.y.redMul(Ke).redISub(Ee.y.redMul(Ve)).cmpn(0) === 0;
  }, le.prototype.eqXToP = function(Ee) {
    var oe = this.z.redSqr(), Pe = Ee.toRed(this.curve.red).redMul(oe);
    if (this.x.cmp(Pe) === 0)
      return !0;
    for (var Ve = Ee.clone(), Ke = this.curve.redN.redMul(oe); ; ) {
      if (Ve.iadd(this.curve.n), Ve.cmp(this.curve.p) >= 0)
        return !1;
      if (Pe.redIAdd(Ke), this.x.cmp(Pe) === 0)
        return !0;
    }
  }, le.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, le.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont) return mont;
  hasRequiredMont = 1;
  var B = requireBn$2(), z = requireInherits_browser(), Y = requireBase$1(), ie = requireUtils$1();
  function se(ae) {
    Y.call(this, "mont", ae), this.a = new B(ae.a, 16).toRed(this.red), this.b = new B(ae.b, 16).toRed(this.red), this.i4 = new B(4).toRed(this.red).redInvm(), this.two = new B(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  z(se, Y), mont = se, se.prototype.validate = function(le) {
    var ge = le.normalize().x, Ee = ge.redSqr(), oe = Ee.redMul(ge).redAdd(Ee.redMul(this.a)).redAdd(ge), Pe = oe.redSqrt();
    return Pe.redSqr().cmp(oe) === 0;
  };
  function ne(ae, le, ge) {
    Y.BasePoint.call(this, ae, "projective"), le === null && ge === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new B(le, 16), this.z = new B(ge, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return z(ne, Y.BasePoint), se.prototype.decodePoint = function(le, ge) {
    return this.point(ie.toArray(le, ge), 1);
  }, se.prototype.point = function(le, ge) {
    return new ne(this, le, ge);
  }, se.prototype.pointFromJSON = function(le) {
    return ne.fromJSON(this, le);
  }, ne.prototype.precompute = function() {
  }, ne.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, ne.fromJSON = function(le, ge) {
    return new ne(le, ge[0], ge[1] || le.one);
  }, ne.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, ne.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, ne.prototype.dbl = function() {
    var le = this.x.redAdd(this.z), ge = le.redSqr(), Ee = this.x.redSub(this.z), oe = Ee.redSqr(), Pe = ge.redSub(oe), Ve = ge.redMul(oe), Ke = Pe.redMul(oe.redAdd(this.curve.a24.redMul(Pe)));
    return this.curve.point(Ve, Ke);
  }, ne.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ne.prototype.diffAdd = function(le, ge) {
    var Ee = this.x.redAdd(this.z), oe = this.x.redSub(this.z), Pe = le.x.redAdd(le.z), Ve = le.x.redSub(le.z), Ke = Ve.redMul(Ee), ht = Pe.redMul(oe), _t = ge.z.redMul(Ke.redAdd(ht).redSqr()), Rt = ge.x.redMul(Ke.redISub(ht).redSqr());
    return this.curve.point(_t, Rt);
  }, ne.prototype.mul = function(le) {
    for (var ge = le.clone(), Ee = this, oe = this.curve.point(null, null), Pe = this, Ve = []; ge.cmpn(0) !== 0; ge.iushrn(1))
      Ve.push(ge.andln(1));
    for (var Ke = Ve.length - 1; Ke >= 0; Ke--)
      Ve[Ke] === 0 ? (Ee = Ee.diffAdd(oe, Pe), oe = oe.dbl()) : (oe = Ee.diffAdd(oe, Pe), Ee = Ee.dbl());
    return oe;
  }, ne.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ne.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, ne.prototype.eq = function(le) {
    return this.getX().cmp(le.getX()) === 0;
  }, ne.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, ne.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards) return edwards;
  hasRequiredEdwards = 1;
  var B = requireUtils$1(), z = requireBn$2(), Y = requireInherits_browser(), ie = requireBase$1(), se = B.assert;
  function ne(le) {
    this.twisted = (le.a | 0) !== 1, this.mOneA = this.twisted && (le.a | 0) === -1, this.extended = this.mOneA, ie.call(this, "edwards", le), this.a = new z(le.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new z(le.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new z(le.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), se(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (le.c | 0) === 1;
  }
  Y(ne, ie), edwards = ne, ne.prototype._mulA = function(ge) {
    return this.mOneA ? ge.redNeg() : this.a.redMul(ge);
  }, ne.prototype._mulC = function(ge) {
    return this.oneC ? ge : this.c.redMul(ge);
  }, ne.prototype.jpoint = function(ge, Ee, oe, Pe) {
    return this.point(ge, Ee, oe, Pe);
  }, ne.prototype.pointFromX = function(ge, Ee) {
    ge = new z(ge, 16), ge.red || (ge = ge.toRed(this.red));
    var oe = ge.redSqr(), Pe = this.c2.redSub(this.a.redMul(oe)), Ve = this.one.redSub(this.c2.redMul(this.d).redMul(oe)), Ke = Pe.redMul(Ve.redInvm()), ht = Ke.redSqrt();
    if (ht.redSqr().redSub(Ke).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var _t = ht.fromRed().isOdd();
    return (Ee && !_t || !Ee && _t) && (ht = ht.redNeg()), this.point(ge, ht);
  }, ne.prototype.pointFromY = function(ge, Ee) {
    ge = new z(ge, 16), ge.red || (ge = ge.toRed(this.red));
    var oe = ge.redSqr(), Pe = oe.redSub(this.c2), Ve = oe.redMul(this.d).redMul(this.c2).redSub(this.a), Ke = Pe.redMul(Ve.redInvm());
    if (Ke.cmp(this.zero) === 0) {
      if (Ee)
        throw new Error("invalid point");
      return this.point(this.zero, ge);
    }
    var ht = Ke.redSqrt();
    if (ht.redSqr().redSub(Ke).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return ht.fromRed().isOdd() !== Ee && (ht = ht.redNeg()), this.point(ht, ge);
  }, ne.prototype.validate = function(ge) {
    if (ge.isInfinity())
      return !0;
    ge.normalize();
    var Ee = ge.x.redSqr(), oe = ge.y.redSqr(), Pe = Ee.redMul(this.a).redAdd(oe), Ve = this.c2.redMul(this.one.redAdd(this.d.redMul(Ee).redMul(oe)));
    return Pe.cmp(Ve) === 0;
  };
  function ae(le, ge, Ee, oe, Pe) {
    ie.BasePoint.call(this, le, "projective"), ge === null && Ee === null && oe === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new z(ge, 16), this.y = new z(Ee, 16), this.z = oe ? new z(oe, 16) : this.curve.one, this.t = Pe && new z(Pe, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return Y(ae, ie.BasePoint), ne.prototype.pointFromJSON = function(ge) {
    return ae.fromJSON(this, ge);
  }, ne.prototype.point = function(ge, Ee, oe, Pe) {
    return new ae(this, ge, Ee, oe, Pe);
  }, ae.fromJSON = function(ge, Ee) {
    return new ae(ge, Ee[0], Ee[1], Ee[2]);
  }, ae.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, ae.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, ae.prototype._extDbl = function() {
    var ge = this.x.redSqr(), Ee = this.y.redSqr(), oe = this.z.redSqr();
    oe = oe.redIAdd(oe);
    var Pe = this.curve._mulA(ge), Ve = this.x.redAdd(this.y).redSqr().redISub(ge).redISub(Ee), Ke = Pe.redAdd(Ee), ht = Ke.redSub(oe), _t = Pe.redSub(Ee), Rt = Ve.redMul(ht), kt = Ke.redMul(_t), Bt = Ve.redMul(_t), Ct = ht.redMul(Ke);
    return this.curve.point(Rt, kt, Ct, Bt);
  }, ae.prototype._projDbl = function() {
    var ge = this.x.redAdd(this.y).redSqr(), Ee = this.x.redSqr(), oe = this.y.redSqr(), Pe, Ve, Ke, ht, _t, Rt;
    if (this.curve.twisted) {
      ht = this.curve._mulA(Ee);
      var kt = ht.redAdd(oe);
      this.zOne ? (Pe = ge.redSub(Ee).redSub(oe).redMul(kt.redSub(this.curve.two)), Ve = kt.redMul(ht.redSub(oe)), Ke = kt.redSqr().redSub(kt).redSub(kt)) : (_t = this.z.redSqr(), Rt = kt.redSub(_t).redISub(_t), Pe = ge.redSub(Ee).redISub(oe).redMul(Rt), Ve = kt.redMul(ht.redSub(oe)), Ke = kt.redMul(Rt));
    } else
      ht = Ee.redAdd(oe), _t = this.curve._mulC(this.z).redSqr(), Rt = ht.redSub(_t).redSub(_t), Pe = this.curve._mulC(ge.redISub(ht)).redMul(Rt), Ve = this.curve._mulC(ht).redMul(Ee.redISub(oe)), Ke = ht.redMul(Rt);
    return this.curve.point(Pe, Ve, Ke);
  }, ae.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, ae.prototype._extAdd = function(ge) {
    var Ee = this.y.redSub(this.x).redMul(ge.y.redSub(ge.x)), oe = this.y.redAdd(this.x).redMul(ge.y.redAdd(ge.x)), Pe = this.t.redMul(this.curve.dd).redMul(ge.t), Ve = this.z.redMul(ge.z.redAdd(ge.z)), Ke = oe.redSub(Ee), ht = Ve.redSub(Pe), _t = Ve.redAdd(Pe), Rt = oe.redAdd(Ee), kt = Ke.redMul(ht), Bt = _t.redMul(Rt), Ct = Ke.redMul(Rt), qt = ht.redMul(_t);
    return this.curve.point(kt, Bt, qt, Ct);
  }, ae.prototype._projAdd = function(ge) {
    var Ee = this.z.redMul(ge.z), oe = Ee.redSqr(), Pe = this.x.redMul(ge.x), Ve = this.y.redMul(ge.y), Ke = this.curve.d.redMul(Pe).redMul(Ve), ht = oe.redSub(Ke), _t = oe.redAdd(Ke), Rt = this.x.redAdd(this.y).redMul(ge.x.redAdd(ge.y)).redISub(Pe).redISub(Ve), kt = Ee.redMul(ht).redMul(Rt), Bt, Ct;
    return this.curve.twisted ? (Bt = Ee.redMul(_t).redMul(Ve.redSub(this.curve._mulA(Pe))), Ct = ht.redMul(_t)) : (Bt = Ee.redMul(_t).redMul(Ve.redSub(Pe)), Ct = this.curve._mulC(ht).redMul(_t)), this.curve.point(kt, Bt, Ct);
  }, ae.prototype.add = function(ge) {
    return this.isInfinity() ? ge : ge.isInfinity() ? this : this.curve.extended ? this._extAdd(ge) : this._projAdd(ge);
  }, ae.prototype.mul = function(ge) {
    return this._hasDoubles(ge) ? this.curve._fixedNafMul(this, ge) : this.curve._wnafMul(this, ge);
  }, ae.prototype.mulAdd = function(ge, Ee, oe) {
    return this.curve._wnafMulAdd(1, [this, Ee], [ge, oe], 2, !1);
  }, ae.prototype.jmulAdd = function(ge, Ee, oe) {
    return this.curve._wnafMulAdd(1, [this, Ee], [ge, oe], 2, !0);
  }, ae.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var ge = this.z.redInvm();
    return this.x = this.x.redMul(ge), this.y = this.y.redMul(ge), this.t && (this.t = this.t.redMul(ge)), this.z = this.curve.one, this.zOne = !0, this;
  }, ae.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, ae.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, ae.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, ae.prototype.eq = function(ge) {
    return this === ge || this.getX().cmp(ge.getX()) === 0 && this.getY().cmp(ge.getY()) === 0;
  }, ae.prototype.eqXToP = function(ge) {
    var Ee = ge.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(Ee) === 0)
      return !0;
    for (var oe = ge.clone(), Pe = this.curve.redN.redMul(this.z); ; ) {
      if (oe.iadd(this.curve.n), oe.cmp(this.curve.p) >= 0)
        return !1;
      if (Ee.redIAdd(Pe), this.x.cmp(Ee) === 0)
        return !0;
    }
  }, ae.prototype.toP = ae.prototype.normalize, ae.prototype.mixedAdd = ae.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(B) {
    var z = B;
    z.base = requireBase$1(), z.short = requireShort(), z.mont = requireMont(), z.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils$1 = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$1;
  hasRequiredUtils = 1;
  var B = requireMinimalisticAssert(), z = requireInherits_browser();
  utils$1.inherits = z;
  function Y(bt, Xe) {
    return (bt.charCodeAt(Xe) & 64512) !== 55296 || Xe < 0 || Xe + 1 >= bt.length ? !1 : (bt.charCodeAt(Xe + 1) & 64512) === 56320;
  }
  function ie(bt, Xe) {
    if (Array.isArray(bt))
      return bt.slice();
    if (!bt)
      return [];
    var ve = [];
    if (typeof bt == "string")
      if (Xe) {
        if (Xe === "hex")
          for (bt = bt.replace(/[^a-z0-9]+/ig, ""), bt.length % 2 !== 0 && (bt = "0" + bt), Qe = 0; Qe < bt.length; Qe += 2)
            ve.push(parseInt(bt[Qe] + bt[Qe + 1], 16));
      } else for (var Ce = 0, Qe = 0; Qe < bt.length; Qe++) {
        var vt = bt.charCodeAt(Qe);
        vt < 128 ? ve[Ce++] = vt : vt < 2048 ? (ve[Ce++] = vt >> 6 | 192, ve[Ce++] = vt & 63 | 128) : Y(bt, Qe) ? (vt = 65536 + ((vt & 1023) << 10) + (bt.charCodeAt(++Qe) & 1023), ve[Ce++] = vt >> 18 | 240, ve[Ce++] = vt >> 12 & 63 | 128, ve[Ce++] = vt >> 6 & 63 | 128, ve[Ce++] = vt & 63 | 128) : (ve[Ce++] = vt >> 12 | 224, ve[Ce++] = vt >> 6 & 63 | 128, ve[Ce++] = vt & 63 | 128);
      }
    else
      for (Qe = 0; Qe < bt.length; Qe++)
        ve[Qe] = bt[Qe] | 0;
    return ve;
  }
  utils$1.toArray = ie;
  function se(bt) {
    for (var Xe = "", ve = 0; ve < bt.length; ve++)
      Xe += le(bt[ve].toString(16));
    return Xe;
  }
  utils$1.toHex = se;
  function ne(bt) {
    var Xe = bt >>> 24 | bt >>> 8 & 65280 | bt << 8 & 16711680 | (bt & 255) << 24;
    return Xe >>> 0;
  }
  utils$1.htonl = ne;
  function ae(bt, Xe) {
    for (var ve = "", Ce = 0; Ce < bt.length; Ce++) {
      var Qe = bt[Ce];
      Xe === "little" && (Qe = ne(Qe)), ve += ge(Qe.toString(16));
    }
    return ve;
  }
  utils$1.toHex32 = ae;
  function le(bt) {
    return bt.length === 1 ? "0" + bt : bt;
  }
  utils$1.zero2 = le;
  function ge(bt) {
    return bt.length === 7 ? "0" + bt : bt.length === 6 ? "00" + bt : bt.length === 5 ? "000" + bt : bt.length === 4 ? "0000" + bt : bt.length === 3 ? "00000" + bt : bt.length === 2 ? "000000" + bt : bt.length === 1 ? "0000000" + bt : bt;
  }
  utils$1.zero8 = ge;
  function Ee(bt, Xe, ve, Ce) {
    var Qe = ve - Xe;
    B(Qe % 4 === 0);
    for (var vt = new Array(Qe / 4), wt = 0, $t = Xe; wt < vt.length; wt++, $t += 4) {
      var xt;
      Ce === "big" ? xt = bt[$t] << 24 | bt[$t + 1] << 16 | bt[$t + 2] << 8 | bt[$t + 3] : xt = bt[$t + 3] << 24 | bt[$t + 2] << 16 | bt[$t + 1] << 8 | bt[$t], vt[wt] = xt >>> 0;
    }
    return vt;
  }
  utils$1.join32 = Ee;
  function oe(bt, Xe) {
    for (var ve = new Array(bt.length * 4), Ce = 0, Qe = 0; Ce < bt.length; Ce++, Qe += 4) {
      var vt = bt[Ce];
      Xe === "big" ? (ve[Qe] = vt >>> 24, ve[Qe + 1] = vt >>> 16 & 255, ve[Qe + 2] = vt >>> 8 & 255, ve[Qe + 3] = vt & 255) : (ve[Qe + 3] = vt >>> 24, ve[Qe + 2] = vt >>> 16 & 255, ve[Qe + 1] = vt >>> 8 & 255, ve[Qe] = vt & 255);
    }
    return ve;
  }
  utils$1.split32 = oe;
  function Pe(bt, Xe) {
    return bt >>> Xe | bt << 32 - Xe;
  }
  utils$1.rotr32 = Pe;
  function Ve(bt, Xe) {
    return bt << Xe | bt >>> 32 - Xe;
  }
  utils$1.rotl32 = Ve;
  function Ke(bt, Xe) {
    return bt + Xe >>> 0;
  }
  utils$1.sum32 = Ke;
  function ht(bt, Xe, ve) {
    return bt + Xe + ve >>> 0;
  }
  utils$1.sum32_3 = ht;
  function _t(bt, Xe, ve, Ce) {
    return bt + Xe + ve + Ce >>> 0;
  }
  utils$1.sum32_4 = _t;
  function Rt(bt, Xe, ve, Ce, Qe) {
    return bt + Xe + ve + Ce + Qe >>> 0;
  }
  utils$1.sum32_5 = Rt;
  function kt(bt, Xe, ve, Ce) {
    var Qe = bt[Xe], vt = bt[Xe + 1], wt = Ce + vt >>> 0, $t = (wt < Ce ? 1 : 0) + ve + Qe;
    bt[Xe] = $t >>> 0, bt[Xe + 1] = wt;
  }
  utils$1.sum64 = kt;
  function Bt(bt, Xe, ve, Ce) {
    var Qe = Xe + Ce >>> 0, vt = (Qe < Xe ? 1 : 0) + bt + ve;
    return vt >>> 0;
  }
  utils$1.sum64_hi = Bt;
  function Ct(bt, Xe, ve, Ce) {
    var Qe = Xe + Ce;
    return Qe >>> 0;
  }
  utils$1.sum64_lo = Ct;
  function qt(bt, Xe, ve, Ce, Qe, vt, wt, $t) {
    var xt = 0, Pt = Xe;
    Pt = Pt + Ce >>> 0, xt += Pt < Xe ? 1 : 0, Pt = Pt + vt >>> 0, xt += Pt < vt ? 1 : 0, Pt = Pt + $t >>> 0, xt += Pt < $t ? 1 : 0;
    var Je = bt + ve + Qe + wt + xt;
    return Je >>> 0;
  }
  utils$1.sum64_4_hi = qt;
  function jt(bt, Xe, ve, Ce, Qe, vt, wt, $t) {
    var xt = Xe + Ce + vt + $t;
    return xt >>> 0;
  }
  utils$1.sum64_4_lo = jt;
  function Ht(bt, Xe, ve, Ce, Qe, vt, wt, $t, xt, Pt) {
    var Je = 0, Ot = Xe;
    Ot = Ot + Ce >>> 0, Je += Ot < Xe ? 1 : 0, Ot = Ot + vt >>> 0, Je += Ot < vt ? 1 : 0, Ot = Ot + $t >>> 0, Je += Ot < $t ? 1 : 0, Ot = Ot + Pt >>> 0, Je += Ot < Pt ? 1 : 0;
    var er = bt + ve + Qe + wt + xt + Je;
    return er >>> 0;
  }
  utils$1.sum64_5_hi = Ht;
  function Yt(bt, Xe, ve, Ce, Qe, vt, wt, $t, xt, Pt) {
    var Je = Xe + Ce + vt + $t + Pt;
    return Je >>> 0;
  }
  utils$1.sum64_5_lo = Yt;
  function Ut(bt, Xe, ve) {
    var Ce = Xe << 32 - ve | bt >>> ve;
    return Ce >>> 0;
  }
  utils$1.rotr64_hi = Ut;
  function Nt(bt, Xe, ve) {
    var Ce = bt << 32 - ve | Xe >>> ve;
    return Ce >>> 0;
  }
  utils$1.rotr64_lo = Nt;
  function Kt(bt, Xe, ve) {
    return bt >>> ve;
  }
  utils$1.shr64_hi = Kt;
  function Ft(bt, Xe, ve) {
    var Ce = bt << 32 - ve | Xe >>> ve;
    return Ce >>> 0;
  }
  return utils$1.shr64_lo = Ft, utils$1;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  var B = requireUtils(), z = requireMinimalisticAssert();
  function Y() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = Y, Y.prototype.update = function(se, ne) {
    if (se = B.toArray(se, ne), this.pending ? this.pending = this.pending.concat(se) : this.pending = se, this.pendingTotal += se.length, this.pending.length >= this._delta8) {
      se = this.pending;
      var ae = se.length % this._delta8;
      this.pending = se.slice(se.length - ae, se.length), this.pending.length === 0 && (this.pending = null), se = B.join32(se, 0, se.length - ae, this.endian);
      for (var le = 0; le < se.length; le += this._delta32)
        this._update(se, le, le + this._delta32);
    }
    return this;
  }, Y.prototype.digest = function(se) {
    return this.update(this._pad()), z(this.pending === null), this._digest(se);
  }, Y.prototype._pad = function() {
    var se = this.pendingTotal, ne = this._delta8, ae = ne - (se + this.padLength) % ne, le = new Array(ae + this.padLength);
    le[0] = 128;
    for (var ge = 1; ge < ae; ge++)
      le[ge] = 0;
    if (se <<= 3, this.endian === "big") {
      for (var Ee = 8; Ee < this.padLength; Ee++)
        le[ge++] = 0;
      le[ge++] = 0, le[ge++] = 0, le[ge++] = 0, le[ge++] = 0, le[ge++] = se >>> 24 & 255, le[ge++] = se >>> 16 & 255, le[ge++] = se >>> 8 & 255, le[ge++] = se & 255;
    } else
      for (le[ge++] = se & 255, le[ge++] = se >>> 8 & 255, le[ge++] = se >>> 16 & 255, le[ge++] = se >>> 24 & 255, le[ge++] = 0, le[ge++] = 0, le[ge++] = 0, le[ge++] = 0, Ee = 8; Ee < this.padLength; Ee++)
        le[ge++] = 0;
    return le;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  var B = requireUtils(), z = B.rotr32;
  function Y(oe, Pe, Ve, Ke) {
    if (oe === 0)
      return ie(Pe, Ve, Ke);
    if (oe === 1 || oe === 3)
      return ne(Pe, Ve, Ke);
    if (oe === 2)
      return se(Pe, Ve, Ke);
  }
  common.ft_1 = Y;
  function ie(oe, Pe, Ve) {
    return oe & Pe ^ ~oe & Ve;
  }
  common.ch32 = ie;
  function se(oe, Pe, Ve) {
    return oe & Pe ^ oe & Ve ^ Pe & Ve;
  }
  common.maj32 = se;
  function ne(oe, Pe, Ve) {
    return oe ^ Pe ^ Ve;
  }
  common.p32 = ne;
  function ae(oe) {
    return z(oe, 2) ^ z(oe, 13) ^ z(oe, 22);
  }
  common.s0_256 = ae;
  function le(oe) {
    return z(oe, 6) ^ z(oe, 11) ^ z(oe, 25);
  }
  common.s1_256 = le;
  function ge(oe) {
    return z(oe, 7) ^ z(oe, 18) ^ oe >>> 3;
  }
  common.g0_256 = ge;
  function Ee(oe) {
    return z(oe, 17) ^ z(oe, 19) ^ oe >>> 10;
  }
  return common.g1_256 = Ee, common;
}
var _1, hasRequired_1;
function require_1() {
  if (hasRequired_1) return _1;
  hasRequired_1 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireCommon(), ie = B.rotl32, se = B.sum32, ne = B.sum32_5, ae = Y.ft_1, le = z.BlockHash, ge = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function Ee() {
    if (!(this instanceof Ee))
      return new Ee();
    le.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return B.inherits(Ee, le), _1 = Ee, Ee.blockSize = 512, Ee.outSize = 160, Ee.hmacStrength = 80, Ee.padLength = 64, Ee.prototype._update = function(Pe, Ve) {
    for (var Ke = this.W, ht = 0; ht < 16; ht++)
      Ke[ht] = Pe[Ve + ht];
    for (; ht < Ke.length; ht++)
      Ke[ht] = ie(Ke[ht - 3] ^ Ke[ht - 8] ^ Ke[ht - 14] ^ Ke[ht - 16], 1);
    var _t = this.h[0], Rt = this.h[1], kt = this.h[2], Bt = this.h[3], Ct = this.h[4];
    for (ht = 0; ht < Ke.length; ht++) {
      var qt = ~~(ht / 20), jt = ne(ie(_t, 5), ae(qt, Rt, kt, Bt), Ct, Ke[ht], ge[qt]);
      Ct = Bt, Bt = kt, kt = ie(Rt, 30), Rt = _t, _t = jt;
    }
    this.h[0] = se(this.h[0], _t), this.h[1] = se(this.h[1], Rt), this.h[2] = se(this.h[2], kt), this.h[3] = se(this.h[3], Bt), this.h[4] = se(this.h[4], Ct);
  }, Ee.prototype._digest = function(Pe) {
    return Pe === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256) return _256;
  hasRequired_256 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireCommon(), ie = requireMinimalisticAssert(), se = B.sum32, ne = B.sum32_4, ae = B.sum32_5, le = Y.ch32, ge = Y.maj32, Ee = Y.s0_256, oe = Y.s1_256, Pe = Y.g0_256, Ve = Y.g1_256, Ke = z.BlockHash, ht = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function _t() {
    if (!(this instanceof _t))
      return new _t();
    Ke.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = ht, this.W = new Array(64);
  }
  return B.inherits(_t, Ke), _256 = _t, _t.blockSize = 512, _t.outSize = 256, _t.hmacStrength = 192, _t.padLength = 64, _t.prototype._update = function(kt, Bt) {
    for (var Ct = this.W, qt = 0; qt < 16; qt++)
      Ct[qt] = kt[Bt + qt];
    for (; qt < Ct.length; qt++)
      Ct[qt] = ne(Ve(Ct[qt - 2]), Ct[qt - 7], Pe(Ct[qt - 15]), Ct[qt - 16]);
    var jt = this.h[0], Ht = this.h[1], Yt = this.h[2], Ut = this.h[3], Nt = this.h[4], Kt = this.h[5], Ft = this.h[6], bt = this.h[7];
    for (ie(this.k.length === Ct.length), qt = 0; qt < Ct.length; qt++) {
      var Xe = ae(bt, oe(Nt), le(Nt, Kt, Ft), this.k[qt], Ct[qt]), ve = se(Ee(jt), ge(jt, Ht, Yt));
      bt = Ft, Ft = Kt, Kt = Nt, Nt = se(Ut, Xe), Ut = Yt, Yt = Ht, Ht = jt, jt = se(Xe, ve);
    }
    this.h[0] = se(this.h[0], jt), this.h[1] = se(this.h[1], Ht), this.h[2] = se(this.h[2], Yt), this.h[3] = se(this.h[3], Ut), this.h[4] = se(this.h[4], Nt), this.h[5] = se(this.h[5], Kt), this.h[6] = se(this.h[6], Ft), this.h[7] = se(this.h[7], bt);
  }, _t.prototype._digest = function(kt) {
    return kt === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224) return _224;
  hasRequired_224 = 1;
  var B = requireUtils(), z = require_256();
  function Y() {
    if (!(this instanceof Y))
      return new Y();
    z.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return B.inherits(Y, z), _224 = Y, Y.blockSize = 512, Y.outSize = 224, Y.hmacStrength = 192, Y.padLength = 64, Y.prototype._digest = function(se) {
    return se === "hex" ? B.toHex32(this.h.slice(0, 7), "big") : B.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512) return _512;
  hasRequired_512 = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = requireMinimalisticAssert(), ie = B.rotr64_hi, se = B.rotr64_lo, ne = B.shr64_hi, ae = B.shr64_lo, le = B.sum64, ge = B.sum64_hi, Ee = B.sum64_lo, oe = B.sum64_4_hi, Pe = B.sum64_4_lo, Ve = B.sum64_5_hi, Ke = B.sum64_5_lo, ht = z.BlockHash, _t = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function Rt() {
    if (!(this instanceof Rt))
      return new Rt();
    ht.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = _t, this.W = new Array(160);
  }
  B.inherits(Rt, ht), _512 = Rt, Rt.blockSize = 1024, Rt.outSize = 512, Rt.hmacStrength = 192, Rt.padLength = 128, Rt.prototype._prepareBlock = function(ve, Ce) {
    for (var Qe = this.W, vt = 0; vt < 32; vt++)
      Qe[vt] = ve[Ce + vt];
    for (; vt < Qe.length; vt += 2) {
      var wt = Ft(Qe[vt - 4], Qe[vt - 3]), $t = bt(Qe[vt - 4], Qe[vt - 3]), xt = Qe[vt - 14], Pt = Qe[vt - 13], Je = Nt(Qe[vt - 30], Qe[vt - 29]), Ot = Kt(Qe[vt - 30], Qe[vt - 29]), er = Qe[vt - 32], sr = Qe[vt - 31];
      Qe[vt] = oe(
        wt,
        $t,
        xt,
        Pt,
        Je,
        Ot,
        er,
        sr
      ), Qe[vt + 1] = Pe(
        wt,
        $t,
        xt,
        Pt,
        Je,
        Ot,
        er,
        sr
      );
    }
  }, Rt.prototype._update = function(ve, Ce) {
    this._prepareBlock(ve, Ce);
    var Qe = this.W, vt = this.h[0], wt = this.h[1], $t = this.h[2], xt = this.h[3], Pt = this.h[4], Je = this.h[5], Ot = this.h[6], er = this.h[7], sr = this.h[8], Jt = this.h[9], Wt = this.h[10], Gt = this.h[11], rr = this.h[12], or = this.h[13], Xt = this.h[14], zt = this.h[15];
    Y(this.k.length === Qe.length);
    for (var ur = 0; ur < Qe.length; ur += 2) {
      var hr = Xt, yr = zt, Sr = Yt(sr, Jt), $r = Ut(sr, Jt), Mr = kt(sr, Jt, Wt, Gt, rr), pr = Bt(sr, Jt, Wt, Gt, rr, or), Fr = this.k[ur], Ar = this.k[ur + 1], Gr = Qe[ur], Lr = Qe[ur + 1], Rr = Ve(
        hr,
        yr,
        Sr,
        $r,
        Mr,
        pr,
        Fr,
        Ar,
        Gr,
        Lr
      ), Vr = Ke(
        hr,
        yr,
        Sr,
        $r,
        Mr,
        pr,
        Fr,
        Ar,
        Gr,
        Lr
      );
      hr = jt(vt, wt), yr = Ht(vt, wt), Sr = Ct(vt, wt, $t, xt, Pt), $r = qt(vt, wt, $t, xt, Pt, Je);
      var jr = ge(hr, yr, Sr, $r), kr = Ee(hr, yr, Sr, $r);
      Xt = rr, zt = or, rr = Wt, or = Gt, Wt = sr, Gt = Jt, sr = ge(Ot, er, Rr, Vr), Jt = Ee(er, er, Rr, Vr), Ot = Pt, er = Je, Pt = $t, Je = xt, $t = vt, xt = wt, vt = ge(Rr, Vr, jr, kr), wt = Ee(Rr, Vr, jr, kr);
    }
    le(this.h, 0, vt, wt), le(this.h, 2, $t, xt), le(this.h, 4, Pt, Je), le(this.h, 6, Ot, er), le(this.h, 8, sr, Jt), le(this.h, 10, Wt, Gt), le(this.h, 12, rr, or), le(this.h, 14, Xt, zt);
  }, Rt.prototype._digest = function(ve) {
    return ve === "hex" ? B.toHex32(this.h, "big") : B.split32(this.h, "big");
  };
  function kt(Xe, ve, Ce, Qe, vt) {
    var wt = Xe & Ce ^ ~Xe & vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Bt(Xe, ve, Ce, Qe, vt, wt) {
    var $t = ve & Qe ^ ~ve & wt;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function Ct(Xe, ve, Ce, Qe, vt) {
    var wt = Xe & Ce ^ Xe & vt ^ Ce & vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function qt(Xe, ve, Ce, Qe, vt, wt) {
    var $t = ve & Qe ^ ve & wt ^ Qe & wt;
    return $t < 0 && ($t += 4294967296), $t;
  }
  function jt(Xe, ve) {
    var Ce = ie(Xe, ve, 28), Qe = ie(ve, Xe, 2), vt = ie(ve, Xe, 7), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Ht(Xe, ve) {
    var Ce = se(Xe, ve, 28), Qe = se(ve, Xe, 2), vt = se(ve, Xe, 7), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Yt(Xe, ve) {
    var Ce = ie(Xe, ve, 14), Qe = ie(Xe, ve, 18), vt = ie(ve, Xe, 9), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Ut(Xe, ve) {
    var Ce = se(Xe, ve, 14), Qe = se(Xe, ve, 18), vt = se(ve, Xe, 9), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Nt(Xe, ve) {
    var Ce = ie(Xe, ve, 1), Qe = ie(Xe, ve, 8), vt = ne(Xe, ve, 7), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Kt(Xe, ve) {
    var Ce = se(Xe, ve, 1), Qe = se(Xe, ve, 8), vt = ae(Xe, ve, 7), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function Ft(Xe, ve) {
    var Ce = ie(Xe, ve, 19), Qe = ie(ve, Xe, 29), vt = ne(Xe, ve, 6), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  function bt(Xe, ve) {
    var Ce = se(Xe, ve, 19), Qe = se(ve, Xe, 29), vt = ae(Xe, ve, 6), wt = Ce ^ Qe ^ vt;
    return wt < 0 && (wt += 4294967296), wt;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384) return _384;
  hasRequired_384 = 1;
  var B = requireUtils(), z = require_512();
  function Y() {
    if (!(this instanceof Y))
      return new Y();
    z.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return B.inherits(Y, z), _384 = Y, Y.blockSize = 1024, Y.outSize = 384, Y.hmacStrength = 192, Y.padLength = 128, Y.prototype._digest = function(se) {
    return se === "hex" ? B.toHex32(this.h.slice(0, 12), "big") : B.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd) return ripemd;
  hasRequiredRipemd = 1;
  var B = requireUtils(), z = requireCommon$1(), Y = B.rotl32, ie = B.sum32, se = B.sum32_3, ne = B.sum32_4, ae = z.BlockHash;
  function le() {
    if (!(this instanceof le))
      return new le();
    ae.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  B.inherits(le, ae), ripemd.ripemd160 = le, le.blockSize = 512, le.outSize = 160, le.hmacStrength = 192, le.padLength = 64, le.prototype._update = function(Rt, kt) {
    for (var Bt = this.h[0], Ct = this.h[1], qt = this.h[2], jt = this.h[3], Ht = this.h[4], Yt = Bt, Ut = Ct, Nt = qt, Kt = jt, Ft = Ht, bt = 0; bt < 80; bt++) {
      var Xe = ie(
        Y(
          ne(Bt, ge(bt, Ct, qt, jt), Rt[Pe[bt] + kt], Ee(bt)),
          Ke[bt]
        ),
        Ht
      );
      Bt = Ht, Ht = jt, jt = Y(qt, 10), qt = Ct, Ct = Xe, Xe = ie(
        Y(
          ne(Yt, ge(79 - bt, Ut, Nt, Kt), Rt[Ve[bt] + kt], oe(bt)),
          ht[bt]
        ),
        Ft
      ), Yt = Ft, Ft = Kt, Kt = Y(Nt, 10), Nt = Ut, Ut = Xe;
    }
    Xe = se(this.h[1], qt, Kt), this.h[1] = se(this.h[2], jt, Ft), this.h[2] = se(this.h[3], Ht, Yt), this.h[3] = se(this.h[4], Bt, Ut), this.h[4] = se(this.h[0], Ct, Nt), this.h[0] = Xe;
  }, le.prototype._digest = function(Rt) {
    return Rt === "hex" ? B.toHex32(this.h, "little") : B.split32(this.h, "little");
  };
  function ge(_t, Rt, kt, Bt) {
    return _t <= 15 ? Rt ^ kt ^ Bt : _t <= 31 ? Rt & kt | ~Rt & Bt : _t <= 47 ? (Rt | ~kt) ^ Bt : _t <= 63 ? Rt & Bt | kt & ~Bt : Rt ^ (kt | ~Bt);
  }
  function Ee(_t) {
    return _t <= 15 ? 0 : _t <= 31 ? 1518500249 : _t <= 47 ? 1859775393 : _t <= 63 ? 2400959708 : 2840853838;
  }
  function oe(_t) {
    return _t <= 15 ? 1352829926 : _t <= 31 ? 1548603684 : _t <= 47 ? 1836072691 : _t <= 63 ? 2053994217 : 0;
  }
  var Pe = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Ve = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], Ke = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ht = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac;
  hasRequiredHmac = 1;
  var B = requireUtils(), z = requireMinimalisticAssert();
  function Y(ie, se, ne) {
    if (!(this instanceof Y))
      return new Y(ie, se, ne);
    this.Hash = ie, this.blockSize = ie.blockSize / 8, this.outSize = ie.outSize / 8, this.inner = null, this.outer = null, this._init(B.toArray(se, ne));
  }
  return hmac = Y, Y.prototype._init = function(se) {
    se.length > this.blockSize && (se = new this.Hash().update(se).digest()), z(se.length <= this.blockSize);
    for (var ne = se.length; ne < this.blockSize; ne++)
      se.push(0);
    for (ne = 0; ne < se.length; ne++)
      se[ne] ^= 54;
    for (this.inner = new this.Hash().update(se), ne = 0; ne < se.length; ne++)
      se[ne] ^= 106;
    this.outer = new this.Hash().update(se);
  }, Y.prototype.update = function(se, ne) {
    return this.inner.update(se, ne), this;
  }, Y.prototype.digest = function(se) {
    return this.outer.update(this.inner.digest()), this.outer.digest(se);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(B) {
    var z = B;
    z.utils = requireUtils(), z.common = requireCommon$1(), z.sha = requireSha(), z.ripemd = requireRipemd(), z.hmac = requireHmac(), z.sha1 = z.sha.sha1, z.sha256 = z.sha.sha256, z.sha224 = z.sha.sha224, z.sha384 = z.sha.sha384, z.sha512 = z.sha.sha512, z.ripemd160 = z.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(B) {
    var z = B, Y = requireHash(), ie = requireCurve(), se = requireUtils$1(), ne = se.assert;
    function ae(Ee) {
      Ee.type === "short" ? this.curve = new ie.short(Ee) : Ee.type === "edwards" ? this.curve = new ie.edwards(Ee) : this.curve = new ie.mont(Ee), this.g = this.curve.g, this.n = this.curve.n, this.hash = Ee.hash, ne(this.g.validate(), "Invalid curve"), ne(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    z.PresetCurve = ae;
    function le(Ee, oe) {
      Object.defineProperty(z, Ee, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var Pe = new ae(oe);
          return Object.defineProperty(z, Ee, {
            configurable: !0,
            enumerable: !0,
            value: Pe
          }), Pe;
        }
      });
    }
    le("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), le("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), le("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), le("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: Y.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), le("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: Y.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), le("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), le("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: Y.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var ge;
    try {
      ge = requireSecp256k1();
    } catch {
      ge = void 0;
    }
    le("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: Y.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        ge
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg) return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var B = requireHash(), z = requireUtils$2(), Y = requireMinimalisticAssert();
  function ie(se) {
    if (!(this instanceof ie))
      return new ie(se);
    this.hash = se.hash, this.predResist = !!se.predResist, this.outLen = this.hash.outSize, this.minEntropy = se.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var ne = z.toArray(se.entropy, se.entropyEnc || "hex"), ae = z.toArray(se.nonce, se.nonceEnc || "hex"), le = z.toArray(se.pers, se.persEnc || "hex");
    Y(
      ne.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(ne, ae, le);
  }
  return hmacDrbg = ie, ie.prototype._init = function(ne, ae, le) {
    var ge = ne.concat(ae).concat(le);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var Ee = 0; Ee < this.V.length; Ee++)
      this.K[Ee] = 0, this.V[Ee] = 1;
    this._update(ge), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, ie.prototype._hmac = function() {
    return new B.hmac(this.hash, this.K);
  }, ie.prototype._update = function(ne) {
    var ae = this._hmac().update(this.V).update([0]);
    ne && (ae = ae.update(ne)), this.K = ae.digest(), this.V = this._hmac().update(this.V).digest(), ne && (this.K = this._hmac().update(this.V).update([1]).update(ne).digest(), this.V = this._hmac().update(this.V).digest());
  }, ie.prototype.reseed = function(ne, ae, le, ge) {
    typeof ae != "string" && (ge = le, le = ae, ae = null), ne = z.toArray(ne, ae), le = z.toArray(le, ge), Y(
      ne.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(ne.concat(le || [])), this._reseed = 1;
  }, ie.prototype.generate = function(ne, ae, le, ge) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof ae != "string" && (ge = le, le = ae, ae = null), le && (le = z.toArray(le, ge || "hex"), this._update(le));
    for (var Ee = []; Ee.length < ne; )
      this.V = this._hmac().update(this.V).digest(), Ee = Ee.concat(this.V);
    var oe = Ee.slice(0, ne);
    return this._update(le), this._reseed++, z.encode(oe, ae);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1) return key$1;
  hasRequiredKey$1 = 1;
  var B = requireBn$2(), z = requireUtils$1(), Y = z.assert;
  function ie(se, ne) {
    this.ec = se, this.priv = null, this.pub = null, ne.priv && this._importPrivate(ne.priv, ne.privEnc), ne.pub && this._importPublic(ne.pub, ne.pubEnc);
  }
  return key$1 = ie, ie.fromPublic = function(ne, ae, le) {
    return ae instanceof ie ? ae : new ie(ne, {
      pub: ae,
      pubEnc: le
    });
  }, ie.fromPrivate = function(ne, ae, le) {
    return ae instanceof ie ? ae : new ie(ne, {
      priv: ae,
      privEnc: le
    });
  }, ie.prototype.validate = function() {
    var ne = this.getPublic();
    return ne.isInfinity() ? { result: !1, reason: "Invalid public key" } : ne.validate() ? ne.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, ie.prototype.getPublic = function(ne, ae) {
    return typeof ne == "string" && (ae = ne, ne = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), ae ? this.pub.encode(ae, ne) : this.pub;
  }, ie.prototype.getPrivate = function(ne) {
    return ne === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, ie.prototype._importPrivate = function(ne, ae) {
    this.priv = new B(ne, ae || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, ie.prototype._importPublic = function(ne, ae) {
    if (ne.x || ne.y) {
      this.ec.curve.type === "mont" ? Y(ne.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Y(ne.x && ne.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(ne.x, ne.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(ne, ae);
  }, ie.prototype.derive = function(ne) {
    return ne.validate() || Y(ne.validate(), "public point not validated"), ne.mul(this.priv).getX();
  }, ie.prototype.sign = function(ne, ae, le) {
    return this.ec.sign(ne, this, ae, le);
  }, ie.prototype.verify = function(ne, ae, le) {
    return this.ec.verify(ne, ae, this, void 0, le);
  }, ie.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1) return signature$1;
  hasRequiredSignature$1 = 1;
  var B = requireBn$2(), z = requireUtils$1(), Y = z.assert;
  function ie(ge, Ee) {
    if (ge instanceof ie)
      return ge;
    this._importDER(ge, Ee) || (Y(ge.r && ge.s, "Signature without r or s"), this.r = new B(ge.r, 16), this.s = new B(ge.s, 16), ge.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = ge.recoveryParam);
  }
  signature$1 = ie;
  function se() {
    this.place = 0;
  }
  function ne(ge, Ee) {
    var oe = ge[Ee.place++];
    if (!(oe & 128))
      return oe;
    var Pe = oe & 15;
    if (Pe === 0 || Pe > 4 || ge[Ee.place] === 0)
      return !1;
    for (var Ve = 0, Ke = 0, ht = Ee.place; Ke < Pe; Ke++, ht++)
      Ve <<= 8, Ve |= ge[ht], Ve >>>= 0;
    return Ve <= 127 ? !1 : (Ee.place = ht, Ve);
  }
  function ae(ge) {
    for (var Ee = 0, oe = ge.length - 1; !ge[Ee] && !(ge[Ee + 1] & 128) && Ee < oe; )
      Ee++;
    return Ee === 0 ? ge : ge.slice(Ee);
  }
  ie.prototype._importDER = function(Ee, oe) {
    Ee = z.toArray(Ee, oe);
    var Pe = new se();
    if (Ee[Pe.place++] !== 48)
      return !1;
    var Ve = ne(Ee, Pe);
    if (Ve === !1 || Ve + Pe.place !== Ee.length || Ee[Pe.place++] !== 2)
      return !1;
    var Ke = ne(Ee, Pe);
    if (Ke === !1 || Ee[Pe.place] & 128)
      return !1;
    var ht = Ee.slice(Pe.place, Ke + Pe.place);
    if (Pe.place += Ke, Ee[Pe.place++] !== 2)
      return !1;
    var _t = ne(Ee, Pe);
    if (_t === !1 || Ee.length !== _t + Pe.place || Ee[Pe.place] & 128)
      return !1;
    var Rt = Ee.slice(Pe.place, _t + Pe.place);
    if (ht[0] === 0)
      if (ht[1] & 128)
        ht = ht.slice(1);
      else
        return !1;
    if (Rt[0] === 0)
      if (Rt[1] & 128)
        Rt = Rt.slice(1);
      else
        return !1;
    return this.r = new B(ht), this.s = new B(Rt), this.recoveryParam = null, !0;
  };
  function le(ge, Ee) {
    if (Ee < 128) {
      ge.push(Ee);
      return;
    }
    var oe = 1 + (Math.log(Ee) / Math.LN2 >>> 3);
    for (ge.push(oe | 128); --oe; )
      ge.push(Ee >>> (oe << 3) & 255);
    ge.push(Ee);
  }
  return ie.prototype.toDER = function(Ee) {
    var oe = this.r.toArray(), Pe = this.s.toArray();
    for (oe[0] & 128 && (oe = [0].concat(oe)), Pe[0] & 128 && (Pe = [0].concat(Pe)), oe = ae(oe), Pe = ae(Pe); !Pe[0] && !(Pe[1] & 128); )
      Pe = Pe.slice(1);
    var Ve = [2];
    le(Ve, oe.length), Ve = Ve.concat(oe), Ve.push(2), le(Ve, Pe.length);
    var Ke = Ve.concat(Pe), ht = [48];
    return le(ht, Ke.length), ht = ht.concat(Ke), z.encode(ht, Ee);
  }, signature$1;
}
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var B = requireBn$2(), z = requireHmacDrbg(), Y = requireUtils$1(), ie = requireCurves(), se = requireBrorand(), ne = Y.assert, ae = requireKey$1(), le = requireSignature$1();
  function ge(Ee) {
    if (!(this instanceof ge))
      return new ge(Ee);
    typeof Ee == "string" && (ne(
      Object.prototype.hasOwnProperty.call(ie, Ee),
      "Unknown curve " + Ee
    ), Ee = ie[Ee]), Ee instanceof ie.PresetCurve && (Ee = { curve: Ee }), this.curve = Ee.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Ee.curve.g, this.g.precompute(Ee.curve.n.bitLength() + 1), this.hash = Ee.hash || Ee.curve.hash;
  }
  return ec = ge, ge.prototype.keyPair = function(oe) {
    return new ae(this, oe);
  }, ge.prototype.keyFromPrivate = function(oe, Pe) {
    return ae.fromPrivate(this, oe, Pe);
  }, ge.prototype.keyFromPublic = function(oe, Pe) {
    return ae.fromPublic(this, oe, Pe);
  }, ge.prototype.genKeyPair = function(oe) {
    oe || (oe = {});
    for (var Pe = new z({
      hash: this.hash,
      pers: oe.pers,
      persEnc: oe.persEnc || "utf8",
      entropy: oe.entropy || se(this.hash.hmacStrength),
      entropyEnc: oe.entropy && oe.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Ve = this.n.byteLength(), Ke = this.n.sub(new B(2)); ; ) {
      var ht = new B(Pe.generate(Ve));
      if (!(ht.cmp(Ke) > 0))
        return ht.iaddn(1), this.keyFromPrivate(ht);
    }
  }, ge.prototype._truncateToN = function(oe, Pe, Ve) {
    var Ke;
    if (B.isBN(oe) || typeof oe == "number")
      oe = new B(oe, 16), Ke = oe.byteLength();
    else if (typeof oe == "object")
      Ke = oe.length, oe = new B(oe, 16);
    else {
      var ht = oe.toString();
      Ke = ht.length + 1 >>> 1, oe = new B(ht, 16);
    }
    typeof Ve != "number" && (Ve = Ke * 8);
    var _t = Ve - this.n.bitLength();
    return _t > 0 && (oe = oe.ushrn(_t)), !Pe && oe.cmp(this.n) >= 0 ? oe.sub(this.n) : oe;
  }, ge.prototype.sign = function(oe, Pe, Ve, Ke) {
    if (typeof Ve == "object" && (Ke = Ve, Ve = null), Ke || (Ke = {}), typeof oe != "string" && typeof oe != "number" && !B.isBN(oe)) {
      ne(
        typeof oe == "object" && oe && typeof oe.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), ne(oe.length >>> 0 === oe.length);
      for (var ht = 0; ht < oe.length; ht++) ne((oe[ht] & 255) === oe[ht]);
    }
    Pe = this.keyFromPrivate(Pe, Ve), oe = this._truncateToN(oe, !1, Ke.msgBitLength), ne(!oe.isNeg(), "Can not sign a negative message");
    var _t = this.n.byteLength(), Rt = Pe.getPrivate().toArray("be", _t), kt = oe.toArray("be", _t);
    ne(new B(kt).eq(oe), "Can not sign message");
    for (var Bt = new z({
      hash: this.hash,
      entropy: Rt,
      nonce: kt,
      pers: Ke.pers,
      persEnc: Ke.persEnc || "utf8"
    }), Ct = this.n.sub(new B(1)), qt = 0; ; qt++) {
      var jt = Ke.k ? Ke.k(qt) : new B(Bt.generate(this.n.byteLength()));
      if (jt = this._truncateToN(jt, !0), !(jt.cmpn(1) <= 0 || jt.cmp(Ct) >= 0)) {
        var Ht = this.g.mul(jt);
        if (!Ht.isInfinity()) {
          var Yt = Ht.getX(), Ut = Yt.umod(this.n);
          if (Ut.cmpn(0) !== 0) {
            var Nt = jt.invm(this.n).mul(Ut.mul(Pe.getPrivate()).iadd(oe));
            if (Nt = Nt.umod(this.n), Nt.cmpn(0) !== 0) {
              var Kt = (Ht.getY().isOdd() ? 1 : 0) | (Yt.cmp(Ut) !== 0 ? 2 : 0);
              return Ke.canonical && Nt.cmp(this.nh) > 0 && (Nt = this.n.sub(Nt), Kt ^= 1), new le({ r: Ut, s: Nt, recoveryParam: Kt });
            }
          }
        }
      }
    }
  }, ge.prototype.verify = function(oe, Pe, Ve, Ke, ht) {
    ht || (ht = {}), oe = this._truncateToN(oe, !1, ht.msgBitLength), Ve = this.keyFromPublic(Ve, Ke), Pe = new le(Pe, "hex");
    var _t = Pe.r, Rt = Pe.s;
    if (_t.cmpn(1) < 0 || _t.cmp(this.n) >= 0 || Rt.cmpn(1) < 0 || Rt.cmp(this.n) >= 0)
      return !1;
    var kt = Rt.invm(this.n), Bt = kt.mul(oe).umod(this.n), Ct = kt.mul(_t).umod(this.n), qt;
    return this.curve._maxwellTrick ? (qt = this.g.jmulAdd(Bt, Ve.getPublic(), Ct), qt.isInfinity() ? !1 : qt.eqXToP(_t)) : (qt = this.g.mulAdd(Bt, Ve.getPublic(), Ct), qt.isInfinity() ? !1 : qt.getX().umod(this.n).cmp(_t) === 0);
  }, ge.prototype.recoverPubKey = function(Ee, oe, Pe, Ve) {
    ne((3 & Pe) === Pe, "The recovery param is more than two bits"), oe = new le(oe, Ve);
    var Ke = this.n, ht = new B(Ee), _t = oe.r, Rt = oe.s, kt = Pe & 1, Bt = Pe >> 1;
    if (_t.cmp(this.curve.p.umod(this.curve.n)) >= 0 && Bt)
      throw new Error("Unable to find sencond key candinate");
    Bt ? _t = this.curve.pointFromX(_t.add(this.curve.n), kt) : _t = this.curve.pointFromX(_t, kt);
    var Ct = oe.r.invm(Ke), qt = Ke.sub(ht).mul(Ct).umod(Ke), jt = Rt.mul(Ct).umod(Ke);
    return this.g.mulAdd(qt, _t, jt);
  }, ge.prototype.getKeyRecoveryParam = function(Ee, oe, Pe, Ve) {
    if (oe = new le(oe, Ve), oe.recoveryParam !== null)
      return oe.recoveryParam;
    for (var Ke = 0; Ke < 4; Ke++) {
      var ht;
      try {
        ht = this.recoverPubKey(Ee, oe, Ke);
      } catch {
        continue;
      }
      if (ht.eq(Pe))
        return Ke;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey) return key;
  hasRequiredKey = 1;
  var B = requireUtils$1(), z = B.assert, Y = B.parseBytes, ie = B.cachedProperty;
  function se(ne, ae) {
    this.eddsa = ne, this._secret = Y(ae.secret), ne.isPoint(ae.pub) ? this._pub = ae.pub : this._pubBytes = Y(ae.pub);
  }
  return se.fromPublic = function(ae, le) {
    return le instanceof se ? le : new se(ae, { pub: le });
  }, se.fromSecret = function(ae, le) {
    return le instanceof se ? le : new se(ae, { secret: le });
  }, se.prototype.secret = function() {
    return this._secret;
  }, ie(se, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), ie(se, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), ie(se, "privBytes", function() {
    var ae = this.eddsa, le = this.hash(), ge = ae.encodingLength - 1, Ee = le.slice(0, ae.encodingLength);
    return Ee[0] &= 248, Ee[ge] &= 127, Ee[ge] |= 64, Ee;
  }), ie(se, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), ie(se, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), ie(se, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), se.prototype.sign = function(ae) {
    return z(this._secret, "KeyPair can only verify"), this.eddsa.sign(ae, this);
  }, se.prototype.verify = function(ae, le) {
    return this.eddsa.verify(ae, le, this);
  }, se.prototype.getSecret = function(ae) {
    return z(this._secret, "KeyPair is public only"), B.encode(this.secret(), ae);
  }, se.prototype.getPublic = function(ae) {
    return B.encode(this.pubBytes(), ae);
  }, key = se, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  var B = requireBn$2(), z = requireUtils$1(), Y = z.assert, ie = z.cachedProperty, se = z.parseBytes;
  function ne(ae, le) {
    this.eddsa = ae, typeof le != "object" && (le = se(le)), Array.isArray(le) && (Y(le.length === ae.encodingLength * 2, "Signature has invalid size"), le = {
      R: le.slice(0, ae.encodingLength),
      S: le.slice(ae.encodingLength)
    }), Y(le.R && le.S, "Signature without R or S"), ae.isPoint(le.R) && (this._R = le.R), le.S instanceof B && (this._S = le.S), this._Rencoded = Array.isArray(le.R) ? le.R : le.Rencoded, this._Sencoded = Array.isArray(le.S) ? le.S : le.Sencoded;
  }
  return ie(ne, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), ie(ne, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), ie(ne, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), ie(ne, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), ne.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, ne.prototype.toHex = function() {
    return z.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = ne, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa) return eddsa;
  hasRequiredEddsa = 1;
  var B = requireHash(), z = requireCurves(), Y = requireUtils$1(), ie = Y.assert, se = Y.parseBytes, ne = requireKey(), ae = requireSignature();
  function le(ge) {
    if (ie(ge === "ed25519", "only tested with ed25519 so far"), !(this instanceof le))
      return new le(ge);
    ge = z[ge].curve, this.curve = ge, this.g = ge.g, this.g.precompute(ge.n.bitLength() + 1), this.pointClass = ge.point().constructor, this.encodingLength = Math.ceil(ge.n.bitLength() / 8), this.hash = B.sha512;
  }
  return eddsa = le, le.prototype.sign = function(Ee, oe) {
    Ee = se(Ee);
    var Pe = this.keyFromSecret(oe), Ve = this.hashInt(Pe.messagePrefix(), Ee), Ke = this.g.mul(Ve), ht = this.encodePoint(Ke), _t = this.hashInt(ht, Pe.pubBytes(), Ee).mul(Pe.priv()), Rt = Ve.add(_t).umod(this.curve.n);
    return this.makeSignature({ R: Ke, S: Rt, Rencoded: ht });
  }, le.prototype.verify = function(Ee, oe, Pe) {
    if (Ee = se(Ee), oe = this.makeSignature(oe), oe.S().gte(oe.eddsa.curve.n) || oe.S().isNeg())
      return !1;
    var Ve = this.keyFromPublic(Pe), Ke = this.hashInt(oe.Rencoded(), Ve.pubBytes(), Ee), ht = this.g.mul(oe.S()), _t = oe.R().add(Ve.pub().mul(Ke));
    return _t.eq(ht);
  }, le.prototype.hashInt = function() {
    for (var Ee = this.hash(), oe = 0; oe < arguments.length; oe++)
      Ee.update(arguments[oe]);
    return Y.intFromLE(Ee.digest()).umod(this.curve.n);
  }, le.prototype.keyFromPublic = function(Ee) {
    return ne.fromPublic(this, Ee);
  }, le.prototype.keyFromSecret = function(Ee) {
    return ne.fromSecret(this, Ee);
  }, le.prototype.makeSignature = function(Ee) {
    return Ee instanceof ae ? Ee : new ae(this, Ee);
  }, le.prototype.encodePoint = function(Ee) {
    var oe = Ee.getY().toArray("le", this.encodingLength);
    return oe[this.encodingLength - 1] |= Ee.getX().isOdd() ? 128 : 0, oe;
  }, le.prototype.decodePoint = function(Ee) {
    Ee = Y.parseBytes(Ee);
    var oe = Ee.length - 1, Pe = Ee.slice(0, oe).concat(Ee[oe] & -129), Ve = (Ee[oe] & 128) !== 0, Ke = Y.intFromLE(Pe);
    return this.curve.pointFromY(Ke, Ve);
  }, le.prototype.encodeInt = function(Ee) {
    return Ee.toArray("le", this.encodingLength);
  }, le.prototype.decodeInt = function(Ee) {
    return Y.intFromLE(Ee);
  }, le.prototype.isPoint = function(Ee) {
    return Ee instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(B) {
    var z = B;
    z.version = require$$0.version, z.utils = requireUtils$1(), z.rand = requireBrorand(), z.curve = requireCurve(), z.curves = requireCurves(), z.ec = requireEc(), z.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var bn = { exports: {} };
bn.exports;
var hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(B) {
    (function(z, Y) {
      function ie(Xe, ve) {
        if (!Xe) throw new Error(ve || "Assertion failed");
      }
      function se(Xe, ve) {
        Xe.super_ = ve;
        var Ce = function() {
        };
        Ce.prototype = ve.prototype, Xe.prototype = new Ce(), Xe.prototype.constructor = Xe;
      }
      function ne(Xe, ve, Ce) {
        if (ne.isBN(Xe))
          return Xe;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, Xe !== null && ((ve === "le" || ve === "be") && (Ce = ve, ve = 10), this._init(Xe || 0, ve || 10, Ce || "be"));
      }
      typeof z == "object" ? z.exports = ne : Y.BN = ne, ne.BN = ne, ne.wordSize = 26;
      var ae;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? ae = window.Buffer : ae = require$$0$1.Buffer;
      } catch {
      }
      ne.isBN = function(ve) {
        return ve instanceof ne ? !0 : ve !== null && typeof ve == "object" && ve.constructor.wordSize === ne.wordSize && Array.isArray(ve.words);
      }, ne.max = function(ve, Ce) {
        return ve.cmp(Ce) > 0 ? ve : Ce;
      }, ne.min = function(ve, Ce) {
        return ve.cmp(Ce) < 0 ? ve : Ce;
      }, ne.prototype._init = function(ve, Ce, Qe) {
        if (typeof ve == "number")
          return this._initNumber(ve, Ce, Qe);
        if (typeof ve == "object")
          return this._initArray(ve, Ce, Qe);
        Ce === "hex" && (Ce = 16), ie(Ce === (Ce | 0) && Ce >= 2 && Ce <= 36), ve = ve.toString().replace(/\s+/g, "");
        var vt = 0;
        ve[0] === "-" && (vt++, this.negative = 1), vt < ve.length && (Ce === 16 ? this._parseHex(ve, vt, Qe) : (this._parseBase(ve, Ce, vt), Qe === "le" && this._initArray(this.toArray(), Ce, Qe)));
      }, ne.prototype._initNumber = function(ve, Ce, Qe) {
        ve < 0 && (this.negative = 1, ve = -ve), ve < 67108864 ? (this.words = [ve & 67108863], this.length = 1) : ve < 4503599627370496 ? (this.words = [
          ve & 67108863,
          ve / 67108864 & 67108863
        ], this.length = 2) : (ie(ve < 9007199254740992), this.words = [
          ve & 67108863,
          ve / 67108864 & 67108863,
          1
        ], this.length = 3), Qe === "le" && this._initArray(this.toArray(), Ce, Qe);
      }, ne.prototype._initArray = function(ve, Ce, Qe) {
        if (ie(typeof ve.length == "number"), ve.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(ve.length / 3), this.words = new Array(this.length);
        for (var vt = 0; vt < this.length; vt++)
          this.words[vt] = 0;
        var wt, $t, xt = 0;
        if (Qe === "be")
          for (vt = ve.length - 1, wt = 0; vt >= 0; vt -= 3)
            $t = ve[vt] | ve[vt - 1] << 8 | ve[vt - 2] << 16, this.words[wt] |= $t << xt & 67108863, this.words[wt + 1] = $t >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, wt++);
        else if (Qe === "le")
          for (vt = 0, wt = 0; vt < ve.length; vt += 3)
            $t = ve[vt] | ve[vt + 1] << 8 | ve[vt + 2] << 16, this.words[wt] |= $t << xt & 67108863, this.words[wt + 1] = $t >>> 26 - xt & 67108863, xt += 24, xt >= 26 && (xt -= 26, wt++);
        return this._strip();
      };
      function le(Xe, ve) {
        var Ce = Xe.charCodeAt(ve);
        if (Ce >= 48 && Ce <= 57)
          return Ce - 48;
        if (Ce >= 65 && Ce <= 70)
          return Ce - 55;
        if (Ce >= 97 && Ce <= 102)
          return Ce - 87;
        ie(!1, "Invalid character in " + Xe);
      }
      function ge(Xe, ve, Ce) {
        var Qe = le(Xe, Ce);
        return Ce - 1 >= ve && (Qe |= le(Xe, Ce - 1) << 4), Qe;
      }
      ne.prototype._parseHex = function(ve, Ce, Qe) {
        this.length = Math.ceil((ve.length - Ce) / 6), this.words = new Array(this.length);
        for (var vt = 0; vt < this.length; vt++)
          this.words[vt] = 0;
        var wt = 0, $t = 0, xt;
        if (Qe === "be")
          for (vt = ve.length - 1; vt >= Ce; vt -= 2)
            xt = ge(ve, Ce, vt) << wt, this.words[$t] |= xt & 67108863, wt >= 18 ? (wt -= 18, $t += 1, this.words[$t] |= xt >>> 26) : wt += 8;
        else {
          var Pt = ve.length - Ce;
          for (vt = Pt % 2 === 0 ? Ce + 1 : Ce; vt < ve.length; vt += 2)
            xt = ge(ve, Ce, vt) << wt, this.words[$t] |= xt & 67108863, wt >= 18 ? (wt -= 18, $t += 1, this.words[$t] |= xt >>> 26) : wt += 8;
        }
        this._strip();
      };
      function Ee(Xe, ve, Ce, Qe) {
        for (var vt = 0, wt = 0, $t = Math.min(Xe.length, Ce), xt = ve; xt < $t; xt++) {
          var Pt = Xe.charCodeAt(xt) - 48;
          vt *= Qe, Pt >= 49 ? wt = Pt - 49 + 10 : Pt >= 17 ? wt = Pt - 17 + 10 : wt = Pt, ie(Pt >= 0 && wt < Qe, "Invalid character"), vt += wt;
        }
        return vt;
      }
      ne.prototype._parseBase = function(ve, Ce, Qe) {
        this.words = [0], this.length = 1;
        for (var vt = 0, wt = 1; wt <= 67108863; wt *= Ce)
          vt++;
        vt--, wt = wt / Ce | 0;
        for (var $t = ve.length - Qe, xt = $t % vt, Pt = Math.min($t, $t - xt) + Qe, Je = 0, Ot = Qe; Ot < Pt; Ot += vt)
          Je = Ee(ve, Ot, Ot + vt, Ce), this.imuln(wt), this.words[0] + Je < 67108864 ? this.words[0] += Je : this._iaddn(Je);
        if (xt !== 0) {
          var er = 1;
          for (Je = Ee(ve, Ot, ve.length, Ce), Ot = 0; Ot < xt; Ot++)
            er *= Ce;
          this.imuln(er), this.words[0] + Je < 67108864 ? this.words[0] += Je : this._iaddn(Je);
        }
        this._strip();
      }, ne.prototype.copy = function(ve) {
        ve.words = new Array(this.length);
        for (var Ce = 0; Ce < this.length; Ce++)
          ve.words[Ce] = this.words[Ce];
        ve.length = this.length, ve.negative = this.negative, ve.red = this.red;
      };
      function oe(Xe, ve) {
        Xe.words = ve.words, Xe.length = ve.length, Xe.negative = ve.negative, Xe.red = ve.red;
      }
      if (ne.prototype._move = function(ve) {
        oe(ve, this);
      }, ne.prototype.clone = function() {
        var ve = new ne(null);
        return this.copy(ve), ve;
      }, ne.prototype._expand = function(ve) {
        for (; this.length < ve; )
          this.words[this.length++] = 0;
        return this;
      }, ne.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, ne.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          ne.prototype[Symbol.for("nodejs.util.inspect.custom")] = Pe;
        } catch {
          ne.prototype.inspect = Pe;
        }
      else
        ne.prototype.inspect = Pe;
      function Pe() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Ve = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Ke = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ht = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      ne.prototype.toString = function(ve, Ce) {
        ve = ve || 10, Ce = Ce | 0 || 1;
        var Qe;
        if (ve === 16 || ve === "hex") {
          Qe = "";
          for (var vt = 0, wt = 0, $t = 0; $t < this.length; $t++) {
            var xt = this.words[$t], Pt = ((xt << vt | wt) & 16777215).toString(16);
            wt = xt >>> 24 - vt & 16777215, vt += 2, vt >= 26 && (vt -= 26, $t--), wt !== 0 || $t !== this.length - 1 ? Qe = Ve[6 - Pt.length] + Pt + Qe : Qe = Pt + Qe;
          }
          for (wt !== 0 && (Qe = wt.toString(16) + Qe); Qe.length % Ce !== 0; )
            Qe = "0" + Qe;
          return this.negative !== 0 && (Qe = "-" + Qe), Qe;
        }
        if (ve === (ve | 0) && ve >= 2 && ve <= 36) {
          var Je = Ke[ve], Ot = ht[ve];
          Qe = "";
          var er = this.clone();
          for (er.negative = 0; !er.isZero(); ) {
            var sr = er.modrn(Ot).toString(ve);
            er = er.idivn(Ot), er.isZero() ? Qe = sr + Qe : Qe = Ve[Je - sr.length] + sr + Qe;
          }
          for (this.isZero() && (Qe = "0" + Qe); Qe.length % Ce !== 0; )
            Qe = "0" + Qe;
          return this.negative !== 0 && (Qe = "-" + Qe), Qe;
        }
        ie(!1, "Base should be between 2 and 36");
      }, ne.prototype.toNumber = function() {
        var ve = this.words[0];
        return this.length === 2 ? ve += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? ve += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && ie(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -ve : ve;
      }, ne.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, ae && (ne.prototype.toBuffer = function(ve, Ce) {
        return this.toArrayLike(ae, ve, Ce);
      }), ne.prototype.toArray = function(ve, Ce) {
        return this.toArrayLike(Array, ve, Ce);
      };
      var _t = function(ve, Ce) {
        return ve.allocUnsafe ? ve.allocUnsafe(Ce) : new ve(Ce);
      };
      ne.prototype.toArrayLike = function(ve, Ce, Qe) {
        this._strip();
        var vt = this.byteLength(), wt = Qe || Math.max(1, vt);
        ie(vt <= wt, "byte array longer than desired length"), ie(wt > 0, "Requested array length <= 0");
        var $t = _t(ve, wt), xt = Ce === "le" ? "LE" : "BE";
        return this["_toArrayLike" + xt]($t, vt), $t;
      }, ne.prototype._toArrayLikeLE = function(ve, Ce) {
        for (var Qe = 0, vt = 0, wt = 0, $t = 0; wt < this.length; wt++) {
          var xt = this.words[wt] << $t | vt;
          ve[Qe++] = xt & 255, Qe < ve.length && (ve[Qe++] = xt >> 8 & 255), Qe < ve.length && (ve[Qe++] = xt >> 16 & 255), $t === 6 ? (Qe < ve.length && (ve[Qe++] = xt >> 24 & 255), vt = 0, $t = 0) : (vt = xt >>> 24, $t += 2);
        }
        if (Qe < ve.length)
          for (ve[Qe++] = vt; Qe < ve.length; )
            ve[Qe++] = 0;
      }, ne.prototype._toArrayLikeBE = function(ve, Ce) {
        for (var Qe = ve.length - 1, vt = 0, wt = 0, $t = 0; wt < this.length; wt++) {
          var xt = this.words[wt] << $t | vt;
          ve[Qe--] = xt & 255, Qe >= 0 && (ve[Qe--] = xt >> 8 & 255), Qe >= 0 && (ve[Qe--] = xt >> 16 & 255), $t === 6 ? (Qe >= 0 && (ve[Qe--] = xt >> 24 & 255), vt = 0, $t = 0) : (vt = xt >>> 24, $t += 2);
        }
        if (Qe >= 0)
          for (ve[Qe--] = vt; Qe >= 0; )
            ve[Qe--] = 0;
      }, Math.clz32 ? ne.prototype._countBits = function(ve) {
        return 32 - Math.clz32(ve);
      } : ne.prototype._countBits = function(ve) {
        var Ce = ve, Qe = 0;
        return Ce >= 4096 && (Qe += 13, Ce >>>= 13), Ce >= 64 && (Qe += 7, Ce >>>= 7), Ce >= 8 && (Qe += 4, Ce >>>= 4), Ce >= 2 && (Qe += 2, Ce >>>= 2), Qe + Ce;
      }, ne.prototype._zeroBits = function(ve) {
        if (ve === 0) return 26;
        var Ce = ve, Qe = 0;
        return Ce & 8191 || (Qe += 13, Ce >>>= 13), Ce & 127 || (Qe += 7, Ce >>>= 7), Ce & 15 || (Qe += 4, Ce >>>= 4), Ce & 3 || (Qe += 2, Ce >>>= 2), Ce & 1 || Qe++, Qe;
      }, ne.prototype.bitLength = function() {
        var ve = this.words[this.length - 1], Ce = this._countBits(ve);
        return (this.length - 1) * 26 + Ce;
      };
      function Rt(Xe) {
        for (var ve = new Array(Xe.bitLength()), Ce = 0; Ce < ve.length; Ce++) {
          var Qe = Ce / 26 | 0, vt = Ce % 26;
          ve[Ce] = Xe.words[Qe] >>> vt & 1;
        }
        return ve;
      }
      ne.prototype.zeroBits = function() {
        if (this.isZero()) return 0;
        for (var ve = 0, Ce = 0; Ce < this.length; Ce++) {
          var Qe = this._zeroBits(this.words[Ce]);
          if (ve += Qe, Qe !== 26) break;
        }
        return ve;
      }, ne.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, ne.prototype.toTwos = function(ve) {
        return this.negative !== 0 ? this.abs().inotn(ve).iaddn(1) : this.clone();
      }, ne.prototype.fromTwos = function(ve) {
        return this.testn(ve - 1) ? this.notn(ve).iaddn(1).ineg() : this.clone();
      }, ne.prototype.isNeg = function() {
        return this.negative !== 0;
      }, ne.prototype.neg = function() {
        return this.clone().ineg();
      }, ne.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, ne.prototype.iuor = function(ve) {
        for (; this.length < ve.length; )
          this.words[this.length++] = 0;
        for (var Ce = 0; Ce < ve.length; Ce++)
          this.words[Ce] = this.words[Ce] | ve.words[Ce];
        return this._strip();
      }, ne.prototype.ior = function(ve) {
        return ie((this.negative | ve.negative) === 0), this.iuor(ve);
      }, ne.prototype.or = function(ve) {
        return this.length > ve.length ? this.clone().ior(ve) : ve.clone().ior(this);
      }, ne.prototype.uor = function(ve) {
        return this.length > ve.length ? this.clone().iuor(ve) : ve.clone().iuor(this);
      }, ne.prototype.iuand = function(ve) {
        var Ce;
        this.length > ve.length ? Ce = ve : Ce = this;
        for (var Qe = 0; Qe < Ce.length; Qe++)
          this.words[Qe] = this.words[Qe] & ve.words[Qe];
        return this.length = Ce.length, this._strip();
      }, ne.prototype.iand = function(ve) {
        return ie((this.negative | ve.negative) === 0), this.iuand(ve);
      }, ne.prototype.and = function(ve) {
        return this.length > ve.length ? this.clone().iand(ve) : ve.clone().iand(this);
      }, ne.prototype.uand = function(ve) {
        return this.length > ve.length ? this.clone().iuand(ve) : ve.clone().iuand(this);
      }, ne.prototype.iuxor = function(ve) {
        var Ce, Qe;
        this.length > ve.length ? (Ce = this, Qe = ve) : (Ce = ve, Qe = this);
        for (var vt = 0; vt < Qe.length; vt++)
          this.words[vt] = Ce.words[vt] ^ Qe.words[vt];
        if (this !== Ce)
          for (; vt < Ce.length; vt++)
            this.words[vt] = Ce.words[vt];
        return this.length = Ce.length, this._strip();
      }, ne.prototype.ixor = function(ve) {
        return ie((this.negative | ve.negative) === 0), this.iuxor(ve);
      }, ne.prototype.xor = function(ve) {
        return this.length > ve.length ? this.clone().ixor(ve) : ve.clone().ixor(this);
      }, ne.prototype.uxor = function(ve) {
        return this.length > ve.length ? this.clone().iuxor(ve) : ve.clone().iuxor(this);
      }, ne.prototype.inotn = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = Math.ceil(ve / 26) | 0, Qe = ve % 26;
        this._expand(Ce), Qe > 0 && Ce--;
        for (var vt = 0; vt < Ce; vt++)
          this.words[vt] = ~this.words[vt] & 67108863;
        return Qe > 0 && (this.words[vt] = ~this.words[vt] & 67108863 >> 26 - Qe), this._strip();
      }, ne.prototype.notn = function(ve) {
        return this.clone().inotn(ve);
      }, ne.prototype.setn = function(ve, Ce) {
        ie(typeof ve == "number" && ve >= 0);
        var Qe = ve / 26 | 0, vt = ve % 26;
        return this._expand(Qe + 1), Ce ? this.words[Qe] = this.words[Qe] | 1 << vt : this.words[Qe] = this.words[Qe] & ~(1 << vt), this._strip();
      }, ne.prototype.iadd = function(ve) {
        var Ce;
        if (this.negative !== 0 && ve.negative === 0)
          return this.negative = 0, Ce = this.isub(ve), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && ve.negative !== 0)
          return ve.negative = 0, Ce = this.isub(ve), ve.negative = 1, Ce._normSign();
        var Qe, vt;
        this.length > ve.length ? (Qe = this, vt = ve) : (Qe = ve, vt = this);
        for (var wt = 0, $t = 0; $t < vt.length; $t++)
          Ce = (Qe.words[$t] | 0) + (vt.words[$t] | 0) + wt, this.words[$t] = Ce & 67108863, wt = Ce >>> 26;
        for (; wt !== 0 && $t < Qe.length; $t++)
          Ce = (Qe.words[$t] | 0) + wt, this.words[$t] = Ce & 67108863, wt = Ce >>> 26;
        if (this.length = Qe.length, wt !== 0)
          this.words[this.length] = wt, this.length++;
        else if (Qe !== this)
          for (; $t < Qe.length; $t++)
            this.words[$t] = Qe.words[$t];
        return this;
      }, ne.prototype.add = function(ve) {
        var Ce;
        return ve.negative !== 0 && this.negative === 0 ? (ve.negative = 0, Ce = this.sub(ve), ve.negative ^= 1, Ce) : ve.negative === 0 && this.negative !== 0 ? (this.negative = 0, Ce = ve.sub(this), this.negative = 1, Ce) : this.length > ve.length ? this.clone().iadd(ve) : ve.clone().iadd(this);
      }, ne.prototype.isub = function(ve) {
        if (ve.negative !== 0) {
          ve.negative = 0;
          var Ce = this.iadd(ve);
          return ve.negative = 1, Ce._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(ve), this.negative = 1, this._normSign();
        var Qe = this.cmp(ve);
        if (Qe === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var vt, wt;
        Qe > 0 ? (vt = this, wt = ve) : (vt = ve, wt = this);
        for (var $t = 0, xt = 0; xt < wt.length; xt++)
          Ce = (vt.words[xt] | 0) - (wt.words[xt] | 0) + $t, $t = Ce >> 26, this.words[xt] = Ce & 67108863;
        for (; $t !== 0 && xt < vt.length; xt++)
          Ce = (vt.words[xt] | 0) + $t, $t = Ce >> 26, this.words[xt] = Ce & 67108863;
        if ($t === 0 && xt < vt.length && vt !== this)
          for (; xt < vt.length; xt++)
            this.words[xt] = vt.words[xt];
        return this.length = Math.max(this.length, xt), vt !== this && (this.negative = 1), this._strip();
      }, ne.prototype.sub = function(ve) {
        return this.clone().isub(ve);
      };
      function kt(Xe, ve, Ce) {
        Ce.negative = ve.negative ^ Xe.negative;
        var Qe = Xe.length + ve.length | 0;
        Ce.length = Qe, Qe = Qe - 1 | 0;
        var vt = Xe.words[0] | 0, wt = ve.words[0] | 0, $t = vt * wt, xt = $t & 67108863, Pt = $t / 67108864 | 0;
        Ce.words[0] = xt;
        for (var Je = 1; Je < Qe; Je++) {
          for (var Ot = Pt >>> 26, er = Pt & 67108863, sr = Math.min(Je, ve.length - 1), Jt = Math.max(0, Je - Xe.length + 1); Jt <= sr; Jt++) {
            var Wt = Je - Jt | 0;
            vt = Xe.words[Wt] | 0, wt = ve.words[Jt] | 0, $t = vt * wt + er, Ot += $t / 67108864 | 0, er = $t & 67108863;
          }
          Ce.words[Je] = er | 0, Pt = Ot | 0;
        }
        return Pt !== 0 ? Ce.words[Je] = Pt | 0 : Ce.length--, Ce._strip();
      }
      var Bt = function(ve, Ce, Qe) {
        var vt = ve.words, wt = Ce.words, $t = Qe.words, xt = 0, Pt, Je, Ot, er = vt[0] | 0, sr = er & 8191, Jt = er >>> 13, Wt = vt[1] | 0, Gt = Wt & 8191, rr = Wt >>> 13, or = vt[2] | 0, Xt = or & 8191, zt = or >>> 13, ur = vt[3] | 0, hr = ur & 8191, yr = ur >>> 13, Sr = vt[4] | 0, $r = Sr & 8191, Mr = Sr >>> 13, pr = vt[5] | 0, Fr = pr & 8191, Ar = pr >>> 13, Gr = vt[6] | 0, Lr = Gr & 8191, Rr = Gr >>> 13, Vr = vt[7] | 0, jr = Vr & 8191, kr = Vr >>> 13, Jr = vt[8] | 0, Xr = Jr & 8191, Vt = Jr >>> 13, Lt = vt[9] | 0, Dt = Lt & 8191, Qt = Lt >>> 13, fr = wt[0] | 0, cr = fr & 8191, lr = fr >>> 13, Ur = wt[1] | 0, Nr = Ur & 8191, Tr = Ur >>> 13, Wr = wt[2] | 0, qr = Wr & 8191, Or = Wr >>> 13, Zr = wt[3] | 0, Yr = Zr & 8191, nr = Zr >>> 13, Zt = wt[4] | 0, ir = Zt & 8191, ar = Zt >>> 13, dr = wt[5] | 0, vr = dr & 8191, br = dr >>> 13, xr = wt[6] | 0, Pr = xr & 8191, Er = xr >>> 13, Dr = wt[7] | 0, Ir = Dr & 8191, tr = Dr >>> 13, gr = wt[8] | 0, wr = gr & 8191, _r = gr >>> 13, Hr = wt[9] | 0, Cr = Hr & 8191, Br = Hr >>> 13;
        Qe.negative = ve.negative ^ Ce.negative, Qe.length = 19, Pt = Math.imul(sr, cr), Je = Math.imul(sr, lr), Je = Je + Math.imul(Jt, cr) | 0, Ot = Math.imul(Jt, lr);
        var zr = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (zr >>> 26) | 0, zr &= 67108863, Pt = Math.imul(Gt, cr), Je = Math.imul(Gt, lr), Je = Je + Math.imul(rr, cr) | 0, Ot = Math.imul(rr, lr), Pt = Pt + Math.imul(sr, Nr) | 0, Je = Je + Math.imul(sr, Tr) | 0, Je = Je + Math.imul(Jt, Nr) | 0, Ot = Ot + Math.imul(Jt, Tr) | 0;
        var tn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (tn >>> 26) | 0, tn &= 67108863, Pt = Math.imul(Xt, cr), Je = Math.imul(Xt, lr), Je = Je + Math.imul(zt, cr) | 0, Ot = Math.imul(zt, lr), Pt = Pt + Math.imul(Gt, Nr) | 0, Je = Je + Math.imul(Gt, Tr) | 0, Je = Je + Math.imul(rr, Nr) | 0, Ot = Ot + Math.imul(rr, Tr) | 0, Pt = Pt + Math.imul(sr, qr) | 0, Je = Je + Math.imul(sr, Or) | 0, Je = Je + Math.imul(Jt, qr) | 0, Ot = Ot + Math.imul(Jt, Or) | 0;
        var Qr = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (Qr >>> 26) | 0, Qr &= 67108863, Pt = Math.imul(hr, cr), Je = Math.imul(hr, lr), Je = Je + Math.imul(yr, cr) | 0, Ot = Math.imul(yr, lr), Pt = Pt + Math.imul(Xt, Nr) | 0, Je = Je + Math.imul(Xt, Tr) | 0, Je = Je + Math.imul(zt, Nr) | 0, Ot = Ot + Math.imul(zt, Tr) | 0, Pt = Pt + Math.imul(Gt, qr) | 0, Je = Je + Math.imul(Gt, Or) | 0, Je = Je + Math.imul(rr, qr) | 0, Ot = Ot + Math.imul(rr, Or) | 0, Pt = Pt + Math.imul(sr, Yr) | 0, Je = Je + Math.imul(sr, nr) | 0, Je = Je + Math.imul(Jt, Yr) | 0, Ot = Ot + Math.imul(Jt, nr) | 0;
        var en = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (en >>> 26) | 0, en &= 67108863, Pt = Math.imul($r, cr), Je = Math.imul($r, lr), Je = Je + Math.imul(Mr, cr) | 0, Ot = Math.imul(Mr, lr), Pt = Pt + Math.imul(hr, Nr) | 0, Je = Je + Math.imul(hr, Tr) | 0, Je = Je + Math.imul(yr, Nr) | 0, Ot = Ot + Math.imul(yr, Tr) | 0, Pt = Pt + Math.imul(Xt, qr) | 0, Je = Je + Math.imul(Xt, Or) | 0, Je = Je + Math.imul(zt, qr) | 0, Ot = Ot + Math.imul(zt, Or) | 0, Pt = Pt + Math.imul(Gt, Yr) | 0, Je = Je + Math.imul(Gt, nr) | 0, Je = Je + Math.imul(rr, Yr) | 0, Ot = Ot + Math.imul(rr, nr) | 0, Pt = Pt + Math.imul(sr, ir) | 0, Je = Je + Math.imul(sr, ar) | 0, Je = Je + Math.imul(Jt, ir) | 0, Ot = Ot + Math.imul(Jt, ar) | 0;
        var sn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (sn >>> 26) | 0, sn &= 67108863, Pt = Math.imul(Fr, cr), Je = Math.imul(Fr, lr), Je = Je + Math.imul(Ar, cr) | 0, Ot = Math.imul(Ar, lr), Pt = Pt + Math.imul($r, Nr) | 0, Je = Je + Math.imul($r, Tr) | 0, Je = Je + Math.imul(Mr, Nr) | 0, Ot = Ot + Math.imul(Mr, Tr) | 0, Pt = Pt + Math.imul(hr, qr) | 0, Je = Je + Math.imul(hr, Or) | 0, Je = Je + Math.imul(yr, qr) | 0, Ot = Ot + Math.imul(yr, Or) | 0, Pt = Pt + Math.imul(Xt, Yr) | 0, Je = Je + Math.imul(Xt, nr) | 0, Je = Je + Math.imul(zt, Yr) | 0, Ot = Ot + Math.imul(zt, nr) | 0, Pt = Pt + Math.imul(Gt, ir) | 0, Je = Je + Math.imul(Gt, ar) | 0, Je = Je + Math.imul(rr, ir) | 0, Ot = Ot + Math.imul(rr, ar) | 0, Pt = Pt + Math.imul(sr, vr) | 0, Je = Je + Math.imul(sr, br) | 0, Je = Je + Math.imul(Jt, vr) | 0, Ot = Ot + Math.imul(Jt, br) | 0;
        var on = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (on >>> 26) | 0, on &= 67108863, Pt = Math.imul(Lr, cr), Je = Math.imul(Lr, lr), Je = Je + Math.imul(Rr, cr) | 0, Ot = Math.imul(Rr, lr), Pt = Pt + Math.imul(Fr, Nr) | 0, Je = Je + Math.imul(Fr, Tr) | 0, Je = Je + Math.imul(Ar, Nr) | 0, Ot = Ot + Math.imul(Ar, Tr) | 0, Pt = Pt + Math.imul($r, qr) | 0, Je = Je + Math.imul($r, Or) | 0, Je = Je + Math.imul(Mr, qr) | 0, Ot = Ot + Math.imul(Mr, Or) | 0, Pt = Pt + Math.imul(hr, Yr) | 0, Je = Je + Math.imul(hr, nr) | 0, Je = Je + Math.imul(yr, Yr) | 0, Ot = Ot + Math.imul(yr, nr) | 0, Pt = Pt + Math.imul(Xt, ir) | 0, Je = Je + Math.imul(Xt, ar) | 0, Je = Je + Math.imul(zt, ir) | 0, Ot = Ot + Math.imul(zt, ar) | 0, Pt = Pt + Math.imul(Gt, vr) | 0, Je = Je + Math.imul(Gt, br) | 0, Je = Je + Math.imul(rr, vr) | 0, Ot = Ot + Math.imul(rr, br) | 0, Pt = Pt + Math.imul(sr, Pr) | 0, Je = Je + Math.imul(sr, Er) | 0, Je = Je + Math.imul(Jt, Pr) | 0, Ot = Ot + Math.imul(Jt, Er) | 0;
        var an = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (an >>> 26) | 0, an &= 67108863, Pt = Math.imul(jr, cr), Je = Math.imul(jr, lr), Je = Je + Math.imul(kr, cr) | 0, Ot = Math.imul(kr, lr), Pt = Pt + Math.imul(Lr, Nr) | 0, Je = Je + Math.imul(Lr, Tr) | 0, Je = Je + Math.imul(Rr, Nr) | 0, Ot = Ot + Math.imul(Rr, Tr) | 0, Pt = Pt + Math.imul(Fr, qr) | 0, Je = Je + Math.imul(Fr, Or) | 0, Je = Je + Math.imul(Ar, qr) | 0, Ot = Ot + Math.imul(Ar, Or) | 0, Pt = Pt + Math.imul($r, Yr) | 0, Je = Je + Math.imul($r, nr) | 0, Je = Je + Math.imul(Mr, Yr) | 0, Ot = Ot + Math.imul(Mr, nr) | 0, Pt = Pt + Math.imul(hr, ir) | 0, Je = Je + Math.imul(hr, ar) | 0, Je = Je + Math.imul(yr, ir) | 0, Ot = Ot + Math.imul(yr, ar) | 0, Pt = Pt + Math.imul(Xt, vr) | 0, Je = Je + Math.imul(Xt, br) | 0, Je = Je + Math.imul(zt, vr) | 0, Ot = Ot + Math.imul(zt, br) | 0, Pt = Pt + Math.imul(Gt, Pr) | 0, Je = Je + Math.imul(Gt, Er) | 0, Je = Je + Math.imul(rr, Pr) | 0, Ot = Ot + Math.imul(rr, Er) | 0, Pt = Pt + Math.imul(sr, Ir) | 0, Je = Je + Math.imul(sr, tr) | 0, Je = Je + Math.imul(Jt, Ir) | 0, Ot = Ot + Math.imul(Jt, tr) | 0;
        var nn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (nn >>> 26) | 0, nn &= 67108863, Pt = Math.imul(Xr, cr), Je = Math.imul(Xr, lr), Je = Je + Math.imul(Vt, cr) | 0, Ot = Math.imul(Vt, lr), Pt = Pt + Math.imul(jr, Nr) | 0, Je = Je + Math.imul(jr, Tr) | 0, Je = Je + Math.imul(kr, Nr) | 0, Ot = Ot + Math.imul(kr, Tr) | 0, Pt = Pt + Math.imul(Lr, qr) | 0, Je = Je + Math.imul(Lr, Or) | 0, Je = Je + Math.imul(Rr, qr) | 0, Ot = Ot + Math.imul(Rr, Or) | 0, Pt = Pt + Math.imul(Fr, Yr) | 0, Je = Je + Math.imul(Fr, nr) | 0, Je = Je + Math.imul(Ar, Yr) | 0, Ot = Ot + Math.imul(Ar, nr) | 0, Pt = Pt + Math.imul($r, ir) | 0, Je = Je + Math.imul($r, ar) | 0, Je = Je + Math.imul(Mr, ir) | 0, Ot = Ot + Math.imul(Mr, ar) | 0, Pt = Pt + Math.imul(hr, vr) | 0, Je = Je + Math.imul(hr, br) | 0, Je = Je + Math.imul(yr, vr) | 0, Ot = Ot + Math.imul(yr, br) | 0, Pt = Pt + Math.imul(Xt, Pr) | 0, Je = Je + Math.imul(Xt, Er) | 0, Je = Je + Math.imul(zt, Pr) | 0, Ot = Ot + Math.imul(zt, Er) | 0, Pt = Pt + Math.imul(Gt, Ir) | 0, Je = Je + Math.imul(Gt, tr) | 0, Je = Je + Math.imul(rr, Ir) | 0, Ot = Ot + Math.imul(rr, tr) | 0, Pt = Pt + Math.imul(sr, wr) | 0, Je = Je + Math.imul(sr, _r) | 0, Je = Je + Math.imul(Jt, wr) | 0, Ot = Ot + Math.imul(Jt, _r) | 0;
        var fn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (fn >>> 26) | 0, fn &= 67108863, Pt = Math.imul(Dt, cr), Je = Math.imul(Dt, lr), Je = Je + Math.imul(Qt, cr) | 0, Ot = Math.imul(Qt, lr), Pt = Pt + Math.imul(Xr, Nr) | 0, Je = Je + Math.imul(Xr, Tr) | 0, Je = Je + Math.imul(Vt, Nr) | 0, Ot = Ot + Math.imul(Vt, Tr) | 0, Pt = Pt + Math.imul(jr, qr) | 0, Je = Je + Math.imul(jr, Or) | 0, Je = Je + Math.imul(kr, qr) | 0, Ot = Ot + Math.imul(kr, Or) | 0, Pt = Pt + Math.imul(Lr, Yr) | 0, Je = Je + Math.imul(Lr, nr) | 0, Je = Je + Math.imul(Rr, Yr) | 0, Ot = Ot + Math.imul(Rr, nr) | 0, Pt = Pt + Math.imul(Fr, ir) | 0, Je = Je + Math.imul(Fr, ar) | 0, Je = Je + Math.imul(Ar, ir) | 0, Ot = Ot + Math.imul(Ar, ar) | 0, Pt = Pt + Math.imul($r, vr) | 0, Je = Je + Math.imul($r, br) | 0, Je = Je + Math.imul(Mr, vr) | 0, Ot = Ot + Math.imul(Mr, br) | 0, Pt = Pt + Math.imul(hr, Pr) | 0, Je = Je + Math.imul(hr, Er) | 0, Je = Je + Math.imul(yr, Pr) | 0, Ot = Ot + Math.imul(yr, Er) | 0, Pt = Pt + Math.imul(Xt, Ir) | 0, Je = Je + Math.imul(Xt, tr) | 0, Je = Je + Math.imul(zt, Ir) | 0, Ot = Ot + Math.imul(zt, tr) | 0, Pt = Pt + Math.imul(Gt, wr) | 0, Je = Je + Math.imul(Gt, _r) | 0, Je = Je + Math.imul(rr, wr) | 0, Ot = Ot + Math.imul(rr, _r) | 0, Pt = Pt + Math.imul(sr, Cr) | 0, Je = Je + Math.imul(sr, Br) | 0, Je = Je + Math.imul(Jt, Cr) | 0, Ot = Ot + Math.imul(Jt, Br) | 0;
        var un = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (un >>> 26) | 0, un &= 67108863, Pt = Math.imul(Dt, Nr), Je = Math.imul(Dt, Tr), Je = Je + Math.imul(Qt, Nr) | 0, Ot = Math.imul(Qt, Tr), Pt = Pt + Math.imul(Xr, qr) | 0, Je = Je + Math.imul(Xr, Or) | 0, Je = Je + Math.imul(Vt, qr) | 0, Ot = Ot + Math.imul(Vt, Or) | 0, Pt = Pt + Math.imul(jr, Yr) | 0, Je = Je + Math.imul(jr, nr) | 0, Je = Je + Math.imul(kr, Yr) | 0, Ot = Ot + Math.imul(kr, nr) | 0, Pt = Pt + Math.imul(Lr, ir) | 0, Je = Je + Math.imul(Lr, ar) | 0, Je = Je + Math.imul(Rr, ir) | 0, Ot = Ot + Math.imul(Rr, ar) | 0, Pt = Pt + Math.imul(Fr, vr) | 0, Je = Je + Math.imul(Fr, br) | 0, Je = Je + Math.imul(Ar, vr) | 0, Ot = Ot + Math.imul(Ar, br) | 0, Pt = Pt + Math.imul($r, Pr) | 0, Je = Je + Math.imul($r, Er) | 0, Je = Je + Math.imul(Mr, Pr) | 0, Ot = Ot + Math.imul(Mr, Er) | 0, Pt = Pt + Math.imul(hr, Ir) | 0, Je = Je + Math.imul(hr, tr) | 0, Je = Je + Math.imul(yr, Ir) | 0, Ot = Ot + Math.imul(yr, tr) | 0, Pt = Pt + Math.imul(Xt, wr) | 0, Je = Je + Math.imul(Xt, _r) | 0, Je = Je + Math.imul(zt, wr) | 0, Ot = Ot + Math.imul(zt, _r) | 0, Pt = Pt + Math.imul(Gt, Cr) | 0, Je = Je + Math.imul(Gt, Br) | 0, Je = Je + Math.imul(rr, Cr) | 0, Ot = Ot + Math.imul(rr, Br) | 0;
        var cn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (cn >>> 26) | 0, cn &= 67108863, Pt = Math.imul(Dt, qr), Je = Math.imul(Dt, Or), Je = Je + Math.imul(Qt, qr) | 0, Ot = Math.imul(Qt, Or), Pt = Pt + Math.imul(Xr, Yr) | 0, Je = Je + Math.imul(Xr, nr) | 0, Je = Je + Math.imul(Vt, Yr) | 0, Ot = Ot + Math.imul(Vt, nr) | 0, Pt = Pt + Math.imul(jr, ir) | 0, Je = Je + Math.imul(jr, ar) | 0, Je = Je + Math.imul(kr, ir) | 0, Ot = Ot + Math.imul(kr, ar) | 0, Pt = Pt + Math.imul(Lr, vr) | 0, Je = Je + Math.imul(Lr, br) | 0, Je = Je + Math.imul(Rr, vr) | 0, Ot = Ot + Math.imul(Rr, br) | 0, Pt = Pt + Math.imul(Fr, Pr) | 0, Je = Je + Math.imul(Fr, Er) | 0, Je = Je + Math.imul(Ar, Pr) | 0, Ot = Ot + Math.imul(Ar, Er) | 0, Pt = Pt + Math.imul($r, Ir) | 0, Je = Je + Math.imul($r, tr) | 0, Je = Je + Math.imul(Mr, Ir) | 0, Ot = Ot + Math.imul(Mr, tr) | 0, Pt = Pt + Math.imul(hr, wr) | 0, Je = Je + Math.imul(hr, _r) | 0, Je = Je + Math.imul(yr, wr) | 0, Ot = Ot + Math.imul(yr, _r) | 0, Pt = Pt + Math.imul(Xt, Cr) | 0, Je = Je + Math.imul(Xt, Br) | 0, Je = Je + Math.imul(zt, Cr) | 0, Ot = Ot + Math.imul(zt, Br) | 0;
        var ln = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (ln >>> 26) | 0, ln &= 67108863, Pt = Math.imul(Dt, Yr), Je = Math.imul(Dt, nr), Je = Je + Math.imul(Qt, Yr) | 0, Ot = Math.imul(Qt, nr), Pt = Pt + Math.imul(Xr, ir) | 0, Je = Je + Math.imul(Xr, ar) | 0, Je = Je + Math.imul(Vt, ir) | 0, Ot = Ot + Math.imul(Vt, ar) | 0, Pt = Pt + Math.imul(jr, vr) | 0, Je = Je + Math.imul(jr, br) | 0, Je = Je + Math.imul(kr, vr) | 0, Ot = Ot + Math.imul(kr, br) | 0, Pt = Pt + Math.imul(Lr, Pr) | 0, Je = Je + Math.imul(Lr, Er) | 0, Je = Je + Math.imul(Rr, Pr) | 0, Ot = Ot + Math.imul(Rr, Er) | 0, Pt = Pt + Math.imul(Fr, Ir) | 0, Je = Je + Math.imul(Fr, tr) | 0, Je = Je + Math.imul(Ar, Ir) | 0, Ot = Ot + Math.imul(Ar, tr) | 0, Pt = Pt + Math.imul($r, wr) | 0, Je = Je + Math.imul($r, _r) | 0, Je = Je + Math.imul(Mr, wr) | 0, Ot = Ot + Math.imul(Mr, _r) | 0, Pt = Pt + Math.imul(hr, Cr) | 0, Je = Je + Math.imul(hr, Br) | 0, Je = Je + Math.imul(yr, Cr) | 0, Ot = Ot + Math.imul(yr, Br) | 0;
        var hn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (hn >>> 26) | 0, hn &= 67108863, Pt = Math.imul(Dt, ir), Je = Math.imul(Dt, ar), Je = Je + Math.imul(Qt, ir) | 0, Ot = Math.imul(Qt, ar), Pt = Pt + Math.imul(Xr, vr) | 0, Je = Je + Math.imul(Xr, br) | 0, Je = Je + Math.imul(Vt, vr) | 0, Ot = Ot + Math.imul(Vt, br) | 0, Pt = Pt + Math.imul(jr, Pr) | 0, Je = Je + Math.imul(jr, Er) | 0, Je = Je + Math.imul(kr, Pr) | 0, Ot = Ot + Math.imul(kr, Er) | 0, Pt = Pt + Math.imul(Lr, Ir) | 0, Je = Je + Math.imul(Lr, tr) | 0, Je = Je + Math.imul(Rr, Ir) | 0, Ot = Ot + Math.imul(Rr, tr) | 0, Pt = Pt + Math.imul(Fr, wr) | 0, Je = Je + Math.imul(Fr, _r) | 0, Je = Je + Math.imul(Ar, wr) | 0, Ot = Ot + Math.imul(Ar, _r) | 0, Pt = Pt + Math.imul($r, Cr) | 0, Je = Je + Math.imul($r, Br) | 0, Je = Je + Math.imul(Mr, Cr) | 0, Ot = Ot + Math.imul(Mr, Br) | 0;
        var dn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (dn >>> 26) | 0, dn &= 67108863, Pt = Math.imul(Dt, vr), Je = Math.imul(Dt, br), Je = Je + Math.imul(Qt, vr) | 0, Ot = Math.imul(Qt, br), Pt = Pt + Math.imul(Xr, Pr) | 0, Je = Je + Math.imul(Xr, Er) | 0, Je = Je + Math.imul(Vt, Pr) | 0, Ot = Ot + Math.imul(Vt, Er) | 0, Pt = Pt + Math.imul(jr, Ir) | 0, Je = Je + Math.imul(jr, tr) | 0, Je = Je + Math.imul(kr, Ir) | 0, Ot = Ot + Math.imul(kr, tr) | 0, Pt = Pt + Math.imul(Lr, wr) | 0, Je = Je + Math.imul(Lr, _r) | 0, Je = Je + Math.imul(Rr, wr) | 0, Ot = Ot + Math.imul(Rr, _r) | 0, Pt = Pt + Math.imul(Fr, Cr) | 0, Je = Je + Math.imul(Fr, Br) | 0, Je = Je + Math.imul(Ar, Cr) | 0, Ot = Ot + Math.imul(Ar, Br) | 0;
        var pn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (pn >>> 26) | 0, pn &= 67108863, Pt = Math.imul(Dt, Pr), Je = Math.imul(Dt, Er), Je = Je + Math.imul(Qt, Pr) | 0, Ot = Math.imul(Qt, Er), Pt = Pt + Math.imul(Xr, Ir) | 0, Je = Je + Math.imul(Xr, tr) | 0, Je = Je + Math.imul(Vt, Ir) | 0, Ot = Ot + Math.imul(Vt, tr) | 0, Pt = Pt + Math.imul(jr, wr) | 0, Je = Je + Math.imul(jr, _r) | 0, Je = Je + Math.imul(kr, wr) | 0, Ot = Ot + Math.imul(kr, _r) | 0, Pt = Pt + Math.imul(Lr, Cr) | 0, Je = Je + Math.imul(Lr, Br) | 0, Je = Je + Math.imul(Rr, Cr) | 0, Ot = Ot + Math.imul(Rr, Br) | 0;
        var vn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (vn >>> 26) | 0, vn &= 67108863, Pt = Math.imul(Dt, Ir), Je = Math.imul(Dt, tr), Je = Je + Math.imul(Qt, Ir) | 0, Ot = Math.imul(Qt, tr), Pt = Pt + Math.imul(Xr, wr) | 0, Je = Je + Math.imul(Xr, _r) | 0, Je = Je + Math.imul(Vt, wr) | 0, Ot = Ot + Math.imul(Vt, _r) | 0, Pt = Pt + Math.imul(jr, Cr) | 0, Je = Je + Math.imul(jr, Br) | 0, Je = Je + Math.imul(kr, Cr) | 0, Ot = Ot + Math.imul(kr, Br) | 0;
        var yn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (yn >>> 26) | 0, yn &= 67108863, Pt = Math.imul(Dt, wr), Je = Math.imul(Dt, _r), Je = Je + Math.imul(Qt, wr) | 0, Ot = Math.imul(Qt, _r), Pt = Pt + Math.imul(Xr, Cr) | 0, Je = Je + Math.imul(Xr, Br) | 0, Je = Je + Math.imul(Vt, Cr) | 0, Ot = Ot + Math.imul(Vt, Br) | 0;
        var mn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        xt = (Ot + (Je >>> 13) | 0) + (mn >>> 26) | 0, mn &= 67108863, Pt = Math.imul(Dt, Cr), Je = Math.imul(Dt, Br), Je = Je + Math.imul(Qt, Cr) | 0, Ot = Math.imul(Qt, Br);
        var gn = (xt + Pt | 0) + ((Je & 8191) << 13) | 0;
        return xt = (Ot + (Je >>> 13) | 0) + (gn >>> 26) | 0, gn &= 67108863, $t[0] = zr, $t[1] = tn, $t[2] = Qr, $t[3] = en, $t[4] = sn, $t[5] = on, $t[6] = an, $t[7] = nn, $t[8] = fn, $t[9] = un, $t[10] = cn, $t[11] = ln, $t[12] = hn, $t[13] = dn, $t[14] = pn, $t[15] = vn, $t[16] = yn, $t[17] = mn, $t[18] = gn, xt !== 0 && ($t[19] = xt, Qe.length++), Qe;
      };
      Math.imul || (Bt = kt);
      function Ct(Xe, ve, Ce) {
        Ce.negative = ve.negative ^ Xe.negative, Ce.length = Xe.length + ve.length;
        for (var Qe = 0, vt = 0, wt = 0; wt < Ce.length - 1; wt++) {
          var $t = vt;
          vt = 0;
          for (var xt = Qe & 67108863, Pt = Math.min(wt, ve.length - 1), Je = Math.max(0, wt - Xe.length + 1); Je <= Pt; Je++) {
            var Ot = wt - Je, er = Xe.words[Ot] | 0, sr = ve.words[Je] | 0, Jt = er * sr, Wt = Jt & 67108863;
            $t = $t + (Jt / 67108864 | 0) | 0, Wt = Wt + xt | 0, xt = Wt & 67108863, $t = $t + (Wt >>> 26) | 0, vt += $t >>> 26, $t &= 67108863;
          }
          Ce.words[wt] = xt, Qe = $t, $t = vt;
        }
        return Qe !== 0 ? Ce.words[wt] = Qe : Ce.length--, Ce._strip();
      }
      function qt(Xe, ve, Ce) {
        return Ct(Xe, ve, Ce);
      }
      ne.prototype.mulTo = function(ve, Ce) {
        var Qe, vt = this.length + ve.length;
        return this.length === 10 && ve.length === 10 ? Qe = Bt(this, ve, Ce) : vt < 63 ? Qe = kt(this, ve, Ce) : vt < 1024 ? Qe = Ct(this, ve, Ce) : Qe = qt(this, ve, Ce), Qe;
      }, ne.prototype.mul = function(ve) {
        var Ce = new ne(null);
        return Ce.words = new Array(this.length + ve.length), this.mulTo(ve, Ce);
      }, ne.prototype.mulf = function(ve) {
        var Ce = new ne(null);
        return Ce.words = new Array(this.length + ve.length), qt(this, ve, Ce);
      }, ne.prototype.imul = function(ve) {
        return this.clone().mulTo(ve, this);
      }, ne.prototype.imuln = function(ve) {
        var Ce = ve < 0;
        Ce && (ve = -ve), ie(typeof ve == "number"), ie(ve < 67108864);
        for (var Qe = 0, vt = 0; vt < this.length; vt++) {
          var wt = (this.words[vt] | 0) * ve, $t = (wt & 67108863) + (Qe & 67108863);
          Qe >>= 26, Qe += wt / 67108864 | 0, Qe += $t >>> 26, this.words[vt] = $t & 67108863;
        }
        return Qe !== 0 && (this.words[vt] = Qe, this.length++), Ce ? this.ineg() : this;
      }, ne.prototype.muln = function(ve) {
        return this.clone().imuln(ve);
      }, ne.prototype.sqr = function() {
        return this.mul(this);
      }, ne.prototype.isqr = function() {
        return this.imul(this.clone());
      }, ne.prototype.pow = function(ve) {
        var Ce = Rt(ve);
        if (Ce.length === 0) return new ne(1);
        for (var Qe = this, vt = 0; vt < Ce.length && Ce[vt] === 0; vt++, Qe = Qe.sqr())
          ;
        if (++vt < Ce.length)
          for (var wt = Qe.sqr(); vt < Ce.length; vt++, wt = wt.sqr())
            Ce[vt] !== 0 && (Qe = Qe.mul(wt));
        return Qe;
      }, ne.prototype.iushln = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = ve % 26, Qe = (ve - Ce) / 26, vt = 67108863 >>> 26 - Ce << 26 - Ce, wt;
        if (Ce !== 0) {
          var $t = 0;
          for (wt = 0; wt < this.length; wt++) {
            var xt = this.words[wt] & vt, Pt = (this.words[wt] | 0) - xt << Ce;
            this.words[wt] = Pt | $t, $t = xt >>> 26 - Ce;
          }
          $t && (this.words[wt] = $t, this.length++);
        }
        if (Qe !== 0) {
          for (wt = this.length - 1; wt >= 0; wt--)
            this.words[wt + Qe] = this.words[wt];
          for (wt = 0; wt < Qe; wt++)
            this.words[wt] = 0;
          this.length += Qe;
        }
        return this._strip();
      }, ne.prototype.ishln = function(ve) {
        return ie(this.negative === 0), this.iushln(ve);
      }, ne.prototype.iushrn = function(ve, Ce, Qe) {
        ie(typeof ve == "number" && ve >= 0);
        var vt;
        Ce ? vt = (Ce - Ce % 26) / 26 : vt = 0;
        var wt = ve % 26, $t = Math.min((ve - wt) / 26, this.length), xt = 67108863 ^ 67108863 >>> wt << wt, Pt = Qe;
        if (vt -= $t, vt = Math.max(0, vt), Pt) {
          for (var Je = 0; Je < $t; Je++)
            Pt.words[Je] = this.words[Je];
          Pt.length = $t;
        }
        if ($t !== 0) if (this.length > $t)
          for (this.length -= $t, Je = 0; Je < this.length; Je++)
            this.words[Je] = this.words[Je + $t];
        else
          this.words[0] = 0, this.length = 1;
        var Ot = 0;
        for (Je = this.length - 1; Je >= 0 && (Ot !== 0 || Je >= vt); Je--) {
          var er = this.words[Je] | 0;
          this.words[Je] = Ot << 26 - wt | er >>> wt, Ot = er & xt;
        }
        return Pt && Ot !== 0 && (Pt.words[Pt.length++] = Ot), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, ne.prototype.ishrn = function(ve, Ce, Qe) {
        return ie(this.negative === 0), this.iushrn(ve, Ce, Qe);
      }, ne.prototype.shln = function(ve) {
        return this.clone().ishln(ve);
      }, ne.prototype.ushln = function(ve) {
        return this.clone().iushln(ve);
      }, ne.prototype.shrn = function(ve) {
        return this.clone().ishrn(ve);
      }, ne.prototype.ushrn = function(ve) {
        return this.clone().iushrn(ve);
      }, ne.prototype.testn = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = ve % 26, Qe = (ve - Ce) / 26, vt = 1 << Ce;
        if (this.length <= Qe) return !1;
        var wt = this.words[Qe];
        return !!(wt & vt);
      }, ne.prototype.imaskn = function(ve) {
        ie(typeof ve == "number" && ve >= 0);
        var Ce = ve % 26, Qe = (ve - Ce) / 26;
        if (ie(this.negative === 0, "imaskn works only with positive numbers"), this.length <= Qe)
          return this;
        if (Ce !== 0 && Qe++, this.length = Math.min(Qe, this.length), Ce !== 0) {
          var vt = 67108863 ^ 67108863 >>> Ce << Ce;
          this.words[this.length - 1] &= vt;
        }
        return this._strip();
      }, ne.prototype.maskn = function(ve) {
        return this.clone().imaskn(ve);
      }, ne.prototype.iaddn = function(ve) {
        return ie(typeof ve == "number"), ie(ve < 67108864), ve < 0 ? this.isubn(-ve) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= ve ? (this.words[0] = ve - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(ve), this.negative = 1, this) : this._iaddn(ve);
      }, ne.prototype._iaddn = function(ve) {
        this.words[0] += ve;
        for (var Ce = 0; Ce < this.length && this.words[Ce] >= 67108864; Ce++)
          this.words[Ce] -= 67108864, Ce === this.length - 1 ? this.words[Ce + 1] = 1 : this.words[Ce + 1]++;
        return this.length = Math.max(this.length, Ce + 1), this;
      }, ne.prototype.isubn = function(ve) {
        if (ie(typeof ve == "number"), ie(ve < 67108864), ve < 0) return this.iaddn(-ve);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(ve), this.negative = 1, this;
        if (this.words[0] -= ve, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var Ce = 0; Ce < this.length && this.words[Ce] < 0; Ce++)
            this.words[Ce] += 67108864, this.words[Ce + 1] -= 1;
        return this._strip();
      }, ne.prototype.addn = function(ve) {
        return this.clone().iaddn(ve);
      }, ne.prototype.subn = function(ve) {
        return this.clone().isubn(ve);
      }, ne.prototype.iabs = function() {
        return this.negative = 0, this;
      }, ne.prototype.abs = function() {
        return this.clone().iabs();
      }, ne.prototype._ishlnsubmul = function(ve, Ce, Qe) {
        var vt = ve.length + Qe, wt;
        this._expand(vt);
        var $t, xt = 0;
        for (wt = 0; wt < ve.length; wt++) {
          $t = (this.words[wt + Qe] | 0) + xt;
          var Pt = (ve.words[wt] | 0) * Ce;
          $t -= Pt & 67108863, xt = ($t >> 26) - (Pt / 67108864 | 0), this.words[wt + Qe] = $t & 67108863;
        }
        for (; wt < this.length - Qe; wt++)
          $t = (this.words[wt + Qe] | 0) + xt, xt = $t >> 26, this.words[wt + Qe] = $t & 67108863;
        if (xt === 0) return this._strip();
        for (ie(xt === -1), xt = 0, wt = 0; wt < this.length; wt++)
          $t = -(this.words[wt] | 0) + xt, xt = $t >> 26, this.words[wt] = $t & 67108863;
        return this.negative = 1, this._strip();
      }, ne.prototype._wordDiv = function(ve, Ce) {
        var Qe = this.length - ve.length, vt = this.clone(), wt = ve, $t = wt.words[wt.length - 1] | 0, xt = this._countBits($t);
        Qe = 26 - xt, Qe !== 0 && (wt = wt.ushln(Qe), vt.iushln(Qe), $t = wt.words[wt.length - 1] | 0);
        var Pt = vt.length - wt.length, Je;
        if (Ce !== "mod") {
          Je = new ne(null), Je.length = Pt + 1, Je.words = new Array(Je.length);
          for (var Ot = 0; Ot < Je.length; Ot++)
            Je.words[Ot] = 0;
        }
        var er = vt.clone()._ishlnsubmul(wt, 1, Pt);
        er.negative === 0 && (vt = er, Je && (Je.words[Pt] = 1));
        for (var sr = Pt - 1; sr >= 0; sr--) {
          var Jt = (vt.words[wt.length + sr] | 0) * 67108864 + (vt.words[wt.length + sr - 1] | 0);
          for (Jt = Math.min(Jt / $t | 0, 67108863), vt._ishlnsubmul(wt, Jt, sr); vt.negative !== 0; )
            Jt--, vt.negative = 0, vt._ishlnsubmul(wt, 1, sr), vt.isZero() || (vt.negative ^= 1);
          Je && (Je.words[sr] = Jt);
        }
        return Je && Je._strip(), vt._strip(), Ce !== "div" && Qe !== 0 && vt.iushrn(Qe), {
          div: Je || null,
          mod: vt
        };
      }, ne.prototype.divmod = function(ve, Ce, Qe) {
        if (ie(!ve.isZero()), this.isZero())
          return {
            div: new ne(0),
            mod: new ne(0)
          };
        var vt, wt, $t;
        return this.negative !== 0 && ve.negative === 0 ? ($t = this.neg().divmod(ve, Ce), Ce !== "mod" && (vt = $t.div.neg()), Ce !== "div" && (wt = $t.mod.neg(), Qe && wt.negative !== 0 && wt.iadd(ve)), {
          div: vt,
          mod: wt
        }) : this.negative === 0 && ve.negative !== 0 ? ($t = this.divmod(ve.neg(), Ce), Ce !== "mod" && (vt = $t.div.neg()), {
          div: vt,
          mod: $t.mod
        }) : this.negative & ve.negative ? ($t = this.neg().divmod(ve.neg(), Ce), Ce !== "div" && (wt = $t.mod.neg(), Qe && wt.negative !== 0 && wt.isub(ve)), {
          div: $t.div,
          mod: wt
        }) : ve.length > this.length || this.cmp(ve) < 0 ? {
          div: new ne(0),
          mod: this
        } : ve.length === 1 ? Ce === "div" ? {
          div: this.divn(ve.words[0]),
          mod: null
        } : Ce === "mod" ? {
          div: null,
          mod: new ne(this.modrn(ve.words[0]))
        } : {
          div: this.divn(ve.words[0]),
          mod: new ne(this.modrn(ve.words[0]))
        } : this._wordDiv(ve, Ce);
      }, ne.prototype.div = function(ve) {
        return this.divmod(ve, "div", !1).div;
      }, ne.prototype.mod = function(ve) {
        return this.divmod(ve, "mod", !1).mod;
      }, ne.prototype.umod = function(ve) {
        return this.divmod(ve, "mod", !0).mod;
      }, ne.prototype.divRound = function(ve) {
        var Ce = this.divmod(ve);
        if (Ce.mod.isZero()) return Ce.div;
        var Qe = Ce.div.negative !== 0 ? Ce.mod.isub(ve) : Ce.mod, vt = ve.ushrn(1), wt = ve.andln(1), $t = Qe.cmp(vt);
        return $t < 0 || wt === 1 && $t === 0 ? Ce.div : Ce.div.negative !== 0 ? Ce.div.isubn(1) : Ce.div.iaddn(1);
      }, ne.prototype.modrn = function(ve) {
        var Ce = ve < 0;
        Ce && (ve = -ve), ie(ve <= 67108863);
        for (var Qe = (1 << 26) % ve, vt = 0, wt = this.length - 1; wt >= 0; wt--)
          vt = (Qe * vt + (this.words[wt] | 0)) % ve;
        return Ce ? -vt : vt;
      }, ne.prototype.modn = function(ve) {
        return this.modrn(ve);
      }, ne.prototype.idivn = function(ve) {
        var Ce = ve < 0;
        Ce && (ve = -ve), ie(ve <= 67108863);
        for (var Qe = 0, vt = this.length - 1; vt >= 0; vt--) {
          var wt = (this.words[vt] | 0) + Qe * 67108864;
          this.words[vt] = wt / ve | 0, Qe = wt % ve;
        }
        return this._strip(), Ce ? this.ineg() : this;
      }, ne.prototype.divn = function(ve) {
        return this.clone().idivn(ve);
      }, ne.prototype.egcd = function(ve) {
        ie(ve.negative === 0), ie(!ve.isZero());
        var Ce = this, Qe = ve.clone();
        Ce.negative !== 0 ? Ce = Ce.umod(ve) : Ce = Ce.clone();
        for (var vt = new ne(1), wt = new ne(0), $t = new ne(0), xt = new ne(1), Pt = 0; Ce.isEven() && Qe.isEven(); )
          Ce.iushrn(1), Qe.iushrn(1), ++Pt;
        for (var Je = Qe.clone(), Ot = Ce.clone(); !Ce.isZero(); ) {
          for (var er = 0, sr = 1; !(Ce.words[0] & sr) && er < 26; ++er, sr <<= 1) ;
          if (er > 0)
            for (Ce.iushrn(er); er-- > 0; )
              (vt.isOdd() || wt.isOdd()) && (vt.iadd(Je), wt.isub(Ot)), vt.iushrn(1), wt.iushrn(1);
          for (var Jt = 0, Wt = 1; !(Qe.words[0] & Wt) && Jt < 26; ++Jt, Wt <<= 1) ;
          if (Jt > 0)
            for (Qe.iushrn(Jt); Jt-- > 0; )
              ($t.isOdd() || xt.isOdd()) && ($t.iadd(Je), xt.isub(Ot)), $t.iushrn(1), xt.iushrn(1);
          Ce.cmp(Qe) >= 0 ? (Ce.isub(Qe), vt.isub($t), wt.isub(xt)) : (Qe.isub(Ce), $t.isub(vt), xt.isub(wt));
        }
        return {
          a: $t,
          b: xt,
          gcd: Qe.iushln(Pt)
        };
      }, ne.prototype._invmp = function(ve) {
        ie(ve.negative === 0), ie(!ve.isZero());
        var Ce = this, Qe = ve.clone();
        Ce.negative !== 0 ? Ce = Ce.umod(ve) : Ce = Ce.clone();
        for (var vt = new ne(1), wt = new ne(0), $t = Qe.clone(); Ce.cmpn(1) > 0 && Qe.cmpn(1) > 0; ) {
          for (var xt = 0, Pt = 1; !(Ce.words[0] & Pt) && xt < 26; ++xt, Pt <<= 1) ;
          if (xt > 0)
            for (Ce.iushrn(xt); xt-- > 0; )
              vt.isOdd() && vt.iadd($t), vt.iushrn(1);
          for (var Je = 0, Ot = 1; !(Qe.words[0] & Ot) && Je < 26; ++Je, Ot <<= 1) ;
          if (Je > 0)
            for (Qe.iushrn(Je); Je-- > 0; )
              wt.isOdd() && wt.iadd($t), wt.iushrn(1);
          Ce.cmp(Qe) >= 0 ? (Ce.isub(Qe), vt.isub(wt)) : (Qe.isub(Ce), wt.isub(vt));
        }
        var er;
        return Ce.cmpn(1) === 0 ? er = vt : er = wt, er.cmpn(0) < 0 && er.iadd(ve), er;
      }, ne.prototype.gcd = function(ve) {
        if (this.isZero()) return ve.abs();
        if (ve.isZero()) return this.abs();
        var Ce = this.clone(), Qe = ve.clone();
        Ce.negative = 0, Qe.negative = 0;
        for (var vt = 0; Ce.isEven() && Qe.isEven(); vt++)
          Ce.iushrn(1), Qe.iushrn(1);
        do {
          for (; Ce.isEven(); )
            Ce.iushrn(1);
          for (; Qe.isEven(); )
            Qe.iushrn(1);
          var wt = Ce.cmp(Qe);
          if (wt < 0) {
            var $t = Ce;
            Ce = Qe, Qe = $t;
          } else if (wt === 0 || Qe.cmpn(1) === 0)
            break;
          Ce.isub(Qe);
        } while (!0);
        return Qe.iushln(vt);
      }, ne.prototype.invm = function(ve) {
        return this.egcd(ve).a.umod(ve);
      }, ne.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, ne.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, ne.prototype.andln = function(ve) {
        return this.words[0] & ve;
      }, ne.prototype.bincn = function(ve) {
        ie(typeof ve == "number");
        var Ce = ve % 26, Qe = (ve - Ce) / 26, vt = 1 << Ce;
        if (this.length <= Qe)
          return this._expand(Qe + 1), this.words[Qe] |= vt, this;
        for (var wt = vt, $t = Qe; wt !== 0 && $t < this.length; $t++) {
          var xt = this.words[$t] | 0;
          xt += wt, wt = xt >>> 26, xt &= 67108863, this.words[$t] = xt;
        }
        return wt !== 0 && (this.words[$t] = wt, this.length++), this;
      }, ne.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, ne.prototype.cmpn = function(ve) {
        var Ce = ve < 0;
        if (this.negative !== 0 && !Ce) return -1;
        if (this.negative === 0 && Ce) return 1;
        this._strip();
        var Qe;
        if (this.length > 1)
          Qe = 1;
        else {
          Ce && (ve = -ve), ie(ve <= 67108863, "Number is too big");
          var vt = this.words[0] | 0;
          Qe = vt === ve ? 0 : vt < ve ? -1 : 1;
        }
        return this.negative !== 0 ? -Qe | 0 : Qe;
      }, ne.prototype.cmp = function(ve) {
        if (this.negative !== 0 && ve.negative === 0) return -1;
        if (this.negative === 0 && ve.negative !== 0) return 1;
        var Ce = this.ucmp(ve);
        return this.negative !== 0 ? -Ce | 0 : Ce;
      }, ne.prototype.ucmp = function(ve) {
        if (this.length > ve.length) return 1;
        if (this.length < ve.length) return -1;
        for (var Ce = 0, Qe = this.length - 1; Qe >= 0; Qe--) {
          var vt = this.words[Qe] | 0, wt = ve.words[Qe] | 0;
          if (vt !== wt) {
            vt < wt ? Ce = -1 : vt > wt && (Ce = 1);
            break;
          }
        }
        return Ce;
      }, ne.prototype.gtn = function(ve) {
        return this.cmpn(ve) === 1;
      }, ne.prototype.gt = function(ve) {
        return this.cmp(ve) === 1;
      }, ne.prototype.gten = function(ve) {
        return this.cmpn(ve) >= 0;
      }, ne.prototype.gte = function(ve) {
        return this.cmp(ve) >= 0;
      }, ne.prototype.ltn = function(ve) {
        return this.cmpn(ve) === -1;
      }, ne.prototype.lt = function(ve) {
        return this.cmp(ve) === -1;
      }, ne.prototype.lten = function(ve) {
        return this.cmpn(ve) <= 0;
      }, ne.prototype.lte = function(ve) {
        return this.cmp(ve) <= 0;
      }, ne.prototype.eqn = function(ve) {
        return this.cmpn(ve) === 0;
      }, ne.prototype.eq = function(ve) {
        return this.cmp(ve) === 0;
      }, ne.red = function(ve) {
        return new Ft(ve);
      }, ne.prototype.toRed = function(ve) {
        return ie(!this.red, "Already a number in reduction context"), ie(this.negative === 0, "red works only with positives"), ve.convertTo(this)._forceRed(ve);
      }, ne.prototype.fromRed = function() {
        return ie(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, ne.prototype._forceRed = function(ve) {
        return this.red = ve, this;
      }, ne.prototype.forceRed = function(ve) {
        return ie(!this.red, "Already a number in reduction context"), this._forceRed(ve);
      }, ne.prototype.redAdd = function(ve) {
        return ie(this.red, "redAdd works only with red numbers"), this.red.add(this, ve);
      }, ne.prototype.redIAdd = function(ve) {
        return ie(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, ve);
      }, ne.prototype.redSub = function(ve) {
        return ie(this.red, "redSub works only with red numbers"), this.red.sub(this, ve);
      }, ne.prototype.redISub = function(ve) {
        return ie(this.red, "redISub works only with red numbers"), this.red.isub(this, ve);
      }, ne.prototype.redShl = function(ve) {
        return ie(this.red, "redShl works only with red numbers"), this.red.shl(this, ve);
      }, ne.prototype.redMul = function(ve) {
        return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, ve), this.red.mul(this, ve);
      }, ne.prototype.redIMul = function(ve) {
        return ie(this.red, "redMul works only with red numbers"), this.red._verify2(this, ve), this.red.imul(this, ve);
      }, ne.prototype.redSqr = function() {
        return ie(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, ne.prototype.redISqr = function() {
        return ie(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, ne.prototype.redSqrt = function() {
        return ie(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, ne.prototype.redInvm = function() {
        return ie(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, ne.prototype.redNeg = function() {
        return ie(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, ne.prototype.redPow = function(ve) {
        return ie(this.red && !ve.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, ve);
      };
      var jt = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Ht(Xe, ve) {
        this.name = Xe, this.p = new ne(ve, 16), this.n = this.p.bitLength(), this.k = new ne(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ht.prototype._tmp = function() {
        var ve = new ne(null);
        return ve.words = new Array(Math.ceil(this.n / 13)), ve;
      }, Ht.prototype.ireduce = function(ve) {
        var Ce = ve, Qe;
        do
          this.split(Ce, this.tmp), Ce = this.imulK(Ce), Ce = Ce.iadd(this.tmp), Qe = Ce.bitLength();
        while (Qe > this.n);
        var vt = Qe < this.n ? -1 : Ce.ucmp(this.p);
        return vt === 0 ? (Ce.words[0] = 0, Ce.length = 1) : vt > 0 ? Ce.isub(this.p) : Ce.strip !== void 0 ? Ce.strip() : Ce._strip(), Ce;
      }, Ht.prototype.split = function(ve, Ce) {
        ve.iushrn(this.n, 0, Ce);
      }, Ht.prototype.imulK = function(ve) {
        return ve.imul(this.k);
      };
      function Yt() {
        Ht.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      se(Yt, Ht), Yt.prototype.split = function(ve, Ce) {
        for (var Qe = 4194303, vt = Math.min(ve.length, 9), wt = 0; wt < vt; wt++)
          Ce.words[wt] = ve.words[wt];
        if (Ce.length = vt, ve.length <= 9) {
          ve.words[0] = 0, ve.length = 1;
          return;
        }
        var $t = ve.words[9];
        for (Ce.words[Ce.length++] = $t & Qe, wt = 10; wt < ve.length; wt++) {
          var xt = ve.words[wt] | 0;
          ve.words[wt - 10] = (xt & Qe) << 4 | $t >>> 22, $t = xt;
        }
        $t >>>= 22, ve.words[wt - 10] = $t, $t === 0 && ve.length > 10 ? ve.length -= 10 : ve.length -= 9;
      }, Yt.prototype.imulK = function(ve) {
        ve.words[ve.length] = 0, ve.words[ve.length + 1] = 0, ve.length += 2;
        for (var Ce = 0, Qe = 0; Qe < ve.length; Qe++) {
          var vt = ve.words[Qe] | 0;
          Ce += vt * 977, ve.words[Qe] = Ce & 67108863, Ce = vt * 64 + (Ce / 67108864 | 0);
        }
        return ve.words[ve.length - 1] === 0 && (ve.length--, ve.words[ve.length - 1] === 0 && ve.length--), ve;
      };
      function Ut() {
        Ht.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      se(Ut, Ht);
      function Nt() {
        Ht.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      se(Nt, Ht);
      function Kt() {
        Ht.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      se(Kt, Ht), Kt.prototype.imulK = function(ve) {
        for (var Ce = 0, Qe = 0; Qe < ve.length; Qe++) {
          var vt = (ve.words[Qe] | 0) * 19 + Ce, wt = vt & 67108863;
          vt >>>= 26, ve.words[Qe] = wt, Ce = vt;
        }
        return Ce !== 0 && (ve.words[ve.length++] = Ce), ve;
      }, ne._prime = function(ve) {
        if (jt[ve]) return jt[ve];
        var Ce;
        if (ve === "k256")
          Ce = new Yt();
        else if (ve === "p224")
          Ce = new Ut();
        else if (ve === "p192")
          Ce = new Nt();
        else if (ve === "p25519")
          Ce = new Kt();
        else
          throw new Error("Unknown prime " + ve);
        return jt[ve] = Ce, Ce;
      };
      function Ft(Xe) {
        if (typeof Xe == "string") {
          var ve = ne._prime(Xe);
          this.m = ve.p, this.prime = ve;
        } else
          ie(Xe.gtn(1), "modulus must be greater than 1"), this.m = Xe, this.prime = null;
      }
      Ft.prototype._verify1 = function(ve) {
        ie(ve.negative === 0, "red works only with positives"), ie(ve.red, "red works only with red numbers");
      }, Ft.prototype._verify2 = function(ve, Ce) {
        ie((ve.negative | Ce.negative) === 0, "red works only with positives"), ie(
          ve.red && ve.red === Ce.red,
          "red works only with red numbers"
        );
      }, Ft.prototype.imod = function(ve) {
        return this.prime ? this.prime.ireduce(ve)._forceRed(this) : (oe(ve, ve.umod(this.m)._forceRed(this)), ve);
      }, Ft.prototype.neg = function(ve) {
        return ve.isZero() ? ve.clone() : this.m.sub(ve)._forceRed(this);
      }, Ft.prototype.add = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.add(Ce);
        return Qe.cmp(this.m) >= 0 && Qe.isub(this.m), Qe._forceRed(this);
      }, Ft.prototype.iadd = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.iadd(Ce);
        return Qe.cmp(this.m) >= 0 && Qe.isub(this.m), Qe;
      }, Ft.prototype.sub = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.sub(Ce);
        return Qe.cmpn(0) < 0 && Qe.iadd(this.m), Qe._forceRed(this);
      }, Ft.prototype.isub = function(ve, Ce) {
        this._verify2(ve, Ce);
        var Qe = ve.isub(Ce);
        return Qe.cmpn(0) < 0 && Qe.iadd(this.m), Qe;
      }, Ft.prototype.shl = function(ve, Ce) {
        return this._verify1(ve), this.imod(ve.ushln(Ce));
      }, Ft.prototype.imul = function(ve, Ce) {
        return this._verify2(ve, Ce), this.imod(ve.imul(Ce));
      }, Ft.prototype.mul = function(ve, Ce) {
        return this._verify2(ve, Ce), this.imod(ve.mul(Ce));
      }, Ft.prototype.isqr = function(ve) {
        return this.imul(ve, ve.clone());
      }, Ft.prototype.sqr = function(ve) {
        return this.mul(ve, ve);
      }, Ft.prototype.sqrt = function(ve) {
        if (ve.isZero()) return ve.clone();
        var Ce = this.m.andln(3);
        if (ie(Ce % 2 === 1), Ce === 3) {
          var Qe = this.m.add(new ne(1)).iushrn(2);
          return this.pow(ve, Qe);
        }
        for (var vt = this.m.subn(1), wt = 0; !vt.isZero() && vt.andln(1) === 0; )
          wt++, vt.iushrn(1);
        ie(!vt.isZero());
        var $t = new ne(1).toRed(this), xt = $t.redNeg(), Pt = this.m.subn(1).iushrn(1), Je = this.m.bitLength();
        for (Je = new ne(2 * Je * Je).toRed(this); this.pow(Je, Pt).cmp(xt) !== 0; )
          Je.redIAdd(xt);
        for (var Ot = this.pow(Je, vt), er = this.pow(ve, vt.addn(1).iushrn(1)), sr = this.pow(ve, vt), Jt = wt; sr.cmp($t) !== 0; ) {
          for (var Wt = sr, Gt = 0; Wt.cmp($t) !== 0; Gt++)
            Wt = Wt.redSqr();
          ie(Gt < Jt);
          var rr = this.pow(Ot, new ne(1).iushln(Jt - Gt - 1));
          er = er.redMul(rr), Ot = rr.redSqr(), sr = sr.redMul(Ot), Jt = Gt;
        }
        return er;
      }, Ft.prototype.invm = function(ve) {
        var Ce = ve._invmp(this.m);
        return Ce.negative !== 0 ? (Ce.negative = 0, this.imod(Ce).redNeg()) : this.imod(Ce);
      }, Ft.prototype.pow = function(ve, Ce) {
        if (Ce.isZero()) return new ne(1).toRed(this);
        if (Ce.cmpn(1) === 0) return ve.clone();
        var Qe = 4, vt = new Array(1 << Qe);
        vt[0] = new ne(1).toRed(this), vt[1] = ve;
        for (var wt = 2; wt < vt.length; wt++)
          vt[wt] = this.mul(vt[wt - 1], ve);
        var $t = vt[0], xt = 0, Pt = 0, Je = Ce.bitLength() % 26;
        for (Je === 0 && (Je = 26), wt = Ce.length - 1; wt >= 0; wt--) {
          for (var Ot = Ce.words[wt], er = Je - 1; er >= 0; er--) {
            var sr = Ot >> er & 1;
            if ($t !== vt[0] && ($t = this.sqr($t)), sr === 0 && xt === 0) {
              Pt = 0;
              continue;
            }
            xt <<= 1, xt |= sr, Pt++, !(Pt !== Qe && (wt !== 0 || er !== 0)) && ($t = this.mul($t, vt[xt]), Pt = 0, xt = 0);
          }
          Je = 26;
        }
        return $t;
      }, Ft.prototype.convertTo = function(ve) {
        var Ce = ve.umod(this.m);
        return Ce === ve ? Ce.clone() : Ce;
      }, Ft.prototype.convertFrom = function(ve) {
        var Ce = ve.clone();
        return Ce.red = null, Ce;
      }, ne.mont = function(ve) {
        return new bt(ve);
      };
      function bt(Xe) {
        Ft.call(this, Xe), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new ne(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      se(bt, Ft), bt.prototype.convertTo = function(ve) {
        return this.imod(ve.ushln(this.shift));
      }, bt.prototype.convertFrom = function(ve) {
        var Ce = this.imod(ve.mul(this.rinv));
        return Ce.red = null, Ce;
      }, bt.prototype.imul = function(ve, Ce) {
        if (ve.isZero() || Ce.isZero())
          return ve.words[0] = 0, ve.length = 1, ve;
        var Qe = ve.imul(Ce), vt = Qe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), wt = Qe.isub(vt).iushrn(this.shift), $t = wt;
        return wt.cmp(this.m) >= 0 ? $t = wt.isub(this.m) : wt.cmpn(0) < 0 && ($t = wt.iadd(this.m)), $t._forceRed(this);
      }, bt.prototype.mul = function(ve, Ce) {
        if (ve.isZero() || Ce.isZero()) return new ne(0)._forceRed(this);
        var Qe = ve.mul(Ce), vt = Qe.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), wt = Qe.isub(vt).iushrn(this.shift), $t = wt;
        return wt.cmp(this.m) >= 0 ? $t = wt.isub(this.m) : wt.cmpn(0) < 0 && ($t = wt.iadd(this.m)), $t._forceRed(this);
      }, bt.prototype.invm = function(ve) {
        var Ce = this.imod(ve._invmp(this.m).mul(this.r2));
        return Ce._forceRed(this);
      };
    })(B, commonjsGlobal);
  }(bn)), bn.exports;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(B, z) {
      if (B.indexOf) return B.indexOf(z);
      for (var Y = 0; Y < B.length; Y++)
        if (B[Y] === z) return Y;
      return -1;
    }, Object_keys = function(B) {
      if (Object.keys) return Object.keys(B);
      var z = [];
      for (var Y in B) z.push(Y);
      return z;
    }, forEach = function(B, z) {
      if (B.forEach) return B.forEach(z);
      for (var Y = 0; Y < B.length; Y++)
        z(B[Y], Y, B);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(B, z, Y) {
          Object.defineProperty(B, z, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: Y
          });
        };
      } catch {
        return function(z, Y, ie) {
          z[Y] = ie;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(z) {
      if (!(this instanceof Script)) return new Script(z);
      this.code = z;
    };
    Script.prototype.runInContext = function(B) {
      if (!(B instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var z = document.createElement("iframe");
      z.style || (z.style = {}), z.style.display = "none", document.body.appendChild(z);
      var Y = z.contentWindow, ie = Y.eval, se = Y.execScript;
      !ie && se && (se.call(Y, "null"), ie = Y.eval), forEach(Object_keys(B), function(le) {
        Y[le] = B[le];
      }), forEach(globals, function(le) {
        B[le] && (Y[le] = B[le]);
      });
      var ne = Object_keys(Y), ae = ie.call(Y, this.code);
      return forEach(Object_keys(Y), function(le) {
        (le in B || indexOf(ne, le) === -1) && (B[le] = Y[le]);
      }), forEach(globals, function(le) {
        le in B || defineProp(B, le, Y[le]);
      }), document.body.removeChild(z), ae;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(B) {
      var z = Script.createContext(B), Y = this.runInContext(z);
      return B && forEach(Object_keys(z), function(ie) {
        B[ie] = z[ie];
      }), Y;
    }, forEach(Object_keys(Script.prototype), function(B) {
      exports[B] = Script[B] = function(z) {
        var Y = Script(z);
        return Y[B].apply(Y, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(B) {
      return B instanceof Context;
    }, exports.createScript = function(B) {
      return exports.Script(B);
    }, exports.createContext = Script.createContext = function(B) {
      var z = new Context();
      return typeof B == "object" && forEach(Object_keys(B), function(Y) {
        z[Y] = B[Y];
      }), z;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(B) {
    var z = requireAsn1$1(), Y = requireInherits_browser(), ie = B;
    ie.define = function(ae, le) {
      return new se(ae, le);
    };
    function se(ne, ae) {
      this.name = ne, this.body = ae, this.decoders = {}, this.encoders = {};
    }
    se.prototype._createNamed = function(ae) {
      var le;
      try {
        le = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        le = function(Ee) {
          this._initNamed(Ee);
        };
      }
      return Y(le, ae), le.prototype._initNamed = function(Ee) {
        ae.call(this, Ee);
      }, new le(this);
    }, se.prototype._getDecoder = function(ae) {
      return ae = ae || "der", this.decoders.hasOwnProperty(ae) || (this.decoders[ae] = this._createNamed(z.decoders[ae])), this.decoders[ae];
    }, se.prototype.decode = function(ae, le, ge) {
      return this._getDecoder(le).decode(ae, ge);
    }, se.prototype._getEncoder = function(ae) {
      return ae = ae || "der", this.encoders.hasOwnProperty(ae) || (this.encoders[ae] = this._createNamed(z.encoders[ae])), this.encoders[ae];
    }, se.prototype.encode = function(ae, le, ge) {
      return this._getEncoder(le).encode(ae, ge);
    };
  }(api)), api;
}
var base$2 = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter) return reporter;
  hasRequiredReporter = 1;
  var B = requireInherits_browser();
  function z(ie) {
    this._reporterState = {
      obj: null,
      path: [],
      options: ie || {},
      errors: []
    };
  }
  reporter.Reporter = z, z.prototype.isError = function(se) {
    return se instanceof Y;
  }, z.prototype.save = function() {
    var se = this._reporterState;
    return { obj: se.obj, pathLen: se.path.length };
  }, z.prototype.restore = function(se) {
    var ne = this._reporterState;
    ne.obj = se.obj, ne.path = ne.path.slice(0, se.pathLen);
  }, z.prototype.enterKey = function(se) {
    return this._reporterState.path.push(se);
  }, z.prototype.exitKey = function(se) {
    var ne = this._reporterState;
    ne.path = ne.path.slice(0, se - 1);
  }, z.prototype.leaveKey = function(se, ne, ae) {
    var le = this._reporterState;
    this.exitKey(se), le.obj !== null && (le.obj[ne] = ae);
  }, z.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, z.prototype.enterObject = function() {
    var se = this._reporterState, ne = se.obj;
    return se.obj = {}, ne;
  }, z.prototype.leaveObject = function(se) {
    var ne = this._reporterState, ae = ne.obj;
    return ne.obj = se, ae;
  }, z.prototype.error = function(se) {
    var ne, ae = this._reporterState, le = se instanceof Y;
    if (le ? ne = se : ne = new Y(ae.path.map(function(ge) {
      return "[" + JSON.stringify(ge) + "]";
    }).join(""), se.message || se, se.stack), !ae.options.partial)
      throw ne;
    return le || ae.errors.push(ne), ne;
  }, z.prototype.wrapResult = function(se) {
    var ne = this._reporterState;
    return ne.options.partial ? {
      result: this.isError(se) ? null : se,
      errors: ne.errors
    } : se;
  };
  function Y(ie, se) {
    this.path = ie, this.rethrow(se);
  }
  return B(Y, Error), Y.prototype.rethrow = function(se) {
    if (this.message = se + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Y), !this.stack)
      try {
        throw new Error(this.message);
      } catch (ne) {
        this.stack = ne.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var B = requireInherits_browser(), z = requireBase().Reporter, Y = require$$0$1.Buffer;
  function ie(ne, ae) {
    if (z.call(this, ae), !Y.isBuffer(ne)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = ne, this.offset = 0, this.length = ne.length;
  }
  B(ie, z), buffer.DecoderBuffer = ie, ie.prototype.save = function() {
    return { offset: this.offset, reporter: z.prototype.save.call(this) };
  }, ie.prototype.restore = function(ae) {
    var le = new ie(this.base);
    return le.offset = ae.offset, le.length = this.offset, this.offset = ae.offset, z.prototype.restore.call(this, ae.reporter), le;
  }, ie.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, ie.prototype.readUInt8 = function(ae) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(ae || "DecoderBuffer overrun");
  }, ie.prototype.skip = function(ae, le) {
    if (!(this.offset + ae <= this.length))
      return this.error(le || "DecoderBuffer overrun");
    var ge = new ie(this.base);
    return ge._reporterState = this._reporterState, ge.offset = this.offset, ge.length = this.offset + ae, this.offset += ae, ge;
  }, ie.prototype.raw = function(ae) {
    return this.base.slice(ae ? ae.offset : this.offset, this.length);
  };
  function se(ne, ae) {
    if (Array.isArray(ne))
      this.length = 0, this.value = ne.map(function(le) {
        return le instanceof se || (le = new se(le, ae)), this.length += le.length, le;
      }, this);
    else if (typeof ne == "number") {
      if (!(0 <= ne && ne <= 255))
        return ae.error("non-byte EncoderBuffer value");
      this.value = ne, this.length = 1;
    } else if (typeof ne == "string")
      this.value = ne, this.length = Y.byteLength(ne);
    else if (Y.isBuffer(ne))
      this.value = ne, this.length = ne.length;
    else
      return ae.error("Unsupported type: " + typeof ne);
  }
  return buffer.EncoderBuffer = se, se.prototype.join = function(ae, le) {
    return ae || (ae = new Y(this.length)), le || (le = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(ge) {
      ge.join(ae, le), le += ge.length;
    }) : (typeof this.value == "number" ? ae[le] = this.value : typeof this.value == "string" ? ae.write(this.value, le) : Y.isBuffer(this.value) && this.value.copy(ae, le), le += this.length)), ae;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var B = requireBase().Reporter, z = requireBase().EncoderBuffer, Y = requireBase().DecoderBuffer, ie = requireMinimalisticAssert(), se = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], ne = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(se), ae = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function le(Ee, oe) {
    var Pe = {};
    this._baseState = Pe, Pe.enc = Ee, Pe.parent = oe || null, Pe.children = null, Pe.tag = null, Pe.args = null, Pe.reverseArgs = null, Pe.choice = null, Pe.optional = !1, Pe.any = !1, Pe.obj = !1, Pe.use = null, Pe.useDecoder = null, Pe.key = null, Pe.default = null, Pe.explicit = null, Pe.implicit = null, Pe.contains = null, Pe.parent || (Pe.children = [], this._wrap());
  }
  node = le;
  var ge = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return le.prototype.clone = function() {
    var oe = this._baseState, Pe = {};
    ge.forEach(function(Ke) {
      Pe[Ke] = oe[Ke];
    });
    var Ve = new this.constructor(Pe.parent);
    return Ve._baseState = Pe, Ve;
  }, le.prototype._wrap = function() {
    var oe = this._baseState;
    ne.forEach(function(Pe) {
      this[Pe] = function() {
        var Ke = new this.constructor(this);
        return oe.children.push(Ke), Ke[Pe].apply(Ke, arguments);
      };
    }, this);
  }, le.prototype._init = function(oe) {
    var Pe = this._baseState;
    ie(Pe.parent === null), oe.call(this), Pe.children = Pe.children.filter(function(Ve) {
      return Ve._baseState.parent === this;
    }, this), ie.equal(Pe.children.length, 1, "Root node can have only one child");
  }, le.prototype._useArgs = function(oe) {
    var Pe = this._baseState, Ve = oe.filter(function(Ke) {
      return Ke instanceof this.constructor;
    }, this);
    oe = oe.filter(function(Ke) {
      return !(Ke instanceof this.constructor);
    }, this), Ve.length !== 0 && (ie(Pe.children === null), Pe.children = Ve, Ve.forEach(function(Ke) {
      Ke._baseState.parent = this;
    }, this)), oe.length !== 0 && (ie(Pe.args === null), Pe.args = oe, Pe.reverseArgs = oe.map(function(Ke) {
      if (typeof Ke != "object" || Ke.constructor !== Object)
        return Ke;
      var ht = {};
      return Object.keys(Ke).forEach(function(_t) {
        _t == (_t | 0) && (_t |= 0);
        var Rt = Ke[_t];
        ht[Rt] = _t;
      }), ht;
    }));
  }, ae.forEach(function(Ee) {
    le.prototype[Ee] = function() {
      var Pe = this._baseState;
      throw new Error(Ee + " not implemented for encoding: " + Pe.enc);
    };
  }), se.forEach(function(Ee) {
    le.prototype[Ee] = function() {
      var Pe = this._baseState, Ve = Array.prototype.slice.call(arguments);
      return ie(Pe.tag === null), Pe.tag = Ee, this._useArgs(Ve), this;
    };
  }), le.prototype.use = function(oe) {
    ie(oe);
    var Pe = this._baseState;
    return ie(Pe.use === null), Pe.use = oe, this;
  }, le.prototype.optional = function() {
    var oe = this._baseState;
    return oe.optional = !0, this;
  }, le.prototype.def = function(oe) {
    var Pe = this._baseState;
    return ie(Pe.default === null), Pe.default = oe, Pe.optional = !0, this;
  }, le.prototype.explicit = function(oe) {
    var Pe = this._baseState;
    return ie(Pe.explicit === null && Pe.implicit === null), Pe.explicit = oe, this;
  }, le.prototype.implicit = function(oe) {
    var Pe = this._baseState;
    return ie(Pe.explicit === null && Pe.implicit === null), Pe.implicit = oe, this;
  }, le.prototype.obj = function() {
    var oe = this._baseState, Pe = Array.prototype.slice.call(arguments);
    return oe.obj = !0, Pe.length !== 0 && this._useArgs(Pe), this;
  }, le.prototype.key = function(oe) {
    var Pe = this._baseState;
    return ie(Pe.key === null), Pe.key = oe, this;
  }, le.prototype.any = function() {
    var oe = this._baseState;
    return oe.any = !0, this;
  }, le.prototype.choice = function(oe) {
    var Pe = this._baseState;
    return ie(Pe.choice === null), Pe.choice = oe, this._useArgs(Object.keys(oe).map(function(Ve) {
      return oe[Ve];
    })), this;
  }, le.prototype.contains = function(oe) {
    var Pe = this._baseState;
    return ie(Pe.use === null), Pe.contains = oe, this;
  }, le.prototype._decode = function(oe, Pe) {
    var Ve = this._baseState;
    if (Ve.parent === null)
      return oe.wrapResult(Ve.children[0]._decode(oe, Pe));
    var Ke = Ve.default, ht = !0, _t = null;
    if (Ve.key !== null && (_t = oe.enterKey(Ve.key)), Ve.optional) {
      var Rt = null;
      if (Ve.explicit !== null ? Rt = Ve.explicit : Ve.implicit !== null ? Rt = Ve.implicit : Ve.tag !== null && (Rt = Ve.tag), Rt === null && !Ve.any) {
        var kt = oe.save();
        try {
          Ve.choice === null ? this._decodeGeneric(Ve.tag, oe, Pe) : this._decodeChoice(oe, Pe), ht = !0;
        } catch {
          ht = !1;
        }
        oe.restore(kt);
      } else if (ht = this._peekTag(oe, Rt, Ve.any), oe.isError(ht))
        return ht;
    }
    var Bt;
    if (Ve.obj && ht && (Bt = oe.enterObject()), ht) {
      if (Ve.explicit !== null) {
        var Ct = this._decodeTag(oe, Ve.explicit);
        if (oe.isError(Ct))
          return Ct;
        oe = Ct;
      }
      var qt = oe.offset;
      if (Ve.use === null && Ve.choice === null) {
        if (Ve.any)
          var kt = oe.save();
        var jt = this._decodeTag(
          oe,
          Ve.implicit !== null ? Ve.implicit : Ve.tag,
          Ve.any
        );
        if (oe.isError(jt))
          return jt;
        Ve.any ? Ke = oe.raw(kt) : oe = jt;
      }
      if (Pe && Pe.track && Ve.tag !== null && Pe.track(oe.path(), qt, oe.length, "tagged"), Pe && Pe.track && Ve.tag !== null && Pe.track(oe.path(), oe.offset, oe.length, "content"), Ve.any ? Ke = Ke : Ve.choice === null ? Ke = this._decodeGeneric(Ve.tag, oe, Pe) : Ke = this._decodeChoice(oe, Pe), oe.isError(Ke))
        return Ke;
      if (!Ve.any && Ve.choice === null && Ve.children !== null && Ve.children.forEach(function(Ut) {
        Ut._decode(oe, Pe);
      }), Ve.contains && (Ve.tag === "octstr" || Ve.tag === "bitstr")) {
        var Ht = new Y(Ke);
        Ke = this._getUse(Ve.contains, oe._reporterState.obj)._decode(Ht, Pe);
      }
    }
    return Ve.obj && ht && (Ke = oe.leaveObject(Bt)), Ve.key !== null && (Ke !== null || ht === !0) ? oe.leaveKey(_t, Ve.key, Ke) : _t !== null && oe.exitKey(_t), Ke;
  }, le.prototype._decodeGeneric = function(oe, Pe, Ve) {
    var Ke = this._baseState;
    return oe === "seq" || oe === "set" ? null : oe === "seqof" || oe === "setof" ? this._decodeList(Pe, oe, Ke.args[0], Ve) : /str$/.test(oe) ? this._decodeStr(Pe, oe, Ve) : oe === "objid" && Ke.args ? this._decodeObjid(Pe, Ke.args[0], Ke.args[1], Ve) : oe === "objid" ? this._decodeObjid(Pe, null, null, Ve) : oe === "gentime" || oe === "utctime" ? this._decodeTime(Pe, oe, Ve) : oe === "null_" ? this._decodeNull(Pe, Ve) : oe === "bool" ? this._decodeBool(Pe, Ve) : oe === "objDesc" ? this._decodeStr(Pe, oe, Ve) : oe === "int" || oe === "enum" ? this._decodeInt(Pe, Ke.args && Ke.args[0], Ve) : Ke.use !== null ? this._getUse(Ke.use, Pe._reporterState.obj)._decode(Pe, Ve) : Pe.error("unknown tag: " + oe);
  }, le.prototype._getUse = function(oe, Pe) {
    var Ve = this._baseState;
    return Ve.useDecoder = this._use(oe, Pe), ie(Ve.useDecoder._baseState.parent === null), Ve.useDecoder = Ve.useDecoder._baseState.children[0], Ve.implicit !== Ve.useDecoder._baseState.implicit && (Ve.useDecoder = Ve.useDecoder.clone(), Ve.useDecoder._baseState.implicit = Ve.implicit), Ve.useDecoder;
  }, le.prototype._decodeChoice = function(oe, Pe) {
    var Ve = this._baseState, Ke = null, ht = !1;
    return Object.keys(Ve.choice).some(function(_t) {
      var Rt = oe.save(), kt = Ve.choice[_t];
      try {
        var Bt = kt._decode(oe, Pe);
        if (oe.isError(Bt))
          return !1;
        Ke = { type: _t, value: Bt }, ht = !0;
      } catch {
        return oe.restore(Rt), !1;
      }
      return !0;
    }, this), ht ? Ke : oe.error("Choice not matched");
  }, le.prototype._createEncoderBuffer = function(oe) {
    return new z(oe, this.reporter);
  }, le.prototype._encode = function(oe, Pe, Ve) {
    var Ke = this._baseState;
    if (!(Ke.default !== null && Ke.default === oe)) {
      var ht = this._encodeValue(oe, Pe, Ve);
      if (ht !== void 0 && !this._skipDefault(ht, Pe, Ve))
        return ht;
    }
  }, le.prototype._encodeValue = function(oe, Pe, Ve) {
    var Ke = this._baseState;
    if (Ke.parent === null)
      return Ke.children[0]._encode(oe, Pe || new B());
    var kt = null;
    if (this.reporter = Pe, Ke.optional && oe === void 0)
      if (Ke.default !== null)
        oe = Ke.default;
      else
        return;
    var ht = null, _t = !1;
    if (Ke.any)
      kt = this._createEncoderBuffer(oe);
    else if (Ke.choice)
      kt = this._encodeChoice(oe, Pe);
    else if (Ke.contains)
      ht = this._getUse(Ke.contains, Ve)._encode(oe, Pe), _t = !0;
    else if (Ke.children)
      ht = Ke.children.map(function(qt) {
        if (qt._baseState.tag === "null_")
          return qt._encode(null, Pe, oe);
        if (qt._baseState.key === null)
          return Pe.error("Child should have a key");
        var jt = Pe.enterKey(qt._baseState.key);
        if (typeof oe != "object")
          return Pe.error("Child expected, but input is not object");
        var Ht = qt._encode(oe[qt._baseState.key], Pe, oe);
        return Pe.leaveKey(jt), Ht;
      }, this).filter(function(qt) {
        return qt;
      }), ht = this._createEncoderBuffer(ht);
    else if (Ke.tag === "seqof" || Ke.tag === "setof") {
      if (!(Ke.args && Ke.args.length === 1))
        return Pe.error("Too many args for : " + Ke.tag);
      if (!Array.isArray(oe))
        return Pe.error("seqof/setof, but data is not Array");
      var Rt = this.clone();
      Rt._baseState.implicit = null, ht = this._createEncoderBuffer(oe.map(function(qt) {
        var jt = this._baseState;
        return this._getUse(jt.args[0], oe)._encode(qt, Pe);
      }, Rt));
    } else Ke.use !== null ? kt = this._getUse(Ke.use, Ve)._encode(oe, Pe) : (ht = this._encodePrimitive(Ke.tag, oe), _t = !0);
    var kt;
    if (!Ke.any && Ke.choice === null) {
      var Bt = Ke.implicit !== null ? Ke.implicit : Ke.tag, Ct = Ke.implicit === null ? "universal" : "context";
      Bt === null ? Ke.use === null && Pe.error("Tag could be omitted only for .use()") : Ke.use === null && (kt = this._encodeComposite(Bt, _t, Ct, ht));
    }
    return Ke.explicit !== null && (kt = this._encodeComposite(Ke.explicit, !1, "context", kt)), kt;
  }, le.prototype._encodeChoice = function(oe, Pe) {
    var Ve = this._baseState, Ke = Ve.choice[oe.type];
    return Ke || ie(
      !1,
      oe.type + " not found in " + JSON.stringify(Object.keys(Ve.choice))
    ), Ke._encode(oe.value, Pe);
  }, le.prototype._encodePrimitive = function(oe, Pe) {
    var Ve = this._baseState;
    if (/str$/.test(oe))
      return this._encodeStr(Pe, oe);
    if (oe === "objid" && Ve.args)
      return this._encodeObjid(Pe, Ve.reverseArgs[0], Ve.args[1]);
    if (oe === "objid")
      return this._encodeObjid(Pe, null, null);
    if (oe === "gentime" || oe === "utctime")
      return this._encodeTime(Pe, oe);
    if (oe === "null_")
      return this._encodeNull();
    if (oe === "int" || oe === "enum")
      return this._encodeInt(Pe, Ve.args && Ve.reverseArgs[0]);
    if (oe === "bool")
      return this._encodeBool(Pe);
    if (oe === "objDesc")
      return this._encodeStr(Pe, oe);
    throw new Error("Unsupported tag: " + oe);
  }, le.prototype._isNumstr = function(oe) {
    return /^[0-9 ]*$/.test(oe);
  }, le.prototype._isPrintstr = function(oe) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(oe);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(B) {
    var z = B;
    z.Reporter = requireReporter().Reporter, z.DecoderBuffer = requireBuffer().DecoderBuffer, z.EncoderBuffer = requireBuffer().EncoderBuffer, z.Node = requireNode();
  }(base$2)), base$2;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(B) {
    var z = requireConstants();
    B.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, B.tagClassByName = z._reverse(B.tagClass), B.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, B.tagByName = z._reverse(B.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(B) {
    var z = B;
    z._reverse = function(ie) {
      var se = {};
      return Object.keys(ie).forEach(function(ne) {
        (ne | 0) == ne && (ne = ne | 0);
        var ae = ie[ne];
        se[ae] = ne;
      }), se;
    }, z.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var B = requireInherits_browser(), z = requireAsn1$1(), Y = z.base, ie = z.bignum, se = z.constants.der;
  function ne(Ee) {
    this.enc = "der", this.name = Ee.name, this.entity = Ee, this.tree = new ae(), this.tree._init(Ee.body);
  }
  der_1$1 = ne, ne.prototype.decode = function(oe, Pe) {
    return oe instanceof Y.DecoderBuffer || (oe = new Y.DecoderBuffer(oe, Pe)), this.tree._decode(oe, Pe);
  };
  function ae(Ee) {
    Y.Node.call(this, "der", Ee);
  }
  B(ae, Y.Node), ae.prototype._peekTag = function(oe, Pe, Ve) {
    if (oe.isEmpty())
      return !1;
    var Ke = oe.save(), ht = le(oe, 'Failed to peek tag: "' + Pe + '"');
    return oe.isError(ht) ? ht : (oe.restore(Ke), ht.tag === Pe || ht.tagStr === Pe || ht.tagStr + "of" === Pe || Ve);
  }, ae.prototype._decodeTag = function(oe, Pe, Ve) {
    var Ke = le(
      oe,
      'Failed to decode tag of "' + Pe + '"'
    );
    if (oe.isError(Ke))
      return Ke;
    var ht = ge(
      oe,
      Ke.primitive,
      'Failed to get length of "' + Pe + '"'
    );
    if (oe.isError(ht))
      return ht;
    if (!Ve && Ke.tag !== Pe && Ke.tagStr !== Pe && Ke.tagStr + "of" !== Pe)
      return oe.error('Failed to match tag: "' + Pe + '"');
    if (Ke.primitive || ht !== null)
      return oe.skip(ht, 'Failed to match body of: "' + Pe + '"');
    var _t = oe.save(), Rt = this._skipUntilEnd(
      oe,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return oe.isError(Rt) ? Rt : (ht = oe.offset - _t.offset, oe.restore(_t), oe.skip(ht, 'Failed to match body of: "' + Pe + '"'));
  }, ae.prototype._skipUntilEnd = function(oe, Pe) {
    for (; ; ) {
      var Ve = le(oe, Pe);
      if (oe.isError(Ve))
        return Ve;
      var Ke = ge(oe, Ve.primitive, Pe);
      if (oe.isError(Ke))
        return Ke;
      var ht;
      if (Ve.primitive || Ke !== null ? ht = oe.skip(Ke) : ht = this._skipUntilEnd(oe, Pe), oe.isError(ht))
        return ht;
      if (Ve.tagStr === "end")
        break;
    }
  }, ae.prototype._decodeList = function(oe, Pe, Ve, Ke) {
    for (var ht = []; !oe.isEmpty(); ) {
      var _t = this._peekTag(oe, "end");
      if (oe.isError(_t))
        return _t;
      var Rt = Ve.decode(oe, "der", Ke);
      if (oe.isError(Rt) && _t)
        break;
      ht.push(Rt);
    }
    return ht;
  }, ae.prototype._decodeStr = function(oe, Pe) {
    if (Pe === "bitstr") {
      var Ve = oe.readUInt8();
      return oe.isError(Ve) ? Ve : { unused: Ve, data: oe.raw() };
    } else if (Pe === "bmpstr") {
      var Ke = oe.raw();
      if (Ke.length % 2 === 1)
        return oe.error("Decoding of string type: bmpstr length mismatch");
      for (var ht = "", _t = 0; _t < Ke.length / 2; _t++)
        ht += String.fromCharCode(Ke.readUInt16BE(_t * 2));
      return ht;
    } else if (Pe === "numstr") {
      var Rt = oe.raw().toString("ascii");
      return this._isNumstr(Rt) ? Rt : oe.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (Pe === "octstr")
        return oe.raw();
      if (Pe === "objDesc")
        return oe.raw();
      if (Pe === "printstr") {
        var kt = oe.raw().toString("ascii");
        return this._isPrintstr(kt) ? kt : oe.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(Pe) ? oe.raw().toString() : oe.error("Decoding of string type: " + Pe + " unsupported");
    }
  }, ae.prototype._decodeObjid = function(oe, Pe, Ve) {
    for (var Ke, ht = [], _t = 0; !oe.isEmpty(); ) {
      var Rt = oe.readUInt8();
      _t <<= 7, _t |= Rt & 127, Rt & 128 || (ht.push(_t), _t = 0);
    }
    Rt & 128 && ht.push(_t);
    var kt = ht[0] / 40 | 0, Bt = ht[0] % 40;
    if (Ve ? Ke = ht : Ke = [kt, Bt].concat(ht.slice(1)), Pe) {
      var Ct = Pe[Ke.join(" ")];
      Ct === void 0 && (Ct = Pe[Ke.join(".")]), Ct !== void 0 && (Ke = Ct);
    }
    return Ke;
  }, ae.prototype._decodeTime = function(oe, Pe) {
    var Ve = oe.raw().toString();
    if (Pe === "gentime")
      var Ke = Ve.slice(0, 4) | 0, ht = Ve.slice(4, 6) | 0, _t = Ve.slice(6, 8) | 0, Rt = Ve.slice(8, 10) | 0, kt = Ve.slice(10, 12) | 0, Bt = Ve.slice(12, 14) | 0;
    else if (Pe === "utctime") {
      var Ke = Ve.slice(0, 2) | 0, ht = Ve.slice(2, 4) | 0, _t = Ve.slice(4, 6) | 0, Rt = Ve.slice(6, 8) | 0, kt = Ve.slice(8, 10) | 0, Bt = Ve.slice(10, 12) | 0;
      Ke < 70 ? Ke = 2e3 + Ke : Ke = 1900 + Ke;
    } else
      return oe.error("Decoding " + Pe + " time is not supported yet");
    return Date.UTC(Ke, ht - 1, _t, Rt, kt, Bt, 0);
  }, ae.prototype._decodeNull = function(oe) {
    return null;
  }, ae.prototype._decodeBool = function(oe) {
    var Pe = oe.readUInt8();
    return oe.isError(Pe) ? Pe : Pe !== 0;
  }, ae.prototype._decodeInt = function(oe, Pe) {
    var Ve = oe.raw(), Ke = new ie(Ve);
    return Pe && (Ke = Pe[Ke.toString(10)] || Ke), Ke;
  }, ae.prototype._use = function(oe, Pe) {
    return typeof oe == "function" && (oe = oe(Pe)), oe._getDecoder("der").tree;
  };
  function le(Ee, oe) {
    var Pe = Ee.readUInt8(oe);
    if (Ee.isError(Pe))
      return Pe;
    var Ve = se.tagClass[Pe >> 6], Ke = (Pe & 32) === 0;
    if ((Pe & 31) === 31) {
      var ht = Pe;
      for (Pe = 0; (ht & 128) === 128; ) {
        if (ht = Ee.readUInt8(oe), Ee.isError(ht))
          return ht;
        Pe <<= 7, Pe |= ht & 127;
      }
    } else
      Pe &= 31;
    var _t = se.tag[Pe];
    return {
      cls: Ve,
      primitive: Ke,
      tag: Pe,
      tagStr: _t
    };
  }
  function ge(Ee, oe, Pe) {
    var Ve = Ee.readUInt8(Pe);
    if (Ee.isError(Ve))
      return Ve;
    if (!oe && Ve === 128)
      return null;
    if (!(Ve & 128))
      return Ve;
    var Ke = Ve & 127;
    if (Ke > 4)
      return Ee.error("length octect is too long");
    Ve = 0;
    for (var ht = 0; ht < Ke; ht++) {
      Ve <<= 8;
      var _t = Ee.readUInt8(Pe);
      if (Ee.isError(_t))
        return _t;
      Ve |= _t;
    }
    return Ve;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var B = requireInherits_browser(), z = require$$0$1.Buffer, Y = requireDer$1();
  function ie(se) {
    Y.call(this, se), this.enc = "pem";
  }
  return B(ie, Y), pem$1 = ie, ie.prototype.decode = function(ne, ae) {
    for (var le = ne.toString().split(/[\r\n]+/g), ge = ae.label.toUpperCase(), Ee = /^-----(BEGIN|END) ([^-]+)-----$/, oe = -1, Pe = -1, Ve = 0; Ve < le.length; Ve++) {
      var Ke = le[Ve].match(Ee);
      if (Ke !== null && Ke[2] === ge)
        if (oe === -1) {
          if (Ke[1] !== "BEGIN")
            break;
          oe = Ve;
        } else {
          if (Ke[1] !== "END")
            break;
          Pe = Ve;
          break;
        }
    }
    if (oe === -1 || Pe === -1)
      throw new Error("PEM section not found for: " + ge);
    var ht = le.slice(oe + 1, Pe).join("");
    ht.replace(/[^a-z0-9\+\/=]+/gi, "");
    var _t = new z(ht, "base64");
    return Y.prototype.decode.call(this, _t, ae);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(B) {
    var z = B;
    z.der = requireDer$1(), z.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var B = requireInherits_browser(), z = require$$0$1.Buffer, Y = requireAsn1$1(), ie = Y.base, se = Y.constants.der;
  function ne(Ee) {
    this.enc = "der", this.name = Ee.name, this.entity = Ee, this.tree = new ae(), this.tree._init(Ee.body);
  }
  der_1 = ne, ne.prototype.encode = function(oe, Pe) {
    return this.tree._encode(oe, Pe).join();
  };
  function ae(Ee) {
    ie.Node.call(this, "der", Ee);
  }
  B(ae, ie.Node), ae.prototype._encodeComposite = function(oe, Pe, Ve, Ke) {
    var ht = ge(oe, Pe, Ve, this.reporter);
    if (Ke.length < 128) {
      var kt = new z(2);
      return kt[0] = ht, kt[1] = Ke.length, this._createEncoderBuffer([kt, Ke]);
    }
    for (var _t = 1, Rt = Ke.length; Rt >= 256; Rt >>= 8)
      _t++;
    var kt = new z(2 + _t);
    kt[0] = ht, kt[1] = 128 | _t;
    for (var Rt = 1 + _t, Bt = Ke.length; Bt > 0; Rt--, Bt >>= 8)
      kt[Rt] = Bt & 255;
    return this._createEncoderBuffer([kt, Ke]);
  }, ae.prototype._encodeStr = function(oe, Pe) {
    if (Pe === "bitstr")
      return this._createEncoderBuffer([oe.unused | 0, oe.data]);
    if (Pe === "bmpstr") {
      for (var Ve = new z(oe.length * 2), Ke = 0; Ke < oe.length; Ke++)
        Ve.writeUInt16BE(oe.charCodeAt(Ke), Ke * 2);
      return this._createEncoderBuffer(Ve);
    } else return Pe === "numstr" ? this._isNumstr(oe) ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : Pe === "printstr" ? this._isPrintstr(oe) ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(Pe) ? this._createEncoderBuffer(oe) : Pe === "objDesc" ? this._createEncoderBuffer(oe) : this.reporter.error("Encoding of string type: " + Pe + " unsupported");
  }, ae.prototype._encodeObjid = function(oe, Pe, Ve) {
    if (typeof oe == "string") {
      if (!Pe)
        return this.reporter.error("string objid given, but no values map found");
      if (!Pe.hasOwnProperty(oe))
        return this.reporter.error("objid not found in values map");
      oe = Pe[oe].split(/[\s\.]+/g);
      for (var Ke = 0; Ke < oe.length; Ke++)
        oe[Ke] |= 0;
    } else if (Array.isArray(oe)) {
      oe = oe.slice();
      for (var Ke = 0; Ke < oe.length; Ke++)
        oe[Ke] |= 0;
    }
    if (!Array.isArray(oe))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(oe));
    if (!Ve) {
      if (oe[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      oe.splice(0, 2, oe[0] * 40 + oe[1]);
    }
    for (var ht = 0, Ke = 0; Ke < oe.length; Ke++) {
      var _t = oe[Ke];
      for (ht++; _t >= 128; _t >>= 7)
        ht++;
    }
    for (var Rt = new z(ht), kt = Rt.length - 1, Ke = oe.length - 1; Ke >= 0; Ke--) {
      var _t = oe[Ke];
      for (Rt[kt--] = _t & 127; (_t >>= 7) > 0; )
        Rt[kt--] = 128 | _t & 127;
    }
    return this._createEncoderBuffer(Rt);
  };
  function le(Ee) {
    return Ee < 10 ? "0" + Ee : Ee;
  }
  ae.prototype._encodeTime = function(oe, Pe) {
    var Ve, Ke = new Date(oe);
    return Pe === "gentime" ? Ve = [
      le(Ke.getFullYear()),
      le(Ke.getUTCMonth() + 1),
      le(Ke.getUTCDate()),
      le(Ke.getUTCHours()),
      le(Ke.getUTCMinutes()),
      le(Ke.getUTCSeconds()),
      "Z"
    ].join("") : Pe === "utctime" ? Ve = [
      le(Ke.getFullYear() % 100),
      le(Ke.getUTCMonth() + 1),
      le(Ke.getUTCDate()),
      le(Ke.getUTCHours()),
      le(Ke.getUTCMinutes()),
      le(Ke.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + Pe + " time is not supported yet"), this._encodeStr(Ve, "octstr");
  }, ae.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, ae.prototype._encodeInt = function(oe, Pe) {
    if (typeof oe == "string") {
      if (!Pe)
        return this.reporter.error("String int or enum given, but no values map");
      if (!Pe.hasOwnProperty(oe))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(oe));
      oe = Pe[oe];
    }
    if (typeof oe != "number" && !z.isBuffer(oe)) {
      var Ve = oe.toArray();
      !oe.sign && Ve[0] & 128 && Ve.unshift(0), oe = new z(Ve);
    }
    if (z.isBuffer(oe)) {
      var Ke = oe.length;
      oe.length === 0 && Ke++;
      var _t = new z(Ke);
      return oe.copy(_t), oe.length === 0 && (_t[0] = 0), this._createEncoderBuffer(_t);
    }
    if (oe < 128)
      return this._createEncoderBuffer(oe);
    if (oe < 256)
      return this._createEncoderBuffer([0, oe]);
    for (var Ke = 1, ht = oe; ht >= 256; ht >>= 8)
      Ke++;
    for (var _t = new Array(Ke), ht = _t.length - 1; ht >= 0; ht--)
      _t[ht] = oe & 255, oe >>= 8;
    return _t[0] & 128 && _t.unshift(0), this._createEncoderBuffer(new z(_t));
  }, ae.prototype._encodeBool = function(oe) {
    return this._createEncoderBuffer(oe ? 255 : 0);
  }, ae.prototype._use = function(oe, Pe) {
    return typeof oe == "function" && (oe = oe(Pe)), oe._getEncoder("der").tree;
  }, ae.prototype._skipDefault = function(oe, Pe, Ve) {
    var Ke = this._baseState, ht;
    if (Ke.default === null)
      return !1;
    var _t = oe.join();
    if (Ke.defaultBuffer === void 0 && (Ke.defaultBuffer = this._encodeValue(Ke.default, Pe, Ve).join()), _t.length !== Ke.defaultBuffer.length)
      return !1;
    for (ht = 0; ht < _t.length; ht++)
      if (_t[ht] !== Ke.defaultBuffer[ht])
        return !1;
    return !0;
  };
  function ge(Ee, oe, Pe, Ve) {
    var Ke;
    if (Ee === "seqof" ? Ee = "seq" : Ee === "setof" && (Ee = "set"), se.tagByName.hasOwnProperty(Ee))
      Ke = se.tagByName[Ee];
    else if (typeof Ee == "number" && (Ee | 0) === Ee)
      Ke = Ee;
    else
      return Ve.error("Unknown tag: " + Ee);
    return Ke >= 31 ? Ve.error("Multi-octet tag encoding unsupported") : (oe || (Ke |= 32), Ke |= se.tagClassByName[Pe || "universal"] << 6, Ke);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var B = requireInherits_browser(), z = requireDer();
  function Y(ie) {
    z.call(this, ie), this.enc = "pem";
  }
  return B(Y, z), pem = Y, Y.prototype.encode = function(se, ne) {
    for (var ae = z.prototype.encode.call(this, se), le = ae.toString("base64"), ge = ["-----BEGIN " + ne.label + "-----"], Ee = 0; Ee < le.length; Ee += 64)
      ge.push(le.slice(Ee, Ee + 64));
    return ge.push("-----END " + ne.label + "-----"), ge.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(B) {
    var z = B;
    z.der = requireDer(), z.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(B) {
    var z = B;
    z.bignum = requireBn$2(), z.define = requireApi().define, z.base = requireBase(), z.constants = requireConstants(), z.decoders = requireDecoders(), z.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate) return certificate;
  hasRequiredCertificate = 1;
  var B = requireAsn1$1(), z = B.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), Y = B.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), ie = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), se = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(ie),
      this.key("subjectPublicKey").bitstr()
    );
  }), ne = B.define("RelativeDistinguishedName", function() {
    this.setof(Y);
  }), ae = B.define("RDNSequence", function() {
    this.seqof(ne);
  }), le = B.define("Name", function() {
    this.choice({
      rdnSequence: this.use(ae)
    });
  }), ge = B.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(z),
      this.key("notAfter").use(z)
    );
  }), Ee = B.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), oe = B.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(ie),
      this.key("issuer").use(le),
      this.key("validity").use(ge),
      this.key("subject").use(le),
      this.key("subjectPublicKeyInfo").use(se),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(Ee).optional()
    );
  }), Pe = B.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(oe),
      this.key("signatureAlgorithm").use(ie),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = Pe, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1) return asn1$1;
  hasRequiredAsn1 = 1;
  var B = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var z = B.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = z;
  var Y = B.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = Y;
  var ie = B.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), se = B.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(ie),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = se;
  var ne = B.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(ie),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = ne;
  var ae = B.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = ae;
  var le = B.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = le, asn1$1.DSAparam = B.define("DSAparam", function() {
    this.int();
  });
  var ge = B.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), Ee = B.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(ge),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = Ee, asn1$1.signature = B.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc) return fixProc;
  hasRequiredFixProc = 1;
  var B = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, z = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, Y = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, ie = requireEvp_bytestokey(), se = requireBrowser$6(), ne = safeBufferExports.Buffer;
  return fixProc = function(ae, le) {
    var ge = ae.toString(), Ee = ge.match(B), oe;
    if (Ee) {
      var Ve = "aes" + Ee[1], Ke = ne.from(Ee[2], "hex"), ht = ne.from(Ee[3].replace(/[\r\n]/g, ""), "base64"), _t = ie(le, Ke.slice(0, 8), parseInt(Ee[1], 10)).key, Rt = [], kt = se.createDecipheriv(Ve, _t, Ke);
      Rt.push(kt.update(ht)), Rt.push(kt.final()), oe = ne.concat(Rt);
    } else {
      var Pe = ge.match(Y);
      oe = ne.from(Pe[2].replace(/[\r\n]/g, ""), "base64");
    }
    var Bt = ge.match(z)[1];
    return {
      tag: Bt,
      data: oe
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1) return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var B = requireAsn1(), z = require$$1, Y = requireFixProc(), ie = requireBrowser$6(), se = requireBrowser$7(), ne = safeBufferExports.Buffer;
  function ae(ge, Ee) {
    var oe = ge.algorithm.decrypt.kde.kdeparams.salt, Pe = parseInt(ge.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), Ve = z[ge.algorithm.decrypt.cipher.algo.join(".")], Ke = ge.algorithm.decrypt.cipher.iv, ht = ge.subjectPrivateKey, _t = parseInt(Ve.split("-")[1], 10) / 8, Rt = se.pbkdf2Sync(Ee, oe, Pe, _t, "sha1"), kt = ie.createDecipheriv(Ve, Rt, Ke), Bt = [];
    return Bt.push(kt.update(ht)), Bt.push(kt.final()), ne.concat(Bt);
  }
  function le(ge) {
    var Ee;
    typeof ge == "object" && !ne.isBuffer(ge) && (Ee = ge.passphrase, ge = ge.key), typeof ge == "string" && (ge = ne.from(ge));
    var oe = Y(ge, Ee), Pe = oe.tag, Ve = oe.data, Ke, ht;
    switch (Pe) {
      case "CERTIFICATE":
        ht = B.certificate.decode(Ve, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (ht || (ht = B.PublicKey.decode(Ve, "der")), Ke = ht.algorithm.algorithm.join("."), Ke) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPublicKey.decode(ht.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return ht.subjectPrivateKey = ht.subjectPublicKey, {
              type: "ec",
              data: ht
            };
          case "1.2.840.10040.4.1":
            return ht.algorithm.params.pub_key = B.DSAparam.decode(ht.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: ht.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ke);
        }
      case "ENCRYPTED PRIVATE KEY":
        Ve = B.EncryptedPrivateKey.decode(Ve, "der"), Ve = ae(Ve, Ee);
      case "PRIVATE KEY":
        switch (ht = B.PrivateKey.decode(Ve, "der"), Ke = ht.algorithm.algorithm.join("."), Ke) {
          case "1.2.840.113549.1.1.1":
            return B.RSAPrivateKey.decode(ht.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: ht.algorithm.curve,
              privateKey: B.ECPrivateKey.decode(ht.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return ht.algorithm.params.priv_key = B.DSAparam.decode(ht.subjectPrivateKey, "der"), {
              type: "dsa",
              params: ht.algorithm.params
            };
          default:
            throw new Error("unknown key id " + Ke);
        }
      case "RSA PUBLIC KEY":
        return B.RSAPublicKey.decode(Ve, "der");
      case "RSA PRIVATE KEY":
        return B.RSAPrivateKey.decode(Ve, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: B.DSAPrivateKey.decode(Ve, "der")
        };
      case "EC PRIVATE KEY":
        return Ve = B.ECPrivateKey.decode(Ve, "der"), {
          curve: Ve.parameters.value,
          privateKey: Ve.privateKey
        };
      default:
        throw new Error("unknown key type " + Pe);
    }
  }
  return le.signature = B.signature, parseAsn1 = le, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var B = safeBufferExports.Buffer, z = requireBrowser$8(), Y = requireBrowserifyRsa(), ie = requireElliptic().ec, se = requireBn(), ne = requireParseAsn1(), ae = require$$4, le = 1;
  function ge(kt, Bt, Ct, qt, jt) {
    var Ht = ne(Bt);
    if (Ht.curve) {
      if (qt !== "ecdsa" && qt !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return Ee(kt, Ht);
    } else if (Ht.type === "dsa") {
      if (qt !== "dsa")
        throw new Error("wrong private key type");
      return oe(kt, Ht, Ct);
    }
    if (qt !== "rsa" && qt !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (Bt.padding !== void 0 && Bt.padding !== le)
      throw new Error("illegal or unsupported padding mode");
    kt = B.concat([jt, kt]);
    for (var Yt = Ht.modulus.byteLength(), Ut = [0, 1]; kt.length + Ut.length + 1 < Yt; )
      Ut.push(255);
    Ut.push(0);
    for (var Nt = -1; ++Nt < kt.length; )
      Ut.push(kt[Nt]);
    var Kt = Y(Ut, Ht);
    return Kt;
  }
  function Ee(kt, Bt) {
    var Ct = ae[Bt.curve.join(".")];
    if (!Ct)
      throw new Error("unknown curve " + Bt.curve.join("."));
    var qt = new ie(Ct), jt = qt.keyFromPrivate(Bt.privateKey), Ht = jt.sign(kt);
    return B.from(Ht.toDER());
  }
  function oe(kt, Bt, Ct) {
    for (var qt = Bt.params.priv_key, jt = Bt.params.p, Ht = Bt.params.q, Yt = Bt.params.g, Ut = new se(0), Nt, Kt = Ke(kt, Ht).mod(Ht), Ft = !1, bt = Ve(qt, Ht, kt, Ct); Ft === !1; )
      Nt = _t(Ht, bt, Ct), Ut = Rt(Yt, Nt, jt, Ht), Ft = Nt.invm(Ht).imul(Kt.add(qt.mul(Ut))).mod(Ht), Ft.cmpn(0) === 0 && (Ft = !1, Ut = new se(0));
    return Pe(Ut, Ft);
  }
  function Pe(kt, Bt) {
    kt = kt.toArray(), Bt = Bt.toArray(), kt[0] & 128 && (kt = [0].concat(kt)), Bt[0] & 128 && (Bt = [0].concat(Bt));
    var Ct = kt.length + Bt.length + 4, qt = [
      48,
      Ct,
      2,
      kt.length
    ];
    return qt = qt.concat(kt, [2, Bt.length], Bt), B.from(qt);
  }
  function Ve(kt, Bt, Ct, qt) {
    if (kt = B.from(kt.toArray()), kt.length < Bt.byteLength()) {
      var jt = B.alloc(Bt.byteLength() - kt.length);
      kt = B.concat([jt, kt]);
    }
    var Ht = Ct.length, Yt = ht(Ct, Bt), Ut = B.alloc(Ht);
    Ut.fill(1);
    var Nt = B.alloc(Ht);
    return Nt = z(qt, Nt).update(Ut).update(B.from([0])).update(kt).update(Yt).digest(), Ut = z(qt, Nt).update(Ut).digest(), Nt = z(qt, Nt).update(Ut).update(B.from([1])).update(kt).update(Yt).digest(), Ut = z(qt, Nt).update(Ut).digest(), { k: Nt, v: Ut };
  }
  function Ke(kt, Bt) {
    var Ct = new se(kt), qt = (kt.length << 3) - Bt.bitLength();
    return qt > 0 && Ct.ishrn(qt), Ct;
  }
  function ht(kt, Bt) {
    kt = Ke(kt, Bt), kt = kt.mod(Bt);
    var Ct = B.from(kt.toArray());
    if (Ct.length < Bt.byteLength()) {
      var qt = B.alloc(Bt.byteLength() - Ct.length);
      Ct = B.concat([qt, Ct]);
    }
    return Ct;
  }
  function _t(kt, Bt, Ct) {
    var qt, jt;
    do {
      for (qt = B.alloc(0); qt.length * 8 < kt.bitLength(); )
        Bt.v = z(Ct, Bt.k).update(Bt.v).digest(), qt = B.concat([qt, Bt.v]);
      jt = Ke(qt, kt), Bt.k = z(Ct, Bt.k).update(Bt.v).update(B.from([0])).digest(), Bt.v = z(Ct, Bt.k).update(Bt.v).digest();
    } while (jt.cmp(kt) !== -1);
    return jt;
  }
  function Rt(kt, Bt, Ct, qt) {
    return kt.toRed(se.mont(Ct)).redPow(Bt).fromRed().mod(qt);
  }
  return sign.exports = ge, sign.exports.getKey = Ve, sign.exports.makeKey = _t, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var B = safeBufferExports.Buffer, z = requireBn(), Y = requireElliptic().ec, ie = requireParseAsn1(), se = require$$4;
  function ne(Ee, oe, Pe, Ve, Ke) {
    var ht = ie(Pe);
    if (ht.type === "ec") {
      if (Ve !== "ecdsa" && Ve !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return ae(Ee, oe, ht);
    } else if (ht.type === "dsa") {
      if (Ve !== "dsa")
        throw new Error("wrong public key type");
      return le(Ee, oe, ht);
    }
    if (Ve !== "rsa" && Ve !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    oe = B.concat([Ke, oe]);
    for (var _t = ht.modulus.byteLength(), Rt = [1], kt = 0; oe.length + Rt.length + 2 < _t; )
      Rt.push(255), kt += 1;
    Rt.push(0);
    for (var Bt = -1; ++Bt < oe.length; )
      Rt.push(oe[Bt]);
    Rt = B.from(Rt);
    var Ct = z.mont(ht.modulus);
    Ee = new z(Ee).toRed(Ct), Ee = Ee.redPow(new z(ht.publicExponent)), Ee = B.from(Ee.fromRed().toArray());
    var qt = kt < 8 ? 1 : 0;
    for (_t = Math.min(Ee.length, Rt.length), Ee.length !== Rt.length && (qt = 1), Bt = -1; ++Bt < _t; )
      qt |= Ee[Bt] ^ Rt[Bt];
    return qt === 0;
  }
  function ae(Ee, oe, Pe) {
    var Ve = se[Pe.data.algorithm.curve.join(".")];
    if (!Ve)
      throw new Error("unknown curve " + Pe.data.algorithm.curve.join("."));
    var Ke = new Y(Ve), ht = Pe.data.subjectPrivateKey.data;
    return Ke.verify(oe, Ee, ht);
  }
  function le(Ee, oe, Pe) {
    var Ve = Pe.data.p, Ke = Pe.data.q, ht = Pe.data.g, _t = Pe.data.pub_key, Rt = ie.signature.decode(Ee, "der"), kt = Rt.s, Bt = Rt.r;
    ge(kt, Ke), ge(Bt, Ke);
    var Ct = z.mont(Ve), qt = kt.invm(Ke), jt = ht.toRed(Ct).redPow(new z(oe).mul(qt).mod(Ke)).fromRed().mul(_t.toRed(Ct).redPow(Bt.mul(qt).mod(Ke)).fromRed()).mod(Ve).mod(Ke);
    return jt.cmp(Bt) === 0;
  }
  function ge(Ee, oe) {
    if (Ee.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (Ee.cmp(oe) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = ne, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3;
  hasRequiredBrowser$3 = 1;
  var B = safeBufferExports.Buffer, z = requireBrowser$9(), Y = requireReadableBrowser(), ie = requireInherits_browser(), se = requireSign(), ne = requireVerify(), ae = require$$6;
  Object.keys(ae).forEach(function(Pe) {
    ae[Pe].id = B.from(ae[Pe].id, "hex"), ae[Pe.toLowerCase()] = ae[Pe];
  });
  function le(Pe) {
    Y.Writable.call(this);
    var Ve = ae[Pe];
    if (!Ve)
      throw new Error("Unknown message digest");
    this._hashType = Ve.hash, this._hash = z(Ve.hash), this._tag = Ve.id, this._signType = Ve.sign;
  }
  ie(le, Y.Writable), le.prototype._write = function(Ve, Ke, ht) {
    this._hash.update(Ve), ht();
  }, le.prototype.update = function(Ve, Ke) {
    return this._hash.update(typeof Ve == "string" ? B.from(Ve, Ke) : Ve), this;
  }, le.prototype.sign = function(Ve, Ke) {
    this.end();
    var ht = this._hash.digest(), _t = se(ht, Ve, this._hashType, this._signType, this._tag);
    return Ke ? _t.toString(Ke) : _t;
  };
  function ge(Pe) {
    Y.Writable.call(this);
    var Ve = ae[Pe];
    if (!Ve)
      throw new Error("Unknown message digest");
    this._hash = z(Ve.hash), this._tag = Ve.id, this._signType = Ve.sign;
  }
  ie(ge, Y.Writable), ge.prototype._write = function(Ve, Ke, ht) {
    this._hash.update(Ve), ht();
  }, ge.prototype.update = function(Ve, Ke) {
    return this._hash.update(typeof Ve == "string" ? B.from(Ve, Ke) : Ve), this;
  }, ge.prototype.verify = function(Ve, Ke, ht) {
    var _t = typeof Ke == "string" ? B.from(Ke, ht) : Ke;
    this.end();
    var Rt = this._hash.digest();
    return ne(_t, Rt, Ve, this._signType, this._tag);
  };
  function Ee(Pe) {
    return new le(Pe);
  }
  function oe(Pe) {
    return new ge(Pe);
  }
  return browser$3 = {
    Sign: Ee,
    Verify: oe,
    createSign: Ee,
    createVerify: oe
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2;
  hasRequiredBrowser$2 = 1;
  var B = requireElliptic(), z = requireBn$2();
  browser$2 = function(ae) {
    return new ie(ae);
  };
  var Y = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  Y.p224 = Y.secp224r1, Y.p256 = Y.secp256r1 = Y.prime256v1, Y.p192 = Y.secp192r1 = Y.prime192v1, Y.p384 = Y.secp384r1, Y.p521 = Y.secp521r1;
  function ie(ne) {
    this.curveType = Y[ne], this.curveType || (this.curveType = {
      name: ne
    }), this.curve = new B.ec(this.curveType.name), this.keys = void 0;
  }
  ie.prototype.generateKeys = function(ne, ae) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(ne, ae);
  }, ie.prototype.computeSecret = function(ne, ae, le) {
    ae = ae || "utf8", Buffer$1.isBuffer(ne) || (ne = new Buffer$1(ne, ae));
    var ge = this.curve.keyFromPublic(ne).getPublic(), Ee = ge.mul(this.keys.getPrivate()).getX();
    return se(Ee, le, this.curveType.byteLength);
  }, ie.prototype.getPublicKey = function(ne, ae) {
    var le = this.keys.getPublic(ae === "compressed", !0);
    return ae === "hybrid" && (le[le.length - 1] % 2 ? le[0] = 7 : le[0] = 6), se(le, ne);
  }, ie.prototype.getPrivateKey = function(ne) {
    return se(this.keys.getPrivate(), ne);
  }, ie.prototype.setPublicKey = function(ne, ae) {
    return ae = ae || "utf8", Buffer$1.isBuffer(ne) || (ne = new Buffer$1(ne, ae)), this.keys._importPublic(ne), this;
  }, ie.prototype.setPrivateKey = function(ne, ae) {
    ae = ae || "utf8", Buffer$1.isBuffer(ne) || (ne = new Buffer$1(ne, ae));
    var le = new z(ne);
    return le = le.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(le), this;
  };
  function se(ne, ae, le) {
    Array.isArray(ne) || (ne = ne.toArray());
    var ge = new Buffer$1(ne);
    if (le && ge.length < le) {
      var Ee = new Buffer$1(le - ge.length);
      Ee.fill(0), ge = Buffer$1.concat([Ee, ge]);
    }
    return ae ? ge.toString(ae) : ge;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf) return mgf;
  hasRequiredMgf = 1;
  var B = requireBrowser$9(), z = safeBufferExports.Buffer;
  mgf = function(ie, se) {
    for (var ne = z.alloc(0), ae = 0, le; ne.length < se; )
      le = Y(ae++), ne = z.concat([ne, B("sha1").update(ie).update(le).digest()]);
    return ne.slice(0, se);
  };
  function Y(ie) {
    var se = z.allocUnsafe(4);
    return se.writeUInt32BE(ie, 0), se;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(z, Y) {
    for (var ie = z.length, se = -1; ++se < ie; )
      z[se] ^= Y[se];
    return z;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic) return withPublic_1;
  hasRequiredWithPublic = 1;
  var B = requireBn$2(), z = safeBufferExports.Buffer;
  function Y(ie, se) {
    return z.from(ie.toRed(B.mont(se.modulus)).redPow(new B(se.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = Y, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt) return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var B = requireParseAsn1(), z = requireBrowser$b(), Y = requireBrowser$9(), ie = requireMgf(), se = requireXor(), ne = requireBn$2(), ae = requireWithPublic(), le = requireBrowserifyRsa(), ge = safeBufferExports.Buffer;
  publicEncrypt = function(Ke, ht, _t) {
    var Rt;
    Ke.padding ? Rt = Ke.padding : _t ? Rt = 1 : Rt = 4;
    var kt = B(Ke), Bt;
    if (Rt === 4)
      Bt = Ee(kt, ht);
    else if (Rt === 1)
      Bt = oe(kt, ht, _t);
    else if (Rt === 3) {
      if (Bt = new ne(ht), Bt.cmp(kt.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return _t ? le(Bt, kt) : ae(Bt, kt);
  };
  function Ee(Ve, Ke) {
    var ht = Ve.modulus.byteLength(), _t = Ke.length, Rt = Y("sha1").update(ge.alloc(0)).digest(), kt = Rt.length, Bt = 2 * kt;
    if (_t > ht - Bt - 2)
      throw new Error("message too long");
    var Ct = ge.alloc(ht - _t - Bt - 2), qt = ht - kt - 1, jt = z(kt), Ht = se(ge.concat([Rt, Ct, ge.alloc(1, 1), Ke], qt), ie(jt, qt)), Yt = se(jt, ie(Ht, kt));
    return new ne(ge.concat([ge.alloc(1), Yt, Ht], ht));
  }
  function oe(Ve, Ke, ht) {
    var _t = Ke.length, Rt = Ve.modulus.byteLength();
    if (_t > Rt - 11)
      throw new Error("message too long");
    var kt;
    return ht ? kt = ge.alloc(Rt - _t - 3, 255) : kt = Pe(Rt - _t - 3), new ne(ge.concat([ge.from([0, ht ? 1 : 2]), kt, ge.alloc(1), Ke], Rt));
  }
  function Pe(Ve) {
    for (var Ke = ge.allocUnsafe(Ve), ht = 0, _t = z(Ve * 2), Rt = 0, kt; ht < Ve; )
      Rt === _t.length && (_t = z(Ve * 2), Rt = 0), kt = _t[Rt++], kt && (Ke[ht++] = kt);
    return Ke;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt) return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var B = requireParseAsn1(), z = requireMgf(), Y = requireXor(), ie = requireBn$2(), se = requireBrowserifyRsa(), ne = requireBrowser$9(), ae = requireWithPublic(), le = safeBufferExports.Buffer;
  privateDecrypt = function(Ve, Ke, ht) {
    var _t;
    Ve.padding ? _t = Ve.padding : ht ? _t = 1 : _t = 4;
    var Rt = B(Ve), kt = Rt.modulus.byteLength();
    if (Ke.length > kt || new ie(Ke).cmp(Rt.modulus) >= 0)
      throw new Error("decryption error");
    var Bt;
    ht ? Bt = ae(new ie(Ke), Rt) : Bt = se(Ke, Rt);
    var Ct = le.alloc(kt - Bt.length);
    if (Bt = le.concat([Ct, Bt], kt), _t === 4)
      return ge(Rt, Bt);
    if (_t === 1)
      return Ee(Rt, Bt, ht);
    if (_t === 3)
      return Bt;
    throw new Error("unknown padding");
  };
  function ge(Pe, Ve) {
    var Ke = Pe.modulus.byteLength(), ht = ne("sha1").update(le.alloc(0)).digest(), _t = ht.length;
    if (Ve[0] !== 0)
      throw new Error("decryption error");
    var Rt = Ve.slice(1, _t + 1), kt = Ve.slice(_t + 1), Bt = Y(Rt, z(kt, _t)), Ct = Y(kt, z(Bt, Ke - _t - 1));
    if (oe(ht, Ct.slice(0, _t)))
      throw new Error("decryption error");
    for (var qt = _t; Ct[qt] === 0; )
      qt++;
    if (Ct[qt++] !== 1)
      throw new Error("decryption error");
    return Ct.slice(qt);
  }
  function Ee(Pe, Ve, Ke) {
    for (var ht = Ve.slice(0, 2), _t = 2, Rt = 0; Ve[_t++] !== 0; )
      if (_t >= Ve.length) {
        Rt++;
        break;
      }
    var kt = Ve.slice(2, _t - 1);
    if ((ht.toString("hex") !== "0002" && !Ke || ht.toString("hex") !== "0001" && Ke) && Rt++, kt.length < 8 && Rt++, Rt)
      throw new Error("decryption error");
    return Ve.slice(_t);
  }
  function oe(Pe, Ve) {
    Pe = le.from(Pe), Ve = le.from(Ve);
    var Ke = 0, ht = Pe.length;
    Pe.length !== Ve.length && (Ke++, ht = Math.min(Pe.length, Ve.length));
    for (var _t = -1; ++_t < ht; )
      Ke += Pe[_t] ^ Ve[_t];
    return Ke;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(B) {
    B.publicEncrypt = requirePublicEncrypt(), B.privateDecrypt = requirePrivateDecrypt(), B.privateEncrypt = function(Y, ie) {
      return B.publicEncrypt(Y, ie, !0);
    }, B.publicDecrypt = function(Y, ie) {
      return B.privateDecrypt(Y, ie, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  function B() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var z = safeBufferExports, Y = requireBrowser$b(), ie = z.Buffer, se = z.kMaxLength, ne = commonjsGlobal.crypto || commonjsGlobal.msCrypto, ae = Math.pow(2, 32) - 1;
  function le(Ve, Ke) {
    if (typeof Ve != "number" || Ve !== Ve)
      throw new TypeError("offset must be a number");
    if (Ve > ae || Ve < 0)
      throw new TypeError("offset must be a uint32");
    if (Ve > se || Ve > Ke)
      throw new RangeError("offset out of range");
  }
  function ge(Ve, Ke, ht) {
    if (typeof Ve != "number" || Ve !== Ve)
      throw new TypeError("size must be a number");
    if (Ve > ae || Ve < 0)
      throw new TypeError("size must be a uint32");
    if (Ve + Ke > ht || Ve > se)
      throw new RangeError("buffer too small");
  }
  ne && ne.getRandomValues || !process$1.browser ? (browser.randomFill = Ee, browser.randomFillSync = Pe) : (browser.randomFill = B, browser.randomFillSync = B);
  function Ee(Ve, Ke, ht, _t) {
    if (!ie.isBuffer(Ve) && !(Ve instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof Ke == "function")
      _t = Ke, Ke = 0, ht = Ve.length;
    else if (typeof ht == "function")
      _t = ht, ht = Ve.length - Ke;
    else if (typeof _t != "function")
      throw new TypeError('"cb" argument must be a function');
    return le(Ke, Ve.length), ge(ht, Ke, Ve.length), oe(Ve, Ke, ht, _t);
  }
  function oe(Ve, Ke, ht, _t) {
    if (process$1.browser) {
      var Rt = Ve.buffer, kt = new Uint8Array(Rt, Ke, ht);
      if (ne.getRandomValues(kt), _t) {
        process$1.nextTick(function() {
          _t(null, Ve);
        });
        return;
      }
      return Ve;
    }
    if (_t) {
      Y(ht, function(Ct, qt) {
        if (Ct)
          return _t(Ct);
        qt.copy(Ve, Ke), _t(null, Ve);
      });
      return;
    }
    var Bt = Y(ht);
    return Bt.copy(Ve, Ke), Ve;
  }
  function Pe(Ve, Ke, ht) {
    if (typeof Ke > "u" && (Ke = 0), !ie.isBuffer(Ve) && !(Ve instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return le(Ke, Ve.length), ht === void 0 && (ht = Ve.length - Ke), ge(ht, Ke, Ve.length), oe(Ve, Ke, ht);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var B = requireAlgos(), z = Object.keys(B), Y = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(z);
  cryptoBrowserify.getHashes = function() {
    return Y;
  };
  var ie = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = ie.pbkdf2, cryptoBrowserify.pbkdf2Sync = ie.pbkdf2Sync;
  var se = requireBrowser$5();
  cryptoBrowserify.Cipher = se.Cipher, cryptoBrowserify.createCipher = se.createCipher, cryptoBrowserify.Cipheriv = se.Cipheriv, cryptoBrowserify.createCipheriv = se.createCipheriv, cryptoBrowserify.Decipher = se.Decipher, cryptoBrowserify.createDecipher = se.createDecipher, cryptoBrowserify.Decipheriv = se.Decipheriv, cryptoBrowserify.createDecipheriv = se.createDecipheriv, cryptoBrowserify.getCiphers = se.getCiphers, cryptoBrowserify.listCiphers = se.listCiphers;
  var ne = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = ne.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = ne.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = ne.getDiffieHellman, cryptoBrowserify.createDiffieHellman = ne.createDiffieHellman, cryptoBrowserify.DiffieHellman = ne.DiffieHellman;
  var ae = requireBrowser$3();
  cryptoBrowserify.createSign = ae.createSign, cryptoBrowserify.Sign = ae.Sign, cryptoBrowserify.createVerify = ae.createVerify, cryptoBrowserify.Verify = ae.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var le = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = le.publicEncrypt, cryptoBrowserify.privateEncrypt = le.privateEncrypt, cryptoBrowserify.publicDecrypt = le.publicDecrypt, cryptoBrowserify.privateDecrypt = le.privateDecrypt;
  var ge = requireBrowser();
  return cryptoBrowserify.randomFill = ge.randomFill, cryptoBrowserify.randomFillSync = ge.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(B) {
  /*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
  Object.defineProperty(B, "__esModule", { value: !0 }), B.utils = B.schnorr = B.verify = B.signSync = B.sign = B.getSharedSecret = B.recoverPublicKey = B.getPublicKey = B.Signature = B.Point = B.CURVE = void 0;
  const z = requireCryptoBrowserify(), Y = BigInt(0), ie = BigInt(1), se = BigInt(2), ne = BigInt(3), ae = BigInt(8), le = Object.freeze({
    a: Y,
    b: BigInt(7),
    P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
    n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
    h: ie,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
  });
  B.CURVE = le;
  const ge = (nr, Zt) => (nr + Zt / se) / Zt, Ee = {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar(nr) {
      const { n: Zt } = le, ir = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), ar = -ie * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), dr = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), vr = ir, br = BigInt("0x100000000000000000000000000000000"), xr = ge(vr * nr, Zt), Pr = ge(-ar * nr, Zt);
      let Er = Ot(nr - xr * ir - Pr * dr, Zt), Dr = Ot(-xr * ar - Pr * vr, Zt);
      const Ir = Er > br, tr = Dr > br;
      if (Ir && (Er = Zt - Er), tr && (Dr = Zt - Dr), Er > br || Dr > br)
        throw new Error("splitScalarEndo: Endomorphism failed, k=" + nr);
      return { k1neg: Ir, k1: Er, k2neg: tr, k2: Dr };
    }
  }, oe = 32, Pe = 32, Ve = 32, Ke = oe + 1, ht = 2 * oe + 1;
  function _t(nr) {
    const { a: Zt, b: ir } = le, ar = Ot(nr * nr), dr = Ot(ar * nr);
    return Ot(dr + Zt * nr + ir);
  }
  const Rt = le.a === Y;
  class kt extends Error {
    constructor(Zt) {
      super(Zt);
    }
  }
  function Bt(nr) {
    if (!(nr instanceof Ct))
      throw new TypeError("JacobianPoint expected");
  }
  class Ct {
    constructor(Zt, ir, ar) {
      this.x = Zt, this.y = ir, this.z = ar;
    }
    static fromAffine(Zt) {
      if (!(Zt instanceof Ht))
        throw new TypeError("JacobianPoint#fromAffine: expected Point");
      return Zt.equals(Ht.ZERO) ? Ct.ZERO : new Ct(Zt.x, Zt.y, ie);
    }
    static toAffineBatch(Zt) {
      const ir = Wt(Zt.map((ar) => ar.z));
      return Zt.map((ar, dr) => ar.toAffine(ir[dr]));
    }
    static normalizeZ(Zt) {
      return Ct.toAffineBatch(Zt).map(Ct.fromAffine);
    }
    equals(Zt) {
      Bt(Zt);
      const { x: ir, y: ar, z: dr } = this, { x: vr, y: br, z: xr } = Zt, Pr = Ot(dr * dr), Er = Ot(xr * xr), Dr = Ot(ir * Er), Ir = Ot(vr * Pr), tr = Ot(Ot(ar * xr) * Er), gr = Ot(Ot(br * dr) * Pr);
      return Dr === Ir && tr === gr;
    }
    negate() {
      return new Ct(this.x, Ot(-this.y), this.z);
    }
    double() {
      const { x: Zt, y: ir, z: ar } = this, dr = Ot(Zt * Zt), vr = Ot(ir * ir), br = Ot(vr * vr), xr = Zt + vr, Pr = Ot(se * (Ot(xr * xr) - dr - br)), Er = Ot(ne * dr), Dr = Ot(Er * Er), Ir = Ot(Dr - se * Pr), tr = Ot(Er * (Pr - Ir) - ae * br), gr = Ot(se * ir * ar);
      return new Ct(Ir, tr, gr);
    }
    add(Zt) {
      Bt(Zt);
      const { x: ir, y: ar, z: dr } = this, { x: vr, y: br, z: xr } = Zt;
      if (vr === Y || br === Y)
        return this;
      if (ir === Y || ar === Y)
        return Zt;
      const Pr = Ot(dr * dr), Er = Ot(xr * xr), Dr = Ot(ir * Er), Ir = Ot(vr * Pr), tr = Ot(Ot(ar * xr) * Er), gr = Ot(Ot(br * dr) * Pr), wr = Ot(Ir - Dr), _r = Ot(gr - tr);
      if (wr === Y)
        return _r === Y ? this.double() : Ct.ZERO;
      const Hr = Ot(wr * wr), Cr = Ot(wr * Hr), Br = Ot(Dr * Hr), zr = Ot(_r * _r - Cr - se * Br), tn = Ot(_r * (Br - zr) - tr * Cr), Qr = Ot(dr * xr * wr);
      return new Ct(zr, tn, Qr);
    }
    subtract(Zt) {
      return this.add(Zt.negate());
    }
    multiplyUnsafe(Zt) {
      const ir = Ct.ZERO;
      if (typeof Zt == "bigint" && Zt === Y)
        return ir;
      let ar = Je(Zt);
      if (ar === ie)
        return this;
      if (!Rt) {
        let Ir = ir, tr = this;
        for (; ar > Y; )
          ar & ie && (Ir = Ir.add(tr)), tr = tr.double(), ar >>= ie;
        return Ir;
      }
      let { k1neg: dr, k1: vr, k2neg: br, k2: xr } = Ee.splitScalar(ar), Pr = ir, Er = ir, Dr = this;
      for (; vr > Y || xr > Y; )
        vr & ie && (Pr = Pr.add(Dr)), xr & ie && (Er = Er.add(Dr)), Dr = Dr.double(), vr >>= ie, xr >>= ie;
      return dr && (Pr = Pr.negate()), br && (Er = Er.negate()), Er = new Ct(Ot(Er.x * Ee.beta), Er.y, Er.z), Pr.add(Er);
    }
    precomputeWindow(Zt) {
      const ir = Rt ? 128 / Zt + 1 : 256 / Zt + 1, ar = [];
      let dr = this, vr = dr;
      for (let br = 0; br < ir; br++) {
        vr = dr, ar.push(vr);
        for (let xr = 1; xr < 2 ** (Zt - 1); xr++)
          vr = vr.add(dr), ar.push(vr);
        dr = vr.double();
      }
      return ar;
    }
    wNAF(Zt, ir) {
      !ir && this.equals(Ct.BASE) && (ir = Ht.BASE);
      const ar = ir && ir._WINDOW_SIZE || 1;
      if (256 % ar)
        throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
      let dr = ir && jt.get(ir);
      dr || (dr = this.precomputeWindow(ar), ir && ar !== 1 && (dr = Ct.normalizeZ(dr), jt.set(ir, dr)));
      let vr = Ct.ZERO, br = Ct.BASE;
      const xr = 1 + (Rt ? 128 / ar : 256 / ar), Pr = 2 ** (ar - 1), Er = BigInt(2 ** ar - 1), Dr = 2 ** ar, Ir = BigInt(ar);
      for (let tr = 0; tr < xr; tr++) {
        const gr = tr * Pr;
        let wr = Number(Zt & Er);
        Zt >>= Ir, wr > Pr && (wr -= Dr, Zt += ie);
        const _r = gr, Hr = gr + Math.abs(wr) - 1, Cr = tr % 2 !== 0, Br = wr < 0;
        wr === 0 ? br = br.add(qt(Cr, dr[_r])) : vr = vr.add(qt(Br, dr[Hr]));
      }
      return { p: vr, f: br };
    }
    multiply(Zt, ir) {
      let ar = Je(Zt), dr, vr;
      if (Rt) {
        const { k1neg: br, k1: xr, k2neg: Pr, k2: Er } = Ee.splitScalar(ar);
        let { p: Dr, f: Ir } = this.wNAF(xr, ir), { p: tr, f: gr } = this.wNAF(Er, ir);
        Dr = qt(br, Dr), tr = qt(Pr, tr), tr = new Ct(Ot(tr.x * Ee.beta), tr.y, tr.z), dr = Dr.add(tr), vr = Ir.add(gr);
      } else {
        const { p: br, f: xr } = this.wNAF(ar, ir);
        dr = br, vr = xr;
      }
      return Ct.normalizeZ([dr, vr])[0];
    }
    toAffine(Zt) {
      const { x: ir, y: ar, z: dr } = this, vr = this.equals(Ct.ZERO);
      Zt == null && (Zt = vr ? ae : Jt(dr));
      const br = Zt, xr = Ot(br * br), Pr = Ot(xr * br), Er = Ot(ir * xr), Dr = Ot(ar * Pr), Ir = Ot(dr * br);
      if (vr)
        return Ht.ZERO;
      if (Ir !== ie)
        throw new Error("invZ was invalid");
      return new Ht(Er, Dr);
    }
  }
  Ct.BASE = new Ct(le.Gx, le.Gy, ie), Ct.ZERO = new Ct(Y, ie, Y);
  function qt(nr, Zt) {
    const ir = Zt.negate();
    return nr ? ir : Zt;
  }
  const jt = /* @__PURE__ */ new WeakMap();
  class Ht {
    constructor(Zt, ir) {
      this.x = Zt, this.y = ir;
    }
    _setWindowSize(Zt) {
      this._WINDOW_SIZE = Zt, jt.delete(this);
    }
    hasEvenY() {
      return this.y % se === Y;
    }
    static fromCompressedHex(Zt) {
      const ir = Zt.length === 32, ar = xt(ir ? Zt : Zt.subarray(1));
      if (!hr(ar))
        throw new Error("Point is not on curve");
      const dr = _t(ar);
      let vr = sr(dr);
      const br = (vr & ie) === ie;
      ir ? br && (vr = Ot(-vr)) : (Zt[0] & 1) === 1 !== br && (vr = Ot(-vr));
      const xr = new Ht(ar, vr);
      return xr.assertValidity(), xr;
    }
    static fromUncompressedHex(Zt) {
      const ir = xt(Zt.subarray(1, oe + 1)), ar = xt(Zt.subarray(oe + 1, oe * 2 + 1)), dr = new Ht(ir, ar);
      return dr.assertValidity(), dr;
    }
    static fromHex(Zt) {
      const ir = Pt(Zt), ar = ir.length, dr = ir[0];
      if (ar === oe)
        return this.fromCompressedHex(ir);
      if (ar === Ke && (dr === 2 || dr === 3))
        return this.fromCompressedHex(ir);
      if (ar === ht && dr === 4)
        return this.fromUncompressedHex(ir);
      throw new Error(`Point.fromHex: received invalid point. Expected 32-${Ke} compressed bytes or ${ht} uncompressed bytes, not ${ar}`);
    }
    static fromPrivateKey(Zt) {
      return Ht.BASE.multiply(Sr(Zt));
    }
    static fromSignature(Zt, ir, ar) {
      const { r: dr, s: vr } = Mr(ir);
      if (![0, 1, 2, 3].includes(ar))
        throw new Error("Cannot recover: invalid recovery bit");
      const br = rr(Pt(Zt)), { n: xr } = le, Pr = ar === 2 || ar === 3 ? dr + xr : dr, Er = Jt(Pr, xr), Dr = Ot(-br * Er, xr), Ir = Ot(vr * Er, xr), tr = ar & 1 ? "03" : "02", gr = Ht.fromHex(tr + Ce(Pr)), wr = Ht.BASE.multiplyAndAddUnsafe(gr, Dr, Ir);
      if (!wr)
        throw new Error("Cannot recover signature: point at infinify");
      return wr.assertValidity(), wr;
    }
    toRawBytes(Zt = !1) {
      return $t(this.toHex(Zt));
    }
    toHex(Zt = !1) {
      const ir = Ce(this.x);
      return Zt ? `${this.hasEvenY() ? "02" : "03"}${ir}` : `04${ir}${Ce(this.y)}`;
    }
    toHexX() {
      return this.toHex(!0).slice(2);
    }
    toRawX() {
      return this.toRawBytes(!0).slice(1);
    }
    assertValidity() {
      const Zt = "Point is not on elliptic curve", { x: ir, y: ar } = this;
      if (!hr(ir) || !hr(ar))
        throw new Error(Zt);
      const dr = Ot(ar * ar), vr = _t(ir);
      if (Ot(dr - vr) !== Y)
        throw new Error(Zt);
    }
    equals(Zt) {
      return this.x === Zt.x && this.y === Zt.y;
    }
    negate() {
      return new Ht(this.x, Ot(-this.y));
    }
    double() {
      return Ct.fromAffine(this).double().toAffine();
    }
    add(Zt) {
      return Ct.fromAffine(this).add(Ct.fromAffine(Zt)).toAffine();
    }
    subtract(Zt) {
      return this.add(Zt.negate());
    }
    multiply(Zt) {
      return Ct.fromAffine(this).multiply(Zt, this).toAffine();
    }
    multiplyAndAddUnsafe(Zt, ir, ar) {
      const dr = Ct.fromAffine(this), vr = ir === Y || ir === ie || this !== Ht.BASE ? dr.multiplyUnsafe(ir) : dr.multiply(ir), br = Ct.fromAffine(Zt).multiplyUnsafe(ar), xr = vr.add(br);
      return xr.equals(Ct.ZERO) ? void 0 : xr.toAffine();
    }
  }
  B.Point = Ht, Ht.BASE = new Ht(le.Gx, le.Gy), Ht.ZERO = new Ht(Y, Y);
  function Yt(nr) {
    return Number.parseInt(nr[0], 16) >= 8 ? "00" + nr : nr;
  }
  function Ut(nr) {
    if (nr.length < 2 || nr[0] !== 2)
      throw new Error(`Invalid signature integer tag: ${Xe(nr)}`);
    const Zt = nr[1], ir = nr.subarray(2, Zt + 2);
    if (!Zt || ir.length !== Zt)
      throw new Error("Invalid signature integer: wrong length");
    if (ir[0] === 0 && ir[1] <= 127)
      throw new Error("Invalid signature integer: trailing length");
    return { data: xt(ir), left: nr.subarray(Zt + 2) };
  }
  function Nt(nr) {
    if (nr.length < 2 || nr[0] != 48)
      throw new Error(`Invalid signature tag: ${Xe(nr)}`);
    if (nr[1] !== nr.length - 2)
      throw new Error("Invalid signature: incorrect length");
    const { data: Zt, left: ir } = Ut(nr.subarray(2)), { data: ar, left: dr } = Ut(ir);
    if (dr.length)
      throw new Error(`Invalid signature: left bytes after parsing: ${Xe(dr)}`);
    return { r: Zt, s: ar };
  }
  class Kt {
    constructor(Zt, ir) {
      this.r = Zt, this.s = ir, this.assertValidity();
    }
    static fromCompact(Zt) {
      const ir = Zt instanceof Uint8Array, ar = "Signature.fromCompact";
      if (typeof Zt != "string" && !ir)
        throw new TypeError(`${ar}: Expected string or Uint8Array`);
      const dr = ir ? Xe(Zt) : Zt;
      if (dr.length !== 128)
        throw new Error(`${ar}: Expected 64-byte hex`);
      return new Kt(wt(dr.slice(0, 64)), wt(dr.slice(64, 128)));
    }
    static fromDER(Zt) {
      const ir = Zt instanceof Uint8Array;
      if (typeof Zt != "string" && !ir)
        throw new TypeError("Signature.fromDER: Expected string or Uint8Array");
      const { r: ar, s: dr } = Nt(ir ? Zt : $t(Zt));
      return new Kt(ar, dr);
    }
    static fromHex(Zt) {
      return this.fromDER(Zt);
    }
    assertValidity() {
      const { r: Zt, s: ir } = this;
      if (!ur(Zt))
        throw new Error("Invalid Signature: r must be 0 < r < n");
      if (!ur(ir))
        throw new Error("Invalid Signature: s must be 0 < s < n");
    }
    hasHighS() {
      const Zt = le.n >> ie;
      return this.s > Zt;
    }
    normalizeS() {
      return this.hasHighS() ? new Kt(this.r, Ot(-this.s, le.n)) : this;
    }
    toDERRawBytes() {
      return $t(this.toDERHex());
    }
    toDERHex() {
      const Zt = Yt(vt(this.s)), ir = Yt(vt(this.r)), ar = Zt.length / 2, dr = ir.length / 2, vr = vt(ar), br = vt(dr);
      return `30${vt(dr + ar + 4)}02${br}${ir}02${vr}${Zt}`;
    }
    toRawBytes() {
      return this.toDERRawBytes();
    }
    toHex() {
      return this.toDERHex();
    }
    toCompactRawBytes() {
      return $t(this.toCompactHex());
    }
    toCompactHex() {
      return Ce(this.r) + Ce(this.s);
    }
  }
  B.Signature = Kt;
  function Ft(...nr) {
    if (!nr.every((ar) => ar instanceof Uint8Array))
      throw new Error("Uint8Array list expected");
    if (nr.length === 1)
      return nr[0];
    const Zt = nr.reduce((ar, dr) => ar + dr.length, 0), ir = new Uint8Array(Zt);
    for (let ar = 0, dr = 0; ar < nr.length; ar++) {
      const vr = nr[ar];
      ir.set(vr, dr), dr += vr.length;
    }
    return ir;
  }
  const bt = Array.from({ length: 256 }, (nr, Zt) => Zt.toString(16).padStart(2, "0"));
  function Xe(nr) {
    if (!(nr instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    let Zt = "";
    for (let ir = 0; ir < nr.length; ir++)
      Zt += bt[nr[ir]];
    return Zt;
  }
  const ve = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
  function Ce(nr) {
    if (typeof nr != "bigint")
      throw new Error("Expected bigint");
    if (!(Y <= nr && nr < ve))
      throw new Error("Expected number 0 <= n < 2^256");
    return nr.toString(16).padStart(64, "0");
  }
  function Qe(nr) {
    const Zt = $t(Ce(nr));
    if (Zt.length !== 32)
      throw new Error("Error: expected 32 bytes");
    return Zt;
  }
  function vt(nr) {
    const Zt = nr.toString(16);
    return Zt.length & 1 ? `0${Zt}` : Zt;
  }
  function wt(nr) {
    if (typeof nr != "string")
      throw new TypeError("hexToNumber: expected string, got " + typeof nr);
    return BigInt(`0x${nr}`);
  }
  function $t(nr) {
    if (typeof nr != "string")
      throw new TypeError("hexToBytes: expected string, got " + typeof nr);
    if (nr.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex" + nr.length);
    const Zt = new Uint8Array(nr.length / 2);
    for (let ir = 0; ir < Zt.length; ir++) {
      const ar = ir * 2, dr = nr.slice(ar, ar + 2), vr = Number.parseInt(dr, 16);
      if (Number.isNaN(vr) || vr < 0)
        throw new Error("Invalid byte sequence");
      Zt[ir] = vr;
    }
    return Zt;
  }
  function xt(nr) {
    return wt(Xe(nr));
  }
  function Pt(nr) {
    return nr instanceof Uint8Array ? Uint8Array.from(nr) : $t(nr);
  }
  function Je(nr) {
    if (typeof nr == "number" && Number.isSafeInteger(nr) && nr > 0)
      return BigInt(nr);
    if (typeof nr == "bigint" && ur(nr))
      return nr;
    throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
  }
  function Ot(nr, Zt = le.P) {
    const ir = nr % Zt;
    return ir >= Y ? ir : Zt + ir;
  }
  function er(nr, Zt) {
    const { P: ir } = le;
    let ar = nr;
    for (; Zt-- > Y; )
      ar *= ar, ar %= ir;
    return ar;
  }
  function sr(nr) {
    const { P: Zt } = le, ir = BigInt(6), ar = BigInt(11), dr = BigInt(22), vr = BigInt(23), br = BigInt(44), xr = BigInt(88), Pr = nr * nr * nr % Zt, Er = Pr * Pr * nr % Zt, Dr = er(Er, ne) * Er % Zt, Ir = er(Dr, ne) * Er % Zt, tr = er(Ir, se) * Pr % Zt, gr = er(tr, ar) * tr % Zt, wr = er(gr, dr) * gr % Zt, _r = er(wr, br) * wr % Zt, Hr = er(_r, xr) * _r % Zt, Cr = er(Hr, br) * wr % Zt, Br = er(Cr, ne) * Er % Zt, zr = er(Br, vr) * gr % Zt, tn = er(zr, ir) * Pr % Zt, Qr = er(tn, se);
    if (Qr * Qr % Zt !== nr)
      throw new Error("Cannot find square root");
    return Qr;
  }
  function Jt(nr, Zt = le.P) {
    if (nr === Y || Zt <= Y)
      throw new Error(`invert: expected positive integers, got n=${nr} mod=${Zt}`);
    let ir = Ot(nr, Zt), ar = Zt, dr = Y, vr = ie;
    for (; ir !== Y; ) {
      const xr = ar / ir, Pr = ar % ir, Er = dr - vr * xr;
      ar = ir, ir = Pr, dr = vr, vr = Er;
    }
    if (ar !== ie)
      throw new Error("invert: does not exist");
    return Ot(dr, Zt);
  }
  function Wt(nr, Zt = le.P) {
    const ir = new Array(nr.length), ar = nr.reduce((vr, br, xr) => br === Y ? vr : (ir[xr] = vr, Ot(vr * br, Zt)), ie), dr = Jt(ar, Zt);
    return nr.reduceRight((vr, br, xr) => br === Y ? vr : (ir[xr] = Ot(vr * ir[xr], Zt), Ot(vr * br, Zt)), dr), ir;
  }
  function Gt(nr) {
    const Zt = nr.length * 8 - Pe * 8, ir = xt(nr);
    return Zt > 0 ? ir >> BigInt(Zt) : ir;
  }
  function rr(nr, Zt = !1) {
    const ir = Gt(nr);
    if (Zt)
      return ir;
    const { n: ar } = le;
    return ir >= ar ? ir - ar : ir;
  }
  let or, Xt;
  class zt {
    constructor(Zt, ir) {
      if (this.hashLen = Zt, this.qByteLen = ir, typeof Zt != "number" || Zt < 2)
        throw new Error("hashLen must be a number");
      if (typeof ir != "number" || ir < 2)
        throw new Error("qByteLen must be a number");
      this.v = new Uint8Array(Zt).fill(1), this.k = new Uint8Array(Zt).fill(0), this.counter = 0;
    }
    hmac(...Zt) {
      return B.utils.hmacSha256(this.k, ...Zt);
    }
    hmacSync(...Zt) {
      return Xt(this.k, ...Zt);
    }
    checkSync() {
      if (typeof Xt != "function")
        throw new kt("hmacSha256Sync needs to be set");
    }
    incr() {
      if (this.counter >= 1e3)
        throw new Error("Tried 1,000 k values for sign(), all were invalid");
      this.counter += 1;
    }
    async reseed(Zt = new Uint8Array()) {
      this.k = await this.hmac(this.v, Uint8Array.from([0]), Zt), this.v = await this.hmac(this.v), Zt.length !== 0 && (this.k = await this.hmac(this.v, Uint8Array.from([1]), Zt), this.v = await this.hmac(this.v));
    }
    reseedSync(Zt = new Uint8Array()) {
      this.checkSync(), this.k = this.hmacSync(this.v, Uint8Array.from([0]), Zt), this.v = this.hmacSync(this.v), Zt.length !== 0 && (this.k = this.hmacSync(this.v, Uint8Array.from([1]), Zt), this.v = this.hmacSync(this.v));
    }
    async generate() {
      this.incr();
      let Zt = 0;
      const ir = [];
      for (; Zt < this.qByteLen; ) {
        this.v = await this.hmac(this.v);
        const ar = this.v.slice();
        ir.push(ar), Zt += this.v.length;
      }
      return Ft(...ir);
    }
    generateSync() {
      this.checkSync(), this.incr();
      let Zt = 0;
      const ir = [];
      for (; Zt < this.qByteLen; ) {
        this.v = this.hmacSync(this.v);
        const ar = this.v.slice();
        ir.push(ar), Zt += this.v.length;
      }
      return Ft(...ir);
    }
  }
  function ur(nr) {
    return Y < nr && nr < le.n;
  }
  function hr(nr) {
    return Y < nr && nr < le.P;
  }
  function yr(nr, Zt, ir, ar = !0) {
    const { n: dr } = le, vr = rr(nr, !0);
    if (!ur(vr))
      return;
    const br = Jt(vr, dr), xr = Ht.BASE.multiply(vr), Pr = Ot(xr.x, dr);
    if (Pr === Y)
      return;
    const Er = Ot(br * Ot(Zt + ir * Pr, dr), dr);
    if (Er === Y)
      return;
    let Dr = new Kt(Pr, Er), Ir = (xr.x === Dr.r ? 0 : 2) | Number(xr.y & ie);
    return ar && Dr.hasHighS() && (Dr = Dr.normalizeS(), Ir ^= 1), { sig: Dr, recovery: Ir };
  }
  function Sr(nr) {
    let Zt;
    if (typeof nr == "bigint")
      Zt = nr;
    else if (typeof nr == "number" && Number.isSafeInteger(nr) && nr > 0)
      Zt = BigInt(nr);
    else if (typeof nr == "string") {
      if (nr.length !== 2 * Pe)
        throw new Error("Expected 32 bytes of private key");
      Zt = wt(nr);
    } else if (nr instanceof Uint8Array) {
      if (nr.length !== Pe)
        throw new Error("Expected 32 bytes of private key");
      Zt = xt(nr);
    } else
      throw new TypeError("Expected valid private key");
    if (!ur(Zt))
      throw new Error("Expected private key: 0 < key < n");
    return Zt;
  }
  function $r(nr) {
    return nr instanceof Ht ? (nr.assertValidity(), nr) : Ht.fromHex(nr);
  }
  function Mr(nr) {
    if (nr instanceof Kt)
      return nr.assertValidity(), nr;
    try {
      return Kt.fromDER(nr);
    } catch {
      return Kt.fromCompact(nr);
    }
  }
  function pr(nr, Zt = !1) {
    return Ht.fromPrivateKey(nr).toRawBytes(Zt);
  }
  B.getPublicKey = pr;
  function Fr(nr, Zt, ir, ar = !1) {
    return Ht.fromSignature(nr, Zt, ir).toRawBytes(ar);
  }
  B.recoverPublicKey = Fr;
  function Ar(nr) {
    const Zt = nr instanceof Uint8Array, ir = typeof nr == "string", ar = (Zt || ir) && nr.length;
    return Zt ? ar === Ke || ar === ht : ir ? ar === Ke * 2 || ar === ht * 2 : nr instanceof Ht;
  }
  function Gr(nr, Zt, ir = !1) {
    if (Ar(nr))
      throw new TypeError("getSharedSecret: first arg must be private key");
    if (!Ar(Zt))
      throw new TypeError("getSharedSecret: second arg must be public key");
    const ar = $r(Zt);
    return ar.assertValidity(), ar.multiply(Sr(nr)).toRawBytes(ir);
  }
  B.getSharedSecret = Gr;
  function Lr(nr) {
    const Zt = nr.length > oe ? nr.slice(0, oe) : nr;
    return xt(Zt);
  }
  function Rr(nr) {
    const Zt = Lr(nr), ir = Ot(Zt, le.n);
    return Vr(ir < Y ? Zt : ir);
  }
  function Vr(nr) {
    return Qe(nr);
  }
  function jr(nr, Zt, ir) {
    if (nr == null)
      throw new Error(`sign: expected valid message hash, not "${nr}"`);
    const ar = Pt(nr), dr = Sr(Zt), vr = [Vr(dr), Rr(ar)];
    if (ir != null) {
      ir === !0 && (ir = B.utils.randomBytes(oe));
      const Pr = Pt(ir);
      if (Pr.length !== oe)
        throw new Error(`sign: Expected ${oe} bytes of extra data`);
      vr.push(Pr);
    }
    const br = Ft(...vr), xr = Lr(ar);
    return { seed: br, m: xr, d: dr };
  }
  function kr(nr, Zt) {
    const { sig: ir, recovery: ar } = nr, { der: dr, recovered: vr } = Object.assign({ canonical: !0, der: !0 }, Zt), br = dr ? ir.toDERRawBytes() : ir.toCompactRawBytes();
    return vr ? [br, ar] : br;
  }
  async function Jr(nr, Zt, ir = {}) {
    const { seed: ar, m: dr, d: vr } = jr(nr, Zt, ir.extraEntropy), br = new zt(Ve, Pe);
    await br.reseed(ar);
    let xr;
    for (; !(xr = yr(await br.generate(), dr, vr, ir.canonical)); )
      await br.reseed();
    return kr(xr, ir);
  }
  B.sign = Jr;
  function Xr(nr, Zt, ir = {}) {
    const { seed: ar, m: dr, d: vr } = jr(nr, Zt, ir.extraEntropy), br = new zt(Ve, Pe);
    br.reseedSync(ar);
    let xr;
    for (; !(xr = yr(br.generateSync(), dr, vr, ir.canonical)); )
      br.reseedSync();
    return kr(xr, ir);
  }
  B.signSync = Xr;
  const Vt = { strict: !0 };
  function Lt(nr, Zt, ir, ar = Vt) {
    let dr;
    try {
      dr = Mr(nr), Zt = Pt(Zt);
    } catch {
      return !1;
    }
    const { r: vr, s: br } = dr;
    if (ar.strict && dr.hasHighS())
      return !1;
    const xr = rr(Zt);
    let Pr;
    try {
      Pr = $r(ir);
    } catch {
      return !1;
    }
    const { n: Er } = le, Dr = Jt(br, Er), Ir = Ot(xr * Dr, Er), tr = Ot(vr * Dr, Er), gr = Ht.BASE.multiplyAndAddUnsafe(Pr, Ir, tr);
    return gr ? Ot(gr.x, Er) === vr : !1;
  }
  B.verify = Lt;
  function Dt(nr) {
    return Ot(xt(nr), le.n);
  }
  class Qt {
    constructor(Zt, ir) {
      this.r = Zt, this.s = ir, this.assertValidity();
    }
    static fromHex(Zt) {
      const ir = Pt(Zt);
      if (ir.length !== 64)
        throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${ir.length}`);
      const ar = xt(ir.subarray(0, 32)), dr = xt(ir.subarray(32, 64));
      return new Qt(ar, dr);
    }
    assertValidity() {
      const { r: Zt, s: ir } = this;
      if (!hr(Zt) || !ur(ir))
        throw new Error("Invalid signature");
    }
    toHex() {
      return Ce(this.r) + Ce(this.s);
    }
    toRawBytes() {
      return $t(this.toHex());
    }
  }
  function fr(nr) {
    return Ht.fromPrivateKey(nr).toRawX();
  }
  class cr {
    constructor(Zt, ir, ar = B.utils.randomBytes()) {
      if (Zt == null)
        throw new TypeError(`sign: Expected valid message, not "${Zt}"`);
      this.m = Pt(Zt);
      const { x: dr, scalar: vr } = this.getScalar(Sr(ir));
      if (this.px = dr, this.d = vr, this.rand = Pt(ar), this.rand.length !== 32)
        throw new TypeError("sign: Expected 32 bytes of aux randomness");
    }
    getScalar(Zt) {
      const ir = Ht.fromPrivateKey(Zt), ar = ir.hasEvenY() ? Zt : le.n - Zt;
      return { point: ir, scalar: ar, x: ir.toRawX() };
    }
    initNonce(Zt, ir) {
      return Qe(Zt ^ xt(ir));
    }
    finalizeNonce(Zt) {
      const ir = Ot(xt(Zt), le.n);
      if (ir === Y)
        throw new Error("sign: Creation of signature failed. k is zero");
      const { point: ar, x: dr, scalar: vr } = this.getScalar(ir);
      return { R: ar, rx: dr, k: vr };
    }
    finalizeSig(Zt, ir, ar, dr) {
      return new Qt(Zt.x, Ot(ir + ar * dr, le.n)).toRawBytes();
    }
    error() {
      throw new Error("sign: Invalid signature produced");
    }
    async calc() {
      const { m: Zt, d: ir, px: ar, rand: dr } = this, vr = B.utils.taggedHash, br = this.initNonce(ir, await vr(Zr.aux, dr)), { R: xr, rx: Pr, k: Er } = this.finalizeNonce(await vr(Zr.nonce, br, ar, Zt)), Dr = Dt(await vr(Zr.challenge, Pr, ar, Zt)), Ir = this.finalizeSig(xr, Er, Dr, ir);
      return await Wr(Ir, Zt, ar) || this.error(), Ir;
    }
    calcSync() {
      const { m: Zt, d: ir, px: ar, rand: dr } = this, vr = B.utils.taggedHashSync, br = this.initNonce(ir, vr(Zr.aux, dr)), { R: xr, rx: Pr, k: Er } = this.finalizeNonce(vr(Zr.nonce, br, ar, Zt)), Dr = Dt(vr(Zr.challenge, Pr, ar, Zt)), Ir = this.finalizeSig(xr, Er, Dr, ir);
      return qr(Ir, Zt, ar) || this.error(), Ir;
    }
  }
  async function lr(nr, Zt, ir) {
    return new cr(nr, Zt, ir).calc();
  }
  function Ur(nr, Zt, ir) {
    return new cr(nr, Zt, ir).calcSync();
  }
  function Nr(nr, Zt, ir) {
    const ar = nr instanceof Qt, dr = ar ? nr : Qt.fromHex(nr);
    return ar && dr.assertValidity(), {
      ...dr,
      m: Pt(Zt),
      P: $r(ir)
    };
  }
  function Tr(nr, Zt, ir, ar) {
    const dr = Ht.BASE.multiplyAndAddUnsafe(Zt, Sr(ir), Ot(-ar, le.n));
    return !(!dr || !dr.hasEvenY() || dr.x !== nr);
  }
  async function Wr(nr, Zt, ir) {
    try {
      const { r: ar, s: dr, m: vr, P: br } = Nr(nr, Zt, ir), xr = Dt(await B.utils.taggedHash(Zr.challenge, Qe(ar), br.toRawX(), vr));
      return Tr(ar, br, dr, xr);
    } catch {
      return !1;
    }
  }
  function qr(nr, Zt, ir) {
    try {
      const { r: ar, s: dr, m: vr, P: br } = Nr(nr, Zt, ir), xr = Dt(B.utils.taggedHashSync(Zr.challenge, Qe(ar), br.toRawX(), vr));
      return Tr(ar, br, dr, xr);
    } catch (ar) {
      if (ar instanceof kt)
        throw ar;
      return !1;
    }
  }
  B.schnorr = {
    Signature: Qt,
    getPublicKey: fr,
    sign: lr,
    verify: Wr,
    signSync: Ur,
    verifySync: qr
  }, Ht.BASE._setWindowSize(8);
  const Or = {
    node: z,
    web: typeof self == "object" && "crypto" in self ? self.crypto : void 0
  }, Zr = {
    challenge: "BIP0340/challenge",
    aux: "BIP0340/aux",
    nonce: "BIP0340/nonce"
  }, Yr = {};
  B.utils = {
    bytesToHex: Xe,
    hexToBytes: $t,
    concatBytes: Ft,
    mod: Ot,
    invert: Jt,
    isValidPrivateKey(nr) {
      try {
        return Sr(nr), !0;
      } catch {
        return !1;
      }
    },
    _bigintTo32Bytes: Qe,
    _normalizePrivateKey: Sr,
    hashToPrivateKey: (nr) => {
      nr = Pt(nr);
      const Zt = Pe + 8;
      if (nr.length < Zt || nr.length > 1024)
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      const ir = Ot(xt(nr), le.n - ie) + ie;
      return Qe(ir);
    },
    randomBytes: (nr = 32) => {
      if (Or.web)
        return Or.web.getRandomValues(new Uint8Array(nr));
      if (Or.node) {
        const { randomBytes: Zt } = Or.node;
        return Uint8Array.from(Zt(nr));
      } else
        throw new Error("The environment doesn't have randomBytes function");
    },
    randomPrivateKey: () => B.utils.hashToPrivateKey(B.utils.randomBytes(Pe + 8)),
    precompute(nr = 8, Zt = Ht.BASE) {
      const ir = Zt === Ht.BASE ? Zt : new Ht(Zt.x, Zt.y);
      return ir._setWindowSize(nr), ir.multiply(ne), ir;
    },
    sha256: async (...nr) => {
      if (Or.web) {
        const Zt = await Or.web.subtle.digest("SHA-256", Ft(...nr));
        return new Uint8Array(Zt);
      } else if (Or.node) {
        const { createHash: Zt } = Or.node, ir = Zt("sha256");
        return nr.forEach((ar) => ir.update(ar)), Uint8Array.from(ir.digest());
      } else
        throw new Error("The environment doesn't have sha256 function");
    },
    hmacSha256: async (nr, ...Zt) => {
      if (Or.web) {
        const ir = await Or.web.subtle.importKey("raw", nr, { name: "HMAC", hash: { name: "SHA-256" } }, !1, ["sign"]), ar = Ft(...Zt), dr = await Or.web.subtle.sign("HMAC", ir, ar);
        return new Uint8Array(dr);
      } else if (Or.node) {
        const { createHmac: ir } = Or.node, ar = ir("sha256", nr);
        return Zt.forEach((dr) => ar.update(dr)), Uint8Array.from(ar.digest());
      } else
        throw new Error("The environment doesn't have hmac-sha256 function");
    },
    sha256Sync: void 0,
    hmacSha256Sync: void 0,
    taggedHash: async (nr, ...Zt) => {
      let ir = Yr[nr];
      if (ir === void 0) {
        const ar = await B.utils.sha256(Uint8Array.from(nr, (dr) => dr.charCodeAt(0)));
        ir = Ft(ar, ar), Yr[nr] = ir;
      }
      return B.utils.sha256(ir, ...Zt);
    },
    taggedHashSync: (nr, ...Zt) => {
      if (typeof or != "function")
        throw new kt("sha256Sync is undefined, you need to set it");
      let ir = Yr[nr];
      if (ir === void 0) {
        const ar = or(Uint8Array.from(nr, (dr) => dr.charCodeAt(0)));
        ir = Ft(ar, ar), Yr[nr] = ir;
      }
      return or(ir, ...Zt);
    },
    _JacobianPoint: Ct
  }, Object.defineProperties(B.utils, {
    sha256Sync: {
      configurable: !1,
      get() {
        return or;
      },
      set(nr) {
        or || (or = nr);
      }
    },
    hmacSha256Sync: {
      configurable: !1,
      get() {
        return Xt;
      },
      set(nr) {
        Xt || (Xt = nr);
      }
    }
  });
})(lib);
var ecdsaSigFormatter = {};
Object.defineProperty(ecdsaSigFormatter, "__esModule", { value: !0 });
ecdsaSigFormatter.joseToDer = ecdsaSigFormatter.derToJose = void 0;
const base64_js_1 = base64Js, base64Url_1 = base64Url;
function getParamSize(B) {
  return (B / 8 | 0) + (B % 8 === 0 ? 0 : 1);
}
const paramBytesForAlg = {
  ES256: getParamSize(256),
  ES384: getParamSize(384),
  ES512: getParamSize(521)
};
function getParamBytesForAlg(B) {
  const z = paramBytesForAlg[B];
  if (z)
    return z;
  throw new Error(`Unknown algorithm "${B}"`);
}
const MAX_OCTET = 128, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 32, TAG_SEQ = 16, TAG_INT = 2, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function signatureAsBytes(B) {
  if (B instanceof Uint8Array)
    return B;
  if (typeof B == "string")
    return (0, base64_js_1.toByteArray)((0, base64Url_1.pad)(B));
  throw new TypeError("ECDSA signature must be a Base64 string or a Uint8Array");
}
function derToJose(B, z) {
  const Y = signatureAsBytes(B), ie = getParamBytesForAlg(z), se = ie + 1, ne = Y.length;
  let ae = 0;
  if (Y[ae++] !== ENCODED_TAG_SEQ)
    throw new Error('Could not find expected "seq"');
  let le = Y[ae++];
  if (le === (MAX_OCTET | 1) && (le = Y[ae++]), ne - ae < le)
    throw new Error(`"seq" specified length of "${le}", only "${ne - ae}" remaining`);
  if (Y[ae++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "r"');
  const ge = Y[ae++];
  if (ne - ae - 2 < ge)
    throw new Error(`"r" specified length of "${ge}", only "${ne - ae - 2}" available`);
  if (se < ge)
    throw new Error(`"r" specified length of "${ge}", max of "${se}" is acceptable`);
  const Ee = ae;
  if (ae += ge, Y[ae++] !== ENCODED_TAG_INT)
    throw new Error('Could not find expected "int" for "s"');
  const oe = Y[ae++];
  if (ne - ae !== oe)
    throw new Error(`"s" specified length of "${oe}", expected "${ne - ae}"`);
  if (se < oe)
    throw new Error(`"s" specified length of "${oe}", max of "${se}" is acceptable`);
  const Pe = ae;
  if (ae += oe, ae !== ne)
    throw new Error(`Expected to consume entire array, but "${ne - ae}" bytes remain`);
  const Ve = ie - ge, Ke = ie - oe, ht = new Uint8Array(Ve + ge + Ke + oe);
  for (ae = 0; ae < Ve; ++ae)
    ht[ae] = 0;
  ht.set(Y.subarray(Ee + Math.max(-Ve, 0), Ee + ge), ae), ae = ie;
  for (const _t = ae; ae < _t + Ke; ++ae)
    ht[ae] = 0;
  return ht.set(Y.subarray(Pe + Math.max(-Ke, 0), Pe + oe), ae), (0, base64Url_1.escape)((0, base64_js_1.fromByteArray)(ht));
}
ecdsaSigFormatter.derToJose = derToJose;
function countPadding(B, z, Y) {
  let ie = 0;
  for (; z + ie < Y && B[z + ie] === 0; )
    ++ie;
  return B[z + ie] >= MAX_OCTET && --ie, ie;
}
function joseToDer(B, z) {
  B = signatureAsBytes(B);
  const Y = getParamBytesForAlg(z), ie = B.length;
  if (ie !== Y * 2)
    throw new TypeError(`"${z}" signatures must be "${Y * 2}" bytes, saw "${ie}"`);
  const se = countPadding(B, 0, Y), ne = countPadding(B, Y, B.length), ae = Y - se, le = Y - ne, ge = 2 + ae + 1 + 1 + le, Ee = ge < MAX_OCTET, oe = new Uint8Array((Ee ? 2 : 3) + ge);
  let Pe = 0;
  return oe[Pe++] = ENCODED_TAG_SEQ, Ee ? oe[Pe++] = ge : (oe[Pe++] = MAX_OCTET | 1, oe[Pe++] = ge & 255), oe[Pe++] = ENCODED_TAG_INT, oe[Pe++] = ae, se < 0 ? (oe[Pe++] = 0, oe.set(B.subarray(0, Y), Pe), Pe += Y) : (oe.set(B.subarray(se, Y), Pe), Pe += Y - se), oe[Pe++] = ENCODED_TAG_INT, oe[Pe++] = le, ne < 0 ? (oe[Pe++] = 0, oe.set(B.subarray(Y), Pe)) : oe.set(B.subarray(Y + ne), Pe), oe;
}
ecdsaSigFormatter.joseToDer = joseToDer;
var errors$1 = {};
Object.defineProperty(errors$1, "__esModule", { value: !0 });
errors$1.InvalidTokenError = errors$1.MissingParametersError = void 0;
class MissingParametersError extends Error {
  constructor(z) {
    super(), this.name = "MissingParametersError", this.message = z || "";
  }
}
errors$1.MissingParametersError = MissingParametersError;
class InvalidTokenError extends Error {
  constructor(z) {
    super(), this.name = "InvalidTokenError", this.message = z || "";
  }
}
errors$1.InvalidTokenError = InvalidTokenError;
Object.defineProperty(secp256k1$1, "__esModule", { value: !0 });
secp256k1$1.SECP256K1Client = void 0;
const hmac_1 = hmac$1, sha256_1$3 = sha256$4, secp = lib, ecdsaSigFormatter_1 = ecdsaSigFormatter, errors_1$2 = errors$1, utils_1$2 = utils$5;
secp.utils.hmacSha256Sync = (B, ...z) => {
  const Y = hmac_1.hmac.create(sha256_1$3.sha256, B);
  return z.forEach((ie) => Y.update(ie)), Y.digest();
};
class SECP256K1Client {
  static derivePublicKey(z, Y = !0) {
    return z.length === 66 && (z = z.slice(0, 64)), z.length < 64 && (z = z.padStart(64, "0")), (0, utils_1$2.bytesToHex)(secp.getPublicKey(z, Y));
  }
  static signHash(z, Y, ie = "jose") {
    if (!z || !Y)
      throw new errors_1$2.MissingParametersError("a signing input hash and private key are all required");
    const se = secp.signSync(z, Y.slice(0, 64), {
      der: !0,
      canonical: !1
    });
    if (ie === "der")
      return (0, utils_1$2.bytesToHex)(se);
    if (ie === "jose")
      return (0, ecdsaSigFormatter_1.derToJose)(se, "ES256");
    throw Error("Invalid signature format");
  }
  static loadSignature(z) {
    return (0, ecdsaSigFormatter_1.joseToDer)(z, "ES256");
  }
  static verifyHash(z, Y, ie) {
    if (!z || !Y || !ie)
      throw new errors_1$2.MissingParametersError("a signing input hash, der signature, and public key are all required");
    return secp.verify(Y, z, ie, { strict: !1 });
  }
}
secp256k1$1.SECP256K1Client = SECP256K1Client;
SECP256K1Client.algorithmName = "ES256K";
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.cryptoClients = B.SECP256K1Client = void 0;
  const z = secp256k1$1;
  Object.defineProperty(B, "SECP256K1Client", { enumerable: !0, get: function() {
    return z.SECP256K1Client;
  } });
  const Y = {
    ES256K: z.SECP256K1Client
  };
  B.cryptoClients = Y;
})(cryptoClients);
var sha256$1 = {}, __awaiter$1 = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ie) {
  function se(ne) {
    return ne instanceof Y ? ne : new Y(function(ae) {
      ae(ne);
    });
  }
  return new (Y || (Y = Promise))(function(ne, ae) {
    function le(oe) {
      try {
        Ee(ie.next(oe));
      } catch (Pe) {
        ae(Pe);
      }
    }
    function ge(oe) {
      try {
        Ee(ie.throw(oe));
      } catch (Pe) {
        ae(Pe);
      }
    }
    function Ee(oe) {
      oe.done ? ne(oe.value) : se(oe.value).then(le, ge);
    }
    Ee((ie = ie.apply(B, z || [])).next());
  });
};
Object.defineProperty(sha256$1, "__esModule", { value: !0 });
sha256$1.hashSha256Async = sha256$1.hashSha256 = void 0;
const sha256_1$2 = sha256$4;
function hashSha256(B) {
  return (0, sha256_1$2.sha256)(B);
}
sha256$1.hashSha256 = hashSha256;
function hashSha256Async(B) {
  return __awaiter$1(this, void 0, void 0, function* () {
    try {
      if (typeof crypto < "u" && typeof crypto.subtle < "u") {
        const Y = typeof B == "string" ? new TextEncoder().encode(B) : B, ie = yield crypto.subtle.digest("SHA-256", Y);
        return new Uint8Array(ie);
      } else {
        const Y = requireCryptoBrowserify();
        if (!Y.createHash)
          throw new Error("`crypto` module does not contain `createHash`");
        return Promise.resolve(Y.createHash("sha256").update(B).digest());
      }
    } catch (z) {
      return console.log(z), console.log('Crypto lib not found. Neither the global `crypto.subtle` Web Crypto API, nor the or the Node.js `require("crypto").createHash` module is available. Falling back to JS implementation.'), Promise.resolve(hashSha256(B));
    }
  });
}
sha256$1.hashSha256Async = hashSha256Async;
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(B, z, Y, ie) {
  function se(ne) {
    return ne instanceof Y ? ne : new Y(function(ae) {
      ae(ne);
    });
  }
  return new (Y || (Y = Promise))(function(ne, ae) {
    function le(oe) {
      try {
        Ee(ie.next(oe));
      } catch (Pe) {
        ae(Pe);
      }
    }
    function ge(oe) {
      try {
        Ee(ie.throw(oe));
      } catch (Pe) {
        ae(Pe);
      }
    }
    function Ee(oe) {
      oe.done ? ne(oe.value) : se(oe.value).then(le, ge);
    }
    Ee((ie = ie.apply(B, z || [])).next());
  });
};
Object.defineProperty(signer, "__esModule", { value: !0 });
signer.TokenSigner = signer.createUnsecuredToken = void 0;
const base64url$2 = base64Url, cryptoClients_1$1 = cryptoClients, errors_1$1 = errors$1, sha256_1$1 = sha256$1;
function createSigningInput(B, z) {
  const Y = [], ie = base64url$2.encode(JSON.stringify(z));
  Y.push(ie);
  const se = base64url$2.encode(JSON.stringify(B));
  return Y.push(se), Y.join(".");
}
function createUnsecuredToken(B) {
  return createSigningInput(B, { typ: "JWT", alg: "none" }) + ".";
}
signer.createUnsecuredToken = createUnsecuredToken;
class TokenSigner {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1$1.MissingParametersError("a signing algorithm and private key are required");
    if (typeof z != "string")
      throw new Error("signing algorithm parameter must be a string");
    if (z = z.toUpperCase(), !cryptoClients_1$1.cryptoClients.hasOwnProperty(z))
      throw new Error("invalid signing algorithm");
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1$1.cryptoClients[z], this.rawPrivateKey = Y;
  }
  header(z = {}) {
    const Y = { typ: this.tokenType, alg: this.cryptoClient.algorithmName };
    return Object.assign({}, Y, z);
  }
  sign(z, Y = !1, ie = {}) {
    const se = this.header(ie), ne = createSigningInput(z, se), ae = (0, sha256_1$1.hashSha256)(ne);
    return this.createWithSignedHash(z, Y, se, ne, ae);
  }
  signAsync(z, Y = !1, ie = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const se = this.header(ie), ne = createSigningInput(z, se), ae = yield (0, sha256_1$1.hashSha256Async)(ne);
      return this.createWithSignedHash(z, Y, se, ne, ae);
    });
  }
  createWithSignedHash(z, Y, ie, se, ne) {
    const ae = this.cryptoClient.signHash(ne, this.rawPrivateKey);
    return Y ? {
      header: [base64url$2.encode(JSON.stringify(ie))],
      payload: JSON.stringify(z),
      signature: [ae]
    } : [se, ae].join(".");
  }
}
signer.TokenSigner = TokenSigner;
var verifier = {};
Object.defineProperty(verifier, "__esModule", { value: !0 });
verifier.TokenVerifier = void 0;
const base64url$1 = base64Url, cryptoClients_1 = cryptoClients, errors_1 = errors$1, sha256_1 = sha256$1;
class TokenVerifier {
  constructor(z, Y) {
    if (!(z && Y))
      throw new errors_1.MissingParametersError("a signing algorithm and public key are required");
    if (typeof z != "string")
      throw "signing algorithm parameter must be a string";
    if (z = z.toUpperCase(), !cryptoClients_1.cryptoClients.hasOwnProperty(z))
      throw "invalid signing algorithm";
    this.tokenType = "JWT", this.cryptoClient = cryptoClients_1.cryptoClients[z], this.rawPublicKey = Y;
  }
  verify(z) {
    return typeof z == "string" ? this.verifyCompact(z, !1) : typeof z == "object" ? this.verifyExpanded(z, !1) : !1;
  }
  verifyAsync(z) {
    return typeof z == "string" ? this.verifyCompact(z, !0) : typeof z == "object" ? this.verifyExpanded(z, !0) : Promise.resolve(!1);
  }
  verifyCompact(z, Y) {
    const ie = z.split("."), se = ie[0] + "." + ie[1], ne = (ae) => {
      const le = this.cryptoClient.loadSignature(ie[2]);
      return this.cryptoClient.verifyHash(ae, le, this.rawPublicKey);
    };
    if (Y)
      return (0, sha256_1.hashSha256Async)(se).then((ae) => ne(ae));
    {
      const ae = (0, sha256_1.hashSha256)(se);
      return ne(ae);
    }
  }
  verifyExpanded(z, Y) {
    const ie = [z.header.join("."), base64url$1.encode(z.payload)].join(".");
    let se = !0;
    const ne = (ae) => (z.signature.map((le) => {
      const ge = this.cryptoClient.loadSignature(le);
      this.cryptoClient.verifyHash(ae, ge, this.rawPublicKey) || (se = !1);
    }), se);
    if (Y)
      return (0, sha256_1.hashSha256Async)(ie).then((ae) => ne(ae));
    {
      const ae = (0, sha256_1.hashSha256)(ie);
      return ne(ae);
    }
  }
}
verifier.TokenVerifier = TokenVerifier;
var decode$i = {};
Object.defineProperty(decode$i, "__esModule", { value: !0 });
decode$i.decodeToken = void 0;
const base64url = base64Url;
function decodeToken(B) {
  if (typeof B == "string") {
    const z = B.split("."), Y = JSON.parse(base64url.decode(z[0])), ie = JSON.parse(base64url.decode(z[1])), se = z[2];
    return {
      header: Y,
      payload: ie,
      signature: se
    };
  } else if (typeof B == "object") {
    if (typeof B.payload != "string")
      throw new Error("Expected token payload to be a base64 or json string");
    let z = B.payload;
    B.payload[0] !== "{" && (z = base64url.decode(z));
    const Y = [];
    return B.header.map((ie) => {
      const se = JSON.parse(base64url.decode(ie));
      Y.push(se);
    }), {
      header: Y,
      payload: JSON.parse(z),
      signature: B.signature
    };
  }
}
decode$i.decodeToken = decodeToken;
(function(B) {
  var z = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(ie, se, ne, ae) {
    ae === void 0 && (ae = ne);
    var le = Object.getOwnPropertyDescriptor(se, ne);
    (!le || ("get" in le ? !se.__esModule : le.writable || le.configurable)) && (le = { enumerable: !0, get: function() {
      return se[ne];
    } }), Object.defineProperty(ie, ae, le);
  } : function(ie, se, ne, ae) {
    ae === void 0 && (ae = ne), ie[ae] = se[ne];
  }), Y = commonjsGlobal && commonjsGlobal.__exportStar || function(ie, se) {
    for (var ne in ie) ne !== "default" && !Object.prototype.hasOwnProperty.call(se, ne) && z(se, ie, ne);
  };
  Object.defineProperty(B, "__esModule", { value: !0 }), Y(signer, B), Y(verifier, B), Y(decode$i, B), Y(errors$1, B), Y(cryptoClients, B);
})(lib$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
(() => {
  const B = Array(256).fill(-1);
  for (let z = 0; z < r.length; ++z) B[r.charCodeAt(z)] = z;
})();
var s, i, o, h$1 = (s = function(B, z) {
  Object.defineProperty(z, "__esModule", { value: !0 }), z.bech32m = z.bech32 = void 0;
  const Y = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ie = {};
  for (let Pe = 0; Pe < 32; Pe++) {
    const Ve = Y.charAt(Pe);
    ie[Ve] = Pe;
  }
  function se(Pe) {
    const Ve = Pe >> 25;
    return (33554431 & Pe) << 5 ^ 996825010 & -(Ve >> 0 & 1) ^ 642813549 & -(Ve >> 1 & 1) ^ 513874426 & -(Ve >> 2 & 1) ^ 1027748829 & -(Ve >> 3 & 1) ^ 705979059 & -(Ve >> 4 & 1);
  }
  function ne(Pe) {
    let Ve = 1;
    for (let Ke = 0; Ke < Pe.length; ++Ke) {
      const ht = Pe.charCodeAt(Ke);
      if (ht < 33 || ht > 126) return "Invalid prefix (" + Pe + ")";
      Ve = se(Ve) ^ ht >> 5;
    }
    Ve = se(Ve);
    for (let Ke = 0; Ke < Pe.length; ++Ke) {
      const ht = Pe.charCodeAt(Ke);
      Ve = se(Ve) ^ 31 & ht;
    }
    return Ve;
  }
  function ae(Pe, Ve, Ke, ht) {
    let _t = 0, Rt = 0;
    const kt = (1 << Ke) - 1, Bt = [];
    for (let Ct = 0; Ct < Pe.length; ++Ct) for (_t = _t << Ve | Pe[Ct], Rt += Ve; Rt >= Ke; ) Rt -= Ke, Bt.push(_t >> Rt & kt);
    if (ht) Rt > 0 && Bt.push(_t << Ke - Rt & kt);
    else {
      if (Rt >= Ve) return "Excess padding";
      if (_t << Ke - Rt & kt) return "Non-zero padding";
    }
    return Bt;
  }
  function le(Pe) {
    return ae(Pe, 8, 5, !0);
  }
  function ge(Pe) {
    const Ve = ae(Pe, 5, 8, !1);
    if (Array.isArray(Ve)) return Ve;
  }
  function Ee(Pe) {
    const Ve = ae(Pe, 5, 8, !1);
    if (Array.isArray(Ve)) return Ve;
    throw new Error(Ve);
  }
  function oe(Pe) {
    let Ve;
    function Ke(ht, _t) {
      if (_t = _t || 90, ht.length < 8) return ht + " too short";
      if (ht.length > _t) return "Exceeds length limit";
      const Rt = ht.toLowerCase(), kt = ht.toUpperCase();
      if (ht !== Rt && ht !== kt) return "Mixed-case string " + ht;
      const Bt = (ht = Rt).lastIndexOf("1");
      if (Bt === -1) return "No separator character for " + ht;
      if (Bt === 0) return "Missing prefix for " + ht;
      const Ct = ht.slice(0, Bt), qt = ht.slice(Bt + 1);
      if (qt.length < 6) return "Data too short";
      let jt = ne(Ct);
      if (typeof jt == "string") return jt;
      const Ht = [];
      for (let Yt = 0; Yt < qt.length; ++Yt) {
        const Ut = qt.charAt(Yt), Nt = ie[Ut];
        if (Nt === void 0) return "Unknown character " + Ut;
        jt = se(jt) ^ Nt, Yt + 6 >= qt.length || Ht.push(Nt);
      }
      return jt !== Ve ? "Invalid checksum for " + ht : { prefix: Ct, words: Ht };
    }
    return Ve = Pe === "bech32" ? 1 : 734539939, { decodeUnsafe: function(ht, _t) {
      const Rt = Ke(ht, _t);
      if (typeof Rt == "object") return Rt;
    }, decode: function(ht, _t) {
      const Rt = Ke(ht, _t);
      if (typeof Rt == "object") return Rt;
      throw new Error(Rt);
    }, encode: function(ht, _t, Rt) {
      if (Rt = Rt || 90, ht.length + 7 + _t.length > Rt) throw new TypeError("Exceeds length limit");
      let kt = ne(ht = ht.toLowerCase());
      if (typeof kt == "string") throw new Error(kt);
      let Bt = ht + "1";
      for (let Ct = 0; Ct < _t.length; ++Ct) {
        const qt = _t[Ct];
        if (qt >> 5) throw new Error("Non 5-bit word");
        kt = se(kt) ^ qt, Bt += Y.charAt(qt);
      }
      for (let Ct = 0; Ct < 6; ++Ct) kt = se(kt);
      kt ^= Ve;
      for (let Ct = 0; Ct < 6; ++Ct) Bt += Y.charAt(kt >> 5 * (5 - Ct) & 31);
      return Bt;
    }, toWords: le, fromWordsUnsafe: ge, fromWords: Ee };
  }
  z.bech32 = oe("bech32"), z.bech32m = oe("bech32m");
}, s(i = { exports: {} }, i.exports), i.exports);
(o = h$1) && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") && o.default;
h$1.bech32m;
h$1.bech32;
new Uint8Array(new Uint16Array([65279]).buffer)[0];
var x, k;
(function(B) {
  B.mainnet = "mainnet", B.testnet = "testnet", B.regtest = "regtest";
})(x || (x = {})), function(B) {
  B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr";
}(k || (k = {}));
k.p2pkh, x.mainnet, k.p2pkh, x.testnet, k.p2sh, x.mainnet, k.p2sh, x.testnet;
var accountChangeEventName = "accountChange";
object({
  type: literal(accountChangeEventName)
});
var networkChangeEventName = "networkChange", networkType = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  type: literal(networkChangeEventName),
  bitcoin: object({
    name: picklist(networkType)
  }),
  stacks: object({
    name: string()
  })
});
var disconnectEventName = "disconnect";
object({
  type: literal(disconnectEventName)
});
function getProviderById(B) {
  return B == null ? void 0 : B.split(".").reduce((z, Y) => z == null ? void 0 : z[Y], window);
}
var BitcoinNetworkType = /* @__PURE__ */ ((B) => (B.Mainnet = "Mainnet", B.Testnet = "Testnet", B.Testnet4 = "Testnet4", B.Signet = "Signet", B.Regtest = "Regtest", B))(BitcoinNetworkType || {}), RpcIdSchema = optional(union([string(), number(), null_()])), rpcRequestMessageSchema = object({
  jsonrpc: literal("2.0"),
  method: string(),
  params: optional(
    union([
      array(unknown()),
      looseObject({}),
      // Note: This is to support current incorrect usage of RPC 2.0. Params need
      // to be either an array or an object when provided. Changing this now would
      // be a breaking change, so accepting null values for now. Tracking in
      // https://linear.app/xverseapp/issue/ENG-4538.
      null_()
    ])
  ),
  id: unwrap(RpcIdSchema)
}), RpcErrorCode = /* @__PURE__ */ ((B) => (B[B.PARSE_ERROR = -32700] = "PARSE_ERROR", B[B.INVALID_REQUEST = -32600] = "INVALID_REQUEST", B[B.METHOD_NOT_FOUND = -32601] = "METHOD_NOT_FOUND", B[B.INVALID_PARAMS = -32602] = "INVALID_PARAMS", B[B.INTERNAL_ERROR = -32603] = "INTERNAL_ERROR", B[B.USER_REJECTION = -32e3] = "USER_REJECTION", B[B.METHOD_NOT_SUPPORTED = -32001] = "METHOD_NOT_SUPPORTED", B[B.ACCESS_DENIED = -32002] = "ACCESS_DENIED", B))(RpcErrorCode || {}), rpcSuccessResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  result: nonOptional(unknown()),
  id: RpcIdSchema
}), rpcErrorResponseMessageSchema = object({
  jsonrpc: literal("2.0"),
  error: nonOptional(unknown()),
  id: RpcIdSchema
});
union([
  rpcSuccessResponseMessageSchema,
  rpcErrorResponseMessageSchema
]);
var stxCallContractMethodName = "stx_callContract", stxCallContractParamsSchema = object({
  /**
   * The contract principal.
   *
   * E.g. `"SPKE...GD5C.my-contract"`
   */
  contract: string(),
  /**
   * The name of the function to call.
   *
   * Note: spec changes ongoing,
   * https://github.com/stacksgov/sips/pull/166#pullrequestreview-1914236999
   */
  functionName: string(),
  /**
   * The function's arguments. The arguments are expected to be hex-encoded
   * strings of Clarity values.
   *
   * To convert Clarity values to their hex representation, the `cvToHex`
   * helper from the `@stacks/transactions` package may be helpful.
   *
   * ```js
   * import { cvToHex } from '@stacks/transactions';
   *
   * const functionArgs = [someClarityValue1, someClarityValue2];
   * const hexArgs = functionArgs.map(cvToHex);
   * ```
   */
  arguments: optional(array(string()))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxCallContractMethodName),
    params: stxCallContractParamsSchema,
    id: string()
  }).entries
});
var stxDeployContractMethodName = "stx_deployContract", stxDeployContractParamsSchema = object({
  /**
   * Name of the contract.
   */
  name: string(),
  /**
   * The source code of the Clarity contract.
   */
  clarityCode: string(),
  /**
   * The version of the Clarity contract.
   */
  clarityVersion: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxDeployContractMethodName),
    params: stxDeployContractParamsSchema,
    id: string()
  }).entries
});
var stxGetAccountsMethodName = "stx_getAccounts", stxGetAccountsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAccountsMethodName),
    params: stxGetAccountsParamsSchema,
    id: string()
  }).entries
});
var AddressPurpose = /* @__PURE__ */ ((B) => (B.Ordinals = "ordinals", B.Payment = "payment", B.Stacks = "stacks", B))(AddressPurpose || {}), AddressType = /* @__PURE__ */ ((B) => (B.p2pkh = "p2pkh", B.p2sh = "p2sh", B.p2wpkh = "p2wpkh", B.p2wsh = "p2wsh", B.p2tr = "p2tr", B.stacks = "stacks", B))(AddressType || {}), addressSchema = object({
  address: string(),
  publicKey: string(),
  purpose: enum_(AddressPurpose),
  addressType: enum_(AddressType),
  walletType: walletTypeSchema
}), stxGetAddressesMethodName = "stx_getAddresses", stxGetAddressesParamsSchema = nullish(
  object({
    /**
     * A message to be displayed to the user in the request prompt.
     */
    message: optional(string())
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxGetAddressesMethodName),
    params: stxGetAddressesParamsSchema,
    id: string()
  }).entries
});
var stxSignMessageMethodName = "stx_signMessage", stxSignMessageParamsSchema = object({
  /**
   * The message to sign.
   */
  message: string(),
  /**
   * The public key to sign the message with.
   */
  publicKey: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignMessageMethodName),
    params: stxSignMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignStructuredMessageMethodName = "stx_signStructuredMessage", stxSignStructuredMessageParamsSchema = object({
  /**
   * The domain to be signed.
   */
  domain: string(),
  /**
   * Message payload to be signed.
   */
  message: string(),
  /**
   * The format version of the parameter.
   */
  parameterFormatVersion: optional(number()),
  /**
   * The public key to sign the message with.
   */
  publicKey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignStructuredMessageMethodName),
    params: stxSignStructuredMessageParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionMethodName = "stx_signTransaction", stxSignTransactionParamsSchema = object({
  /**
   * The transaction to sign as a hex-encoded string.
   */
  transaction: string(),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string()),
  /**
   * Whether to broadcast the transaction after signing. Defaults to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionMethodName),
    params: stxSignTransactionParamsSchema,
    id: string()
  }).entries
});
var stxSignTransactionsMethodName = "stx_signTransactions", stxSignTransactionsParamsSchema = object({
  /**
   * The transactions to sign as hex-encoded strings.
   */
  transactions: pipe(
    array(
      pipe(
        string(),
        check$e((B) => !0, "Invalid hex-encoded Stacks transaction.")
      )
    ),
    minLength(1)
  ),
  /**
   * Whether the signed transactions should be broadcast after signing. Defaults
   * to `true`.
   */
  broadcast: optional(boolean())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxSignTransactionsMethodName),
    params: stxSignTransactionsParamsSchema,
    id: string()
  }).entries
});
var stxTransferStxMethodName = "stx_transferStx", stxTransferStxParamsSchema = object({
  /**
   * Amount of STX tokens to transfer in microstacks as a string. Anything
   * parseable by `BigInt` is acceptable.
   *
   * Example,
   *
   * ```js
   * const amount1 = 1234;
   * const amount2 = 1234n;
   * const amount3 = '1234';
   * ```
   */
  amount: union([number(), string()]),
  /**
   * The recipeint's principal.
   */
  recipient: string(),
  /**
   * A string representing the memo.
   */
  memo: optional(string()),
  /**
   * Version of parameter format.
   */
  version: optional(string()),
  /**
   * The mode of the post conditions.
   */
  postConditionMode: optional(number()),
  /**
   * A hex-encoded string representing the post conditions.
   *
   * A post condition may be converted to it's hex representation using the `serializePostCondition` helper from the `@stacks/transactions` package,
   *
   * ```js
   * import { serializePostCondition } from '@stacks/transactions';
   *
   * const postCondition = somePostCondition;
   * const hexPostCondition = serializePostCondition(postCondition).toString('hex');
   * ```
   */
  postConditions: optional(array(string())),
  /**
   * The public key to sign the transaction with. The wallet may use any key
   * when not provided.
   */
  pubkey: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(stxTransferStxMethodName),
    params: stxTransferStxParamsSchema,
    id: string()
  }).entries
});
var walletTypes = ["software", "ledger", "keystone"], walletTypeSchema = picklist(walletTypes), getInfoMethodName = "getInfo", getInfoParamsSchema = nullish(null_());
object({
  /**
   * Version of the wallet.
   */
  version: string(),
  /**
   * [WBIP](https://wbips.netlify.app/wbips/WBIP002) methods supported by the wallet.
   */
  methods: optional(array(string())),
  /**
   * List of WBIP standards supported by the wallet. Not currently used.
   */
  supports: array(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInfoMethodName),
    params: getInfoParamsSchema,
    id: string()
  }).entries
});
var getAddressesMethodName = "getAddresses", getAddressesParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAddressesMethodName),
    params: getAddressesParamsSchema,
    id: string()
  }).entries
});
var signMessageMethodName = "signMessage", MessageSigningProtocols = /* @__PURE__ */ ((B) => (B.ECDSA = "ECDSA", B.BIP322 = "BIP322", B))(MessageSigningProtocols || {}), signMessageParamsSchema = object({
  /**
   * The address used for signing.
   **/
  address: string(),
  /**
   * The message to sign.
   **/
  message: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: optional(enum_(MessageSigningProtocols))
});
object({
  /**
   * The signature of the message.
   */
  signature: string(),
  /**
   * hash of the message.
   */
  messageHash: string(),
  /**
   * The address used for signing.
   */
  address: string(),
  /**
   * The protocol to use for signing the message.
   */
  protocol: enum_(MessageSigningProtocols)
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signMessageMethodName),
    params: signMessageParamsSchema,
    id: string()
  }).entries
});
var sendTransferMethodName = "sendTransfer", sendTransferParamsSchema = object({
  /**
   * Array of recipients to send to.
   * The amount to send to each recipient is in satoshis.
   */
  recipients: array(
    object({
      address: string(),
      amount: number()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendTransferMethodName),
    params: sendTransferParamsSchema,
    id: string()
  }).entries
});
var signPsbtMethodName = "signPsbt", signPsbtParamsSchema = object({
  /**
   * The base64 encoded PSBT to sign.
   */
  psbt: string(),
  /**
   * The inputs to sign.
   * The key is the address and the value is an array of indexes of the inputs to sign.
   */
  signInputs: record(string(), array(number())),
  /**
   * Whether to broadcast the transaction after signing.
   **/
  broadcast: optional(boolean())
});
object({
  /**
   * The base64 encoded PSBT after signing.
   */
  psbt: string(),
  /**
   * The transaction id as a hex-encoded string.
   * This is only returned if the transaction was broadcast.
   **/
  txid: optional(string())
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(signPsbtMethodName),
    params: signPsbtParamsSchema,
    id: string()
  }).entries
});
var getAccountsMethodName = "getAccounts", getAccountsParamsSchema = object({
  /**
   * The purposes for which to generate addresses. See
   * {@linkcode AddressPurpose} for available purposes.
   */
  purposes: array(enum_(AddressPurpose)),
  /**
   * A message to be displayed to the user in the request prompt.
   */
  message: optional(string())
});
array(
  object({
    ...addressSchema.entries,
    ...object({
      walletType: walletTypeSchema
    }).entries
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountsMethodName),
    params: getAccountsParamsSchema,
    id: string()
  }).entries
});
var getBalanceMethodName = "getBalance";
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getBalanceMethodName),
    id: string()
  }).entries
});
var accountActionsSchema = object({
  read: optional(boolean())
}), walletActionsSchema = object({
  readNetwork: optional(boolean())
}), accountPermissionSchema = object({
  type: literal("account"),
  resourceId: string(),
  clientId: string(),
  actions: accountActionsSchema
}), walletPermissionSchema = object({
  type: literal("wallet"),
  resourceId: string(),
  clientId: string(),
  actions: walletActionsSchema
}), PermissionRequestParams = variant("type", [
  object({
    ...omit(accountPermissionSchema, ["clientId"]).entries
  }),
  object({
    ...omit(walletPermissionSchema, ["clientId"]).entries
  })
]), requestPermissionsMethodName = "wallet_requestPermissions", requestPermissionsParamsSchema = nullish(array(PermissionRequestParams));
literal(!0);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(requestPermissionsMethodName),
    params: requestPermissionsParamsSchema,
    id: string()
  }).entries
});
var renouncePermissionsMethodName = "wallet_renouncePermissions", renouncePermissionsParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(renouncePermissionsMethodName),
    params: renouncePermissionsParamsSchema,
    id: string()
  }).entries
});
var disconnectMethodName = "wallet_disconnect", disconnectParamsSchema = nullish(null_());
nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(disconnectMethodName),
    params: disconnectParamsSchema,
    id: string()
  }).entries
});
var getWalletTypeMethodName = "wallet_getWalletType", getWalletTypeParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getWalletTypeMethodName),
    params: getWalletTypeParamsSchema,
    id: string()
  }).entries
});
var getCurrentPermissionsMethodName = "wallet_getCurrentPermissions", getCurrentPermissionsParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getCurrentPermissionsMethodName),
    params: getCurrentPermissionsParamsSchema,
    id: string()
  }).entries
});
var getAccountMethodName = "wallet_getAccount", getAccountParamsSchema = nullish(null_());
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getAccountMethodName),
    params: getAccountParamsSchema,
    id: string()
  }).entries
});
var getNetworkMethodName = "wallet_getNetwork", getNetworkParamsSchema = nullish(null_()), networkType2 = ["Mainnet", "Testnet", "Testnet4", "Signet", "Regtest"];
object({
  bitcoin: object({
    name: picklist(networkType2)
  }),
  stacks: object({
    name: string()
  })
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getNetworkMethodName),
    params: getNetworkParamsSchema,
    id: string()
  }).entries
});
var connectMethodName = "wallet_connect", connectParamsSchema = nullish(
  object({
    permissions: optional(array(PermissionRequestParams)),
    addresses: optional(array(enum_(AddressPurpose))),
    message: optional(
      pipe(string(), maxLength(80, "The message must not exceed 80 characters."))
    )
  })
);
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(connectMethodName),
    params: connectParamsSchema,
    id: string()
  }).entries
});
var runesEtchMethodName = "runes_etch", etchTermsSchema = object({
  amount: string(),
  cap: string(),
  heightStart: optional(string()),
  heightEnd: optional(string()),
  offsetStart: optional(string()),
  offsetEnd: optional(string())
}), inscriptionDetailsSchema = object({
  contentType: string(),
  contentBase64: string()
}), runesEtchParamsSchema = object({
  runeName: string(),
  divisibility: optional(number()),
  symbol: optional(string()),
  premine: optional(string()),
  isMintable: boolean(),
  delegateInscriptionId: optional(string()),
  destinationAddress: string(),
  refundAddress: string(),
  feeRate: number(),
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  terms: optional(etchTermsSchema),
  inscriptionDetails: optional(inscriptionDetailsSchema),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesEtchMethodName),
    params: runesEtchParamsSchema,
    id: string()
  }).entries
});
var runesGetBalanceMethodName = "runes_getBalance", runesGetBalanceParamsSchema = nullish(null_());
object({
  balances: array(
    object({
      runeName: string(),
      amount: string(),
      divisibility: number(),
      symbol: string(),
      inscriptionId: nullish(string())
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesGetBalanceMethodName),
    params: runesGetBalanceParamsSchema,
    id: string()
  }).entries
});
var runesMintMethodName = "runes_mint", runesMintParamsSchema = object({
  appServiceFee: optional(number()),
  appServiceFeeAddress: optional(string()),
  destinationAddress: string(),
  feeRate: number(),
  refundAddress: string(),
  repeats: number(),
  runeName: string(),
  network: optional(enum_(BitcoinNetworkType))
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesMintMethodName),
    params: runesMintParamsSchema,
    id: string()
  }).entries
});
var runesTransferMethodName = "runes_transfer", runesTransferParamsSchema = object({
  recipients: array(
    object({
      runeName: string(),
      amount: string(),
      address: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(runesTransferMethodName),
    params: runesTransferParamsSchema,
    id: string()
  }).entries
});
var getInscriptionsMethodName = "ord_getInscriptions", getInscriptionsParamsSchema = object({
  offset: number(),
  limit: number()
});
object({
  total: number(),
  limit: number(),
  offset: number(),
  inscriptions: array(
    object({
      inscriptionId: string(),
      inscriptionNumber: string(),
      address: string(),
      collectionName: optional(string()),
      postage: string(),
      contentLength: string(),
      contentType: string(),
      timestamp: number(),
      offset: number(),
      genesisTransaction: string(),
      output: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(getInscriptionsMethodName),
    params: getInscriptionsParamsSchema,
    id: string()
  }).entries
});
var sendInscriptionsMethodName = "ord_sendInscriptions", sendInscriptionsParamsSchema = object({
  transfers: array(
    object({
      address: string(),
      inscriptionId: string()
    })
  )
});
object({
  ...rpcRequestMessageSchema.entries,
  ...object({
    method: literal(sendInscriptionsMethodName),
    params: sendInscriptionsParamsSchema,
    id: string()
  }).entries
});
var request = async (B, z, Y) => {
  var ne;
  let ie = ((ne = window.XverseProviders) == null ? void 0 : ne.BitcoinProvider) || window.BitcoinProvider;
  if (ie = await getProviderById(Y), !ie)
    throw new Error("no wallet provider was found");
  if (!B)
    throw new Error("A wallet method is required");
  const se = await ie.request(B, z);
  return is(rpcErrorResponseMessageSchema, se) ? {
    status: "error",
    error: se.error
  } : is(rpcSuccessResponseMessageSchema, se) ? {
    status: "success",
    result: se.result
  } : {
    status: "error",
    error: {
      code: -32603,
      message: "Received unknown response from provider.",
      data: se
    }
  };
};
async function waitForUnisatExtensionReady() {
  let B = 0;
  const z = 20;
  for (; B < z; ) {
    if (typeof window < "u" && window.unisat)
      try {
        const Y = await window.unisat.getAccounts();
        if (Y && Y.length > 0)
          return !0;
      } catch {
        break;
      }
    B += 1, await new Promise((Y) => {
      setTimeout(Y, 100);
    });
  }
  return !1;
}
BitcoinNetworkType.Mainnet, BitcoinNetworkType.Testnet, BitcoinNetworkType.Signet;
const getXverseAddresses = async (B) => {
  var se;
  if (typeof window > "u")
    throw new OrditSDKError("Cannot call this function outside a browser");
  if (!(typeof ((se = window.XverseProviders) == null ? void 0 : se.BitcoinProvider) < "u"))
    throw new BrowserWalletNotInstalledError("Xverse not installed");
  const Y = [], ie = await request(
    "wallet_connect",
    {
      message: "Provide access to Payment address and Ordinals address",
      addresses: ["ordinals", "payment"]
    },
    "XverseProviders.BitcoinProvider"
  );
  if (ie.status === "error")
    throw new Error("Failed to connect to Xverse");
  if (ie.status === "success") {
    if (console.log("==>response", ie.result), !ie.result || !ie.result.addresses || ie.result.addresses.length !== 2)
      throw new BrowserWalletSigningError(
        "Failed to retrieve addresses using selected wallet"
      );
    ie.result.addresses.forEach((ne) => {
      console.log("==>format", "format");
      try {
        const ae = getAddressFormat(ne.address, B);
        let le = ne.publicKey;
        ae === "taproot" && (le = Buffer$1.from(ne.publicKey, "hex").length === 33 ? le : `02${le}`), Y.push({
          publicKey: le,
          address: ne.address,
          format: ae
        });
      } catch {
        throw B === Network.TESTNET ? new Error(
          "Wrong network type selected. To switch networks in Xverse wallet, go to Settings () > click on Network > Switch to Testnet4 and save your settings."
        ) : new Error(
          `Wrong network type selected. To switch networks in Xverse wallet, go to Settings () > click on Network > Switch to ${B} and save your settings.`
        );
      }
    });
  }
  return Y;
}, WALLET_CHROME_EXTENSION_URL = {
  [Wallet.OKX]: "https://www.okx.com/web3",
  [Wallet.MAGICEDEN]: "https://wallet.magiceden.io/",
  [Wallet.UNISAT]: "https://unisat.io/download",
  // their www subdomain doesn't work\  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.XVERSE]: "https://www.xverse.app/download",
  [Wallet.LEATHER]: "https://leather.io/install-extension"
}, connectWallet = async ({
  network: B,
  wallet: z,
  chain: Y = Chain.BITCOIN
}, { readOnly: ie = !1 } = {}) => {
  switch (z) {
    case Wallet.UNISAT: {
      const ne = await getAddresses$3(B === "testnet4" ? "testnet" : B, Y, {
        readOnly: ie
      });
      if (!ne || ne.length < 1)
        throw new Error("Unisat via Ordit returned no addresses");
      const ae = ne[0];
      return {
        address: {
          ordinals: ae.address,
          payments: ae.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ae.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ae.format
        }
      };
    }
    case Wallet.XVERSE: {
      const se = await getXverseAddresses(B);
      if (console.log("==>xverse", se), !se || se.length < 1)
        throw new Error("Xverse via Ordit returned no addresses");
      const ne = se.find(
        (le) => le.format === "p2sh-p2wpkh" || le.format === "segwit"
      );
      if (!ne)
        throw new Error(
          "Xverse via Ordit did not return a P2SH or Segwit address"
        );
      const ae = se.find(
        (le) => le.format === "taproot"
      );
      if (!ae)
        throw new Error("Xverse via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: ae.address,
          payments: ne.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ne.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ne.format
        }
      };
    }
    case Wallet.MAGICEDEN: {
      const se = await getAddresses$2(B);
      if (!se || se.length < 1)
        throw new Error("Magic Eden via Ordit returned no addresses");
      const ne = se.find(
        (le) => le.format === "segwit" || le.format === "p2sh-p2wpkh"
      );
      if (!ne)
        throw new Error(
          "Magic Eden via Ordit did not return a P2SH or Segwit address"
        );
      const ae = se.find(
        (le) => le.format === "taproot"
      );
      if (!ae)
        throw new Error(
          "Magic Eden via Ordit did not return a Taproot address"
        );
      return {
        address: {
          ordinals: ae.address,
          payments: ne.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ne.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ne.format
        }
      };
    }
    case Wallet.LEATHER: {
      const se = await getAddresses$1(B);
      if (!se || se.length < 1)
        throw new Error("Leather via Ordit returned no addresses");
      const ne = se.find(
        (le) => le.format === "segwit"
      );
      if (!ne)
        throw new Error("Leather via Ordit did not return a Segwit address");
      const ae = se.find(
        (le) => le.format === "taproot"
      );
      if (!ae)
        throw new Error("Leather via Ordit did not return a Taproot address");
      return {
        address: {
          ordinals: ae.address,
          payments: ne.address
        },
        publicKey: {
          ordinals: ae.publicKey,
          payments: ne.publicKey
        },
        format: {
          ordinals: ae.format,
          payments: ne.format
        }
      };
    }
    case Wallet.OKX: {
      const se = await getAddresses(B);
      if (!se || se.length < 1)
        throw new Error("OKX via Ordit returned no addresses");
      const ne = se[0];
      return {
        address: {
          ordinals: ne.address,
          payments: ne.address
        },
        publicKey: {
          ordinals: ne.publicKey,
          payments: ne.publicKey
        },
        format: {
          ordinals: ne.format,
          payments: ne.format
        }
      };
    }
    default:
      throw new Error("Invalid wallet");
  }
};
function useConnect({
  onClose: B,
  onError: z
}) {
  const {
    updateAddress: Y,
    updateTestnetAddress: ie,
    network: se,
    updateWallet: ne,
    updatePublicKey: ae,
    updateFormat: le,
    disconnectWallet: ge,
    address: Ee,
    publicKey: oe,
    format: Pe,
    wallet: Ve,
    chain: Ke
  } = useOrdConnect(), ht = (Rt, kt) => {
    z(kt.message ?? kt.toString()), console.error(`Error while connecting to ${Rt} wallet`, kt), ge(), kt instanceof BrowserWalletNotInstalledError && window.open(
      WALLET_CHROME_EXTENSION_URL[Rt],
      "_blank",
      "noopener,noreferrer"
    );
  }, _t = async (Rt, { readOnly: kt = !1 } = {}) => {
    try {
      const { address: Bt, publicKey: Ct, format: qt } = await connectWallet(
        { network: se, wallet: Rt, chain: Ke },
        { readOnly: kt }
      );
      return se === Network.TESTNET || se === "testnet4" ? ie({
        ordinals: Bt.ordinals,
        payments: Bt.payments
      }) : Y({
        ordinals: Bt.ordinals,
        payments: Bt.payments
      }), ae({
        ordinals: Ct.ordinals,
        payments: Ct.payments
      }), ne(Rt), le({
        ordinals: qt.ordinals,
        payments: qt.payments
      }), B(), !0;
    } catch (Bt) {
      return console.log("===>err", Bt), ht(Rt, Bt), !1;
    }
  };
  return useEffect(() => {
    if (Ve !== Wallet.UNISAT)
      return;
    let Rt = !0, kt = !1;
    const Bt = () => _t(Wallet.UNISAT);
    return Ee && oe && Pe && (async () => {
      const qt = await waitForUnisatExtensionReady();
      if (Rt) {
        if (!qt) {
          ge();
          return;
        }
        kt = await _t(Wallet.UNISAT, {
          readOnly: !0
        }), Rt && kt && window.unisat.addListener("accountsChanged", Bt);
      }
    })(), () => {
      Rt = !1, kt && window.unisat.removeListener("accountsChanged", Bt);
    };
  }, [Ve]), { connectWallet: _t };
}
const ChevronRightIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9%2018L15%2012L9%206'%20stroke='white'%20stroke-width='2'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", LoadingIcon = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20width='44'%20height='44'%20viewBox='0%200%2044%2044'%20stroke='%23fff'%3e%3cg%20fill='none'%20fill-rule='evenodd'%20stroke-width='2'%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='0s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='0s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3ccircle%20cx='22'%20cy='22'%20r='1'%3e%3canimate%20attributeName='r'%20begin='-0.9s'%20dur='1.8s'%20values='1;%2020'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.165,%200.84,%200.44,%201'%20repeatCount='indefinite'/%3e%3canimate%20attributeName='stroke-opacity'%20begin='-0.9s'%20dur='1.8s'%20values='1;%200'%20calcMode='spline'%20keyTimes='0;%201'%20keySplines='0.3,%200.61,%200.355,%201'%20repeatCount='indefinite'/%3e%3c/circle%3e%3c/g%3e%3c/svg%3e", WALLET_TO_NAME = {
  [Wallet.MAGICEDEN]: "Magic Eden",
  [Wallet.UNISAT]: "UniSat",
  [Wallet.XVERSE]: "Xverse",
  [Wallet.LEATHER]: "Leather",
  [Wallet.OKX]: "OKX"
};
function WalletButton({
  wallet: B,
  onConnect: z,
  icon: Y,
  renderAvatar: ie,
  isPreferred: se
}) {
  const ne = isMobileUserAgent(), { wallet: ae, network: le, address: ge, testnetAddress: Ee } = useOrdConnect(), oe = le === Network.TESTNET || le === "testnet4" ? Ee : ge, [Pe, Ve] = useState(!1), Ke = WALLET_TO_NAME[B], ht = async () => {
    Ve(!0);
    try {
      await z();
    } catch {
    }
    Ve(!1);
  }, _t = ae === B && oe.ordinals;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: "button",
      className: "wallet-option-button",
      onClick: ht,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "option-wrapper", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "wallet-icon", src: Y, alt: "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-label", children: Ke }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "wallet-option-subtitle", children: ne ? "Available on app" : "" })
        ] }),
        ae === B && oe.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "wallet-option-connected-address", children: [
          ie ? ie(oe.ordinals, "small") : /* @__PURE__ */ jsxRuntimeExports.jsx(
            Avatar,
            {
              size: ne ? 12 : 16,
              variant: "beam",
              name: oe.ordinals,
              colors: ["#1C2DCB", "#F226B8"]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "label", children: truncateMiddle(oe.ordinals) })
        ] }) : null,
        !_t && se ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "preferred-label", children: "Preferred" }) : null,
        Pe ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: LoadingIcon,
            width: ne ? 20 : 24,
            height: ne ? 20 : 24,
            alt: `${Ke} extension is loading`
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            src: ChevronRightIcon,
            alt: "",
            width: ne ? 20 : 24,
            height: ne ? 20 : 24,
            className: "chevron-btn"
          }
        )
      ] })
    }
  );
}
const CHAIN_TO_NAME = {
  [Chain.BITCOIN]: "Bitcoin",
  [Chain.FRACTAL_BITCOIN]: "Fractal Bitcoin"
};
function SelectWalletModal({
  isOpen: B,
  closeModal: z,
  renderAvatar: Y,
  preferredWallet: ie,
  walletsOrder: se,
  visibleWallets: ne
}) {
  const [ae, le] = useState(""), { connectWallet: ge } = useConnect({
    onClose: z,
    onError: (Ke) => le(Ke)
  }), { network: Ee, chain: oe } = useOrdConnect(), Pe = isMobileUserAgent(), Ve = useMemo(() => {
    const ht = [
      {
        wallet: Wallet.OKX,
        onConnect: () => ge(Wallet.OKX),
        icon: OKXWalletIcon,
        hidden: Pe && Ee !== Network.MAINNET,
        order: 20,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.UNISAT,
        onConnect: () => ge(Wallet.UNISAT),
        icon: UnisatWalletIcon,
        hidden: Pe,
        order: 21,
        chains: [Chain.BITCOIN, Chain.FRACTAL_BITCOIN]
      },
      {
        wallet: Wallet.XVERSE,
        onConnect: () => ge(Wallet.XVERSE),
        icon: XverseWalletIcon,
        order: 22,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.MAGICEDEN,
        onConnect: () => ge(Wallet.MAGICEDEN),
        icon: MagicEdenWalletIcon,
        order: 23,
        chains: [Chain.BITCOIN]
      },
      {
        wallet: Wallet.LEATHER,
        onConnect: () => ge(Wallet.LEATHER),
        icon: LeatherWalletIcon,
        hidden: Pe,
        order: 24,
        chains: [Chain.BITCOIN]
      }
    ].filter((Rt) => (ne || []).includes(Rt.wallet)).filter(
      (Rt) => Rt.chains.includes(oe) && !Rt.hidden
    );
    return se ? ht.map((Rt) => {
      const kt = se.findIndex(
        (Bt) => Bt === Rt.wallet
      );
      return kt >= 0 ? { ...Rt, order: kt } : Rt;
    }).sort((Rt, kt) => Rt.order - kt.order) : ht;
  }, [Pe, Ee, se, ge, ne, oe]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ze$1, { appear: !0, show: B, as: Fragment, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    yt$1,
    {
      as: "div",
      className: "ord-connect-font ord-connect-wallet-modal",
      onClose: z,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0",
            enterTo: "opacity-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100",
            leaveTo: "opacity-0",
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "backdrop" })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "outer-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "inner-container", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ze$1.Child,
          {
            as: Fragment,
            enter: "ease-out duration-300",
            enterFrom: "opacity-0 scale-95",
            enterTo: "opacity-100 scale-100",
            leave: "ease-in duration-200",
            leaveFrom: "opacity-100 scale-100",
            leaveTo: "opacity-0 scale-95",
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Panel, { className: "panel", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-title-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(yt$1.Title, { as: "h3", className: "panel-title", children: [
                  "Choose ",
                  CHAIN_TO_NAME[oe],
                  " wallet to connect"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "button",
                  {
                    type: "button",
                    onClick: z,
                    className: "close-button",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: CloseModalIcon, alt: "Close" })
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: "panel-content-container", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: "panel-content-inner-container", children: Ve.map((Ke, ht) => {
                  const _t = ht === Ve.length - 1;
                  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      WalletButton,
                      {
                        wallet: Ke.wallet,
                        onConnect: async () => {
                          le("");
                          const Rt = Ke.onConnect().then((Bt) => (Bt && le(""), Bt)), kt = await Promise.race([
                            Rt,
                            new Promise((Bt) => {
                              setTimeout(() => Bt("timeout"), 5e3);
                            })
                          ]);
                          return typeof kt == "string" ? (le(
                            "No wallet pop-up? The extension is not responding. Try reloading your browser."
                          ), Rt) : kt;
                        },
                        icon: Ke.icon,
                        renderAvatar: Y,
                        isPreferred: ie === Ke.wallet
                      }
                    ),
                    !_t && /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: "horizontal-separator" })
                  ] }, Ke.wallet);
                }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "error-message", children: ae })
              ] })
            ] })
          }
        ) }) })
      ]
    }
  ) });
}
function OrdConnectKit({
  hideConnectButton: B,
  onViewProfile: z,
  onChangeWalletClick: Y,
  onDisconnectWalletClick: ie,
  renderAvatar: se,
  preferredWallet: ne,
  walletsOrder: ae
}) {
  const {
    address: le,
    disconnectWallet: ge,
    network: Ee,
    isModalOpen: oe,
    openModal: Pe,
    closeModal: Ve,
    visibleWallets: Ke
  } = useOrdConnect(), ht = useHasMounted(), _t = () => B ? null : le != null && le.ordinals ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    PostConnectButton,
    {
      address: le.ordinals,
      network: Ee,
      onViewProfile: z,
      onChangeWallet: () => {
        Pe(), Y == null || Y();
      },
      onDisconnectWallet: () => {
        ge(), ie == null || ie();
      },
      renderAvatar: se
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(PreConnectButton, { disabled: !ht, openModal: Pe });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    _t(),
    ht ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectWalletModal,
      {
        isOpen: oe,
        closeModal: Ve,
        renderAvatar: se,
        preferredWallet: ne,
        walletsOrder: ae,
        visibleWallets: Ke
      }
    ) : null
  ] });
}
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER$2 = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(B) {
  var z, Y, ie, se = Bt.prototype = { constructor: Bt, toString: null, valueOf: null }, ne = new Bt(1), ae = 20, le = 4, ge = -7, Ee = 21, oe = -1e7, Pe = 1e7, Ve = !1, Ke = 1, ht = 0, _t = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "",
    // non-breaking space
    suffix: ""
  }, Rt = "0123456789abcdefghijklmnopqrstuvwxyz", kt = !0;
  function Bt(Ut, Nt) {
    var Kt, Ft, bt, Xe, ve, Ce, Qe, vt, wt = this;
    if (!(wt instanceof Bt)) return new Bt(Ut, Nt);
    if (Nt == null) {
      if (Ut && Ut._isBigNumber === !0) {
        wt.s = Ut.s, !Ut.c || Ut.e > Pe ? wt.c = wt.e = null : Ut.e < oe ? wt.c = [wt.e = 0] : (wt.e = Ut.e, wt.c = Ut.c.slice());
        return;
      }
      if ((Ce = typeof Ut == "number") && Ut * 0 == 0) {
        if (wt.s = 1 / Ut < 0 ? (Ut = -Ut, -1) : 1, Ut === ~~Ut) {
          for (Xe = 0, ve = Ut; ve >= 10; ve /= 10, Xe++) ;
          Xe > Pe ? wt.c = wt.e = null : (wt.e = Xe, wt.c = [Ut]);
          return;
        }
        vt = String(Ut);
      } else {
        if (!isNumeric.test(vt = String(Ut))) return ie(wt, vt, Ce);
        wt.s = vt.charCodeAt(0) == 45 ? (vt = vt.slice(1), -1) : 1;
      }
      (Xe = vt.indexOf(".")) > -1 && (vt = vt.replace(".", "")), (ve = vt.search(/e/i)) > 0 ? (Xe < 0 && (Xe = ve), Xe += +vt.slice(ve + 1), vt = vt.substring(0, ve)) : Xe < 0 && (Xe = vt.length);
    } else {
      if (intCheck(Nt, 2, Rt.length, "Base"), Nt == 10 && kt)
        return wt = new Bt(Ut), Ht(wt, ae + wt.e + 1, le);
      if (vt = String(Ut), Ce = typeof Ut == "number") {
        if (Ut * 0 != 0) return ie(wt, vt, Ce, Nt);
        if (wt.s = 1 / Ut < 0 ? (vt = vt.slice(1), -1) : 1, Bt.DEBUG && vt.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Ut);
      } else
        wt.s = vt.charCodeAt(0) === 45 ? (vt = vt.slice(1), -1) : 1;
      for (Kt = Rt.slice(0, Nt), Xe = ve = 0, Qe = vt.length; ve < Qe; ve++)
        if (Kt.indexOf(Ft = vt.charAt(ve)) < 0) {
          if (Ft == ".") {
            if (ve > Xe) {
              Xe = Qe;
              continue;
            }
          } else if (!bt && (vt == vt.toUpperCase() && (vt = vt.toLowerCase()) || vt == vt.toLowerCase() && (vt = vt.toUpperCase()))) {
            bt = !0, ve = -1, Xe = 0;
            continue;
          }
          return ie(wt, String(Ut), Ce, Nt);
        }
      Ce = !1, vt = Y(vt, Nt, 10, wt.s), (Xe = vt.indexOf(".")) > -1 ? vt = vt.replace(".", "") : Xe = vt.length;
    }
    for (ve = 0; vt.charCodeAt(ve) === 48; ve++) ;
    for (Qe = vt.length; vt.charCodeAt(--Qe) === 48; ) ;
    if (vt = vt.slice(ve, ++Qe)) {
      if (Qe -= ve, Ce && Bt.DEBUG && Qe > 15 && (Ut > MAX_SAFE_INTEGER$2 || Ut !== mathfloor(Ut)))
        throw Error(tooManyDigits + wt.s * Ut);
      if ((Xe = Xe - ve - 1) > Pe)
        wt.c = wt.e = null;
      else if (Xe < oe)
        wt.c = [wt.e = 0];
      else {
        if (wt.e = Xe, wt.c = [], ve = (Xe + 1) % LOG_BASE, Xe < 0 && (ve += LOG_BASE), ve < Qe) {
          for (ve && wt.c.push(+vt.slice(0, ve)), Qe -= LOG_BASE; ve < Qe; )
            wt.c.push(+vt.slice(ve, ve += LOG_BASE));
          ve = LOG_BASE - (vt = vt.slice(ve)).length;
        } else
          ve -= Qe;
        for (; ve--; vt += "0") ;
        wt.c.push(+vt);
      }
    } else
      wt.c = [wt.e = 0];
  }
  Bt.clone = clone, Bt.ROUND_UP = 0, Bt.ROUND_DOWN = 1, Bt.ROUND_CEIL = 2, Bt.ROUND_FLOOR = 3, Bt.ROUND_HALF_UP = 4, Bt.ROUND_HALF_DOWN = 5, Bt.ROUND_HALF_EVEN = 6, Bt.ROUND_HALF_CEIL = 7, Bt.ROUND_HALF_FLOOR = 8, Bt.EUCLID = 9, Bt.config = Bt.set = function(Ut) {
    var Nt, Kt;
    if (Ut != null)
      if (typeof Ut == "object") {
        if (Ut.hasOwnProperty(Nt = "DECIMAL_PLACES") && (Kt = Ut[Nt], intCheck(Kt, 0, MAX, Nt), ae = Kt), Ut.hasOwnProperty(Nt = "ROUNDING_MODE") && (Kt = Ut[Nt], intCheck(Kt, 0, 8, Nt), le = Kt), Ut.hasOwnProperty(Nt = "EXPONENTIAL_AT") && (Kt = Ut[Nt], Kt && Kt.pop ? (intCheck(Kt[0], -1e9, 0, Nt), intCheck(Kt[1], 0, MAX, Nt), ge = Kt[0], Ee = Kt[1]) : (intCheck(Kt, -1e9, MAX, Nt), ge = -(Ee = Kt < 0 ? -Kt : Kt))), Ut.hasOwnProperty(Nt = "RANGE"))
          if (Kt = Ut[Nt], Kt && Kt.pop)
            intCheck(Kt[0], -1e9, -1, Nt), intCheck(Kt[1], 1, MAX, Nt), oe = Kt[0], Pe = Kt[1];
          else if (intCheck(Kt, -1e9, MAX, Nt), Kt)
            oe = -(Pe = Kt < 0 ? -Kt : Kt);
          else
            throw Error(bignumberError + Nt + " cannot be zero: " + Kt);
        if (Ut.hasOwnProperty(Nt = "CRYPTO"))
          if (Kt = Ut[Nt], Kt === !!Kt)
            if (Kt)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Ve = Kt;
              else
                throw Ve = !Kt, Error(bignumberError + "crypto unavailable");
            else
              Ve = Kt;
          else
            throw Error(bignumberError + Nt + " not true or false: " + Kt);
        if (Ut.hasOwnProperty(Nt = "MODULO_MODE") && (Kt = Ut[Nt], intCheck(Kt, 0, 9, Nt), Ke = Kt), Ut.hasOwnProperty(Nt = "POW_PRECISION") && (Kt = Ut[Nt], intCheck(Kt, 0, MAX, Nt), ht = Kt), Ut.hasOwnProperty(Nt = "FORMAT"))
          if (Kt = Ut[Nt], typeof Kt == "object") _t = Kt;
          else throw Error(bignumberError + Nt + " not an object: " + Kt);
        if (Ut.hasOwnProperty(Nt = "ALPHABET"))
          if (Kt = Ut[Nt], typeof Kt == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(Kt))
            kt = Kt.slice(0, 10) == "0123456789", Rt = Kt;
          else
            throw Error(bignumberError + Nt + " invalid: " + Kt);
      } else
        throw Error(bignumberError + "Object expected: " + Ut);
    return {
      DECIMAL_PLACES: ae,
      ROUNDING_MODE: le,
      EXPONENTIAL_AT: [ge, Ee],
      RANGE: [oe, Pe],
      CRYPTO: Ve,
      MODULO_MODE: Ke,
      POW_PRECISION: ht,
      FORMAT: _t,
      ALPHABET: Rt
    };
  }, Bt.isBigNumber = function(Ut) {
    if (!Ut || Ut._isBigNumber !== !0) return !1;
    if (!Bt.DEBUG) return !0;
    var Nt, Kt, Ft = Ut.c, bt = Ut.e, Xe = Ut.s;
    e: if ({}.toString.call(Ft) == "[object Array]") {
      if ((Xe === 1 || Xe === -1) && bt >= -1e9 && bt <= MAX && bt === mathfloor(bt)) {
        if (Ft[0] === 0) {
          if (bt === 0 && Ft.length === 1) return !0;
          break e;
        }
        if (Nt = (bt + 1) % LOG_BASE, Nt < 1 && (Nt += LOG_BASE), String(Ft[0]).length == Nt) {
          for (Nt = 0; Nt < Ft.length; Nt++)
            if (Kt = Ft[Nt], Kt < 0 || Kt >= BASE || Kt !== mathfloor(Kt)) break e;
          if (Kt !== 0) return !0;
        }
      }
    } else if (Ft === null && bt === null && (Xe === null || Xe === 1 || Xe === -1))
      return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Ut);
  }, Bt.maximum = Bt.max = function() {
    return qt(arguments, -1);
  }, Bt.minimum = Bt.min = function() {
    return qt(arguments, 1);
  }, Bt.random = function() {
    var Ut = 9007199254740992, Nt = Math.random() * Ut & 2097151 ? function() {
      return mathfloor(Math.random() * Ut);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(Kt) {
      var Ft, bt, Xe, ve, Ce, Qe = 0, vt = [], wt = new Bt(ne);
      if (Kt == null ? Kt = ae : intCheck(Kt, 0, MAX), ve = mathceil(Kt / LOG_BASE), Ve)
        if (crypto.getRandomValues) {
          for (Ft = crypto.getRandomValues(new Uint32Array(ve *= 2)); Qe < ve; )
            Ce = Ft[Qe] * 131072 + (Ft[Qe + 1] >>> 11), Ce >= 9e15 ? (bt = crypto.getRandomValues(new Uint32Array(2)), Ft[Qe] = bt[0], Ft[Qe + 1] = bt[1]) : (vt.push(Ce % 1e14), Qe += 2);
          Qe = ve / 2;
        } else if (crypto.randomBytes) {
          for (Ft = crypto.randomBytes(ve *= 7); Qe < ve; )
            Ce = (Ft[Qe] & 31) * 281474976710656 + Ft[Qe + 1] * 1099511627776 + Ft[Qe + 2] * 4294967296 + Ft[Qe + 3] * 16777216 + (Ft[Qe + 4] << 16) + (Ft[Qe + 5] << 8) + Ft[Qe + 6], Ce >= 9e15 ? crypto.randomBytes(7).copy(Ft, Qe) : (vt.push(Ce % 1e14), Qe += 7);
          Qe = ve / 7;
        } else
          throw Ve = !1, Error(bignumberError + "crypto unavailable");
      if (!Ve)
        for (; Qe < ve; )
          Ce = Nt(), Ce < 9e15 && (vt[Qe++] = Ce % 1e14);
      for (ve = vt[--Qe], Kt %= LOG_BASE, ve && Kt && (Ce = POWS_TEN[LOG_BASE - Kt], vt[Qe] = mathfloor(ve / Ce) * Ce); vt[Qe] === 0; vt.pop(), Qe--) ;
      if (Qe < 0)
        vt = [Xe = 0];
      else {
        for (Xe = -1; vt[0] === 0; vt.splice(0, 1), Xe -= LOG_BASE) ;
        for (Qe = 1, Ce = vt[0]; Ce >= 10; Ce /= 10, Qe++) ;
        Qe < LOG_BASE && (Xe -= LOG_BASE - Qe);
      }
      return wt.e = Xe, wt.c = vt, wt;
    };
  }(), Bt.sum = function() {
    for (var Ut = 1, Nt = arguments, Kt = new Bt(Nt[0]); Ut < Nt.length; ) Kt = Kt.plus(Nt[Ut++]);
    return Kt;
  }, Y = /* @__PURE__ */ function() {
    var Ut = "0123456789";
    function Nt(Kt, Ft, bt, Xe) {
      for (var ve, Ce = [0], Qe, vt = 0, wt = Kt.length; vt < wt; ) {
        for (Qe = Ce.length; Qe--; Ce[Qe] *= Ft) ;
        for (Ce[0] += Xe.indexOf(Kt.charAt(vt++)), ve = 0; ve < Ce.length; ve++)
          Ce[ve] > bt - 1 && (Ce[ve + 1] == null && (Ce[ve + 1] = 0), Ce[ve + 1] += Ce[ve] / bt | 0, Ce[ve] %= bt);
      }
      return Ce.reverse();
    }
    return function(Kt, Ft, bt, Xe, ve) {
      var Ce, Qe, vt, wt, $t, xt, Pt, Je, Ot = Kt.indexOf("."), er = ae, sr = le;
      for (Ot >= 0 && (wt = ht, ht = 0, Kt = Kt.replace(".", ""), Je = new Bt(Ft), xt = Je.pow(Kt.length - Ot), ht = wt, Je.c = Nt(
        toFixedPoint(coeffToString(xt.c), xt.e, "0"),
        10,
        bt,
        Ut
      ), Je.e = Je.c.length), Pt = Nt(Kt, Ft, bt, ve ? (Ce = Rt, Ut) : (Ce = Ut, Rt)), vt = wt = Pt.length; Pt[--wt] == 0; Pt.pop()) ;
      if (!Pt[0]) return Ce.charAt(0);
      if (Ot < 0 ? --vt : (xt.c = Pt, xt.e = vt, xt.s = Xe, xt = z(xt, Je, er, sr, bt), Pt = xt.c, $t = xt.r, vt = xt.e), Qe = vt + er + 1, Ot = Pt[Qe], wt = bt / 2, $t = $t || Qe < 0 || Pt[Qe + 1] != null, $t = sr < 4 ? (Ot != null || $t) && (sr == 0 || sr == (xt.s < 0 ? 3 : 2)) : Ot > wt || Ot == wt && (sr == 4 || $t || sr == 6 && Pt[Qe - 1] & 1 || sr == (xt.s < 0 ? 8 : 7)), Qe < 1 || !Pt[0])
        Kt = $t ? toFixedPoint(Ce.charAt(1), -er, Ce.charAt(0)) : Ce.charAt(0);
      else {
        if (Pt.length = Qe, $t)
          for (--bt; ++Pt[--Qe] > bt; )
            Pt[Qe] = 0, Qe || (++vt, Pt = [1].concat(Pt));
        for (wt = Pt.length; !Pt[--wt]; ) ;
        for (Ot = 0, Kt = ""; Ot <= wt; Kt += Ce.charAt(Pt[Ot++])) ;
        Kt = toFixedPoint(Kt, vt, Ce.charAt(0));
      }
      return Kt;
    };
  }(), z = /* @__PURE__ */ function() {
    function Ut(Ft, bt, Xe) {
      var ve, Ce, Qe, vt, wt = 0, $t = Ft.length, xt = bt % SQRT_BASE, Pt = bt / SQRT_BASE | 0;
      for (Ft = Ft.slice(); $t--; )
        Qe = Ft[$t] % SQRT_BASE, vt = Ft[$t] / SQRT_BASE | 0, ve = Pt * Qe + vt * xt, Ce = xt * Qe + ve % SQRT_BASE * SQRT_BASE + wt, wt = (Ce / Xe | 0) + (ve / SQRT_BASE | 0) + Pt * vt, Ft[$t] = Ce % Xe;
      return wt && (Ft = [wt].concat(Ft)), Ft;
    }
    function Nt(Ft, bt, Xe, ve) {
      var Ce, Qe;
      if (Xe != ve)
        Qe = Xe > ve ? 1 : -1;
      else
        for (Ce = Qe = 0; Ce < Xe; Ce++)
          if (Ft[Ce] != bt[Ce]) {
            Qe = Ft[Ce] > bt[Ce] ? 1 : -1;
            break;
          }
      return Qe;
    }
    function Kt(Ft, bt, Xe, ve) {
      for (var Ce = 0; Xe--; )
        Ft[Xe] -= Ce, Ce = Ft[Xe] < bt[Xe] ? 1 : 0, Ft[Xe] = Ce * ve + Ft[Xe] - bt[Xe];
      for (; !Ft[0] && Ft.length > 1; Ft.splice(0, 1)) ;
    }
    return function(Ft, bt, Xe, ve, Ce) {
      var Qe, vt, wt, $t, xt, Pt, Je, Ot, er, sr, Jt, Wt, Gt, rr, or, Xt, zt, ur = Ft.s == bt.s ? 1 : -1, hr = Ft.c, yr = bt.c;
      if (!hr || !hr[0] || !yr || !yr[0])
        return new Bt(
          // Return NaN if either NaN, or both Infinity or 0.
          !Ft.s || !bt.s || (hr ? yr && hr[0] == yr[0] : !yr) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            hr && hr[0] == 0 || !yr ? ur * 0 : ur / 0
          )
        );
      for (Ot = new Bt(ur), er = Ot.c = [], vt = Ft.e - bt.e, ur = Xe + vt + 1, Ce || (Ce = BASE, vt = bitFloor(Ft.e / LOG_BASE) - bitFloor(bt.e / LOG_BASE), ur = ur / LOG_BASE | 0), wt = 0; yr[wt] == (hr[wt] || 0); wt++) ;
      if (yr[wt] > (hr[wt] || 0) && vt--, ur < 0)
        er.push(1), $t = !0;
      else {
        for (rr = hr.length, Xt = yr.length, wt = 0, ur += 2, xt = mathfloor(Ce / (yr[0] + 1)), xt > 1 && (yr = Ut(yr, xt, Ce), hr = Ut(hr, xt, Ce), Xt = yr.length, rr = hr.length), Gt = Xt, sr = hr.slice(0, Xt), Jt = sr.length; Jt < Xt; sr[Jt++] = 0) ;
        zt = yr.slice(), zt = [0].concat(zt), or = yr[0], yr[1] >= Ce / 2 && or++;
        do {
          if (xt = 0, Qe = Nt(yr, sr, Xt, Jt), Qe < 0) {
            if (Wt = sr[0], Xt != Jt && (Wt = Wt * Ce + (sr[1] || 0)), xt = mathfloor(Wt / or), xt > 1)
              for (xt >= Ce && (xt = Ce - 1), Pt = Ut(yr, xt, Ce), Je = Pt.length, Jt = sr.length; Nt(Pt, sr, Je, Jt) == 1; )
                xt--, Kt(Pt, Xt < Je ? zt : yr, Je, Ce), Je = Pt.length, Qe = 1;
            else
              xt == 0 && (Qe = xt = 1), Pt = yr.slice(), Je = Pt.length;
            if (Je < Jt && (Pt = [0].concat(Pt)), Kt(sr, Pt, Jt, Ce), Jt = sr.length, Qe == -1)
              for (; Nt(yr, sr, Xt, Jt) < 1; )
                xt++, Kt(sr, Xt < Jt ? zt : yr, Jt, Ce), Jt = sr.length;
          } else Qe === 0 && (xt++, sr = [0]);
          er[wt++] = xt, sr[0] ? sr[Jt++] = hr[Gt] || 0 : (sr = [hr[Gt]], Jt = 1);
        } while ((Gt++ < rr || sr[0] != null) && ur--);
        $t = sr[0] != null, er[0] || er.splice(0, 1);
      }
      if (Ce == BASE) {
        for (wt = 1, ur = er[0]; ur >= 10; ur /= 10, wt++) ;
        Ht(Ot, Xe + (Ot.e = wt + vt * LOG_BASE - 1) + 1, ve, $t);
      } else
        Ot.e = vt, Ot.r = +$t;
      return Ot;
    };
  }();
  function Ct(Ut, Nt, Kt, Ft) {
    var bt, Xe, ve, Ce, Qe;
    if (Kt == null ? Kt = le : intCheck(Kt, 0, 8), !Ut.c) return Ut.toString();
    if (bt = Ut.c[0], ve = Ut.e, Nt == null)
      Qe = coeffToString(Ut.c), Qe = Ft == 1 || Ft == 2 && (ve <= ge || ve >= Ee) ? toExponential(Qe, ve) : toFixedPoint(Qe, ve, "0");
    else if (Ut = Ht(new Bt(Ut), Nt, Kt), Xe = Ut.e, Qe = coeffToString(Ut.c), Ce = Qe.length, Ft == 1 || Ft == 2 && (Nt <= Xe || Xe <= ge)) {
      for (; Ce < Nt; Qe += "0", Ce++) ;
      Qe = toExponential(Qe, Xe);
    } else if (Nt -= ve, Qe = toFixedPoint(Qe, Xe, "0"), Xe + 1 > Ce) {
      if (--Nt > 0) for (Qe += "."; Nt--; Qe += "0") ;
    } else if (Nt += Xe - Ce, Nt > 0)
      for (Xe + 1 == Ce && (Qe += "."); Nt--; Qe += "0") ;
    return Ut.s < 0 && bt ? "-" + Qe : Qe;
  }
  function qt(Ut, Nt) {
    for (var Kt, Ft, bt = 1, Xe = new Bt(Ut[0]); bt < Ut.length; bt++)
      Ft = new Bt(Ut[bt]), (!Ft.s || (Kt = compare(Xe, Ft)) === Nt || Kt === 0 && Xe.s === Nt) && (Xe = Ft);
    return Xe;
  }
  function jt(Ut, Nt, Kt) {
    for (var Ft = 1, bt = Nt.length; !Nt[--bt]; Nt.pop()) ;
    for (bt = Nt[0]; bt >= 10; bt /= 10, Ft++) ;
    return (Kt = Ft + Kt * LOG_BASE - 1) > Pe ? Ut.c = Ut.e = null : Kt < oe ? Ut.c = [Ut.e = 0] : (Ut.e = Kt, Ut.c = Nt), Ut;
  }
  ie = /* @__PURE__ */ function() {
    var Ut = /^(-?)0([xbo])(?=\w[\w.]*$)/i, Nt = /^([^.]+)\.$/, Kt = /^\.([^.]+)$/, Ft = /^-?(Infinity|NaN)$/, bt = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(Xe, ve, Ce, Qe) {
      var vt, wt = Ce ? ve : ve.replace(bt, "");
      if (Ft.test(wt))
        Xe.s = isNaN(wt) ? null : wt < 0 ? -1 : 1;
      else {
        if (!Ce && (wt = wt.replace(Ut, function($t, xt, Pt) {
          return vt = (Pt = Pt.toLowerCase()) == "x" ? 16 : Pt == "b" ? 2 : 8, !Qe || Qe == vt ? xt : $t;
        }), Qe && (vt = Qe, wt = wt.replace(Nt, "$1").replace(Kt, "0.$1")), ve != wt))
          return new Bt(wt, vt);
        if (Bt.DEBUG)
          throw Error(bignumberError + "Not a" + (Qe ? " base " + Qe : "") + " number: " + ve);
        Xe.s = null;
      }
      Xe.c = Xe.e = null;
    };
  }();
  function Ht(Ut, Nt, Kt, Ft) {
    var bt, Xe, ve, Ce, Qe, vt, wt, $t = Ut.c, xt = POWS_TEN;
    if ($t) {
      e: {
        for (bt = 1, Ce = $t[0]; Ce >= 10; Ce /= 10, bt++) ;
        if (Xe = Nt - bt, Xe < 0)
          Xe += LOG_BASE, ve = Nt, Qe = $t[vt = 0], wt = mathfloor(Qe / xt[bt - ve - 1] % 10);
        else if (vt = mathceil((Xe + 1) / LOG_BASE), vt >= $t.length)
          if (Ft) {
            for (; $t.length <= vt; $t.push(0)) ;
            Qe = wt = 0, bt = 1, Xe %= LOG_BASE, ve = Xe - LOG_BASE + 1;
          } else
            break e;
        else {
          for (Qe = Ce = $t[vt], bt = 1; Ce >= 10; Ce /= 10, bt++) ;
          Xe %= LOG_BASE, ve = Xe - LOG_BASE + bt, wt = ve < 0 ? 0 : mathfloor(Qe / xt[bt - ve - 1] % 10);
        }
        if (Ft = Ft || Nt < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        $t[vt + 1] != null || (ve < 0 ? Qe : Qe % xt[bt - ve - 1]), Ft = Kt < 4 ? (wt || Ft) && (Kt == 0 || Kt == (Ut.s < 0 ? 3 : 2)) : wt > 5 || wt == 5 && (Kt == 4 || Ft || Kt == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (Xe > 0 ? ve > 0 ? Qe / xt[bt - ve] : 0 : $t[vt - 1]) % 10 & 1 || Kt == (Ut.s < 0 ? 8 : 7)), Nt < 1 || !$t[0])
          return $t.length = 0, Ft ? (Nt -= Ut.e + 1, $t[0] = xt[(LOG_BASE - Nt % LOG_BASE) % LOG_BASE], Ut.e = -Nt || 0) : $t[0] = Ut.e = 0, Ut;
        if (Xe == 0 ? ($t.length = vt, Ce = 1, vt--) : ($t.length = vt + 1, Ce = xt[LOG_BASE - Xe], $t[vt] = ve > 0 ? mathfloor(Qe / xt[bt - ve] % xt[ve]) * Ce : 0), Ft)
          for (; ; )
            if (vt == 0) {
              for (Xe = 1, ve = $t[0]; ve >= 10; ve /= 10, Xe++) ;
              for (ve = $t[0] += Ce, Ce = 1; ve >= 10; ve /= 10, Ce++) ;
              Xe != Ce && (Ut.e++, $t[0] == BASE && ($t[0] = 1));
              break;
            } else {
              if ($t[vt] += Ce, $t[vt] != BASE) break;
              $t[vt--] = 0, Ce = 1;
            }
        for (Xe = $t.length; $t[--Xe] === 0; $t.pop()) ;
      }
      Ut.e > Pe ? Ut.c = Ut.e = null : Ut.e < oe && (Ut.c = [Ut.e = 0]);
    }
    return Ut;
  }
  function Yt(Ut) {
    var Nt, Kt = Ut.e;
    return Kt === null ? Ut.toString() : (Nt = coeffToString(Ut.c), Nt = Kt <= ge || Kt >= Ee ? toExponential(Nt, Kt) : toFixedPoint(Nt, Kt, "0"), Ut.s < 0 ? "-" + Nt : Nt);
  }
  return se.absoluteValue = se.abs = function() {
    var Ut = new Bt(this);
    return Ut.s < 0 && (Ut.s = 1), Ut;
  }, se.comparedTo = function(Ut, Nt) {
    return compare(this, new Bt(Ut, Nt));
  }, se.decimalPlaces = se.dp = function(Ut, Nt) {
    var Kt, Ft, bt, Xe = this;
    if (Ut != null)
      return intCheck(Ut, 0, MAX), Nt == null ? Nt = le : intCheck(Nt, 0, 8), Ht(new Bt(Xe), Ut + Xe.e + 1, Nt);
    if (!(Kt = Xe.c)) return null;
    if (Ft = ((bt = Kt.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, bt = Kt[bt]) for (; bt % 10 == 0; bt /= 10, Ft--) ;
    return Ft < 0 && (Ft = 0), Ft;
  }, se.dividedBy = se.div = function(Ut, Nt) {
    return z(this, new Bt(Ut, Nt), ae, le);
  }, se.dividedToIntegerBy = se.idiv = function(Ut, Nt) {
    return z(this, new Bt(Ut, Nt), 0, 1);
  }, se.exponentiatedBy = se.pow = function(Ut, Nt) {
    var Kt, Ft, bt, Xe, ve, Ce, Qe, vt, wt, $t = this;
    if (Ut = new Bt(Ut), Ut.c && !Ut.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + Yt(Ut));
    if (Nt != null && (Nt = new Bt(Nt)), Ce = Ut.e > 14, !$t.c || !$t.c[0] || $t.c[0] == 1 && !$t.e && $t.c.length == 1 || !Ut.c || !Ut.c[0])
      return wt = new Bt(Math.pow(+Yt($t), Ce ? Ut.s * (2 - isOdd(Ut)) : +Yt(Ut))), Nt ? wt.mod(Nt) : wt;
    if (Qe = Ut.s < 0, Nt) {
      if (Nt.c ? !Nt.c[0] : !Nt.s) return new Bt(NaN);
      Ft = !Qe && $t.isInteger() && Nt.isInteger(), Ft && ($t = $t.mod(Nt));
    } else {
      if (Ut.e > 9 && ($t.e > 0 || $t.e < -1 || ($t.e == 0 ? $t.c[0] > 1 || Ce && $t.c[1] >= 24e7 : $t.c[0] < 8e13 || Ce && $t.c[0] <= 9999975e7)))
        return Xe = $t.s < 0 && isOdd(Ut) ? -0 : 0, $t.e > -1 && (Xe = 1 / Xe), new Bt(Qe ? 1 / Xe : Xe);
      ht && (Xe = mathceil(ht / LOG_BASE + 2));
    }
    for (Ce ? (Kt = new Bt(0.5), Qe && (Ut.s = 1), vt = isOdd(Ut)) : (bt = Math.abs(+Yt(Ut)), vt = bt % 2), wt = new Bt(ne); ; ) {
      if (vt) {
        if (wt = wt.times($t), !wt.c) break;
        Xe ? wt.c.length > Xe && (wt.c.length = Xe) : Ft && (wt = wt.mod(Nt));
      }
      if (bt) {
        if (bt = mathfloor(bt / 2), bt === 0) break;
        vt = bt % 2;
      } else if (Ut = Ut.times(Kt), Ht(Ut, Ut.e + 1, 1), Ut.e > 14)
        vt = isOdd(Ut);
      else {
        if (bt = +Yt(Ut), bt === 0) break;
        vt = bt % 2;
      }
      $t = $t.times($t), Xe ? $t.c && $t.c.length > Xe && ($t.c.length = Xe) : Ft && ($t = $t.mod(Nt));
    }
    return Ft ? wt : (Qe && (wt = ne.div(wt)), Nt ? wt.mod(Nt) : Xe ? Ht(wt, ht, le, ve) : wt);
  }, se.integerValue = function(Ut) {
    var Nt = new Bt(this);
    return Ut == null ? Ut = le : intCheck(Ut, 0, 8), Ht(Nt, Nt.e + 1, Ut);
  }, se.isEqualTo = se.eq = function(Ut, Nt) {
    return compare(this, new Bt(Ut, Nt)) === 0;
  }, se.isFinite = function() {
    return !!this.c;
  }, se.isGreaterThan = se.gt = function(Ut, Nt) {
    return compare(this, new Bt(Ut, Nt)) > 0;
  }, se.isGreaterThanOrEqualTo = se.gte = function(Ut, Nt) {
    return (Nt = compare(this, new Bt(Ut, Nt))) === 1 || Nt === 0;
  }, se.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, se.isLessThan = se.lt = function(Ut, Nt) {
    return compare(this, new Bt(Ut, Nt)) < 0;
  }, se.isLessThanOrEqualTo = se.lte = function(Ut, Nt) {
    return (Nt = compare(this, new Bt(Ut, Nt))) === -1 || Nt === 0;
  }, se.isNaN = function() {
    return !this.s;
  }, se.isNegative = function() {
    return this.s < 0;
  }, se.isPositive = function() {
    return this.s > 0;
  }, se.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, se.minus = function(Ut, Nt) {
    var Kt, Ft, bt, Xe, ve = this, Ce = ve.s;
    if (Ut = new Bt(Ut, Nt), Nt = Ut.s, !Ce || !Nt) return new Bt(NaN);
    if (Ce != Nt)
      return Ut.s = -Nt, ve.plus(Ut);
    var Qe = ve.e / LOG_BASE, vt = Ut.e / LOG_BASE, wt = ve.c, $t = Ut.c;
    if (!Qe || !vt) {
      if (!wt || !$t) return wt ? (Ut.s = -Nt, Ut) : new Bt($t ? ve : NaN);
      if (!wt[0] || !$t[0])
        return $t[0] ? (Ut.s = -Nt, Ut) : new Bt(wt[0] ? ve : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          le == 3 ? -0 : 0
        ));
    }
    if (Qe = bitFloor(Qe), vt = bitFloor(vt), wt = wt.slice(), Ce = Qe - vt) {
      for ((Xe = Ce < 0) ? (Ce = -Ce, bt = wt) : (vt = Qe, bt = $t), bt.reverse(), Nt = Ce; Nt--; bt.push(0)) ;
      bt.reverse();
    } else
      for (Ft = (Xe = (Ce = wt.length) < (Nt = $t.length)) ? Ce : Nt, Ce = Nt = 0; Nt < Ft; Nt++)
        if (wt[Nt] != $t[Nt]) {
          Xe = wt[Nt] < $t[Nt];
          break;
        }
    if (Xe && (bt = wt, wt = $t, $t = bt, Ut.s = -Ut.s), Nt = (Ft = $t.length) - (Kt = wt.length), Nt > 0) for (; Nt--; wt[Kt++] = 0) ;
    for (Nt = BASE - 1; Ft > Ce; ) {
      if (wt[--Ft] < $t[Ft]) {
        for (Kt = Ft; Kt && !wt[--Kt]; wt[Kt] = Nt) ;
        --wt[Kt], wt[Ft] += BASE;
      }
      wt[Ft] -= $t[Ft];
    }
    for (; wt[0] == 0; wt.splice(0, 1), --vt) ;
    return wt[0] ? jt(Ut, wt, vt) : (Ut.s = le == 3 ? -1 : 1, Ut.c = [Ut.e = 0], Ut);
  }, se.modulo = se.mod = function(Ut, Nt) {
    var Kt, Ft, bt = this;
    return Ut = new Bt(Ut, Nt), !bt.c || !Ut.s || Ut.c && !Ut.c[0] ? new Bt(NaN) : !Ut.c || bt.c && !bt.c[0] ? new Bt(bt) : (Ke == 9 ? (Ft = Ut.s, Ut.s = 1, Kt = z(bt, Ut, 0, 3), Ut.s = Ft, Kt.s *= Ft) : Kt = z(bt, Ut, 0, Ke), Ut = bt.minus(Kt.times(Ut)), !Ut.c[0] && Ke == 1 && (Ut.s = bt.s), Ut);
  }, se.multipliedBy = se.times = function(Ut, Nt) {
    var Kt, Ft, bt, Xe, ve, Ce, Qe, vt, wt, $t, xt, Pt, Je, Ot, er, sr = this, Jt = sr.c, Wt = (Ut = new Bt(Ut, Nt)).c;
    if (!Jt || !Wt || !Jt[0] || !Wt[0])
      return !sr.s || !Ut.s || Jt && !Jt[0] && !Wt || Wt && !Wt[0] && !Jt ? Ut.c = Ut.e = Ut.s = null : (Ut.s *= sr.s, !Jt || !Wt ? Ut.c = Ut.e = null : (Ut.c = [0], Ut.e = 0)), Ut;
    for (Ft = bitFloor(sr.e / LOG_BASE) + bitFloor(Ut.e / LOG_BASE), Ut.s *= sr.s, Qe = Jt.length, $t = Wt.length, Qe < $t && (Je = Jt, Jt = Wt, Wt = Je, bt = Qe, Qe = $t, $t = bt), bt = Qe + $t, Je = []; bt--; Je.push(0)) ;
    for (Ot = BASE, er = SQRT_BASE, bt = $t; --bt >= 0; ) {
      for (Kt = 0, xt = Wt[bt] % er, Pt = Wt[bt] / er | 0, ve = Qe, Xe = bt + ve; Xe > bt; )
        vt = Jt[--ve] % er, wt = Jt[ve] / er | 0, Ce = Pt * vt + wt * xt, vt = xt * vt + Ce % er * er + Je[Xe] + Kt, Kt = (vt / Ot | 0) + (Ce / er | 0) + Pt * wt, Je[Xe--] = vt % Ot;
      Je[Xe] = Kt;
    }
    return Kt ? ++Ft : Je.splice(0, 1), jt(Ut, Je, Ft);
  }, se.negated = function() {
    var Ut = new Bt(this);
    return Ut.s = -Ut.s || null, Ut;
  }, se.plus = function(Ut, Nt) {
    var Kt, Ft = this, bt = Ft.s;
    if (Ut = new Bt(Ut, Nt), Nt = Ut.s, !bt || !Nt) return new Bt(NaN);
    if (bt != Nt)
      return Ut.s = -Nt, Ft.minus(Ut);
    var Xe = Ft.e / LOG_BASE, ve = Ut.e / LOG_BASE, Ce = Ft.c, Qe = Ut.c;
    if (!Xe || !ve) {
      if (!Ce || !Qe) return new Bt(bt / 0);
      if (!Ce[0] || !Qe[0]) return Qe[0] ? Ut : new Bt(Ce[0] ? Ft : bt * 0);
    }
    if (Xe = bitFloor(Xe), ve = bitFloor(ve), Ce = Ce.slice(), bt = Xe - ve) {
      for (bt > 0 ? (ve = Xe, Kt = Qe) : (bt = -bt, Kt = Ce), Kt.reverse(); bt--; Kt.push(0)) ;
      Kt.reverse();
    }
    for (bt = Ce.length, Nt = Qe.length, bt - Nt < 0 && (Kt = Qe, Qe = Ce, Ce = Kt, Nt = bt), bt = 0; Nt; )
      bt = (Ce[--Nt] = Ce[Nt] + Qe[Nt] + bt) / BASE | 0, Ce[Nt] = BASE === Ce[Nt] ? 0 : Ce[Nt] % BASE;
    return bt && (Ce = [bt].concat(Ce), ++ve), jt(Ut, Ce, ve);
  }, se.precision = se.sd = function(Ut, Nt) {
    var Kt, Ft, bt, Xe = this;
    if (Ut != null && Ut !== !!Ut)
      return intCheck(Ut, 1, MAX), Nt == null ? Nt = le : intCheck(Nt, 0, 8), Ht(new Bt(Xe), Ut, Nt);
    if (!(Kt = Xe.c)) return null;
    if (bt = Kt.length - 1, Ft = bt * LOG_BASE + 1, bt = Kt[bt]) {
      for (; bt % 10 == 0; bt /= 10, Ft--) ;
      for (bt = Kt[0]; bt >= 10; bt /= 10, Ft++) ;
    }
    return Ut && Xe.e + 1 > Ft && (Ft = Xe.e + 1), Ft;
  }, se.shiftedBy = function(Ut) {
    return intCheck(Ut, -9007199254740991, MAX_SAFE_INTEGER$2), this.times("1e" + Ut);
  }, se.squareRoot = se.sqrt = function() {
    var Ut, Nt, Kt, Ft, bt, Xe = this, ve = Xe.c, Ce = Xe.s, Qe = Xe.e, vt = ae + 4, wt = new Bt("0.5");
    if (Ce !== 1 || !ve || !ve[0])
      return new Bt(!Ce || Ce < 0 && (!ve || ve[0]) ? NaN : ve ? Xe : 1 / 0);
    if (Ce = Math.sqrt(+Yt(Xe)), Ce == 0 || Ce == 1 / 0 ? (Nt = coeffToString(ve), (Nt.length + Qe) % 2 == 0 && (Nt += "0"), Ce = Math.sqrt(+Nt), Qe = bitFloor((Qe + 1) / 2) - (Qe < 0 || Qe % 2), Ce == 1 / 0 ? Nt = "5e" + Qe : (Nt = Ce.toExponential(), Nt = Nt.slice(0, Nt.indexOf("e") + 1) + Qe), Kt = new Bt(Nt)) : Kt = new Bt(Ce + ""), Kt.c[0]) {
      for (Qe = Kt.e, Ce = Qe + vt, Ce < 3 && (Ce = 0); ; )
        if (bt = Kt, Kt = wt.times(bt.plus(z(Xe, bt, vt, 1))), coeffToString(bt.c).slice(0, Ce) === (Nt = coeffToString(Kt.c)).slice(0, Ce))
          if (Kt.e < Qe && --Ce, Nt = Nt.slice(Ce - 3, Ce + 1), Nt == "9999" || !Ft && Nt == "4999") {
            if (!Ft && (Ht(bt, bt.e + ae + 2, 0), bt.times(bt).eq(Xe))) {
              Kt = bt;
              break;
            }
            vt += 4, Ce += 4, Ft = 1;
          } else {
            (!+Nt || !+Nt.slice(1) && Nt.charAt(0) == "5") && (Ht(Kt, Kt.e + ae + 2, 1), Ut = !Kt.times(Kt).eq(Xe));
            break;
          }
    }
    return Ht(Kt, Kt.e + ae + 1, le, Ut);
  }, se.toExponential = function(Ut, Nt) {
    return Ut != null && (intCheck(Ut, 0, MAX), Ut++), Ct(this, Ut, Nt, 1);
  }, se.toFixed = function(Ut, Nt) {
    return Ut != null && (intCheck(Ut, 0, MAX), Ut = Ut + this.e + 1), Ct(this, Ut, Nt);
  }, se.toFormat = function(Ut, Nt, Kt) {
    var Ft, bt = this;
    if (Kt == null)
      Ut != null && Nt && typeof Nt == "object" ? (Kt = Nt, Nt = null) : Ut && typeof Ut == "object" ? (Kt = Ut, Ut = Nt = null) : Kt = _t;
    else if (typeof Kt != "object")
      throw Error(bignumberError + "Argument not an object: " + Kt);
    if (Ft = bt.toFixed(Ut, Nt), bt.c) {
      var Xe, ve = Ft.split("."), Ce = +Kt.groupSize, Qe = +Kt.secondaryGroupSize, vt = Kt.groupSeparator || "", wt = ve[0], $t = ve[1], xt = bt.s < 0, Pt = xt ? wt.slice(1) : wt, Je = Pt.length;
      if (Qe && (Xe = Ce, Ce = Qe, Qe = Xe, Je -= Xe), Ce > 0 && Je > 0) {
        for (Xe = Je % Ce || Ce, wt = Pt.substr(0, Xe); Xe < Je; Xe += Ce) wt += vt + Pt.substr(Xe, Ce);
        Qe > 0 && (wt += vt + Pt.slice(Xe)), xt && (wt = "-" + wt);
      }
      Ft = $t ? wt + (Kt.decimalSeparator || "") + ((Qe = +Kt.fractionGroupSize) ? $t.replace(
        new RegExp("\\d{" + Qe + "}\\B", "g"),
        "$&" + (Kt.fractionGroupSeparator || "")
      ) : $t) : wt;
    }
    return (Kt.prefix || "") + Ft + (Kt.suffix || "");
  }, se.toFraction = function(Ut) {
    var Nt, Kt, Ft, bt, Xe, ve, Ce, Qe, vt, wt, $t, xt, Pt = this, Je = Pt.c;
    if (Ut != null && (Ce = new Bt(Ut), !Ce.isInteger() && (Ce.c || Ce.s !== 1) || Ce.lt(ne)))
      throw Error(bignumberError + "Argument " + (Ce.isInteger() ? "out of range: " : "not an integer: ") + Yt(Ce));
    if (!Je) return new Bt(Pt);
    for (Nt = new Bt(ne), vt = Kt = new Bt(ne), Ft = Qe = new Bt(ne), xt = coeffToString(Je), Xe = Nt.e = xt.length - Pt.e - 1, Nt.c[0] = POWS_TEN[(ve = Xe % LOG_BASE) < 0 ? LOG_BASE + ve : ve], Ut = !Ut || Ce.comparedTo(Nt) > 0 ? Xe > 0 ? Nt : vt : Ce, ve = Pe, Pe = 1 / 0, Ce = new Bt(xt), Qe.c[0] = 0; wt = z(Ce, Nt, 0, 1), bt = Kt.plus(wt.times(Ft)), bt.comparedTo(Ut) != 1; )
      Kt = Ft, Ft = bt, vt = Qe.plus(wt.times(bt = vt)), Qe = bt, Nt = Ce.minus(wt.times(bt = Nt)), Ce = bt;
    return bt = z(Ut.minus(Kt), Ft, 0, 1), Qe = Qe.plus(bt.times(vt)), Kt = Kt.plus(bt.times(Ft)), Qe.s = vt.s = Pt.s, Xe = Xe * 2, $t = z(vt, Ft, Xe, le).minus(Pt).abs().comparedTo(
      z(Qe, Kt, Xe, le).minus(Pt).abs()
    ) < 1 ? [vt, Ft] : [Qe, Kt], Pe = ve, $t;
  }, se.toNumber = function() {
    return +Yt(this);
  }, se.toPrecision = function(Ut, Nt) {
    return Ut != null && intCheck(Ut, 1, MAX), Ct(this, Ut, Nt, 2);
  }, se.toString = function(Ut) {
    var Nt, Kt = this, Ft = Kt.s, bt = Kt.e;
    return bt === null ? Ft ? (Nt = "Infinity", Ft < 0 && (Nt = "-" + Nt)) : Nt = "NaN" : (Ut == null ? Nt = bt <= ge || bt >= Ee ? toExponential(coeffToString(Kt.c), bt) : toFixedPoint(coeffToString(Kt.c), bt, "0") : Ut === 10 && kt ? (Kt = Ht(new Bt(Kt), ae + bt + 1, le), Nt = toFixedPoint(coeffToString(Kt.c), Kt.e, "0")) : (intCheck(Ut, 2, Rt.length, "Base"), Nt = Y(toFixedPoint(coeffToString(Kt.c), bt, "0"), 10, Ut, Ft, !0)), Ft < 0 && Kt.c[0] && (Nt = "-" + Nt)), Nt;
  }, se.valueOf = se.toJSON = function() {
    return Yt(this);
  }, se._isBigNumber = !0, se[Symbol.toStringTag] = "BigNumber", se[Symbol.for("nodejs.util.inspect.custom")] = se.valueOf, B != null && Bt.set(B), Bt;
}
function bitFloor(B) {
  var z = B | 0;
  return B > 0 || B === z ? z : z - 1;
}
function coeffToString(B) {
  for (var z, Y, ie = 1, se = B.length, ne = B[0] + ""; ie < se; ) {
    for (z = B[ie++] + "", Y = LOG_BASE - z.length; Y--; z = "0" + z) ;
    ne += z;
  }
  for (se = ne.length; ne.charCodeAt(--se) === 48; ) ;
  return ne.slice(0, se + 1 || 1);
}
function compare(B, z) {
  var Y, ie, se = B.c, ne = z.c, ae = B.s, le = z.s, ge = B.e, Ee = z.e;
  if (!ae || !le) return null;
  if (Y = se && !se[0], ie = ne && !ne[0], Y || ie) return Y ? ie ? 0 : -le : ae;
  if (ae != le) return ae;
  if (Y = ae < 0, ie = ge == Ee, !se || !ne) return ie ? 0 : !se ^ Y ? 1 : -1;
  if (!ie) return ge > Ee ^ Y ? 1 : -1;
  for (le = (ge = se.length) < (Ee = ne.length) ? ge : Ee, ae = 0; ae < le; ae++) if (se[ae] != ne[ae]) return se[ae] > ne[ae] ^ Y ? 1 : -1;
  return ge == Ee ? 0 : ge > Ee ^ Y ? 1 : -1;
}
function intCheck(B, z, Y, ie) {
  if (B < z || B > Y || B !== mathfloor(B))
    throw Error(bignumberError + (ie || "Argument") + (typeof B == "number" ? B < z || B > Y ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(B));
}
function isOdd(B) {
  var z = B.c.length - 1;
  return bitFloor(B.e / LOG_BASE) == z && B.c[z] % 2 != 0;
}
function toExponential(B, z) {
  return (B.length > 1 ? B.charAt(0) + "." + B.slice(1) : B) + (z < 0 ? "e" : "e+") + z;
}
function toFixedPoint(B, z, Y) {
  var ie, se;
  if (z < 0) {
    for (se = Y + "."; ++z; se += Y) ;
    B = se + B;
  } else if (ie = B.length, ++z > ie) {
    for (se = Y, z -= ie; --z; se += Y) ;
    B += se;
  } else z < ie && (B = B.slice(0, z) + "." + B.slice(z));
  return B;
}
var BigNumber = clone();
function useBalance() {
  const { network: B, publicKey: z, format: Y, chain: ie } = useOrdConnect(), [se, ne] = useState(null), [ae, le] = useState(!1);
  return { getBalance: useCallback(async () => {
    le(!0);
    try {
      if (ne(null), !Y || !Y.payments || !z || !z.payments)
        throw new Error("No wallet is connected");
      const { address: Ee } = getAddressesFromPublicKey(
        z.payments,
        B,
        ADDRESS_FORMAT_TO_TYPE[Y.payments],
        ie
      )[0], Pe = await new JsonRpcDatasource({
        chain: ie,
        network: B
      }).getBalance({ address: Ee }), Ve = Number(
        new BigNumber(Pe).multipliedBy(1e8).toFixed(0, BigNumber.ROUND_HALF_DOWN)
      );
      return le(!1), Ve;
    } catch (Ee) {
      throw ne(Ee.message), le(!1), Ee;
    }
  }, [Y, B, z]), error: se, loading: ae };
}
async function signPsbt({
  address: B,
  wallet: z,
  network: Y,
  psbt: ie,
  options: se
}) {
  var ge, Ee;
  if ((ge = se == null ? void 0 : se.signingIndexes) != null && ge.length && ((Ee = se == null ? void 0 : se.inputsToSign) != null && Ee.length))
    throw new Error("Cannot have both indexes and inputs to sign together");
  const ne = (se == null ? void 0 : se.finalize) ?? !0, ae = (se == null ? void 0 : se.extractTx) ?? !0, le = () => ie.data.inputs.map((oe, Pe) => Pe);
  if (z === Wallet.MAGICEDEN)
    return await signPsbt$1(ie, {
      network: Y,
      inputsToSign: (se == null ? void 0 : se.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (se == null ? void 0 : se.signingIndexes) ?? le(),
          sigHash: se == null ? void 0 : se.sigHash
        }
      ],
      finalize: ne,
      extractTx: ae
    });
  if (z === Wallet.UNISAT)
    return await signPsbt$2(ie, {
      finalize: ne,
      extractTx: ae
    });
  if (z === Wallet.XVERSE)
    return await signPsbt$3(ie, {
      network: Y,
      inputsToSign: (se == null ? void 0 : se.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (se == null ? void 0 : se.signingIndexes) ?? le(),
          // If signingIndexes is not provided, just sign everything
          sigHash: se == null ? void 0 : se.sigHash
        }
      ],
      finalize: ne,
      extractTx: ae
    });
  if (z === Wallet.LEATHER)
    return await signPsbt$4(ie, {
      network: Y,
      finalize: ne,
      extractTx: ae,
      allowedSighash: se != null && se.sigHash ? [se == null ? void 0 : se.sigHash] : [],
      signAtIndexes: (se == null ? void 0 : se.signingIndexes) ?? le()
      // If signingIndexes is not provided, just sign everything
    });
  if (z === Wallet.OKX)
    return await signPsbt$5(ie, {
      finalize: ne,
      extractTx: ae,
      network: Y,
      inputsToSign: (se == null ? void 0 : se.inputsToSign) ?? [
        {
          address: B,
          signingIndexes: (se == null ? void 0 : se.signingIndexes) ?? le(),
          // If signingIndexes is not provided, just sign everything
          sigHash: se == null ? void 0 : se.sigHash
        }
      ]
    });
  throw new Error("Invalid wallet selected");
}
function useSend() {
  const { wallet: B, network: z, address: Y, publicKey: ie, chain: se } = useOrdConnect(), [ne, ae] = useState(null), [le, ge] = useState(!1);
  return { send: useCallback(
    async (oe, Pe, Ve, Ke = !0) => {
      ge(!0);
      try {
        if (ae(null), !Y || !Y.payments || !ie || !ie.payments || !B)
          throw new Error("No wallet is connected");
        const ht = new PSBTBuilder({
          address: Y.payments,
          feeRate: Ve,
          network: z,
          chain: se,
          publicKey: ie.payments,
          outputs: [
            {
              address: oe,
              value: Pe
            }
          ]
        });
        await ht.prepare();
        const _t = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: ht.toPSBT()
        });
        if (Ke) {
          const kt = await new JsonRpcDatasource({ network: z, chain: se }).relay({ hex: _t.hex });
          return ge(!1), kt;
        }
        return ge(!1), _t.hex;
      } catch (ht) {
        return ae(ht.message), ge(!1), null;
      }
    },
    [Y, z, ie, B]
  ), error: ne, loading: le };
}
function useSendV2() {
  const { wallet: B, network: z, address: Y, publicKey: ie, chain: se } = useOrdConnect(), [ne, ae] = useState(!1);
  return { send: useCallback(
    async ({
      toAddress: ge,
      satoshis: Ee,
      feeRate: oe,
      relay: Pe = !0,
      rbf: Ve = !1
    }) => {
      ae(!0);
      try {
        if (!Y || !Y.payments || !ie || !ie.payments || !B)
          throw new Error("No wallet is connected");
        const Ke = new PSBTBuilder({
          address: Y.payments,
          feeRate: oe,
          network: z,
          chain: se,
          publicKey: ie.payments,
          outputs: [
            {
              address: ge,
              value: Ee
            }
          ]
        });
        Ke.setRBF(Ve), await Ke.prepare();
        const ht = await signPsbt({
          address: Y.payments,
          wallet: B,
          network: z,
          psbt: Ke.toPSBT()
        });
        if (Pe) {
          const Rt = await new JsonRpcDatasource({ network: z, chain: se }).relay({ hex: ht.hex });
          return ae(!1), {
            txId: Rt
          };
        }
        return ae(!1), {
          signedPsbtHex: ht.hex
        };
      } catch (Ke) {
        return ae(!1), {
          error: Ke.message
        };
      }
    },
    [Y, z, ie, B]
  ), isLoading: ne };
}
var src$1 = {}, address = {}, networks = {};
Object.defineProperty(networks, "__esModule", { value: !0 });
networks.testnet = networks.regtest = networks.bitcoin = void 0;
networks.bitcoin = {
  /**
   * The message prefix used for signing Bitcoin messages.
   */
  messagePrefix: `Bitcoin Signed Message:
`,
  /**
   * The Bech32 prefix used for Bitcoin addresses.
   */
  bech32: "bc",
  /**
   * The BIP32 key prefixes for Bitcoin.
   */
  bip32: {
    /**
     * The public key prefix for BIP32 extended public keys.
     */
    public: 76067358,
    /**
     * The private key prefix for BIP32 extended private keys.
     */
    private: 76066276
  },
  /**
   * The prefix for Bitcoin public key hashes.
   */
  pubKeyHash: 0,
  /**
   * The prefix for Bitcoin script hashes.
   */
  scriptHash: 5,
  /**
   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
   */
  wif: 128
};
networks.regtest = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bcrt",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
networks.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var payments$2 = {}, embed = {}, script = {}, bip66 = {};
Object.defineProperty(bip66, "__esModule", { value: !0 });
bip66.encode = bip66.decode = bip66.check = void 0;
function check$d(B) {
  if (B.length < 8 || B.length > 72 || B[0] !== 48 || B[1] !== B.length - 2 || B[2] !== 2) return !1;
  const z = B[3];
  if (z === 0 || 5 + z >= B.length || B[4 + z] !== 2) return !1;
  const Y = B[5 + z];
  return !(Y === 0 || 6 + z + Y !== B.length || B[4] & 128 || z > 1 && B[4] === 0 && !(B[5] & 128) || B[z + 6] & 128 || Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128));
}
bip66.check = check$d;
function decode$h(B) {
  if (B.length < 8) throw new Error("DER sequence length is too short");
  if (B.length > 72) throw new Error("DER sequence length is too long");
  if (B[0] !== 48) throw new Error("Expected DER sequence");
  if (B[1] !== B.length - 2)
    throw new Error("DER sequence length is invalid");
  if (B[2] !== 2) throw new Error("Expected DER integer");
  const z = B[3];
  if (z === 0) throw new Error("R length is zero");
  if (5 + z >= B.length) throw new Error("R length is too long");
  if (B[4 + z] !== 2) throw new Error("Expected DER integer (2)");
  const Y = B[5 + z];
  if (Y === 0) throw new Error("S length is zero");
  if (6 + z + Y !== B.length) throw new Error("S length is invalid");
  if (B[4] & 128) throw new Error("R value is negative");
  if (z > 1 && B[4] === 0 && !(B[5] & 128))
    throw new Error("R value excessively padded");
  if (B[z + 6] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[z + 6] === 0 && !(B[z + 7] & 128))
    throw new Error("S value excessively padded");
  return {
    r: B.slice(4, 4 + z),
    s: B.slice(6 + z)
  };
}
bip66.decode = decode$h;
function encode$i(B, z) {
  const Y = B.length, ie = z.length;
  if (Y === 0) throw new Error("R length is zero");
  if (ie === 0) throw new Error("S length is zero");
  if (Y > 33) throw new Error("R length is too long");
  if (ie > 33) throw new Error("S length is too long");
  if (B[0] & 128) throw new Error("R value is negative");
  if (z[0] & 128) throw new Error("S value is negative");
  if (Y > 1 && B[0] === 0 && !(B[1] & 128))
    throw new Error("R value excessively padded");
  if (ie > 1 && z[0] === 0 && !(z[1] & 128))
    throw new Error("S value excessively padded");
  const se = Buffer$1.allocUnsafe(6 + Y + ie);
  return se[0] = 48, se[1] = se.length - 2, se[2] = 2, se[3] = B.length, B.copy(se, 4), se[4 + Y] = 2, se[5 + Y] = z.length, z.copy(se, 6 + Y), se;
}
bip66.encode = encode$i;
var ops = {};
Object.defineProperty(ops, "__esModule", { value: !0 });
ops.REVERSE_OPS = ops.OPS = void 0;
const OPS$7 = {
  OP_FALSE: 0,
  OP_0: 0,
  OP_PUSHDATA1: 76,
  OP_PUSHDATA2: 77,
  OP_PUSHDATA4: 78,
  OP_1NEGATE: 79,
  OP_RESERVED: 80,
  OP_TRUE: 81,
  OP_1: 81,
  OP_2: 82,
  OP_3: 83,
  OP_4: 84,
  OP_5: 85,
  OP_6: 86,
  OP_7: 87,
  OP_8: 88,
  OP_9: 89,
  OP_10: 90,
  OP_11: 91,
  OP_12: 92,
  OP_13: 93,
  OP_14: 94,
  OP_15: 95,
  OP_16: 96,
  OP_NOP: 97,
  OP_VER: 98,
  OP_IF: 99,
  OP_NOTIF: 100,
  OP_VERIF: 101,
  OP_VERNOTIF: 102,
  OP_ELSE: 103,
  OP_ENDIF: 104,
  OP_VERIFY: 105,
  OP_RETURN: 106,
  OP_TOALTSTACK: 107,
  OP_FROMALTSTACK: 108,
  OP_2DROP: 109,
  OP_2DUP: 110,
  OP_3DUP: 111,
  OP_2OVER: 112,
  OP_2ROT: 113,
  OP_2SWAP: 114,
  OP_IFDUP: 115,
  OP_DEPTH: 116,
  OP_DROP: 117,
  OP_DUP: 118,
  OP_NIP: 119,
  OP_OVER: 120,
  OP_PICK: 121,
  OP_ROLL: 122,
  OP_ROT: 123,
  OP_SWAP: 124,
  OP_TUCK: 125,
  OP_CAT: 126,
  OP_SUBSTR: 127,
  OP_LEFT: 128,
  OP_RIGHT: 129,
  OP_SIZE: 130,
  OP_INVERT: 131,
  OP_AND: 132,
  OP_OR: 133,
  OP_XOR: 134,
  OP_EQUAL: 135,
  OP_EQUALVERIFY: 136,
  OP_RESERVED1: 137,
  OP_RESERVED2: 138,
  OP_1ADD: 139,
  OP_1SUB: 140,
  OP_2MUL: 141,
  OP_2DIV: 142,
  OP_NEGATE: 143,
  OP_ABS: 144,
  OP_NOT: 145,
  OP_0NOTEQUAL: 146,
  OP_ADD: 147,
  OP_SUB: 148,
  OP_MUL: 149,
  OP_DIV: 150,
  OP_MOD: 151,
  OP_LSHIFT: 152,
  OP_RSHIFT: 153,
  OP_BOOLAND: 154,
  OP_BOOLOR: 155,
  OP_NUMEQUAL: 156,
  OP_NUMEQUALVERIFY: 157,
  OP_NUMNOTEQUAL: 158,
  OP_LESSTHAN: 159,
  OP_GREATERTHAN: 160,
  OP_LESSTHANOREQUAL: 161,
  OP_GREATERTHANOREQUAL: 162,
  OP_MIN: 163,
  OP_MAX: 164,
  OP_WITHIN: 165,
  OP_RIPEMD160: 166,
  OP_SHA1: 167,
  OP_SHA256: 168,
  OP_HASH160: 169,
  OP_HASH256: 170,
  OP_CODESEPARATOR: 171,
  OP_CHECKSIG: 172,
  OP_CHECKSIGVERIFY: 173,
  OP_CHECKMULTISIG: 174,
  OP_CHECKMULTISIGVERIFY: 175,
  OP_NOP1: 176,
  OP_NOP2: 177,
  OP_CHECKLOCKTIMEVERIFY: 177,
  OP_NOP3: 178,
  OP_CHECKSEQUENCEVERIFY: 178,
  OP_NOP4: 179,
  OP_NOP5: 180,
  OP_NOP6: 181,
  OP_NOP7: 182,
  OP_NOP8: 183,
  OP_NOP9: 184,
  OP_NOP10: 185,
  OP_CHECKSIGADD: 186,
  OP_PUBKEYHASH: 253,
  OP_PUBKEY: 254,
  OP_INVALIDOPCODE: 255
};
ops.OPS = OPS$7;
const REVERSE_OPS = {};
ops.REVERSE_OPS = REVERSE_OPS;
for (const B of Object.keys(OPS$7)) {
  const z = OPS$7[B];
  REVERSE_OPS[z] = B;
}
var push_data = {};
Object.defineProperty(push_data, "__esModule", { value: !0 });
push_data.decode = push_data.encode = push_data.encodingLength = void 0;
const ops_1 = ops;
function encodingLength$2(B) {
  return B < ops_1.OPS.OP_PUSHDATA1 ? 1 : B <= 255 ? 2 : B <= 65535 ? 3 : 5;
}
push_data.encodingLength = encodingLength$2;
function encode$h(B, z, Y) {
  const ie = encodingLength$2(z);
  return ie === 1 ? B.writeUInt8(z, Y) : ie === 2 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA1, Y), B.writeUInt8(z, Y + 1)) : ie === 3 ? (B.writeUInt8(ops_1.OPS.OP_PUSHDATA2, Y), B.writeUInt16LE(z, Y + 1)) : (B.writeUInt8(ops_1.OPS.OP_PUSHDATA4, Y), B.writeUInt32LE(z, Y + 1)), ie;
}
push_data.encode = encode$h;
function decode$g(B, z) {
  const Y = B.readUInt8(z);
  let ie, se;
  if (Y < ops_1.OPS.OP_PUSHDATA1)
    ie = Y, se = 1;
  else if (Y === ops_1.OPS.OP_PUSHDATA1) {
    if (z + 2 > B.length) return null;
    ie = B.readUInt8(z + 1), se = 2;
  } else if (Y === ops_1.OPS.OP_PUSHDATA2) {
    if (z + 3 > B.length) return null;
    ie = B.readUInt16LE(z + 1), se = 3;
  } else {
    if (z + 5 > B.length) return null;
    if (Y !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
    ie = B.readUInt32LE(z + 1), se = 5;
  }
  return {
    opcode: Y,
    number: ie,
    size: se
  };
}
push_data.decode = decode$g;
var script_number = {};
Object.defineProperty(script_number, "__esModule", { value: !0 });
script_number.encode = script_number.decode = void 0;
function decode$f(B, z, Y) {
  z = z || 4, Y = Y === void 0 ? !0 : Y;
  const ie = B.length;
  if (ie === 0) return 0;
  if (ie > z) throw new TypeError("Script number overflow");
  if (Y && !(B[ie - 1] & 127) && (ie <= 1 || !(B[ie - 2] & 128)))
    throw new Error("Non-minimally encoded script number");
  if (ie === 5) {
    const ne = B.readUInt32LE(0), ae = B.readUInt8(4);
    return ae & 128 ? -((ae & -129) * 4294967296 + ne) : ae * 4294967296 + ne;
  }
  let se = 0;
  for (let ne = 0; ne < ie; ++ne)
    se |= B[ne] << 8 * ne;
  return B[ie - 1] & 128 ? -(se & ~(128 << 8 * (ie - 1))) : se;
}
script_number.decode = decode$f;
function scriptNumSize(B) {
  return B > 2147483647 ? 5 : B > 8388607 ? 4 : B > 32767 ? 3 : B > 127 ? 2 : B > 0 ? 1 : 0;
}
function encode$g(B) {
  let z = Math.abs(B);
  const Y = scriptNumSize(z), ie = Buffer$1.allocUnsafe(Y), se = B < 0;
  for (let ne = 0; ne < Y; ++ne)
    ie.writeUInt8(z & 255, ne), z >>= 8;
  return ie[Y - 1] & 128 ? ie.writeUInt8(se ? 128 : 0, Y - 1) : se && (ie[Y - 1] |= 128), ie;
}
script_number.encode = encode$g;
var script_signature = {}, types$4 = {}, types$3 = {
  Array: function(B) {
    return B != null && B.constructor === Array;
  },
  Boolean: function(B) {
    return typeof B == "boolean";
  },
  Function: function(B) {
    return typeof B == "function";
  },
  Nil: function(B) {
    return B == null;
  },
  Number: function(B) {
    return typeof B == "number";
  },
  Object: function(B) {
    return typeof B == "object";
  },
  String: function(B) {
    return typeof B == "string";
  },
  "": function() {
    return !0;
  }
};
types$3.Null = types$3.Nil;
for (var typeName$1 in types$3)
  types$3[typeName$1].toJSON = (function(B) {
    return B;
  }).bind(null, typeName$1);
var native$1 = types$3, native = native$1;
function getTypeName(B) {
  return B.name || B.toString().match(/function (.*?)\s*\(/)[1];
}
function getValueTypeName$1(B) {
  return native.Nil(B) ? "" : getTypeName(B.constructor);
}
function getValue(B) {
  return native.Function(B) ? "" : native.String(B) ? JSON.stringify(B) : B && native.Object(B) ? "" : B;
}
function captureStackTrace(B, z) {
  Error.captureStackTrace && Error.captureStackTrace(B, z);
}
function tfJSON$1(B) {
  return native.Function(B) ? B.toJSON ? B.toJSON() : getTypeName(B) : native.Array(B) ? "Array" : B && native.Object(B) ? "Object" : B !== void 0 ? B : "";
}
function tfErrorString(B, z, Y) {
  var ie = getValue(z);
  return "Expected " + tfJSON$1(B) + ", got" + (Y !== "" ? " " + Y : "") + (ie !== "" ? " " + ie : "");
}
function TfTypeError$1(B, z, Y) {
  Y = Y || getValueTypeName$1(z), this.message = tfErrorString(B, z, Y), captureStackTrace(this, TfTypeError$1), this.__type = B, this.__value = z, this.__valueTypeName = Y;
}
TfTypeError$1.prototype = Object.create(Error.prototype);
TfTypeError$1.prototype.constructor = TfTypeError$1;
function tfPropertyErrorString(B, z, Y, ie, se) {
  var ne = '" of type ';
  return z === "key" && (ne = '" with key type '), tfErrorString('property "' + tfJSON$1(Y) + ne + tfJSON$1(B), ie, se);
}
function TfPropertyTypeError$1(B, z, Y, ie, se) {
  B ? (se = se || getValueTypeName$1(ie), this.message = tfPropertyErrorString(B, Y, z, ie, se)) : this.message = 'Unexpected property "' + z + '"', captureStackTrace(this, TfTypeError$1), this.__label = Y, this.__property = z, this.__type = B, this.__value = ie, this.__valueTypeName = se;
}
TfPropertyTypeError$1.prototype = Object.create(Error.prototype);
TfPropertyTypeError$1.prototype.constructor = TfTypeError$1;
function tfCustomError(B, z) {
  return new TfTypeError$1(B, {}, z);
}
function tfSubError$1(B, z, Y) {
  return B instanceof TfPropertyTypeError$1 ? (z = z + "." + B.__property, B = new TfPropertyTypeError$1(
    B.__type,
    z,
    B.__label,
    B.__value,
    B.__valueTypeName
  )) : B instanceof TfTypeError$1 && (B = new TfPropertyTypeError$1(
    B.__type,
    z,
    Y,
    B.__value,
    B.__valueTypeName
  )), captureStackTrace(B), B;
}
var errors = {
  TfTypeError: TfTypeError$1,
  TfPropertyTypeError: TfPropertyTypeError$1,
  tfCustomError,
  tfSubError: tfSubError$1,
  tfJSON: tfJSON$1,
  getValueTypeName: getValueTypeName$1
}, extra, hasRequiredExtra;
function requireExtra() {
  if (hasRequiredExtra) return extra;
  hasRequiredExtra = 1;
  var B = native$1, z = errors;
  function Y(Ht) {
    return Buffer$1.isBuffer(Ht);
  }
  function ie(Ht) {
    return typeof Ht == "string" && /^([0-9a-f]{2})+$/i.test(Ht);
  }
  function se(Ht, Yt) {
    var Ut = Ht.toJSON();
    function Nt(Kt) {
      if (!Ht(Kt)) return !1;
      if (Kt.length === Yt) return !0;
      throw z.tfCustomError(Ut + "(Length: " + Yt + ")", Ut + "(Length: " + Kt.length + ")");
    }
    return Nt.toJSON = function() {
      return Ut;
    }, Nt;
  }
  var ne = se.bind(null, B.Array), ae = se.bind(null, Y), le = se.bind(null, ie), ge = se.bind(null, B.String);
  function Ee(Ht, Yt, Ut) {
    Ut = Ut || B.Number;
    function Nt(Kt, Ft) {
      return Ut(Kt, Ft) && Kt > Ht && Kt < Yt;
    }
    return Nt.toJSON = function() {
      return `${Ut.toJSON()} between [${Ht}, ${Yt}]`;
    }, Nt;
  }
  var oe = Math.pow(2, 53) - 1;
  function Pe(Ht) {
    return typeof Ht == "number" && isFinite(Ht);
  }
  function Ve(Ht) {
    return Ht << 24 >> 24 === Ht;
  }
  function Ke(Ht) {
    return Ht << 16 >> 16 === Ht;
  }
  function ht(Ht) {
    return (Ht | 0) === Ht;
  }
  function _t(Ht) {
    return typeof Ht == "number" && Ht >= -oe && Ht <= oe && Math.floor(Ht) === Ht;
  }
  function Rt(Ht) {
    return (Ht & 255) === Ht;
  }
  function kt(Ht) {
    return (Ht & 65535) === Ht;
  }
  function Bt(Ht) {
    return Ht >>> 0 === Ht;
  }
  function Ct(Ht) {
    return typeof Ht == "number" && Ht >= 0 && Ht <= oe && Math.floor(Ht) === Ht;
  }
  var qt = {
    ArrayN: ne,
    Buffer: Y,
    BufferN: ae,
    Finite: Pe,
    Hex: ie,
    HexN: le,
    Int8: Ve,
    Int16: Ke,
    Int32: ht,
    Int53: _t,
    Range: Ee,
    StringN: ge,
    UInt8: Rt,
    UInt16: kt,
    UInt32: Bt,
    UInt53: Ct
  };
  for (var jt in qt)
    qt[jt].toJSON = (function(Ht) {
      return Ht;
    }).bind(null, jt);
  return extra = qt, extra;
}
var ERRORS = errors, NATIVE = native$1, tfJSON = ERRORS.tfJSON, TfTypeError = ERRORS.TfTypeError, TfPropertyTypeError = ERRORS.TfPropertyTypeError, tfSubError = ERRORS.tfSubError, getValueTypeName = ERRORS.getValueTypeName, TYPES = {
  arrayOf: function B(z, Y) {
    z = compile(z), Y = Y || {};
    function ie(se, ne) {
      return !NATIVE.Array(se) || NATIVE.Nil(se) || Y.minLength !== void 0 && se.length < Y.minLength || Y.maxLength !== void 0 && se.length > Y.maxLength || Y.length !== void 0 && se.length !== Y.length ? !1 : se.every(function(ae, le) {
        try {
          return typeforce$3(z, ae, ne);
        } catch (ge) {
          throw tfSubError(ge, le);
        }
      });
    }
    return ie.toJSON = function() {
      var se = "[" + tfJSON(z) + "]";
      return Y.length !== void 0 ? se += "{" + Y.length + "}" : (Y.minLength !== void 0 || Y.maxLength !== void 0) && (se += "{" + (Y.minLength === void 0 ? 0 : Y.minLength) + "," + (Y.maxLength === void 0 ? 1 / 0 : Y.maxLength) + "}"), se;
    }, ie;
  },
  maybe: function B(z) {
    z = compile(z);
    function Y(ie, se) {
      return NATIVE.Nil(ie) || z(ie, se, B);
    }
    return Y.toJSON = function() {
      return "?" + tfJSON(z);
    }, Y;
  },
  map: function B(z, Y) {
    z = compile(z), Y && (Y = compile(Y));
    function ie(se, ne) {
      if (!NATIVE.Object(se) || NATIVE.Nil(se)) return !1;
      for (var ae in se) {
        try {
          Y && typeforce$3(Y, ae, ne);
        } catch (ge) {
          throw tfSubError(ge, ae, "key");
        }
        try {
          var le = se[ae];
          typeforce$3(z, le, ne);
        } catch (ge) {
          throw tfSubError(ge, ae);
        }
      }
      return !0;
    }
    return Y ? ie.toJSON = function() {
      return "{" + tfJSON(Y) + ": " + tfJSON(z) + "}";
    } : ie.toJSON = function() {
      return "{" + tfJSON(z) + "}";
    }, ie;
  },
  object: function B(z) {
    var Y = {};
    for (var ie in z)
      Y[ie] = compile(z[ie]);
    function se(ne, ae) {
      if (!NATIVE.Object(ne) || NATIVE.Nil(ne)) return !1;
      var le;
      try {
        for (le in Y) {
          var ge = Y[le], Ee = ne[le];
          typeforce$3(ge, Ee, ae);
        }
      } catch (oe) {
        throw tfSubError(oe, le);
      }
      if (ae) {
        for (le in ne)
          if (!Y[le])
            throw new TfPropertyTypeError(void 0, le);
      }
      return !0;
    }
    return se.toJSON = function() {
      return tfJSON(Y);
    }, se;
  },
  anyOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ie, se) {
      return z.some(function(ne) {
        try {
          return typeforce$3(ne, ie, se);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join("|");
    }, Y;
  },
  allOf: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ie, se) {
      return z.every(function(ne) {
        try {
          return typeforce$3(ne, ie, se);
        } catch {
          return !1;
        }
      });
    }
    return Y.toJSON = function() {
      return z.map(tfJSON).join(" & ");
    }, Y;
  },
  quacksLike: function B(z) {
    function Y(ie) {
      return z === getValueTypeName(ie);
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  },
  tuple: function B() {
    var z = [].slice.call(arguments).map(compile);
    function Y(ie, se) {
      return NATIVE.Nil(ie) || NATIVE.Nil(ie.length) || se && ie.length !== z.length ? !1 : z.every(function(ne, ae) {
        try {
          return typeforce$3(ne, ie[ae], se);
        } catch (le) {
          throw tfSubError(le, ae);
        }
      });
    }
    return Y.toJSON = function() {
      return "(" + z.map(tfJSON).join(", ") + ")";
    }, Y;
  },
  value: function B(z) {
    function Y(ie) {
      return ie === z;
    }
    return Y.toJSON = function() {
      return z;
    }, Y;
  }
};
TYPES.oneOf = TYPES.anyOf;
function compile(B) {
  if (NATIVE.String(B))
    return B[0] === "?" ? TYPES.maybe(B.slice(1)) : NATIVE[B] || TYPES.quacksLike(B);
  if (B && NATIVE.Object(B)) {
    if (NATIVE.Array(B)) {
      if (B.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return TYPES.arrayOf(B[0]);
    }
    return TYPES.object(B);
  } else if (NATIVE.Function(B))
    return B;
  return TYPES.value(B);
}
function typeforce$3(B, z, Y, ie) {
  if (NATIVE.Function(B)) {
    if (B(z, Y)) return !0;
    throw new TfTypeError(ie || B, z);
  }
  return typeforce$3(compile(B), z, Y);
}
for (var typeName in NATIVE)
  typeforce$3[typeName] = NATIVE[typeName];
for (typeName in TYPES)
  typeforce$3[typeName] = TYPES[typeName];
var EXTRA = requireExtra();
for (typeName in EXTRA)
  typeforce$3[typeName] = EXTRA[typeName];
typeforce$3.compile = compile;
typeforce$3.TfTypeError = TfTypeError;
typeforce$3.TfPropertyTypeError = TfPropertyTypeError;
var typeforce_1 = typeforce$3;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.oneOf = B.Null = B.BufferN = B.Function = B.UInt32 = B.UInt8 = B.tuple = B.maybe = B.Hex = B.Buffer = B.String = B.Boolean = B.Array = B.Number = B.Hash256bit = B.Hash160bit = B.Buffer256bit = B.isTaptree = B.isTapleaf = B.TAPLEAF_VERSION_MASK = B.Satoshi = B.isPoint = B.stacksEqual = B.typeforce = void 0;
  const z = require$$0$1;
  B.typeforce = typeforce_1;
  const Y = z.Buffer.alloc(32, 0), ie = z.Buffer.from(
    "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
    "hex"
  );
  function se(oe, Pe) {
    return oe.length !== Pe.length ? !1 : oe.every((Ve, Ke) => Ve.equals(Pe[Ke]));
  }
  B.stacksEqual = se;
  function ne(oe) {
    if (!z.Buffer.isBuffer(oe) || oe.length < 33) return !1;
    const Pe = oe[0], Ve = oe.slice(1, 33);
    if (Ve.compare(Y) === 0 || Ve.compare(ie) >= 0) return !1;
    if ((Pe === 2 || Pe === 3) && oe.length === 33)
      return !0;
    const Ke = oe.slice(33);
    return Ke.compare(Y) === 0 || Ke.compare(ie) >= 0 ? !1 : Pe === 4 && oe.length === 65;
  }
  B.isPoint = ne;
  const ae = 21 * 1e14;
  function le(oe) {
    return B.typeforce.UInt53(oe) && oe <= ae;
  }
  B.Satoshi = le, B.TAPLEAF_VERSION_MASK = 254;
  function ge(oe) {
    return !oe || !("output" in oe) || !z.Buffer.isBuffer(oe.output) ? !1 : oe.version !== void 0 ? (oe.version & B.TAPLEAF_VERSION_MASK) === oe.version : !0;
  }
  B.isTapleaf = ge;
  function Ee(oe) {
    return (0, B.Array)(oe) ? oe.length !== 2 ? !1 : oe.every((Pe) => Ee(Pe)) : ge(oe);
  }
  B.isTaptree = Ee, B.Buffer256bit = B.typeforce.BufferN(32), B.Hash160bit = B.typeforce.BufferN(20), B.Hash256bit = B.typeforce.BufferN(32), B.Number = B.typeforce.Number, B.Array = B.typeforce.Array, B.Boolean = B.typeforce.Boolean, B.String = B.typeforce.String, B.Buffer = B.typeforce.Buffer, B.Hex = B.typeforce.Hex, B.maybe = B.typeforce.maybe, B.tuple = B.typeforce.tuple, B.UInt8 = B.typeforce.UInt8, B.UInt32 = B.typeforce.UInt32, B.Function = B.typeforce.Function, B.BufferN = B.typeforce.BufferN, B.Null = B.typeforce.Null, B.oneOf = B.typeforce.oneOf;
})(types$4);
var hasRequiredScript_signature;
function requireScript_signature() {
  if (hasRequiredScript_signature) return script_signature;
  hasRequiredScript_signature = 1, Object.defineProperty(script_signature, "__esModule", { value: !0 }), script_signature.encode = script_signature.decode = void 0;
  const B = bip66, z = requireScript(), Y = types$4, { typeforce: ie } = Y, se = Buffer$1.alloc(1, 0);
  function ne(Ee) {
    let oe = 0;
    for (; Ee[oe] === 0; ) ++oe;
    return oe === Ee.length ? se : (Ee = Ee.slice(oe), Ee[0] & 128 ? Buffer$1.concat([se, Ee], 1 + Ee.length) : Ee);
  }
  function ae(Ee) {
    Ee[0] === 0 && (Ee = Ee.slice(1));
    const oe = Buffer$1.alloc(32, 0), Pe = Math.max(0, 32 - Ee.length);
    return Ee.copy(oe, Pe), oe;
  }
  function le(Ee) {
    const oe = Ee.readUInt8(Ee.length - 1);
    if (!(0, z.isDefinedHashType)(oe))
      throw new Error("Invalid hashType " + oe);
    const Pe = B.decode(Ee.slice(0, -1)), Ve = ae(Pe.r), Ke = ae(Pe.s);
    return { signature: Buffer$1.concat([Ve, Ke], 64), hashType: oe };
  }
  script_signature.decode = le;
  function ge(Ee, oe) {
    if (ie(
      {
        signature: Y.BufferN(64),
        hashType: Y.UInt8
      },
      { signature: Ee, hashType: oe }
    ), !(0, z.isDefinedHashType)(oe))
      throw new Error("Invalid hashType " + oe);
    const Pe = Buffer$1.allocUnsafe(1);
    Pe.writeUInt8(oe, 0);
    const Ve = ne(Ee.slice(0, 32)), Ke = ne(Ee.slice(32, 64));
    return Buffer$1.concat([B.encode(Ve, Ke), Pe]);
  }
  return script_signature.encode = ge, script_signature;
}
var hasRequiredScript;
function requireScript() {
  return hasRequiredScript || (hasRequiredScript = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.signature = B.number = B.isCanonicalScriptSignature = B.isDefinedHashType = B.isCanonicalPubKey = B.toStack = B.fromASM = B.toASM = B.decompile = B.compile = B.countNonPushOnlyOPs = B.isPushOnly = B.OPS = void 0;
    const z = bip66, Y = ops;
    Object.defineProperty(B, "OPS", {
      enumerable: !0,
      get: function() {
        return Y.OPS;
      }
    });
    const ie = push_data, se = script_number, ne = requireScript_signature(), ae = types$4, { typeforce: le } = ae, ge = Y.OPS.OP_RESERVED;
    function Ee(Nt) {
      return ae.Number(Nt) && (Nt === Y.OPS.OP_0 || Nt >= Y.OPS.OP_1 && Nt <= Y.OPS.OP_16 || Nt === Y.OPS.OP_1NEGATE);
    }
    function oe(Nt) {
      return ae.Buffer(Nt) || Ee(Nt);
    }
    function Pe(Nt) {
      return ae.Array(Nt) && Nt.every(oe);
    }
    B.isPushOnly = Pe;
    function Ve(Nt) {
      return Nt.length - Nt.filter(oe).length;
    }
    B.countNonPushOnlyOPs = Ve;
    function Ke(Nt) {
      if (Nt.length === 0) return Y.OPS.OP_0;
      if (Nt.length === 1) {
        if (Nt[0] >= 1 && Nt[0] <= 16) return ge + Nt[0];
        if (Nt[0] === 129) return Y.OPS.OP_1NEGATE;
      }
    }
    function ht(Nt) {
      return Buffer$1.isBuffer(Nt);
    }
    function _t(Nt) {
      return ae.Array(Nt);
    }
    function Rt(Nt) {
      return Buffer$1.isBuffer(Nt);
    }
    function kt(Nt) {
      if (ht(Nt)) return Nt;
      le(ae.Array, Nt);
      const Kt = Nt.reduce((Xe, ve) => Rt(ve) ? ve.length === 1 && Ke(ve) !== void 0 ? Xe + 1 : Xe + ie.encodingLength(ve.length) + ve.length : Xe + 1, 0), Ft = Buffer$1.allocUnsafe(Kt);
      let bt = 0;
      if (Nt.forEach((Xe) => {
        if (Rt(Xe)) {
          const ve = Ke(Xe);
          if (ve !== void 0) {
            Ft.writeUInt8(ve, bt), bt += 1;
            return;
          }
          bt += ie.encode(Ft, Xe.length, bt), Xe.copy(Ft, bt), bt += Xe.length;
        } else
          Ft.writeUInt8(Xe, bt), bt += 1;
      }), bt !== Ft.length) throw new Error("Could not decode chunks");
      return Ft;
    }
    B.compile = kt;
    function Bt(Nt) {
      if (_t(Nt)) return Nt;
      le(ae.Buffer, Nt);
      const Kt = [];
      let Ft = 0;
      for (; Ft < Nt.length; ) {
        const bt = Nt[Ft];
        if (bt > Y.OPS.OP_0 && bt <= Y.OPS.OP_PUSHDATA4) {
          const Xe = ie.decode(Nt, Ft);
          if (Xe === null || (Ft += Xe.size, Ft + Xe.number > Nt.length)) return null;
          const ve = Nt.slice(Ft, Ft + Xe.number);
          Ft += Xe.number;
          const Ce = Ke(ve);
          Ce !== void 0 ? Kt.push(Ce) : Kt.push(ve);
        } else
          Kt.push(bt), Ft += 1;
      }
      return Kt;
    }
    B.decompile = Bt;
    function Ct(Nt) {
      if (ht(Nt) && (Nt = Bt(Nt)), !Nt)
        throw new Error("Could not convert invalid chunks to ASM");
      return Nt.map((Kt) => {
        if (Rt(Kt)) {
          const Ft = Ke(Kt);
          if (Ft === void 0) return Kt.toString("hex");
          Kt = Ft;
        }
        return Y.REVERSE_OPS[Kt];
      }).join(" ");
    }
    B.toASM = Ct;
    function qt(Nt) {
      return le(ae.String, Nt), kt(
        Nt.split(" ").map((Kt) => Y.OPS[Kt] !== void 0 ? Y.OPS[Kt] : (le(ae.Hex, Kt), Buffer$1.from(Kt, "hex")))
      );
    }
    B.fromASM = qt;
    function jt(Nt) {
      return Nt = Bt(Nt), le(Pe, Nt), Nt.map((Kt) => Rt(Kt) ? Kt : Kt === Y.OPS.OP_0 ? Buffer$1.allocUnsafe(0) : se.encode(Kt - ge));
    }
    B.toStack = jt;
    function Ht(Nt) {
      return ae.isPoint(Nt);
    }
    B.isCanonicalPubKey = Ht;
    function Yt(Nt) {
      const Kt = Nt & -129;
      return Kt > 0 && Kt < 4;
    }
    B.isDefinedHashType = Yt;
    function Ut(Nt) {
      return !Buffer$1.isBuffer(Nt) || !Yt(Nt[Nt.length - 1]) ? !1 : z.check(Nt.slice(0, -1));
    }
    B.isCanonicalScriptSignature = Ut, B.number = se, B.signature = ne;
  }(script)), script;
}
var lazy$7 = {};
Object.defineProperty(lazy$7, "__esModule", { value: !0 });
lazy$7.value = lazy$7.prop = void 0;
function prop(B, z, Y) {
  Object.defineProperty(B, z, {
    configurable: !0,
    enumerable: !0,
    get() {
      const ie = Y.call(this);
      return this[z] = ie, ie;
    },
    set(ie) {
      Object.defineProperty(this, z, {
        configurable: !0,
        enumerable: !0,
        value: ie,
        writable: !0
      });
    }
  });
}
lazy$7.prop = prop;
function value(B) {
  let z;
  return () => (z !== void 0 || (z = B()), z);
}
lazy$7.value = value;
Object.defineProperty(embed, "__esModule", { value: !0 });
embed.p2data = void 0;
const networks_1$7 = networks, bscript$9 = requireScript(), types_1$7 = types$4, lazy$6 = lazy$7, OPS$6 = bscript$9.OPS;
function p2data(B, z) {
  if (!B.data && !B.output) throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$7.typeforce)(
    {
      network: types_1$7.typeforce.maybe(types_1$7.typeforce.Object),
      output: types_1$7.typeforce.maybe(types_1$7.typeforce.Buffer),
      data: types_1$7.typeforce.maybe(
        types_1$7.typeforce.arrayOf(types_1$7.typeforce.Buffer)
      )
    },
    B
  );
  const ie = { name: "embed", network: B.network || networks_1$7.bitcoin };
  if (lazy$6.prop(ie, "output", () => {
    if (B.data)
      return bscript$9.compile([OPS$6.OP_RETURN].concat(B.data));
  }), lazy$6.prop(ie, "data", () => {
    if (B.output)
      return bscript$9.decompile(B.output).slice(1);
  }), z.validate && B.output) {
    const se = bscript$9.decompile(B.output);
    if (se[0] !== OPS$6.OP_RETURN) throw new TypeError("Output is invalid");
    if (!se.slice(1).every(types_1$7.typeforce.Buffer))
      throw new TypeError("Output is invalid");
    if (B.data && !(0, types_1$7.stacksEqual)(B.data, ie.data))
      throw new TypeError("Data mismatch");
  }
  return Object.assign(ie, B);
}
embed.p2data = p2data;
var p2ms$1 = {};
Object.defineProperty(p2ms$1, "__esModule", { value: !0 });
p2ms$1.p2ms = void 0;
const networks_1$6 = networks, bscript$8 = requireScript(), types_1$6 = types$4, lazy$5 = lazy$7, OPS$5 = bscript$8.OPS, OP_INT_BASE = OPS$5.OP_RESERVED;
function p2ms(B, z) {
  if (!B.input && !B.output && !(B.pubkeys && B.m !== void 0) && !B.signatures)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {});
  function Y(ge) {
    return bscript$8.isCanonicalScriptSignature(ge) || (z.allowIncomplete && ge === OPS$5.OP_0) !== void 0;
  }
  (0, types_1$6.typeforce)(
    {
      network: types_1$6.typeforce.maybe(types_1$6.typeforce.Object),
      m: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      n: types_1$6.typeforce.maybe(types_1$6.typeforce.Number),
      output: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer),
      pubkeys: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(types_1$6.isPoint)
      ),
      signatures: types_1$6.typeforce.maybe(
        types_1$6.typeforce.arrayOf(Y)
      ),
      input: types_1$6.typeforce.maybe(types_1$6.typeforce.Buffer)
    },
    B
  );
  const se = { network: B.network || networks_1$6.bitcoin };
  let ne = [], ae = !1;
  function le(ge) {
    ae || (ae = !0, ne = bscript$8.decompile(ge), se.m = ne[0] - OP_INT_BASE, se.n = ne[ne.length - 2] - OP_INT_BASE, se.pubkeys = ne.slice(1, -2));
  }
  if (lazy$5.prop(se, "output", () => {
    if (B.m && se.n && B.pubkeys)
      return bscript$8.compile(
        [].concat(
          OP_INT_BASE + B.m,
          B.pubkeys,
          OP_INT_BASE + se.n,
          OPS$5.OP_CHECKMULTISIG
        )
      );
  }), lazy$5.prop(se, "m", () => {
    if (se.output)
      return le(se.output), se.m;
  }), lazy$5.prop(se, "n", () => {
    if (se.pubkeys)
      return se.pubkeys.length;
  }), lazy$5.prop(se, "pubkeys", () => {
    if (B.output)
      return le(B.output), se.pubkeys;
  }), lazy$5.prop(se, "signatures", () => {
    if (B.input)
      return bscript$8.decompile(B.input).slice(1);
  }), lazy$5.prop(se, "input", () => {
    if (B.signatures)
      return bscript$8.compile([OPS$5.OP_0].concat(B.signatures));
  }), lazy$5.prop(se, "witness", () => {
    if (se.input)
      return [];
  }), lazy$5.prop(se, "name", () => {
    if (!(!se.m || !se.n))
      return `p2ms(${se.m} of ${se.n})`;
  }), z.validate) {
    if (B.output) {
      if (le(B.output), !types_1$6.typeforce.Number(ne[0]))
        throw new TypeError("Output is invalid");
      if (!types_1$6.typeforce.Number(ne[ne.length - 2]))
        throw new TypeError("Output is invalid");
      if (ne[ne.length - 1] !== OPS$5.OP_CHECKMULTISIG)
        throw new TypeError("Output is invalid");
      if (se.m <= 0 || se.n > 16 || se.m > se.n || se.n !== ne.length - 3)
        throw new TypeError("Output is invalid");
      if (!se.pubkeys.every((ge) => (0, types_1$6.isPoint)(ge)))
        throw new TypeError("Output is invalid");
      if (B.m !== void 0 && B.m !== se.m) throw new TypeError("m mismatch");
      if (B.n !== void 0 && B.n !== se.n) throw new TypeError("n mismatch");
      if (B.pubkeys && !(0, types_1$6.stacksEqual)(B.pubkeys, se.pubkeys))
        throw new TypeError("Pubkeys mismatch");
    }
    if (B.pubkeys) {
      if (B.n !== void 0 && B.n !== B.pubkeys.length)
        throw new TypeError("Pubkey count mismatch");
      if (se.n = B.pubkeys.length, se.n < se.m) throw new TypeError("Pubkey count cannot be less than m");
    }
    if (B.signatures) {
      if (B.signatures.length < se.m)
        throw new TypeError("Not enough signatures provided");
      if (B.signatures.length > se.m)
        throw new TypeError("Too many signatures provided");
    }
    if (B.input) {
      if (B.input[0] !== OPS$5.OP_0) throw new TypeError("Input is invalid");
      if (se.signatures.length === 0 || !se.signatures.every(Y))
        throw new TypeError("Input has invalid signature(s)");
      if (B.signatures && !(0, types_1$6.stacksEqual)(B.signatures, se.signatures))
        throw new TypeError("Signature mismatch");
      if (B.m !== void 0 && B.m !== B.signatures.length)
        throw new TypeError("Signature count mismatch");
    }
  }
  return Object.assign(se, B);
}
p2ms$1.p2ms = p2ms;
var p2pk$1 = {};
Object.defineProperty(p2pk$1, "__esModule", { value: !0 });
p2pk$1.p2pk = void 0;
const networks_1$5 = networks, bscript$7 = requireScript(), types_1$5 = types$4, lazy$4 = lazy$7, OPS$4 = bscript$7.OPS;
function p2pk(B, z) {
  if (!B.input && !B.output && !B.pubkey && !B.input && !B.signature)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$5.typeforce)(
    {
      network: types_1$5.typeforce.maybe(types_1$5.typeforce.Object),
      output: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer),
      pubkey: types_1$5.typeforce.maybe(types_1$5.isPoint),
      signature: types_1$5.typeforce.maybe(bscript$7.isCanonicalScriptSignature),
      input: types_1$5.typeforce.maybe(types_1$5.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$4.value(() => bscript$7.decompile(B.input)), se = { name: "p2pk", network: B.network || networks_1$5.bitcoin };
  if (lazy$4.prop(se, "output", () => {
    if (B.pubkey)
      return bscript$7.compile([B.pubkey, OPS$4.OP_CHECKSIG]);
  }), lazy$4.prop(se, "pubkey", () => {
    if (B.output)
      return B.output.slice(1, -1);
  }), lazy$4.prop(se, "signature", () => {
    if (B.input)
      return Y()[0];
  }), lazy$4.prop(se, "input", () => {
    if (B.signature)
      return bscript$7.compile([B.signature]);
  }), lazy$4.prop(se, "witness", () => {
    if (se.input)
      return [];
  }), z.validate) {
    if (B.output) {
      if (B.output[B.output.length - 1] !== OPS$4.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      if (!(0, types_1$5.isPoint)(se.pubkey))
        throw new TypeError("Output pubkey is invalid");
      if (B.pubkey && !B.pubkey.equals(se.pubkey))
        throw new TypeError("Pubkey mismatch");
    }
    if (B.signature && B.input && !B.input.equals(se.input))
      throw new TypeError("Signature mismatch");
    if (B.input) {
      if (Y().length !== 1) throw new TypeError("Input is invalid");
      if (!bscript$7.isCanonicalScriptSignature(se.signature))
        throw new TypeError("Input has invalid signature");
    }
  }
  return Object.assign(se, B);
}
p2pk$1.p2pk = p2pk;
var p2pkh$1 = {}, crypto$1 = {}, ripemd160 = {};
Object.defineProperty(ripemd160, "__esModule", { value: !0 });
ripemd160.ripemd160 = ripemd160.RIPEMD160 = void 0;
const _md_js_1$1 = _md, utils_js_1$1 = utils$5, Rho = /* @__PURE__ */ new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]), Id = /* @__PURE__ */ new Uint8Array(new Array(16).fill(0).map((B, z) => z)), Pi = /* @__PURE__ */ Id.map((B) => (9 * B + 5) % 16);
let idxL = [Id], idxR = [Pi];
for (let B = 0; B < 4; B++)
  for (let z of [idxL, idxR])
    z.push(z[B].map((Y) => Rho[Y]));
const shifts = /* @__PURE__ */ [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((B) => new Uint8Array(B)), shiftsL = /* @__PURE__ */ idxL.map((B, z) => B.map((Y) => shifts[z][Y])), shiftsR = /* @__PURE__ */ idxR.map((B, z) => B.map((Y) => shifts[z][Y])), Kl = /* @__PURE__ */ new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]), Kr = /* @__PURE__ */ new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(B, z, Y, ie) {
  return B === 0 ? z ^ Y ^ ie : B === 1 ? z & Y | ~z & ie : B === 2 ? (z | ~Y) ^ ie : B === 3 ? z & ie | Y & ~ie : z ^ (Y | ~ie);
}
const R_BUF = /* @__PURE__ */ new Uint32Array(16);
class RIPEMD160 extends _md_js_1$1.HashMD {
  constructor() {
    super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: z, h1: Y, h2: ie, h3: se, h4: ne } = this;
    return [z, Y, ie, se, ne];
  }
  set(z, Y, ie, se, ne) {
    this.h0 = z | 0, this.h1 = Y | 0, this.h2 = ie | 0, this.h3 = se | 0, this.h4 = ne | 0;
  }
  process(z, Y) {
    for (let Ke = 0; Ke < 16; Ke++, Y += 4)
      R_BUF[Ke] = z.getUint32(Y, !0);
    let ie = this.h0 | 0, se = ie, ne = this.h1 | 0, ae = ne, le = this.h2 | 0, ge = le, Ee = this.h3 | 0, oe = Ee, Pe = this.h4 | 0, Ve = Pe;
    for (let Ke = 0; Ke < 5; Ke++) {
      const ht = 4 - Ke, _t = Kl[Ke], Rt = Kr[Ke], kt = idxL[Ke], Bt = idxR[Ke], Ct = shiftsL[Ke], qt = shiftsR[Ke];
      for (let jt = 0; jt < 16; jt++) {
        const Ht = (0, utils_js_1$1.rotl)(ie + f(Ke, ne, le, Ee) + R_BUF[kt[jt]] + _t, Ct[jt]) + Pe | 0;
        ie = Pe, Pe = Ee, Ee = (0, utils_js_1$1.rotl)(le, 10) | 0, le = ne, ne = Ht;
      }
      for (let jt = 0; jt < 16; jt++) {
        const Ht = (0, utils_js_1$1.rotl)(se + f(ht, ae, ge, oe) + R_BUF[Bt[jt]] + Rt, qt[jt]) + Ve | 0;
        se = Ve, Ve = oe, oe = (0, utils_js_1$1.rotl)(ge, 10) | 0, ge = ae, ae = Ht;
      }
    }
    this.set(this.h1 + le + oe | 0, this.h2 + Ee + Ve | 0, this.h3 + Pe + se | 0, this.h4 + ie + ae | 0, this.h0 + ne + ge | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
}
ripemd160.RIPEMD160 = RIPEMD160;
ripemd160.ripemd160 = (0, utils_js_1$1.wrapConstructor)(() => new RIPEMD160());
var sha1 = {};
Object.defineProperty(sha1, "__esModule", { value: !0 });
sha1.sha1 = sha1.SHA1 = void 0;
const _md_js_1 = _md, utils_js_1 = utils$5, SHA1_IV = /* @__PURE__ */ new Uint32Array([
  1732584193,
  4023233417,
  2562383102,
  271733878,
  3285377520
]), SHA1_W = /* @__PURE__ */ new Uint32Array(80);
class SHA1 extends _md_js_1.HashMD {
  constructor() {
    super(64, 20, 8, !1), this.A = SHA1_IV[0] | 0, this.B = SHA1_IV[1] | 0, this.C = SHA1_IV[2] | 0, this.D = SHA1_IV[3] | 0, this.E = SHA1_IV[4] | 0;
  }
  get() {
    const { A: z, B: Y, C: ie, D: se, E: ne } = this;
    return [z, Y, ie, se, ne];
  }
  set(z, Y, ie, se, ne) {
    this.A = z | 0, this.B = Y | 0, this.C = ie | 0, this.D = se | 0, this.E = ne | 0;
  }
  process(z, Y) {
    for (let ge = 0; ge < 16; ge++, Y += 4)
      SHA1_W[ge] = z.getUint32(Y, !1);
    for (let ge = 16; ge < 80; ge++)
      SHA1_W[ge] = (0, utils_js_1.rotl)(SHA1_W[ge - 3] ^ SHA1_W[ge - 8] ^ SHA1_W[ge - 14] ^ SHA1_W[ge - 16], 1);
    let { A: ie, B: se, C: ne, D: ae, E: le } = this;
    for (let ge = 0; ge < 80; ge++) {
      let Ee, oe;
      ge < 20 ? (Ee = (0, _md_js_1.Chi)(se, ne, ae), oe = 1518500249) : ge < 40 ? (Ee = se ^ ne ^ ae, oe = 1859775393) : ge < 60 ? (Ee = (0, _md_js_1.Maj)(se, ne, ae), oe = 2400959708) : (Ee = se ^ ne ^ ae, oe = 3395469782);
      const Pe = (0, utils_js_1.rotl)(ie, 5) + Ee + le + oe + SHA1_W[ge] | 0;
      le = ae, ae = ne, ne = (0, utils_js_1.rotl)(se, 30), se = ie, ie = Pe;
    }
    ie = ie + this.A | 0, se = se + this.B | 0, ne = ne + this.C | 0, ae = ae + this.D | 0, le = le + this.E | 0, this.set(ie, se, ne, ae, le);
  }
  roundClean() {
    SHA1_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
sha1.SHA1 = SHA1;
sha1.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.taggedHash = B.TAGGED_HASH_PREFIXES = B.TAGS = B.hash256 = B.hash160 = B.sha256 = B.sha1 = B.ripemd160 = void 0;
  const z = ripemd160, Y = sha1, ie = sha256$4;
  function se(oe) {
    return Buffer$1.from((0, z.ripemd160)(Uint8Array.from(oe)));
  }
  B.ripemd160 = se;
  function ne(oe) {
    return Buffer$1.from((0, Y.sha1)(Uint8Array.from(oe)));
  }
  B.sha1 = ne;
  function ae(oe) {
    return Buffer$1.from((0, ie.sha256)(Uint8Array.from(oe)));
  }
  B.sha256 = ae;
  function le(oe) {
    return Buffer$1.from(
      (0, z.ripemd160)((0, ie.sha256)(Uint8Array.from(oe)))
    );
  }
  B.hash160 = le;
  function ge(oe) {
    return Buffer$1.from(
      (0, ie.sha256)((0, ie.sha256)(Uint8Array.from(oe)))
    );
  }
  B.hash256 = ge, B.TAGS = [
    "BIP0340/challenge",
    "BIP0340/aux",
    "BIP0340/nonce",
    "TapLeaf",
    "TapBranch",
    "TapSighash",
    "TapTweak",
    "KeyAgg list",
    "KeyAgg coefficient"
  ], B.TAGGED_HASH_PREFIXES = {
    "BIP0340/challenge": Buffer$1.from([
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124,
      123,
      181,
      45,
      122,
      159,
      239,
      88,
      50,
      62,
      177,
      191,
      122,
      64,
      125,
      179,
      130,
      210,
      243,
      242,
      216,
      27,
      177,
      34,
      79,
      73,
      254,
      81,
      143,
      109,
      72,
      211,
      124
    ]),
    "BIP0340/aux": Buffer$1.from([
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144,
      241,
      239,
      78,
      94,
      192,
      99,
      202,
      218,
      109,
      148,
      202,
      250,
      157,
      152,
      126,
      160,
      105,
      38,
      88,
      57,
      236,
      193,
      31,
      151,
      45,
      119,
      165,
      46,
      216,
      193,
      204,
      144
    ]),
    "BIP0340/nonce": Buffer$1.from([
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47,
      7,
      73,
      119,
      52,
      167,
      155,
      203,
      53,
      91,
      155,
      140,
      125,
      3,
      79,
      18,
      28,
      244,
      52,
      215,
      62,
      247,
      45,
      218,
      25,
      135,
      0,
      97,
      251,
      82,
      191,
      235,
      47
    ]),
    TapLeaf: Buffer$1.from([
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238,
      174,
      234,
      143,
      220,
      66,
      8,
      152,
      49,
      5,
      115,
      75,
      88,
      8,
      29,
      30,
      38,
      56,
      211,
      95,
      28,
      181,
      64,
      8,
      212,
      211,
      87,
      202,
      3,
      190,
      120,
      233,
      238
    ]),
    TapBranch: Buffer$1.from([
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21,
      25,
      65,
      161,
      242,
      229,
      110,
      185,
      95,
      162,
      169,
      241,
      148,
      190,
      92,
      1,
      247,
      33,
      111,
      51,
      237,
      130,
      176,
      145,
      70,
      52,
      144,
      208,
      91,
      245,
      22,
      160,
      21
    ]),
    TapSighash: Buffer$1.from([
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49,
      244,
      10,
      72,
      223,
      75,
      42,
      112,
      200,
      180,
      146,
      75,
      242,
      101,
      70,
      97,
      237,
      61,
      149,
      253,
      102,
      163,
      19,
      235,
      135,
      35,
      117,
      151,
      198,
      40,
      228,
      160,
      49
    ]),
    TapTweak: Buffer$1.from([
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233,
      232,
      15,
      225,
      99,
      156,
      156,
      160,
      80,
      227,
      175,
      27,
      57,
      193,
      67,
      198,
      62,
      66,
      156,
      188,
      235,
      21,
      217,
      64,
      251,
      181,
      197,
      161,
      244,
      175,
      87,
      197,
      233
    ]),
    "KeyAgg list": Buffer$1.from([
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240,
      72,
      28,
      151,
      28,
      60,
      11,
      70,
      215,
      240,
      178,
      117,
      174,
      89,
      141,
      78,
      44,
      126,
      215,
      49,
      156,
      89,
      74,
      92,
      110,
      199,
      158,
      160,
      212,
      153,
      2,
      148,
      240
    ]),
    "KeyAgg coefficient": Buffer$1.from([
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129,
      191,
      201,
      4,
      3,
      77,
      28,
      136,
      232,
      200,
      14,
      34,
      229,
      61,
      36,
      86,
      109,
      100,
      130,
      78,
      214,
      66,
      114,
      129,
      192,
      145,
      0,
      249,
      77,
      205,
      82,
      201,
      129
    ])
  };
  function Ee(oe, Pe) {
    return ae(Buffer$1.concat([B.TAGGED_HASH_PREFIXES[oe], Pe]));
  }
  B.taggedHash = Ee;
})(crypto$1);
function base$1(B) {
  if (B.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var z = new Uint8Array(256), Y = 0; Y < z.length; Y++)
    z[Y] = 255;
  for (var ie = 0; ie < B.length; ie++) {
    var se = B.charAt(ie), ne = se.charCodeAt(0);
    if (z[ne] !== 255)
      throw new TypeError(se + " is ambiguous");
    z[ne] = ie;
  }
  var ae = B.length, le = B.charAt(0), ge = Math.log(ae) / Math.log(256), Ee = Math.log(256) / Math.log(ae);
  function oe(Ke) {
    if (Ke instanceof Uint8Array || (ArrayBuffer.isView(Ke) ? Ke = new Uint8Array(Ke.buffer, Ke.byteOffset, Ke.byteLength) : Array.isArray(Ke) && (Ke = Uint8Array.from(Ke))), !(Ke instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (Ke.length === 0)
      return "";
    for (var ht = 0, _t = 0, Rt = 0, kt = Ke.length; Rt !== kt && Ke[Rt] === 0; )
      Rt++, ht++;
    for (var Bt = (kt - Rt) * Ee + 1 >>> 0, Ct = new Uint8Array(Bt); Rt !== kt; ) {
      for (var qt = Ke[Rt], jt = 0, Ht = Bt - 1; (qt !== 0 || jt < _t) && Ht !== -1; Ht--, jt++)
        qt += 256 * Ct[Ht] >>> 0, Ct[Ht] = qt % ae >>> 0, qt = qt / ae >>> 0;
      if (qt !== 0)
        throw new Error("Non-zero carry");
      _t = jt, Rt++;
    }
    for (var Yt = Bt - _t; Yt !== Bt && Ct[Yt] === 0; )
      Yt++;
    for (var Ut = le.repeat(ht); Yt < Bt; ++Yt)
      Ut += B.charAt(Ct[Yt]);
    return Ut;
  }
  function Pe(Ke) {
    if (typeof Ke != "string")
      throw new TypeError("Expected String");
    if (Ke.length === 0)
      return new Uint8Array();
    for (var ht = 0, _t = 0, Rt = 0; Ke[ht] === le; )
      _t++, ht++;
    for (var kt = (Ke.length - ht) * ge + 1 >>> 0, Bt = new Uint8Array(kt); Ke[ht]; ) {
      var Ct = z[Ke.charCodeAt(ht)];
      if (Ct === 255)
        return;
      for (var qt = 0, jt = kt - 1; (Ct !== 0 || qt < Rt) && jt !== -1; jt--, qt++)
        Ct += ae * Bt[jt] >>> 0, Bt[jt] = Ct % 256 >>> 0, Ct = Ct / 256 >>> 0;
      if (Ct !== 0)
        throw new Error("Non-zero carry");
      Rt = qt, ht++;
    }
    for (var Ht = kt - Rt; Ht !== kt && Bt[Ht] === 0; )
      Ht++;
    for (var Yt = new Uint8Array(_t + (kt - Ht)), Ut = _t; Ht !== kt; )
      Yt[Ut++] = Bt[Ht++];
    return Yt;
  }
  function Ve(Ke) {
    var ht = Pe(Ke);
    if (ht)
      return ht;
    throw new Error("Non-base" + ae + " character");
  }
  return {
    encode: oe,
    decodeUnsafe: Pe,
    decode: Ve
  };
}
var src = base$1;
const basex = src, ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58 = basex(ALPHABET$1), base58 = bs58, base = function(B) {
  function z(ne) {
    var ae = Uint8Array.from(ne), le = B(ae), ge = ae.length + 4, Ee = new Uint8Array(ge);
    return Ee.set(ae, 0), Ee.set(le.subarray(0, 4), ae.length), base58.encode(Ee, ge);
  }
  function Y(ne) {
    var ae = ne.slice(0, -4), le = ne.slice(-4), ge = B(ae);
    if (!(le[0] ^ ge[0] | le[1] ^ ge[1] | le[2] ^ ge[2] | le[3] ^ ge[3]))
      return ae;
  }
  function ie(ne) {
    var ae = base58.decodeUnsafe(ne);
    if (ae)
      return Y(ae);
  }
  function se(ne) {
    var ae = base58.decode(ne), le = Y(ae);
    if (!le) throw new Error("Invalid checksum");
    return le;
  }
  return {
    encode: z,
    decode: se,
    decodeUnsafe: ie
  };
}, { sha256 } = sha256$4, bs58checkBase = base;
function sha256x2(B) {
  return sha256(sha256(B));
}
var bs58check$2 = bs58checkBase(sha256x2);
Object.defineProperty(p2pkh$1, "__esModule", { value: !0 });
p2pkh$1.p2pkh = void 0;
const bcrypto$5 = crypto$1, networks_1$4 = networks, bscript$6 = requireScript(), types_1$4 = types$4, lazy$3 = lazy$7, bs58check$1 = bs58check$2, OPS$3 = bscript$6.OPS;
function p2pkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$4.typeforce)(
    {
      network: types_1$4.typeforce.maybe(types_1$4.typeforce.Object),
      address: types_1$4.typeforce.maybe(types_1$4.typeforce.String),
      hash: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(20)),
      output: types_1$4.typeforce.maybe(types_1$4.typeforce.BufferN(25)),
      pubkey: types_1$4.typeforce.maybe(types_1$4.isPoint),
      signature: types_1$4.typeforce.maybe(bscript$6.isCanonicalScriptSignature),
      input: types_1$4.typeforce.maybe(types_1$4.typeforce.Buffer)
    },
    B
  );
  const Y = lazy$3.value(() => {
    const ae = Buffer$1.from(bs58check$1.decode(B.address)), le = ae.readUInt8(0), ge = ae.slice(1);
    return { version: le, hash: ge };
  }), ie = lazy$3.value(() => bscript$6.decompile(B.input)), se = B.network || networks_1$4.bitcoin, ne = { name: "p2pkh", network: se };
  if (lazy$3.prop(ne, "address", () => {
    if (!ne.hash) return;
    const ae = Buffer$1.allocUnsafe(21);
    return ae.writeUInt8(se.pubKeyHash, 0), ne.hash.copy(ae, 1), bs58check$1.encode(ae);
  }), lazy$3.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(3, 23);
    if (B.address) return Y().hash;
    if (B.pubkey || ne.pubkey) return bcrypto$5.hash160(B.pubkey || ne.pubkey);
  }), lazy$3.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$6.compile([
        OPS$3.OP_DUP,
        OPS$3.OP_HASH160,
        ne.hash,
        OPS$3.OP_EQUALVERIFY,
        OPS$3.OP_CHECKSIG
      ]);
  }), lazy$3.prop(ne, "pubkey", () => {
    if (B.input)
      return ie()[1];
  }), lazy$3.prop(ne, "signature", () => {
    if (B.input)
      return ie()[0];
  }), lazy$3.prop(ne, "input", () => {
    if (B.pubkey && B.signature)
      return bscript$6.compile([B.signature, B.pubkey]);
  }), lazy$3.prop(ne, "witness", () => {
    if (ne.input)
      return [];
  }), z.validate) {
    let ae = Buffer$1.from([]);
    if (B.address) {
      if (Y().version !== se.pubKeyHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (Y().hash.length !== 20) throw new TypeError("Invalid address");
      ae = Y().hash;
    }
    if (B.hash) {
      if (ae.length > 0 && !ae.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ae = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 25 || B.output[0] !== OPS$3.OP_DUP || B.output[1] !== OPS$3.OP_HASH160 || B.output[2] !== 20 || B.output[23] !== OPS$3.OP_EQUALVERIFY || B.output[24] !== OPS$3.OP_CHECKSIG)
        throw new TypeError("Output is invalid");
      const le = B.output.slice(3, 23);
      if (ae.length > 0 && !ae.equals(le))
        throw new TypeError("Hash mismatch");
      ae = le;
    }
    if (B.pubkey) {
      const le = bcrypto$5.hash160(B.pubkey);
      if (ae.length > 0 && !ae.equals(le))
        throw new TypeError("Hash mismatch");
      ae = le;
    }
    if (B.input) {
      const le = ie();
      if (le.length !== 2) throw new TypeError("Input is invalid");
      if (!bscript$6.isCanonicalScriptSignature(le[0]))
        throw new TypeError("Input has invalid signature");
      if (!(0, types_1$4.isPoint)(le[1]))
        throw new TypeError("Input has invalid pubkey");
      if (B.signature && !B.signature.equals(le[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(le[1]))
        throw new TypeError("Pubkey mismatch");
      const ge = bcrypto$5.hash160(le[1]);
      if (ae.length > 0 && !ae.equals(ge))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(ne, B);
}
p2pkh$1.p2pkh = p2pkh;
var p2sh$1 = {};
Object.defineProperty(p2sh$1, "__esModule", { value: !0 });
p2sh$1.p2sh = void 0;
const bcrypto$4 = crypto$1, networks_1$3 = networks, bscript$5 = requireScript(), types_1$3 = types$4, lazy$2 = lazy$7, bs58check = bs58check$2, OPS$2 = bscript$5.OPS;
function p2sh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.input)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$3.typeforce)(
    {
      network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
      address: types_1$3.typeforce.maybe(types_1$3.typeforce.String),
      hash: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(20)),
      output: types_1$3.typeforce.maybe(types_1$3.typeforce.BufferN(23)),
      redeem: types_1$3.typeforce.maybe({
        network: types_1$3.typeforce.maybe(types_1$3.typeforce.Object),
        output: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
        witness: types_1$3.typeforce.maybe(
          types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
        )
      }),
      input: types_1$3.typeforce.maybe(types_1$3.typeforce.Buffer),
      witness: types_1$3.typeforce.maybe(
        types_1$3.typeforce.arrayOf(types_1$3.typeforce.Buffer)
      )
    },
    B
  );
  let Y = B.network;
  Y || (Y = B.redeem && B.redeem.network || networks_1$3.bitcoin);
  const ie = { network: Y }, se = lazy$2.value(() => {
    const le = Buffer$1.from(bs58check.decode(B.address)), ge = le.readUInt8(0), Ee = le.slice(1);
    return { version: ge, hash: Ee };
  }), ne = lazy$2.value(() => bscript$5.decompile(B.input)), ae = lazy$2.value(() => {
    const le = ne(), ge = le[le.length - 1];
    return {
      network: Y,
      output: ge === OPS$2.OP_FALSE ? Buffer$1.from([]) : ge,
      input: bscript$5.compile(le.slice(0, -1)),
      witness: B.witness || []
    };
  });
  if (lazy$2.prop(ie, "address", () => {
    if (!ie.hash) return;
    const le = Buffer$1.allocUnsafe(21);
    return le.writeUInt8(ie.network.scriptHash, 0), ie.hash.copy(le, 1), bs58check.encode(le);
  }), lazy$2.prop(ie, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return se().hash;
    if (ie.redeem && ie.redeem.output) return bcrypto$4.hash160(ie.redeem.output);
  }), lazy$2.prop(ie, "output", () => {
    if (ie.hash)
      return bscript$5.compile([OPS$2.OP_HASH160, ie.hash, OPS$2.OP_EQUAL]);
  }), lazy$2.prop(ie, "redeem", () => {
    if (B.input)
      return ae();
  }), lazy$2.prop(ie, "input", () => {
    if (!(!B.redeem || !B.redeem.input || !B.redeem.output))
      return bscript$5.compile(
        [].concat(bscript$5.decompile(B.redeem.input), B.redeem.output)
      );
  }), lazy$2.prop(ie, "witness", () => {
    if (ie.redeem && ie.redeem.witness) return ie.redeem.witness;
    if (ie.input) return [];
  }), lazy$2.prop(ie, "name", () => {
    const le = ["p2sh"];
    return ie.redeem !== void 0 && ie.redeem.name !== void 0 && le.push(ie.redeem.name), le.join("-");
  }), z.validate) {
    let le = Buffer$1.from([]);
    if (B.address) {
      if (se().version !== Y.scriptHash)
        throw new TypeError("Invalid version or Network mismatch");
      if (se().hash.length !== 20) throw new TypeError("Invalid address");
      le = se().hash;
    }
    if (B.hash) {
      if (le.length > 0 && !le.equals(B.hash))
        throw new TypeError("Hash mismatch");
      le = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 23 || B.output[0] !== OPS$2.OP_HASH160 || B.output[1] !== 20 || B.output[22] !== OPS$2.OP_EQUAL)
        throw new TypeError("Output is invalid");
      const Ee = B.output.slice(2, 22);
      if (le.length > 0 && !le.equals(Ee))
        throw new TypeError("Hash mismatch");
      le = Ee;
    }
    const ge = (Ee) => {
      if (Ee.output) {
        const oe = bscript$5.decompile(Ee.output);
        if (!oe || oe.length < 1)
          throw new TypeError("Redeem.output too short");
        if (Ee.output.byteLength > 520)
          throw new TypeError(
            "Redeem.output unspendable if larger than 520 bytes"
          );
        if (bscript$5.countNonPushOnlyOPs(oe) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const Pe = bcrypto$4.hash160(Ee.output);
        if (le.length > 0 && !le.equals(Pe))
          throw new TypeError("Hash mismatch");
        le = Pe;
      }
      if (Ee.input) {
        const oe = Ee.input.length > 0, Pe = Ee.witness && Ee.witness.length > 0;
        if (!oe && !Pe) throw new TypeError("Empty input");
        if (oe && Pe)
          throw new TypeError("Input and witness provided");
        if (oe) {
          const Ve = bscript$5.decompile(Ee.input);
          if (!bscript$5.isPushOnly(Ve))
            throw new TypeError("Non push-only scriptSig");
        }
      }
    };
    if (B.input) {
      const Ee = ne();
      if (!Ee || Ee.length < 1) throw new TypeError("Input too short");
      if (!Buffer$1.isBuffer(ae().output))
        throw new TypeError("Input is invalid");
      ge(ae());
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== Y)
        throw new TypeError("Network mismatch");
      if (B.input) {
        const Ee = ae();
        if (B.redeem.output && !B.redeem.output.equals(Ee.output))
          throw new TypeError("Redeem.output mismatch");
        if (B.redeem.input && !B.redeem.input.equals(Ee.input))
          throw new TypeError("Redeem.input mismatch");
      }
      ge(B.redeem);
    }
    if (B.witness && B.redeem && B.redeem.witness && !(0, types_1$3.stacksEqual)(B.redeem.witness, B.witness))
      throw new TypeError("Witness and redeem.witness mismatch");
  }
  return Object.assign(ie, B);
}
p2sh$1.p2sh = p2sh;
var p2wpkh$1 = {}, dist = {};
Object.defineProperty(dist, "__esModule", { value: !0 });
dist.bech32m = dist.bech32 = void 0;
const ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", ALPHABET_MAP = {};
for (let B = 0; B < ALPHABET.length; B++) {
  const z = ALPHABET.charAt(B);
  ALPHABET_MAP[z] = B;
}
function polymodStep(B) {
  const z = B >> 25;
  return (B & 33554431) << 5 ^ -(z >> 0 & 1) & 996825010 ^ -(z >> 1 & 1) & 642813549 ^ -(z >> 2 & 1) & 513874426 ^ -(z >> 3 & 1) & 1027748829 ^ -(z >> 4 & 1) & 705979059;
}
function prefixChk(B) {
  let z = 1;
  for (let Y = 0; Y < B.length; ++Y) {
    const ie = B.charCodeAt(Y);
    if (ie < 33 || ie > 126)
      return "Invalid prefix (" + B + ")";
    z = polymodStep(z) ^ ie >> 5;
  }
  z = polymodStep(z);
  for (let Y = 0; Y < B.length; ++Y) {
    const ie = B.charCodeAt(Y);
    z = polymodStep(z) ^ ie & 31;
  }
  return z;
}
function convert$2(B, z, Y, ie) {
  let se = 0, ne = 0;
  const ae = (1 << Y) - 1, le = [];
  for (let ge = 0; ge < B.length; ++ge)
    for (se = se << z | B[ge], ne += z; ne >= Y; )
      ne -= Y, le.push(se >> ne & ae);
  if (ie)
    ne > 0 && le.push(se << Y - ne & ae);
  else {
    if (ne >= z)
      return "Excess padding";
    if (se << Y - ne & ae)
      return "Non-zero padding";
  }
  return le;
}
function toWords(B) {
  return convert$2(B, 8, 5, !0);
}
function fromWordsUnsafe(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
}
function fromWords(B) {
  const z = convert$2(B, 5, 8, !1);
  if (Array.isArray(z))
    return z;
  throw new Error(z);
}
function getLibraryFromEncoding(B) {
  let z;
  B === "bech32" ? z = 1 : z = 734539939;
  function Y(ae, le, ge) {
    if (ge = ge || 90, ae.length + 7 + le.length > ge)
      throw new TypeError("Exceeds length limit");
    ae = ae.toLowerCase();
    let Ee = prefixChk(ae);
    if (typeof Ee == "string")
      throw new Error(Ee);
    let oe = ae + "1";
    for (let Pe = 0; Pe < le.length; ++Pe) {
      const Ve = le[Pe];
      if (Ve >> 5)
        throw new Error("Non 5-bit word");
      Ee = polymodStep(Ee) ^ Ve, oe += ALPHABET.charAt(Ve);
    }
    for (let Pe = 0; Pe < 6; ++Pe)
      Ee = polymodStep(Ee);
    Ee ^= z;
    for (let Pe = 0; Pe < 6; ++Pe) {
      const Ve = Ee >> (5 - Pe) * 5 & 31;
      oe += ALPHABET.charAt(Ve);
    }
    return oe;
  }
  function ie(ae, le) {
    if (le = le || 90, ae.length < 8)
      return ae + " too short";
    if (ae.length > le)
      return "Exceeds length limit";
    const ge = ae.toLowerCase(), Ee = ae.toUpperCase();
    if (ae !== ge && ae !== Ee)
      return "Mixed-case string " + ae;
    ae = ge;
    const oe = ae.lastIndexOf("1");
    if (oe === -1)
      return "No separator character for " + ae;
    if (oe === 0)
      return "Missing prefix for " + ae;
    const Pe = ae.slice(0, oe), Ve = ae.slice(oe + 1);
    if (Ve.length < 6)
      return "Data too short";
    let Ke = prefixChk(Pe);
    if (typeof Ke == "string")
      return Ke;
    const ht = [];
    for (let _t = 0; _t < Ve.length; ++_t) {
      const Rt = Ve.charAt(_t), kt = ALPHABET_MAP[Rt];
      if (kt === void 0)
        return "Unknown character " + Rt;
      Ke = polymodStep(Ke) ^ kt, !(_t + 6 >= Ve.length) && ht.push(kt);
    }
    return Ke !== z ? "Invalid checksum for " + ae : { prefix: Pe, words: ht };
  }
  function se(ae, le) {
    const ge = ie(ae, le);
    if (typeof ge == "object")
      return ge;
  }
  function ne(ae, le) {
    const ge = ie(ae, le);
    if (typeof ge == "object")
      return ge;
    throw new Error(ge);
  }
  return {
    decodeUnsafe: se,
    decode: ne,
    encode: Y,
    toWords,
    fromWordsUnsafe,
    fromWords
  };
}
dist.bech32 = getLibraryFromEncoding("bech32");
dist.bech32m = getLibraryFromEncoding("bech32m");
Object.defineProperty(p2wpkh$1, "__esModule", { value: !0 });
p2wpkh$1.p2wpkh = void 0;
const bcrypto$3 = crypto$1, networks_1$2 = networks, bscript$4 = requireScript(), types_1$2 = types$4, lazy$1 = lazy$7, bech32_1$1 = dist, OPS$1 = bscript$4.OPS, EMPTY_BUFFER$2 = Buffer$1.alloc(0);
function p2wpkh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.pubkey && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$2.typeforce)(
    {
      address: types_1$2.typeforce.maybe(types_1$2.typeforce.String),
      hash: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(20)),
      input: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(0)),
      network: types_1$2.typeforce.maybe(types_1$2.typeforce.Object),
      output: types_1$2.typeforce.maybe(types_1$2.typeforce.BufferN(22)),
      pubkey: types_1$2.typeforce.maybe(types_1$2.isPoint),
      signature: types_1$2.typeforce.maybe(bscript$4.isCanonicalScriptSignature),
      witness: types_1$2.typeforce.maybe(
        types_1$2.typeforce.arrayOf(types_1$2.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy$1.value(() => {
    const ne = bech32_1$1.bech32.decode(B.address), ae = ne.words.shift(), le = bech32_1$1.bech32.fromWords(ne.words);
    return {
      version: ae,
      prefix: ne.prefix,
      data: Buffer$1.from(le)
    };
  }), ie = B.network || networks_1$2.bitcoin, se = { name: "p2wpkh", network: ie };
  if (lazy$1.prop(se, "address", () => {
    if (!se.hash) return;
    const ne = bech32_1$1.bech32.toWords(se.hash);
    return ne.unshift(0), bech32_1$1.bech32.encode(ie.bech32, ne);
  }), lazy$1.prop(se, "hash", () => {
    if (B.output) return B.output.slice(2, 22);
    if (B.address) return Y().data;
    if (B.pubkey || se.pubkey) return bcrypto$3.hash160(B.pubkey || se.pubkey);
  }), lazy$1.prop(se, "output", () => {
    if (se.hash)
      return bscript$4.compile([OPS$1.OP_0, se.hash]);
  }), lazy$1.prop(se, "pubkey", () => {
    if (B.pubkey) return B.pubkey;
    if (B.witness)
      return B.witness[1];
  }), lazy$1.prop(se, "signature", () => {
    if (B.witness)
      return B.witness[0];
  }), lazy$1.prop(se, "input", () => {
    if (se.witness)
      return EMPTY_BUFFER$2;
  }), lazy$1.prop(se, "witness", () => {
    if (B.pubkey && B.signature)
      return [B.signature, B.pubkey];
  }), z.validate) {
    let ne = Buffer$1.from([]);
    if (B.address) {
      if (ie && ie.bech32 !== Y().prefix)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 20)
        throw new TypeError("Invalid address data");
      ne = Y().data;
    }
    if (B.hash) {
      if (ne.length > 0 && !ne.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ne = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 22 || B.output[0] !== OPS$1.OP_0 || B.output[1] !== 20)
        throw new TypeError("Output is invalid");
      if (ne.length > 0 && !ne.equals(B.output.slice(2)))
        throw new TypeError("Hash mismatch");
      ne = B.output.slice(2);
    }
    if (B.pubkey) {
      const ae = bcrypto$3.hash160(B.pubkey);
      if (ne.length > 0 && !ne.equals(ae))
        throw new TypeError("Hash mismatch");
      if (ne = ae, !(0, types_1$2.isPoint)(B.pubkey) || B.pubkey.length !== 33)
        throw new TypeError("Invalid pubkey for p2wpkh");
    }
    if (B.witness) {
      if (B.witness.length !== 2) throw new TypeError("Witness is invalid");
      if (!bscript$4.isCanonicalScriptSignature(B.witness[0]))
        throw new TypeError("Witness has invalid signature");
      if (!(0, types_1$2.isPoint)(B.witness[1]) || B.witness[1].length !== 33)
        throw new TypeError("Witness has invalid pubkey");
      if (B.signature && !B.signature.equals(B.witness[0]))
        throw new TypeError("Signature mismatch");
      if (B.pubkey && !B.pubkey.equals(B.witness[1]))
        throw new TypeError("Pubkey mismatch");
      const ae = bcrypto$3.hash160(B.witness[1]);
      if (ne.length > 0 && !ne.equals(ae))
        throw new TypeError("Hash mismatch");
    }
  }
  return Object.assign(se, B);
}
p2wpkh$1.p2wpkh = p2wpkh;
var p2wsh$1 = {};
Object.defineProperty(p2wsh$1, "__esModule", { value: !0 });
p2wsh$1.p2wsh = void 0;
const bcrypto$2 = crypto$1, networks_1$1 = networks, bscript$3 = requireScript(), types_1$1 = types$4, lazy = lazy$7, bech32_1 = dist, OPS = bscript$3.OPS, EMPTY_BUFFER$1 = Buffer$1.alloc(0);
function chunkHasUncompressedPubkey(B) {
  return !!(Buffer$1.isBuffer(B) && B.length === 65 && B[0] === 4 && (0, types_1$1.isPoint)(B));
}
function p2wsh(B, z) {
  if (!B.address && !B.hash && !B.output && !B.redeem && !B.witness)
    throw new TypeError("Not enough data");
  z = Object.assign({ validate: !0 }, z || {}), (0, types_1$1.typeforce)(
    {
      network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
      address: types_1$1.typeforce.maybe(types_1$1.typeforce.String),
      hash: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(32)),
      output: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(34)),
      redeem: types_1$1.typeforce.maybe({
        input: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        network: types_1$1.typeforce.maybe(types_1$1.typeforce.Object),
        output: types_1$1.typeforce.maybe(types_1$1.typeforce.Buffer),
        witness: types_1$1.typeforce.maybe(
          types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
        )
      }),
      input: types_1$1.typeforce.maybe(types_1$1.typeforce.BufferN(0)),
      witness: types_1$1.typeforce.maybe(
        types_1$1.typeforce.arrayOf(types_1$1.typeforce.Buffer)
      )
    },
    B
  );
  const Y = lazy.value(() => {
    const ae = bech32_1.bech32.decode(B.address), le = ae.words.shift(), ge = bech32_1.bech32.fromWords(ae.words);
    return {
      version: le,
      prefix: ae.prefix,
      data: Buffer$1.from(ge)
    };
  }), ie = lazy.value(() => bscript$3.decompile(B.redeem.input));
  let se = B.network;
  se || (se = B.redeem && B.redeem.network || networks_1$1.bitcoin);
  const ne = { network: se };
  if (lazy.prop(ne, "address", () => {
    if (!ne.hash) return;
    const ae = bech32_1.bech32.toWords(ne.hash);
    return ae.unshift(0), bech32_1.bech32.encode(se.bech32, ae);
  }), lazy.prop(ne, "hash", () => {
    if (B.output) return B.output.slice(2);
    if (B.address) return Y().data;
    if (ne.redeem && ne.redeem.output) return bcrypto$2.sha256(ne.redeem.output);
  }), lazy.prop(ne, "output", () => {
    if (ne.hash)
      return bscript$3.compile([OPS.OP_0, ne.hash]);
  }), lazy.prop(ne, "redeem", () => {
    if (B.witness)
      return {
        output: B.witness[B.witness.length - 1],
        input: EMPTY_BUFFER$1,
        witness: B.witness.slice(0, -1)
      };
  }), lazy.prop(ne, "input", () => {
    if (ne.witness)
      return EMPTY_BUFFER$1;
  }), lazy.prop(ne, "witness", () => {
    if (B.redeem && B.redeem.input && B.redeem.input.length > 0 && B.redeem.output && B.redeem.output.length > 0) {
      const ae = bscript$3.toStack(ie());
      return ne.redeem = Object.assign({ witness: ae }, B.redeem), ne.redeem.input = EMPTY_BUFFER$1, [].concat(ae, B.redeem.output);
    }
    if (B.redeem && B.redeem.output && B.redeem.witness)
      return [].concat(B.redeem.witness, B.redeem.output);
  }), lazy.prop(ne, "name", () => {
    const ae = ["p2wsh"];
    return ne.redeem !== void 0 && ne.redeem.name !== void 0 && ae.push(ne.redeem.name), ae.join("-");
  }), z.validate) {
    let ae = Buffer$1.from([]);
    if (B.address) {
      if (Y().prefix !== se.bech32)
        throw new TypeError("Invalid prefix or Network mismatch");
      if (Y().version !== 0)
        throw new TypeError("Invalid address version");
      if (Y().data.length !== 32)
        throw new TypeError("Invalid address data");
      ae = Y().data;
    }
    if (B.hash) {
      if (ae.length > 0 && !ae.equals(B.hash))
        throw new TypeError("Hash mismatch");
      ae = B.hash;
    }
    if (B.output) {
      if (B.output.length !== 34 || B.output[0] !== OPS.OP_0 || B.output[1] !== 32)
        throw new TypeError("Output is invalid");
      const le = B.output.slice(2);
      if (ae.length > 0 && !ae.equals(le))
        throw new TypeError("Hash mismatch");
      ae = le;
    }
    if (B.redeem) {
      if (B.redeem.network && B.redeem.network !== se)
        throw new TypeError("Network mismatch");
      if (B.redeem.input && B.redeem.input.length > 0 && B.redeem.witness && B.redeem.witness.length > 0)
        throw new TypeError("Ambiguous witness source");
      if (B.redeem.output) {
        const le = bscript$3.decompile(B.redeem.output);
        if (!le || le.length < 1)
          throw new TypeError("Redeem.output is invalid");
        if (B.redeem.output.byteLength > 3600)
          throw new TypeError(
            "Redeem.output unspendable if larger than 3600 bytes"
          );
        if (bscript$3.countNonPushOnlyOPs(le) > 201)
          throw new TypeError(
            "Redeem.output unspendable with more than 201 non-push ops"
          );
        const ge = bcrypto$2.sha256(B.redeem.output);
        if (ae.length > 0 && !ae.equals(ge))
          throw new TypeError("Hash mismatch");
        ae = ge;
      }
      if (B.redeem.input && !bscript$3.isPushOnly(ie()))
        throw new TypeError("Non push-only scriptSig");
      if (B.witness && B.redeem.witness && !(0, types_1$1.stacksEqual)(B.witness, B.redeem.witness))
        throw new TypeError("Witness and redeem.witness mismatch");
      if (B.redeem.input && ie().some(chunkHasUncompressedPubkey) || B.redeem.output && (bscript$3.decompile(B.redeem.output) || []).some(
        chunkHasUncompressedPubkey
      ))
        throw new TypeError(
          "redeem.input or redeem.output contains uncompressed pubkey"
        );
    }
    if (B.witness && B.witness.length > 0) {
      const le = B.witness[B.witness.length - 1];
      if (B.redeem && B.redeem.output && !B.redeem.output.equals(le))
        throw new TypeError("Witness and redeem.output mismatch");
      if (B.witness.some(chunkHasUncompressedPubkey) || (bscript$3.decompile(le) || []).some(chunkHasUncompressedPubkey))
        throw new TypeError("Witness contains uncompressed pubkey");
    }
  }
  return Object.assign(ne, B);
}
p2wsh$1.p2wsh = p2wsh;
var p2tr = {}, ecc_lib = {};
Object.defineProperty(ecc_lib, "__esModule", { value: !0 });
ecc_lib.getEccLib = ecc_lib.initEccLib = void 0;
const _ECCLIB_CACHE = {};
function initEccLib(B) {
  B ? B !== _ECCLIB_CACHE.eccLib && (verifyEcc(B), _ECCLIB_CACHE.eccLib = B) : _ECCLIB_CACHE.eccLib = B;
}
ecc_lib.initEccLib = initEccLib;
function getEccLib() {
  if (!_ECCLIB_CACHE.eccLib)
    throw new Error(
      "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
    );
  return _ECCLIB_CACHE.eccLib;
}
ecc_lib.getEccLib = getEccLib;
const h = (B) => Buffer$1.from(B, "hex");
function verifyEcc(B) {
  assert(typeof B.isXOnlyPoint == "function"), assert(
    B.isXOnlyPoint(
      h("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), assert(
    B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
    )
  ), assert(
    B.isXOnlyPoint(
      h("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
    )
  ), assert(
    B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), assert(
    !B.isXOnlyPoint(
      h("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
    )
  ), assert(typeof B.xOnlyPointAddTweak == "function"), tweakAddVectors.forEach((z) => {
    const Y = B.xOnlyPointAddTweak(h(z.pubkey), h(z.tweak));
    z.result === null ? assert(Y === null) : (assert(Y !== null), assert(Y.parity === z.parity), assert(Buffer$1.from(Y.xOnlyPubkey).equals(h(z.result))));
  });
}
function assert(B) {
  if (!B) throw new Error("ecc library invalid");
}
const tweakAddVectors = [
  {
    pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
    tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
    parity: -1,
    result: null
  },
  {
    pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
    tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
    parity: 1,
    result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
  },
  {
    pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
    tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
    parity: 0,
    result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
  }
];
var bip341 = {}, bufferutils = {}, Buffer = safeBufferExports.Buffer, MAX_SAFE_INTEGER$1 = 9007199254740991;
function checkUInt53$1(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER$1 || B % 1 !== 0) throw new RangeError("value out of range");
}
function encode$f(B, z, Y) {
  if (checkUInt53$1(B), z || (z = Buffer.allocUnsafe(encodingLength$1(B))), !Buffer.isBuffer(z)) throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), encode$f.bytes = 1) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), encode$f.bytes = 3) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), encode$f.bytes = 5) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), encode$f.bytes = 9), z;
}
function decode$e(B, z) {
  if (!Buffer.isBuffer(B)) throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  var Y = B.readUInt8(z);
  if (Y < 253)
    return decode$e.bytes = 1, Y;
  if (Y === 253)
    return decode$e.bytes = 3, B.readUInt16LE(z + 1);
  if (Y === 254)
    return decode$e.bytes = 5, B.readUInt32LE(z + 1);
  decode$e.bytes = 9;
  var ie = B.readUInt32LE(z + 1), se = B.readUInt32LE(z + 5), ne = se * 4294967296 + ie;
  return checkUInt53$1(ne), ne;
}
function encodingLength$1(B) {
  return checkUInt53$1(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
var varuintBitcoin = { encode: encode$f, decode: decode$e, encodingLength: encodingLength$1 };
Object.defineProperty(bufferutils, "__esModule", { value: !0 });
bufferutils.BufferReader = bufferutils.BufferWriter = bufferutils.cloneBuffer = bufferutils.reverseBuffer = bufferutils.writeUInt64LE = bufferutils.readUInt64LE = bufferutils.varuint = void 0;
const types$2 = types$4, { typeforce: typeforce$2 } = types$2, varuint$7 = varuintBitcoin;
bufferutils.varuint = varuint$7;
function verifuint$1(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE$1(B, z) {
  const Y = B.readUInt32LE(z);
  let ie = B.readUInt32LE(z + 4);
  return ie *= 4294967296, verifuint$1(ie + Y, 9007199254740991), ie + Y;
}
bufferutils.readUInt64LE = readUInt64LE$1;
function writeUInt64LE$1(B, z, Y) {
  return verifuint$1(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
bufferutils.writeUInt64LE = writeUInt64LE$1;
function reverseBuffer$1(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ie = 0; ie < B.length / 2; ie++)
    Y = B[ie], B[ie] = B[z], B[z] = Y, z--;
  return B;
}
bufferutils.reverseBuffer = reverseBuffer$1;
function cloneBuffer(B) {
  const z = Buffer$1.allocUnsafe(B.length);
  return B.copy(z), z;
}
bufferutils.cloneBuffer = cloneBuffer;
class BufferWriter {
  static withCapacity(z) {
    return new BufferWriter(Buffer$1.alloc(z));
  }
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  writeUInt8(z) {
    this.offset = this.buffer.writeUInt8(z, this.offset);
  }
  writeInt32(z) {
    this.offset = this.buffer.writeInt32LE(z, this.offset);
  }
  writeUInt32(z) {
    this.offset = this.buffer.writeUInt32LE(z, this.offset);
  }
  writeUInt64(z) {
    this.offset = writeUInt64LE$1(this.buffer, z, this.offset);
  }
  writeVarInt(z) {
    varuint$7.encode(z, this.buffer, this.offset), this.offset += varuint$7.encode.bytes;
  }
  writeSlice(z) {
    if (this.buffer.length < this.offset + z.length)
      throw new Error("Cannot write slice out of bounds");
    this.offset += z.copy(this.buffer, this.offset);
  }
  writeVarSlice(z) {
    this.writeVarInt(z.length), this.writeSlice(z);
  }
  writeVector(z) {
    this.writeVarInt(z.length), z.forEach((Y) => this.writeVarSlice(Y));
  }
  end() {
    if (this.buffer.length === this.offset)
      return this.buffer;
    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
  }
}
bufferutils.BufferWriter = BufferWriter;
class BufferReader {
  constructor(z, Y = 0) {
    this.buffer = z, this.offset = Y, typeforce$2(types$2.tuple(types$2.Buffer, types$2.UInt32), [z, Y]);
  }
  readUInt8() {
    const z = this.buffer.readUInt8(this.offset);
    return this.offset++, z;
  }
  readInt32() {
    const z = this.buffer.readInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt32() {
    const z = this.buffer.readUInt32LE(this.offset);
    return this.offset += 4, z;
  }
  readUInt64() {
    const z = readUInt64LE$1(this.buffer, this.offset);
    return this.offset += 8, z;
  }
  readVarInt() {
    const z = varuint$7.decode(this.buffer, this.offset);
    return this.offset += varuint$7.decode.bytes, z;
  }
  readSlice(z) {
    if (this.buffer.length < this.offset + z)
      throw new Error("Cannot read slice out of bounds");
    const Y = this.buffer.slice(this.offset, this.offset + z);
    return this.offset += z, Y;
  }
  readVarSlice() {
    return this.readSlice(this.readVarInt());
  }
  readVector() {
    const z = this.readVarInt(), Y = [];
    for (let ie = 0; ie < z; ie++) Y.push(this.readVarSlice());
    return Y;
  }
}
bufferutils.BufferReader = BufferReader;
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.tweakKey = B.tapTweakHash = B.tapleafHash = B.findScriptPath = B.toHashTree = B.rootHashFromPath = B.MAX_TAPTREE_DEPTH = B.LEAF_VERSION_TAPSCRIPT = void 0;
  const z = require$$0$1, Y = ecc_lib, ie = crypto$1, se = bufferutils, ne = types$4;
  B.LEAF_VERSION_TAPSCRIPT = 192, B.MAX_TAPTREE_DEPTH = 128;
  const ae = (_t) => "left" in _t && "right" in _t;
  function le(_t, Rt) {
    if (_t.length < 33)
      throw new TypeError(
        `The control-block length is too small. Got ${_t.length}, expected min 33.`
      );
    const kt = (_t.length - 33) / 32;
    let Bt = Rt;
    for (let Ct = 0; Ct < kt; Ct++) {
      const qt = _t.slice(33 + 32 * Ct, 65 + 32 * Ct);
      Bt.compare(qt) < 0 ? Bt = Ke(Bt, qt) : Bt = Ke(qt, Bt);
    }
    return Bt;
  }
  B.rootHashFromPath = le;
  function ge(_t) {
    if ((0, ne.isTapleaf)(_t))
      return { hash: oe(_t) };
    const Rt = [ge(_t[0]), ge(_t[1])];
    Rt.sort((Ct, qt) => Ct.hash.compare(qt.hash));
    const [kt, Bt] = Rt;
    return {
      hash: Ke(kt.hash, Bt.hash),
      left: kt,
      right: Bt
    };
  }
  B.toHashTree = ge;
  function Ee(_t, Rt) {
    if (ae(_t)) {
      const kt = Ee(_t.left, Rt);
      if (kt !== void 0) return [...kt, _t.right.hash];
      const Bt = Ee(_t.right, Rt);
      if (Bt !== void 0) return [...Bt, _t.left.hash];
    } else if (_t.hash.equals(Rt))
      return [];
  }
  B.findScriptPath = Ee;
  function oe(_t) {
    const Rt = _t.version || B.LEAF_VERSION_TAPSCRIPT;
    return ie.taggedHash(
      "TapLeaf",
      z.Buffer.concat([
        z.Buffer.from([Rt]),
        ht(_t.output)
      ])
    );
  }
  B.tapleafHash = oe;
  function Pe(_t, Rt) {
    return ie.taggedHash(
      "TapTweak",
      z.Buffer.concat(Rt ? [_t, Rt] : [_t])
    );
  }
  B.tapTweakHash = Pe;
  function Ve(_t, Rt) {
    if (!z.Buffer.isBuffer(_t) || _t.length !== 32 || Rt && Rt.length !== 32) return null;
    const kt = Pe(_t, Rt), Bt = (0, Y.getEccLib)().xOnlyPointAddTweak(_t, kt);
    return !Bt || Bt.xOnlyPubkey === null ? null : {
      parity: Bt.parity,
      x: z.Buffer.from(Bt.xOnlyPubkey)
    };
  }
  B.tweakKey = Ve;
  function Ke(_t, Rt) {
    return ie.taggedHash("TapBranch", z.Buffer.concat([_t, Rt]));
  }
  function ht(_t) {
    const Rt = se.varuint.encodingLength(_t.length), kt = z.Buffer.allocUnsafe(Rt);
    return se.varuint.encode(_t.length, kt), z.Buffer.concat([kt, _t]);
  }
})(bip341);
var hasRequiredP2tr;
function requireP2tr() {
  if (hasRequiredP2tr) return p2tr;
  hasRequiredP2tr = 1, Object.defineProperty(p2tr, "__esModule", { value: !0 }), p2tr.p2tr = void 0;
  const B = require$$0$1, z = networks, Y = requireScript(), ie = types$4, se = ecc_lib, ne = bip341, ae = lazy$7, le = dist, ge = requireAddress(), Ee = Y.OPS, oe = 1, Pe = 80;
  function Ve(Ke, ht) {
    if (!Ke.address && !Ke.output && !Ke.pubkey && !Ke.internalPubkey && !(Ke.witness && Ke.witness.length > 1))
      throw new TypeError("Not enough data");
    ht = Object.assign({ validate: !0 }, ht || {}), (0, ie.typeforce)(
      {
        address: ie.typeforce.maybe(ie.typeforce.String),
        input: ie.typeforce.maybe(ie.typeforce.BufferN(0)),
        network: ie.typeforce.maybe(ie.typeforce.Object),
        output: ie.typeforce.maybe(ie.typeforce.BufferN(34)),
        internalPubkey: ie.typeforce.maybe(ie.typeforce.BufferN(32)),
        hash: ie.typeforce.maybe(ie.typeforce.BufferN(32)),
        pubkey: ie.typeforce.maybe(ie.typeforce.BufferN(32)),
        signature: ie.typeforce.maybe(
          ie.typeforce.anyOf(
            ie.typeforce.BufferN(64),
            ie.typeforce.BufferN(65)
          )
        ),
        witness: ie.typeforce.maybe(
          ie.typeforce.arrayOf(ie.typeforce.Buffer)
        ),
        scriptTree: ie.typeforce.maybe(ie.isTaptree),
        redeem: ie.typeforce.maybe({
          output: ie.typeforce.maybe(ie.typeforce.Buffer),
          redeemVersion: ie.typeforce.maybe(ie.typeforce.Number),
          witness: ie.typeforce.maybe(
            ie.typeforce.arrayOf(ie.typeforce.Buffer)
          )
        }),
        redeemVersion: ie.typeforce.maybe(ie.typeforce.Number)
      },
      Ke
    );
    const _t = ae.value(() => (0, ge.fromBech32)(Ke.address)), Rt = ae.value(() => {
      if (!(!Ke.witness || !Ke.witness.length))
        return Ke.witness.length >= 2 && Ke.witness[Ke.witness.length - 1][0] === Pe ? Ke.witness.slice(0, -1) : Ke.witness.slice();
    }), kt = ae.value(() => {
      if (Ke.scriptTree) return (0, ne.toHashTree)(Ke.scriptTree);
      if (Ke.hash) return { hash: Ke.hash };
    }), Bt = Ke.network || z.bitcoin, Ct = { name: "p2tr", network: Bt };
    if (ae.prop(Ct, "address", () => {
      if (!Ct.pubkey) return;
      const qt = le.bech32m.toWords(Ct.pubkey);
      return qt.unshift(oe), le.bech32m.encode(Bt.bech32, qt);
    }), ae.prop(Ct, "hash", () => {
      const qt = kt();
      if (qt) return qt.hash;
      const jt = Rt();
      if (jt && jt.length > 1) {
        const Ht = jt[jt.length - 1], Yt = Ht[0] & ie.TAPLEAF_VERSION_MASK, Ut = jt[jt.length - 2], Nt = (0, ne.tapleafHash)({
          output: Ut,
          version: Yt
        });
        return (0, ne.rootHashFromPath)(Ht, Nt);
      }
      return null;
    }), ae.prop(Ct, "output", () => {
      if (Ct.pubkey)
        return Y.compile([Ee.OP_1, Ct.pubkey]);
    }), ae.prop(Ct, "redeemVersion", () => Ke.redeemVersion ? Ke.redeemVersion : Ke.redeem && Ke.redeem.redeemVersion !== void 0 && Ke.redeem.redeemVersion !== null ? Ke.redeem.redeemVersion : ne.LEAF_VERSION_TAPSCRIPT), ae.prop(Ct, "redeem", () => {
      const qt = Rt();
      if (!(!qt || qt.length < 2))
        return {
          output: qt[qt.length - 2],
          witness: qt.slice(0, -2),
          redeemVersion: qt[qt.length - 1][0] & ie.TAPLEAF_VERSION_MASK
        };
    }), ae.prop(Ct, "pubkey", () => {
      if (Ke.pubkey) return Ke.pubkey;
      if (Ke.output) return Ke.output.slice(2);
      if (Ke.address) return _t().data;
      if (Ct.internalPubkey) {
        const qt = (0, ne.tweakKey)(Ct.internalPubkey, Ct.hash);
        if (qt) return qt.x;
      }
    }), ae.prop(Ct, "internalPubkey", () => {
      if (Ke.internalPubkey) return Ke.internalPubkey;
      const qt = Rt();
      if (qt && qt.length > 1)
        return qt[qt.length - 1].slice(1, 33);
    }), ae.prop(Ct, "signature", () => {
      if (Ke.signature) return Ke.signature;
      const qt = Rt();
      if (!(!qt || qt.length !== 1))
        return qt[0];
    }), ae.prop(Ct, "witness", () => {
      if (Ke.witness) return Ke.witness;
      const qt = kt();
      if (qt && Ke.redeem && Ke.redeem.output && Ke.internalPubkey) {
        const jt = (0, ne.tapleafHash)({
          output: Ke.redeem.output,
          version: Ct.redeemVersion
        }), Ht = (0, ne.findScriptPath)(qt, jt);
        if (!Ht) return;
        const Yt = (0, ne.tweakKey)(Ke.internalPubkey, qt.hash);
        if (!Yt) return;
        const Ut = B.Buffer.concat(
          [
            B.Buffer.from([Ct.redeemVersion | Yt.parity]),
            Ke.internalPubkey
          ].concat(Ht)
        );
        return [Ke.redeem.output, Ut];
      }
      if (Ke.signature) return [Ke.signature];
    }), ht.validate) {
      let qt = B.Buffer.from([]);
      if (Ke.address) {
        if (Bt && Bt.bech32 !== _t().prefix)
          throw new TypeError("Invalid prefix or Network mismatch");
        if (_t().version !== oe)
          throw new TypeError("Invalid address version");
        if (_t().data.length !== 32)
          throw new TypeError("Invalid address data");
        qt = _t().data;
      }
      if (Ke.pubkey) {
        if (qt.length > 0 && !qt.equals(Ke.pubkey))
          throw new TypeError("Pubkey mismatch");
        qt = Ke.pubkey;
      }
      if (Ke.output) {
        if (Ke.output.length !== 34 || Ke.output[0] !== Ee.OP_1 || Ke.output[1] !== 32)
          throw new TypeError("Output is invalid");
        if (qt.length > 0 && !qt.equals(Ke.output.slice(2)))
          throw new TypeError("Pubkey mismatch");
        qt = Ke.output.slice(2);
      }
      if (Ke.internalPubkey) {
        const Yt = (0, ne.tweakKey)(Ke.internalPubkey, Ct.hash);
        if (qt.length > 0 && !qt.equals(Yt.x))
          throw new TypeError("Pubkey mismatch");
        qt = Yt.x;
      }
      if (qt && qt.length && !(0, se.getEccLib)().isXOnlyPoint(qt))
        throw new TypeError("Invalid pubkey for p2tr");
      const jt = kt();
      if (Ke.hash && jt && !Ke.hash.equals(jt.hash))
        throw new TypeError("Hash mismatch");
      if (Ke.redeem && Ke.redeem.output && jt) {
        const Yt = (0, ne.tapleafHash)({
          output: Ke.redeem.output,
          version: Ct.redeemVersion
        });
        if (!(0, ne.findScriptPath)(jt, Yt))
          throw new TypeError("Redeem script not in tree");
      }
      const Ht = Rt();
      if (Ke.redeem && Ct.redeem) {
        if (Ke.redeem.redeemVersion && Ke.redeem.redeemVersion !== Ct.redeem.redeemVersion)
          throw new TypeError("Redeem.redeemVersion and witness mismatch");
        if (Ke.redeem.output) {
          if (Y.decompile(Ke.redeem.output).length === 0)
            throw new TypeError("Redeem.output is invalid");
          if (Ct.redeem.output && !Ke.redeem.output.equals(Ct.redeem.output))
            throw new TypeError("Redeem.output and witness mismatch");
        }
        if (Ke.redeem.witness && Ct.redeem.witness && !(0, ie.stacksEqual)(Ke.redeem.witness, Ct.redeem.witness))
          throw new TypeError("Redeem.witness and witness mismatch");
      }
      if (Ht && Ht.length)
        if (Ht.length === 1) {
          if (Ke.signature && !Ke.signature.equals(Ht[0]))
            throw new TypeError("Signature mismatch");
        } else {
          const Yt = Ht[Ht.length - 1];
          if (Yt.length < 33)
            throw new TypeError(
              `The control-block length is too small. Got ${Yt.length}, expected min 33.`
            );
          if ((Yt.length - 33) % 32 !== 0)
            throw new TypeError(
              `The control-block length of ${Yt.length} is incorrect!`
            );
          const Ut = (Yt.length - 33) / 32;
          if (Ut > 128)
            throw new TypeError(
              `The script path is too long. Got ${Ut}, expected max 128.`
            );
          const Nt = Yt.slice(1, 33);
          if (Ke.internalPubkey && !Ke.internalPubkey.equals(Nt))
            throw new TypeError("Internal pubkey mismatch");
          if (!(0, se.getEccLib)().isXOnlyPoint(Nt))
            throw new TypeError("Invalid internalPubkey for p2tr witness");
          const Kt = Yt[0] & ie.TAPLEAF_VERSION_MASK, Ft = Ht[Ht.length - 2], bt = (0, ne.tapleafHash)({
            output: Ft,
            version: Kt
          }), Xe = (0, ne.rootHashFromPath)(Yt, bt), ve = (0, ne.tweakKey)(Nt, Xe);
          if (!ve)
            throw new TypeError("Invalid outputKey for p2tr witness");
          if (qt.length && !qt.equals(ve.x))
            throw new TypeError("Pubkey mismatch for p2tr witness");
          if (ve.parity !== (Yt[0] & 1))
            throw new Error("Incorrect parity");
        }
    }
    return Object.assign(Ct, Ke);
  }
  return p2tr.p2tr = Ve, p2tr;
}
var hasRequiredPayments;
function requirePayments() {
  return hasRequiredPayments || (hasRequiredPayments = 1, function(B) {
    Object.defineProperty(B, "__esModule", { value: !0 }), B.p2tr = B.p2wsh = B.p2wpkh = B.p2sh = B.p2pkh = B.p2pk = B.p2ms = B.embed = void 0;
    const z = embed;
    Object.defineProperty(B, "embed", {
      enumerable: !0,
      get: function() {
        return z.p2data;
      }
    });
    const Y = p2ms$1;
    Object.defineProperty(B, "p2ms", {
      enumerable: !0,
      get: function() {
        return Y.p2ms;
      }
    });
    const ie = p2pk$1;
    Object.defineProperty(B, "p2pk", {
      enumerable: !0,
      get: function() {
        return ie.p2pk;
      }
    });
    const se = p2pkh$1;
    Object.defineProperty(B, "p2pkh", {
      enumerable: !0,
      get: function() {
        return se.p2pkh;
      }
    });
    const ne = p2sh$1;
    Object.defineProperty(B, "p2sh", {
      enumerable: !0,
      get: function() {
        return ne.p2sh;
      }
    });
    const ae = p2wpkh$1;
    Object.defineProperty(B, "p2wpkh", {
      enumerable: !0,
      get: function() {
        return ae.p2wpkh;
      }
    });
    const le = p2wsh$1;
    Object.defineProperty(B, "p2wsh", {
      enumerable: !0,
      get: function() {
        return le.p2wsh;
      }
    });
    const ge = requireP2tr();
    Object.defineProperty(B, "p2tr", {
      enumerable: !0,
      get: function() {
        return ge.p2tr;
      }
    });
  }(payments$2)), payments$2;
}
var hasRequiredAddress;
function requireAddress() {
  if (hasRequiredAddress) return address;
  hasRequiredAddress = 1, Object.defineProperty(address, "__esModule", { value: !0 }), address.toOutputScript = address.fromOutputScript = address.toBech32 = address.toBase58Check = address.fromBech32 = address.fromBase58Check = void 0;
  const B = networks, z = requirePayments(), Y = requireScript(), ie = types$4, se = dist, ne = bs58check$2, ae = 40, le = 2, ge = 16, Ee = 2, oe = 80, Pe = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
  function Ve(Ct, qt) {
    const jt = Ct.slice(2);
    if (jt.length < le || jt.length > ae)
      throw new TypeError("Invalid program length for segwit address");
    const Ht = Ct[0] - oe;
    if (Ht < Ee || Ht > ge)
      throw new TypeError("Invalid version for segwit address");
    if (Ct[1] !== jt.length)
      throw new TypeError("Invalid script for segwit address");
    return console.warn(Pe), Rt(jt, Ht, qt.bech32);
  }
  function Ke(Ct) {
    const qt = Buffer$1.from(ne.decode(Ct));
    if (qt.length < 21) throw new TypeError(Ct + " is too short");
    if (qt.length > 21) throw new TypeError(Ct + " is too long");
    const jt = qt.readUInt8(0), Ht = qt.slice(1);
    return { version: jt, hash: Ht };
  }
  address.fromBase58Check = Ke;
  function ht(Ct) {
    let qt, jt;
    try {
      qt = se.bech32.decode(Ct);
    } catch {
    }
    if (qt) {
      if (jt = qt.words[0], jt !== 0) throw new TypeError(Ct + " uses wrong encoding");
    } else if (qt = se.bech32m.decode(Ct), jt = qt.words[0], jt === 0) throw new TypeError(Ct + " uses wrong encoding");
    const Ht = se.bech32.fromWords(qt.words.slice(1));
    return {
      version: jt,
      prefix: qt.prefix,
      data: Buffer$1.from(Ht)
    };
  }
  address.fromBech32 = ht;
  function _t(Ct, qt) {
    (0, ie.typeforce)(
      (0, ie.tuple)(ie.Hash160bit, ie.UInt8),
      arguments
    );
    const jt = Buffer$1.allocUnsafe(21);
    return jt.writeUInt8(qt, 0), Ct.copy(jt, 1), ne.encode(jt);
  }
  address.toBase58Check = _t;
  function Rt(Ct, qt, jt) {
    const Ht = se.bech32.toWords(Ct);
    return Ht.unshift(qt), qt === 0 ? se.bech32.encode(jt, Ht) : se.bech32m.encode(jt, Ht);
  }
  address.toBech32 = Rt;
  function kt(Ct, qt) {
    qt = qt || B.bitcoin;
    try {
      return z.p2pkh({ output: Ct, network: qt }).address;
    } catch {
    }
    try {
      return z.p2sh({ output: Ct, network: qt }).address;
    } catch {
    }
    try {
      return z.p2wpkh({ output: Ct, network: qt }).address;
    } catch {
    }
    try {
      return z.p2wsh({ output: Ct, network: qt }).address;
    } catch {
    }
    try {
      return z.p2tr({ output: Ct, network: qt }).address;
    } catch {
    }
    try {
      return Ve(Ct, qt);
    } catch {
    }
    throw new Error(Y.toASM(Ct) + " has no matching Address");
  }
  address.fromOutputScript = kt;
  function Bt(Ct, qt) {
    qt = qt || B.bitcoin;
    let jt, Ht;
    try {
      jt = Ke(Ct);
    } catch {
    }
    if (jt) {
      if (jt.version === qt.pubKeyHash)
        return z.p2pkh({ hash: jt.hash }).output;
      if (jt.version === qt.scriptHash)
        return z.p2sh({ hash: jt.hash }).output;
    } else {
      try {
        Ht = ht(Ct);
      } catch {
      }
      if (Ht) {
        if (Ht.prefix !== qt.bech32)
          throw new Error(Ct + " has an invalid prefix");
        if (Ht.version === 0) {
          if (Ht.data.length === 20)
            return z.p2wpkh({ hash: Ht.data }).output;
          if (Ht.data.length === 32)
            return z.p2wsh({ hash: Ht.data }).output;
        } else if (Ht.version === 1) {
          if (Ht.data.length === 32)
            return z.p2tr({ pubkey: Ht.data }).output;
        } else if (Ht.version >= Ee && Ht.version <= ge && Ht.data.length >= le && Ht.data.length <= ae)
          return console.warn(Pe), Y.compile([
            Ht.version + oe,
            Ht.data
          ]);
      }
    }
    throw new Error(Ct + " has no matching Script");
  }
  return address.toOutputScript = Bt, address;
}
var block = {}, merkle = {};
Object.defineProperty(merkle, "__esModule", { value: !0 });
merkle.fastMerkleRoot = void 0;
function fastMerkleRoot(B, z) {
  if (!Array.isArray(B)) throw TypeError("Expected values Array");
  if (typeof z != "function")
    throw TypeError("Expected digest Function");
  let Y = B.length;
  const ie = B.concat();
  for (; Y > 1; ) {
    let se = 0;
    for (let ne = 0; ne < Y; ne += 2, ++se) {
      const ae = ie[ne], le = ne + 1 === Y ? ae : ie[ne + 1], ge = Buffer$1.concat([ae, le]);
      ie[se] = z(ge);
    }
    Y = se;
  }
  return ie[0];
}
merkle.fastMerkleRoot = fastMerkleRoot;
var transaction = {};
Object.defineProperty(transaction, "__esModule", { value: !0 });
transaction.Transaction = void 0;
const bufferutils_1$2 = bufferutils, bcrypto$1 = crypto$1, bscript$2 = requireScript(), script_1 = requireScript(), types$1 = types$4, { typeforce: typeforce$1 } = types$1;
function varSliceSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + z;
}
function vectorSize(B) {
  const z = B.length;
  return bufferutils_1$2.varuint.encodingLength(z) + B.reduce((Y, ie) => Y + varSliceSize(ie), 0);
}
const EMPTY_BUFFER = Buffer$1.allocUnsafe(0), EMPTY_WITNESS = [], ZERO = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000000",
  "hex"
), ONE = Buffer$1.from(
  "0000000000000000000000000000000000000000000000000000000000000001",
  "hex"
), VALUE_UINT64_MAX = Buffer$1.from("ffffffffffffffff", "hex"), BLANK_OUTPUT = {
  script: EMPTY_BUFFER,
  valueBuffer: VALUE_UINT64_MAX
};
function isOutput(B) {
  return B.value !== void 0;
}
class Transaction {
  constructor() {
    this.version = 1, this.locktime = 0, this.ins = [], this.outs = [];
  }
  static fromBuffer(z, Y) {
    const ie = new bufferutils_1$2.BufferReader(z), se = new Transaction();
    se.version = ie.readInt32();
    const ne = ie.readUInt8(), ae = ie.readUInt8();
    let le = !1;
    ne === Transaction.ADVANCED_TRANSACTION_MARKER && ae === Transaction.ADVANCED_TRANSACTION_FLAG ? le = !0 : ie.offset -= 2;
    const ge = ie.readVarInt();
    for (let oe = 0; oe < ge; ++oe)
      se.ins.push({
        hash: ie.readSlice(32),
        index: ie.readUInt32(),
        script: ie.readVarSlice(),
        sequence: ie.readUInt32(),
        witness: EMPTY_WITNESS
      });
    const Ee = ie.readVarInt();
    for (let oe = 0; oe < Ee; ++oe)
      se.outs.push({
        value: ie.readUInt64(),
        script: ie.readVarSlice()
      });
    if (le) {
      for (let oe = 0; oe < ge; ++oe)
        se.ins[oe].witness = ie.readVector();
      if (!se.hasWitnesses())
        throw new Error("Transaction has superfluous witness data");
    }
    if (se.locktime = ie.readUInt32(), Y) return se;
    if (ie.offset !== z.length)
      throw new Error("Transaction has unexpected data");
    return se;
  }
  static fromHex(z) {
    return Transaction.fromBuffer(Buffer$1.from(z, "hex"), !1);
  }
  static isCoinbaseHash(z) {
    typeforce$1(types$1.Hash256bit, z);
    for (let Y = 0; Y < 32; ++Y)
      if (z[Y] !== 0) return !1;
    return !0;
  }
  isCoinbase() {
    return this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash);
  }
  addInput(z, Y, ie, se) {
    return typeforce$1(
      types$1.tuple(
        types$1.Hash256bit,
        types$1.UInt32,
        types$1.maybe(types$1.UInt32),
        types$1.maybe(types$1.Buffer)
      ),
      arguments
    ), types$1.Null(ie) && (ie = Transaction.DEFAULT_SEQUENCE), this.ins.push({
      hash: z,
      index: Y,
      script: se || EMPTY_BUFFER,
      sequence: ie,
      witness: EMPTY_WITNESS
    }) - 1;
  }
  addOutput(z, Y) {
    return typeforce$1(types$1.tuple(types$1.Buffer, types$1.Satoshi), arguments), this.outs.push({
      script: z,
      value: Y
    }) - 1;
  }
  hasWitnesses() {
    return this.ins.some((z) => z.witness.length !== 0);
  }
  weight() {
    const z = this.byteLength(!1), Y = this.byteLength(!0);
    return z * 3 + Y;
  }
  virtualSize() {
    return Math.ceil(this.weight() / 4);
  }
  byteLength(z = !0) {
    const Y = z && this.hasWitnesses();
    return (Y ? 10 : 8) + bufferutils_1$2.varuint.encodingLength(this.ins.length) + bufferutils_1$2.varuint.encodingLength(this.outs.length) + this.ins.reduce((ie, se) => ie + 40 + varSliceSize(se.script), 0) + this.outs.reduce((ie, se) => ie + 8 + varSliceSize(se.script), 0) + (Y ? this.ins.reduce((ie, se) => ie + vectorSize(se.witness), 0) : 0);
  }
  clone() {
    const z = new Transaction();
    return z.version = this.version, z.locktime = this.locktime, z.ins = this.ins.map((Y) => ({
      hash: Y.hash,
      index: Y.index,
      script: Y.script,
      sequence: Y.sequence,
      witness: Y.witness
    })), z.outs = this.outs.map((Y) => ({
      script: Y.script,
      value: Y.value
    })), z;
  }
  /**
   * Hash transaction for signing a specific input.
   *
   * Bitcoin uses a different hash for each signed transaction input.
   * This method copies the transaction, makes the necessary changes based on the
   * hashType, and then hashes the result.
   * This hash can then be used to sign the provided transaction input.
   */
  hashForSignature(z, Y, ie) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        types$1.Buffer,
        /* types.UInt8 */
        types$1.Number
      ),
      arguments
    ), z >= this.ins.length) return ONE;
    const se = bscript$2.compile(
      bscript$2.decompile(Y).filter((le) => le !== script_1.OPS.OP_CODESEPARATOR)
    ), ne = this.clone();
    if ((ie & 31) === Transaction.SIGHASH_NONE)
      ne.outs = [], ne.ins.forEach((le, ge) => {
        ge !== z && (le.sequence = 0);
      });
    else if ((ie & 31) === Transaction.SIGHASH_SINGLE) {
      if (z >= this.outs.length) return ONE;
      ne.outs.length = z + 1;
      for (let le = 0; le < z; le++)
        ne.outs[le] = BLANK_OUTPUT;
      ne.ins.forEach((le, ge) => {
        ge !== z && (le.sequence = 0);
      });
    }
    ie & Transaction.SIGHASH_ANYONECANPAY ? (ne.ins = [ne.ins[z]], ne.ins[0].script = se) : (ne.ins.forEach((le) => {
      le.script = EMPTY_BUFFER;
    }), ne.ins[z].script = se);
    const ae = Buffer$1.allocUnsafe(ne.byteLength(!1) + 4);
    return ae.writeInt32LE(ie, ae.length - 4), ne.__toBuffer(ae, 0, !1), bcrypto$1.hash256(ae);
  }
  hashForWitnessV1(z, Y, ie, se, ne, ae) {
    if (typeforce$1(
      types$1.tuple(
        types$1.UInt32,
        typeforce$1.arrayOf(types$1.Buffer),
        typeforce$1.arrayOf(types$1.Satoshi),
        types$1.UInt32
      ),
      arguments
    ), ie.length !== this.ins.length || Y.length !== this.ins.length)
      throw new Error("Must supply prevout script and value for all inputs");
    const le = se === Transaction.SIGHASH_DEFAULT ? Transaction.SIGHASH_ALL : se & Transaction.SIGHASH_OUTPUT_MASK, Ee = (se & Transaction.SIGHASH_INPUT_MASK) === Transaction.SIGHASH_ANYONECANPAY, oe = le === Transaction.SIGHASH_NONE, Pe = le === Transaction.SIGHASH_SINGLE;
    let Ve = EMPTY_BUFFER, Ke = EMPTY_BUFFER, ht = EMPTY_BUFFER, _t = EMPTY_BUFFER, Rt = EMPTY_BUFFER;
    if (!Ee) {
      let qt = bufferutils_1$2.BufferWriter.withCapacity(
        36 * this.ins.length
      );
      this.ins.forEach((jt) => {
        qt.writeSlice(jt.hash), qt.writeUInt32(jt.index);
      }), Ve = bcrypto$1.sha256(qt.end()), qt = bufferutils_1$2.BufferWriter.withCapacity(
        8 * this.ins.length
      ), ie.forEach((jt) => qt.writeUInt64(jt)), Ke = bcrypto$1.sha256(qt.end()), qt = bufferutils_1$2.BufferWriter.withCapacity(
        Y.map(varSliceSize).reduce((jt, Ht) => jt + Ht)
      ), Y.forEach(
        (jt) => qt.writeVarSlice(jt)
      ), ht = bcrypto$1.sha256(qt.end()), qt = bufferutils_1$2.BufferWriter.withCapacity(
        4 * this.ins.length
      ), this.ins.forEach((jt) => qt.writeUInt32(jt.sequence)), _t = bcrypto$1.sha256(qt.end());
    }
    if (oe || Pe) {
      if (Pe && z < this.outs.length) {
        const qt = this.outs[z], jt = bufferutils_1$2.BufferWriter.withCapacity(
          8 + varSliceSize(qt.script)
        );
        jt.writeUInt64(qt.value), jt.writeVarSlice(qt.script), Rt = bcrypto$1.sha256(jt.end());
      }
    } else {
      const qt = this.outs.map((Ht) => 8 + varSliceSize(Ht.script)).reduce((Ht, Yt) => Ht + Yt), jt = bufferutils_1$2.BufferWriter.withCapacity(qt);
      this.outs.forEach((Ht) => {
        jt.writeUInt64(Ht.value), jt.writeVarSlice(Ht.script);
      }), Rt = bcrypto$1.sha256(jt.end());
    }
    const kt = (ne ? 2 : 0) + (ae ? 1 : 0), Bt = 174 - (Ee ? 49 : 0) - (oe ? 32 : 0) + (ae ? 32 : 0) + (ne ? 37 : 0), Ct = bufferutils_1$2.BufferWriter.withCapacity(Bt);
    if (Ct.writeUInt8(se), Ct.writeInt32(this.version), Ct.writeUInt32(this.locktime), Ct.writeSlice(Ve), Ct.writeSlice(Ke), Ct.writeSlice(ht), Ct.writeSlice(_t), oe || Pe || Ct.writeSlice(Rt), Ct.writeUInt8(kt), Ee) {
      const qt = this.ins[z];
      Ct.writeSlice(qt.hash), Ct.writeUInt32(qt.index), Ct.writeUInt64(ie[z]), Ct.writeVarSlice(Y[z]), Ct.writeUInt32(qt.sequence);
    } else
      Ct.writeUInt32(z);
    if (ae) {
      const qt = bufferutils_1$2.BufferWriter.withCapacity(
        varSliceSize(ae)
      );
      qt.writeVarSlice(ae), Ct.writeSlice(bcrypto$1.sha256(qt.end()));
    }
    return Pe && Ct.writeSlice(Rt), ne && (Ct.writeSlice(ne), Ct.writeUInt8(0), Ct.writeUInt32(4294967295)), bcrypto$1.taggedHash(
      "TapSighash",
      Buffer$1.concat([Buffer$1.from([0]), Ct.end()])
    );
  }
  hashForWitnessV0(z, Y, ie, se) {
    typeforce$1(
      types$1.tuple(types$1.UInt32, types$1.Buffer, types$1.Satoshi, types$1.UInt32),
      arguments
    );
    let ne = Buffer$1.from([]), ae, le = ZERO, ge = ZERO, Ee = ZERO;
    if (se & Transaction.SIGHASH_ANYONECANPAY || (ne = Buffer$1.allocUnsafe(36 * this.ins.length), ae = new bufferutils_1$2.BufferWriter(ne, 0), this.ins.forEach((Pe) => {
      ae.writeSlice(Pe.hash), ae.writeUInt32(Pe.index);
    }), ge = bcrypto$1.hash256(ne)), !(se & Transaction.SIGHASH_ANYONECANPAY) && (se & 31) !== Transaction.SIGHASH_SINGLE && (se & 31) !== Transaction.SIGHASH_NONE && (ne = Buffer$1.allocUnsafe(4 * this.ins.length), ae = new bufferutils_1$2.BufferWriter(ne, 0), this.ins.forEach((Pe) => {
      ae.writeUInt32(Pe.sequence);
    }), Ee = bcrypto$1.hash256(ne)), (se & 31) !== Transaction.SIGHASH_SINGLE && (se & 31) !== Transaction.SIGHASH_NONE) {
      const Pe = this.outs.reduce((Ve, Ke) => Ve + 8 + varSliceSize(Ke.script), 0);
      ne = Buffer$1.allocUnsafe(Pe), ae = new bufferutils_1$2.BufferWriter(ne, 0), this.outs.forEach((Ve) => {
        ae.writeUInt64(Ve.value), ae.writeVarSlice(Ve.script);
      }), le = bcrypto$1.hash256(ne);
    } else if ((se & 31) === Transaction.SIGHASH_SINGLE && z < this.outs.length) {
      const Pe = this.outs[z];
      ne = Buffer$1.allocUnsafe(8 + varSliceSize(Pe.script)), ae = new bufferutils_1$2.BufferWriter(ne, 0), ae.writeUInt64(Pe.value), ae.writeVarSlice(Pe.script), le = bcrypto$1.hash256(ne);
    }
    ne = Buffer$1.allocUnsafe(156 + varSliceSize(Y)), ae = new bufferutils_1$2.BufferWriter(ne, 0);
    const oe = this.ins[z];
    return ae.writeInt32(this.version), ae.writeSlice(ge), ae.writeSlice(Ee), ae.writeSlice(oe.hash), ae.writeUInt32(oe.index), ae.writeVarSlice(Y), ae.writeUInt64(ie), ae.writeUInt32(oe.sequence), ae.writeSlice(le), ae.writeUInt32(this.locktime), ae.writeUInt32(se), bcrypto$1.hash256(ne);
  }
  getHash(z) {
    return z && this.isCoinbase() ? Buffer$1.alloc(32, 0) : bcrypto$1.hash256(this.__toBuffer(void 0, void 0, z));
  }
  getId() {
    return (0, bufferutils_1$2.reverseBuffer)(this.getHash(!1)).toString(
      "hex"
    );
  }
  toBuffer(z, Y) {
    return this.__toBuffer(z, Y, !0);
  }
  toHex() {
    return this.toBuffer(void 0, void 0).toString("hex");
  }
  setInputScript(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, types$1.Buffer), arguments), this.ins[z].script = Y;
  }
  setWitness(z, Y) {
    typeforce$1(types$1.tuple(types$1.Number, [types$1.Buffer]), arguments), this.ins[z].witness = Y;
  }
  __toBuffer(z, Y, ie = !1) {
    z || (z = Buffer$1.allocUnsafe(this.byteLength(ie)));
    const se = new bufferutils_1$2.BufferWriter(
      z,
      Y || 0
    );
    se.writeInt32(this.version);
    const ne = ie && this.hasWitnesses();
    return ne && (se.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER), se.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG)), se.writeVarInt(this.ins.length), this.ins.forEach((ae) => {
      se.writeSlice(ae.hash), se.writeUInt32(ae.index), se.writeVarSlice(ae.script), se.writeUInt32(ae.sequence);
    }), se.writeVarInt(this.outs.length), this.outs.forEach((ae) => {
      isOutput(ae) ? se.writeUInt64(ae.value) : se.writeSlice(ae.valueBuffer), se.writeVarSlice(ae.script);
    }), ne && this.ins.forEach((ae) => {
      se.writeVector(ae.witness);
    }), se.writeUInt32(this.locktime), Y !== void 0 ? z.slice(Y, se.offset) : z;
  }
}
transaction.Transaction = Transaction;
Transaction.DEFAULT_SEQUENCE = 4294967295;
Transaction.SIGHASH_DEFAULT = 0;
Transaction.SIGHASH_ALL = 1;
Transaction.SIGHASH_NONE = 2;
Transaction.SIGHASH_SINGLE = 3;
Transaction.SIGHASH_ANYONECANPAY = 128;
Transaction.SIGHASH_OUTPUT_MASK = 3;
Transaction.SIGHASH_INPUT_MASK = 128;
Transaction.ADVANCED_TRANSACTION_MARKER = 0;
Transaction.ADVANCED_TRANSACTION_FLAG = 1;
Object.defineProperty(block, "__esModule", { value: !0 });
block.Block = void 0;
const bufferutils_1$1 = bufferutils, bcrypto = crypto$1, merkle_1 = merkle, transaction_1$3 = transaction, types = types$4, { typeforce } = types, errorMerkleNoTxes = new TypeError(
  "Cannot compute merkle root for zero transactions"
), errorWitnessNotSegwit = new TypeError(
  "Cannot compute witness commit for non-segwit block"
);
class Block {
  constructor() {
    this.version = 1, this.prevHash = void 0, this.merkleRoot = void 0, this.timestamp = 0, this.witnessCommit = void 0, this.bits = 0, this.nonce = 0, this.transactions = void 0;
  }
  static fromBuffer(z) {
    if (z.length < 80) throw new Error("Buffer too small (< 80 bytes)");
    const Y = new bufferutils_1$1.BufferReader(z), ie = new Block();
    if (ie.version = Y.readInt32(), ie.prevHash = Y.readSlice(32), ie.merkleRoot = Y.readSlice(32), ie.timestamp = Y.readUInt32(), ie.bits = Y.readUInt32(), ie.nonce = Y.readUInt32(), z.length === 80) return ie;
    const se = () => {
      const le = transaction_1$3.Transaction.fromBuffer(
        Y.buffer.slice(Y.offset),
        !0
      );
      return Y.offset += le.byteLength(), le;
    }, ne = Y.readVarInt();
    ie.transactions = [];
    for (let le = 0; le < ne; ++le) {
      const ge = se();
      ie.transactions.push(ge);
    }
    const ae = ie.getWitnessCommit();
    return ae && (ie.witnessCommit = ae), ie;
  }
  static fromHex(z) {
    return Block.fromBuffer(Buffer$1.from(z, "hex"));
  }
  static calculateTarget(z) {
    const Y = ((z & 4278190080) >> 24) - 3, ie = z & 8388607, se = Buffer$1.alloc(32, 0);
    return se.writeUIntBE(ie, 29 - Y, 3), se;
  }
  static calculateMerkleRoot(z, Y) {
    if (typeforce([{ getHash: types.Function }], z), z.length === 0) throw errorMerkleNoTxes;
    if (Y && !txesHaveWitnessCommit(z))
      throw errorWitnessNotSegwit;
    const ie = z.map(
      (ne) => ne.getHash(Y)
    ), se = (0, merkle_1.fastMerkleRoot)(ie, bcrypto.hash256);
    return Y ? bcrypto.hash256(
      Buffer$1.concat([se, z[0].ins[0].witness[0]])
    ) : se;
  }
  getWitnessCommit() {
    if (!txesHaveWitnessCommit(this.transactions)) return null;
    const z = this.transactions[0].outs.filter(
      (ie) => ie.script.slice(0, 6).equals(Buffer$1.from("6a24aa21a9ed", "hex"))
    ).map((ie) => ie.script.slice(6, 38));
    if (z.length === 0) return null;
    const Y = z[z.length - 1];
    return Y instanceof Buffer$1 && Y.length === 32 ? Y : null;
  }
  hasWitnessCommit() {
    return this.witnessCommit instanceof Buffer$1 && this.witnessCommit.length === 32 || this.getWitnessCommit() !== null;
  }
  hasWitness() {
    return anyTxHasWitness(this.transactions);
  }
  weight() {
    const z = this.byteLength(!1, !1), Y = this.byteLength(!1, !0);
    return z * 3 + Y;
  }
  byteLength(z, Y = !0) {
    return z || !this.transactions ? 80 : 80 + bufferutils_1$1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((ie, se) => ie + se.byteLength(Y), 0);
  }
  getHash() {
    return bcrypto.hash256(this.toBuffer(!0));
  }
  getId() {
    return (0, bufferutils_1$1.reverseBuffer)(this.getHash()).toString("hex");
  }
  getUTCDate() {
    const z = /* @__PURE__ */ new Date(0);
    return z.setUTCSeconds(this.timestamp), z;
  }
  // TODO: buffer, offset compatibility
  toBuffer(z) {
    const Y = Buffer$1.allocUnsafe(this.byteLength(z)), ie = new bufferutils_1$1.BufferWriter(Y);
    return ie.writeInt32(this.version), ie.writeSlice(this.prevHash), ie.writeSlice(this.merkleRoot), ie.writeUInt32(this.timestamp), ie.writeUInt32(this.bits), ie.writeUInt32(this.nonce), z || !this.transactions || (bufferutils_1$1.varuint.encode(
      this.transactions.length,
      Y,
      ie.offset
    ), ie.offset += bufferutils_1$1.varuint.encode.bytes, this.transactions.forEach((se) => {
      const ne = se.byteLength();
      se.toBuffer(Y, ie.offset), ie.offset += ne;
    })), Y;
  }
  toHex(z) {
    return this.toBuffer(z).toString("hex");
  }
  checkTxRoots() {
    const z = this.hasWitnessCommit();
    return !z && this.hasWitness() ? !1 : this.__checkMerkleRoot() && (z ? this.__checkWitnessCommit() : !0);
  }
  checkProofOfWork() {
    const z = (0, bufferutils_1$1.reverseBuffer)(this.getHash()), Y = Block.calculateTarget(this.bits);
    return z.compare(Y) <= 0;
  }
  __checkMerkleRoot() {
    if (!this.transactions) throw errorMerkleNoTxes;
    const z = Block.calculateMerkleRoot(this.transactions);
    return this.merkleRoot.compare(z) === 0;
  }
  __checkWitnessCommit() {
    if (!this.transactions) throw errorMerkleNoTxes;
    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
    const z = Block.calculateMerkleRoot(
      this.transactions,
      !0
    );
    return this.witnessCommit.compare(z) === 0;
  }
}
block.Block = Block;
function txesHaveWitnessCommit(B) {
  return B instanceof Array && B[0] && B[0].ins && B[0].ins instanceof Array && B[0].ins[0] && B[0].ins[0].witness && B[0].ins[0].witness instanceof Array && B[0].ins[0].witness.length > 0;
}
function anyTxHasWitness(B) {
  return B instanceof Array && B.some(
    (z) => typeof z == "object" && z.ins instanceof Array && z.ins.some(
      (Y) => typeof Y == "object" && Y.witness instanceof Array && Y.witness.length > 0
    )
  );
}
var psbt$1 = {}, psbt = {}, combiner = {}, parser = {}, fromBuffer = {}, converter = {}, typeFields = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), function(z) {
    z[z.UNSIGNED_TX = 0] = "UNSIGNED_TX", z[z.GLOBAL_XPUB = 1] = "GLOBAL_XPUB";
  }(B.GlobalTypes || (B.GlobalTypes = {})), B.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"], function(z) {
    z[z.NON_WITNESS_UTXO = 0] = "NON_WITNESS_UTXO", z[z.WITNESS_UTXO = 1] = "WITNESS_UTXO", z[z.PARTIAL_SIG = 2] = "PARTIAL_SIG", z[z.SIGHASH_TYPE = 3] = "SIGHASH_TYPE", z[z.REDEEM_SCRIPT = 4] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 5] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 6] = "BIP32_DERIVATION", z[z.FINAL_SCRIPTSIG = 7] = "FINAL_SCRIPTSIG", z[z.FINAL_SCRIPTWITNESS = 8] = "FINAL_SCRIPTWITNESS", z[z.POR_COMMITMENT = 9] = "POR_COMMITMENT", z[z.TAP_KEY_SIG = 19] = "TAP_KEY_SIG", z[z.TAP_SCRIPT_SIG = 20] = "TAP_SCRIPT_SIG", z[z.TAP_LEAF_SCRIPT = 21] = "TAP_LEAF_SCRIPT", z[z.TAP_BIP32_DERIVATION = 22] = "TAP_BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 23] = "TAP_INTERNAL_KEY", z[z.TAP_MERKLE_ROOT = 24] = "TAP_MERKLE_ROOT";
  }(B.InputTypes || (B.InputTypes = {})), B.INPUT_TYPE_NAMES = [
    "nonWitnessUtxo",
    "witnessUtxo",
    "partialSig",
    "sighashType",
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "finalScriptSig",
    "finalScriptWitness",
    "porCommitment",
    "tapKeySig",
    "tapScriptSig",
    "tapLeafScript",
    "tapBip32Derivation",
    "tapInternalKey",
    "tapMerkleRoot"
  ], function(z) {
    z[z.REDEEM_SCRIPT = 0] = "REDEEM_SCRIPT", z[z.WITNESS_SCRIPT = 1] = "WITNESS_SCRIPT", z[z.BIP32_DERIVATION = 2] = "BIP32_DERIVATION", z[z.TAP_INTERNAL_KEY = 5] = "TAP_INTERNAL_KEY", z[z.TAP_TREE = 6] = "TAP_TREE", z[z.TAP_BIP32_DERIVATION = 7] = "TAP_BIP32_DERIVATION";
  }(B.OutputTypes || (B.OutputTypes = {})), B.OUTPUT_TYPE_NAMES = [
    "redeemScript",
    "witnessScript",
    "bip32Derivation",
    "tapInternalKey",
    "tapTree",
    "tapBip32Derivation"
  ];
})(typeFields);
var globalXpub$1 = {};
Object.defineProperty(globalXpub$1, "__esModule", { value: !0 });
const typeFields_1$g = typeFields, range$2 = (B) => [...Array(B).keys()];
function decode$d(B) {
  if (B.key[0] !== typeFields_1$g.GlobalTypes.GLOBAL_XPUB)
    throw new Error(
      "Decode Error: could not decode globalXpub with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 79 || ![2, 3].includes(B.key[46]))
    throw new Error(
      "Decode Error: globalXpub has invalid extended pubkey in key 0x" + B.key.toString("hex")
    );
  if (B.value.length / 4 % 1 !== 0)
    throw new Error(
      "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
    );
  const z = B.key.slice(1), Y = {
    masterFingerprint: B.value.slice(0, 4),
    extendedPubkey: z,
    path: "m"
  };
  for (const ie of range$2(B.value.length / 4 - 1)) {
    const se = B.value.readUInt32LE(ie * 4 + 4), ne = !!(se & 2147483648), ae = se & 2147483647;
    Y.path += "/" + ae.toString(10) + (ne ? "'" : "");
  }
  return Y;
}
globalXpub$1.decode = decode$d;
function encode$e(B) {
  const z = Buffer$1.from([typeFields_1$g.GlobalTypes.GLOBAL_XPUB]), Y = Buffer$1.concat([z, B.extendedPubkey]), ie = B.path.split("/"), se = Buffer$1.allocUnsafe(ie.length * 4);
  B.masterFingerprint.copy(se, 0);
  let ne = 4;
  return ie.slice(1).forEach((ae) => {
    const le = ae.slice(-1) === "'";
    let ge = 2147483647 & parseInt(le ? ae.slice(0, -1) : ae, 10);
    le && (ge += 2147483648), se.writeUInt32LE(ge, ne), ne += 4;
  }), {
    key: Y,
    value: se
  };
}
globalXpub$1.encode = encode$e;
globalXpub$1.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
function check$c(B) {
  const z = B.extendedPubkey, Y = B.masterFingerprint, ie = B.path;
  return Buffer$1.isBuffer(z) && z.length === 78 && [2, 3].indexOf(z[45]) > -1 && Buffer$1.isBuffer(Y) && Y.length === 4 && typeof ie == "string" && !!ie.match(/^m(\/\d+'?)*$/);
}
globalXpub$1.check = check$c;
function canAddToArray$3(B, z, Y) {
  const ie = z.extendedPubkey.toString("hex");
  return Y.has(ie) ? !1 : (Y.add(ie), B.filter((se) => se.extendedPubkey.equals(z.extendedPubkey)).length === 0);
}
globalXpub$1.canAddToArray = canAddToArray$3;
var unsignedTx$1 = {};
Object.defineProperty(unsignedTx$1, "__esModule", { value: !0 });
const typeFields_1$f = typeFields;
function encode$d(B) {
  return {
    key: Buffer$1.from([typeFields_1$f.GlobalTypes.UNSIGNED_TX]),
    value: B.toBuffer()
  };
}
unsignedTx$1.encode = encode$d;
var finalScriptSig$1 = {};
Object.defineProperty(finalScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$e = typeFields;
function decode$c(B) {
  if (B.key[0] !== typeFields_1$e.InputTypes.FINAL_SCRIPTSIG)
    throw new Error(
      "Decode Error: could not decode finalScriptSig with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptSig$1.decode = decode$c;
function encode$c(B) {
  return {
    key: Buffer$1.from([typeFields_1$e.InputTypes.FINAL_SCRIPTSIG]),
    value: B
  };
}
finalScriptSig$1.encode = encode$c;
finalScriptSig$1.expected = "Buffer";
function check$b(B) {
  return Buffer$1.isBuffer(B);
}
finalScriptSig$1.check = check$b;
function canAdd$8(B, z) {
  return !!B && !!z && B.finalScriptSig === void 0;
}
finalScriptSig$1.canAdd = canAdd$8;
var finalScriptWitness$1 = {};
Object.defineProperty(finalScriptWitness$1, "__esModule", { value: !0 });
const typeFields_1$d = typeFields;
function decode$b(B) {
  if (B.key[0] !== typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS)
    throw new Error(
      "Decode Error: could not decode finalScriptWitness with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
finalScriptWitness$1.decode = decode$b;
function encode$b(B) {
  return {
    key: Buffer$1.from([typeFields_1$d.InputTypes.FINAL_SCRIPTWITNESS]),
    value: B
  };
}
finalScriptWitness$1.encode = encode$b;
finalScriptWitness$1.expected = "Buffer";
function check$a(B) {
  return Buffer$1.isBuffer(B);
}
finalScriptWitness$1.check = check$a;
function canAdd$7(B, z) {
  return !!B && !!z && B.finalScriptWitness === void 0;
}
finalScriptWitness$1.canAdd = canAdd$7;
var nonWitnessUtxo$1 = {};
Object.defineProperty(nonWitnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$c = typeFields;
function decode$a(B) {
  if (B.key[0] !== typeFields_1$c.InputTypes.NON_WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode nonWitnessUtxo with key 0x" + B.key.toString("hex")
    );
  return B.value;
}
nonWitnessUtxo$1.decode = decode$a;
function encode$a(B) {
  return {
    key: Buffer$1.from([typeFields_1$c.InputTypes.NON_WITNESS_UTXO]),
    value: B
  };
}
nonWitnessUtxo$1.encode = encode$a;
nonWitnessUtxo$1.expected = "Buffer";
function check$9(B) {
  return Buffer$1.isBuffer(B);
}
nonWitnessUtxo$1.check = check$9;
function canAdd$6(B, z) {
  return !!B && !!z && B.nonWitnessUtxo === void 0;
}
nonWitnessUtxo$1.canAdd = canAdd$6;
var partialSig$1 = {};
Object.defineProperty(partialSig$1, "__esModule", { value: !0 });
const typeFields_1$b = typeFields;
function decode$9(B) {
  if (B.key[0] !== typeFields_1$b.InputTypes.PARTIAL_SIG)
    throw new Error(
      "Decode Error: could not decode partialSig with key 0x" + B.key.toString("hex")
    );
  if (!(B.key.length === 34 || B.key.length === 66) || ![2, 3, 4].includes(B.key[1]))
    throw new Error(
      "Decode Error: partialSig has invalid pubkey in key 0x" + B.key.toString("hex")
    );
  return {
    pubkey: B.key.slice(1),
    signature: B.value
  };
}
partialSig$1.decode = decode$9;
function encode$9(B) {
  const z = Buffer$1.from([typeFields_1$b.InputTypes.PARTIAL_SIG]);
  return {
    key: Buffer$1.concat([z, B.pubkey]),
    value: B.signature
  };
}
partialSig$1.encode = encode$9;
partialSig$1.expected = "{ pubkey: Buffer; signature: Buffer; }";
function check$8(B) {
  return Buffer$1.isBuffer(B.pubkey) && Buffer$1.isBuffer(B.signature) && [33, 65].includes(B.pubkey.length) && [2, 3, 4].includes(B.pubkey[0]) && isDerSigWithSighash(B.signature);
}
partialSig$1.check = check$8;
function isDerSigWithSighash(B) {
  if (!Buffer$1.isBuffer(B) || B.length < 9 || B[0] !== 48 || B.length !== B[1] + 3 || B[2] !== 2) return !1;
  const z = B[3];
  if (z > 33 || z < 1 || B[3 + z + 1] !== 2) return !1;
  const Y = B[3 + z + 2];
  return !(Y > 33 || Y < 1 || B.length !== 3 + z + 2 + Y + 2);
}
function canAddToArray$2(B, z, Y) {
  const ie = z.pubkey.toString("hex");
  return Y.has(ie) ? !1 : (Y.add(ie), B.filter((se) => se.pubkey.equals(z.pubkey)).length === 0);
}
partialSig$1.canAddToArray = canAddToArray$2;
var porCommitment$1 = {};
Object.defineProperty(porCommitment$1, "__esModule", { value: !0 });
const typeFields_1$a = typeFields;
function decode$8(B) {
  if (B.key[0] !== typeFields_1$a.InputTypes.POR_COMMITMENT)
    throw new Error(
      "Decode Error: could not decode porCommitment with key 0x" + B.key.toString("hex")
    );
  return B.value.toString("utf8");
}
porCommitment$1.decode = decode$8;
function encode$8(B) {
  return {
    key: Buffer$1.from([typeFields_1$a.InputTypes.POR_COMMITMENT]),
    value: Buffer$1.from(B, "utf8")
  };
}
porCommitment$1.encode = encode$8;
porCommitment$1.expected = "string";
function check$7(B) {
  return typeof B == "string";
}
porCommitment$1.check = check$7;
function canAdd$5(B, z) {
  return !!B && !!z && B.porCommitment === void 0;
}
porCommitment$1.canAdd = canAdd$5;
var sighashType$1 = {};
Object.defineProperty(sighashType$1, "__esModule", { value: !0 });
const typeFields_1$9 = typeFields;
function decode$7(B) {
  if (B.key[0] !== typeFields_1$9.InputTypes.SIGHASH_TYPE)
    throw new Error(
      "Decode Error: could not decode sighashType with key 0x" + B.key.toString("hex")
    );
  return B.value.readUInt32LE(0);
}
sighashType$1.decode = decode$7;
function encode$7(B) {
  const z = Buffer$1.from([typeFields_1$9.InputTypes.SIGHASH_TYPE]), Y = Buffer$1.allocUnsafe(4);
  return Y.writeUInt32LE(B, 0), {
    key: z,
    value: Y
  };
}
sighashType$1.encode = encode$7;
sighashType$1.expected = "number";
function check$6(B) {
  return typeof B == "number";
}
sighashType$1.check = check$6;
function canAdd$4(B, z) {
  return !!B && !!z && B.sighashType === void 0;
}
sighashType$1.canAdd = canAdd$4;
var tapKeySig$1 = {};
Object.defineProperty(tapKeySig$1, "__esModule", { value: !0 });
const typeFields_1$8 = typeFields;
function decode$6(B) {
  if (B.key[0] !== typeFields_1$8.InputTypes.TAP_KEY_SIG || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapKeySig with key 0x" + B.key.toString("hex")
    );
  if (!check$5(B.value))
    throw new Error(
      "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
    );
  return B.value;
}
tapKeySig$1.decode = decode$6;
function encode$6(B) {
  return { key: Buffer$1.from([typeFields_1$8.InputTypes.TAP_KEY_SIG]), value: B };
}
tapKeySig$1.encode = encode$6;
tapKeySig$1.expected = "Buffer";
function check$5(B) {
  return Buffer$1.isBuffer(B) && (B.length === 64 || B.length === 65);
}
tapKeySig$1.check = check$5;
function canAdd$3(B, z) {
  return !!B && !!z && B.tapKeySig === void 0;
}
tapKeySig$1.canAdd = canAdd$3;
var tapLeafScript$1 = {};
Object.defineProperty(tapLeafScript$1, "__esModule", { value: !0 });
const typeFields_1$7 = typeFields;
function decode$5(B) {
  if (B.key[0] !== typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT)
    throw new Error(
      "Decode Error: could not decode tapLeafScript with key 0x" + B.key.toString("hex")
    );
  if ((B.key.length - 2) % 32 !== 0)
    throw new Error(
      "Decode Error: tapLeafScript has invalid control block in key 0x" + B.key.toString("hex")
    );
  const z = B.value[B.value.length - 1];
  if ((B.key[1] & 254) !== z)
    throw new Error(
      "Decode Error: tapLeafScript bad leaf version in key 0x" + B.key.toString("hex")
    );
  const Y = B.value.slice(0, -1);
  return { controlBlock: B.key.slice(1), script: Y, leafVersion: z };
}
tapLeafScript$1.decode = decode$5;
function encode$5(B) {
  const z = Buffer$1.from([typeFields_1$7.InputTypes.TAP_LEAF_SCRIPT]), Y = Buffer$1.from([B.leafVersion]);
  return {
    key: Buffer$1.concat([z, B.controlBlock]),
    value: Buffer$1.concat([B.script, Y])
  };
}
tapLeafScript$1.encode = encode$5;
tapLeafScript$1.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
function check$4(B) {
  return Buffer$1.isBuffer(B.controlBlock) && (B.controlBlock.length - 1) % 32 === 0 && (B.controlBlock[0] & 254) === B.leafVersion && Buffer$1.isBuffer(B.script);
}
tapLeafScript$1.check = check$4;
function canAddToArray$1(B, z, Y) {
  const ie = z.controlBlock.toString("hex");
  return Y.has(ie) ? !1 : (Y.add(ie), B.filter((se) => se.controlBlock.equals(z.controlBlock)).length === 0);
}
tapLeafScript$1.canAddToArray = canAddToArray$1;
var tapMerkleRoot$1 = {};
Object.defineProperty(tapMerkleRoot$1, "__esModule", { value: !0 });
const typeFields_1$6 = typeFields;
function decode$4(B) {
  if (B.key[0] !== typeFields_1$6.InputTypes.TAP_MERKLE_ROOT || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapMerkleRoot with key 0x" + B.key.toString("hex")
    );
  if (!check$3(B.value))
    throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
  return B.value;
}
tapMerkleRoot$1.decode = decode$4;
function encode$4(B) {
  return { key: Buffer$1.from([typeFields_1$6.InputTypes.TAP_MERKLE_ROOT]), value: B };
}
tapMerkleRoot$1.encode = encode$4;
tapMerkleRoot$1.expected = "Buffer";
function check$3(B) {
  return Buffer$1.isBuffer(B) && B.length === 32;
}
tapMerkleRoot$1.check = check$3;
function canAdd$2(B, z) {
  return !!B && !!z && B.tapMerkleRoot === void 0;
}
tapMerkleRoot$1.canAdd = canAdd$2;
var tapScriptSig$1 = {};
Object.defineProperty(tapScriptSig$1, "__esModule", { value: !0 });
const typeFields_1$5 = typeFields;
function decode$3(B) {
  if (B.key[0] !== typeFields_1$5.InputTypes.TAP_SCRIPT_SIG)
    throw new Error(
      "Decode Error: could not decode tapScriptSig with key 0x" + B.key.toString("hex")
    );
  if (B.key.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid key 0x" + B.key.toString("hex")
    );
  if (B.value.length !== 64 && B.value.length !== 65)
    throw new Error(
      "Decode Error: tapScriptSig has invalid signature in key 0x" + B.key.toString("hex")
    );
  const z = B.key.slice(1, 33), Y = B.key.slice(33);
  return {
    pubkey: z,
    leafHash: Y,
    signature: B.value
  };
}
tapScriptSig$1.decode = decode$3;
function encode$3(B) {
  const z = Buffer$1.from([typeFields_1$5.InputTypes.TAP_SCRIPT_SIG]);
  return {
    key: Buffer$1.concat([z, B.pubkey, B.leafHash]),
    value: B.signature
  };
}
tapScriptSig$1.encode = encode$3;
tapScriptSig$1.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
function check$2(B) {
  return Buffer$1.isBuffer(B.pubkey) && Buffer$1.isBuffer(B.leafHash) && Buffer$1.isBuffer(B.signature) && B.pubkey.length === 32 && B.leafHash.length === 32 && (B.signature.length === 64 || B.signature.length === 65);
}
tapScriptSig$1.check = check$2;
function canAddToArray(B, z, Y) {
  const ie = z.pubkey.toString("hex") + z.leafHash.toString("hex");
  return Y.has(ie) ? !1 : (Y.add(ie), B.filter(
    (se) => se.pubkey.equals(z.pubkey) && se.leafHash.equals(z.leafHash)
  ).length === 0);
}
tapScriptSig$1.canAddToArray = canAddToArray;
var witnessUtxo$1 = {}, tools = {}, varint = {};
Object.defineProperty(varint, "__esModule", { value: !0 });
const MAX_SAFE_INTEGER = 9007199254740991;
function checkUInt53(B) {
  if (B < 0 || B > MAX_SAFE_INTEGER || B % 1 !== 0)
    throw new RangeError("value out of range");
}
function encode$2(B, z, Y) {
  if (checkUInt53(B), z || (z = Buffer$1.allocUnsafe(encodingLength(B))), !Buffer$1.isBuffer(z))
    throw new TypeError("buffer must be a Buffer instance");
  return Y || (Y = 0), B < 253 ? (z.writeUInt8(B, Y), Object.assign(encode$2, { bytes: 1 })) : B <= 65535 ? (z.writeUInt8(253, Y), z.writeUInt16LE(B, Y + 1), Object.assign(encode$2, { bytes: 3 })) : B <= 4294967295 ? (z.writeUInt8(254, Y), z.writeUInt32LE(B, Y + 1), Object.assign(encode$2, { bytes: 5 })) : (z.writeUInt8(255, Y), z.writeUInt32LE(B >>> 0, Y + 1), z.writeUInt32LE(B / 4294967296 | 0, Y + 5), Object.assign(encode$2, { bytes: 9 })), z;
}
varint.encode = encode$2;
function decode$2(B, z) {
  if (!Buffer$1.isBuffer(B))
    throw new TypeError("buffer must be a Buffer instance");
  z || (z = 0);
  const Y = B.readUInt8(z);
  if (Y < 253)
    return Object.assign(decode$2, { bytes: 1 }), Y;
  if (Y === 253)
    return Object.assign(decode$2, { bytes: 3 }), B.readUInt16LE(z + 1);
  if (Y === 254)
    return Object.assign(decode$2, { bytes: 5 }), B.readUInt32LE(z + 1);
  {
    Object.assign(decode$2, { bytes: 9 });
    const ie = B.readUInt32LE(z + 1), ne = B.readUInt32LE(z + 5) * 4294967296 + ie;
    return checkUInt53(ne), ne;
  }
}
varint.decode = decode$2;
function encodingLength(B) {
  return checkUInt53(B), B < 253 ? 1 : B <= 65535 ? 3 : B <= 4294967295 ? 5 : 9;
}
varint.encodingLength = encodingLength;
Object.defineProperty(tools, "__esModule", { value: !0 });
const varuint$6 = varint;
tools.range = (B) => [...Array(B).keys()];
function reverseBuffer(B) {
  if (B.length < 1) return B;
  let z = B.length - 1, Y = 0;
  for (let ie = 0; ie < B.length / 2; ie++)
    Y = B[ie], B[ie] = B[z], B[z] = Y, z--;
  return B;
}
tools.reverseBuffer = reverseBuffer;
function keyValsToBuffer(B) {
  const z = B.map(keyValToBuffer);
  return z.push(Buffer$1.from([0])), Buffer$1.concat(z);
}
tools.keyValsToBuffer = keyValsToBuffer;
function keyValToBuffer(B) {
  const z = B.key.length, Y = B.value.length, ie = varuint$6.encodingLength(z), se = varuint$6.encodingLength(Y), ne = Buffer$1.allocUnsafe(
    ie + z + se + Y
  );
  return varuint$6.encode(z, ne, 0), B.key.copy(ne, ie), varuint$6.encode(Y, ne, ie + z), B.value.copy(ne, ie + z + se), ne;
}
tools.keyValToBuffer = keyValToBuffer;
function verifuint(B, z) {
  if (typeof B != "number")
    throw new Error("cannot write a non-number as a number");
  if (B < 0)
    throw new Error("specified a negative value for writing an unsigned value");
  if (B > z) throw new Error("RangeError: value out of range");
  if (Math.floor(B) !== B)
    throw new Error("value has a fractional component");
}
function readUInt64LE(B, z) {
  const Y = B.readUInt32LE(z);
  let ie = B.readUInt32LE(z + 4);
  return ie *= 4294967296, verifuint(ie + Y, 9007199254740991), ie + Y;
}
tools.readUInt64LE = readUInt64LE;
function writeUInt64LE(B, z, Y) {
  return verifuint(z, 9007199254740991), B.writeInt32LE(z & -1, Y), B.writeUInt32LE(Math.floor(z / 4294967296), Y + 4), Y + 8;
}
tools.writeUInt64LE = writeUInt64LE;
Object.defineProperty(witnessUtxo$1, "__esModule", { value: !0 });
const typeFields_1$4 = typeFields, tools_1$2 = tools, varuint$5 = varint;
function decode$1(B) {
  if (B.key[0] !== typeFields_1$4.InputTypes.WITNESS_UTXO)
    throw new Error(
      "Decode Error: could not decode witnessUtxo with key 0x" + B.key.toString("hex")
    );
  const z = tools_1$2.readUInt64LE(B.value, 0);
  let Y = 8;
  const ie = varuint$5.decode(B.value, Y);
  Y += varuint$5.encodingLength(ie);
  const se = B.value.slice(Y);
  if (se.length !== ie)
    throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
  return {
    script: se,
    value: z
  };
}
witnessUtxo$1.decode = decode$1;
function encode$1(B) {
  const { script: z, value: Y } = B, ie = varuint$5.encodingLength(z.length), se = Buffer$1.allocUnsafe(8 + ie + z.length);
  return tools_1$2.writeUInt64LE(se, Y, 0), varuint$5.encode(z.length, se, 8), z.copy(se, 8 + ie), {
    key: Buffer$1.from([typeFields_1$4.InputTypes.WITNESS_UTXO]),
    value: se
  };
}
witnessUtxo$1.encode = encode$1;
witnessUtxo$1.expected = "{ script: Buffer; value: number; }";
function check$1(B) {
  return Buffer$1.isBuffer(B.script) && typeof B.value == "number";
}
witnessUtxo$1.check = check$1;
function canAdd$1(B, z) {
  return !!B && !!z && B.witnessUtxo === void 0;
}
witnessUtxo$1.canAdd = canAdd$1;
var tapTree$1 = {};
Object.defineProperty(tapTree$1, "__esModule", { value: !0 });
const typeFields_1$3 = typeFields, varuint$4 = varint;
function decode(B) {
  if (B.key[0] !== typeFields_1$3.OutputTypes.TAP_TREE || B.key.length !== 1)
    throw new Error(
      "Decode Error: could not decode tapTree with key 0x" + B.key.toString("hex")
    );
  let z = 0;
  const Y = [];
  for (; z < B.value.length; ) {
    const ie = B.value[z++], se = B.value[z++], ne = varuint$4.decode(B.value, z);
    z += varuint$4.encodingLength(ne), Y.push({
      depth: ie,
      leafVersion: se,
      script: B.value.slice(z, z + ne)
    }), z += ne;
  }
  return { leaves: Y };
}
tapTree$1.decode = decode;
function encode(B) {
  const z = Buffer$1.from([typeFields_1$3.OutputTypes.TAP_TREE]), Y = [].concat(
    ...B.leaves.map((ie) => [
      Buffer$1.of(ie.depth, ie.leafVersion),
      varuint$4.encode(ie.script.length),
      ie.script
    ])
  );
  return {
    key: z,
    value: Buffer$1.concat(Y)
  };
}
tapTree$1.encode = encode;
tapTree$1.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
function check(B) {
  return Array.isArray(B.leaves) && B.leaves.every(
    (z) => z.depth >= 0 && z.depth <= 128 && (z.leafVersion & 254) === z.leafVersion && Buffer$1.isBuffer(z.script)
  );
}
tapTree$1.check = check;
function canAdd(B, z) {
  return !!B && !!z && B.tapTree === void 0;
}
tapTree$1.canAdd = canAdd;
var bip32Derivation$2 = {};
Object.defineProperty(bip32Derivation$2, "__esModule", { value: !0 });
const range$1 = (B) => [...Array(B).keys()], isValidDERKey = (B) => B.length === 33 && [2, 3].includes(B[0]) || B.length === 65 && B[0] === 4;
function makeConverter$4(B, z = isValidDERKey) {
  function Y(le) {
    if (le.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode bip32Derivation with key 0x" + le.key.toString("hex")
      );
    const ge = le.key.slice(1);
    if (!z(ge))
      throw new Error(
        "Decode Error: bip32Derivation has invalid pubkey in key 0x" + le.key.toString("hex")
      );
    if (le.value.length / 4 % 1 !== 0)
      throw new Error(
        "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
      );
    const Ee = {
      masterFingerprint: le.value.slice(0, 4),
      pubkey: ge,
      path: "m"
    };
    for (const oe of range$1(le.value.length / 4 - 1)) {
      const Pe = le.value.readUInt32LE(oe * 4 + 4), Ve = !!(Pe & 2147483648), Ke = Pe & 2147483647;
      Ee.path += "/" + Ke.toString(10) + (Ve ? "'" : "");
    }
    return Ee;
  }
  function ie(le) {
    const ge = Buffer$1.from([B]), Ee = Buffer$1.concat([ge, le.pubkey]), oe = le.path.split("/"), Pe = Buffer$1.allocUnsafe(oe.length * 4);
    le.masterFingerprint.copy(Pe, 0);
    let Ve = 4;
    return oe.slice(1).forEach((Ke) => {
      const ht = Ke.slice(-1) === "'";
      let _t = 2147483647 & parseInt(ht ? Ke.slice(0, -1) : Ke, 10);
      ht && (_t += 2147483648), Pe.writeUInt32LE(_t, Ve), Ve += 4;
    }), {
      key: Ee,
      value: Pe
    };
  }
  const se = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
  function ne(le) {
    return Buffer$1.isBuffer(le.pubkey) && Buffer$1.isBuffer(le.masterFingerprint) && typeof le.path == "string" && z(le.pubkey) && le.masterFingerprint.length === 4;
  }
  function ae(le, ge, Ee) {
    const oe = ge.pubkey.toString("hex");
    return Ee.has(oe) ? !1 : (Ee.add(oe), le.filter((Pe) => Pe.pubkey.equals(ge.pubkey)).length === 0);
  }
  return {
    decode: Y,
    encode: ie,
    check: ne,
    expected: se,
    canAddToArray: ae
  };
}
bip32Derivation$2.makeConverter = makeConverter$4;
var checkPubkey$1 = {};
Object.defineProperty(checkPubkey$1, "__esModule", { value: !0 });
function makeChecker(B) {
  return z;
  function z(Y) {
    let ie;
    if (B.includes(Y.key[0]) && (ie = Y.key.slice(1), !(ie.length === 33 || ie.length === 65) || ![2, 3, 4].includes(ie[0])))
      throw new Error(
        "Format Error: invalid pubkey in key 0x" + Y.key.toString("hex")
      );
    return ie;
  }
}
checkPubkey$1.makeChecker = makeChecker;
var redeemScript$1 = {};
Object.defineProperty(redeemScript$1, "__esModule", { value: !0 });
function makeConverter$3(B) {
  function z(ae) {
    if (ae.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode redeemScript with key 0x" + ae.key.toString("hex")
      );
    return ae.value;
  }
  function Y(ae) {
    return {
      key: Buffer$1.from([B]),
      value: ae
    };
  }
  const ie = "Buffer";
  function se(ae) {
    return Buffer$1.isBuffer(ae);
  }
  function ne(ae, le) {
    return !!ae && !!le && ae.redeemScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: se,
    expected: ie,
    canAdd: ne
  };
}
redeemScript$1.makeConverter = makeConverter$3;
var tapBip32Derivation$1 = {};
Object.defineProperty(tapBip32Derivation$1, "__esModule", { value: !0 });
const varuint$3 = varint, bip32Derivation$1 = bip32Derivation$2, isValidBIP340Key = (B) => B.length === 32;
function makeConverter$2(B) {
  const z = bip32Derivation$1.makeConverter(B, isValidBIP340Key);
  function Y(ae) {
    const le = varuint$3.decode(ae.value), ge = varuint$3.encodingLength(le), Ee = z.decode({
      key: ae.key,
      value: ae.value.slice(ge + le * 32)
    }), oe = new Array(le);
    for (let Pe = 0, Ve = ge; Pe < le; Pe++, Ve += 32)
      oe[Pe] = ae.value.slice(Ve, Ve + 32);
    return Object.assign({}, Ee, { leafHashes: oe });
  }
  function ie(ae) {
    const le = z.encode(ae), ge = varuint$3.encodingLength(ae.leafHashes.length), Ee = Buffer$1.allocUnsafe(ge);
    varuint$3.encode(ae.leafHashes.length, Ee);
    const oe = Buffer$1.concat([Ee, ...ae.leafHashes, le.value]);
    return Object.assign({}, le, { value: oe });
  }
  const se = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
  function ne(ae) {
    return Array.isArray(ae.leafHashes) && ae.leafHashes.every(
      (le) => Buffer$1.isBuffer(le) && le.length === 32
    ) && z.check(ae);
  }
  return {
    decode: Y,
    encode: ie,
    check: ne,
    expected: se,
    canAddToArray: z.canAddToArray
  };
}
tapBip32Derivation$1.makeConverter = makeConverter$2;
var tapInternalKey$1 = {};
Object.defineProperty(tapInternalKey$1, "__esModule", { value: !0 });
function makeConverter$1(B) {
  function z(ae) {
    if (ae.key[0] !== B || ae.key.length !== 1)
      throw new Error(
        "Decode Error: could not decode tapInternalKey with key 0x" + ae.key.toString("hex")
      );
    if (ae.value.length !== 32)
      throw new Error(
        "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
      );
    return ae.value;
  }
  function Y(ae) {
    return { key: Buffer$1.from([B]), value: ae };
  }
  const ie = "Buffer";
  function se(ae) {
    return Buffer$1.isBuffer(ae) && ae.length === 32;
  }
  function ne(ae, le) {
    return !!ae && !!le && ae.tapInternalKey === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: se,
    expected: ie,
    canAdd: ne
  };
}
tapInternalKey$1.makeConverter = makeConverter$1;
var witnessScript$1 = {};
Object.defineProperty(witnessScript$1, "__esModule", { value: !0 });
function makeConverter(B) {
  function z(ae) {
    if (ae.key[0] !== B)
      throw new Error(
        "Decode Error: could not decode witnessScript with key 0x" + ae.key.toString("hex")
      );
    return ae.value;
  }
  function Y(ae) {
    return {
      key: Buffer$1.from([B]),
      value: ae
    };
  }
  const ie = "Buffer";
  function se(ae) {
    return Buffer$1.isBuffer(ae);
  }
  function ne(ae, le) {
    return !!ae && !!le && ae.witnessScript === void 0;
  }
  return {
    decode: z,
    encode: Y,
    check: se,
    expected: ie,
    canAdd: ne
  };
}
witnessScript$1.makeConverter = makeConverter;
Object.defineProperty(converter, "__esModule", { value: !0 });
const typeFields_1$2 = typeFields, globalXpub = globalXpub$1, unsignedTx = unsignedTx$1, finalScriptSig = finalScriptSig$1, finalScriptWitness = finalScriptWitness$1, nonWitnessUtxo = nonWitnessUtxo$1, partialSig = partialSig$1, porCommitment = porCommitment$1, sighashType = sighashType$1, tapKeySig = tapKeySig$1, tapLeafScript = tapLeafScript$1, tapMerkleRoot = tapMerkleRoot$1, tapScriptSig = tapScriptSig$1, witnessUtxo = witnessUtxo$1, tapTree = tapTree$1, bip32Derivation = bip32Derivation$2, checkPubkey = checkPubkey$1, redeemScript = redeemScript$1, tapBip32Derivation = tapBip32Derivation$1, tapInternalKey = tapInternalKey$1, witnessScript = witnessScript$1, globals = {
  unsignedTx,
  globalXpub,
  // pass an Array of key bytes that require pubkey beside the key
  checkPubkey: checkPubkey.makeChecker([])
};
converter.globals = globals;
const inputs = {
  nonWitnessUtxo,
  partialSig,
  sighashType,
  finalScriptSig,
  finalScriptWitness,
  porCommitment,
  witnessUtxo,
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.InputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.InputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.InputTypes.PARTIAL_SIG,
    typeFields_1$2.InputTypes.BIP32_DERIVATION
  ]),
  tapKeySig,
  tapScriptSig,
  tapLeafScript,
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.InputTypes.TAP_BIP32_DERIVATION
  ),
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.InputTypes.TAP_INTERNAL_KEY
  ),
  tapMerkleRoot
};
converter.inputs = inputs;
const outputs = {
  bip32Derivation: bip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ),
  redeemScript: redeemScript.makeConverter(
    typeFields_1$2.OutputTypes.REDEEM_SCRIPT
  ),
  witnessScript: witnessScript.makeConverter(
    typeFields_1$2.OutputTypes.WITNESS_SCRIPT
  ),
  checkPubkey: checkPubkey.makeChecker([
    typeFields_1$2.OutputTypes.BIP32_DERIVATION
  ]),
  tapBip32Derivation: tapBip32Derivation.makeConverter(
    typeFields_1$2.OutputTypes.TAP_BIP32_DERIVATION
  ),
  tapTree,
  tapInternalKey: tapInternalKey.makeConverter(
    typeFields_1$2.OutputTypes.TAP_INTERNAL_KEY
  )
};
converter.outputs = outputs;
Object.defineProperty(fromBuffer, "__esModule", { value: !0 });
const convert$1 = converter, tools_1$1 = tools, varuint$2 = varint, typeFields_1$1 = typeFields;
function psbtFromBuffer(B, z) {
  let Y = 0;
  function ie() {
    const Rt = varuint$2.decode(B, Y);
    Y += varuint$2.encodingLength(Rt);
    const kt = B.slice(Y, Y + Rt);
    return Y += Rt, kt;
  }
  function se() {
    const Rt = B.readUInt32BE(Y);
    return Y += 4, Rt;
  }
  function ne() {
    const Rt = B.readUInt8(Y);
    return Y += 1, Rt;
  }
  function ae() {
    const Rt = ie(), kt = ie();
    return {
      key: Rt,
      value: kt
    };
  }
  function le() {
    if (Y >= B.length)
      throw new Error("Format Error: Unexpected End of PSBT");
    const Rt = B.readUInt8(Y) === 0;
    return Rt && Y++, Rt;
  }
  if (se() !== 1886610036)
    throw new Error("Format Error: Invalid Magic Number");
  if (ne() !== 255)
    throw new Error(
      "Format Error: Magic Number must be followed by 0xff separator"
    );
  const ge = [], Ee = {};
  for (; !le(); ) {
    const Rt = ae(), kt = Rt.key.toString("hex");
    if (Ee[kt])
      throw new Error(
        "Format Error: Keys must be unique for global keymap: key " + kt
      );
    Ee[kt] = 1, ge.push(Rt);
  }
  const oe = ge.filter(
    (Rt) => Rt.key[0] === typeFields_1$1.GlobalTypes.UNSIGNED_TX
  );
  if (oe.length !== 1)
    throw new Error("Format Error: Only one UNSIGNED_TX allowed");
  const Pe = z(oe[0].value), { inputCount: Ve, outputCount: Ke } = Pe.getInputOutputCounts(), ht = [], _t = [];
  for (const Rt of tools_1$1.range(Ve)) {
    const kt = {}, Bt = [];
    for (; !le(); ) {
      const Ct = ae(), qt = Ct.key.toString("hex");
      if (kt[qt])
        throw new Error(
          "Format Error: Keys must be unique for each input: input index " + Rt + " key " + qt
        );
      kt[qt] = 1, Bt.push(Ct);
    }
    ht.push(Bt);
  }
  for (const Rt of tools_1$1.range(Ke)) {
    const kt = {}, Bt = [];
    for (; !le(); ) {
      const Ct = ae(), qt = Ct.key.toString("hex");
      if (kt[qt])
        throw new Error(
          "Format Error: Keys must be unique for each output: output index " + Rt + " key " + qt
        );
      kt[qt] = 1, Bt.push(Ct);
    }
    _t.push(Bt);
  }
  return psbtFromKeyVals(Pe, {
    globalMapKeyVals: ge,
    inputKeyVals: ht,
    outputKeyVals: _t
  });
}
fromBuffer.psbtFromBuffer = psbtFromBuffer;
function checkKeyBuffer(B, z, Y) {
  if (!z.equals(Buffer$1.from([Y])))
    throw new Error(
      `Format Error: Invalid ${B} key: ${z.toString("hex")}`
    );
}
fromBuffer.checkKeyBuffer = checkKeyBuffer;
function psbtFromKeyVals(B, { globalMapKeyVals: z, inputKeyVals: Y, outputKeyVals: ie }) {
  const se = {
    unsignedTx: B
  };
  let ne = 0;
  for (const oe of z)
    switch (oe.key[0]) {
      case typeFields_1$1.GlobalTypes.UNSIGNED_TX:
        if (checkKeyBuffer(
          "global",
          oe.key,
          typeFields_1$1.GlobalTypes.UNSIGNED_TX
        ), ne > 0)
          throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
        ne++;
        break;
      case typeFields_1$1.GlobalTypes.GLOBAL_XPUB:
        se.globalXpub === void 0 && (se.globalXpub = []), se.globalXpub.push(convert$1.globals.globalXpub.decode(oe));
        break;
      default:
        se.unknownKeyVals || (se.unknownKeyVals = []), se.unknownKeyVals.push(oe);
    }
  const ae = Y.length, le = ie.length, ge = [], Ee = [];
  for (const oe of tools_1$1.range(ae)) {
    const Pe = {};
    for (const Ve of Y[oe])
      switch (convert$1.inputs.checkPubkey(Ve), Ve.key[0]) {
        case typeFields_1$1.InputTypes.NON_WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.NON_WITNESS_UTXO
          ), Pe.nonWitnessUtxo !== void 0)
            throw new Error(
              "Format Error: Input has multiple NON_WITNESS_UTXO"
            );
          Pe.nonWitnessUtxo = convert$1.inputs.nonWitnessUtxo.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.WITNESS_UTXO:
          if (checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.WITNESS_UTXO
          ), Pe.witnessUtxo !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_UTXO");
          Pe.witnessUtxo = convert$1.inputs.witnessUtxo.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.PARTIAL_SIG:
          Pe.partialSig === void 0 && (Pe.partialSig = []), Pe.partialSig.push(convert$1.inputs.partialSig.decode(Ve));
          break;
        case typeFields_1$1.InputTypes.SIGHASH_TYPE:
          if (checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.SIGHASH_TYPE
          ), Pe.sighashType !== void 0)
            throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
          Pe.sighashType = convert$1.inputs.sighashType.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.REDEEM_SCRIPT
          ), Pe.redeemScript !== void 0)
            throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
          Pe.redeemScript = convert$1.inputs.redeemScript.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.WITNESS_SCRIPT
          ), Pe.witnessScript !== void 0)
            throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
          Pe.witnessScript = convert$1.inputs.witnessScript.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.BIP32_DERIVATION:
          Pe.bip32Derivation === void 0 && (Pe.bip32Derivation = []), Pe.bip32Derivation.push(
            convert$1.inputs.bip32Derivation.decode(Ve)
          );
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTSIG:
          checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTSIG
          ), Pe.finalScriptSig = convert$1.inputs.finalScriptSig.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS:
          checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.FINAL_SCRIPTWITNESS
          ), Pe.finalScriptWitness = convert$1.inputs.finalScriptWitness.decode(
            Ve
          );
          break;
        case typeFields_1$1.InputTypes.POR_COMMITMENT:
          checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.POR_COMMITMENT
          ), Pe.porCommitment = convert$1.inputs.porCommitment.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.TAP_KEY_SIG:
          checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.TAP_KEY_SIG
          ), Pe.tapKeySig = convert$1.inputs.tapKeySig.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.TAP_SCRIPT_SIG:
          Pe.tapScriptSig === void 0 && (Pe.tapScriptSig = []), Pe.tapScriptSig.push(convert$1.inputs.tapScriptSig.decode(Ve));
          break;
        case typeFields_1$1.InputTypes.TAP_LEAF_SCRIPT:
          Pe.tapLeafScript === void 0 && (Pe.tapLeafScript = []), Pe.tapLeafScript.push(convert$1.inputs.tapLeafScript.decode(Ve));
          break;
        case typeFields_1$1.InputTypes.TAP_BIP32_DERIVATION:
          Pe.tapBip32Derivation === void 0 && (Pe.tapBip32Derivation = []), Pe.tapBip32Derivation.push(
            convert$1.inputs.tapBip32Derivation.decode(Ve)
          );
          break;
        case typeFields_1$1.InputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.TAP_INTERNAL_KEY
          ), Pe.tapInternalKey = convert$1.inputs.tapInternalKey.decode(Ve);
          break;
        case typeFields_1$1.InputTypes.TAP_MERKLE_ROOT:
          checkKeyBuffer(
            "input",
            Ve.key,
            typeFields_1$1.InputTypes.TAP_MERKLE_ROOT
          ), Pe.tapMerkleRoot = convert$1.inputs.tapMerkleRoot.decode(Ve);
          break;
        default:
          Pe.unknownKeyVals || (Pe.unknownKeyVals = []), Pe.unknownKeyVals.push(Ve);
      }
    ge.push(Pe);
  }
  for (const oe of tools_1$1.range(le)) {
    const Pe = {};
    for (const Ve of ie[oe])
      switch (convert$1.outputs.checkPubkey(Ve), Ve.key[0]) {
        case typeFields_1$1.OutputTypes.REDEEM_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ve.key,
            typeFields_1$1.OutputTypes.REDEEM_SCRIPT
          ), Pe.redeemScript !== void 0)
            throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
          Pe.redeemScript = convert$1.outputs.redeemScript.decode(Ve);
          break;
        case typeFields_1$1.OutputTypes.WITNESS_SCRIPT:
          if (checkKeyBuffer(
            "output",
            Ve.key,
            typeFields_1$1.OutputTypes.WITNESS_SCRIPT
          ), Pe.witnessScript !== void 0)
            throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
          Pe.witnessScript = convert$1.outputs.witnessScript.decode(Ve);
          break;
        case typeFields_1$1.OutputTypes.BIP32_DERIVATION:
          Pe.bip32Derivation === void 0 && (Pe.bip32Derivation = []), Pe.bip32Derivation.push(
            convert$1.outputs.bip32Derivation.decode(Ve)
          );
          break;
        case typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY:
          checkKeyBuffer(
            "output",
            Ve.key,
            typeFields_1$1.OutputTypes.TAP_INTERNAL_KEY
          ), Pe.tapInternalKey = convert$1.outputs.tapInternalKey.decode(Ve);
          break;
        case typeFields_1$1.OutputTypes.TAP_TREE:
          checkKeyBuffer(
            "output",
            Ve.key,
            typeFields_1$1.OutputTypes.TAP_TREE
          ), Pe.tapTree = convert$1.outputs.tapTree.decode(Ve);
          break;
        case typeFields_1$1.OutputTypes.TAP_BIP32_DERIVATION:
          Pe.tapBip32Derivation === void 0 && (Pe.tapBip32Derivation = []), Pe.tapBip32Derivation.push(
            convert$1.outputs.tapBip32Derivation.decode(Ve)
          );
          break;
        default:
          Pe.unknownKeyVals || (Pe.unknownKeyVals = []), Pe.unknownKeyVals.push(Ve);
      }
    Ee.push(Pe);
  }
  return { globalMap: se, inputs: ge, outputs: Ee };
}
fromBuffer.psbtFromKeyVals = psbtFromKeyVals;
var toBuffer = {};
Object.defineProperty(toBuffer, "__esModule", { value: !0 });
const convert = converter, tools_1 = tools;
function psbtToBuffer({ globalMap: B, inputs: z, outputs: Y }) {
  const { globalKeyVals: ie, inputKeyVals: se, outputKeyVals: ne } = psbtToKeyVals({
    globalMap: B,
    inputs: z,
    outputs: Y
  }), ae = tools_1.keyValsToBuffer(ie), le = (Pe) => Pe.length === 0 ? [Buffer$1.from([0])] : Pe.map(tools_1.keyValsToBuffer), ge = le(se), Ee = le(ne), oe = Buffer$1.allocUnsafe(5);
  return oe.writeUIntBE(482972169471, 0, 5), Buffer$1.concat(
    [oe, ae].concat(ge, Ee)
  );
}
toBuffer.psbtToBuffer = psbtToBuffer;
const sortKeyVals = (B, z) => B.key.compare(z.key);
function keyValsFromMap(B, z) {
  const Y = /* @__PURE__ */ new Set(), ie = Object.entries(B).reduce((ne, [ae, le]) => {
    if (ae === "unknownKeyVals") return ne;
    const ge = z[ae];
    if (ge === void 0) return ne;
    const Ee = (Array.isArray(le) ? le : [le]).map(
      ge.encode
    );
    return Ee.map((Pe) => Pe.key.toString("hex")).forEach((Pe) => {
      if (Y.has(Pe))
        throw new Error("Serialize Error: Duplicate key: " + Pe);
      Y.add(Pe);
    }), ne.concat(Ee);
  }, []), se = B.unknownKeyVals ? B.unknownKeyVals.filter((ne) => !Y.has(ne.key.toString("hex"))) : [];
  return ie.concat(se).sort(sortKeyVals);
}
function psbtToKeyVals({ globalMap: B, inputs: z, outputs: Y }) {
  return {
    globalKeyVals: keyValsFromMap(B, convert.globals),
    inputKeyVals: z.map((ie) => keyValsFromMap(ie, convert.inputs)),
    outputKeyVals: Y.map((ie) => keyValsFromMap(ie, convert.outputs))
  };
}
toBuffer.psbtToKeyVals = psbtToKeyVals;
(function(B) {
  function z(Y) {
    for (var ie in Y) B.hasOwnProperty(ie) || (B[ie] = Y[ie]);
  }
  Object.defineProperty(B, "__esModule", { value: !0 }), z(fromBuffer), z(toBuffer);
})(parser);
Object.defineProperty(combiner, "__esModule", { value: !0 });
const parser_1$1 = parser;
function combine(B) {
  const z = B[0], Y = parser_1$1.psbtToKeyVals(z), ie = B.slice(1);
  if (ie.length === 0) throw new Error("Combine: Nothing to combine");
  const se = getTx(z);
  if (se === void 0)
    throw new Error("Combine: Self missing transaction");
  const ne = getKeySet(Y.globalKeyVals), ae = Y.inputKeyVals.map(getKeySet), le = Y.outputKeyVals.map(getKeySet);
  for (const ge of ie) {
    const Ee = getTx(ge);
    if (Ee === void 0 || !Ee.toBuffer().equals(se.toBuffer()))
      throw new Error(
        "Combine: One of the Psbts does not have the same transaction."
      );
    const oe = parser_1$1.psbtToKeyVals(ge);
    getKeySet(oe.globalKeyVals).forEach(
      keyPusher(
        ne,
        Y.globalKeyVals,
        oe.globalKeyVals
      )
    ), oe.inputKeyVals.map(getKeySet).forEach(
      (ht, _t) => ht.forEach(
        keyPusher(
          ae[_t],
          Y.inputKeyVals[_t],
          oe.inputKeyVals[_t]
        )
      )
    ), oe.outputKeyVals.map(getKeySet).forEach(
      (ht, _t) => ht.forEach(
        keyPusher(
          le[_t],
          Y.outputKeyVals[_t],
          oe.outputKeyVals[_t]
        )
      )
    );
  }
  return parser_1$1.psbtFromKeyVals(se, {
    globalMapKeyVals: Y.globalKeyVals,
    inputKeyVals: Y.inputKeyVals,
    outputKeyVals: Y.outputKeyVals
  });
}
combiner.combine = combine;
function keyPusher(B, z, Y) {
  return (ie) => {
    if (B.has(ie)) return;
    const se = Y.filter((ne) => ne.key.toString("hex") === ie)[0];
    z.push(se), B.add(ie);
  };
}
function getTx(B) {
  return B.globalMap.unsignedTx;
}
function getKeySet(B) {
  const z = /* @__PURE__ */ new Set();
  return B.forEach((Y) => {
    const ie = Y.key.toString("hex");
    if (z.has(ie))
      throw new Error("Combine: KeyValue Map keys should be unique");
    z.add(ie);
  }), z;
}
var utils = {};
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 });
  const z = converter;
  function Y(Ke, ht) {
    const _t = Ke[ht];
    if (_t === void 0) throw new Error(`No input #${ht}`);
    return _t;
  }
  B.checkForInput = Y;
  function ie(Ke, ht) {
    const _t = Ke[ht];
    if (_t === void 0) throw new Error(`No output #${ht}`);
    return _t;
  }
  B.checkForOutput = ie;
  function se(Ke, ht, _t) {
    if (Ke.key[0] < _t)
      throw new Error(
        "Use the method for your specific key instead of addUnknownKeyVal*"
      );
    if (ht && ht.filter((Rt) => Rt.key.equals(Ke.key)).length !== 0)
      throw new Error(`Duplicate Key: ${Ke.key.toString("hex")}`);
  }
  B.checkHasKey = se;
  function ne(Ke) {
    let ht = 0;
    return Object.keys(Ke).forEach((_t) => {
      Number(isNaN(Number(_t))) && ht++;
    }), ht;
  }
  B.getEnumLength = ne;
  function ae(Ke, ht) {
    let _t = !1;
    if (ht.nonWitnessUtxo || ht.witnessUtxo) {
      const Rt = !!ht.redeemScript, kt = !!ht.witnessScript, Bt = !Rt || !!ht.finalScriptSig, Ct = !kt || !!ht.finalScriptWitness, qt = !!ht.finalScriptSig || !!ht.finalScriptWitness;
      _t = Bt && Ct && qt;
    }
    if (_t === !1)
      throw new Error(
        `Input #${Ke} has too much or too little data to clean`
      );
  }
  B.inputCheckUncleanFinalized = ae;
  function le(Ke, ht, _t, Rt) {
    throw new Error(
      `Data for ${Ke} key ${ht} is incorrect: Expected ${_t} and got ${JSON.stringify(Rt)}`
    );
  }
  function ge(Ke) {
    return (ht, _t) => {
      for (const Rt of Object.keys(ht)) {
        const kt = ht[Rt], { canAdd: Bt, canAddToArray: Ct, check: qt, expected: jt } = (
          // @ts-ignore
          z[Ke + "s"][Rt] || {}
        ), Ht = !!Ct;
        if (qt)
          if (Ht) {
            if (!Array.isArray(kt) || // @ts-ignore
            _t[Rt] && !Array.isArray(_t[Rt]))
              throw new Error(`Key type ${Rt} must be an array`);
            kt.every(qt) || le(Ke, Rt, jt, kt);
            const Yt = _t[Rt] || [], Ut = /* @__PURE__ */ new Set();
            if (!kt.every((Nt) => Ct(Yt, Nt, Ut)))
              throw new Error("Can not add duplicate data to array");
            _t[Rt] = Yt.concat(kt);
          } else {
            if (qt(kt) || le(Ke, Rt, jt, kt), !Bt(_t, kt))
              throw new Error(`Can not add duplicate data to ${Ke}`);
            _t[Rt] = kt;
          }
      }
    };
  }
  B.updateGlobal = ge("global"), B.updateInput = ge("input"), B.updateOutput = ge("output");
  function Ee(Ke, ht) {
    const _t = Ke.length - 1, Rt = Y(Ke, _t);
    B.updateInput(ht, Rt);
  }
  B.addInputAttributes = Ee;
  function oe(Ke, ht) {
    const _t = Ke.length - 1, Rt = ie(Ke, _t);
    B.updateOutput(ht, Rt);
  }
  B.addOutputAttributes = oe;
  function Pe(Ke, ht) {
    if (!Buffer$1.isBuffer(ht) || ht.length < 4)
      throw new Error("Set Version: Invalid Transaction");
    return ht.writeUInt32LE(Ke, 0), ht;
  }
  B.defaultVersionSetter = Pe;
  function Ve(Ke, ht) {
    if (!Buffer$1.isBuffer(ht) || ht.length < 4)
      throw new Error("Set Locktime: Invalid Transaction");
    return ht.writeUInt32LE(Ke, ht.length - 4), ht;
  }
  B.defaultLocktimeSetter = Ve;
})(utils);
Object.defineProperty(psbt, "__esModule", { value: !0 });
const combiner_1 = combiner, parser_1 = parser, typeFields_1 = typeFields, utils_1$1 = utils;
let Psbt$1 = class {
  constructor(z) {
    this.inputs = [], this.outputs = [], this.globalMap = {
      unsignedTx: z
    };
  }
  static fromBase64(z, Y) {
    const ie = Buffer$1.from(z, "base64");
    return this.fromBuffer(ie, Y);
  }
  static fromHex(z, Y) {
    const ie = Buffer$1.from(z, "hex");
    return this.fromBuffer(ie, Y);
  }
  static fromBuffer(z, Y) {
    const ie = parser_1.psbtFromBuffer(z, Y), se = new this(ie.globalMap.unsignedTx);
    return Object.assign(se, ie), se;
  }
  toBase64() {
    return this.toBuffer().toString("base64");
  }
  toHex() {
    return this.toBuffer().toString("hex");
  }
  toBuffer() {
    return parser_1.psbtToBuffer(this);
  }
  updateGlobal(z) {
    return utils_1$1.updateGlobal(z, this.globalMap), this;
  }
  updateInput(z, Y) {
    const ie = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.updateInput(Y, ie), this;
  }
  updateOutput(z, Y) {
    const ie = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.updateOutput(Y, ie), this;
  }
  addUnknownKeyValToGlobal(z) {
    return utils_1$1.checkHasKey(
      z,
      this.globalMap.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.GlobalTypes)
    ), this.globalMap.unknownKeyVals || (this.globalMap.unknownKeyVals = []), this.globalMap.unknownKeyVals.push(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    const ie = utils_1$1.checkForInput(this.inputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ie.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.InputTypes)
    ), ie.unknownKeyVals || (ie.unknownKeyVals = []), ie.unknownKeyVals.push(Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    const ie = utils_1$1.checkForOutput(this.outputs, z);
    return utils_1$1.checkHasKey(
      Y,
      ie.unknownKeyVals,
      utils_1$1.getEnumLength(typeFields_1.OutputTypes)
    ), ie.unknownKeyVals || (ie.unknownKeyVals = []), ie.unknownKeyVals.push(Y), this;
  }
  addInput(z) {
    this.globalMap.unsignedTx.addInput(z), this.inputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ie = this.inputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (se) => this.addUnknownKeyValToInput(ie, se)
    ), utils_1$1.addInputAttributes(this.inputs, z), this;
  }
  addOutput(z) {
    this.globalMap.unsignedTx.addOutput(z), this.outputs.push({
      unknownKeyVals: []
    });
    const Y = z.unknownKeyVals || [], ie = this.outputs.length - 1;
    if (!Array.isArray(Y))
      throw new Error("unknownKeyVals must be an Array");
    return Y.forEach(
      (se) => this.addUnknownKeyValToOutput(ie, se)
    ), utils_1$1.addOutputAttributes(this.outputs, z), this;
  }
  clearFinalizedInput(z) {
    const Y = utils_1$1.checkForInput(this.inputs, z);
    utils_1$1.inputCheckUncleanFinalized(z, Y);
    for (const ie of Object.keys(Y))
      [
        "witnessUtxo",
        "nonWitnessUtxo",
        "finalScriptSig",
        "finalScriptWitness",
        "unknownKeyVals"
      ].includes(ie) || delete Y[ie];
    return this;
  }
  combine(...z) {
    const Y = combiner_1.combine([this].concat(z));
    return Object.assign(this, Y), this;
  }
  getTransaction() {
    return this.globalMap.unsignedTx.toBuffer();
  }
};
psbt.Psbt = Psbt$1;
var bip371 = {}, psbtutils = {};
Object.defineProperty(psbtutils, "__esModule", { value: !0 });
psbtutils.signatureBlocksAction = psbtutils.checkInputForSig = psbtutils.pubkeyInScript = psbtutils.pubkeyPositionInScript = psbtutils.witnessStackToScriptWitness = psbtutils.isP2TR = psbtutils.isP2SHScript = psbtutils.isP2WSHScript = psbtutils.isP2WPKH = psbtutils.isP2PKH = psbtutils.isP2PK = psbtutils.isP2MS = void 0;
const varuint$1 = varint, bscript$1 = requireScript(), transaction_1$2 = transaction, crypto_1 = crypto$1, payments$1 = requirePayments();
function isPaymentFactory(B) {
  return (z) => {
    try {
      return B({ output: z }), !0;
    } catch {
      return !1;
    }
  };
}
psbtutils.isP2MS = isPaymentFactory(payments$1.p2ms);
psbtutils.isP2PK = isPaymentFactory(payments$1.p2pk);
psbtutils.isP2PKH = isPaymentFactory(payments$1.p2pkh);
psbtutils.isP2WPKH = isPaymentFactory(payments$1.p2wpkh);
psbtutils.isP2WSHScript = isPaymentFactory(payments$1.p2wsh);
psbtutils.isP2SHScript = isPaymentFactory(payments$1.p2sh);
psbtutils.isP2TR = isPaymentFactory(payments$1.p2tr);
function witnessStackToScriptWitness(B) {
  let z = Buffer$1.allocUnsafe(0);
  function Y(ae) {
    z = Buffer$1.concat([z, Buffer$1.from(ae)]);
  }
  function ie(ae) {
    const le = z.length, ge = varuint$1.encodingLength(ae);
    z = Buffer$1.concat([z, Buffer$1.allocUnsafe(ge)]), varuint$1.encode(ae, z, le);
  }
  function se(ae) {
    ie(ae.length), Y(ae);
  }
  function ne(ae) {
    ie(ae.length), ae.forEach(se);
  }
  return ne(B), z;
}
psbtutils.witnessStackToScriptWitness = witnessStackToScriptWitness;
function pubkeyPositionInScript(B, z) {
  const Y = (0, crypto_1.hash160)(B), ie = B.slice(1, 33), se = bscript$1.decompile(z);
  if (se === null) throw new Error("Unknown script error");
  return se.findIndex((ne) => typeof ne == "number" ? !1 : ne.equals(B) || ne.equals(Y) || ne.equals(ie));
}
psbtutils.pubkeyPositionInScript = pubkeyPositionInScript;
function pubkeyInScript(B, z) {
  return pubkeyPositionInScript(B, z) !== -1;
}
psbtutils.pubkeyInScript = pubkeyInScript;
function checkInputForSig(B, z) {
  return extractPartialSigs(B).some(
    (ie) => signatureBlocksAction(ie, bscript$1.signature.decode, z)
  );
}
psbtutils.checkInputForSig = checkInputForSig;
function signatureBlocksAction(B, z, Y) {
  const { hashType: ie } = z(B), se = [];
  switch (ie & transaction_1$2.Transaction.SIGHASH_ANYONECANPAY && se.push("addInput"), ie & 31) {
    case transaction_1$2.Transaction.SIGHASH_ALL:
      break;
    case transaction_1$2.Transaction.SIGHASH_SINGLE:
    case transaction_1$2.Transaction.SIGHASH_NONE:
      se.push("addOutput"), se.push("setInputSequence");
      break;
  }
  return se.indexOf(Y) === -1;
}
psbtutils.signatureBlocksAction = signatureBlocksAction;
function extractPartialSigs(B) {
  let z = [];
  if ((B.partialSig || []).length === 0) {
    if (!B.finalScriptSig && !B.finalScriptWitness) return [];
    z = getPsigsFromInputFinalScripts(B);
  } else
    z = B.partialSig;
  return z.map((Y) => Y.signature);
}
function getPsigsFromInputFinalScripts(B) {
  const z = B.finalScriptSig ? bscript$1.decompile(B.finalScriptSig) || [] : [], Y = B.finalScriptWitness ? bscript$1.decompile(B.finalScriptWitness) || [] : [];
  return z.concat(Y).filter((ie) => Buffer$1.isBuffer(ie) && bscript$1.isCanonicalScriptSignature(ie)).map((ie) => ({ signature: ie }));
}
Object.defineProperty(bip371, "__esModule", { value: !0 });
bip371.checkTaprootInputForSigs = bip371.tapTreeFromList = bip371.tapTreeToList = bip371.tweakInternalPubKey = bip371.checkTaprootOutputFields = bip371.checkTaprootInputFields = bip371.isTaprootOutput = bip371.isTaprootInput = bip371.serializeTaprootSignature = bip371.tapScriptFinalizer = bip371.toXOnly = void 0;
const types_1 = types$4, transaction_1$1 = transaction, psbtutils_1$1 = psbtutils, bip341_1$1 = bip341, payments_1 = requirePayments(), psbtutils_2 = psbtutils, toXOnly = (B) => B.length === 32 ? B : B.slice(1, 33);
bip371.toXOnly = toXOnly;
function tapScriptFinalizer(B, z, Y) {
  const ie = findTapLeafToFinalize(
    z,
    B,
    Y
  );
  try {
    const ne = sortSignatures(z, ie).concat(ie.script).concat(ie.controlBlock);
    return {
      finalScriptWitness: (0, psbtutils_1$1.witnessStackToScriptWitness)(ne)
    };
  } catch (se) {
    throw new Error(`Can not finalize taproot input #${B}: ${se}`);
  }
}
bip371.tapScriptFinalizer = tapScriptFinalizer;
function serializeTaprootSignature(B, z) {
  const Y = z ? Buffer$1.from([z]) : Buffer$1.from([]);
  return Buffer$1.concat([B, Y]);
}
bip371.serializeTaprootSignature = serializeTaprootSignature;
function isTaprootInput(B) {
  return B && !!(B.tapInternalKey || B.tapMerkleRoot || B.tapLeafScript && B.tapLeafScript.length || B.tapBip32Derivation && B.tapBip32Derivation.length || B.witnessUtxo && (0, psbtutils_1$1.isP2TR)(B.witnessUtxo.script));
}
bip371.isTaprootInput = isTaprootInput;
function isTaprootOutput(B, z) {
  return B && !!(B.tapInternalKey || B.tapTree || B.tapBip32Derivation && B.tapBip32Derivation.length || z && (0, psbtutils_1$1.isP2TR)(z));
}
bip371.isTaprootOutput = isTaprootOutput;
function checkTaprootInputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootInputFields(B, z, Y), checkIfTapLeafInTree(B, z, Y);
}
bip371.checkTaprootInputFields = checkTaprootInputFields;
function checkTaprootOutputFields(B, z, Y) {
  checkMixedTaprootAndNonTaprootOutputFields(B, z, Y), checkTaprootScriptPubkey(B, z);
}
bip371.checkTaprootOutputFields = checkTaprootOutputFields;
function checkTaprootScriptPubkey(B, z) {
  if (!z.tapTree && !z.tapInternalKey) return;
  const Y = z.tapInternalKey || B.tapInternalKey, ie = z.tapTree || B.tapTree;
  if (Y) {
    const { script: se } = B, ne = getTaprootScripPubkey(Y, ie);
    if (se && !se.equals(ne))
      throw new Error("Error adding output. Script or address missmatch.");
  }
}
function getTaprootScripPubkey(B, z) {
  const Y = z && tapTreeFromList(z.leaves), { output: ie } = (0, payments_1.p2tr)({
    internalPubkey: B,
    scriptTree: Y
  });
  return ie;
}
function tweakInternalPubKey(B, z) {
  const Y = z.tapInternalKey, ie = Y && (0, bip341_1$1.tweakKey)(Y, z.tapMerkleRoot);
  if (!ie)
    throw new Error(
      `Cannot tweak tap internal key for input #${B}. Public key: ${Y && Y.toString("hex")}`
    );
  return ie.x;
}
bip371.tweakInternalPubKey = tweakInternalPubKey;
function tapTreeToList(B) {
  if (!(0, types_1.isTaptree)(B))
    throw new Error(
      "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
    );
  return _tapTreeToList(B);
}
bip371.tapTreeToList = tapTreeToList;
function tapTreeFromList(B = []) {
  return B.length === 1 && B[0].depth === 0 ? {
    output: B[0].script,
    version: B[0].leafVersion
  } : instertLeavesInTree(B);
}
bip371.tapTreeFromList = tapTreeFromList;
function checkTaprootInputForSigs(B, z) {
  return extractTaprootSigs(B).some(
    (ie) => (0, psbtutils_2.signatureBlocksAction)(ie, decodeSchnorrSignature, z)
  );
}
bip371.checkTaprootInputForSigs = checkTaprootInputForSigs;
function decodeSchnorrSignature(B) {
  return {
    signature: B.slice(0, 64),
    hashType: B.slice(64)[0] || transaction_1$1.Transaction.SIGHASH_DEFAULT
  };
}
function extractTaprootSigs(B) {
  const z = [];
  if (B.tapKeySig && z.push(B.tapKeySig), B.tapScriptSig && z.push(...B.tapScriptSig.map((Y) => Y.signature)), !z.length) {
    const Y = getTapKeySigFromWithness(B.finalScriptWitness);
    Y && z.push(Y);
  }
  return z;
}
function getTapKeySigFromWithness(B) {
  if (!B) return;
  const z = B.slice(2);
  if (z.length === 64 || z.length === 65) return z;
}
function _tapTreeToList(B, z = [], Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  return B ? (0, types_1.isTapleaf)(B) ? (z.push({
    depth: Y,
    leafVersion: B.version || bip341_1$1.LEAF_VERSION_TAPSCRIPT,
    script: B.output
  }), z) : (B[0] && _tapTreeToList(B[0], z, Y + 1), B[1] && _tapTreeToList(B[1], z, Y + 1), z) : [];
}
function instertLeavesInTree(B) {
  let z;
  for (const Y of B)
    if (z = instertLeafInTree(Y, z), !z) throw new Error("No room left to insert tapleaf in tree");
  return z;
}
function instertLeafInTree(B, z, Y = 0) {
  if (Y > bip341_1$1.MAX_TAPTREE_DEPTH)
    throw new Error("Max taptree depth exceeded.");
  if (B.depth === Y)
    return z ? void 0 : {
      output: B.script,
      version: B.leafVersion
    };
  if ((0, types_1.isTapleaf)(z)) return;
  const ie = instertLeafInTree(B, z && z[0], Y + 1);
  if (ie) return [ie, z && z[1]];
  const se = instertLeafInTree(B, z && z[1], Y + 1);
  if (se) return [z && z[0], se];
}
function checkMixedTaprootAndNonTaprootInputFields(B, z, Y) {
  const ie = isTaprootInput(B) && hasNonTaprootFields(z), se = hasNonTaprootFields(B) && isTaprootInput(z), ne = B === z && isTaprootInput(z) && hasNonTaprootFields(z);
  if (ie || se || ne)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkMixedTaprootAndNonTaprootOutputFields(B, z, Y) {
  const ie = isTaprootOutput(B) && hasNonTaprootFields(z), se = hasNonTaprootFields(B) && isTaprootOutput(z), ne = B === z && isTaprootOutput(z) && hasNonTaprootFields(z);
  if (ie || se || ne)
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Cannot use both taproot and non-taproot fields.`
    );
}
function checkIfTapLeafInTree(B, z, Y) {
  if (z.tapMerkleRoot) {
    const ie = (z.tapLeafScript || []).every(
      (ne) => isTapLeafInTree(ne, z.tapMerkleRoot)
    ), se = (B.tapLeafScript || []).every(
      (ne) => isTapLeafInTree(ne, z.tapMerkleRoot)
    );
    if (!ie || !se)
      throw new Error(
        `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
      );
  } else if (B.tapMerkleRoot && !(z.tapLeafScript || []).every(
    (se) => isTapLeafInTree(se, B.tapMerkleRoot)
  ))
    throw new Error(
      `Invalid arguments for Psbt.${Y}. Tapleaf not part of taptree.`
    );
}
function isTapLeafInTree(B, z) {
  if (!z) return !0;
  const Y = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (0, bip341_1$1.rootHashFromPath)(
    B.controlBlock,
    Y
  ).equals(z);
}
function sortSignatures(B, z) {
  const Y = (0, bip341_1$1.tapleafHash)({
    output: z.script,
    version: z.leafVersion
  });
  return (B.tapScriptSig || []).filter((ie) => ie.leafHash.equals(Y)).map((ie) => addPubkeyPositionInScript(z.script, ie)).sort((ie, se) => se.positionInScript - ie.positionInScript).map((ie) => ie.signature);
}
function addPubkeyPositionInScript(B, z) {
  return Object.assign(
    {
      positionInScript: (0, psbtutils_1$1.pubkeyPositionInScript)(
        z.pubkey,
        B
      )
    },
    z
  );
}
function findTapLeafToFinalize(B, z, Y) {
  if (!B.tapScriptSig || !B.tapScriptSig.length)
    throw new Error(
      `Can not finalize taproot input #${z}. No tapleaf script signature provided.`
    );
  const ie = (B.tapLeafScript || []).sort((se, ne) => se.controlBlock.length - ne.controlBlock.length).find(
    (se) => canFinalizeLeaf(se, B.tapScriptSig, Y)
  );
  if (!ie)
    throw new Error(
      `Can not finalize taproot input #${z}. Signature for tapleaf script not found.`
    );
  return ie;
}
function canFinalizeLeaf(B, z, Y) {
  const ie = (0, bip341_1$1.tapleafHash)({
    output: B.script,
    version: B.leafVersion
  });
  return (!Y || Y.equals(ie)) && z.find((ne) => ne.leafHash.equals(ie)) !== void 0;
}
function hasNonTaprootFields(B) {
  return B && !!(B.redeemScript || B.witnessScript || B.bip32Derivation && B.bip32Derivation.length);
}
Object.defineProperty(psbt$1, "__esModule", { value: !0 });
psbt$1.Psbt = void 0;
const bip174_1 = psbt, varuint = varint, utils_1 = utils, address_1 = requireAddress(), bufferutils_1 = bufferutils, networks_1 = networks, payments = requirePayments(), bip341_1 = bip341, bscript = requireScript(), transaction_1 = transaction, bip371_1 = bip371, psbtutils_1 = psbtutils, DEFAULT_OPTS = {
  /**
   * A bitcoinjs Network object. This is only used if you pass an `address`
   * parameter to addOutput. Otherwise it is not needed and can be left default.
   */
  network: networks_1.bitcoin,
  /**
   * When extractTransaction is called, the fee rate is checked.
   * THIS IS NOT TO BE RELIED ON.
   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
   */
  maximumFeeRate: 5e3
  // satoshi per byte
};
class Psbt {
  static fromBase64(z, Y = {}) {
    const ie = Buffer$1.from(z, "base64");
    return this.fromBuffer(ie, Y);
  }
  static fromHex(z, Y = {}) {
    const ie = Buffer$1.from(z, "hex");
    return this.fromBuffer(ie, Y);
  }
  static fromBuffer(z, Y = {}) {
    const ie = bip174_1.Psbt.fromBuffer(z, transactionFromBuffer), se = new Psbt(Y, ie);
    return checkTxForDupeIns(se.__CACHE.__TX, se.__CACHE), se;
  }
  constructor(z = {}, Y = new bip174_1.Psbt(new PsbtTransaction())) {
    this.data = Y, this.opts = Object.assign({}, DEFAULT_OPTS, z), this.__CACHE = {
      __NON_WITNESS_UTXO_TX_CACHE: [],
      __NON_WITNESS_UTXO_BUF_CACHE: [],
      __TX_IN_CACHE: {},
      __TX: this.data.globalMap.unsignedTx.tx,
      // Psbt's predecessor (TransactionBuilder - now removed) behavior
      // was to not confirm input values  before signing.
      // Even though we highly encourage people to get
      // the full parent transaction to verify values, the ability to
      // sign non-segwit inputs without the full transaction was often
      // requested. So the only way to activate is to use @ts-ignore.
      // We will disable exporting the Psbt when unsafe sign is active.
      // because it is not BIP174 compliant.
      __UNSAFE_SIGN_NONSEGWIT: !1
    }, this.data.inputs.length === 0 && this.setVersion(2);
    const ie = (se, ne, ae, le) => Object.defineProperty(se, ne, {
      enumerable: ae,
      writable: le
    });
    ie(this, "__CACHE", !1, !0), ie(this, "opts", !1, !0);
  }
  get inputCount() {
    return this.data.inputs.length;
  }
  get version() {
    return this.__CACHE.__TX.version;
  }
  set version(z) {
    this.setVersion(z);
  }
  get locktime() {
    return this.__CACHE.__TX.locktime;
  }
  set locktime(z) {
    this.setLocktime(z);
  }
  get txInputs() {
    return this.__CACHE.__TX.ins.map((z) => ({
      hash: (0, bufferutils_1.cloneBuffer)(z.hash),
      index: z.index,
      sequence: z.sequence
    }));
  }
  get txOutputs() {
    return this.__CACHE.__TX.outs.map((z) => {
      let Y;
      try {
        Y = (0, address_1.fromOutputScript)(
          z.script,
          this.opts.network
        );
      } catch {
      }
      return {
        script: (0, bufferutils_1.cloneBuffer)(z.script),
        value: z.value,
        address: Y
      };
    });
  }
  combine(...z) {
    return this.data.combine(...z.map((Y) => Y.data)), this;
  }
  clone() {
    const z = Psbt.fromBuffer(this.data.toBuffer());
    return z.opts = JSON.parse(JSON.stringify(this.opts)), z;
  }
  setMaximumFeeRate(z) {
    check32Bit(z), this.opts.maximumFeeRate = z;
  }
  setVersion(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setVersion");
    const Y = this.__CACHE;
    return Y.__TX.version = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setLocktime(z) {
    check32Bit(z), checkInputsForPartialSig(this.data.inputs, "setLocktime");
    const Y = this.__CACHE;
    return Y.__TX.locktime = z, Y.__EXTRACTED_TX = void 0, this;
  }
  setInputSequence(z, Y) {
    check32Bit(Y), checkInputsForPartialSig(this.data.inputs, "setInputSequence");
    const ie = this.__CACHE;
    if (ie.__TX.ins.length <= z)
      throw new Error("Input index too high");
    return ie.__TX.ins[z].sequence = Y, ie.__EXTRACTED_TX = void 0, this;
  }
  addInputs(z) {
    return z.forEach((Y) => this.addInput(Y)), this;
  }
  addInput(z) {
    if (arguments.length > 1 || !z || z.hash === void 0 || z.index === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]"
      );
    (0, bip371_1.checkTaprootInputFields)(z, z, "addInput"), checkInputsForPartialSig(this.data.inputs, "addInput"), z.witnessScript && checkInvalidP2WSH(z.witnessScript);
    const Y = this.__CACHE;
    this.data.addInput(z);
    const ie = Y.__TX.ins[Y.__TX.ins.length - 1];
    checkTxInputCache(Y, ie);
    const se = this.data.inputs.length - 1, ne = this.data.inputs[se];
    return ne.nonWitnessUtxo && addNonWitnessTxCache(this.__CACHE, ne, se), Y.__FEE = void 0, Y.__FEE_RATE = void 0, Y.__EXTRACTED_TX = void 0, this;
  }
  addOutputs(z) {
    return z.forEach((Y) => this.addOutput(Y)), this;
  }
  addOutput(z) {
    if (arguments.length > 1 || !z || z.value === void 0 || z.address === void 0 && z.script === void 0)
      throw new Error(
        "Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]"
      );
    checkInputsForPartialSig(this.data.inputs, "addOutput");
    const { address: Y } = z;
    if (typeof Y == "string") {
      const { network: se } = this.opts, ne = (0, address_1.toOutputScript)(Y, se);
      z = Object.assign({}, z, { script: ne });
    }
    (0, bip371_1.checkTaprootOutputFields)(z, z, "addOutput");
    const ie = this.__CACHE;
    return this.data.addOutput(z), ie.__FEE = void 0, ie.__FEE_RATE = void 0, ie.__EXTRACTED_TX = void 0, this;
  }
  extractTransaction(z) {
    if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
    const Y = this.__CACHE;
    if (z || checkFees(this, Y, this.opts), Y.__EXTRACTED_TX) return Y.__EXTRACTED_TX;
    const ie = Y.__TX.clone();
    return inputFinalizeGetAmts(this.data.inputs, ie, Y, !0), ie;
  }
  getFeeRate() {
    return getTxCacheValue(
      "__FEE_RATE",
      "fee rate",
      this.data.inputs,
      this.__CACHE
    );
  }
  getFee() {
    return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
  }
  finalizeAllInputs() {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).forEach((z) => this.finalizeInput(z)), this;
  }
  finalizeInput(z, Y) {
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(ie) ? this._finalizeTaprootInput(
      z,
      ie,
      void 0,
      Y
    ) : this._finalizeInput(z, ie, Y);
  }
  finalizeTaprootInput(z, Y, ie = bip371_1.tapScriptFinalizer) {
    const se = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(se))
      return this._finalizeTaprootInput(
        z,
        se,
        Y,
        ie
      );
    throw new Error(`Cannot finalize input #${z}. Not Taproot.`);
  }
  _finalizeInput(z, Y, ie = getFinalScripts) {
    const { script: se, isP2SH: ne, isP2WSH: ae, isSegwit: le } = getScriptFromInput(
      z,
      Y,
      this.__CACHE
    );
    if (!se) throw new Error(`No script found for input #${z}`);
    checkPartialSigSighashes(Y);
    const { finalScriptSig: ge, finalScriptWitness: Ee } = ie(
      z,
      Y,
      se,
      le,
      ne,
      ae
    );
    if (ge && this.data.updateInput(z, { finalScriptSig: ge }), Ee && this.data.updateInput(z, { finalScriptWitness: Ee }), !ge && !Ee)
      throw new Error(`Unknown error finalizing input #${z}`);
    return this.data.clearFinalizedInput(z), this;
  }
  _finalizeTaprootInput(z, Y, ie, se = bip371_1.tapScriptFinalizer) {
    if (!Y.witnessUtxo)
      throw new Error(
        `Cannot finalize input #${z}. Missing withness utxo.`
      );
    if (Y.tapKeySig) {
      const ne = payments.p2tr({
        output: Y.witnessUtxo.script,
        signature: Y.tapKeySig
      }), ae = (0, psbtutils_1.witnessStackToScriptWitness)(
        ne.witness
      );
      this.data.updateInput(z, { finalScriptWitness: ae });
    } else {
      const { finalScriptWitness: ne } = se(
        z,
        Y,
        ie
      );
      this.data.updateInput(z, { finalScriptWitness: ne });
    }
    return this.data.clearFinalizedInput(z), this;
  }
  getInputType(z) {
    const Y = (0, utils_1.checkForInput)(this.data.inputs, z), ie = getScriptFromUtxo(z, Y, this.__CACHE), se = getMeaningfulScript(
      ie,
      z,
      "input",
      Y.redeemScript || redeemFromFinalScriptSig(Y.finalScriptSig),
      Y.witnessScript || redeemFromFinalWitnessScript(Y.finalScriptWitness)
    ), ne = se.type === "raw" ? "" : se.type + "-", ae = classifyScript(se.meaningfulScript);
    return ne + ae;
  }
  inputHasPubkey(z, Y) {
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z);
    return pubkeyInInput(Y, ie, z, this.__CACHE);
  }
  inputHasHDKey(z, Y) {
    const ie = (0, utils_1.checkForInput)(this.data.inputs, z), se = bip32DerivationIsMine(Y);
    return !!ie.bip32Derivation && ie.bip32Derivation.some(se);
  }
  outputHasPubkey(z, Y) {
    const ie = (0, utils_1.checkForOutput)(this.data.outputs, z);
    return pubkeyInOutput(Y, ie, z, this.__CACHE);
  }
  outputHasHDKey(z, Y) {
    const ie = (0, utils_1.checkForOutput)(this.data.outputs, z), se = bip32DerivationIsMine(Y);
    return !!ie.bip32Derivation && ie.bip32Derivation.some(se);
  }
  validateSignaturesOfAllInputs(z) {
    return (0, utils_1.checkForInput)(this.data.inputs, 0), range(this.data.inputs.length).map(
      (ie) => this.validateSignaturesOfInput(ie, z)
    ).reduce((ie, se) => se === !0 && ie, !0);
  }
  validateSignaturesOfInput(z, Y, ie) {
    const se = this.data.inputs[z];
    return (0, bip371_1.isTaprootInput)(se) ? this.validateSignaturesOfTaprootInput(
      z,
      Y,
      ie
    ) : this._validateSignaturesOfInput(z, Y, ie);
  }
  _validateSignaturesOfInput(z, Y, ie) {
    const se = this.data.inputs[z], ne = (se || {}).partialSig;
    if (!se || !ne || ne.length < 1)
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    const ae = ie ? ne.filter((Pe) => Pe.pubkey.equals(ie)) : ne;
    if (ae.length < 1) throw new Error("No signatures for this pubkey");
    const le = [];
    let ge, Ee, oe;
    for (const Pe of ae) {
      const Ve = bscript.signature.decode(Pe.signature), { hash: Ke, script: ht } = oe !== Ve.hashType ? getHashForSig(
        z,
        Object.assign({}, se, { sighashType: Ve.hashType }),
        this.__CACHE,
        !0
      ) : { hash: ge, script: Ee };
      oe = Ve.hashType, ge = Ke, Ee = ht, checkScriptForPubkey(Pe.pubkey, ht, "verify"), le.push(Y(Pe.pubkey, Ke, Ve.signature));
    }
    return le.every((Pe) => Pe === !0);
  }
  validateSignaturesOfTaprootInput(z, Y, ie) {
    const se = this.data.inputs[z], ne = (se || {}).tapKeySig, ae = (se || {}).tapScriptSig;
    if (!se && !ne && !(ae && !ae.length))
      throw new Error("No signatures to validate");
    if (typeof Y != "function")
      throw new Error("Need validator function to validate signatures");
    ie = ie && (0, bip371_1.toXOnly)(ie);
    const le = ie ? getTaprootHashesForSig(
      z,
      se,
      this.data.inputs,
      ie,
      this.__CACHE
    ) : getAllTaprootHashesForSig(
      z,
      se,
      this.data.inputs,
      this.__CACHE
    );
    if (!le.length) throw new Error("No signatures for this pubkey");
    const ge = le.find((oe) => !oe.leafHash);
    let Ee = 0;
    if (ne && ge) {
      if (!Y(
        ge.pubkey,
        ge.hash,
        trimTaprootSig(ne)
      )) return !1;
      Ee++;
    }
    if (ae)
      for (const oe of ae) {
        const Pe = le.find((Ve) => oe.pubkey.equals(Ve.pubkey));
        if (Pe) {
          if (!Y(
            oe.pubkey,
            Pe.hash,
            trimTaprootSig(oe.signature)
          )) return !1;
          Ee++;
        }
      }
    return Ee > 0;
  }
  signAllInputsHD(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!z || !z.publicKey || !z.fingerprint)
      throw new Error("Need HDSigner to sign input");
    const ie = [];
    for (const se of range(this.data.inputs.length))
      try {
        this.signInputHD(se, z, Y), ie.push(!0);
      } catch {
        ie.push(!1);
      }
    if (ie.every((se) => se === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsHDAsync(z, Y = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((ie, se) => {
      if (!z || !z.publicKey || !z.fingerprint)
        return se(new Error("Need HDSigner to sign input"));
      const ne = [], ae = [];
      for (const le of range(this.data.inputs.length))
        ae.push(
          this.signInputHDAsync(le, z, Y).then(
            () => {
              ne.push(!0);
            },
            () => {
              ne.push(!1);
            }
          )
        );
      return Promise.all(ae).then(() => {
        if (ne.every((le) => le === !1))
          return se(new Error("No inputs were signed"));
        ie();
      });
    });
  }
  signInputHD(z, Y, ie = [transaction_1.Transaction.SIGHASH_ALL]) {
    if (!Y || !Y.publicKey || !Y.fingerprint)
      throw new Error("Need HDSigner to sign input");
    return getSignersFromHD(z, this.data.inputs, Y).forEach((ne) => this.signInput(z, ne, ie)), this;
  }
  signInputHDAsync(z, Y, ie = [transaction_1.Transaction.SIGHASH_ALL]) {
    return new Promise((se, ne) => {
      if (!Y || !Y.publicKey || !Y.fingerprint)
        return ne(new Error("Need HDSigner to sign input"));
      const le = getSignersFromHD(z, this.data.inputs, Y).map(
        (ge) => this.signInputAsync(z, ge, ie)
      );
      return Promise.all(le).then(() => {
        se();
      }).catch(ne);
    });
  }
  signAllInputs(z, Y) {
    if (!z || !z.publicKey)
      throw new Error("Need Signer to sign input");
    const ie = [];
    for (const se of range(this.data.inputs.length))
      try {
        this.signInput(se, z, Y), ie.push(!0);
      } catch {
        ie.push(!1);
      }
    if (ie.every((se) => se === !1))
      throw new Error("No inputs were signed");
    return this;
  }
  signAllInputsAsync(z, Y) {
    return new Promise((ie, se) => {
      if (!z || !z.publicKey)
        return se(new Error("Need Signer to sign input"));
      const ne = [], ae = [];
      for (const [le] of this.data.inputs.entries())
        ae.push(
          this.signInputAsync(le, z, Y).then(
            () => {
              ne.push(!0);
            },
            () => {
              ne.push(!1);
            }
          )
        );
      return Promise.all(ae).then(() => {
        if (ne.every((le) => le === !1))
          return se(new Error("No inputs were signed"));
        ie();
      });
    });
  }
  signInput(z, Y, ie) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const se = (0, utils_1.checkForInput)(this.data.inputs, z);
    return (0, bip371_1.isTaprootInput)(se) ? this._signTaprootInput(
      z,
      se,
      Y,
      void 0,
      ie
    ) : this._signInput(z, Y, ie);
  }
  signTaprootInput(z, Y, ie, se) {
    if (!Y || !Y.publicKey)
      throw new Error("Need Signer to sign input");
    const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
    if ((0, bip371_1.isTaprootInput)(ne))
      return this._signTaprootInput(
        z,
        ne,
        Y,
        ie,
        se
      );
    throw new Error(`Input #${z} is not of type Taproot.`);
  }
  _signInput(z, Y, ie = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: se, sighashType: ne } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ie
    ), ae = [
      {
        pubkey: Y.publicKey,
        signature: bscript.signature.encode(Y.sign(se), ne)
      }
    ];
    return this.data.updateInput(z, { partialSig: ae }), this;
  }
  _signTaprootInput(z, Y, ie, se, ne = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const ae = this.checkTaprootHashesForSig(
      z,
      Y,
      ie,
      se,
      ne
    ), le = ae.filter((Ee) => !Ee.leafHash).map(
      (Ee) => (0, bip371_1.serializeTaprootSignature)(
        ie.signSchnorr(Ee.hash),
        Y.sighashType
      )
    )[0], ge = ae.filter((Ee) => !!Ee.leafHash).map((Ee) => ({
      pubkey: (0, bip371_1.toXOnly)(ie.publicKey),
      signature: (0, bip371_1.serializeTaprootSignature)(
        ie.signSchnorr(Ee.hash),
        Y.sighashType
      ),
      leafHash: Ee.leafHash
    }));
    return le && this.data.updateInput(z, { tapKeySig: le }), ge.length && this.data.updateInput(z, { tapScriptSig: ge }), this;
  }
  signInputAsync(z, Y, ie) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const se = (0, utils_1.checkForInput)(this.data.inputs, z);
      return (0, bip371_1.isTaprootInput)(se) ? this._signTaprootInputAsync(
        z,
        se,
        Y,
        void 0,
        ie
      ) : this._signInputAsync(z, Y, ie);
    });
  }
  signTaprootInputAsync(z, Y, ie, se) {
    return Promise.resolve().then(() => {
      if (!Y || !Y.publicKey)
        throw new Error("Need Signer to sign input");
      const ne = (0, utils_1.checkForInput)(this.data.inputs, z);
      if ((0, bip371_1.isTaprootInput)(ne))
        return this._signTaprootInputAsync(
          z,
          ne,
          Y,
          ie,
          se
        );
      throw new Error(`Input #${z} is not of type Taproot.`);
    });
  }
  _signInputAsync(z, Y, ie = [transaction_1.Transaction.SIGHASH_ALL]) {
    const { hash: se, sighashType: ne } = getHashAndSighashType(
      this.data.inputs,
      z,
      Y.publicKey,
      this.__CACHE,
      ie
    );
    return Promise.resolve(Y.sign(se)).then((ae) => {
      const le = [
        {
          pubkey: Y.publicKey,
          signature: bscript.signature.encode(ae, ne)
        }
      ];
      this.data.updateInput(z, { partialSig: le });
    });
  }
  async _signTaprootInputAsync(z, Y, ie, se, ne = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
    const ae = this.checkTaprootHashesForSig(
      z,
      Y,
      ie,
      se,
      ne
    ), le = [], ge = ae.filter((oe) => !oe.leafHash)[0];
    if (ge) {
      const oe = Promise.resolve(
        ie.signSchnorr(ge.hash)
      ).then((Pe) => ({
        tapKeySig: (0, bip371_1.serializeTaprootSignature)(
          Pe,
          Y.sighashType
        )
      }));
      le.push(oe);
    }
    const Ee = ae.filter((oe) => !!oe.leafHash);
    if (Ee.length) {
      const oe = Ee.map((Pe) => Promise.resolve(ie.signSchnorr(Pe.hash)).then(
        (Ve) => ({ tapScriptSig: [
          {
            pubkey: (0, bip371_1.toXOnly)(ie.publicKey),
            signature: (0, bip371_1.serializeTaprootSignature)(
              Ve,
              Y.sighashType
            ),
            leafHash: Pe.leafHash
          }
        ] })
      ));
      le.push(...oe);
    }
    return Promise.all(le).then((oe) => {
      oe.forEach((Pe) => this.data.updateInput(z, Pe));
    });
  }
  checkTaprootHashesForSig(z, Y, ie, se, ne) {
    if (typeof ie.signSchnorr != "function")
      throw new Error(
        `Need Schnorr Signer to sign taproot input #${z}.`
      );
    const ae = getTaprootHashesForSig(
      z,
      Y,
      this.data.inputs,
      ie.publicKey,
      this.__CACHE,
      se,
      ne
    );
    if (!ae || !ae.length)
      throw new Error(
        `Can not sign for input #${z} with the key ${ie.publicKey.toString(
          "hex"
        )}`
      );
    return ae;
  }
  toBuffer() {
    return checkCache(this.__CACHE), this.data.toBuffer();
  }
  toHex() {
    return checkCache(this.__CACHE), this.data.toHex();
  }
  toBase64() {
    return checkCache(this.__CACHE), this.data.toBase64();
  }
  updateGlobal(z) {
    return this.data.updateGlobal(z), this;
  }
  updateInput(z, Y) {
    return Y.witnessScript && checkInvalidP2WSH(Y.witnessScript), (0, bip371_1.checkTaprootInputFields)(
      this.data.inputs[z],
      Y,
      "updateInput"
    ), this.data.updateInput(z, Y), Y.nonWitnessUtxo && addNonWitnessTxCache(
      this.__CACHE,
      this.data.inputs[z],
      z
    ), this;
  }
  updateOutput(z, Y) {
    const ie = this.data.outputs[z];
    return (0, bip371_1.checkTaprootOutputFields)(
      ie,
      Y,
      "updateOutput"
    ), this.data.updateOutput(z, Y), this;
  }
  addUnknownKeyValToGlobal(z) {
    return this.data.addUnknownKeyValToGlobal(z), this;
  }
  addUnknownKeyValToInput(z, Y) {
    return this.data.addUnknownKeyValToInput(z, Y), this;
  }
  addUnknownKeyValToOutput(z, Y) {
    return this.data.addUnknownKeyValToOutput(z, Y), this;
  }
  clearFinalizedInput(z) {
    return this.data.clearFinalizedInput(z), this;
  }
}
psbt$1.Psbt = Psbt;
const transactionFromBuffer = (B) => new PsbtTransaction(B);
class PsbtTransaction {
  constructor(z = Buffer$1.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
    this.tx = transaction_1.Transaction.fromBuffer(z), checkTxEmpty(this.tx), Object.defineProperty(this, "tx", {
      enumerable: !1,
      writable: !0
    });
  }
  getInputOutputCounts() {
    return {
      inputCount: this.tx.ins.length,
      outputCount: this.tx.outs.length
    };
  }
  addInput(z) {
    if (z.hash === void 0 || z.index === void 0 || !Buffer$1.isBuffer(z.hash) && typeof z.hash != "string" || typeof z.index != "number")
      throw new Error("Error adding input.");
    const Y = typeof z.hash == "string" ? (0, bufferutils_1.reverseBuffer)(Buffer$1.from(z.hash, "hex")) : z.hash;
    this.tx.addInput(Y, z.index, z.sequence);
  }
  addOutput(z) {
    if (z.script === void 0 || z.value === void 0 || !Buffer$1.isBuffer(z.script) || typeof z.value != "number")
      throw new Error("Error adding output.");
    this.tx.addOutput(z.script, z.value);
  }
  toBuffer() {
    return this.tx.toBuffer();
  }
}
function canFinalize(B, z, Y) {
  switch (Y) {
    case "pubkey":
    case "pubkeyhash":
    case "witnesspubkeyhash":
      return hasSigs(1, B.partialSig);
    case "multisig":
      const ie = payments.p2ms({ output: z });
      return hasSigs(ie.m, B.partialSig, ie.pubkeys);
    default:
      return !1;
  }
}
function checkCache(B) {
  if (B.__UNSAFE_SIGN_NONSEGWIT !== !1)
    throw new Error("Not BIP174 compliant, can not export");
}
function hasSigs(B, z, Y) {
  if (!z) return !1;
  let ie;
  if (Y ? ie = Y.map((se) => {
    const ne = compressPubkey(se);
    return z.find((ae) => ae.pubkey.equals(ne));
  }).filter((se) => !!se) : ie = z, ie.length > B) throw new Error("Too many signatures");
  return ie.length === B;
}
function isFinalized(B) {
  return !!B.finalScriptSig || !!B.finalScriptWitness;
}
function bip32DerivationIsMine(B) {
  return (z) => !(!z.masterFingerprint.equals(B.fingerprint) || !B.derivePath(z.path).publicKey.equals(z.pubkey));
}
function check32Bit(B) {
  if (typeof B != "number" || B !== Math.floor(B) || B > 4294967295 || B < 0)
    throw new Error("Invalid 32 bit integer");
}
function checkFees(B, z, Y) {
  const ie = z.__FEE_RATE || B.getFeeRate(), se = z.__EXTRACTED_TX.virtualSize(), ne = ie * se;
  if (ie >= Y.maximumFeeRate)
    throw new Error(
      `Warning: You are paying around ${(ne / 1e8).toFixed(8)} in fees, which is ${ie} satoshi per byte for a transaction with a VSize of ${se} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
    );
}
function checkInputsForPartialSig(B, z) {
  B.forEach((Y) => {
    if ((0, bip371_1.isTaprootInput)(Y) ? (0, bip371_1.checkTaprootInputForSigs)(Y, z) : (0, psbtutils_1.checkInputForSig)(Y, z))
      throw new Error("Can not modify transaction, signatures exist.");
  });
}
function checkPartialSigSighashes(B) {
  if (!B.sighashType || !B.partialSig) return;
  const { partialSig: z, sighashType: Y } = B;
  z.forEach((ie) => {
    const { hashType: se } = bscript.signature.decode(ie.signature);
    if (Y !== se)
      throw new Error("Signature sighash does not match input sighash type");
  });
}
function checkScriptForPubkey(B, z, Y) {
  if (!(0, psbtutils_1.pubkeyInScript)(B, z))
    throw new Error(
      `Can not ${Y} for this input with the key ${B.toString("hex")}`
    );
}
function checkTxEmpty(B) {
  if (!B.ins.every(
    (Y) => Y.script && Y.script.length === 0 && Y.witness && Y.witness.length === 0
  ))
    throw new Error("Format Error: Transaction ScriptSigs are not empty");
}
function checkTxForDupeIns(B, z) {
  B.ins.forEach((Y) => {
    checkTxInputCache(z, Y);
  });
}
function checkTxInputCache(B, z) {
  const Y = (0, bufferutils_1.reverseBuffer)(Buffer$1.from(z.hash)).toString("hex") + ":" + z.index;
  if (B.__TX_IN_CACHE[Y]) throw new Error("Duplicate input detected.");
  B.__TX_IN_CACHE[Y] = 1;
}
function scriptCheckerFactory(B, z) {
  return (Y, ie, se, ne) => {
    const ae = B({
      redeem: { output: se }
    }).output;
    if (!ie.equals(ae))
      throw new Error(
        `${z} for ${ne} #${Y} doesn't match the scriptPubKey in the prevout`
      );
  };
}
const checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script"), checkWitnessScript = scriptCheckerFactory(
  payments.p2wsh,
  "Witness script"
);
function getTxCacheValue(B, z, Y, ie) {
  if (!Y.every(isFinalized))
    throw new Error(`PSBT must be finalized to calculate ${z}`);
  if (B === "__FEE_RATE" && ie.__FEE_RATE) return ie.__FEE_RATE;
  if (B === "__FEE" && ie.__FEE) return ie.__FEE;
  let se, ne = !0;
  if (ie.__EXTRACTED_TX ? (se = ie.__EXTRACTED_TX, ne = !1) : se = ie.__TX.clone(), inputFinalizeGetAmts(Y, se, ie, ne), B === "__FEE_RATE") return ie.__FEE_RATE;
  if (B === "__FEE") return ie.__FEE;
}
function getFinalScripts(B, z, Y, ie, se, ne) {
  const ae = classifyScript(Y);
  if (!canFinalize(z, Y, ae))
    throw new Error(`Can not finalize input #${B}`);
  return prepareFinalScripts(
    Y,
    ae,
    z.partialSig,
    ie,
    se,
    ne
  );
}
function prepareFinalScripts(B, z, Y, ie, se, ne) {
  let ae, le;
  const ge = getPayment(B, z, Y), Ee = ne ? payments.p2wsh({ redeem: ge }) : null, oe = se ? payments.p2sh({ redeem: Ee || ge }) : null;
  return ie ? (Ee ? le = (0, psbtutils_1.witnessStackToScriptWitness)(
    Ee.witness
  ) : le = (0, psbtutils_1.witnessStackToScriptWitness)(
    ge.witness
  ), oe && (ae = oe.input)) : oe ? ae = oe.input : ae = ge.input, {
    finalScriptSig: ae,
    finalScriptWitness: le
  };
}
function getHashAndSighashType(B, z, Y, ie, se) {
  const ne = (0, utils_1.checkForInput)(B, z), { hash: ae, sighashType: le, script: ge } = getHashForSig(
    z,
    ne,
    ie,
    !1,
    se
  );
  return checkScriptForPubkey(Y, ge, "sign"), {
    hash: ae,
    sighashType: le
  };
}
function getHashForSig(B, z, Y, ie, se) {
  const ne = Y.__TX, ae = z.sighashType || transaction_1.Transaction.SIGHASH_ALL;
  checkSighashTypeAllowed(ae, se);
  let le, ge;
  if (z.nonWitnessUtxo) {
    const Pe = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), Ve = ne.ins[B].hash, Ke = Pe.getHash();
    if (!Ve.equals(Ke))
      throw new Error(
        `Non-witness UTXO hash for input #${B} doesn't match the hash specified in the prevout`
      );
    const ht = ne.ins[B].index;
    ge = Pe.outs[ht];
  } else if (z.witnessUtxo)
    ge = z.witnessUtxo;
  else
    throw new Error("Need a Utxo input item for signing");
  const { meaningfulScript: Ee, type: oe } = getMeaningfulScript(
    ge.script,
    B,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  if (["p2sh-p2wsh", "p2wsh"].indexOf(oe) >= 0)
    le = ne.hashForWitnessV0(
      B,
      Ee,
      ge.value,
      ae
    );
  else if ((0, psbtutils_1.isP2WPKH)(Ee)) {
    const Pe = payments.p2pkh({
      hash: Ee.slice(2)
    }).output;
    le = ne.hashForWitnessV0(
      B,
      Pe,
      ge.value,
      ae
    );
  } else {
    if (z.nonWitnessUtxo === void 0 && Y.__UNSAFE_SIGN_NONSEGWIT === !1)
      throw new Error(
        `Input #${B} has witnessUtxo but non-segwit script: ${Ee.toString("hex")}`
      );
    !ie && Y.__UNSAFE_SIGN_NONSEGWIT !== !1 && console.warn(
      `Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.
*********************
PROCEED WITH CAUTION!
*********************`
    ), le = ne.hashForSignature(
      B,
      Ee,
      ae
    );
  }
  return {
    script: Ee,
    sighashType: ae,
    hash: le
  };
}
function getAllTaprootHashesForSig(B, z, Y, ie) {
  const se = [];
  if (z.tapInternalKey) {
    const ae = getPrevoutTaprootKey(B, z, ie);
    ae && se.push(ae);
  }
  if (z.tapScriptSig) {
    const ae = z.tapScriptSig.map((le) => le.pubkey);
    se.push(...ae);
  }
  return se.map(
    (ae) => getTaprootHashesForSig(B, z, Y, ae, ie)
  ).flat();
}
function getPrevoutTaprootKey(B, z, Y) {
  const { script: ie } = getScriptAndAmountFromUtxo(B, z, Y);
  return (0, psbtutils_1.isP2TR)(ie) ? ie.subarray(2, 34) : null;
}
function trimTaprootSig(B) {
  return B.length === 64 ? B : B.subarray(0, 64);
}
function getTaprootHashesForSig(B, z, Y, ie, se, ne, ae) {
  const le = se.__TX, ge = z.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
  checkSighashTypeAllowed(ge, ae);
  const Ee = Y.map(
    (ht, _t) => getScriptAndAmountFromUtxo(_t, ht, se)
  ), oe = Ee.map((ht) => ht.script), Pe = Ee.map((ht) => ht.value), Ve = [];
  if (z.tapInternalKey && !ne) {
    const ht = getPrevoutTaprootKey(B, z, se) || Buffer$1.from([]);
    if ((0, bip371_1.toXOnly)(ie).equals(ht)) {
      const _t = le.hashForWitnessV1(
        B,
        oe,
        Pe,
        ge
      );
      Ve.push({ pubkey: ie, hash: _t });
    }
  }
  const Ke = (z.tapLeafScript || []).filter((ht) => (0, psbtutils_1.pubkeyInScript)(ie, ht.script)).map((ht) => {
    const _t = (0, bip341_1.tapleafHash)({
      output: ht.script,
      version: ht.leafVersion
    });
    return Object.assign({ hash: _t }, ht);
  }).filter(
    (ht) => !ne || ne.equals(ht.hash)
  ).map((ht) => {
    const _t = le.hashForWitnessV1(
      B,
      oe,
      Pe,
      ge,
      ht.hash
    );
    return {
      pubkey: ie,
      hash: _t,
      leafHash: ht.hash
    };
  });
  return Ve.concat(Ke);
}
function checkSighashTypeAllowed(B, z) {
  if (z && z.indexOf(B) < 0) {
    const Y = sighashTypeToString(B);
    throw new Error(
      `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${Y}`
    );
  }
}
function getPayment(B, z, Y) {
  let ie;
  switch (z) {
    case "multisig":
      const se = getSortedSigs(B, Y);
      ie = payments.p2ms({
        output: B,
        signatures: se
      });
      break;
    case "pubkey":
      ie = payments.p2pk({
        output: B,
        signature: Y[0].signature
      });
      break;
    case "pubkeyhash":
      ie = payments.p2pkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
    case "witnesspubkeyhash":
      ie = payments.p2wpkh({
        output: B,
        pubkey: Y[0].pubkey,
        signature: Y[0].signature
      });
      break;
  }
  return ie;
}
function getScriptFromInput(B, z, Y) {
  const ie = Y.__TX, se = {
    script: null,
    isSegwit: !1,
    isP2SH: !1,
    isP2WSH: !1
  };
  if (se.isP2SH = !!z.redeemScript, se.isP2WSH = !!z.witnessScript, z.witnessScript)
    se.script = z.witnessScript;
  else if (z.redeemScript)
    se.script = z.redeemScript;
  else if (z.nonWitnessUtxo) {
    const ne = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ), ae = ie.ins[B].index;
    se.script = ne.outs[ae].script;
  } else z.witnessUtxo && (se.script = z.witnessUtxo.script);
  return (z.witnessScript || (0, psbtutils_1.isP2WPKH)(se.script)) && (se.isSegwit = !0), se;
}
function getSignersFromHD(B, z, Y) {
  const ie = (0, utils_1.checkForInput)(z, B);
  if (!ie.bip32Derivation || ie.bip32Derivation.length === 0)
    throw new Error("Need bip32Derivation to sign with HD");
  const se = ie.bip32Derivation.map((ae) => {
    if (ae.masterFingerprint.equals(Y.fingerprint))
      return ae;
  }).filter((ae) => !!ae);
  if (se.length === 0)
    throw new Error(
      "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
    );
  return se.map((ae) => {
    const le = Y.derivePath(ae.path);
    if (!ae.pubkey.equals(le.publicKey))
      throw new Error("pubkey did not match bip32Derivation");
    return le;
  });
}
function getSortedSigs(B, z) {
  return payments.p2ms({ output: B }).pubkeys.map((ie) => (z.filter((se) => se.pubkey.equals(ie))[0] || {}).signature).filter((ie) => !!ie);
}
function scriptWitnessToWitnessStack(B) {
  let z = 0;
  function Y(ae) {
    return z += ae, B.slice(z - ae, z);
  }
  function ie() {
    const ae = varuint.decode(B, z);
    return z += varuint.decode.bytes, ae;
  }
  function se() {
    return Y(ie());
  }
  function ne() {
    const ae = ie(), le = [];
    for (let ge = 0; ge < ae; ge++) le.push(se());
    return le;
  }
  return ne();
}
function sighashTypeToString(B) {
  let z = B & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
  switch (B & 31) {
    case transaction_1.Transaction.SIGHASH_ALL:
      z += "SIGHASH_ALL";
      break;
    case transaction_1.Transaction.SIGHASH_SINGLE:
      z += "SIGHASH_SINGLE";
      break;
    case transaction_1.Transaction.SIGHASH_NONE:
      z += "SIGHASH_NONE";
      break;
  }
  return z;
}
function addNonWitnessTxCache(B, z, Y) {
  B.__NON_WITNESS_UTXO_BUF_CACHE[Y] = z.nonWitnessUtxo;
  const ie = transaction_1.Transaction.fromBuffer(z.nonWitnessUtxo);
  B.__NON_WITNESS_UTXO_TX_CACHE[Y] = ie;
  const se = B, ne = Y;
  delete z.nonWitnessUtxo, Object.defineProperty(z, "nonWitnessUtxo", {
    enumerable: !0,
    get() {
      const ae = se.__NON_WITNESS_UTXO_BUF_CACHE[ne], le = se.__NON_WITNESS_UTXO_TX_CACHE[ne];
      if (ae !== void 0)
        return ae;
      {
        const ge = le.toBuffer();
        return se.__NON_WITNESS_UTXO_BUF_CACHE[ne] = ge, ge;
      }
    },
    set(ae) {
      se.__NON_WITNESS_UTXO_BUF_CACHE[ne] = ae;
    }
  });
}
function inputFinalizeGetAmts(B, z, Y, ie) {
  let se = 0;
  B.forEach((ge, Ee) => {
    if (ie && ge.finalScriptSig && (z.ins[Ee].script = ge.finalScriptSig), ie && ge.finalScriptWitness && (z.ins[Ee].witness = scriptWitnessToWitnessStack(
      ge.finalScriptWitness
    )), ge.witnessUtxo)
      se += ge.witnessUtxo.value;
    else if (ge.nonWitnessUtxo) {
      const oe = nonWitnessUtxoTxFromCache(Y, ge, Ee), Pe = z.ins[Ee].index, Ve = oe.outs[Pe];
      se += Ve.value;
    }
  });
  const ne = z.outs.reduce((ge, Ee) => ge + Ee.value, 0), ae = se - ne;
  if (ae < 0)
    throw new Error("Outputs are spending more than Inputs");
  const le = z.virtualSize();
  Y.__FEE = ae, Y.__EXTRACTED_TX = z, Y.__FEE_RATE = Math.floor(ae / le);
}
function nonWitnessUtxoTxFromCache(B, z, Y) {
  const ie = B.__NON_WITNESS_UTXO_TX_CACHE;
  return ie[Y] || addNonWitnessTxCache(B, z, Y), ie[Y];
}
function getScriptFromUtxo(B, z, Y) {
  const { script: ie } = getScriptAndAmountFromUtxo(B, z, Y);
  return ie;
}
function getScriptAndAmountFromUtxo(B, z, Y) {
  if (z.witnessUtxo !== void 0)
    return {
      script: z.witnessUtxo.script,
      value: z.witnessUtxo.value
    };
  if (z.nonWitnessUtxo !== void 0) {
    const se = nonWitnessUtxoTxFromCache(
      Y,
      z,
      B
    ).outs[Y.__TX.ins[B].index];
    return { script: se.script, value: se.value };
  } else
    throw new Error("Can't find pubkey in input without Utxo data");
}
function pubkeyInInput(B, z, Y, ie) {
  const se = getScriptFromUtxo(Y, z, ie), { meaningfulScript: ne } = getMeaningfulScript(
    se,
    Y,
    "input",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ne);
}
function pubkeyInOutput(B, z, Y, ie) {
  const se = ie.__TX.outs[Y].script, { meaningfulScript: ne } = getMeaningfulScript(
    se,
    Y,
    "output",
    z.redeemScript,
    z.witnessScript
  );
  return (0, psbtutils_1.pubkeyInScript)(B, ne);
}
function redeemFromFinalScriptSig(B) {
  if (!B) return;
  const z = bscript.decompile(B);
  if (!z) return;
  const Y = z[z.length - 1];
  if (!(!Buffer$1.isBuffer(Y) || isPubkeyLike(Y) || isSigLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function redeemFromFinalWitnessScript(B) {
  if (!B) return;
  const z = scriptWitnessToWitnessStack(B), Y = z[z.length - 1];
  if (!(isPubkeyLike(Y) || !bscript.decompile(Y)))
    return Y;
}
function compressPubkey(B) {
  if (B.length === 65) {
    const z = B[64] & 1, Y = B.slice(0, 33);
    return Y[0] = 2 | z, Y;
  }
  return B.slice();
}
function isPubkeyLike(B) {
  return B.length === 33 && bscript.isCanonicalPubKey(B);
}
function isSigLike(B) {
  return bscript.isCanonicalScriptSignature(B);
}
function getMeaningfulScript(B, z, Y, ie, se) {
  const ne = (0, psbtutils_1.isP2SHScript)(B), ae = ne && ie && (0, psbtutils_1.isP2WSHScript)(ie), le = (0, psbtutils_1.isP2WSHScript)(B);
  if (ne && ie === void 0)
    throw new Error("scriptPubkey is P2SH but redeemScript missing");
  if ((le || ae) && se === void 0)
    throw new Error(
      "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
    );
  let ge;
  return ae ? (ge = se, checkRedeemScript(z, B, ie, Y), checkWitnessScript(z, ie, se, Y), checkInvalidP2WSH(ge)) : le ? (ge = se, checkWitnessScript(z, B, se, Y), checkInvalidP2WSH(ge)) : ne ? (ge = ie, checkRedeemScript(z, B, ie, Y)) : ge = B, {
    meaningfulScript: ge,
    type: ae ? "p2sh-p2wsh" : ne ? "p2sh" : le ? "p2wsh" : "raw"
  };
}
function checkInvalidP2WSH(B) {
  if ((0, psbtutils_1.isP2WPKH)(B) || (0, psbtutils_1.isP2SHScript)(B))
    throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
}
function classifyScript(B) {
  return (0, psbtutils_1.isP2WPKH)(B) ? "witnesspubkeyhash" : (0, psbtutils_1.isP2PKH)(B) ? "pubkeyhash" : (0, psbtutils_1.isP2MS)(B) ? "multisig" : (0, psbtutils_1.isP2PK)(B) ? "pubkey" : "nonstandard";
}
function range(B) {
  return [...Array(B).keys()];
}
(function(B) {
  Object.defineProperty(B, "__esModule", { value: !0 }), B.initEccLib = B.Transaction = B.opcodes = B.Psbt = B.Block = B.script = B.payments = B.networks = B.crypto = B.address = void 0;
  const z = requireAddress();
  B.address = z;
  const Y = crypto$1;
  B.crypto = Y;
  const ie = networks;
  B.networks = ie;
  const se = requirePayments();
  B.payments = se;
  const ne = requireScript();
  B.script = ne;
  var ae = block;
  Object.defineProperty(B, "Block", {
    enumerable: !0,
    get: function() {
      return ae.Block;
    }
  });
  var le = psbt$1;
  Object.defineProperty(B, "Psbt", {
    enumerable: !0,
    get: function() {
      return le.Psbt;
    }
  });
  var ge = ops;
  Object.defineProperty(B, "opcodes", {
    enumerable: !0,
    get: function() {
      return ge.OPS;
    }
  });
  var Ee = transaction;
  Object.defineProperty(B, "Transaction", {
    enumerable: !0,
    get: function() {
      return Ee.Transaction;
    }
  });
  var oe = ecc_lib;
  Object.defineProperty(B, "initEccLib", {
    enumerable: !0,
    get: function() {
      return oe.initEccLib;
    }
  });
})(src$1);
function useSign() {
  const { network: B, publicKey: z, format: Y, wallet: ie } = useOrdConnect(), [se, ne] = useState(null), [ae, le] = useState(!1);
  return { sign: useCallback(
    async (Ee, oe, Pe) => {
      le(!0);
      try {
        if (ne(null), !Y || !z || !ie)
          throw new Error("No wallet is connected");
        const Ve = src$1.Psbt.fromBase64(oe), Ke = await signPsbt({
          address: Ee,
          wallet: ie,
          network: B,
          psbt: Ve,
          options: Pe
        });
        return le(!1), Ke;
      } catch (Ve) {
        throw ne(Ve.message), le(!1), Ve;
      }
    },
    [Y, B, z, ie]
  ), error: se, loading: ae };
}
function leatherPaymentTypeFromFormat(B) {
  if (B === "segwit")
    return LeatherAddressType.P2WPKH;
  if (B === "taproot")
    return LeatherAddressType.P2TR;
  throw new Error("Leather payment address format is not supported");
}
async function signXverseMessage(B, z, Y) {
  if (!B || !Y || !z)
    throw new OrditSDKError("Invalid options provided");
  let ie, se = null;
  const ne = await request("signMessage", {
    address: z,
    message: B
  }, "XverseProviders.BitcoinProvider");
  if (console.log("xxxresponse", ne), !ne)
    throw new BrowserWalletSigningError(
      "Failed to sign message using selected wallet"
    );
  if (ne.status === "success")
    ie = Buffer$1.from(ne.result.signature, "base64").toString("hex"), se = ne.result.signature;
  else throw ne.error.code === RpcErrorCode.USER_REJECTION ? new BrowserWalletRequestCancelledByUserError() : new Error("Failed to sign message");
  return { hex: ie, base64: se };
}
async function signMessage({
  message: B,
  wallet: z,
  address: Y,
  network: ie,
  format: se
}) {
  if (z === Wallet.MAGICEDEN) {
    const { base64: ne } = await signMessage$1(B, Y, ie);
    return ne;
  }
  if (z === Wallet.UNISAT) {
    const { base64: ne } = await signMessage$2(B, "bip322-simple");
    return ne;
  }
  if (z === Wallet.XVERSE) {
    const { base64: ne } = await signXverseMessage(B, Y, ie);
    return ne;
  }
  if (z === Wallet.LEATHER) {
    const ne = leatherPaymentTypeFromFormat(se), { base64: ae } = await signMessage$3(B, {
      paymentType: ne,
      network: ie
    });
    return ae;
  }
  if (z === Wallet.OKX) {
    const { base64: ne } = await signMessage$4(B, "bip322-simple", ie);
    return ne;
  }
  throw new Error("Invalid wallet selected");
}
function useSignMessage() {
  const {
    network: B,
    wallet: z,
    publicKey: Y,
    format: ie,
    address: se,
    testnetAddress: ne
  } = useOrdConnect(), [ae, le] = useState(null), [ge, Ee] = useState(!1);
  return { signMsg: useCallback(
    async (Pe, Ve) => {
      Ee(!0);
      try {
        if (le(null), !ie || !Y || !z)
          throw new Error("No wallet is connected");
        const Ke = B === Network.TESTNET || B === "testnet4" ? ne : se;
        if (Ke.ordinals !== Pe && Ke.payments !== Pe)
          throw new Error("Address supplied is not connected address");
        console.log("==>signedAddress", Pe, Ke);
        const ht = await signMessage({
          address: Pe,
          wallet: z,
          message: Ve,
          network: B,
          format: Ke.ordinals === Pe ? ie.ordinals : ie.payments
        });
        return Ee(!1), ht;
      } catch (Ke) {
        throw console.log("==>err", Ke), le(Ke.message), Ee(!1), Ke;
      }
    },
    [ie, B, Y, z, se]
  ), error: ae, isLoading: ge };
}
export {
  Chain,
  Network,
  OrdConnectKit,
  OrdConnectProvider,
  SelectWalletModal,
  Wallet,
  useBalance,
  useOrdConnect,
  useSend,
  useSendV2,
  useSign,
  useSignMessage
};
